<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="0ac236a3ea7a0e9ead5326f9e44c423dc78ebc26" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</source>
          <target state="translated">测试一个字符是否为小写字母。如果一个字符属于Unicode类别Ll,Letter,则该字符被归类为小写字母。小写字母。</target>
        </trans-unit>
        <trans-unit id="91cdaf6d3cfe470a11194162162137ec98b73f57" translate="yes" xml:space="preserve">
          <source>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</source>
          <target state="translated">测试一个字符是否为大写字母。如果一个字符属于Unicode类别Lu,Letter,则该字符被归为大写字母。Uppercase,或 Lt,Letter:大写字母。</target>
        </trans-unit>
        <trans-unit id="45909810023531a635329b57dc9f15acb810e806" translate="yes" xml:space="preserve">
          <source>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</source>
          <target state="translated">测试一个字符是否为空白字符。包括ASCII字符'/t'、'/n'、'/v'、'/f'、'/r'、''、拉丁字母U+0085和Unicode类别Zs中的字符。</target>
        </trans-unit>
        <trans-unit id="b0a4dc18e63052a8e4b050ac6060b42fea1cafaa" translate="yes" xml:space="preserve">
          <source>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</source>
          <target state="translated">测试一个字符是否为数字字符,如果一个字符属于Unicode通用类别Number,即类别代码以'N'开头的字符,则被归为数字字符。如果一个字符属于Unicode通用类别Number,即类别代码以'N'开头的字符,则该字符被归为数字字符。</target>
        </trans-unit>
        <trans-unit id="982f0addad2d0da939982a5caca6283ccb1d7eb4" translate="yes" xml:space="preserve">
          <source>Tests whether a character is printable, including spaces, but not a control character.</source>
          <target state="translated">测试一个字符是否可以打印,包括空格,但不是控制字符。</target>
        </trans-unit>
        <trans-unit id="e49525a9628b3bad0a6106685a8ac5eeac97a7e1" translate="yes" xml:space="preserve">
          <source>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</source>
          <target state="translated">测试是否定义了一个全局变量或对象字段,参数可以是一个模块和一个符号或一个复合对象和字段名(作为符号)或索引。参数可以是一个模块和一个符号,也可以是一个复合对象和字段名(作为符号)或索引。</target>
        </trans-unit>
        <trans-unit id="b292cfab7944ffbf6199920c5349913e95d9eeb7" translate="yes" xml:space="preserve">
          <source>Tests whether variable &lt;code&gt;s&lt;/code&gt; is defined in the current scope.</source>
          <target state="translated">测试变量 &lt;code&gt;s&lt;/code&gt; 是否在当前范围内定义。</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">文本I/O</target>
        </trans-unit>
        <trans-unit id="ea824a563aca9df06f453afa8aed6e59740fd02e" translate="yes" xml:space="preserve">
          <source>Text from external sources, such as quotations from books or websites, can be quoted using &lt;code&gt;&amp;gt;&lt;/code&gt; characters prepended to each line of the quote as follows.</source>
          <target state="translated">可以使用引号各行前面的 &lt;code&gt;&amp;gt;&lt;/code&gt; 字符来引用来自外部来源的文本（例如来自书本或网站的引文），如下所示。</target>
        </trans-unit>
        <trans-unit id="fbe2b75f7fbda9be349dabaf963a9b88611d5493" translate="yes" xml:space="preserve">
          <source>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Here are some of the catch-all method definitions given in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用促销实际上就是所有这些。剩下的只是一个聪明的应用程序，最典型的&amp;ldquo;聪明&amp;rdquo;应用程序是数字运算（如算术运算符 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; )的所有方法的定义。这是&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; 中&lt;/a&gt;给出的一些通用方法定义：</target>
        </trans-unit>
        <trans-unit id="a55180ee0e35250f4a5e86928557c4ebfc2a5b49" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;fdot(x)&lt;/code&gt; is ten times faster and allocates 1/6 the memory of &lt;code&gt;f(x)&lt;/code&gt;, because each &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operation in &lt;code&gt;f(x)&lt;/code&gt; allocates a new temporary array and executes in a separate loop. (Of course, if you just do &lt;code&gt;f.(x)&lt;/code&gt; then it is as fast as &lt;code&gt;fdot(x)&lt;/code&gt; in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)</source>
          <target state="translated">即， &lt;code&gt;fdot(x)&lt;/code&gt; 是快十倍和分配1/6的存储器 &lt;code&gt;f(x)&lt;/code&gt; ，因为每个 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 在操作 &lt;code&gt;f(x)&lt;/code&gt; 分配在一个单独的循环一个新的临时数组和执行。（当然，如果您只做 &lt;code&gt;f.(x)&lt;/code&gt; 那么它在本例中就和 &lt;code&gt;fdot(x)&lt;/code&gt; 一样快，但是在许多情况下，在表达式中撒一些点比定义一个单独的函数更方便。每个向量化操作。）</target>
        </trans-unit>
        <trans-unit id="96ae6d125bf587e76e862ea35e250d9a1dd1ac01" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;maxintfloat&lt;/code&gt; returns the smallest positive integer-valued floating-point number &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;n+1&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exactly representable in the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">即， &lt;code&gt;maxintfloat&lt;/code&gt; 返回最小的正整数值浮点数 &lt;code&gt;n&lt;/code&gt; 使得 &lt;code&gt;n+1&lt;/code&gt; 个是&lt;em&gt;未&lt;/em&gt;在类型精确表示 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5135aa1a424ac6b5ea53a127625ebc585292c35c" translate="yes" xml:space="preserve">
          <source>That is, in the first call, the expression &lt;code&gt;:(1 == 1.0)&lt;/code&gt; is spliced into the test condition slot, while the value of &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the &lt;code&gt;@assert&lt;/code&gt; macro call occurs. Then at execution time, if the test expression evaluates to true, then &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the &lt;em&gt;value&lt;/em&gt; of the condition is available and it would be impossible to display the expression that computed it in the error message.</source>
          <target state="translated">也就是说，在第一次调用中，将表达式 &lt;code&gt;:(1 == 1.0)&lt;/code&gt; 拼接到测试条件槽中，而将 &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; 值拼接到断言消息槽中。这样构造的整个表达式被放置到语法树中，在该语法树中发生 &lt;code&gt;@assert&lt;/code&gt; 宏调用。然后在执行时，如果测试表达式的计算结果为true，则不返回&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;内容，而如果测试为false，则会引发错误，指示断言的表达式为false。请注意，将其编写为函数是不可能的，因为只有条件的&lt;em&gt;值&lt;/em&gt;可用，并且不可能在错误消息中显示计算出该条件的表达式。</target>
        </trans-unit>
        <trans-unit id="a5c2c27899b95213132fa8a21acc33667eaa425d" translate="yes" xml:space="preserve">
          <source>That is, write:</source>
          <target state="translated">就是说,写。</target>
        </trans-unit>
        <trans-unit id="d78e12b42ebbdc9ccff0d1ee38bf8bf79ad2272d" translate="yes" xml:space="preserve">
          <source>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; was chosen is that it is 17,676,660 hours after &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;, and 17,676,660 is divisible by 10.</source>
          <target state="translated">鉴于小时（12）不能被10整除，这似乎令人困惑。选择 &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; 的原因是，它是在 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 之后的17,676,660小时，并且17,676,660被10整除。</target>
        </trans-unit>
        <trans-unit id="8eac926841ffd7462f202ab5376273deeb8cd2ba" translate="yes" xml:space="preserve">
          <source>That's all. This macro says that the literal contents of the string literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; should be passed to the &lt;code&gt;@r_str&lt;/code&gt; macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; is equivalent to placing the following object directly into the syntax tree:</source>
          <target state="translated">就这样。该宏表示，字符串文字 &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 的文字内容应传递给 &lt;code&gt;@r_str&lt;/code&gt; 宏，并且扩展结果应放在字符串文字的语法树中发生。换句话说，表达式 &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 等效于将以下对象直接放入语法树中：</target>
        </trans-unit>
        <trans-unit id="ececc5f47222691560cc9e3bee59dad9b3d640dc" translate="yes" xml:space="preserve">
          <source>The &quot;splat&quot; operator, &lt;code&gt;...&lt;/code&gt;, represents a sequence of arguments. &lt;code&gt;...&lt;/code&gt; can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. &lt;code&gt;...&lt;/code&gt; can also be used to apply a function to a sequence of arguments.</source>
          <target state="translated">&amp;ldquo; splat&amp;rdquo;运算符 &lt;code&gt;...&lt;/code&gt; 表示参数序列。 &lt;code&gt;...&lt;/code&gt; 可以在函数定义中使用，以指示函数接受任意数量的参数。 &lt;code&gt;...&lt;/code&gt; 也可用于将函数应用于参数序列。</target>
        </trans-unit>
        <trans-unit id="6e87b92b09ff210cf587ecb8ad71387d805a3837" translate="yes" xml:space="preserve">
          <source>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value &lt;code&gt;0x04030201&lt;/code&gt;. Big-endian machines will contain the value &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">32位字节顺序标记指示主机的本机字节顺序。小字节序计算机将包含值 &lt;code&gt;0x04030201&lt;/code&gt; 。大端机器将包含值 &lt;code&gt;0x01020304&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc0d418f0a58caa5e7b5119be0993120b5604ac3" translate="yes" xml:space="preserve">
          <source>The 32-bit floating-point literal expression &lt;code&gt;1.5f22&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1.5&lt;/code&gt; multiplied by the variable &lt;code&gt;f22&lt;/code&gt;.</source>
          <target state="translated">32位浮点文字表达式 &lt;code&gt;1.5f22&lt;/code&gt; 可以解释为数字文字 &lt;code&gt;1.5&lt;/code&gt; 乘以变量 &lt;code&gt;f22&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0554b963c33c05a019079c25e9e8af324781e9db" translate="yes" xml:space="preserve">
          <source>The 5 allocations seen are from running the &lt;code&gt;@time&lt;/code&gt; macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</source>
          <target state="translated">看到的5个分配来自在全局范围内运行 &lt;code&gt;@time&lt;/code&gt; 宏本身。如果我们改为在函数中运行计时，则可以看到实际上没有执行任何分配：</target>
        </trans-unit>
        <trans-unit id="7dea49356c38a6636e3d8df6877285b62b149f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="translated">当前的记录器将调用&lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt; &lt;code&gt;Logging.shouldlog&lt;/code&gt; &lt;/a&gt;函数，该函数会获取一些可以静态计算的最小信息（级别，模块，组，ID）。最有用的是， &lt;code&gt;shouldlog&lt;/code&gt; 传递一个事件 &lt;code&gt;id&lt;/code&gt; ，该事件ID可用于根据缓存的谓词尽早丢弃事件。</target>
        </trans-unit>
        <trans-unit id="9817feb15ee575eea4a8ff720d63067615a333e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types implements arbitrary-precision floating point and integer arithmetic, respectively. For &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR library&lt;/a&gt; is used, and for &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; is used.</source>
          <target state="translated">的&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 有&lt;/a&gt;类型的工具的任意精度浮点和整数运算，分别。对于&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;，使用&lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR库&lt;/a&gt;，对于&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;，使用&lt;a href=&quot;https://gmplib.org&quot;&gt;GNU多精度算术库（GMP）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad3f2b7adf33af93573e441a9559f7a7900079c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; functions ultimately call &lt;code&gt;show&lt;/code&gt; in order to write an object &lt;code&gt;x&lt;/code&gt; as a given &lt;code&gt;mime&lt;/code&gt; type to a given I/O stream &lt;code&gt;io&lt;/code&gt; (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type &lt;code&gt;T&lt;/code&gt;, it is only necessary to define a new &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, via: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt;, where &lt;code&gt;mime&lt;/code&gt; is a MIME-type string and the function body calls &lt;a href=&quot;#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; (or similar) to write that representation of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;io&lt;/code&gt;. (Note that the &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; notation only supports literal strings; to construct &lt;code&gt;MIME&lt;/code&gt; types in a more flexible manner use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt;.)</source>
          <target state="translated">如果可能的话，&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt;函数最终会调用 &lt;code&gt;show&lt;/code&gt; ，以便将对象 &lt;code&gt;x&lt;/code&gt; 作为给定的 &lt;code&gt;mime&lt;/code&gt; 类型写入给定的I / O流 &lt;code&gt;io&lt;/code&gt; （通常是内存缓冲区）。为了提供用户定义的类型 &lt;code&gt;T&lt;/code&gt; 的丰富多媒体表示，只需通过以下方法为 &lt;code&gt;T&lt;/code&gt; 定义新的 &lt;code&gt;show&lt;/code&gt; 方法： &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt; ，其中 &lt;code&gt;mime&lt;/code&gt; 是一个MIME类型串和函数调用身体&lt;a href=&quot;#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;（或类似）到该表示写 &lt;code&gt;x&lt;/code&gt; 到 &lt;code&gt;io&lt;/code&gt; 。 （请注意， &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; 表示法仅支持文字字符串；以更灵活的方式构造 &lt;code&gt;MIME&lt;/code&gt; 类型，请使用 &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="5436a7d5a656260665ad063d5ab1e6eff72c987d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt;&lt;code&gt;r&lt;/code&gt; controls the direction of the rounding; the default is &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that &lt;code&gt;round&lt;/code&gt; may give incorrect results if the global rounding mode is changed (see &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">所述&lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; &lt;code&gt;r&lt;/code&gt; 控制舍入的方向; 默认值是&lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt;，它四舍五入到最接近的整数，并且关系（分数值为0.5）被四舍五入到最接近的偶数整数。需要注意的是 &lt;code&gt;round&lt;/code&gt; ，如果全球舍入模式改变可能会给出不正确的结果（见&lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="36e18d121f5a838cc6709524d85e5f444560cd8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Dates.dayname&quot;&gt;&lt;code&gt;dayname&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthname&quot;&gt;&lt;code&gt;monthname&lt;/code&gt;&lt;/a&gt; methods can also take an optional &lt;code&gt;locale&lt;/code&gt; keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely &lt;a href=&quot;#Dates.dayabbr&quot;&gt;&lt;code&gt;dayabbr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthabbr&quot;&gt;&lt;code&gt;monthabbr&lt;/code&gt;&lt;/a&gt;. First the mapping is loaded into the &lt;code&gt;LOCALES&lt;/code&gt; variable:</source>
          <target state="translated">该&lt;a href=&quot;#Dates.dayname&quot;&gt; &lt;code&gt;dayname&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.monthname&quot;&gt; &lt;code&gt;monthname&lt;/code&gt; &lt;/a&gt;方法也可以使用一个可选 &lt;code&gt;locale&lt;/code&gt; 关键字，可用于返回一年中的一天或一个月为其他语言/区域设置的名称。这些函数也有返回缩写名称的版本，即&lt;a href=&quot;#Dates.dayabbr&quot;&gt; &lt;code&gt;dayabbr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.monthabbr&quot;&gt; &lt;code&gt;monthabbr&lt;/code&gt; &lt;/a&gt;。首先，将映射加载到 &lt;code&gt;LOCALES&lt;/code&gt; 变量中：</target>
        </trans-unit>
        <trans-unit id="b0ea31c9b36eaba5425ec694eab3ed041d8c9eef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; module provides a way to record the history and progress of a computation as a log of events. Events are created by inserting a logging statement into the source code, for example:</source>
          <target state="translated">该&lt;a href=&quot;#Logging.Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt;模块提供了一种方法来记录历史，并为事件的日志计算的进步。通过将日志记录语句插入源代码来创建事件，例如：</target>
        </trans-unit>
        <trans-unit id="3b0d2cdace4e12d15a4692bf023ef78f32612455" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions-1&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="translated">的&lt;a href=&quot;#Rounding-functions-1&quot;&gt;舍入函数&lt;/a&gt;采取类型 &lt;code&gt;T&lt;/code&gt; 作为可选参数。例如， &lt;code&gt;round(Int,x)&lt;/code&gt; 是 &lt;code&gt;Int(round(x))&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="5eb87235a3e582308fdae141ff9f8e2932202086" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector &lt;code&gt;I&lt;/code&gt; of row indices, a vector &lt;code&gt;J&lt;/code&gt; of column indices, and a vector &lt;code&gt;V&lt;/code&gt; of stored values (this is also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (coordinate) format&lt;/a&gt;). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; then constructs a sparse matrix such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The equivalent sparse vector constructor is &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt;, which takes the (row) index vector &lt;code&gt;I&lt;/code&gt; and the vector &lt;code&gt;V&lt;/code&gt; with the stored values and constructs a sparse vector &lt;code&gt;R&lt;/code&gt; such that &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;的功能往往是构建稀疏数组的便捷方式。例如，要构造稀疏矩阵，我们可以输入行索引的向量 &lt;code&gt;I&lt;/code&gt; ，列索引的向量 &lt;code&gt;J&lt;/code&gt; 和存储值的向量 &lt;code&gt;V&lt;/code&gt; （也称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO（坐标）格式&lt;/a&gt;）。 &lt;code&gt;sparse(I,J,V)&lt;/code&gt; 然后构造一个稀疏矩阵，使得 &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; 。等效的稀疏向量构造函数是&lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt;，它使用（行）索引向量 &lt;code&gt;I&lt;/code&gt; 和具有存储值的向量 &lt;code&gt;V&lt;/code&gt; 并构造稀疏向量 &lt;code&gt;R&lt;/code&gt; ，使得 &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce4dd4aa2504c940aa48ceeab07c53ca96b6449" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; can be a block:</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt;宏重写这一呼吁是完全等效于上述更长的版本。对于更长的生成代码块，给&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt;的expression参数可以是一个块：</target>
        </trans-unit>
        <trans-unit id="38ef0a3b168bd74d25880aec3b78cf19271d94b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt; macro makes use of &lt;code&gt;@__doc__&lt;/code&gt; to allow for documenting &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;s. Examining its definition should serve as an example of how to use &lt;code&gt;@__doc__&lt;/code&gt; correctly.</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt;宏利用的 &lt;code&gt;@__doc__&lt;/code&gt; 允许记录&lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;秒。检查其定义应作为如何正确使用 &lt;code&gt;@__doc__&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="acfadefe2bb6121d5e848cbd0b9afe7e8768d52d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function is used to produce an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; that interrupts the normal flow of control.</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Base.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt;函数用于产生&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;该中断控制的正常流动。</target>
        </trans-unit>
        <trans-unit id="fd385b6cfaa8837c37589622c3c706028ad36f1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; operator is another exception: &lt;code&gt;missing&lt;/code&gt; is considered as greater than any other value. This operator is used by &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, which therefore places &lt;code&gt;missing&lt;/code&gt; values after all other values.</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;运营商是另一个异常： &lt;code&gt;missing&lt;/code&gt; 被视为大于任何其他值。该运算符由&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; 使用&lt;/a&gt;，因此会将 &lt;code&gt;missing&lt;/code&gt; 值放在所有其他值之后。</target>
        </trans-unit>
        <trans-unit id="4d17e67e8157d57768d314d2878bcbffb2b8fe95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions also apply to floating-point types:</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;功能也适用于浮点类型：</target>
        </trans-unit>
        <trans-unit id="de73ba08a71f852e7d2733fa6dfed62a7f72340d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;功能确认的&amp;ldquo;两化&amp;rdquo;建设情况 &lt;code&gt;NoFields&lt;/code&gt; 实际上是同一个。单例类型将在&lt;a href=&quot;#man-singleton-types-1&quot;&gt;下面&lt;/a&gt;进一步详细描述。</target>
        </trans-unit>
        <trans-unit id="d77ec66ab2077f795aecb0927e53656b9c9cc945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;构造函数采用任意数量的参数，并通过他们的字符串表示串联起来创建一个新的符号：</target>
        </trans-unit>
        <trans-unit id="414514dfacecedf70ecbd06d5fef52f6a37552e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; function tests if an object is of a given type and returns true or false:</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt;功能测试对象是否是给定类型并且返回真或假：</target>
        </trans-unit>
        <trans-unit id="bf1b3d1c04844d76b7ef3cb166b81958a1f65c08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;功能</target>
        </trans-unit>
        <trans-unit id="b96dfc29471c7f4e7faf38271fb34f184e922afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</source>
          <target state="translated">在示例中的整个手册中已经使用过的&lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt;函数返回其参数的类型。如上所述，由于类型是对象，因此它们也具有类型，我们可以询问它们的类型是什么：</target>
        </trans-unit>
        <trans-unit id="0d827a86b6df88cc411d1f3d30cdcddabf2bc33a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;, but only operates on a single name at a time. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="translated">该&lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;关键字支持相同的语法&lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;，但仅限于单一的名字在同一时间运行。它不会以 &lt;code&gt;using&lt;/code&gt; 方式添加要搜索的模块。 &lt;code&gt;import&lt;/code&gt; 与 &lt;code&gt;using&lt;/code&gt; 的不同之处还在于，可以使用新方法扩展使用 &lt;code&gt;import&lt;/code&gt; 导入的功能。</target>
        </trans-unit>
        <trans-unit id="ec874bb7238b430b76f31f6a2f70602d5cd36c3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt; type is essentially a synonym for &lt;code&gt;Ptr{UInt8}&lt;/code&gt;, except the conversion to &lt;code&gt;Cstring&lt;/code&gt; throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator). If you are passing a &lt;code&gt;char*&lt;/code&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use &lt;code&gt;Ptr{UInt8}&lt;/code&gt; as the argument type. &lt;code&gt;Cstring&lt;/code&gt; can also be used as the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</source>
          <target state="translated">所述&lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt;类型基本上为同义词 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; ，除转化为 &lt;code&gt;Cstring&lt;/code&gt; 如果朱莉娅字符串包含任何嵌入NUL字符引发错误（这将导致字符串如果被静默截断C例程对待NUL作为终止子） 。如果要将 &lt;code&gt;char*&lt;/code&gt; 传递给不假定NUL终止的C例程（例如，因为传递了显式的字符串长度），或者如果您确定自己的Julia字符串不包含NUL并想跳过检查，则可以可以使用 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 作为参数类型。 &lt;code&gt;Cstring&lt;/code&gt; 也可以用作&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 返回类型，但在那种情况下，它显然不会引入任何额外的检查，而仅仅是为了提高调用的可读性。</target>
        </trans-unit>
        <trans-unit id="3fe5df294c64ae2bc17b6c645704bd7bc62ca16b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;Base.filter&lt;/code&gt;&lt;/a&gt; method can be used to obtain all valid dates/moments in a specified range:</source>
          <target state="translated">该&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;Base.filter&lt;/code&gt; &lt;/a&gt;方法可用于获得在特定范围内的所有有效的日期/时刻：</target>
        </trans-unit>
        <trans-unit id="32116ae8c0495cf49f4c9c66e837a3e4255f5c44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt; function provides indented and annotated display of &lt;code&gt;Expr&lt;/code&gt; objects:</source>
          <target state="translated">该&lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt;功能提供缩进和注释的显示 &lt;code&gt;Expr&lt;/code&gt; 的对象：</target>
        </trans-unit>
        <trans-unit id="63e3ea8e88f5b981ca22a0c9f75818db8e88281d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro addresses scenarios where we do not want a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="translated">该&lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt; &lt;code&gt;@threadcall&lt;/code&gt; &lt;/a&gt;宏地址的情况，我们不希望&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;挡主朱莉娅事件循环。它调度C函数以在单独的线程中执行。为此，使用默认大小为4的线程池。 &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; 的大小由环境变量UV_THREADPOOL_SIZE控制。在等待空闲线程时，以及在函数执行过程中，一旦有线程可用，请求的任务（在主Julia事件循环上）就会屈服于其他任务。请注意，直到执行完成， &lt;code&gt;@threadcall&lt;/code&gt; 才会返回。从用户的角度来看，因此它像其他Julia API一样是阻塞调用。</target>
        </trans-unit>
        <trans-unit id="9980cd05996241c9e77ece29af3cb2e812c97a73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; type is a direct child type of &lt;code&gt;Any&lt;/code&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is its child. In turn, &lt;code&gt;Real&lt;/code&gt; has two children (it has more, but only two are shown here; we'll get to the others later): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt;, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, &lt;code&gt;AbstractFloat&lt;/code&gt; is a proper subtype of &lt;code&gt;Real&lt;/code&gt;, including only floating-point representations of real numbers. Integers are further subdivided into &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; varieties.</source>
          <target state="translated">该&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;类型的直接子类型 &lt;code&gt;Any&lt;/code&gt; 和&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;是其子。反过来， &lt;code&gt;Real&lt;/code&gt; 有两个子代（它有更多子代，但这里仅显示两个；稍后我们将介绍其他子代）：&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt;，将世界分为整数表示和实数表示。实数的表示形式当然包括浮点类型，但也包括其他类型，例如有理数。因此， &lt;code&gt;AbstractFloat&lt;/code&gt; 是 &lt;code&gt;Real&lt;/code&gt; 的适当子类型，仅包含实数的浮点表示形式。整数进一步细分为有&lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; 品种。</target>
        </trans-unit>
        <trans-unit id="a61c350b843f41f66bd6a94fb06646bf09f7c269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; function MUST exit as soon as all the requested workers have been launched.</source>
          <target state="translated">该&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;方法是在一个单独的任务异步调用。该任务的终止表明所有请求的工作人员已经启动。因此，&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;功能必须在所有请求的工作程序启动后立即退出。</target>
        </trans-unit>
        <trans-unit id="e5928b30867a053dbff6206d1bc20c56f14e738b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method takes the following arguments:</source>
          <target state="translated">该&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;方法采用下列参数：</target>
        </trans-unit>
        <trans-unit id="7b33ac485b0a3f8ebfda5064c9e3efc2a8bcfdcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="translated">从变量构造复数时，&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;文字数字系数符号&lt;/a&gt;不起作用。相反，必须明确写出乘法：</target>
        </trans-unit>
        <trans-unit id="275af0000e44bc521cd56c3026533fc5cd78a5de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="translated">反对 &lt;code&gt;+&lt;/code&gt; 的&lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;主要观点&lt;/a&gt;是字符串串联不是可交换的，而 &lt;code&gt;+&lt;/code&gt; 通常用作交换运算符。尽管Julia社区认识到其他语言使用不同的运算符，并且 &lt;code&gt;*&lt;/code&gt; 对于某些用户可能并不熟悉，但它传达了某些代数性质。</target>
        </trans-unit>
        <trans-unit id="c14035985c996abe00f4042cc746b4176aab2201" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames package&lt;/a&gt; provides data frames.</source>
          <target state="translated">所述&lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames包&lt;/a&gt;提供的数据帧。</target>
        </trans-unit>
        <trans-unit id="e3ebf2c6b9c4eb22391edbc55310df1678b26195" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt;包可以帮助你找到代码中常见的性能问题。</target>
        </trans-unit>
        <trans-unit id="09270743df4b19bd666f57937fe0296a7b3d369a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C (and not Julia).</source>
          <target state="translated">在&lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU科学图书馆&lt;/a&gt;（这里假定为通过访问 &lt;code&gt;:libgsl&lt;/code&gt; ）定义了一个不透明的指针， &lt;code&gt;gsl_permutation *&lt;/code&gt; ，作为C函数的返回类型 &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; 。由于用户代码 &lt;code&gt;gsl_permutation&lt;/code&gt; 查看gsl_permutation结构内部，因此相应的Julia包装器仅需要一个新的类型声明 &lt;code&gt;gsl_permutation&lt;/code&gt; ，该声明没有内部字段，其唯一目的是放在 &lt;code&gt;Ptr&lt;/code&gt; 类型的type参数中。&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的返回类型声明为 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; ，因为 &lt;code&gt;output_ptr&lt;/code&gt; 分配并指向了内存 由C（而不是Julia）控制。</target>
        </trans-unit>
        <trans-unit id="72ea3eda7ce888d73eff517a4ef953491525adf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; syntax is deprecated, use the &lt;code&gt;Ref{T}&lt;/code&gt; argument type instead.</source>
          <target state="translated">的 &lt;code&gt;&amp;amp;&lt;/code&gt; 语法已过时，使用 &lt;code&gt;Ref{T}&lt;/code&gt; 参数类型代替。</target>
        </trans-unit>
        <trans-unit id="ff8eac00092307ddc7d1e59e50812b91cc8012ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;:&lt;/code&gt; operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns &lt;code&gt;true&lt;/code&gt; when its left operand is a subtype of its right operand:</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;:&lt;/code&gt; 操作者在一般的意思是&amp;ldquo;是的子类型&amp;rdquo;，并且在声明像这样使用，声明了右手型是新声明的类型的直接超类型。它也可以在表达式中用作子类型运算符，当其左操作数是其右操作数的子类型时返回 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="462f03c3cade5b2449ca60ca2d04cc3130736218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</source>
          <target state="translated">本 &lt;code&gt;--&lt;/code&gt; 分隔符可以用来用于从用于朱莉娅参数的脚本文件单独的命令行参数：</target>
        </trans-unit>
        <trans-unit id="396147a6b9dfacff46d28874aadee188884bc052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</source>
          <target state="translated">该 &lt;code&gt;2x + y&lt;/code&gt; 的定义仅在第一种情况下使用，而 &lt;code&gt;2x - y&lt;/code&gt; 定义是在他人使用。永远不会执行函数参数的自动转换或转换：Julia中的所有转换都是非魔术的，并且是完全明确的。但是，&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换和推广&lt;/a&gt;表明，如何充分运用先进技术才能与魔术区分开。&lt;a href=&quot;#footnote-Clarke61&quot;&gt;[克拉克61]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702c47148e007cd263dc6deb6727c14f26afb82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</source>
          <target state="translated">该 &lt;code&gt;::&lt;/code&gt; 操作符可以用来连接类型注释表达式和变量的程序。这样做有两个主要原因：</target>
        </trans-unit>
        <trans-unit id="a4ee1c478f2612aec54bd174690fa6ea35ddb91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;/code&gt; character has two syntactic purposes in Julia. The first form creates a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;interned string&lt;/a&gt; used as one building-block of expressions:</source>
          <target state="translated">的 &lt;code&gt;:&lt;/code&gt; 字符在朱莉娅2点语法的目的。第一种形式创建一个&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;，它是一个用作表达式的构建块的&lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;内部字符串&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="48c311a5c224de0110d74a449183e9149c5a0fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@assert&lt;/code&gt; macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</source>
          <target state="translated">该 &lt;code&gt;@assert&lt;/code&gt; 宏使得大量使用拼接成报表达式简化宏体内表达的操纵。</target>
        </trans-unit>
        <trans-unit id="801ed9019f04c0f8f529dacee5be7631d5e276fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@boundscheck&lt;/code&gt; annotation allows you, as a library writer, to opt-in to allowing &lt;em&gt;other code&lt;/em&gt; to remove your bounds checks with &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;. As noted there, the caller must verify&amp;mdash;using information they can access&amp;mdash;that their accesses are valid before using &lt;code&gt;@inbounds&lt;/code&gt;. For indexing into your &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; subclasses, for example, this involves checking the indices against its &lt;a href=&quot;../arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;code&gt;@boundscheck&lt;/code&gt; annotations should only be added to a &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; implementation after you are certain its behavior is correct.</source>
          <target state="translated">该 &lt;code&gt;@boundscheck&lt;/code&gt; 注释允许你为图书馆的作家，要选择加入，允许&lt;em&gt;其他代码&lt;/em&gt;与删除您的边界检查&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;。如此处所述，在使用 &lt;code&gt;@inbounds&lt;/code&gt; 之前，调用者必须使用他们可以访问的信息来验证其访问是否有效。例如，要为您的&lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;子类建立索引，这涉及针对其&lt;a href=&quot;../arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;检查索引。因此， &lt;code&gt;@boundscheck&lt;/code&gt; 批注仅应添加到&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;确定其行为正确之后再实施。</target>
        </trans-unit>
        <trans-unit id="8d04719fe4369bb879f4c27763dea9901ff5736f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;. By default, documentation is expected to be written in Markdown, and the &lt;code&gt;doc&quot;&quot;&lt;/code&gt; string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</source>
          <target state="translated">所述 &lt;code&gt;@doc&lt;/code&gt; 宏其第一个参数，其在被称为每个模块字典第二关联 &lt;code&gt;META&lt;/code&gt; 。默认情况下，文档应使用Markdown编写，并且 &lt;code&gt;doc&quot;&quot;&lt;/code&gt; 字符串宏仅创建表示Markdown内容的对象。将来可能会做更高级的事情，例如允许相对的图像或链接路径。</target>
        </trans-unit>
        <trans-unit id="3901521653150d23278fa27f787a9dbcf11d8111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@simd&lt;/code&gt; does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; to also assert that:</source>
          <target state="translated">该 &lt;code&gt;@simd&lt;/code&gt; 没有断言在默认情况下，该回路是完全免费的循环进行内存的依赖，这是一个可以很容易地在通用的代码侵犯的假设。如果您正在编写非通用代码，则可以使用 &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; 来声明：</target>
        </trans-unit>
        <trans-unit id="22755b36a58e8494f0fc686a468ea1d881c82d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; form is equivalent to writing &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; which can be useful when the expression is a call using infix syntax such as approximate comparisons:</source>
          <target state="translated">所述 &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; 形式等同于写入 &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; 当表达式是使用中缀语法的呼叫，其可以是有用例如近似比较：</target>
        </trans-unit>
        <trans-unit id="16c63b805f73cc977b60037a10997e30bb4b9947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">该 &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; 形式的作品作为 &lt;code&gt;@test&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="abdc5ad65294f55eba9140a8f0b4f4933db8d022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">该 &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; 形式的作品作为 &lt;code&gt;@test&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="8d32bc610a43028740032f0894a8d5b65d4647e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@testset&lt;/code&gt; macro can be used to group tests into &lt;em&gt;sets&lt;/em&gt;. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a &lt;code&gt;TestSetException&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;@testset&lt;/code&gt; 宏可用于组测试成&lt;em&gt;套&lt;/em&gt;。将运行测试集中的所有测试，并在测试集结束时打印摘要。如果任何测试失败，或者由于错误而无法评估，则测试集将抛出 &lt;code&gt;TestSetException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1109eb4b0b82fe1adad014b7f4cf1b1315fb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threadcall&lt;/code&gt; macro is called in the same way as &lt;a href=&quot;../c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main &lt;code&gt;julia&lt;/code&gt; thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; environment variable and restarting the &lt;code&gt;julia&lt;/code&gt; process.</source>
          <target state="translated">该 &lt;code&gt;@threadcall&lt;/code&gt; 宏被调用以同样的方式作为&lt;a href=&quot;../c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;但确实在不同的线程的工作。当您要调用阻塞的C函数而不会导致 &lt;code&gt;julia&lt;/code&gt; 主线程被阻塞时，这很有用。并发性受libuv线程池大小的限制，该线程池默认为4个线程，但可以通过设置 &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; 环境变量并重新启动 &lt;code&gt;julia&lt;/code&gt; 进程来增加并发性。</target>
        </trans-unit>
        <trans-unit id="be390301ffbdbbfe0c2a21aa488c727a5bb08d3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threads&lt;/code&gt; Macro</source>
          <target state="translated">该 &lt;code&gt;@threads&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="3926862dd6a57d44f61884e7fbb13c9a98fc27be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@views&lt;/code&gt; macro only affects &lt;code&gt;array[...]&lt;/code&gt; expressions that appear explicitly in the given &lt;code&gt;expression&lt;/code&gt;, not array slicing that occurs in functions called by that code.</source>
          <target state="translated">所述 &lt;code&gt;@views&lt;/code&gt; 宏仅影响 &lt;code&gt;array[...]&lt;/code&gt; 是，在给定的显式出现的表达式 &lt;code&gt;expression&lt;/code&gt; ，而不是发生在由代码调用的函数阵列切片。</target>
        </trans-unit>
        <trans-unit id="f1624bacdb2ea72aa9e204c460f79dbfffe8ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;AbstractArray&lt;/code&gt; 类型包括任何依稀阵列状，并且它的实现可能是从传统阵列有很大不同。例如，元素可以应要求计算而不是存储。但是，任何具体的 &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; 类型通常应至少实现&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size(A)&lt;/code&gt; &lt;/a&gt;（返回一个 &lt;code&gt;Int&lt;/code&gt; 元组）， &lt;code&gt;getindex(A,i)&lt;/code&gt; 和&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt; &lt;/a&gt;；可变数组也应该实现&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;。建议这些操作具有几乎恒定的时间复杂度，或者从技术上讲是&amp;Otilde;（1）复杂度，否则某些数组函数可能会出乎意料地缓慢。具体类型通常还应提供&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt; &lt;/a&gt;，该方法用于为&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;和其他异地操作分配相似的数组。无论内部如何表示 &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; 都是通过&lt;em&gt;整数&lt;/em&gt;索引返回的对象类型（ &lt;code&gt;A[1, ..., 1]&lt;/code&gt; ，当 &lt;code&gt;A&lt;/code&gt; 不为空时）， &lt;code&gt;N&lt;/code&gt; 应该是&lt;em&gt;整数&lt;/em&gt;的长度。元组按&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;返回。有关定义自定义 &lt;code&gt;AbstractArray&lt;/code&gt; 实现的更多详细信息，请参见&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;接口一章中&lt;/a&gt;的数组接口指南。</target>
        </trans-unit>
        <trans-unit id="a1a42131bfca003806ea94dc4875800e91fc9149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractChar&lt;/code&gt; type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the &lt;a href=&quot;#Base.codepoint&quot;&gt;&lt;code&gt;codepoint&lt;/code&gt;&lt;/a&gt; function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, for example. New &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; types should define a &lt;code&gt;codepoint(::T)&lt;/code&gt; method and a &lt;code&gt;T(::UInt32)&lt;/code&gt; constructor, at minimum.</source>
          <target state="translated">该 &lt;code&gt;AbstractChar&lt;/code&gt; 类型是朱莉娅所有的字符实现的超类型。字符表示Unicode代码点，可以通过&lt;a href=&quot;#Base.codepoint&quot;&gt; &lt;code&gt;codepoint&lt;/code&gt; &lt;/a&gt;函数将其转换为整数，以获得代码点的数值，也可以由同一整数构造。例如，这些数值确定如何将字符与 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 进行比较。新的 &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; 类型至少应定义一个 &lt;code&gt;codepoint(::T)&lt;/code&gt; 方法和一个 &lt;code&gt;T(::UInt32)&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="1c7306a482beca890d3fe61802010a334de7540c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConfigEntry&lt;/code&gt; would look like the following:</source>
          <target state="translated">该 &lt;code&gt;ConfigEntry&lt;/code&gt; 将如下所示：</target>
        </trans-unit>
        <trans-unit id="ba9c45997f3e5b0258d17d45edce07e2353ce6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module approach tries to follow the simple principle of trying to change as little as possible when doing &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; arithmetic. This approach is also often known as &lt;em&gt;calendrical&lt;/em&gt; arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;March 3&lt;/a&gt; (assumes 31 days). PHP says &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;March 2&lt;/a&gt; (assumes 30 days). The fact is, there is no right answer. In the &lt;code&gt;Dates&lt;/code&gt; module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.</source>
          <target state="translated">该 &lt;code&gt;Dates&lt;/code&gt; 模块化方法试图遵循的做时试图改变尽可能少的简单的原则&lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt;的算术。这种方法通常也称为&lt;em&gt;日历&lt;/em&gt;计算，或者如果有人在对话中问您相同的计算，您可能会猜到什么。为什么对此大惊小怪？让我们举一个经典的例子：在2014年1月31日前增加1个月。答案是什么？ Javascript将显示&lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;3月3日&lt;/a&gt;（假设为31天）。 PHP表示&lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;3月2日&lt;/a&gt;（假设30天）。事实是，没有正确的答案。在&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; 模块中，它给出2月28日的结果。如何解决呢？我喜欢想到赌场中经典的7-7-7赌博游戏。</target>
        </trans-unit>
        <trans-unit id="f3b7289c36cdd40212d2c06b1045bb17b9239ebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides the &lt;em&gt;adjuster&lt;/em&gt; API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and return or &lt;em&gt;adjust to&lt;/em&gt; the first or last of the desired period relative to the input.</source>
          <target state="translated">该 &lt;code&gt;Dates&lt;/code&gt; 模块提供&lt;em&gt;调节&lt;/em&gt;通过几种简便的方法是，在简练表达域规则援助API。第一组调节器方法处理周，月，季度和年的头和尾。它们每个都使用单个&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;作为输入，并且相对于输入返回或&lt;em&gt;调整到&lt;/em&gt;所需时间段的第一个或最后一个。</target>
        </trans-unit>
        <trans-unit id="822dabd74f61866145ac5d6c2a28ae2c68643b5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides two types for working with dates: &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, representing day and millisecond precision, respectively; both are subtypes of the abstract &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.</source>
          <target state="translated">该 &lt;code&gt;Dates&lt;/code&gt; 模块提供两种类型的使用日期：&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，代表天，精确到毫秒，分别;两者都是抽象&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; 的&lt;/a&gt;子类型。区分类型的动机很简单：当不必处理更高精度的复杂性时，某些操作在代码和思维推理方面都简单得多。例如，由于&amp;ldquo; &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;类型只能解析为单个日期的精度（即无小时，分钟或秒），因此无需时常考虑时区，夏令时/夏令时和leap秒。</target>
        </trans-unit>
        <trans-unit id="47e6ad22d3652de8f0079c299b50b93cf7e90cb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Docs&lt;/code&gt; module provides the &lt;code&gt;@doc&lt;/code&gt; macro which can be used to set and retrieve documentation metadata for Julia objects.</source>
          <target state="translated">所述 &lt;code&gt;Docs&lt;/code&gt; 模块提供 &lt;code&gt;@doc&lt;/code&gt; 宏其可用于设置和检索文档的元数据为对象朱莉娅。</target>
        </trans-unit>
        <trans-unit id="21bb014706065802683533ccfbc183fd2f75ab09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GitHash&lt;/code&gt; of the target object of &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;GitHash&lt;/code&gt; 的目标对象的 &lt;code&gt;tag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e3fa0171d91b22777ce2dc8384f8c21045a536e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JL_GC_POP&lt;/code&gt; call releases the references established by the previous &lt;code&gt;JL_GC_PUSH&lt;/code&gt;. Note that &lt;code&gt;JL_GC_PUSH&lt;/code&gt; stores references on the C stack, so it must be exactly paired with a &lt;code&gt;JL_GC_POP&lt;/code&gt; before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; was invoked.</source>
          <target state="translated">该 &lt;code&gt;JL_GC_POP&lt;/code&gt; 呼叫释放由先前建立的参考 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 。请注意， &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 将引用存储在C堆栈上，因此在退出范围之前，它必须与 &lt;code&gt;JL_GC_POP&lt;/code&gt; 完全配对。也就是说，在函数返回之前，否则控制流会离开调用 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 的块。</target>
        </trans-unit>
        <trans-unit id="3b348f9eede2ca6e62ca6337bddb047633174b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.</source>
          <target state="translated">该 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 环境变量用于填充全局朱莉娅&lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt; &lt;code&gt;DEPOT_PATH&lt;/code&gt; &lt;/a&gt;变量，它控制在包管理器，以及Julia的代码加载机制，寻找软件包注册表，安装的软件包，名为环境，回购克隆，缓存编译包的图像，并配置文件。</target>
        </trans-unit>
        <trans-unit id="69afeb6e2b2ee8e42ee83f53cc80115effd30019" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 环境变量用来填充全局朱莉娅&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt;变量，这决定了其包装可通过加载 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;using&lt;/code&gt; （见&lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;代码加载&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="34bade2917d4a413edb80c43d8efdb3c090b4bcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profile&lt;/code&gt; module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify &quot;bottlenecks&quot; as targets for optimization.</source>
          <target state="translated">该 &lt;code&gt;Profile&lt;/code&gt; 模块提供工具，以帮助开发人员提高其代码的性能。使用时，它将对正在运行的代码进行测量，并产生输出，以帮助您了解在单个行上花费了多少时间。最常见的用法是将&amp;ldquo;瓶颈&amp;rdquo;确定为优化目标。</target>
        </trans-unit>
        <trans-unit id="dee6516fb82f5277170e1ea0a8d04d1ed4092fd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pub&lt;/code&gt; package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</source>
          <target state="translated">该 &lt;code&gt;Pub&lt;/code&gt; 包是用户库，在用户安装的软件包现场。这些仅对安装它们的用户可用。</target>
        </trans-unit>
        <trans-unit id="a8c1397c7dbb153add27fc9553cd4c77cee5bc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regex()&lt;/code&gt; constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to &lt;code&gt;Regex()&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">在 &lt;code&gt;Regex()&lt;/code&gt; 构造函数可用于以编程方式创建一个有效的正则表达式的字符串。这允许在构造正则表达式字符串时使用字符串变量的内容和其他字符串操作。上面的任何正则表达式代码都可以在 &lt;code&gt;Regex()&lt;/code&gt; 的单个字符串参数中使用。这里有些例子：</target>
        </trans-unit>
        <trans-unit id="73ca6d3bf4c447b201b63ae9bba284f7ce5a10d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StackTraces&lt;/code&gt; module provides simple stack traces that are both human readable and easy to use programmatically.</source>
          <target state="translated">该 &lt;code&gt;StackTraces&lt;/code&gt; 模块提供了与人可读和易于编程方式使用简单的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="c7aa3a52368467c889b31b4e2156567453a420c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Test&lt;/code&gt; module provides simple &lt;em&gt;unit testing&lt;/em&gt; functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</source>
          <target state="translated">所述 &lt;code&gt;Test&lt;/code&gt; 模块提供了简单的&lt;em&gt;单元测试&lt;/em&gt;功能。单元测试是一种通过检查结果是否符合预期来查看代码是否正确的方法。确保您的代码在进行更改后仍然可以工作，这很有用，并且可以在开发时用作指定代码完成后应具有的行为的方式。</target>
        </trans-unit>
        <trans-unit id="3a54216422a2392050b1e4b2adcb38fe041e32d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTInstant&lt;/code&gt; represents a machine timeline based on UT time (1 day = one revolution of the earth). The &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;Period&lt;/code&gt; parameter that indicates the resolution or precision of the instant.</source>
          <target state="translated">所述 &lt;code&gt;UTInstant&lt;/code&gt; 表示基于UT时间（1天地球=一转）的机器的时间表。该 &lt;code&gt;T&lt;/code&gt; 是一个 &lt;code&gt;Period&lt;/code&gt; 参数，指示瞬间的分辨率和精度。</target>
        </trans-unit>
        <trans-unit id="f172eb4712d1e651ca4443a247edaddae0c02ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnitRange&lt;/code&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="translated">该 &lt;code&gt;UnitRange&lt;/code&gt; &lt;code&gt;irange&lt;/code&gt; 的指定索引排序的特征值来搜索。</target>
        </trans-unit>
        <trans-unit id="ec153c629332b5ec9f45e8c540e2078292ed5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; character should be escaped appropriately if the text is embedded in a Julia source code, for example, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt;, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the &lt;code&gt;raw&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro:</source>
          <target state="translated">所述 &lt;code&gt;\&lt;/code&gt; 字符应适当转义如果文本嵌入在朱源代码，例如， &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt; ，因为它被解释为字符串文字。另外，为了避免转义，可以将 &lt;code&gt;raw&lt;/code&gt; 字符串宏与 &lt;code&gt;@doc&lt;/code&gt; 宏一起使用：</target>
        </trans-unit>
        <trans-unit id="81508e7a2286289f4f9b4e988f086408435f8b86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</source>
          <target state="translated">这里的 &lt;code&gt;\&lt;/code&gt; 操作执行线性解。左除法运算符功能非常强大，并且易于编写紧凑，易读的代码，该代码足够灵活以解决各种线性方程组。</target>
        </trans-unit>
        <trans-unit id="70fe69b8656c0c45fea00d261b4a1573767bfc08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abstract type&lt;/code&gt; keyword introduces a new abstract type, whose name is given by &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt;. This name can be optionally followed by &lt;code&gt;&amp;lt;:&lt;/code&gt; and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</source>
          <target state="translated">该 &lt;code&gt;abstract type&lt;/code&gt; 的关键字引入了一个新的抽象类型，其名字由下式给出 &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt; 。可以在此名称后附加 &lt;code&gt;&amp;lt;:&lt;/code&gt; 和一个已经存在的类型，表示新声明的抽象类型是此&amp;ldquo;父&amp;rdquo;类型的子类型。</target>
        </trans-unit>
        <trans-unit id="2f9421706ce1251dd1a3a86cb4c9ef2ac4b3c269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowed_types&lt;/code&gt; contains a bitmask of &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; values specifying which authentication methods should be attempted.</source>
          <target state="translated">该 &lt;code&gt;allowed_types&lt;/code&gt; 包含的位掩码 &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; 值规定的认证方法应尝试。</target>
        </trans-unit>
        <trans-unit id="8b06ca131e63337ccd916fd14f532e8185770099" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; keyword arguments requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; is available as a positional argument, but this will be deprecated in Julia 2.0.</source>
          <target state="translated">在 &lt;code&gt;atol&lt;/code&gt; 和 &lt;code&gt;rtol&lt;/code&gt; 关键字参数至少需要朱莉娅1.1。在Julia 1.0中，可以使用 &lt;code&gt;rtol&lt;/code&gt; 作为位置参数，但是在Julia 2.0中将不建议使用。</target>
        </trans-unit>
        <trans-unit id="7a8f8106813dc53840cdd36136d9eb3701004f27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted). Now, suppose that we have a 1d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we worry about calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define &lt;code&gt;&amp;lt;&lt;/code&gt;):</source>
          <target state="translated">所述 &lt;code&gt;base&lt;/code&gt; 的参数是一个指向长度的数组 &lt;code&gt;nmemb&lt;/code&gt; 个，随着元件 &lt;code&gt;size&lt;/code&gt; 的字节每个。 &lt;code&gt;compare&lt;/code&gt; 是一个回调函数，它使用指向两个元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的指针，并在 &lt;code&gt;a&lt;/code&gt; 出现在 &lt;code&gt;b&lt;/code&gt; 之前/之后返回小于/大于零的整数（如果允许任何顺序，则返回零）。现在，假设我们要使用 &lt;code&gt;qsort&lt;/code&gt; 函数（而不是Julia的内置 &lt;code&gt;sort&lt;/code&gt; 函数）对 Julia中的一维值数组 &lt;code&gt;A&lt;/code&gt; 进行排序。在我们担心调用 &lt;code&gt;qsort&lt;/code&gt; 之前和传递参数，我们需要编写一个比较函数，该函数可用于某些任意对象（定义 &lt;code&gt;&amp;lt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="2208a0a1e673c387c0482cabd9f5481f4d468aa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;baseline&lt;/code&gt; is the tree to be used for comparison to the working directory and index; defaults to HEAD.</source>
          <target state="translated">该 &lt;code&gt;baseline&lt;/code&gt; 是用于比较到工作目录和索引树; 默认为HEAD。</target>
        </trans-unit>
        <trans-unit id="29b441ac8e59d2fd60c5cee59a3c67db4265556f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chnl&lt;/code&gt; object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed &lt;code&gt;Channel&lt;/code&gt; objects.</source>
          <target state="translated">该 &lt;code&gt;chnl&lt;/code&gt; 对象可以明确地关闭独立任务终止。终止任务对已经关闭的 &lt;code&gt;Channel&lt;/code&gt; 对象没有影响。</target>
        </trans-unit>
        <trans-unit id="efa868ba15d4c70e293eebe72c9574ee9fe6fe35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a &lt;code&gt;const&lt;/code&gt; declaration solves this performance problem.</source>
          <target state="translated">该 &lt;code&gt;const&lt;/code&gt; 的声明应该仅在全局全球范围内使用。编译器很难优化涉及全局变量的代码，因为它们的值（甚至它们的类型）几乎可以随时更改。如果全局变量不变，则添加 &lt;code&gt;const&lt;/code&gt; 声明可以解决此性能问题。</target>
        </trans-unit>
        <trans-unit id="58b4a67ce4add4334b6cfa9f5f2082d426131b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert&lt;/code&gt; function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</source>
          <target state="translated">的 &lt;code&gt;convert&lt;/code&gt; 功能通常需要两个参数：第一个是一种类型的对象和第二个是转换成类型的值。返回的值是转换为给定类型的实例的值。理解此功能的最简单方法是查看其功能：</target>
        </trans-unit>
        <trans-unit id="e7cb3fc07af13ab851df995a0b91fc4d68f51c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current&lt;/code&gt; status object may be a &lt;code&gt;StatStruct&lt;/code&gt;, an &lt;code&gt;EOFError&lt;/code&gt; (indicating the timeout elapsed), or some other &lt;code&gt;Exception&lt;/code&gt; subtype (if the &lt;code&gt;stat&lt;/code&gt; operation failed - for example, if the path does not exist).</source>
          <target state="translated">的 &lt;code&gt;current&lt;/code&gt; 状态的对象可以是 &lt;code&gt;StatStruct&lt;/code&gt; ，一个 &lt;code&gt;EOFError&lt;/code&gt; （指示超时经过），或一些其它 &lt;code&gt;Exception&lt;/code&gt; 亚型（如果该 &lt;code&gt;stat&lt;/code&gt; 操作失败-例如，如果路径不存在）。</target>
        </trans-unit>
        <trans-unit id="940a17c26916de1b6351b6066b3e6217426d4df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; array must be distinct from the &lt;code&gt;src&lt;/code&gt; array (they cannot alias each other).</source>
          <target state="translated">所述 &lt;code&gt;dest&lt;/code&gt; 阵列必须是从不同 &lt;code&gt;src&lt;/code&gt; 阵列（它们不能互为别名）。</target>
        </trans-unit>
        <trans-unit id="611e9863b6fe56ca0563d7d25daad5883ed6f0ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dir&lt;/code&gt; keyword argument can be used to specify a working directory for the command.</source>
          <target state="translated">该 &lt;code&gt;dir&lt;/code&gt; 关键字参数可以用来指定命令工作目录。</target>
        </trans-unit>
        <trans-unit id="a4bff47d996768873bcc39999935a98007b3cec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do x&lt;/code&gt; syntax creates an anonymous function with argument &lt;code&gt;x&lt;/code&gt; and passes it as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Similarly, &lt;code&gt;do a,b&lt;/code&gt; would create a two-argument anonymous function, and a plain &lt;code&gt;do&lt;/code&gt; would declare that what follows is an anonymous function of the form &lt;code&gt;() -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;do x&lt;/code&gt; 语法创建一个带有参数的匿名函数 &lt;code&gt;x&lt;/code&gt; ，并将其作为第一个参数&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;。类似地， &lt;code&gt;do a,b&lt;/code&gt; 将创建一个包含两个参数的匿名函数，而一个普通的 &lt;code&gt;do&lt;/code&gt; 将声明其后是形式为 &lt;code&gt;() -&amp;gt; ...&lt;/code&gt; 的匿名函数。</target>
        </trans-unit>
        <trans-unit id="38f76b197c154b053fc67ebe8a0b86d9c54ffd48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used. The condition expressions in the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; construct are evaluated until the first one evaluates to &lt;code&gt;true&lt;/code&gt;, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</source>
          <target state="translated">的 &lt;code&gt;elseif&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块是可选的，并且尽可能多的 &lt;code&gt;elseif&lt;/code&gt; 块可以根据需要使用。评估 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 构造中的条件表达式，直到第一个条件评估为 &lt;code&gt;true&lt;/code&gt; ，然后评估关联的块，并且不再评估其他条件表达式或块。</target>
        </trans-unit>
        <trans-unit id="dabea74759059aade9a04e98141814de885b1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; where the logging macro occurs in the source code.</source>
          <target state="translated">的 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; ，其中记录宏在源代码中发生。</target>
        </trans-unit>
        <trans-unit id="baef46876dcf6509194a8000268158d1d7c2494a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above &lt;code&gt;while&lt;/code&gt; loop does is so common, it can be expressed more concisely with a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 循环，使普通的重复评价的成语更容易编写。由于像上面的 &lt;code&gt;while&lt;/code&gt; 循环那样向上和向下计数非常普遍，因此可以使用 &lt;code&gt;for&lt;/code&gt; 循环更简洁地表示：</target>
        </trans-unit>
        <trans-unit id="ee6a3346a6698b43646ee623779b34ee8b0963c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grow&lt;/code&gt; keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &amp;lt; requested array size). Write privileges are required to grow the file.</source>
          <target state="translated">的 &lt;code&gt;grow&lt;/code&gt; 关键字参数指定的磁盘文件是否应该被生长，以适应阵列的所请求的大小（如果总文件大小是&amp;lt;请求数组的大小）。增长文件需要写特权。</target>
        </trans-unit>
        <trans-unit id="944e976cee83757342402d268820319c708e7f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello&lt;/code&gt; is the output of the &lt;code&gt;echo&lt;/code&gt; command, sent to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. The run method itself returns &lt;code&gt;nothing&lt;/code&gt;, and throws an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; if the external command fails to run successfully.</source>
          <target state="translated">该 &lt;code&gt;hello&lt;/code&gt; 是的输出 &lt;code&gt;echo&lt;/code&gt; 命令，发送到&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;。如果外部命令无法成功运行，则run方法本身不返回 &lt;code&gt;nothing&lt;/code&gt; ，并引发&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3728644266a88dfcc97848c625f08a3fe62768b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ipv6only&lt;/code&gt; parameter disables dual stack mode. If &lt;code&gt;ipv6only=true&lt;/code&gt;, only an IPv6 stack is created.</source>
          <target state="translated">所述 &lt;code&gt;ipv6only&lt;/code&gt; 参数禁用双栈模式。如果 &lt;code&gt;ipv6only=true&lt;/code&gt; ，则仅创建一个IPv6堆栈。</target>
        </trans-unit>
        <trans-unit id="9131ac4a45cc03434a2d1d252e0b9eb47948d016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt;th diagonal of a matrix, as a vector.</source>
          <target state="translated">矩阵的第 &lt;code&gt;k&lt;/code&gt; 个对角线，作为向量。</target>
        </trans-unit>
        <trans-unit id="586747034b4744d9048e093e3d358be130046659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; block creates a new variable &lt;code&gt;r&lt;/code&gt; whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automate the insertion of &lt;code&gt;let&lt;/code&gt; statements as in &lt;code&gt;abmult3&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;let&lt;/code&gt; 块创建一个新的变量 &lt;code&gt;r&lt;/code&gt; ，其范围是仅内部函数。第二种技术在存在捕获的变量的情况下恢复完整的语言性能。请注意，这是编译器的一个快速发展的方面，将来的发行版可能不需要这种程度的程序员注释即可获得性能。与此同时，像一些用户贡献的包&lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt;自动插入 &lt;code&gt;let&lt;/code&gt; 语句作为 &lt;code&gt;abmult3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404db33b1806403679f9afdc7e45d8ad145e7ae6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords can also be applied to destructuring assignments, e.g. &lt;code&gt;local x, y = 1, 2&lt;/code&gt;. In this case the keyword affects all listed variables.</source>
          <target state="translated">的 &lt;code&gt;local&lt;/code&gt; 和 &lt;code&gt;global&lt;/code&gt; 的关键字也能够适用于解构分配，例如 &lt;code&gt;local x, y = 1, 2&lt;/code&gt; 。在这种情况下，关键字会影响所有列出的变量。</target>
        </trans-unit>
        <trans-unit id="b4e455fac98bba78f84dcce75d6fd177f25053bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses are included.</source>
          <target state="translated">该 &lt;code&gt;loopback&lt;/code&gt; 关键字参数使然是否环回地址都包括在内。</target>
        </trans-unit>
        <trans-unit id="43f03591f994b72dda2b585d5125cc1a285cbfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; in which the logging macro was expanded.</source>
          <target state="translated">在其中扩展了日志记录宏的 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4522c3b2f49470689410e3676d64813c5ddeff60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt;-norm is defined as</source>
          <target state="translated">的 &lt;code&gt;p&lt;/code&gt; 范数被定义为</target>
        </trans-unit>
        <trans-unit id="98b88a0b1c328d1e6bd27b342609d1fb54652c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote&lt;/code&gt; function converts all its arguments to a common type &amp;ndash; in this case &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition, the &lt;code&gt;Point&lt;/code&gt; constructor promotes its arguments the same way that numeric operators like &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; do, and works for all kinds of real numbers:</source>
          <target state="translated">在 &lt;code&gt;promote&lt;/code&gt; 功能将其所有参数为通用类型-在这种情况下&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。使用此方法定义， &lt;code&gt;Point&lt;/code&gt; 构造函数以与&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;等数字运算符相同的方式提升其参数，并适用于各种实数：</target>
        </trans-unit>
        <trans-unit id="8297e1ed549bbae968b6d4d9056ddd08eaa6ab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote_rule&lt;/code&gt; function is used as a building block to define a second function called &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which, given any number of type objects, returns the common type to which those values, as arguments to &lt;code&gt;promote&lt;/code&gt; should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use &lt;code&gt;promote_type&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;promote_rule&lt;/code&gt; 函数被用作构建块来定义称为第二功能&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;，其中，给定任何数量的类型的对象，则返回普通型，其这些值，作为参数 &lt;code&gt;promote&lt;/code&gt; 应促进。因此，如果要在没有实际值的情况下知道某些类型的值的集合将提升为哪种类型，可以使用 &lt;code&gt;promote_type&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3b692555ebed7ff435cd42db277bcbc90f0f6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r&quot;...&quot;&lt;/code&gt; literal is constructed without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). Here is an example showing the difference from standard string literals:</source>
          <target state="translated">的 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; 的文字没有插值和转义构造（除了引号 &lt;code&gt;&quot;&lt;/code&gt; 仍具有转义）这里是示出从标准字符串文字的差异的例子：</target>
        </trans-unit>
        <trans-unit id="2a6072b422e59a959f8b81bd76474b677710288a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; Keyword</source>
          <target state="translated">在 &lt;code&gt;return&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="fbd3a71fad13cb9858c23c4a3ef4f996112c52ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_type_numeric&lt;/code&gt; function behaves much like the &lt;code&gt;same_type&lt;/code&gt; function defined above, but is only defined for pairs of numbers.</source>
          <target state="translated">所述 &lt;code&gt;same_type_numeric&lt;/code&gt; 函数的行为很像 &lt;code&gt;same_type&lt;/code&gt; 上面定义的函数，而是仅对于对数的定义。</target>
        </trans-unit>
        <trans-unit id="9fab5a03f87c103ae23a4670919e1023dea2f659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; keyword argument specifies whether the resulting &lt;code&gt;Array&lt;/code&gt; and changes made to it will be visible to other processes mapping the same file.</source>
          <target state="translated">所述 &lt;code&gt;shared&lt;/code&gt; 关键字参数指定是否将所得 &lt;code&gt;Array&lt;/code&gt; 向它提出和变化将是其他进程映射相同的文件可见。</target>
        </trans-unit>
        <trans-unit id="0931d123977915d4a1d899bba2683bbb5d1cf496" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shred&lt;/code&gt; keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to &lt;code&gt;false&lt;/code&gt; during testing.</source>
          <target state="translated">该 &lt;code&gt;shred&lt;/code&gt; 关键字控制在有效载荷证书字段的敏感信息是否应该被销毁。仅应在测试期间设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe58d87c8dd555b134b1d599492862c038b6d10f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 对象可以是任何对象，并且应该为每种可迭代类型选择适当的状态对象。有关定义自定义可迭代类型的更多详细信息，请参见&lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;迭代界面上&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="197a5a1cfcc6bf414db454749ace6bc6b46270e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transcode&lt;/code&gt; function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</source>
          <target state="translated">只要可以在目标编码中合理表示输入数据， &lt;code&gt;transcode&lt;/code&gt; 功能就会成功。对于UTF-XX编码之间的转换，即使对于无效的Unicode数据，它总是成功。</target>
        </trans-unit>
        <trans-unit id="25bce1e285bcf1b8934e0d8620acac52150b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement</source>
          <target state="translated">在 &lt;code&gt;try/catch&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="c2c1155010a79df372e519698f4e8f431ee252c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement allows for &lt;code&gt;Exception&lt;/code&gt;s to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a &lt;code&gt;try/catch&lt;/code&gt; block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a &lt;code&gt;try/catch&lt;/code&gt; block is much slower than using conditional branching to handle those situations. Below there are more examples of handling exceptions with a &lt;code&gt;try/catch&lt;/code&gt; block:</source>
          <target state="translated">在 &lt;code&gt;try/catch&lt;/code&gt; 语句允许 &lt;code&gt;Exception&lt;/code&gt; S代表进行测试，以及对事情通常会打破你的应用程序优雅地处理。例如，在下面的代码中，平方根函数通常会引发异常。通过在其周围放置一个 &lt;code&gt;try/catch&lt;/code&gt; 块，我们可以在此处减轻这种情况。您可以选择希望如何处理此异常，无论是记录它，返回占位符值还是在下面我们刚刚打印出一条语句的情况下。在决定如何处理意外情况时要考虑的一件事是，使用 &lt;code&gt;try/catch&lt;/code&gt; 块比使用条件分支处理那些情况要慢得多。下面有更多使用 &lt;code&gt;try/catch&lt;/code&gt; 处理异常的示例 块：</target>
        </trans-unit>
        <trans-unit id="8de2b2884ad5c0d59519c41370d411d31e17c8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">此函数上的 &lt;code&gt;unsafe&lt;/code&gt; 前缀表示未对指针 &lt;code&gt;p&lt;/code&gt; 进行任何验证以确保其有效。与C一样，使用不当可能会破坏程序或使程序出错。</target>
        </trans-unit>
        <trans-unit id="1ad1cf514621d9bd7509c63edb01e709a946f374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</source>
          <target state="translated">此函数上的 &lt;code&gt;unsafe&lt;/code&gt; 前缀表示未对指针 &lt;code&gt;p&lt;/code&gt; 进行任何验证以确保其有效。与C相同，使用不正确可能会导致程序段错误或返回垃圾答复。</target>
        </trans-unit>
        <trans-unit id="ffd2fc5d018bc4147802a9ab69acc1302211d9d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointers &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">此函数上的 &lt;code&gt;unsafe&lt;/code&gt; 前缀表示未对指针 &lt;code&gt;dest&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; 进行任何验证以确保它们有效。与C一样，使用不当可能会破坏程序或使程序出错。</target>
        </trans-unit>
        <trans-unit id="c545e57ea20b7dee78b3ead6faf2e0dd60dec4ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">此函数上的 &lt;code&gt;unsafe&lt;/code&gt; 前缀表示未执行任何验证以确保N是任一阵列上的入站。与C一样，使用不当可能会破坏程序或使程序出错。</target>
        </trans-unit>
        <trans-unit id="f4d657f988d9e3352165918f5b958ddc6e9310c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that using the result of this function after the &lt;code&gt;x&lt;/code&gt; argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</source>
          <target state="translated">此函数上的 &lt;code&gt;unsafe&lt;/code&gt; 前缀表示程序以后无法再访问该函数的 &lt;code&gt;x&lt;/code&gt; 参数之后使用此函数的结果可能会导致未定义的行为，包括程序损坏或段错误。</target>
        </trans-unit>
        <trans-unit id="1f00bb06127cf74d0a7a977235b45b41a807deea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;userdata&lt;/code&gt; field is used to store information for each worker by external managers.</source>
          <target state="translated">该 &lt;code&gt;userdata&lt;/code&gt; 字段用于存储由外部管理每个工人的信息。</target>
        </trans-unit>
        <trans-unit id="ea1c59c30ca45a88d468b07114183bcee1a4d149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword creates a type that is an iterated union of other types, over all values of some variable. For example &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; includes all &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt;s where the element type is some kind of &lt;code&gt;Real&lt;/code&gt; number.</source>
          <target state="translated">在 &lt;code&gt;where&lt;/code&gt; 关键字创建一个类型是其他类型的迭代结合，在一些变量的所有值。例如， &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; 包括元素类型为某种 &lt;code&gt;Real&lt;/code&gt; 数的所有&lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2963a52dada4be3a4b826619d947c135b0ff9a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</source>
          <target state="translated">在 &lt;code&gt;where&lt;/code&gt; 关键字本身可以被嵌套在一个更复杂的声明中。例如，考虑以下声明创建的两种类型：</target>
        </trans-unit>
        <trans-unit id="998cd2a7738c69cc615469e2df80e3038aa7e4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop evaluates the condition expression (&lt;code&gt;i &amp;lt;= 5&lt;/code&gt; in this case), and as long it remains &lt;code&gt;true&lt;/code&gt;, keeps also evaluating the body of the &lt;code&gt;while&lt;/code&gt; loop. If the condition expression is &lt;code&gt;false&lt;/code&gt; when the &lt;code&gt;while&lt;/code&gt; loop is first reached, the body is never evaluated.</source>
          <target state="translated">的 &lt;code&gt;while&lt;/code&gt; 循环计算的条件表达式（ &lt;code&gt;i &amp;lt;= 5&lt;/code&gt; 在这种情况下），并且只要它保持 &lt;code&gt;true&lt;/code&gt; ，保持还评估的主体 &lt;code&gt;while&lt;/code&gt; 循环。如果在第一次到达 &lt;code&gt;while&lt;/code&gt; 循环时条件表达式为 &lt;code&gt;false&lt;/code&gt; ，则永远不会对主体进行求值。</target>
        </trans-unit>
        <trans-unit id="c9eac2e060f4090d788f5a1733519b89ab4b4ae0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binomial coefficient&lt;/em&gt;$\binom{n}{k}$, being the coefficient of the $k$th term in the polynomial expansion of $(1+x)^n$.</source>
          <target state="translated">所述&lt;em&gt;二项式系数&lt;/em&gt; $ \ binom {N} {K} $，是的$ $ķ系数中的$多项式展开（1 + X）个术语^ N $。</target>
        </trans-unit>
        <trans-unit id="5f58dd4e346415c12b8a2bde13968a9b1deff1c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible.</source>
          <target state="translated">的&lt;em&gt;日志级别&lt;/em&gt;是一个广泛的类别为用于早期过滤所述消息。有几个&lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt; &lt;code&gt;LogLevel&lt;/code&gt; &lt;/a&gt;类型的标准级别；用户定义的级别也是可能的。</target>
        </trans-unit>
        <trans-unit id="31fe1c7ad22ee14f0705951a3acf51f247460513" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;show(io,mime,obj)&lt;/code&gt; according to the display capabilities of the installed logger.</source>
          <target state="translated">该&lt;em&gt;消息&lt;/em&gt;是描述事件的对象。按照惯例，假定作为消息传递的 &lt;code&gt;AbstractString&lt;/code&gt; s是markdown格式。根据安装的记录器的显示功能，将使用 &lt;code&gt;show(io,mime,obj)&lt;/code&gt; 显示其他类型。</target>
        </trans-unit>
        <trans-unit id="ff35386d12b40dc9ba6f11aed8e1486efcf6f63b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primary environment&lt;/em&gt;&amp;mdash;i.e. the first environment in a stack&amp;mdash;is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</source>
          <target state="translated">的&lt;em&gt;主环境&lt;/em&gt; -即在第一环境堆叠忠实地嵌入在堆叠环境。保证堆栈中第一个环境的完整依赖关系图完整地包含在包含所有依赖项的相同版本的堆叠环境中。</target>
        </trans-unit>
        <trans-unit id="f56a5c0b72490015a89e1c362931e81a9ffdc753" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called &lt;code&gt;x&lt;/code&gt; without the two &lt;code&gt;x&lt;/code&gt;'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</source>
          <target state="translated">变量的&lt;em&gt;范围&lt;/em&gt;是在其中可见变量的代码区域。变量作用域有助于避免变量命名冲突。这个概念很直观：两个函数都可以具有称为 &lt;code&gt;x&lt;/code&gt; 的参数，而两个 &lt;code&gt;x&lt;/code&gt; 都没有引用相同的事物。同样，在许多其他情况下，不同的代码块可以使用相同的名称而无需引用相同的内容。相同变量名称何时引用或不引用相同对象的规则称为作用域规则。本节详细说明了它们。</target>
        </trans-unit>
        <trans-unit id="e823801b39157cff5d7794c3183a7d1989add808" translate="yes" xml:space="preserve">
          <source>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the &lt;code&gt;Random&lt;/code&gt; module. For example, it's typically sufficient to implement one &lt;code&gt;rand&lt;/code&gt; method in order to have all other usual methods work automatically.</source>
          <target state="translated">用于1）的API的功能非常强大，但是相对而言是相对较新的，因此在随后的 &lt;code&gt;Random&lt;/code&gt; 模块发行版中可能仍需要改进。例如，通常只需实现一个 &lt;code&gt;rand&lt;/code&gt; 方法即可使所有其他常用方法自动工作。</target>
        </trans-unit>
        <trans-unit id="8ab319b5b160e68efa740a64380d05f1be87039a" translate="yes" xml:space="preserve">
          <source>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</source>
          <target state="translated">2)的API还很初级,可能需要实现者做更多的工作,而不是严格意义上的必要工作,以支持通常类型的生成值。</target>
        </trans-unit>
        <trans-unit id="2f9630cea145272914a5264c86a31f652e4069fa" translate="yes" xml:space="preserve">
          <source>The API is not clearly defined yet, but as a rule of thumb:</source>
          <target state="translated">API还没有明确的定义,但作为经验法则。</target>
        </trans-unit>
        <trans-unit id="a2cac855dd1e1320bc002428689d4b74c6a1a9ec" translate="yes" xml:space="preserve">
          <source>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produces the single byte 255. The Unicode escape &lt;code&gt;\u2200&lt;/code&gt; is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</source>
          <target state="translated">ASCII字符串&amp;ldquo; DATA&amp;rdquo;对应于字节 &lt;code&gt;\xff&lt;/code&gt; 。\ xff产生单个字节 &lt;code&gt;\u2200&lt;/code&gt; 转义\ u2200以UTF-8编码为三个字节226、136、128。请注意，结果字节数组与有效的UTF-8字符串不对应：</target>
        </trans-unit>
        <trans-unit id="39a538bac8d2eeb537bfbc18fea41895f84fba1e" translate="yes" xml:space="preserve">
          <source>The C &lt;code&gt;getenv&lt;/code&gt; function indicates an error by returning &lt;code&gt;NULL&lt;/code&gt;, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</source>
          <target state="translated">C &lt;code&gt;getenv&lt;/code&gt; 函数通过返回 &lt;code&gt;NULL&lt;/code&gt; 来指示错误，但是其他标准C函数通过各种不同的方式来指示错误，包括通过返回-1、0、1和其他特殊值。如果调用方尝试获取不存在的环境变量，则该包装器将引发异常，以明确指示问题：</target>
        </trans-unit>
        <trans-unit id="bb0be6121167f43ded0796e444ece3ab2ece1c9f" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable can only be used with corresponding input type declaration &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia, not C. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="translated">包装的C函数返回整数错误代码；Bessel J函数的实际求值结果将填充Julia数组 &lt;code&gt;result_array&lt;/code&gt; 。此变量只能与相应的输入类型声明 &lt;code&gt;Ref{Cdouble}&lt;/code&gt; ，因为其内存是由Julia而不是C分配和管理的。对&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt; &lt;/a&gt;的隐式调用将Julia指针解压缩为a Julia将数组数据结构转换为C可以理解的形式。</target>
        </trans-unit>
        <trans-unit id="e369993cdb5fa6e70590fdbba6d637a46744b422" translate="yes" xml:space="preserve">
          <source>The C null pointer constant, sometimes used when calling external code.</source>
          <target state="translated">C语言的空指针常量,有时在调用外部代码时使用。</target>
        </trans-unit>
        <trans-unit id="1266dcff3400e720f05ea76935c60007b496fe2d" translate="yes" xml:space="preserve">
          <source>The Darwin kernel descends from BSD, which means that &lt;code&gt;Sys.isbsd()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; on macOS systems. To exclude macOS from a predicate, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt;.</source>
          <target state="translated">Darwin内核源自BSD，这意味着 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 在macOS系统上为 &lt;code&gt;true&lt;/code&gt; 。要从谓词中排除macOS，请使用 &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d062d595ac22ed3de2b1695d4234bbdd4c8970f" translate="yes" xml:space="preserve">
          <source>The Examples folder &lt;code&gt;clustermanager/simple&lt;/code&gt; is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</source>
          <target state="translated">示例文件夹 &lt;code&gt;clustermanager/simple&lt;/code&gt; 是一个示例，显示了使用UNIX域套接字进行群集设置的简单实现。</target>
        </trans-unit>
        <trans-unit id="47538569b998ba670f072a1e4a838d9065a41d8f" translate="yes" xml:space="preserve">
          <source>The GC can be allowed to deallocate a variable by removing the reference to it from &lt;code&gt;refs&lt;/code&gt; using the function &lt;code&gt;delete!&lt;/code&gt;, provided that no other reference to the variable is kept anywhere:</source>
          <target state="translated">GC能够被允许通过从引用来解除分配变量 &lt;code&gt;refs&lt;/code&gt; 使用函数 &lt;code&gt;delete!&lt;/code&gt; ，前提是该变量的任何其他引用都不能保留在任何地方：</target>
        </trans-unit>
        <trans-unit id="9114ec3ce1d9b68ea428c28233e88219f98a90cb" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="translated">仅当分配了Julia对象时，GC才能运行。诸如 &lt;code&gt;jl_box_float64&lt;/code&gt; 之类的调用执行分配，并且分配也可能在运行Julia代码的任何时候发生。但是，通常在 &lt;code&gt;jl_...&lt;/code&gt; 调用之间使用指针是安全的。但是为了确保值可以在 &lt;code&gt;jl_...&lt;/code&gt; 调用中保留下来，我们必须告诉Julia我们持有对Julia值的引用。可以使用 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 宏完成此操作：</target>
        </trans-unit>
        <trans-unit id="4c26097947d8e62d93e95f7bb8a753aa81198a0d" translate="yes" xml:space="preserve">
          <source>The Julia REPL</source>
          <target state="translated">Julia REPL</target>
        </trans-unit>
        <trans-unit id="966cbe6fa0ef45947b54d91f086e0f21369273f7" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).</source>
          <target state="translated">Julia REPL充分利用了键绑定。上面已经介绍了几个控制键绑定（ &lt;code&gt;^D&lt;/code&gt; 退出， &lt;code&gt;^R&lt;/code&gt; 和 &lt;code&gt;^S&lt;/code&gt; 搜索），但还有更多。除了Control键之外，还有meta键绑定。这些因平台而异，但是大多数终端默认使用按住Alt键或Option键的同时发送键（或可以配置为发送元键）。</target>
        </trans-unit>
        <trans-unit id="78a8d27e5d46846612931d336af5427fb48eaefb" translate="yes" xml:space="preserve">
          <source>The Julia internal variable &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt;&lt;code&gt;Sys.WORD_SIZE&lt;/code&gt;&lt;/a&gt; indicates whether the target system is 32-bit or 64-bit:</source>
          <target state="translated">Julia内部变量&lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt; &lt;code&gt;Sys.WORD_SIZE&lt;/code&gt; &lt;/a&gt;指示目标系统是32位还是64位：</target>
        </trans-unit>
        <trans-unit id="1693b1af11374cde64dabe11066916f7ee8e88c7" translate="yes" xml:space="preserve">
          <source>The Julia process running the driver script in the example above has an &lt;code&gt;id&lt;/code&gt; equal to 1, just like a process providing an interactive prompt.</source>
          <target state="translated">上面示例中运行驱动程序脚本的Julia进程的 &lt;code&gt;id&lt;/code&gt; 等于1，就像提供交互式提示的进程一样。</target>
        </trans-unit>
        <trans-unit id="aa8416476707db541c2333530ff960a4433eec90" translate="yes" xml:space="preserve">
          <source>The Julian mode</source>
          <target state="translated">朱利安模式</target>
        </trans-unit>
        <trans-unit id="65c675577bb25cbb84233bfad40ea840727c87ba" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;.</source>
          <target state="translated">LQ分解是 &lt;code&gt;transpose(A)&lt;/code&gt; 的QR分解。</target>
        </trans-unit>
        <trans-unit id="b05b84454661b0ad77fcf176c57484bf1c0a4367" translate="yes" xml:space="preserve">
          <source>The LibGit2 module provides bindings to &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;, a portable C library that implements core functionality for the &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package.</source>
          <target state="translated">LibGit2模块提供对&lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2的&lt;/a&gt;绑定，libgit2是可移植的C库，可为&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;版本控制系统实现核心功能。这些绑定当前用于驱动Julia的软件包管理器。预计该模块最终将移至单独的程序包中。</target>
        </trans-unit>
        <trans-unit id="9bf2cc298d975bbd37b6f7fd047fb42694bf8a90" translate="yes" xml:space="preserve">
          <source>The MethodInstance containing the execution context (if it could be found).</source>
          <target state="translated">包含执行上下文的MethodInstance(如果可以找到的话)。</target>
        </trans-unit>
        <trans-unit id="09f175ba6c5dae9885fb192f636fd6ea181b8da1" translate="yes" xml:space="preserve">
          <source>The MultiSelectMenu allows users to select many choices from a list.</source>
          <target state="translated">多重选择菜单(MultiSelectMenu)允许用户从一个列表中选择许多选择。</target>
        </trans-unit>
        <trans-unit id="e79dc73e951d809603b22dcb8e0be503a1e70e20" translate="yes" xml:space="preserve">
          <source>The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like &lt;code&gt;$|&lt;/code&gt; (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation &lt;em&gt;does&lt;/em&gt; occur:</source>
          <target state="translated">Perl表达式需要用单引号引起，这有两个原因：使得空格不会将表达式分成多个shell单词，以及使用Perl变量，例如 &lt;code&gt;$|&lt;/code&gt; （是的，这就是Perl中变量的名称），不要引起插值。在其他情况下，你可能想使插值用双引号&lt;em&gt;确实&lt;/em&gt;会发生：</target>
        </trans-unit>
        <trans-unit id="ac56e6a222fd8496371258c1e3e6d866939f3927" translate="yes" xml:space="preserve">
          <source>The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt;. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.</source>
          <target state="translated">REPL具有四种主要操作模式。第一个也是最常见的是朱利安提示。这是默认的操作模式。每条新行最初 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 开头。您可以在此处输入Julia表达式。输入完整表达式后，按回车或回车将评估该输入并显示最后一个表达式的结果。</target>
        </trans-unit>
        <trans-unit id="7b885d623b0799b11114ac06066f9470abd82025" translate="yes" xml:space="preserve">
          <source>The RadioMenu allows the user to select one option from the list. The &lt;code&gt;request&lt;/code&gt; function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or &lt;code&gt;ctrl-c&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt; will return a &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">RadioMenu允许用户从列表中选择一个选项。的 &lt;code&gt;request&lt;/code&gt; 功能显示交互菜单并返回所选择的选择的索引。如果用户按下'q'或 &lt;code&gt;ctrl-c&lt;/code&gt; ，则 &lt;code&gt;request&lt;/code&gt; 将返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59e9b2d3e677af4a8fc2eebaa65445429cdf1c63" translate="yes" xml:space="preserve">
          <source>The Statistics module contains basic statistics functionality.</source>
          <target state="translated">统计模块包含基本的统计功能。</target>
        </trans-unit>
        <trans-unit id="05d7e2a5c0d018541c4ea58100e6545824bf9830" translate="yes" xml:space="preserve">
          <source>The ability to define function behavior across many combinations of argument types via &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;</source>
          <target state="translated">通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;多次分派&lt;/a&gt;在众多参数类型组合中定义函数行为的能力</target>
        </trans-unit>
        <trans-unit id="8cbecc736377010eae111d725b15330296dbcf5e" translate="yes" xml:space="preserve">
          <source>The above cross referencing is &lt;em&gt;not&lt;/em&gt; a Markdown feature, and relies on &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;, which is used to build base Julia's documentation.</source>
          <target state="translated">上面的交叉引用&lt;em&gt;不是&lt;/em&gt; Markdown功能，&lt;em&gt;而是&lt;/em&gt;依赖于&lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;，该文件用于构建基本Julia的文档。</target>
        </trans-unit>
        <trans-unit id="96d64d7232abba83a2151348646c44806eda095b" translate="yes" xml:space="preserve">
          <source>The above mentioned functions can then be used to perform the queries:</source>
          <target state="translated">然后可以利用上述功能进行查询。</target>
        </trans-unit>
        <trans-unit id="b1864a2a8cdc1de40a1915df6dd632015d943dc9" translate="yes" xml:space="preserve">
          <source>The above results are all &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. Literal &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; values can be entered by writing an &lt;code&gt;f&lt;/code&gt; in place of &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">以上结果均为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值。可以使用 &lt;code&gt;f&lt;/code&gt; 代替 &lt;code&gt;e&lt;/code&gt; 来输入文字&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="8361f38beb9f62ba5d41300ac34886cea61348b7" translate="yes" xml:space="preserve">
          <source>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</source>
          <target state="translated">上述语法增强功能显著降低了书写常见数学公式时产生的视觉噪音。需要注意的是,数字字面系数与它所乘的标识符或括号内的表达式之间不得有空格。</target>
        </trans-unit>
        <trans-unit id="60fe34a8f000c3fae237bc0700dfba4695829533" translate="yes" xml:space="preserve">
          <source>The above would transfer &lt;code&gt;foo&lt;/code&gt; only once to each worker.</source>
          <target state="translated">上面只会将 &lt;code&gt;foo&lt;/code&gt; 一次转移给每个工人。</target>
        </trans-unit>
        <trans-unit id="b269bbaa9bb906bbb27460a932677dba11288dd6" translate="yes" xml:space="preserve">
          <source>The absolute path &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; of the REPL's history file. If &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; is not set, then &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defaults to</source>
          <target state="translated">REPL历史记录文件的绝对路径 &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; 。如果未设置 &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; ，则 &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; 默认为</target>
        </trans-unit>
        <trans-unit id="3648e183f2c998051f65ea547854578d5a18dead" translate="yes" xml:space="preserve">
          <source>The absolute path of the directory containing the Julia executable, which sets the global variable &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt;&lt;code&gt;Sys.BINDIR&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; is not set, then Julia determines the value &lt;code&gt;Sys.BINDIR&lt;/code&gt; at run-time.</source>
          <target state="translated">包含Julia可执行文件的目录的绝对路径，该目录设置全局变量&lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt; &lt;code&gt;Sys.BINDIR&lt;/code&gt; &lt;/a&gt;。如果未设置 &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; ，则Julia 在运行时确定值 &lt;code&gt;Sys.BINDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8927a0d24697e123dd4df5a3afe112eef67df6d2" translate="yes" xml:space="preserve">
          <source>The absolute path of the shell with which Julia should execute external commands (via &lt;code&gt;Base.repl_cmd()&lt;/code&gt;). Defaults to the environment variable &lt;code&gt;$SHELL&lt;/code&gt;, and falls back to &lt;code&gt;/bin/sh&lt;/code&gt; if &lt;code&gt;$SHELL&lt;/code&gt; is unset.</source>
          <target state="translated">Julia应该用来执行外部命令的外壳程序的绝对路径（通过 &lt;code&gt;Base.repl_cmd()&lt;/code&gt; ）。默认为环境变量 &lt;code&gt;$SHELL&lt;/code&gt; ，如果未设置 &lt;code&gt;$SHELL&lt;/code&gt; 则回退到 &lt;code&gt;/bin/sh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb992db79bc340c73f7d0c78a81caf2c5fb6b5d" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的绝对值。</target>
        </trans-unit>
        <trans-unit id="8cc93eeda62c80f4972fdd152957671d0189f643" translate="yes" xml:space="preserve">
          <source>The abstract supertype of all enumerated types defined with &lt;a href=&quot;#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt;定义的所有枚举类型的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="580f4961193cdce395b23ec3d5fef77701e0ce25" translate="yes" xml:space="preserve">
          <source>The actual body of the function is a single &lt;code&gt;leaq&lt;/code&gt; instruction, which computes the integer multiply and add at once. This is even more beneficial when &lt;code&gt;f&lt;/code&gt; gets inlined into another function:</source>
          <target state="translated">该函数的实际主体是单个 &lt;code&gt;leaq&lt;/code&gt; 指令，该指令可立即计算整数乘法和加法。当 &lt;code&gt;f&lt;/code&gt; 内联到另一个函数中时，这将更加有益：</target>
        </trans-unit>
        <trans-unit id="b18e2a05bc75f9cb445304a890f63b9983ea2e1c" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="translated">Julia Base 中 &lt;code&gt;@assert&lt;/code&gt; 的实际定义更为复杂。它允许用户有选择地指定他们自己的错误消息，而不仅仅是打印失败的表达式。就像在具有可变数量的参数的函数（&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;）中一样，此函数在最后一个参数之后用省略号指定：</target>
        </trans-unit>
        <trans-unit id="3249b07e810b7bf455aef815d32c41a4e16eda1a" translate="yes" xml:space="preserve">
          <source>The addition of a &lt;code&gt;Date&lt;/code&gt; with a &lt;code&gt;Time&lt;/code&gt; produces a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;Time&lt;/code&gt; are used along with the year, month, and day of the &lt;code&gt;Date&lt;/code&gt; to create the new &lt;code&gt;DateTime&lt;/code&gt;. Non-zero microseconds or nanoseconds in the &lt;code&gt;Time&lt;/code&gt; type will result in an &lt;code&gt;InexactError&lt;/code&gt; being thrown.</source>
          <target state="translated">将 &lt;code&gt;Date&lt;/code&gt; 与 &lt;code&gt;Time&lt;/code&gt; 相加会生成 &lt;code&gt;DateTime&lt;/code&gt; 。时，分，秒和毫秒部分的 &lt;code&gt;Time&lt;/code&gt; 都用年，月，和天一起使用 &lt;code&gt;Date&lt;/code&gt; 创建新 &lt;code&gt;DateTime&lt;/code&gt; 。 &lt;code&gt;Time&lt;/code&gt; 类型中的非零微秒或纳秒将导致引发 &lt;code&gt;InexactError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e0f2aeb81b016f9f8ad15cc7fa177089d4b107f" translate="yes" xml:space="preserve">
          <source>The advantage is that your testing code is now contained in a module and does not use the global scope in &lt;code&gt;Main&lt;/code&gt; for definitions, which is a bit more tidy.</source>
          <target state="translated">优点是您的测试代码现在包含在一个模块中，并且不使用 &lt;code&gt;Main&lt;/code&gt; 中的全局范围进行定义，这更加整洁。</target>
        </trans-unit>
        <trans-unit id="f20a70b4f6a41daccbadde162c2965a4719810ba" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;itr&lt;/code&gt; 的每个条目都是从该生成分布得出的IID 的假设下，该算法返回生成分布的标准偏差的估计量。对于数组，此计算等效于计算 &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt; 。如果 &lt;code&gt;corrected&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，则总和被按比例与 &lt;code&gt;n-1&lt;/code&gt; 个，而该和与缩放 &lt;code&gt;n&lt;/code&gt; 如果 &lt;code&gt;corrected&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 同 &lt;code&gt;n&lt;/code&gt; 中元素的数量 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5d718f1e39513cb56beb2116bcad02f80b82c53" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;true&lt;code&gt;, then the sum is scaled with&lt;/code&gt;n-1&lt;code&gt;, whereas the sum is scaled with&lt;/code&gt;n&lt;code&gt;if&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;false&lt;code&gt;with&lt;/code&gt;n&lt;code&gt;the number of elements in&lt;/code&gt;itr`.</source>
          <target state="translated">在 &lt;code&gt;itr&lt;/code&gt; 的每个条目都是从该生成分布得出的IID 的假设下，该算法返回生成分布的方差的估计量。对于数组，此计算等效于计算 &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt; 校正 &lt;code&gt;is&lt;/code&gt; 真 &lt;code&gt;, then the sum is scaled with&lt;/code&gt; n-1个 &lt;code&gt;, whereas the sum is scaled with&lt;/code&gt; &amp;Ntilde; &lt;code&gt;if&lt;/code&gt; 纠正 &lt;code&gt;is&lt;/code&gt; 假 &lt;code&gt;with&lt;/code&gt; &amp;Ntilde; &lt;code&gt;the number of elements in&lt;/code&gt; itr`。</target>
        </trans-unit>
        <trans-unit id="01293a961a773cd4d130208dbabeea56d0a5c61c" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;itr&lt;/code&gt; 的每个条目都是从该生成分布得出的IID 的假设下，该算法返回生成分布的方差的估计量。对于数组，此计算等效于计算 &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt; 。如果 &lt;code&gt;corrected&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，则总和被按比例与 &lt;code&gt;n-1&lt;/code&gt; 个，而该和与缩放 &lt;code&gt;n&lt;/code&gt; 如果 &lt;code&gt;corrected&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 同 &lt;code&gt;n&lt;/code&gt; 中元素的数量 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac2877c35123766a145f522e7dfc5430f0ca77c" translate="yes" xml:space="preserve">
          <source>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in &lt;code&gt;vertcat(A{:})&lt;/code&gt; in MATLAB, is written using the splat operator in Julia, e.g. as &lt;code&gt;vcat(A...)&lt;/code&gt;.</source>
          <target state="translated">使用Julia中的splat运算符 &lt;code&gt;vcat(A...)&lt;/code&gt; 例如vcat（A ...））来提取（或&amp;ldquo;解引用&amp;rdquo;）单元数组的所有元素（例如在 &lt;code&gt;vertcat(A{:})&lt;/code&gt; 中）的类似物。</target>
        </trans-unit>
        <trans-unit id="f3f2e21d1a797762aaea13aa49c6c7d374ab6e23" translate="yes" xml:space="preserve">
          <source>The annotation &lt;code&gt;@fastmath&lt;/code&gt; re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression &lt;code&gt;1 / (2*dx)&lt;/code&gt; in the function &lt;code&gt;deriv&lt;/code&gt; is hoisted out of the loop (i.e. calculated outside the loop), as if one had written &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt;. In the loop, the expression &lt;code&gt;... / (2*dx)&lt;/code&gt; then becomes &lt;code&gt;... * idx&lt;/code&gt;, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">注释 &lt;code&gt;@fastmath&lt;/code&gt; 重新排列了浮点表达式，例如，更改了求值顺序，或者假设某些特殊情况（inf，nan）不会发生。在这种情况下（以及在这台特定的计算机上），主要区别在于函数 &lt;code&gt;deriv&lt;/code&gt; 中的表达式 &lt;code&gt;1 / (2*dx)&lt;/code&gt; 被提升到循环之外（即，在循环外部计算），就像一个人写了 &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt; 。在循环中，表达式 &lt;code&gt;... / (2*dx)&lt;/code&gt; 然后变为 &lt;code&gt;... * idx&lt;/code&gt; ，评估起来要快得多。当然，编译器进行的实际优化以及最终的提速很大程度上取决于硬件。您可以使用Julia的&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt;函数检查生成的代码中的更改。</target>
        </trans-unit>
        <trans-unit id="91407676de179a11323fecebc90b0b28f6220397" translate="yes" xml:space="preserve">
          <source>The application also depends on the &lt;code&gt;Pub&lt;/code&gt; package, which in turn depends on the public &lt;code&gt;Priv&lt;/code&gt; and the same &lt;code&gt;Zebra&lt;/code&gt; package that the private &lt;code&gt;Priv&lt;/code&gt; package depends on.</source>
          <target state="translated">该应用程序还取决于 &lt;code&gt;Pub&lt;/code&gt; 包，而Pub包又取决于公共 &lt;code&gt;Priv&lt;/code&gt; 和私有 &lt;code&gt;Priv&lt;/code&gt; 包所依赖的同一 &lt;code&gt;Zebra&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="d108508038e64416f7594e79cff0ba0d5c60ed1c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;A&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;ldiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">该参数 &lt;code&gt;A&lt;/code&gt; 应该&lt;em&gt;不会&lt;/em&gt;是一个矩阵。相反，应该是分解对象（例如，由&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; 生成&lt;/a&gt;）而不是矩阵。这样做的原因是分解本身既昂贵又通常分配内存（尽管也可以通过例如&lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt;就地完成），以及对性能要求 &lt;code&gt;ldiv!&lt;/code&gt; 情况需要ldiv!。通常还需要对 &lt;code&gt;A&lt;/code&gt; 的分解进行细粒度控制。</target>
        </trans-unit>
        <trans-unit id="8ba5f6815e327ac58578c3c74637303b6ebdc780" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;B&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;rdiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">这个论点 &lt;code&gt;B&lt;/code&gt; 应该&lt;em&gt;不&lt;/em&gt;是一个矩阵。相反，应该是分解对象（例如，由&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; 生成&lt;/a&gt;）而不是矩阵。这样做的原因是分解本身既昂贵又通常分配内存（尽管也可以通过例如&lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt;就地完成），以及对性能有严格要求的情况需要 &lt;code&gt;rdiv!&lt;/code&gt; 。通常还需要对 &lt;code&gt;B&lt;/code&gt; 的分解进行细粒度控制。</target>
        </trans-unit>
        <trans-unit id="f6947ba42284e98465ca0fe899c7260684fa80d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__module__&lt;/code&gt; provides information (in the form of a &lt;code&gt;Module&lt;/code&gt; object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</source>
          <target state="translated">&lt;code&gt;__module__&lt;/code&gt; 参数提供有关宏调用的扩展上下文的信息（以 &lt;code&gt;Module&lt;/code&gt; 对象的形式）。这允许宏查找上下文信息（例如现有绑定），或将值插入为运行时函数调用的附加参数，以在当前模块中进行自反射。</target>
        </trans-unit>
        <trans-unit id="118cff9af4b8de3b0527244748b6b6cdd9ccdeb6" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__source__&lt;/code&gt; provides information (in the form of a &lt;code&gt;LineNumberNode&lt;/code&gt; object) about the parser location of the &lt;code&gt;@&lt;/code&gt; sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt;&lt;code&gt;@__LINE__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt;&lt;code&gt;@__DIR__&lt;/code&gt;&lt;/a&gt; macros.</source>
          <target state="translated">自变量 &lt;code&gt;__source__&lt;/code&gt; 提供有关宏调用中 &lt;code&gt;@&lt;/code&gt; 符号的解析器位置的信息（以 &lt;code&gt;LineNumberNode&lt;/code&gt; 对象的形式）。这使宏可以包括更好的错误诊断信息，并且通常用于日志记录，字符串解析器宏和docs，以及用于实现&lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt; &lt;code&gt;@__LINE__&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt; &lt;code&gt;@__DIR__&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="28332afec21b48c8f9eedddb529063711d48dde4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;val&lt;/code&gt; to a function or constructor is outside the valid domain.</source>
          <target state="translated">函数或构造函数的参数 &lt;code&gt;val&lt;/code&gt; 在有效域之外。</target>
        </trans-unit>
        <trans-unit id="c5eb1e5a4cdcda6110ebd89f0ecb14ceede7e9cb" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;left&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">该参数位于矩阵矩阵操作的&lt;em&gt;左侧&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7b59a99385d1b11a2ad5b866d4ec7b5957c8ab4c" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;right&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">该参数位于矩阵矩阵运算的&lt;em&gt;右侧&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="884d75c174d0479198ef02863fa90299587b8335" translate="yes" xml:space="preserve">
          <source>The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)</source>
          <target state="translated">阵列数据必须以二进制格式表示(例如,不支持CSV等ASCII格式)。</target>
        </trans-unit>
        <trans-unit id="b10872dab02eb4daf575beb40c2f7b4e9635a0b7" translate="yes" xml:space="preserve">
          <source>The asserted condition did not evaluate to &lt;code&gt;true&lt;/code&gt;. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">断言的条件未达到 &lt;code&gt;true&lt;/code&gt; 。可选参数 &lt;code&gt;msg&lt;/code&gt; 是描述性错误字符串。</target>
        </trans-unit>
        <trans-unit id="9ef046749eb00971a20635012815c9aa3fe8e4de" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt; since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage. Here is an example where the behavior of &lt;code&gt;let&lt;/code&gt; is needed:</source>
          <target state="translated">在引入左侧的新变量之前，将按顺序评估分配，并在范围中评估每个右侧。因此，写出 &lt;code&gt;let x = x&lt;/code&gt; 类的东西很有意义，因为两个 &lt;code&gt;x&lt;/code&gt; 变量是不同的并且具有独立的存储。这是一个需要 &lt;code&gt;let&lt;/code&gt; 行为的示例：</target>
        </trans-unit>
        <trans-unit id="332e2ebabecf595b9a10dedb9752fafc32737dcf" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt;, since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage.</source>
          <target state="translated">在引入左侧的新变量之前，将按顺序评估分配，并在范围中评估每个右侧。因此，写出 &lt;code&gt;let x = x&lt;/code&gt; 这样的东西是有意义的，因为两个 &lt;code&gt;x&lt;/code&gt; 变量是不同的并且具有独立的存储。</target>
        </trans-unit>
        <trans-unit id="cb5c5acb0ed1217a3a242c8796f09db063ffe31c" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like &lt;code&gt;-&lt;/code&gt; because it is undefined whether &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; should be evaluated as &lt;code&gt;(1-2)-3&lt;/code&gt; or &lt;code&gt;1-(2-3)&lt;/code&gt;. Use &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity.</source>
          <target state="translated">简化的关联性取决于实现。这意味着您不能使用像 &lt;code&gt;-&lt;/code&gt; 这样的非关联操作，因为未定义 &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; 应该被评估为 &lt;code&gt;(1-2)-3&lt;/code&gt; 还是 &lt;code&gt;1-(2-3)&lt;/code&gt; 。请使用&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; &lt;/a&gt;来确保左或右的关联性。</target>
        </trans-unit>
        <trans-unit id="8e83411f941380eef1e4e97a62a5d00092492f0f" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of &lt;code&gt;f&lt;/code&gt; for elements that appear multiple times in &lt;code&gt;itr&lt;/code&gt;. Use &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity and invocation of &lt;code&gt;f&lt;/code&gt; for every value.</source>
          <target state="translated">减少的关联性取决于实现。另外，某些实现可能会将 &lt;code&gt;f&lt;/code&gt; 的返回值重用于在 &lt;code&gt;itr&lt;/code&gt; 中多次出现的元素。请使用&lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldl&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldr&lt;/code&gt; &lt;/a&gt;来保证左或右的关联性，并为每个值调用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa2ffdac4b6b173468c64bdf00df48adef8f3782" translate="yes" xml:space="preserve">
          <source>The available color keys can be seen by typing &lt;code&gt;Base.text_colors&lt;/code&gt; in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.</source>
          <target state="translated">通过在REPL的帮助模式下键入 &lt;code&gt;Base.text_colors&lt;/code&gt; 可以看到可用的颜色键。此外，整数0到255可用作支持256色支持的终端的颜色键。</target>
        </trans-unit>
        <trans-unit id="d6514960ce535f34b9eb969fcb1b4f9c39742102" translate="yes" xml:space="preserve">
          <source>The base Julia installation has in-built support for two types of clusters:</source>
          <target state="translated">基本的Julia安装有两种类型的集群的内置支持。</target>
        </trans-unit>
        <trans-unit id="562f643f12db492fbdb1e985351909d826402fa4" translate="yes" xml:space="preserve">
          <source>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</source>
          <target state="translated">基本的Julia运行时只提供纯文本显示,但更丰富的显示可以通过加载外部模块或使用图形化的Julia环境(如基于IPython的IJulia笔记本)来实现。</target>
        </trans-unit>
        <trans-unit id="002dc05c0d427615b628a5faca800a873b359de7" translate="yes" xml:space="preserve">
          <source>The base array type in Julia is the abstract type &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray{T,N}&lt;/code&gt;&lt;/a&gt;. It is parameterized by the number of dimensions &lt;code&gt;N&lt;/code&gt; and the element type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt;&lt;code&gt;AbstractVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt;&lt;code&gt;AbstractMatrix&lt;/code&gt;&lt;/a&gt; are aliases for the 1-d and 2-d cases. Operations on &lt;code&gt;AbstractArray&lt;/code&gt; objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</source>
          <target state="translated">Julia中的基本数组类型是抽象类型&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; &lt;/a&gt;。它由维数 &lt;code&gt;N&lt;/code&gt; 和元素类型 &lt;code&gt;T&lt;/code&gt; 参数化。&lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt; &lt;code&gt;AbstractVector&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt; &lt;code&gt;AbstractMatrix&lt;/code&gt; &lt;/a&gt;是1-d和2-d情况的别名。上的操作 &lt;code&gt;AbstractArray&lt;/code&gt; 对象定义使用较高级别运算符和函数，在某种程度上独立于底层存储的。这些操作通常可以正常工作，作为任何特定阵列实现的后备。</target>
        </trans-unit>
        <trans-unit id="b29d93a344c231f0373e8777552dd842d0c0ae6b" translate="yes" xml:space="preserve">
          <source>The base library of Julia. &lt;code&gt;Base&lt;/code&gt; is a module that contains basic functionality (the contents of &lt;code&gt;base/&lt;/code&gt;). All modules implicitly contain &lt;code&gt;using Base&lt;/code&gt;, since this is needed in the vast majority of cases.</source>
          <target state="translated">朱莉娅的基础库。 &lt;code&gt;Base&lt;/code&gt; 是包含基本功能（ &lt;code&gt;base/&lt;/code&gt; 的内容）的模块。所有模块都隐式包含 &lt;code&gt;using Base&lt;/code&gt; ，因为在大多数情况下都需要使用Base。</target>
        </trans-unit>
        <trans-unit id="f9d1c85fa2408916e8a238b5528b77d6327d21e9" translate="yes" xml:space="preserve">
          <source>The basic function for waiting for an event is &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. Several objects implement &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;; for example, given a &lt;code&gt;Process&lt;/code&gt; object, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; will wait for it to exit. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is often implicit; for example, a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; can happen inside a call to &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; to wait for data to be available.</source>
          <target state="translated">等待事件的基本功能是&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;。几个对象实施&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ; 例如，给定一个 &lt;code&gt;Process&lt;/code&gt; 对象，&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;将等待它退出。&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;通常是隐含的；例如，在调用中可能发生&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，以等待&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;数据。</target>
        </trans-unit>
        <trans-unit id="38afa5a3f5d12c0c2e4c45c469ff70f9f6584c66" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="translated">基本语法很简单：出现在对象（函数，宏，类型或实例）之前的最顶层的任何字符串都将被解释为对其进行记录（称为&lt;em&gt;docstrings&lt;/em&gt;）。请注意，在文档字符串和已记录的对象之间不得插入任何空白行或注释。这是一个基本示例：</target>
        </trans-unit>
        <trans-unit id="3e6788f6ee76ef14250b1c48634160dc28850751" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;missing&lt;/code&gt; values follows one basic rule: &lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 值的行为遵循一个基本规则： &lt;code&gt;missing&lt;/code&gt; 值传递给标准运算符和函数（尤其是数学函数）时会自动&lt;em&gt;传播&lt;/em&gt;。操作数之一的值不确定会导致结果不确定。实际上，这意味着涉及 &lt;code&gt;missing&lt;/code&gt; 值的操作通常会返回 &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e648e6d6c87b02acc6c1db84cf592e9a9a93a8" translate="yes" xml:space="preserve">
          <source>The behavior of the logical &quot;and&quot; operator &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; is similar to that of the &lt;code&gt;|&lt;/code&gt; operator, with the difference that missingness does not propagate when one of the operands is &lt;code&gt;false&lt;/code&gt;. For example, when that is the case of the first operand</source>
          <target state="translated">逻辑&amp;ldquo;和&amp;rdquo;运算符&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;的行为与 &lt;code&gt;|&lt;/code&gt; 相似。运算符，区别在于当其中一个操作数为 &lt;code&gt;false&lt;/code&gt; 时缺失不会传播。例如，在第一个操作数的情况下</target>
        </trans-unit>
        <trans-unit id="7b67ccc64e36fcf07f7c05aa43c8c2a633077f18" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="translated">最好的办法是避免定义&lt;em&gt;两种&lt;/em&gt;这些方法：相反，依赖于一个通用的方法 &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; ，并确保这种方法与一般的调用来实现（像 &lt;code&gt;similar&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; ），对于做正确的事每个容器类型和元素类型&lt;em&gt;分别&lt;/em&gt;。这只是使您的方法&lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;正交&lt;/a&gt;的建议的更复杂的变体。</target>
        </trans-unit>
        <trans-unit id="d958f10307af7b028b81ab80b4d640f64af23b08" translate="yes" xml:space="preserve">
          <source>The better design would be to define your call hierarchy like this:</source>
          <target state="translated">更好的设计应该是这样定义你的调用层次结构。</target>
        </trans-unit>
        <trans-unit id="3983e66c166493bdb9b9e27ea74aedeb9d2d8cf1" translate="yes" xml:space="preserve">
          <source>The biggest advantage of &lt;code&gt;advection_shared!&lt;/code&gt; is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</source>
          <target state="translated">&lt;code&gt;advection_shared!&lt;/code&gt; 的最大优势！这样做是为了最大程度地减少工作人员之间的通信量，从而使每个人都可以在分配的工件上进行较长时间的计算。</target>
        </trans-unit>
        <trans-unit id="194659e7083e920d17f0c59327a653e32e8cfe4a" translate="yes" xml:space="preserve">
          <source>The binary operator &lt;code&gt;&amp;asymp;&lt;/code&gt; is equivalent to &lt;code&gt;isapprox&lt;/code&gt; with the default arguments, and &lt;code&gt;x ≉ y&lt;/code&gt; is equivalent to &lt;code&gt;!isapprox(x,y)&lt;/code&gt;.</source>
          <target state="translated">二进制运算符 &lt;code&gt;&amp;asymp;&lt;/code&gt; 等效于具有默认参数的 &lt;code&gt;isapprox&lt;/code&gt; ， &lt;code&gt;x ≉ y&lt;/code&gt; 等效于 &lt;code&gt;!isapprox(x,y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ba294c6e25bcc46b7feed1d1a73c0b3e0ef49e3" translate="yes" xml:space="preserve">
          <source>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</source>
          <target state="translated">空行上其实有空格。幸运的是,对于迭代字符串中的字符来说,上述笨拙的成语是不必要的,因为你可以直接将字符串作为一个可迭代对象,不需要异常处理。</target>
        </trans-unit>
        <trans-unit id="586252847b0a965d3d0a5b40259b311ee19d7146" translate="yes" xml:space="preserve">
          <source>The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by &lt;code&gt;similar&lt;/code&gt;, using the Broadcasted object as its first argument.</source>
          <target state="translated">为每个广播操作计算广播样式，以允许分发和专门化。结果数组的实际分配是通过 &lt;code&gt;similar&lt;/code&gt; ，使用Broadcasted对象作为其第一个参数来处理的。</target>
        </trans-unit>
        <trans-unit id="5232abbd2579e189a3c4536c48fbc58adcc52edd" translate="yes" xml:space="preserve">
          <source>The built-in concrete type used for strings (and string literals) in Julia is &lt;code&gt;String&lt;/code&gt;. This supports the full range of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; characters via the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding. (A &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert to/from other Unicode encodings.)</source>
          <target state="translated">Julia中用于字符串（和字符串文字）的内置具体类型为 &lt;code&gt;String&lt;/code&gt; 。它通过&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;编码支持所有&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;字符。（提供了一个&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;功能，可以与其他Unicode编码进行相互转换。）</target>
        </trans-unit>
        <trans-unit id="dc25d16dd1aba7b0c5bea6b12ba6118124030ae4" translate="yes" xml:space="preserve">
          <source>The byte offset of field &lt;code&gt;i&lt;/code&gt; of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</source>
          <target state="translated">相对于数据起始类型的字段 &lt;code&gt;i&lt;/code&gt; 的字节偏移。例如，我们可以按以下方式使用它来汇总有关结构的信息：</target>
        </trans-unit>
        <trans-unit id="df22a65b46868ee938e0477154f053724ad2e34c" translate="yes" xml:space="preserve">
          <source>The callback you pass to C should only execute a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;:uv_async_send&lt;/code&gt;, passing &lt;code&gt;cond.handle&lt;/code&gt; as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</source>
          <target state="translated">传递到C回调应该只执行一个&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;到 &lt;code&gt;:uv_async_send&lt;/code&gt; ，路过 &lt;code&gt;cond.handle&lt;/code&gt; 作为参数，同时注意避免与朱莉娅运行的任何拨款或其他交互。</target>
        </trans-unit>
        <trans-unit id="b1e65b00ae78a0300e89eb33901bc2c6dff08184" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="translated">在调用此方法之前，调用者必须持有拥有 &lt;code&gt;c&lt;/code&gt; 的&lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;。调用任务将被阻塞，直到其他任务将其唤醒为止，通常是通过在同一Condition对象上调用&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; `&lt;/a&gt;来完成的。锁定时，该锁定将被原子释放（即使它被递归锁定），并且在返回之前将被重新获取。</target>
        </trans-unit>
        <trans-unit id="b9769cfc324c619140bf4882f569b4d5be45feda" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;rand&lt;/code&gt; is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using &lt;code&gt;Future.randjump&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 的情况要复杂一些，因为我们必须确保每个线程都使用不重叠的伪随机数序列。使用 &lt;code&gt;Future.randjump&lt;/code&gt; 函数可以简单地确保这一点：</target>
        </trans-unit>
        <trans-unit id="5555fa452d0454119cd31b5aa3d13eec12b96796" translate="yes" xml:space="preserve">
          <source>The channels example from above can be modified for interprocess communication, as shown below.</source>
          <target state="translated">上文中的通道示例可以修改为进程间通信,如下图所示。</target>
        </trans-unit>
        <trans-unit id="89b722bb0d4e7814b2f6957c408ca31cc4584902" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="translated">选择应用函数时要执行的方法的选择称为&lt;em&gt;dispatch&lt;/em&gt;。 Julia允许调度过程根据给定参数的数量以及所有函数参数的类型来选择要调用函数的方法。这与传统的面向对象语言不同，传统的面向对象语言仅基于第一个参数进行分派，该参数通常具有特殊的参数语法，并且有时是隐式的，而不是显式地编写为参数。&lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;使用函数的所有参数来选择应该调用哪种方法，而不仅仅是第一种方法，这称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;多重调度&lt;/a&gt;。多重分派对于数学代码特别有用，在这种情况下，人为地认为操作&amp;ldquo;归属&amp;rdquo;于一个参数比其他任何参数都没有意义： &lt;code&gt;x + y&lt;/code&gt; 中的加法运算与x相比，属于 &lt;code&gt;x&lt;/code&gt; 的意义更大吗？ &lt;code&gt;y&lt;/code&gt; ？数学运算符的实现通常取决于其所有参数的类型。但是，即使超出数学运算范围，多次派遣最终仍是构造和组织程序的强大而便捷的范例。</target>
        </trans-unit>
        <trans-unit id="810842d6186800c0a575092bdf409289f500ddec" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;x-&amp;gt;x&lt;/code&gt; carries a reference to &lt;code&gt;Foo&lt;/code&gt;, and since &lt;code&gt;Foo&lt;/code&gt; is unavailable on node 2, an &lt;code&gt;UndefVarError&lt;/code&gt; is thrown.</source>
          <target state="translated">闭包 &lt;code&gt;x-&amp;gt;x&lt;/code&gt; 带有对 &lt;code&gt;Foo&lt;/code&gt; 的引用，并且由于 &lt;code&gt;Foo&lt;/code&gt; 在节点2上不可用，因此抛出 &lt;code&gt;UndefVarError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd31f7bc6251a511018cdc2ef8ff1b65e61abb04" translate="yes" xml:space="preserve">
          <source>The cluster manager captures the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; of each worker and makes it available to the master process.</source>
          <target state="translated">集群管理器捕获每个工作程序的&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;，并将其提供给主进程。</target>
        </trans-unit>
        <trans-unit id="56c5bc198a3439c620845fc2e6da1bcc9a273974" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</source>
          <target state="translated">要调用的代码必须作为共享库提供。大多数C和Fortran库都已经作为共享库进行了编译，但是如果您使用GCC（或Clang）自己编译代码，则需要使用 &lt;code&gt;-shared&lt;/code&gt; 和 &lt;code&gt;-fPIC&lt;/code&gt; 选项。 Julia的JIT生成的机器指令与本地C调用相同，因此产生的开销与从C代码中调用库函数相同。 （C和Julia中的非库函数调用都可以内联，因此比共享库函数的调用开销更少。当LLVM生成库和可执行文件时，可以执行整个程序优化，甚至可以在此范围内进行优化，但Julia尚不支持。但是将来可能会这样做，从而获得更大的性能提升。）</target>
        </trans-unit>
        <trans-unit id="98f830d6caf7ed0451c6b75d05afceaf2e516b19" translate="yes" xml:space="preserve">
          <source>The collection must not be empty.</source>
          <target state="translated">收藏品不能是空的。</target>
        </trans-unit>
        <trans-unit id="b1b1444de74c16e81499ba99fc21db058cdbcd70" translate="yes" xml:space="preserve">
          <source>The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, which is to be placed inside your home directory:</source>
          <target state="translated">Julia和REPL使用的颜色也可以自定义。要更改Julia提示的颜色，您可以将以下内容添加到 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 文件中，该文件将放置在主目录中：</target>
        </trans-unit>
        <trans-unit id="6ae3351e931cdaf68574bd5908ad25710f928fca" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">假定这些列由一个或多个空格分隔。行定界符的结尾为 &lt;code&gt;\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b166229d69582696f7886d8f6669f9f89c33f90c" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">假定这些列由一个或多个空格分隔。行定界符的结尾为 &lt;code&gt;\n&lt;/code&gt; 。如果所有数据均为数字，则结果将为数字数组。如果某些元素不能解析为数字，则返回数字和字符串的异构数组。</target>
        </trans-unit>
        <trans-unit id="c128fcb09c50ebb22346ed7e858f0e921632da46" translate="yes" xml:space="preserve">
          <source>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</source>
          <target state="translated">高级编程语言、一流的命令抽象和进程间管道的自动设置的结合是一个强大的组合。为了让大家对可以轻松创建的复杂管道有一定的了解,下面是一些比较复杂的例子,对于Perl单行本的使用过多表示歉意。</target>
        </trans-unit>
        <trans-unit id="6a7191f54d1d0a0057ae059656a933d9b6a26e58" translate="yes" xml:space="preserve">
          <source>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as &lt;code&gt;julia&lt;/code&gt;'s immediate child process, using &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; calls.</source>
          <target state="translated">该命令永远不会与外壳一起运行。取而代之的是，Julia直接解析命令语法，适当地插补变量并像shell一样分割单词，同时遵守shell引用语法。该命令使用 &lt;code&gt;fork&lt;/code&gt; 和 &lt;code&gt;exec&lt;/code&gt; 调用作为 &lt;code&gt;julia&lt;/code&gt; 的直接子进程运行。</target>
        </trans-unit>
        <trans-unit id="4a0dcc8c9826601bed0e074d703f3ff7a640f8d1" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;).</source>
          <target state="translated">如果Array使用非常规索引，则使用1：n索引到AbstractArray的常见习惯是不安全的，如果关闭边界检查，则可能会导致分段错误。请改用 &lt;code&gt;LinearIndices(x)&lt;/code&gt; 或 &lt;code&gt;eachindex(x)&lt;/code&gt; （另请参见&lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f0451ae3f3f75dd1173ec1688aaf529347960c71" translate="yes" xml:space="preserve">
          <source>The commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;). This means it will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">常用的 &lt;code&gt;Int&lt;/code&gt; 类型对应于机器整数类型（ &lt;code&gt;Int32&lt;/code&gt; 或 &lt;code&gt;Int64&lt;/code&gt; ）。这意味着它将溢出，这样 &lt;code&gt;2^64 == 0&lt;/code&gt; 。如果需要更大的值，请使用其他合适的类型，例如 &lt;code&gt;Int128&lt;/code&gt; ，&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;或浮点类型，例如 &lt;code&gt;Float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="282c5d6af8a85d4583f2090ba3bf0607d51cccb2" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="translated">许多语言的编译器都有一个内部联合构造，用于推理类型。Julia只是将其公开给程序员。通过在每种类型的单独分支中生成专用代码，Julia编译器能够在具有少量类型&lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;的 &lt;code&gt;Union&lt;/code&gt; 类型的情况下生成高效代码。</target>
        </trans-unit>
        <trans-unit id="d307808f74aeaa37d8dbbea9a15606c901a4cae0" translate="yes" xml:space="preserve">
          <source>The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.</source>
          <target state="translated">函数输出的字段的完成采用类型推理,只有在函数类型稳定的情况下,它才能建议字段。</target>
        </trans-unit>
        <trans-unit id="d3138fe1fc8f7174a34adb1898449525528a913c" translate="yes" xml:space="preserve">
          <source>The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.</source>
          <target state="translated">方法的完成使用类型推理,因此即使参数是函数输出的,也能看到参数是否匹配。函数需要类型稳定,完成才能够删除不匹配的方法。</target>
        </trans-unit>
        <trans-unit id="6f83f5850ac6b62e295ec56f0e83533e7801ad37" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; is linear in the length of &lt;code&gt;s&lt;/code&gt;, unless an optimized method with constant complexity is available, which is the case for &lt;code&gt;Dict&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;BitSet&lt;/code&gt;. For more than a few calls, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; instead, or either &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; or &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; as appropriate.</source>
          <target state="translated">&lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; 的复杂度在s的长度内是线性 &lt;code&gt;s&lt;/code&gt; ，除非可以使用具有恒定复杂度的优化方法，例如 &lt;code&gt;Dict&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;BitSet&lt;/code&gt; 。对于多个调用，请改用 &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; ，或适当使用 &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; 或 &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="311dcfe3310c4c1e71b8fdd71e07a972ef0dc132" translate="yes" xml:space="preserve">
          <source>The components of tuples can optionally be named, in which case a &lt;em&gt;named tuple&lt;/em&gt; is constructed:</source>
          <target state="translated">元组的组成部分可以有选择地命名，在这种情况下，将构造&lt;em&gt;命名的元组&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="3e9339bf8ddc8517e7daf0c8e7c807dbe19f1e27" translate="yes" xml:space="preserve">
          <source>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</source>
          <target state="translated">压缩后的稀疏列存储使访问稀疏矩阵列中的元素变得方便快捷,而按行访问稀疏矩阵则要慢得多。在CSC结构中一次一次插入以前未存储的条目等操作往往很慢。这是因为稀疏矩阵中所有超出插入点的元素都要被移动一个位置过去。</target>
        </trans-unit>
        <trans-unit id="8b1889cfa906d5de7f417dbba5d8a75294042a14" translate="yes" xml:space="preserve">
          <source>The concatenation functions are used so often that they have special syntax:</source>
          <target state="translated">连接函数的使用频率很高,所以它们有特殊的语法。</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">常数∏。</target>
        </trans-unit>
        <trans-unit id="cdd946b3bbe64931ddb3bd5e7f32f9d59fbf8fe0" translate="yes" xml:space="preserve">
          <source>The constant ℯ.</source>
          <target state="translated">常数ℯ。</target>
        </trans-unit>
        <trans-unit id="9cefd93a0c7128d9cee7f50ca451b5a8198bc929" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; allows us to construct references to channels holding more than one value of a specific type. &lt;code&gt;f&lt;/code&gt; is a function executed on &lt;code&gt;pid&lt;/code&gt; and it must return an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">构造函数 &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; 允许我们构造对包含多个特定类型值的通道的引用。 &lt;code&gt;f&lt;/code&gt; 是在 &lt;code&gt;pid&lt;/code&gt; 上执行的函数，它必须返回 &lt;code&gt;AbstractChannel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76232e9ec80692ffa1332b97fa1e6fc3973cc15d" translate="yes" xml:space="preserve">
          <source>The constructor for a shared array is of the form:</source>
          <target state="translated">共享数组的构造函数是这样的形式。</target>
        </trans-unit>
        <trans-unit id="09f297e05974522f0c6701c3e5abf5ccf2ee32ab" translate="yes" xml:space="preserve">
          <source>The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;item two&lt;/code&gt;.</source>
          <target state="translated">列表中每个项目的内容必须与项目的第一行对齐。在上面的例子围栏码块必须由四个空格缩进到对准与 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;item two&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a711e2ee96d05b52332ef79c64c2aa17ad5865e1" translate="yes" xml:space="preserve">
          <source>The cookie may be passed to the workers at startup via argument &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt;. If argument &lt;code&gt;--worker&lt;/code&gt; is specified without the cookie, the worker tries to read the cookie from its standard input (&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;stdin&lt;/code&gt; is closed immediately after the cookie is retrieved.</source>
          <target state="translated">cookie可以在启动时通过 &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt; 参数传递给工作人员。如果指定参数 &lt;code&gt;--worker&lt;/code&gt; 而不使用cookie，则worker尝试从其标准输入（&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;）中读取cookie 。该 &lt;code&gt;stdin&lt;/code&gt; 饼干检索后立即关闭。</target>
        </trans-unit>
        <trans-unit id="870af6ba603446abce307b3e8bfd11194f33f900" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="translated">核心语言的要求很低,Julia Base和标准库都是用Julia自己编写的,包括整数算术等原始操作。</target>
        </trans-unit>
        <trans-unit id="3bc4ff368fbfc76c3ff3eaa70599d7710f608522" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="translated">查找当前记录器状态，并根据记录器的缓存最低级别（通过调用&lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt; &lt;code&gt;Logging.min_enabled_level&lt;/code&gt; &lt;/a&gt;找到）来检查消息级别。可以通过环境变量覆盖此行为（稍后会对此进行详细介绍）。</target>
        </trans-unit>
        <trans-unit id="3f7f546fa478be5baf73e1d9a88ce7b4f22fd7b5" translate="yes" xml:space="preserve">
          <source>The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.</source>
          <target state="translated">当前版本的Julia将所有任务复用到一个OS线程上。因此,当涉及I/O操作的任务受益于并行执行时,计算绑定的任务则有效地在单个OS线程上顺序执行。未来版本的Julia可能会支持在多个线程上调度任务,在这种情况下,计算绑定的任务也会看到并行执行的好处。</target>
        </trans-unit>
        <trans-unit id="76aeeb5da0056ec0aaaca0d1c584f7796e1043fc" translate="yes" xml:space="preserve">
          <source>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</source>
          <target state="translated">滥用多重调度的危险性(也就是更多的关于以值为参数的类型</target>
        </trans-unit>
        <trans-unit id="61e6dec9a93ab50439a3df7d4ed79515ae264595" translate="yes" xml:space="preserve">
          <source>The day of month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 或 &lt;code&gt;DateTime&lt;/code&gt; 作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的月份中的一天。</target>
        </trans-unit>
        <trans-unit id="299252ee9be4ede7afdc82ba83cfa67ed6efb411" translate="yes" xml:space="preserve">
          <source>The declared types of all fields in a composite DataType &lt;code&gt;T&lt;/code&gt; as a tuple.</source>
          <target state="translated">复合数据类型 &lt;code&gt;T&lt;/code&gt; 中所有字段的声明类型为元组。</target>
        </trans-unit>
        <trans-unit id="2ef7bb84da109de096d6179f580e39fcc330d135" translate="yes" xml:space="preserve">
          <source>The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and lines containing only spaces or tabs (the line containing the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is always included). Then for all lines, excluding the text following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</source>
          <target state="translated">凹痕级别确定为所有行中空格或制表符的最长公共起始序列，不包括开头 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 行和仅包含空格或制表符的行（始终包含结尾 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 的行）。然后，对于所有行（不包括开头 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 之后的文本），将删除共同的开始顺序（包括仅包含空格和制表符的行，如果它们以该顺序开头），例如：</target>
        </trans-unit>
        <trans-unit id="2356f962c8d3ff60eecc6a182ea052ea39664b67" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">默认 &lt;code&gt;pid&lt;/code&gt; 是当前进程。</target>
        </trans-unit>
        <trans-unit id="13fb2cffe54cc4ab8a1dd2c832ae7310589c0943" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments. Therefore, this case should be handled by defining a 2-argument &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; method.</source>
          <target state="translated">默认的MIME类型是 &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt; 。 &lt;code&gt;text/plain&lt;/code&gt; 输出有一个备用定义，该定义使用2个参数 &lt;code&gt;show&lt;/code&gt; 调用。因此，应通过定义2个参数 &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; 方法来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="e57baa92c6f6a7e34ff4590072c999e03c2e6a26" translate="yes" xml:space="preserve">
          <source>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism, to improve human readability, and to catch programmer errors.</source>
          <target state="translated">当类型被省略时,Julia的默认行为是允许值为任何类型。因此,人们可以在不明确使用类型的情况下写出许多有用的Julia函数。然而,当需要额外的表现力时,很容易将显式类型注释逐渐引入到以前 &quot;无类型 &quot;的代码中。添加注释主要有三个目的:利用Julia强大的多调度机制,提高人类的可读性,以及捕捉程序员的错误。</target>
        </trans-unit>
        <trans-unit id="d1df4775c1a0c6149628da164ef2c2add2aea3bd" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove leading whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">默认行为是删除前导空格和定界符：有关详细信息，请参见&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c11c76e6a974f0248876da7137e97c01ffa7caf" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove trailing whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">默认行为是删除尾随空格和定界符：有关详细信息，请参见&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="855bff164720a2c745d8e506987fbf1482013980" translate="yes" xml:space="preserve">
          <source>The default implementation (which uses TCP/IP sockets) is implemented as &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt;.</source>
          <target state="translated">默认实现（使用TCP / IP套接字）实现为 &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78e7fa17aefadd075c2be825658630ae2cf9c235" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;isequal&lt;/code&gt; calls &lt;code&gt;==&lt;/code&gt;, so a type that does not involve floating-point values generally only needs to define &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 调用 &lt;code&gt;==&lt;/code&gt; 的默认实现，因此不涉及浮点值的类型通常只需要定义 &lt;code&gt;==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40594727e32e7ffa62fc7c197ea4f5e0449e9039" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields channel::Channel{Int} workers::Set{Int} where &lt;code&gt;channel&lt;/code&gt; contains free worker pids and &lt;code&gt;workers&lt;/code&gt; is the set of all workers associated with this pool.</source>
          <target state="translated">上面的默认实现（在 &lt;code&gt;AbstractWorkerPool&lt;/code&gt; 上）需要字段channel :: Channel {Int} worker :: Set {Int}，其中 &lt;code&gt;channel&lt;/code&gt; 包含免费的worker pid，而 &lt;code&gt;workers&lt;/code&gt; 是与此池关联的所有worker的集合。</target>
        </trans-unit>
        <trans-unit id="90d0098a5b9857be430bc6bdbd24d7771a71aa03" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认值为&lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="939929b76e159e18d5e7761850ea7b359afa492d" translate="yes" xml:space="preserve">
          <source>The default mode used is always &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</source>
          <target state="translated">使用的默认模式始终为&lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt;，它四舍五入到最接近的可表示值，并用最小有效位向四舍五入到最接近的值。</target>
        </trans-unit>
        <trans-unit id="bb41fa3202534d6677ac2f342e3bce0fdc60f379" translate="yes" xml:space="preserve">
          <source>The default precision (in number of bits of the significand) and rounding mode of &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; operations can be changed globally by calling &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt;&lt;code&gt;setprecision&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;setrounding&lt;/code&gt;, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a &lt;code&gt;do&lt;/code&gt; block:</source>
          <target state="translated">默认精度（在有效数位的数目）和舍入模式&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;操作可以在全球通过调用被改变&lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt; &lt;code&gt;setprecision&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;setrounding&lt;/code&gt; ，并且所有进一步的计算将在考虑这些变化。或者，仅可以在特定代码块的执行过程中通过将相同的功能与 &lt;code&gt;do&lt;/code&gt; 块一起使用来更改精度或舍入：</target>
        </trans-unit>
        <trans-unit id="bf260c790afbd5fd76456a214c3da2bfee6f596b" translate="yes" xml:space="preserve">
          <source>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</source>
          <target state="translated">默认的四舍五入模式,四舍五入到最接近的整数,平局(0.5的小数)四舍五入到最接近的偶数。四舍五入到最接近的整数,平局(0.5的小数值)四舍五入到最接近的偶数。</target>
        </trans-unit>
        <trans-unit id="a8d023ed2ec488f600d82c5f04099bb7053c6343" translate="yes" xml:space="preserve">
          <source>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;em&gt;appear&lt;/em&gt; to be so. For numeric types indeed, &lt;code&gt;QuickSort&lt;/code&gt; is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt;.</source>
          <target state="translated">选择默认的排序算法是基于它们的快速和稳定，或者&lt;em&gt;看起来&lt;/em&gt;如此。实际上，对于数字类型，选择了 &lt;code&gt;QuickSort&lt;/code&gt; ，因为在这种情况下，它与稳定的排序相比更快且没有区别（除非数组以某种方式记录了其突变）。稳定性属性的成本不可忽略，因此，如果不需要它，则可能需要明确指定首选算法，例如 &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e4b294c96581c70e29314614e72dd9c556dd867" translate="yes" xml:space="preserve">
          <source>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</source>
          <target state="translated">整数文字的默认类型取决于目标系统是32位架构还是64位架构。</target>
        </trans-unit>
        <trans-unit id="0025d7cf20de7d8585d610cdb20c478776196150" translate="yes" xml:space="preserve">
          <source>The default value (for iterators that do not define this function) is &lt;code&gt;HasLength()&lt;/code&gt;. This means that most iterators are assumed to implement &lt;a href=&quot;#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认值（对于未定义此函数的迭代器）为 &lt;code&gt;HasLength()&lt;/code&gt; 。这意味着假定大多数迭代器都实现&lt;a href=&quot;#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1fec164addf150bd6fc4ed074c8bde6086195e" translate="yes" xml:space="preserve">
          <source>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</source>
          <target state="translated">当没有传入关键字时,默认是打开文件只读。返回一个用于访问打开的文件的流。</target>
        </trans-unit>
        <trans-unit id="46ad04b79597833ac2971450ca4faf1a5ac755c0" translate="yes" xml:space="preserve">
          <source>The definitive guide to floating point arithmetic is the &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 Standard&lt;/a&gt;; however, it is not available for free online.</source>
          <target state="translated">浮点运算的&lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;权威&lt;/a&gt;指南是IEEE 754-2008标准；但是，它不能免费在线获得。</target>
        </trans-unit>
        <trans-unit id="c7a1e185817162d29c3ca02c640a39cf90726456" translate="yes" xml:space="preserve">
          <source>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</source>
          <target state="translated">描述字符串接受循环指数的插值。如果没有提供描述,则根据变量构建一个描述。</target>
        </trans-unit>
        <trans-unit id="b9783bd3f57cabbb7dcb6efff07a6fb2ce7cf2be" translate="yes" xml:space="preserve">
          <source>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. &lt;code&gt;(x, y)&lt;/code&gt;) instead of just a symbol, then an assignment &lt;code&gt;(x, y) = argument&lt;/code&gt; will be inserted for you:</source>
          <target state="translated">解构功能也可以在函数参数中使用。如果函数参数名称被写为元组（例如 &lt;code&gt;(x, y)&lt;/code&gt; ）而不是符号，那么将为您插入一个赋值 &lt;code&gt;(x, y) = argument&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dca7fd4aaff137c3b5ad312f731763865f2c4777" translate="yes" xml:space="preserve">
          <source>The diagonal of the matrix &lt;code&gt;X&lt;/code&gt; is assumed to be all ones.</source>
          <target state="translated">假定矩阵 &lt;code&gt;X&lt;/code&gt; 的对角线全为1。</target>
        </trans-unit>
        <trans-unit id="65475d5b108ff8d6ff4d0b451b5957edd3247c0c" translate="yes" xml:space="preserve">
          <source>The diagonal values of the matrix &lt;code&gt;X&lt;/code&gt; will be read.</source>
          <target state="translated">将读取矩阵 &lt;code&gt;X&lt;/code&gt; 的对角线值。</target>
        </trans-unit>
        <trans-unit id="35294cd283107f3ea2ad299c610959761013b001" translate="yes" xml:space="preserve">
          <source>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator &lt;code&gt;p&lt;/code&gt;-norm of a &lt;code&gt;1 &amp;times; n&lt;/code&gt; matrix.</source>
          <target state="translated">向量空间与其对偶之间的范数差异会保留对偶性与点积之间的关系，其结果与 &lt;code&gt;1 &amp;times; n&lt;/code&gt; 矩阵的算子 &lt;code&gt;p&lt;/code&gt; -范数一致。</target>
        </trans-unit>
        <trans-unit id="fe30caaca3ec896d42d37e2680c6fbcc22f3fc58" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="translated">差异似乎微不足道，但实际上由于&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;的行为，差异非常大。在第一种方法中，随机矩阵是在本地构造的，然后发送到另一个过程中进行平方。在第二种方法中，随机矩阵既在另一过程中构造又平方。因此，第二种方法发送的数据少于第一种。</target>
        </trans-unit>
        <trans-unit id="515d7afeaf87e8c8538070fa94ff623cdced8f10" translate="yes" xml:space="preserve">
          <source>The different prompt modes</source>
          <target state="translated">不同的提示模式</target>
        </trans-unit>
        <trans-unit id="cf7712c8e857525e49eb6c6feac8d5fe578af7a4" translate="yes" xml:space="preserve">
          <source>The discussion in the preceding paragraph referred to the &quot;parser&quot;, that is, the phase of compilation that takes place when the module containing &lt;code&gt;abmult&lt;/code&gt; is first loaded, as opposed to the later phase when it is first invoked. The parser does not &quot;know&quot; that &lt;code&gt;Int&lt;/code&gt; is a fixed type, or that the statement &lt;code&gt;r = -r&lt;/code&gt; transforms an &lt;code&gt;Int&lt;/code&gt; to another &lt;code&gt;Int&lt;/code&gt;. The magic of type inference takes place in the later phase of compilation.</source>
          <target state="translated">上一段中的讨论涉及&amp;ldquo;解析器&amp;rdquo;，即，在首先加载包含 &lt;code&gt;abmult&lt;/code&gt; 的模块时发生的编译阶段，与之相反的是在其最初被调用时的后期阶段。解析器不会&amp;ldquo;知道&amp;rdquo; &lt;code&gt;Int&lt;/code&gt; 是固定类型，或者语句 &lt;code&gt;r = -r&lt;/code&gt; 将一个 &lt;code&gt;Int&lt;/code&gt; 转换为另一个 &lt;code&gt;Int&lt;/code&gt; 。类型推断的魔力发生在编译的后期。</target>
        </trans-unit>
        <trans-unit id="228846c17a2f8eda9af9e04280c4e7e004d8ecbb" translate="yes" xml:space="preserve">
          <source>The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</source>
          <target state="translated">对基于特征的推广的讨论为我们下一个设计模式提供了一个过渡:计算矩阵操作的输出元素类型。</target>
        </trans-unit>
        <trans-unit id="c9eeea461d08f16f6e9e3e76a2854c7413f10de0" translate="yes" xml:space="preserve">
          <source>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, &lt;code&gt;eps(1.0)&lt;/code&gt; is the same as &lt;code&gt;eps(Float64)&lt;/code&gt; since &lt;code&gt;1.0&lt;/code&gt; is a 64-bit floating-point value.</source>
          <target state="translated">两个相邻的可表示浮点数之间的距离不是恒定的，但是对于较小的值则较小，而对于较大的值较大。换句话说，可表示的浮点数在实数线中最接近零，并且随着一个人远离零而呈指数增长。根据定义， &lt;code&gt;eps(1.0)&lt;/code&gt; 与 &lt;code&gt;eps(Float64)&lt;/code&gt; 相同，因为 &lt;code&gt;1.0&lt;/code&gt; 是64位浮点值。</target>
        </trans-unit>
        <trans-unit id="17711720acdfc250d4da5bdf1c59e4156516b762" translate="yes" xml:space="preserve">
          <source>The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments. Consider the modification of the last example by moving &lt;code&gt;bar&lt;/code&gt; to the global scope:</source>
          <target state="translated">继承全局作用域和嵌套局部作用域之间的区别可能导致在局部作用域和全局作用域中为变量分配定义的函数之间存在一些细微差异。考虑通过将 &lt;code&gt;bar&lt;/code&gt; 移到全局范围来修改最后一个示例：</target>
        </trans-unit>
        <trans-unit id="bcbd86bd1c455f650a19858504ec03684521d39b" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;.</source>
          <target state="translated">该文档也以PDF格式提供：&lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c976d9d02fc2e4f087f2db86ac987d2cebacc0" translate="yes" xml:space="preserve">
          <source>The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or &quot;REPL&quot;) by double-clicking the Julia executable or running &lt;code&gt;julia&lt;/code&gt; from the command line:</source>
          <target state="translated">学习和使用Julia的最简单方法是通过双击Julia可执行文件或从命令行运行 &lt;code&gt;julia&lt;/code&gt; 来启动交互式会话（也称为read-eval-print循环或&amp;ldquo; REPL&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="2182ffaca8a0c2d19e2f394d632b220a4bda55b5" translate="yes" xml:space="preserve">
          <source>The easiest way to understand this behavior is to see an example. In the previous example, the &lt;code&gt;println&lt;/code&gt; call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:</source>
          <target state="translated">理解这种行为的最简单方法是看一个例子。在前面的示例中， &lt;code&gt;println&lt;/code&gt; 调用由所有三个分支共享：唯一的实际选择是要打印哪个文字字符串。这可以使用三元运算符更简洁地编写。为了清楚起见，让我们首先尝试一个双向版本：</target>
        </trans-unit>
        <trans-unit id="56dd1399973b5466f5b438f54aa5084eb3d4b3fd" translate="yes" xml:space="preserve">
          <source>The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">可以通过将 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; ， &lt;code&gt;VISUAL&lt;/code&gt; 或 &lt;code&gt;EDITOR&lt;/code&gt; 设置为环境变量来更改编辑器。</target>
        </trans-unit>
        <trans-unit id="8d60f89821e0be17d3c10fd641e166470b0fae98" translate="yes" xml:space="preserve">
          <source>The editor returned by &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; and used in, e.g., &lt;code&gt;InteractiveUtils.edit&lt;/code&gt;, referring to the command of the preferred editor, for instance &lt;code&gt;vim&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; 返回并在例如 &lt;code&gt;InteractiveUtils.edit&lt;/code&gt; 中使用的编辑器，指的是首选编辑器的命令，例如 &lt;code&gt;vim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f31493a5d545803d2bc443ac0f38b3d641d141b" translate="yes" xml:space="preserve">
          <source>The efficiency gained by being able to store &lt;code&gt;Point{Float64}&lt;/code&gt; objects with immediate values is magnified enormously in the case of arrays: an &lt;code&gt;Array{Float64}&lt;/code&gt; can be stored as a contiguous memory block of 64-bit floating-point values, whereas an &lt;code&gt;Array{Real}&lt;/code&gt; must be an array of pointers to individually allocated &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; which may well be &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;boxed&lt;/a&gt; 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the &lt;code&gt;Real&lt;/code&gt; abstract type.</source>
          <target state="translated">在数组的情况下，通过存储具有即时值的 &lt;code&gt;Point{Float64}&lt;/code&gt; 对象而获得的效率大大提高： &lt;code&gt;Array{Float64}&lt;/code&gt; 可以存储为64位浮点值的连续存储块，而 &lt;code&gt;Array{Real}&lt;/code&gt; 必须是指向单独分配的&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;对象的指针的数组&amp;ndash;可能是&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;装箱的&lt;/a&gt; 64位浮点值，但也可能是任意大而复杂的对象，它们声明为 &lt;code&gt;Real&lt;/code&gt; 抽象类型的实现。</target>
        </trans-unit>
        <trans-unit id="77656128da3c3e27758883f72427b834f3cb4b6e" translate="yes" xml:space="preserve">
          <source>The eigenvalues are returned in &lt;code&gt;W&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">特征值在 &lt;code&gt;W&lt;/code&gt; 中返回，特征向量在 &lt;code&gt;Z&lt;/code&gt; 中返回。</target>
        </trans-unit>
        <trans-unit id="709d89b2d19663c267d1c6a4862d61316a231e84" translate="yes" xml:space="preserve">
          <source>The element type of the result is chosen using promotion (see &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;) based on the element type of &lt;code&gt;A&lt;/code&gt; and on the types of the &lt;code&gt;new&lt;/code&gt; values in pairs. If &lt;code&gt;count&lt;/code&gt; is omitted and the element type of &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Union&lt;/code&gt;, the element type of the result will not include singleton types which are replaced with values of a different type: for example, &lt;code&gt;Union{T,Missing}&lt;/code&gt; will become &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;missing&lt;/code&gt; is replaced.</source>
          <target state="translated">基于 &lt;code&gt;A&lt;/code&gt; 的元素类型和成对的 &lt;code&gt;new&lt;/code&gt; 值的类型，使用promotion（请参见&lt;a href=&quot;../base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;）选择结果的元素类型。如果 &lt;code&gt;count&lt;/code&gt; 被省略并且的元素类型 &lt;code&gt;A&lt;/code&gt; 是一个 &lt;code&gt;Union&lt;/code&gt; ，结果的元素类型将不包括与不同类型的值替换单类型：例如， &lt;code&gt;Union{T,Missing}&lt;/code&gt; 将变得 &lt;code&gt;T&lt;/code&gt; 如果 &lt;code&gt;missing&lt;/code&gt; 是更换。</target>
        </trans-unit>
        <trans-unit id="14b4f332ac46b505bad4228677357909dd03b266" translate="yes" xml:space="preserve">
          <source>The element type of the tuple must be an instance of &lt;code&gt;VecElement{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a primitive type that is 1, 2, 4 or 8 bytes.</source>
          <target state="translated">元组的元素类型必须是 &lt;code&gt;VecElement{T}&lt;/code&gt; 的实例，其中 &lt;code&gt;T&lt;/code&gt; 是1、2、4或8个字节的原始类型。</target>
        </trans-unit>
        <trans-unit id="c9296fda074d952d1c87394f1441913d330aa413" translate="yes" xml:space="preserve">
          <source>The empty (or &quot;bottom&quot;) type, written as &lt;code&gt;Union{}&lt;/code&gt; (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</source>
          <target state="translated">写为 &lt;code&gt;Union{}&lt;/code&gt; （空的联合类型）的空（或&amp;ldquo;底部&amp;rdquo;）类型是没有值且没有子类型（自身除外）的类型。通常，您将不需要使用此类型。</target>
        </trans-unit>
        <trans-unit id="3534ea1366da3151258e1f770bb393a26a8c9156" translate="yes" xml:space="preserve">
          <source>The empty tuple (&lt;code&gt;()&lt;/code&gt;) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</source>
          <target state="translated">空元组（ &lt;code&gt;()&lt;/code&gt; ）是虚无的另一种形式。但是，实际上不应将其视为零，而应是零值的元组。</target>
        </trans-unit>
        <trans-unit id="f2bd3a290bc2b2f98102d89ff212080bf2528200" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">行定界符的结尾为 &lt;code&gt;\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13d242b1b1e933d4ec26a29014e675d01b5c3b93" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">行定界符的结尾为 &lt;code&gt;\n&lt;/code&gt; 。如果所有数据均为数字，则结果将为数字数组。如果某些元素不能解析为数字，则返回数字和字符串的异构数组。</target>
        </trans-unit>
        <trans-unit id="0c21a922512e76aea89910e75ca40814c713417b" translate="yes" xml:space="preserve">
          <source>The entries of &lt;code&gt;F.D1&lt;/code&gt; and &lt;code&gt;F.D2&lt;/code&gt; are related, as explained in the LAPACK documentation for the &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;generalized SVD&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; routine which is called underneath (in LAPACK 3.6.0 and newer).</source>
          <target state="translated">&lt;code&gt;F.D1&lt;/code&gt; 和 &lt;code&gt;F.D2&lt;/code&gt; 的条目是相关的，如LAPACK文档中针对&lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;通用SVD&lt;/a&gt;和&lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt;例程（在下面称为LAPACK 3.6.0及更高版本）中所述。</target>
        </trans-unit>
        <trans-unit id="6c6e8a6592578860941072596b3389f0e39bd834" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list defined environment variables relevant for Julia, including those for which &lt;code&gt;JULIA&lt;/code&gt; appears in the name.</source>
          <target state="translated">Julia使用的环境变量通常以 &lt;code&gt;JULIA&lt;/code&gt; 开头。如果使用关键字 &lt;code&gt;verbose=true&lt;/code&gt; 调用&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt; &lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt; &lt;/a&gt;，则输出将列出与Julia相关的已定义环境变量，包括名称中出现 &lt;code&gt;JULIA&lt;/code&gt; 的环境变量。</target>
        </trans-unit>
        <trans-unit id="7ebc4dca8e995a281e980c9657b899d8cf0df29e" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be written using the following syntax:</source>
          <target state="translated">可以使用以下语法编写与 &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML标记等效的标记：</target>
        </trans-unit>
        <trans-unit id="74efd542b7345e98fdaed051a7a6183a8d020db5" translate="yes" xml:space="preserve">
          <source>The example generated function &lt;code&gt;foo&lt;/code&gt; above did not do anything a normal function &lt;code&gt;foo(x) = x * x&lt;/code&gt; could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</source>
          <target state="translated">上面的示例生成的函数 &lt;code&gt;foo&lt;/code&gt; 不能执行普通函数 &lt;code&gt;foo(x) = x * x&lt;/code&gt; 不能执行的任何操作（除了在第一次调用时打印类型，并且会产生更高的开销）。但是，生成函数的功能在于其根据传递给它的类型来计算不同的带引号表达式的能力：</target>
        </trans-unit>
        <trans-unit id="e119c6a2d56d3760f8ebb0ae8619e173f79b4b25" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="translated">在上一节中的示例掩盖的实现细节&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;，即：在这些性状方面的工作。在矩阵上进行迭代时（例如在 &lt;code&gt;map&lt;/code&gt; 的实现中），一个重要的问题是使用什么顺序遍历数据。当 &lt;code&gt;AbstractArray&lt;/code&gt; 子类型实现&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;Base.IndexStyle&lt;/code&gt; &lt;/a&gt;特征时，其他函数（例如 &lt;code&gt;map&lt;/code&gt; )可以根据此信息进行调度以选择最佳算法（请参见&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;）。这意味着每个子类型都不需要实现 &lt;code&gt;map&lt;/code&gt; 的自定义版本，因为通用定义+特征类将使系统选择最快的版本。这是一个 &lt;code&gt;map&lt;/code&gt; 的玩具实现，说明了基于特征的调度：</target>
        </trans-unit>
        <trans-unit id="c4e7ac687a3c1938fcc96d92a705ce561c8d3bfd" translate="yes" xml:space="preserve">
          <source>The exception is that quotation marks still must be escaped, e.g. &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt;. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</source>
          <target state="translated">唯一的例外是引号仍然必须转义，例如 &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; 等同于 &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; 。为了能够表达所有字符串，还必须转义反斜线，但仅当出现在引号字符正前方时：</target>
        </trans-unit>
        <trans-unit id="806a2c6eb838f5063922dc987163b721668d0145" translate="yes" xml:space="preserve">
          <source>The exception stack is stored on the &lt;code&gt;Task&lt;/code&gt; where the exceptions occurred. When a task fails with uncaught exceptions, &lt;code&gt;catch_stack(task)&lt;/code&gt; may be used to inspect the exception stack for that task.</source>
          <target state="translated">异常堆栈存储在发生异常的 &lt;code&gt;Task&lt;/code&gt; 上。当任务因未捕获的异常而失败时， &lt;code&gt;catch_stack(task)&lt;/code&gt; 可用于检查该任务的异常堆栈。</target>
        </trans-unit>
        <trans-unit id="928c8d0396de54cd800b9aede32ea561fba936f5" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="translated">此规则的例外是最小和最大的有限值（例如 &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; 和 &lt;code&gt;prevfloat(Inf)&lt;/code&gt; 的&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;），这一轮的价值越小。</target>
        </trans-unit>
        <trans-unit id="def91518b0989f4a83def2144fe01cdce215a440" translate="yes" xml:space="preserve">
          <source>The executable itself is one of</source>
          <target state="translated">可执行文件本身是一个</target>
        </trans-unit>
        <trans-unit id="0db1c4486699e7de0f4ce2a483205ec8ce5f38db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt;, before the &lt;code&gt;?&lt;/code&gt;, is a condition expression, and the ternary operation evaluates the expression &lt;code&gt;b&lt;/code&gt;, before the &lt;code&gt;:&lt;/code&gt;, if the condition &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the expression &lt;code&gt;c&lt;/code&gt;, after the &lt;code&gt;:&lt;/code&gt;, if it is &lt;code&gt;false&lt;/code&gt;. Note that the spaces around &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; are mandatory: an expression like &lt;code&gt;a?b:c&lt;/code&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;code&gt;?&lt;/code&gt; and the &lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">表达式 &lt;code&gt;a&lt;/code&gt; ，在 &lt;code&gt;?&lt;/code&gt; 之前？，是一个条件表达式，和三元操作计算表达式 &lt;code&gt;b&lt;/code&gt; ，前 &lt;code&gt;:&lt;/code&gt; ，如果条件 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 或表达 &lt;code&gt;c&lt;/code&gt; ，后 &lt;code&gt;:&lt;/code&gt; 如果是 &lt;code&gt;false&lt;/code&gt; 。注意周围的空格 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 是必需的： &lt;code&gt;a?b:c&lt;/code&gt; 之类的表达式不是有效的三元表达式（但在 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 之后都可以使用换行符）。</target>
        </trans-unit>
        <trans-unit id="465bf593bbe53b12eb7783b96c9712a167cf8578" translate="yes" xml:space="preserve">
          <source>The expression passed to the &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function could not be interpreted as a valid Julia expression.</source>
          <target state="translated">传递给&lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;函数的表达式不能解释为有效的Julia表达式。</target>
        </trans-unit>
        <trans-unit id="a177c1288ef44211cc6e949df284aa83f006f7fc" translate="yes" xml:space="preserve">
          <source>The extension given by the constant &lt;code&gt;dlext&lt;/code&gt; (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt;, or &lt;code&gt;.dylib&lt;/code&gt;) can be omitted from the &lt;code&gt;libfile&lt;/code&gt; string, as it is automatically appended if needed. If &lt;code&gt;libfile&lt;/code&gt; is not an absolute path name, then the paths in the array &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; are searched for &lt;code&gt;libfile&lt;/code&gt;, followed by the system load path.</source>
          <target state="translated">可以从 &lt;code&gt;libfile&lt;/code&gt; 字符串中省略由常量 &lt;code&gt;dlext&lt;/code&gt; （ &lt;code&gt;.so&lt;/code&gt; ， &lt;code&gt;.dll&lt;/code&gt; 或 &lt;code&gt;.dylib&lt;/code&gt; ）给出的扩展名，因为如果需要，它会自动附加。如果 &lt;code&gt;libfile&lt;/code&gt; 不是绝对路径名，那么将在数组 &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; 中的路径中搜索 &lt;code&gt;libfile&lt;/code&gt; ，然后是系统加载路径。</target>
        </trans-unit>
        <trans-unit id="36c16e65be4afc2c66cb3288c6300982f05c7ad1" translate="yes" xml:space="preserve">
          <source>The fact that the type of &lt;code&gt;m.a&lt;/code&gt; is known from &lt;code&gt;m&lt;/code&gt;'s type&amp;mdash;coupled with the fact that its type cannot change mid-function&amp;mdash;allows the compiler to generate highly-optimized code for objects like &lt;code&gt;m&lt;/code&gt; but not for objects like &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">该类型的事实 &lt;code&gt;m.a&lt;/code&gt; 从已知 &lt;code&gt;m&lt;/code&gt; 的类型耦合的事实，它的类型不能改变中间函数允许编译器生成用于像物体高度优化代码 &lt;code&gt;m&lt;/code&gt; 但不能用于像对象 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0c52690600fcbcb99da1f62c4bac2b9e5d6f697" translate="yes" xml:space="preserve">
          <source>The fallback definition is</source>
          <target state="translated">后备定义是</target>
        </trans-unit>
        <trans-unit id="ee6beb39d94f4bf27bb085bd2200c292b19c5e9a" translate="yes" xml:space="preserve">
          <source>The fields represent:</source>
          <target state="translated">这些领域代表:</target>
        </trans-unit>
        <trans-unit id="c9020dd8336689ac7fec628824c2784dbf9a80fb" translate="yes" xml:space="preserve">
          <source>The file is passed via the stream argument, either as an open &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; or filename string. When you initialize the stream, use &lt;code&gt;&quot;r&quot;&lt;/code&gt; for a &quot;read-only&quot; array, and &lt;code&gt;&quot;w+&quot;&lt;/code&gt; to create a new array used to write values to disk.</source>
          <target state="translated">该文件通过流参数作为打开的&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;或文件名字符串传递。初始化流时，将 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 用于&amp;ldquo;只读&amp;rdquo;数组，将 &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 用于创建用于将值写入磁盘的新数组。</target>
        </trans-unit>
        <trans-unit id="689e05efadfddad191a25330c014009d3e84b447" translate="yes" xml:space="preserve">
          <source>The file-system preferred block size for the file</source>
          <target state="translated">文件系统首选的文件块大小。</target>
        </trans-unit>
        <trans-unit id="c3038fc2cf1255c7ec1e11b0a18b74e94018430a" translate="yes" xml:space="preserve">
          <source>The final call to &lt;code&gt;qsort&lt;/code&gt; looks like this:</source>
          <target state="translated">对 &lt;code&gt;qsort&lt;/code&gt; 的最终调用如下所示：</target>
        </trans-unit>
        <trans-unit id="7d988c680830d3c098bed962d30d54cd701b74ad" translate="yes" xml:space="preserve">
          <source>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</source>
          <target state="translated">最后一个仍未解决的问题是自引用对象的构造,或者更一般地说,递归数据结构。由于基本的困难可能不是很明显,所以让我们简单地解释一下。考虑以下递归类型声明。</target>
        </trans-unit>
        <trans-unit id="2c490723b997dd55f5ce00727bf52c98838be748" translate="yes" xml:space="preserve">
          <source>The first &quot;important&quot; line in this output is this one:</source>
          <target state="translated">在这个输出中,第一行 &quot;重要 &quot;的是这个。</target>
        </trans-unit>
        <trans-unit id="355a754edd3ac1108f8aa47f09609e4797573a28" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;old&lt;/code&gt; is the signature of the deprecated method, the second one &lt;code&gt;new&lt;/code&gt; is the call which replaces it. &lt;code&gt;@deprecate&lt;/code&gt; exports &lt;code&gt;old&lt;/code&gt; unless the optional third argument is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;old&lt;/code&gt; 是已弃用方法的签名，第二个参数 &lt;code&gt;new&lt;/code&gt; 是替换它的调用。 &lt;code&gt;@deprecate&lt;/code&gt; 导出 &lt;code&gt;old&lt;/code&gt; ,除非可选的第三个参数为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca4a6f093dfc816b748358bcada908fd4397bf69" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; can be marked with a &lt;code&gt;$&lt;/code&gt;, in which case the return value will instead be a &lt;code&gt;struct CFunction&lt;/code&gt; which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt;&lt;code&gt;finalizer&lt;/code&gt;&lt;/a&gt; when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;的第一个参数可以用 &lt;code&gt;$&lt;/code&gt; 标记，在这种情况下，返回值将是 &lt;code&gt;struct CFunction&lt;/code&gt; ，该函数在参数上封闭。您必须确保此返回对象保持活动状态，直到完成所有使用。当删除并退出该引用时，将通过&lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt; &lt;code&gt;finalizer&lt;/code&gt; &lt;/a&gt;擦除cfunction指针处的内容和代码。由于C中不存在此功能，因此通常不需要此功能，但对于处理设计不良的API（不提供单独的闭包环境参数）可能很有用。</target>
        </trans-unit>
        <trans-unit id="693dd527818a9b4cb2e07e46d1435896bbc1c434" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can also be an expression evaluated at run time. In this case, the expression must evaluate to a &lt;code&gt;Ptr&lt;/code&gt;, which will be used as the address of the native function to call. This behavior occurs when the first &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的第一个参数也可以是在运行时评估的表达式。在这种情况下，表达式必须求值为 &lt;code&gt;Ptr&lt;/code&gt; ，它将用作要调用的本机函数的地址。当第一个&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;参数包含对非常数的引用（例如局部变量，函数参数或非常数全局变量）时，就会发生此行为。</target>
        </trans-unit>
        <trans-unit id="145bbc0abe5deab0a11d30eff56416193fa999ea" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;remotecall&lt;/code&gt; is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but &lt;code&gt;remotecall&lt;/code&gt; is considered a low-level interface providing finer control. The second argument to &lt;code&gt;remotecall&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt; of the process that will do the work, and the remaining arguments will be passed to the function being called.</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; 的第一个参数是要调用的函数。Julia中的大多数并行编程都没有引用特定的进程或可用的进程数，但是 &lt;code&gt;remotecall&lt;/code&gt; 被认为是提供更好控制的低级接口。 &lt;code&gt;remotecall&lt;/code&gt; 的第二个参数是将完成工作的进程的 &lt;code&gt;id&lt;/code&gt; ，其余参数将传递给被调用的函数。</target>
        </trans-unit>
        <trans-unit id="25e1aab2d5890f1ec3fee29d387628c8119eeb0c" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;show&lt;/code&gt; can be an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; specifying output format properties. See &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">要 &lt;code&gt;show&lt;/code&gt; 的第一个参数可以是指定输出格式属性的&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52b90970f0dc891c8696d7672a072123d726419a" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; is executed when &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is called. The resulting expression contains &lt;em&gt;only&lt;/em&gt; the second &lt;code&gt;println&lt;/code&gt;:</source>
          <target state="translated">调用&lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt;时执行对&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;的第一次调用。结果表达式&lt;em&gt;仅&lt;/em&gt;包含第二个 &lt;code&gt;println&lt;/code&gt; ：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8464368be55c0ee0f473e53693ff139c3f5a4a18" translate="yes" xml:space="preserve">
          <source>The first case works, because the last character &lt;code&gt;y&lt;/code&gt; and the space are one-byte characters, whereas &lt;code&gt;end-2&lt;/code&gt; indexes into the middle of the &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte representation. The correct way for this case is using &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; or, if you're using that value to index into &lt;code&gt;s&lt;/code&gt; you can write &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; expands to &lt;code&gt;lastindex(s)&lt;/code&gt;.</source>
          <target state="translated">第一种情况有效，因为最后一个字符 &lt;code&gt;y&lt;/code&gt; 和空格是一个字节的字符，而 &lt;code&gt;end-2&lt;/code&gt; 索引到 &lt;code&gt;&amp;exist;&lt;/code&gt; 多字节表示形式的中间。这种情况的正确方法是使用 &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; 或者，如果您使用该值索引到 &lt;code&gt;s&lt;/code&gt; ，则可以编写 &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; 并将 &lt;code&gt;end&lt;/code&gt; 扩展为 &lt;code&gt;lastindex(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cae7754ed7d4e8921dc21019e00cb20a90b09dbc" translate="yes" xml:space="preserve">
          <source>The first construct is used when you need the value, but not index, of each element. In the second construct, &lt;code&gt;i&lt;/code&gt; will be an &lt;code&gt;Int&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an array type with fast linear indexing; otherwise, it will be a &lt;code&gt;CartesianIndex&lt;/code&gt;:</source>
          <target state="translated">当您需要每个元素的值而不是索引时，将使用第一个构造。在第二种构造中，如果 &lt;code&gt;A&lt;/code&gt; 是具有快速线性索引的数组类型，则 &lt;code&gt;i&lt;/code&gt; 将为 &lt;code&gt;Int&lt;/code&gt; ；否则，它将为 &lt;code&gt;CartesianIndex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a131f32e4f6815b22742934540634fef42489da" translate="yes" xml:space="preserve">
          <source>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</source>
          <target state="translated">第一个条目是 &quot;用户仓库&quot;,应该是当前用户可以写入并拥有的。用户仓库是:克隆注册表、安装新的包版本、创建和更新命名环境、克隆包仓库、保存新编译的包镜像文件、写入日志文件、默认勾选开发包、保存全局配置数据的地方。部署路径中后面的条目按只读处理,适合系统管理员安装和管理的注册表、包等。</target>
        </trans-unit>
        <trans-unit id="006a5d47461c1a2f566eaae2f91fca6d12ba4594" translate="yes" xml:space="preserve">
          <source>The first five control flow mechanisms are standard to high-level programming languages. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</source>
          <target state="translated">前五个控制流机制是高级编程语言的标准。&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;并不是那么标准：它们提供了非本地控制流，因此可以在临时暂停的计算之间进行切换。这是一个强大的构造：异常处理和协作式多任务都在Julia中使用任务实现。日常编程不需要直接使用任务，但是使用任务可以更轻松地解决某些问题。</target>
        </trans-unit>
        <trans-unit id="bc720da072f28a4dbfd483b203295a21a9e3bf91" translate="yes" xml:space="preserve">
          <source>The first index</source>
          <target state="translated">第一个指数</target>
        </trans-unit>
        <trans-unit id="bb11ec038c2596553227120950a5afbedeee7655" translate="yes" xml:space="preserve">
          <source>The first line &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; declares that &lt;code&gt;OurRational&lt;/code&gt; takes one type parameter of an integer type, and is itself a real type. The field declarations &lt;code&gt;num::T&lt;/code&gt; and &lt;code&gt;den::T&lt;/code&gt; indicate that the data held in a &lt;code&gt;OurRational{T}&lt;/code&gt; object are a pair of integers of type &lt;code&gt;T&lt;/code&gt;, one representing the rational value's numerator and the other representing its denominator.</source>
          <target state="translated">第一行&amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash;声明 &lt;code&gt;OurRational&lt;/code&gt; 接受一个整数类型的类型参数，它本身就是一个实数类型。字段声明 &lt;code&gt;num::T&lt;/code&gt; 和 &lt;code&gt;den::T&lt;/code&gt; 表示 &lt;code&gt;OurRational{T}&lt;/code&gt; 对象中保存的数据是一对 &lt;code&gt;T&lt;/code&gt; 类型的整数，一个代表有理值的分子，另一个代表其分母。</target>
        </trans-unit>
        <trans-unit id="427adf0e5c19944f265b6711e004071ffee6d958" translate="yes" xml:space="preserve">
          <source>The first line shows that 80 backtraces were taken at line 73 of &lt;code&gt;event.jl&lt;/code&gt;, but it's not that this line was &quot;expensive&quot; on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to &lt;code&gt;eval_user_input&lt;/code&gt;, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</source>
          <target state="translated">第一行显示80条回溯记录是在 &lt;code&gt;event.jl&lt;/code&gt; 的第73行进行的，但这并不是说该行本身是&amp;ldquo;昂贵的&amp;rdquo;：第三行显示了所有这些80条回溯记录实际上是在其对 &lt;code&gt;eval_user_input&lt;/code&gt; 的调用内触发的，等等。为了弄清楚哪些操作实际上在花时间，我们需要深入研究调用链。</target>
        </trans-unit>
        <trans-unit id="37442d0cb92e69637999d8ebca28303617dca96e" translate="yes" xml:space="preserve">
          <source>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</source>
          <target state="translated">第一个方法适用于两个参数都是相同的具体类型的情况,不管是什么类型,而第二个方法则是一个包罗万象的方法,涵盖了所有其他情况。因此,总的来说,这定义了一个布尔函数,检查它的两个参数是否为同一类型。</target>
        </trans-unit>
        <trans-unit id="babb1cbcd790c4e72ac9f6036b92d0c0da3483a5" translate="yes" xml:space="preserve">
          <source>The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</source>
          <target state="translated">第一条规则说,用任何其他整数类型促进一个有理数的发展,促进到一个其分子/分母类型是其分子/分母类型与其他整数类型促进的结果的有理数类型。第二条规则将同样的逻辑应用于两个不同类型的有理数,结果是它们各自的分子/分母类型的推广的有理数。第三条也是最后一条规则规定,用浮点数推广有理数的结果与用浮点数推广分子/分母类型的结果相同。</target>
        </trans-unit>
        <trans-unit id="5020af03736f636ddf8f18f7a30cb8b1c77d29b4" translate="yes" xml:space="preserve">
          <source>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling &lt;code&gt;jl_init&lt;/code&gt;, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use &lt;code&gt;jl_init_with_image&lt;/code&gt; instead.</source>
          <target state="translated">调用任何其他Julia C函数之前必须做的第一件事是初始化Julia。这是通过调用 &lt;code&gt;jl_init&lt;/code&gt; 完成的，它会尝试自动确定Julia的安装位置。如果需要指定自定义位置或指定要加载的系统映像，请改用 &lt;code&gt;jl_init_with_image&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="823f93752a3686f8e2124abf1332680955d50534" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="translated">首先要注意的是，以上参数声明等效于 &lt;code&gt;x::Any&lt;/code&gt; 和 &lt;code&gt;y::Any&lt;/code&gt; 。调用此函数时，例如说 &lt;code&gt;myplus(2,5)&lt;/code&gt; ，调度程序将选择与给定参数匹配的最特定的方法 &lt;code&gt;myplus&lt;/code&gt; 。（有关更多调度的更多信息，请参见&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a6f07b43794fd555596c18f4ead21c7719a2dcd3" translate="yes" xml:space="preserve">
          <source>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</source>
          <target state="translated">第一个版本的代码形成一个字符串,然后将其写入文件,而第二个版本则直接将值写入文件。同时注意到,在某些情况下,字符串插值会比较难读。可以考虑一下。</target>
        </trans-unit>
        <trans-unit id="7b79b92115c47e04b621f66bea7584e8b8cc8d6b" translate="yes" xml:space="preserve">
          <source>The floating-point literal expression &lt;code&gt;1e10&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1&lt;/code&gt; multiplied by the variable &lt;code&gt;e10&lt;/code&gt;, and similarly with the equivalent &lt;code&gt;E&lt;/code&gt; form.</source>
          <target state="translated">浮点文字表达式 &lt;code&gt;1e10&lt;/code&gt; 可以解释为数字文字 &lt;code&gt;1&lt;/code&gt; 乘以变量 &lt;code&gt;e10&lt;/code&gt; 的方式，并且类似地使用等效的 &lt;code&gt;E&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="b8f774bd2a3cc1859a12b8ce9ea22d04daec926b" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="translated">划分后的商和模数。等效于 &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc58e18ac764f385326b970e654dea814c444fa3" translate="yes" xml:space="preserve">
          <source>The folder &lt;code&gt;clustermanager/0mq&lt;/code&gt; in the &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;Examples repository&lt;/a&gt; contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all &lt;em&gt;logically&lt;/em&gt; connected to each other&amp;ndash;any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</source>
          <target state="translated">该文件夹 &lt;code&gt;clustermanager/0mq&lt;/code&gt; 在&lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;实例库中&lt;/a&gt;包含使用ZeroMQ朱莉娅工人星形拓扑结构，在中间的0MQ经纪人连接的例子。注意：Julia进程仍然在&lt;em&gt;逻辑上&lt;/em&gt;相互连接&amp;ndash;任何工作人员都可以直接向任何其他工作人员发送消息，而不会意识到0MQ被用作传输层。</target>
        </trans-unit>
        <trans-unit id="a25bab23609fe72a03f9f2d28cbc6e4cfaac93b5" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;arithmetic operators&lt;/a&gt; are supported on all primitive numeric types:</source>
          <target state="translated">所有原始数字类型均支持以下&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;算术运算符&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b432537d382d58fcb2012895b80fa177f57617f4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;bitwise operators&lt;/a&gt; are supported on all primitive integer types:</source>
          <target state="translated">所有原始整数类型均支持以下&lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;按位运算符&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bc2ce27e5cd51f5b5da2d26eef20e592177e82dd" translate="yes" xml:space="preserve">
          <source>The following Julia code calls &lt;code&gt;dist&lt;/code&gt; using &lt;code&gt;ccall&lt;/code&gt;:</source>
          <target state="translated">以下Julia代码使用 &lt;code&gt;ccall&lt;/code&gt; 调用 &lt;code&gt;dist&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="82ab1c7eae6116d2e86f4fd6447f19f5008f2767" translate="yes" xml:space="preserve">
          <source>The following are Julia's primitive numeric types:</source>
          <target state="translated">以下是Julia的原始数字类型。</target>
        </trans-unit>
        <trans-unit id="68261312da3f6e4277114d21e46489769870f01a" translate="yes" xml:space="preserve">
          <source>The following arguments, if any, are the actual argument values passed to the function.</source>
          <target state="translated">以下参数(如果有)是传递给函数的实际参数值。</target>
        </trans-unit>
        <trans-unit id="345825a433cae3afd4ca7643a01203ee8503ec4c" translate="yes" xml:space="preserve">
          <source>The following elements can be written either at the &quot;toplevel&quot; of a document or within another &quot;toplevel&quot; element.</source>
          <target state="translated">以下元素可以写在文档的 &quot;toplevel &quot;处,也可以写在另一个 &quot;toplevel &quot;元素中。</target>
        </trans-unit>
        <trans-unit id="5790b1d96d0b783ee001251802dd3d3773c38e07" translate="yes" xml:space="preserve">
          <source>The following escape sequences are recognised:</source>
          <target state="translated">下列逃逸序列被识别。</target>
        </trans-unit>
        <trans-unit id="b2e62d45eb7d1c7cb2ac8b8faa743869642b4084" translate="yes" xml:space="preserve">
          <source>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</source>
          <target state="translated">下面的例子计算了当前元素和它的左邻和右邻沿1-d网格的加权平均值。</target>
        </trans-unit>
        <trans-unit id="07c71a4306d82cac91450f4de662495a1563cd2f" translate="yes" xml:space="preserve">
          <source>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</source>
          <target state="translated">下面的例子计算了一个较大数组的一小部分的QR分解,不需要创建任何时序,通过调用适当的LAPACK函数,使用正确的前导维度大小和跨度参数。</target>
        </trans-unit>
        <trans-unit id="01c45a39447b88a2e0d45df263308e82a86e4712" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</source>
          <target state="translated">下面的例子展示了模块的主要特征。它不是为了运行,而是为了说明问题。</target>
        </trans-unit>
        <trans-unit id="ec34fbe859ef32bab5a71865f07de40a61bead9c" translate="yes" xml:space="preserve">
          <source>The following examples highlight execution in different tasks by returning the &lt;code&gt;objectid&lt;/code&gt; of the tasks in which the mapping function is executed.</source>
          <target state="translated">以下示例通过返回执行映射功能的任务的对象 &lt;code&gt;objectid&lt;/code&gt; 突出显示了在不同任务中的执行。</target>
        </trans-unit>
        <trans-unit id="874609aa4f87e9365e65a6b29283f60a85fb17ac" translate="yes" xml:space="preserve">
          <source>The following examples may help you interpret expressions marked as containing non-leaf types:</source>
          <target state="translated">下面的例子可以帮助您解释被标记为包含非叶型的表达式。</target>
        </trans-unit>
        <trans-unit id="cbdf8c8b616fe2394336d97bc9a1e9b4526f4626" translate="yes" xml:space="preserve">
          <source>The following examples show the different forms.</source>
          <target state="translated">下面的例子显示了不同的形式。</target>
        </trans-unit>
        <trans-unit id="e0233afcec03abf55b61a44d6697627a2028159d" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;BunchKaufman&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt;&lt;code&gt;issymmetric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt;&lt;code&gt;ishermitian&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下函数可用于 &lt;code&gt;BunchKaufman&lt;/code&gt; 对象：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt; &lt;code&gt;issymmetric&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt; &lt;code&gt;ishermitian&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="624545d56fb5f27fa75152ac7cc2635666c3e206" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;Eigen&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下功能可用于本 &lt;code&gt;Eigen&lt;/code&gt; 对象： &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1aea27103439af78084bb11124346f279815f32" translate="yes" xml:space="preserve">
          <source>The following functions are available for the &lt;code&gt;QR&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;\&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; is rectangular, &lt;code&gt;\&lt;/code&gt; will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When &lt;code&gt;A&lt;/code&gt; is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</source>
          <target state="translated">以下功能可用于 &lt;code&gt;QR&lt;/code&gt; 对象： &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;\&lt;/code&gt; 。当 &lt;code&gt;A&lt;/code&gt; 为矩形时， &lt;code&gt;\&lt;/code&gt; 将返回最小二乘解；如果该解不是唯一的，则返回范数最小的解。当 &lt;code&gt;A&lt;/code&gt; 不为全秩时，需要使用（列）枢轴分解以获取最小范数解。</target>
        </trans-unit>
        <trans-unit id="aabc44011e588107ac199e54e743b25f507c9ed0" translate="yes" xml:space="preserve">
          <source>The following functions are not exported:</source>
          <target state="translated">以下函数不输出:</target>
        </trans-unit>
        <trans-unit id="688d351a0c5736fa7ecff6e47939996801847a5a" translate="yes" xml:space="preserve">
          <source>The following language constructs call &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">以下语言构造了调用 &lt;code&gt;convert&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6c5e57131238ccfda9b38e0c3969a02ae25bed8d" translate="yes" xml:space="preserve">
          <source>The following methods and types in &lt;code&gt;Base.StackTraces&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base.StackTraces&lt;/code&gt; 中的以下方法和类型不会导出，需要调用，例如 &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="427d5751feb1ea6470872d5f773b472a734eb30c" translate="yes" xml:space="preserve">
          <source>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</source>
          <target state="translated">以下方法被描述为 &quot;不安全&quot;,因为一个错误的指针或类型声明会导致Julia突然终止。</target>
        </trans-unit>
        <trans-unit id="b0ebcfaf65e09f2421f1536d1962299cfa2d23fa" translate="yes" xml:space="preserve">
          <source>The following operators are supported for arrays:</source>
          <target state="translated">数组支持以下运算符。</target>
        </trans-unit>
        <trans-unit id="61cb6687852400c8b9d8a7c3529a66703d4cce18" translate="yes" xml:space="preserve">
          <source>The following properties are in common use:</source>
          <target state="translated">以下是常用的属性。</target>
        </trans-unit>
        <trans-unit id="d1b72ce471ac18a5159131679678a4b35625017b" translate="yes" xml:space="preserve">
          <source>The following rules and examples pertain to local scopes. A newly introduced variable in a local scope cannot be referenced by a parent scope. For example, here the $z$ is not introduced into the top-level scope:</source>
          <target state="translated">下面的规则和示例与局部作用域有关。在局部作用域中新引入的变量不能被父作用域引用。例如,这里的$z$没有被引入到顶层作用域中。</target>
        </trans-unit>
        <trans-unit id="b337c7ef95094018464c8f26d41814785e93faec" translate="yes" xml:space="preserve">
          <source>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</source>
          <target state="translated">下面的章节解释了习惯性Julia编码风格的几个方面。这些规则都不是绝对的,它们只是一些建议,以帮助您熟悉这门语言,并帮助您在其他设计中做出选择。</target>
        </trans-unit>
        <trans-unit id="599c61734f3be9adb8efdea5a3e2879b8d0d65f5" translate="yes" xml:space="preserve">
          <source>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix &lt;code&gt;S&lt;/code&gt;, or that the resulting sparse matrix has density &lt;code&gt;d&lt;/code&gt;, i.e. each matrix element has a probability &lt;code&gt;d&lt;/code&gt; of being non-zero.</source>
          <target state="translated">下表给出了稀疏矩阵的内置方法与稠密矩阵类型的相应方法之间的对应关系。一般而言，生成稀疏矩阵的方法从它们的稠密对应物不同，所述所得矩阵遵循相同的稀疏图案作为给定的稀疏矩阵 &lt;code&gt;S&lt;/code&gt; ，或所得到的稀疏矩阵具有密度 &lt;code&gt;d&lt;/code&gt; ，即，每个矩阵元素具有概率 &lt;code&gt;d&lt;/code&gt; 的感非零。</target>
        </trans-unit>
        <trans-unit id="2850e916b8328a8067cb56753c2fae6f207d9a41" translate="yes" xml:space="preserve">
          <source>The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments). You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing &lt;code&gt;?&lt;/code&gt; and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).</source>
          <target state="translated">下表列出了可以在Julia REPL（以及其他各种编辑环境）中通过LaTeX类缩写的制表符补全输入的Unicode字符。您还可以通过在REPL帮助中输入符号来获取有关如何键入符号的信息，即键入 &lt;code&gt;?&lt;/code&gt; 。然后在REPL中输入该符号（例如，从您看到该符号的位置进行复制粘贴）。</target>
        </trans-unit>
        <trans-unit id="84caf0f2b4e520eb1362c7d90034a53ce384352e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Standard Functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="translated">下表总结了在Julia中实现的矩阵分解的类型。可以在线性代数文档的&amp;ldquo; &lt;a href=&quot;#Standard-Functions-1&quot;&gt;标准功能&amp;rdquo;&lt;/a&gt;部分中找到其相关方法的详细信息。</target>
        </trans-unit>
        <trans-unit id="a5e3ae439be1705d14dc31df2b803cc4528033bf" translate="yes" xml:space="preserve">
          <source>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</source>
          <target state="translated">下表总结了Julia中已经实现的特殊矩阵的类型,以及在LAPACK中是否有针对它们的各种优化方法的钩子。</target>
        </trans-unit>
        <trans-unit id="58787cfe45db809926391f964f8c2fe50eb9c66e" translate="yes" xml:space="preserve">
          <source>The following two-word sequences are reserved: &lt;code&gt;abstract type&lt;/code&gt;, &lt;code&gt;mutable struct&lt;/code&gt;, &lt;code&gt;primitive type&lt;/code&gt;. However, you can create variables with names: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;mutable&lt;/code&gt;, &lt;code&gt;primitive&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">保留了以下两个单词序列： &lt;code&gt;abstract type&lt;/code&gt; ， &lt;code&gt;mutable struct&lt;/code&gt; ， &lt;code&gt;primitive type&lt;/code&gt; 。但是，您可以使用以下名称创建变量： &lt;code&gt;abstract&lt;/code&gt; ， &lt;code&gt;mutable&lt;/code&gt; ， &lt;code&gt;primitive&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c16965f50c24120006902ac240b6d5249b8840ca" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.answer_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that output should have at the terminal.</source>
          <target state="translated">输出应在终端上具有的格式 &lt;code&gt;Base.answer_color()&lt;/code&gt; （默认值：正常， &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="2a94f6ed982371cc454e13d3c41d22bd28f7000c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.error_color()&lt;/code&gt; (default: light red, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt;) that errors should have at the terminal.</source>
          <target state="translated">终端应有错误的格式 &lt;code&gt;Base.error_color()&lt;/code&gt; （默认：浅红色， &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5bedb24b2b2a4f0d544b13331782037e6b751d7c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.info_color()&lt;/code&gt; (default: cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt;) that info should have at the terminal.</source>
          <target state="translated">信息应该在终端上具有的格式 &lt;code&gt;Base.info_color()&lt;/code&gt; （默认：青色， &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9abdd1879aac44fbed37a23e8cd8c9521c6a3a7b" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.input_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that input should have at the terminal.</source>
          <target state="translated">输入应在终端上具有的格式 &lt;code&gt;Base.input_color()&lt;/code&gt; （默认值：正常， &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="5c3246893833440c6ee277a6f4469b2f678db3a7" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that function calls should have during a stack trace at the terminal.</source>
          <target state="translated">在终端进行堆栈跟踪时，函数调用应具有的格式 &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; （默认值：粗体， &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="276edac3df59db618aba660c48a61b72521725f5" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that line info should have during a stack trace at the terminal.</source>
          <target state="translated">在终端进行堆栈跟踪时，行信息应具有的格式 &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; （默认值：粗体， &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="5a3d58af274070ed561a7473fe7be9c81a95ede6" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.warn_color()&lt;/code&gt; (default: yellow, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt;) that warnings should have at the terminal.</source>
          <target state="translated">终端应具有警告的格式化 &lt;code&gt;Base.warn_color()&lt;/code&gt; 格式（默认值：黄色， &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e430bf906d90ec3cbe26e6641c11eeda24fe35ca" translate="yes" xml:space="preserve">
          <source>The former is a single character value of type &lt;code&gt;Char&lt;/code&gt;, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</source>
          <target state="translated">前者是 &lt;code&gt;Char&lt;/code&gt; 类型的单个字符值，而后者是恰好只包含一个字符的字符串值。在朱莉娅，这些是完全不同的事情。</target>
        </trans-unit>
        <trans-unit id="d152dae5600534a9646e1a87a36f09f36dd3ded5" translate="yes" xml:space="preserve">
          <source>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and the second due to the &lt;code&gt;fetch&lt;/code&gt; (or even a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;fetch&lt;/code&gt;/&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is also being executed serially resulting in an overall poorer performance.</source>
          <target state="translated">前者导致与每个工作人员的单个网络往返，而后者则导致两个网络调用-第一个是&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;，第二个是由于 &lt;code&gt;fetch&lt;/code&gt; （甚至是&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;）。该 &lt;code&gt;fetch&lt;/code&gt; / &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;也被串行执行导致整体性能较差。</target>
        </trans-unit>
        <trans-unit id="d93e33c90f8c053ee253be6b3d20b4b263f781d7" translate="yes" xml:space="preserve">
          <source>The fully expanded value of &lt;code&gt;LOAD_PATH&lt;/code&gt; that is searched for projects and packages can be seen by calling the &lt;code&gt;Base.load_path()&lt;/code&gt; function.</source>
          <target state="translated">可以通过调用 &lt;code&gt;Base.load_path()&lt;/code&gt; 函数来查看用于搜索项目和程序包的 &lt;code&gt;LOAD_PATH&lt;/code&gt; 的完全展开的值。</target>
        </trans-unit>
        <trans-unit id="53cd7e3be35b834ce5e0e038f9eb6daebb41c365" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;count_heads&lt;/code&gt; simply adds together &lt;code&gt;n&lt;/code&gt; random bits. Here is how we can perform some trials on two machines, and add together the results:</source>
          <target state="translated">函数 &lt;code&gt;count_heads&lt;/code&gt; 只是将 &lt;code&gt;n&lt;/code&gt; 个随机位加在一起。这是我们可以在两台机器上进行一些试验并将结果加在一起的方法：</target>
        </trans-unit>
        <trans-unit id="1a7009ac781780ee28678319854f5347c9495c13" translate="yes" xml:space="preserve">
          <source>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</source>
          <target state="translated">函数调用增长超过了调用栈的大小。这种情况通常发生在一个调用无限循环的时候。</target>
        </trans-unit>
        <trans-unit id="da6b2e5a2ff44122d7db169754c14ee6b172e967" translate="yes" xml:space="preserve">
          <source>The function in which &lt;code&gt;@boundscheck&lt;/code&gt; is written must be inlined into its caller in order for &lt;code&gt;@inbounds&lt;/code&gt; to have effect.</source>
          <target state="translated">必须将写入 &lt;code&gt;@boundscheck&lt;/code&gt; 的函数内联到其调用程序中，以使 &lt;code&gt;@inbounds&lt;/code&gt; 生效。</target>
        </trans-unit>
        <trans-unit id="39d7cf55fabb709098be0379cf1a36954e7ad2fc" translate="yes" xml:space="preserve">
          <source>The function parameter &lt;code&gt;f&lt;/code&gt; should have following signature:</source>
          <target state="translated">函数参数 &lt;code&gt;f&lt;/code&gt; 应该具有以下签名：</target>
        </trans-unit>
        <trans-unit id="c1a0f9cdfffaafbbc345f4ef6dcd681fce922423" translate="yes" xml:space="preserve">
          <source>The function reads the cookie from stdin if required, and listens on a free port (or if specified, the port in the &lt;code&gt;--bind-to&lt;/code&gt; command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</source>
          <target state="translated">如果需要，该函数从stdin读取cookie，并在空闲端口（或指定的 &lt;code&gt;--bind-to&lt;/code&gt; 命令行选项中的端口）上侦听，并计划任务以处理传入的TCP连接和请求。它还（可选）关闭stdin并将stderr重定向到stdout。</target>
        </trans-unit>
        <trans-unit id="b716ab0d4ac152e4a4f9c6b1390eb5136f17d5d2" translate="yes" xml:space="preserve">
          <source>The garbage collector does not guarantee any order of finalization. That is, if &lt;code&gt;a&lt;/code&gt; contained a reference to &lt;code&gt;b&lt;/code&gt; and both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are due for garbage collection, there is no guarantee that &lt;code&gt;b&lt;/code&gt; would be finalized after &lt;code&gt;a&lt;/code&gt;. If proper finalization of &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt; being valid, it must be handled in other ways.</source>
          <target state="translated">垃圾收集器不保证任何终结命令。也就是说，如果 &lt;code&gt;a&lt;/code&gt; 包含对 &lt;code&gt;b&lt;/code&gt; 的引用，并且 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都应进行垃圾回收，则不能保证 &lt;code&gt;b&lt;/code&gt; 将在 &lt;code&gt;a&lt;/code&gt; 之后完成。如果正确确定 &lt;code&gt;a&lt;/code&gt; 取决于 &lt;code&gt;b&lt;/code&gt; 是否有效，则必须以其他方式进行处理。</target>
        </trans-unit>
        <trans-unit id="2c5ffa9d8537b10e07bd1e1cd0016a03d6887376" translate="yes" xml:space="preserve">
          <source>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the &lt;code&gt;jl_gc_wb&lt;/code&gt; (write barrier) function like so:</source>
          <target state="translated">垃圾收集器在假设它知道每个指向年轻一代对象的旧对象的假设下运行。每当指针更新打破该假设时，都必须使用 &lt;code&gt;jl_gc_wb&lt;/code&gt; （写屏障）函数将其发送给收集器，如下所示：</target>
        </trans-unit>
        <trans-unit id="7f907da64c464f65fc72aafc195dfebc2e4f4da6" translate="yes" xml:space="preserve">
          <source>The general syntax for assigning values in an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">在n维数组 &lt;code&gt;A&lt;/code&gt; 中分配值的一般语法为：</target>
        </trans-unit>
        <trans-unit id="7f7fec22031b950929a2be2bf28c88a4e32319b3" translate="yes" xml:space="preserve">
          <source>The general syntax for indexing into an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">索引到n维数组 &lt;code&gt;A&lt;/code&gt; 的一般语法为：</target>
        </trans-unit>
        <trans-unit id="03b4ccfaa881cd16fd244ada75dc950f11a8dd7c" translate="yes" xml:space="preserve">
          <source>The general syntaxes for declaring a primitive type are:</source>
          <target state="translated">声明一个基元类型的一般语法是:。</target>
        </trans-unit>
        <trans-unit id="3e8b49d87c21864e9239600316a0864509f86bdd" translate="yes" xml:space="preserve">
          <source>The generalized eigenvalues are returned in &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt;. The left Schur vectors are returned in &lt;code&gt;vsl&lt;/code&gt; and the right Schur vectors are returned in &lt;code&gt;vsr&lt;/code&gt;.</source>
          <target state="translated">广义特征值以 &lt;code&gt;alpha&lt;/code&gt; 和 &lt;code&gt;beta&lt;/code&gt; 返回。左舒尔载体在返回 &lt;code&gt;vsl&lt;/code&gt; 和正确的舒尔载体在返回 &lt;code&gt;vsr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa0ec4e7835e3ddd782c0a7070e015136b4b04a9" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="translated">全局常数&lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt;绑定到复数&lt;em&gt;i&lt;/em&gt;，代表-1的主平方根。（由于使用了普遍的索引变量名称，因此拒绝使用数学家的 &lt;code&gt;i&lt;/code&gt; 或工程师的 &lt;code&gt;j&lt;/code&gt; 作为通用全局变量。）由于Julia允许将数字文字&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;与标识符作为系数并置&lt;/a&gt;，该绑定足以为复数提供方便的语法，类似传统的数学符号：</target>
        </trans-unit>
        <trans-unit id="ef1d21913b7da2cd50221a9ea53be6e2ac79e4fa" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="translated">可以使用&lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt; &lt;code&gt;global_logger&lt;/code&gt; &lt;/a&gt;设置全局记录器，并使用&lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt; &lt;code&gt;with_logger&lt;/code&gt; &lt;/a&gt;控制本地任务记录器。新产生的任务继承了父任务的记录器。</target>
        </trans-unit>
        <trans-unit id="65f673e90f9a09b859b5b51800816fab3de4b761" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determines a relative path from &lt;code&gt;Sys.BINDIR&lt;/code&gt; to the data directory associated with Julia. Then the path</source>
          <target state="translated">全局变量 &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; 确定从 &lt;code&gt;Sys.BINDIR&lt;/code&gt; 到与Julia关联的数据目录的相对路径。然后的路径</target>
        </trans-unit>
        <trans-unit id="e3bc80be4d521baacc06dd9873b328760a93de88" translate="yes" xml:space="preserve">
          <source>The golden ratio.</source>
          <target state="translated">黄金比例。</target>
        </trans-unit>
        <trans-unit id="354c17f25309f78f252b602097180cb50161163d" translate="yes" xml:space="preserve">
          <source>The group id of the file owner</source>
          <target state="translated">文件所有者的组ID</target>
        </trans-unit>
        <trans-unit id="9e739954ff8de8447d1ab16a3adde7a80c985194" translate="yes" xml:space="preserve">
          <source>The hexadecimal integer literal expression &lt;code&gt;0xff&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;0&lt;/code&gt; multiplied by the variable &lt;code&gt;xff&lt;/code&gt;.</source>
          <target state="translated">十六进制整数文字表达式 &lt;code&gt;0xff&lt;/code&gt; 可解释为数字文字 &lt;code&gt;0&lt;/code&gt; 乘以变量 &lt;code&gt;xff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49109aa658d7c92b2a2e148756ac4fc9b1efb6c1" translate="yes" xml:space="preserve">
          <source>The highest finite value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">给定浮点数据类型 &lt;code&gt;T&lt;/code&gt; 表示的最高有限值。</target>
        </trans-unit>
        <trans-unit id="1c54bd6057f9e745e71a4f119d94151d139d45e8" translate="yes" xml:space="preserve">
          <source>The highest value representable by the given (real) numeric &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">给定（实际）数字 &lt;code&gt;DataType&lt;/code&gt; 可表示的最大值。</target>
        </trans-unit>
        <trans-unit id="3d03859ad784bc750f8658c68023988ea70e276c" translate="yes" xml:space="preserve">
          <source>The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</source>
          <target state="translated">主机必须有必要的SIMD寄存器。例如,上面的代码在没有AVX支持的主机上将无法工作。</target>
        </trans-unit>
        <trans-unit id="69486992100b48c68c6ad0bb1508ce13148c9067" translate="yes" xml:space="preserve">
          <source>The hour of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的小时。</target>
        </trans-unit>
        <trans-unit id="0ae14cb6dca4ab146e83e6f66251f24254e3bb17" translate="yes" xml:space="preserve">
          <source>The hour of day of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 的一天中的小时，作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b1bfeaaafc9c1b963fac8395380b6b23cf36c72" translate="yes" xml:space="preserve">
          <source>The hour part of a DateTime as a &lt;code&gt;Hour&lt;/code&gt;.</source>
          <target state="translated">DateTime的小时部分，作为 &lt;code&gt;Hour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3215c43ad10d3da4db391c4e4892aec7413196da" translate="yes" xml:space="preserve">
          <source>The identity function. Returns its argument.</source>
          <target state="translated">身份函数。返回其参数。</target>
        </trans-unit>
        <trans-unit id="c738dd3a82cae47bce1402d7e9ed9b1a08ec88db" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;j&lt;/code&gt; as in MATLAB.</source>
          <target state="translated">虚数单位 &lt;code&gt;sqrt(-1)&lt;/code&gt; 在Julia中表示为&lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt;，而不在MATLAB中 &lt;code&gt;j&lt;/code&gt; 为 &lt;code&gt;i&lt;/code&gt; 或j。</target>
        </trans-unit>
        <trans-unit id="7823efd88570f05c6cdcdeba7b9c6d877d28d4c3" translate="yes" xml:space="preserve">
          <source>The imaginary unit.</source>
          <target state="translated">虚单位。</target>
        </trans-unit>
        <trans-unit id="d2f3b37cc4a76dd392140d18be234dc4fa787173" translate="yes" xml:space="preserve">
          <source>The implementation of this behavior is a &quot;world age counter&quot;. This monotonically increasing value tracks each method definition operation. This allows describing &quot;the set of method definitions visible to a given runtime environment&quot; as a single number, or &quot;world age&quot;. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the &quot;current world&quot; (in which the method &lt;code&gt;newfun&lt;/code&gt; exists), is one greater than the task-local &quot;runtime world&quot; that was fixed when the execution of &lt;code&gt;tryeval&lt;/code&gt; started.</source>
          <target state="translated">此行为的实现是&amp;ldquo;世界年龄计数器&amp;rdquo;。该单调递增的值跟踪每个方法定义操作。这允许将&amp;ldquo;对给定运行时环境可见的方法定义集&amp;rdquo;描述为一个数字或&amp;ldquo;世界年龄&amp;rdquo;。它也允许仅通过比较它们的序数值来比较两个世界中可用的方法。在上面的示例中，我们看到&amp;ldquo;当前世界&amp;rdquo;（存在 &lt;code&gt;newfun&lt;/code&gt; 方法）比在 &lt;code&gt;tryeval&lt;/code&gt; 开始执行时固定的任务本地&amp;ldquo;运行时世界&amp;rdquo;大一个。</target>
        </trans-unit>
        <trans-unit id="b253e7f28529381ae2517e2dd4df05c0e78e871f" translate="yes" xml:space="preserve">
          <source>The incremental precompiled module file are created and used automatically when using &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;using&lt;/code&gt; to load a module. This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt;&lt;code&gt;Base.compilecache(modulename)&lt;/code&gt;&lt;/a&gt;. The resulting cache files will be stored in &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt;. Subsequently, the module is automatically recompiled upon &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt;&lt;code&gt;include_dependency(path)&lt;/code&gt;&lt;/a&gt; in the module file(s).</source>
          <target state="translated">增量预编译模块文件创建和使用时自动使用 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;using&lt;/code&gt; 加载的模块。这将导致它在首次导入时被自动编译。或者，您可以手动调用&lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt; &lt;code&gt;Base.compilecache(modulename)&lt;/code&gt; &lt;/a&gt;。生成的缓存文件将存储在 &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt; 。随后，每当其依赖项发生任何更改时，模块都会在 &lt;code&gt;using&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 时自动重新编译；依赖项是它导入的模块，Julia构建，包含的文件或由模块文件中的&lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt; &lt;code&gt;include_dependency(path)&lt;/code&gt; &lt;/a&gt;声明的显式依赖项。</target>
        </trans-unit>
        <trans-unit id="13dd8189d32c7c1290b037751919f6e30e7f64f8" translate="yes" xml:space="preserve">
          <source>The individual components of the decomposition &lt;code&gt;F&lt;/code&gt; can be retrieved via property accessors:</source>
          <target state="translated">分解 &lt;code&gt;F&lt;/code&gt; 的各个组成部分可以通过属性访问器检索：</target>
        </trans-unit>
        <trans-unit id="ce0913135fd9f357f77350a326cce1c8ed6fa49d" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="translated">可以通过 &lt;code&gt;getproperty&lt;/code&gt; 访问分解因子 &lt;code&gt;F&lt;/code&gt; 的各个组件：</target>
        </trans-unit>
        <trans-unit id="c6e01ca13a398bafdf18f4d4f60195a783a431cf" translate="yes" xml:space="preserve">
          <source>The infix form is exactly equivalent to the function application form &amp;ndash; in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;*&lt;/code&gt; just like you would with other function values:</source>
          <target state="translated">中缀形式与功能应用程序形式完全等效&amp;ndash;实际上，前者被解析为内部产生函数调用。这也意味着您可以像其他函数值一样分配和传递&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;*&lt;/code&gt; 等运算符：</target>
        </trans-unit>
        <trans-unit id="ab93d805a4e1efd3cacbdba9a517e0dc2379a9e4" translate="yes" xml:space="preserve">
          <source>The infix operation &lt;code&gt;a ⊻ b&lt;/code&gt; is a synonym for &lt;code&gt;xor(a,b)&lt;/code&gt;, and &lt;code&gt;⊻&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\xor&lt;/code&gt; or &lt;code&gt;\veebar&lt;/code&gt; in the Julia REPL.</source>
          <target state="translated">中缀运算 &lt;code&gt;a ⊻ b&lt;/code&gt; 为同义词 &lt;code&gt;xor(a,b)&lt;/code&gt; ，和 &lt;code&gt;⊻&lt;/code&gt; 可以通过制表完成键入 &lt;code&gt;\xor&lt;/code&gt; 或 &lt;code&gt;\veebar&lt;/code&gt; 在朱莉娅REPL。</target>
        </trans-unit>
        <trans-unit id="e1b31695e555eb78c96b1ce43ed5d4b769be43f4" translate="yes" xml:space="preserve">
          <source>The initial Julia process, also called the &lt;code&gt;master&lt;/code&gt;, is special and has an &lt;code&gt;id&lt;/code&gt; of 1.</source>
          <target state="translated">最初的Julia流程（也称为 &lt;code&gt;master&lt;/code&gt; ）很特殊，其 &lt;code&gt;id&lt;/code&gt; 为1。</target>
        </trans-unit>
        <trans-unit id="46aabc78dd4e507670425bdb3bf204611d3ffb13" translate="yes" xml:space="preserve">
          <source>The inode number of the file</source>
          <target state="translated">文件的inode号</target>
        </trans-unit>
        <trans-unit id="204c42952f2670f515bfe08f06a0ba3dd55c909a" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输入 &lt;code&gt;n&lt;/code&gt; 通过值传递，因此该函数的输入签名仅声明为 &lt;code&gt;(Csize_t,)&lt;/code&gt; ,而无需任何 &lt;code&gt;Ref&lt;/code&gt; 或 &lt;code&gt;Ptr&lt;/code&gt; 。（如果包装程序改为调用Fortran函数，则相应的函数输入签名应为 &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt; ，因为Fortran变量是通过指针传递的。）此外， &lt;code&gt;n&lt;/code&gt; 可以是可转换为 &lt;code&gt;Csize_t&lt;/code&gt; 整数的任何类型。; 在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;隐式调用&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8b235e73123abb02c8610a64480c17659bc5e36" translate="yes" xml:space="preserve">
          <source>The input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; will not contain their eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called. They are used as workspaces.</source>
          <target state="translated">输入矩阵 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 在进行 &lt;code&gt;eigvals!&lt;/code&gt; 之后将不包含其特征值！叫做。它们用作工作区。</target>
        </trans-unit>
        <trans-unit id="a25e9d14fa9f0f89dab37c152c425a3aebebbd0f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;A&lt;/code&gt; will not contain its eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called on it - &lt;code&gt;A&lt;/code&gt; is used as a workspace.</source>
          <target state="translated">输入矩阵 &lt;code&gt;A&lt;/code&gt; 将在 &lt;code&gt;eigvals!&lt;/code&gt; 之后不包含其特征值！被称为 &lt;code&gt;A&lt;/code&gt; 用作工作空间。</target>
        </trans-unit>
        <trans-unit id="1417019c8a8204f046e43b52db1e1b8dfe779fc9" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; is not transposed or conjugated.</source>
          <target state="translated">输入矩阵 &lt;code&gt;X&lt;/code&gt; 不转置或共轭。</target>
        </trans-unit>
        <trans-unit id="696317e85c44155ed1679065a21cab9ea0d94c6f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be conjugated and transposed.</source>
          <target state="translated">输入矩阵 &lt;code&gt;X&lt;/code&gt; 将被共轭和转置。</target>
        </trans-unit>
        <trans-unit id="edc49f341fce73dbc1b810339993fe819e7483f6" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be transposed.</source>
          <target state="translated">输入矩阵 &lt;code&gt;X&lt;/code&gt; 将被转置。</target>
        </trans-unit>
        <trans-unit id="ce8cf57c3583cc5f6f01c812980b6d9e8e041658" translate="yes" xml:space="preserve">
          <source>The intuition behind this behavior is that &lt;code&gt;x&lt;/code&gt; is evaluated once for each &lt;code&gt;$&lt;/code&gt;: one &lt;code&gt;$&lt;/code&gt; works similarly to &lt;code&gt;eval(:x)&lt;/code&gt;, giving &lt;code&gt;x&lt;/code&gt;'s value, while two &lt;code&gt;$&lt;/code&gt;s do the equivalent of &lt;code&gt;eval(eval(:x))&lt;/code&gt;.</source>
          <target state="translated">这种行为背后的直觉是，每个 &lt;code&gt;$&lt;/code&gt; 都会对 &lt;code&gt;x&lt;/code&gt; 进行一次评估：一个 &lt;code&gt;$&lt;/code&gt; 与 &lt;code&gt;eval(:x)&lt;/code&gt; 的工作原理类似，给出 &lt;code&gt;x&lt;/code&gt; 的值，而两个 &lt;code&gt;$&lt;/code&gt; 相当于 &lt;code&gt;eval(eval(:x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9951fb03011eb6ccac99ddca5a1c8a2596a1921f" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt; functions is &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, which retrieves the inputs used to create the sparse array. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; returns the cartesian indices of non-zero entries in &lt;code&gt;x&lt;/code&gt; (including stored entries equal to zero).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt;函数的反函数是&lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt;，它检索用于创建稀疏数组的输入。 &lt;code&gt;findall(!iszero, x)&lt;/code&gt; 返回非零条目的笛卡尔指数 &lt;code&gt;x&lt;/code&gt; （包括存储的条目等于零）。</target>
        </trans-unit>
        <trans-unit id="08e030af941b44ba6a6057a4b8409ccf9a09fa65" translate="yes" xml:space="preserve">
          <source>The item or field is not defined for the given object.</source>
          <target state="translated">项目或字段没有为给定对象定义。</target>
        </trans-unit>
        <trans-unit id="5978b1760bac737678645da104214e401ee6745d" translate="yes" xml:space="preserve">
          <source>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="translated">迭代空间在线程之间被分割,之后每个线程将其线程ID写入其分配的位置。</target>
        </trans-unit>
        <trans-unit id="27814682e2f12bb813126e15aaa61e9b9ecadb0b" translate="yes" xml:space="preserve">
          <source>The keyword argument &lt;code&gt;topology&lt;/code&gt; passed to &lt;code&gt;addprocs&lt;/code&gt; is used to specify how the workers must be connected to each other:</source>
          <target state="translated">传递给 &lt;code&gt;addprocs&lt;/code&gt; 的关键字参数 &lt;code&gt;topology&lt;/code&gt; 用于指定工作程序必须如何相互连接：</target>
        </trans-unit>
        <trans-unit id="071e1626e259689d138d5d354cd990a797f9cc76" translate="yes" xml:space="preserve">
          <source>The keyword argument is:</source>
          <target state="translated">关键字参数是。</target>
        </trans-unit>
        <trans-unit id="b53040371261a8a003dc97b8ee4567faef82b0f5" translate="yes" xml:space="preserve">
          <source>The keyword arguments are:</source>
          <target state="translated">关键字的参数是:</target>
        </trans-unit>
        <trans-unit id="aff2628de569031caf118a1cfbb476e502ae8a02" translate="yes" xml:space="preserve">
          <source>The keyword arguments can be any combination of:</source>
          <target state="translated">关键字参数可以是以下的任意组合。</target>
        </trans-unit>
        <trans-unit id="88a5016b4ada3cfa1d337884f9c60b1547e662dc" translate="yes" xml:space="preserve">
          <source>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">关键字参数确定应监视哪个读和/或写状态；至少其中之一必须设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c36d11485ade8e4d84f52006bfe2371bd7a3a31" translate="yes" xml:space="preserve">
          <source>The keyword debuginfo controls the amount of code metadata present in the output.</source>
          <target state="translated">关键字debuginfo控制了输出中代码元数据的数量。</target>
        </trans-unit>
        <trans-unit id="1c08fd56fd5a7ec1b4c4d5ce6e7cd9fc470d3bc9" translate="yes" xml:space="preserve">
          <source>The largest &lt;code&gt;a^n&lt;/code&gt; not greater than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must not be less than 1.</source>
          <target state="translated">最大 &lt;code&gt;a^n&lt;/code&gt; 不大于 &lt;code&gt;x&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是一个非负整数。 &lt;code&gt;a&lt;/code&gt; 必须大于1， &lt;code&gt;x&lt;/code&gt; 不得小于1。</target>
        </trans-unit>
        <trans-unit id="1950191e788c00e6e81f70c06794860257be97cd" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer representable in the given floating-point type &lt;code&gt;T&lt;/code&gt; that also does not exceed the maximum integer representable by the integer type &lt;code&gt;S&lt;/code&gt;. Equivalently, it is the minimum of &lt;code&gt;maxintfloat(T)&lt;/code&gt; and &lt;a href=&quot;#Base.typemax&quot;&gt;&lt;code&gt;typemax(S)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在给定的浮点类型 &lt;code&gt;T&lt;/code&gt; 中可以表示的最大连续整数，该连续整数也不超过整数类型 &lt;code&gt;S&lt;/code&gt; 可以表示的最大整数。等效地，它是 &lt;code&gt;maxintfloat(T)&lt;/code&gt; 和&lt;a href=&quot;#Base.typemax&quot;&gt; &lt;code&gt;typemax(S)&lt;/code&gt; &lt;/a&gt;的最小值。</target>
        </trans-unit>
        <trans-unit id="ecdd0c5829d6c2ebd17e2173ff4d8725a651c73f" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type &lt;code&gt;T&lt;/code&gt; (which defaults to &lt;code&gt;Float64&lt;/code&gt;).</source>
          <target state="translated">在给定的浮点类型 &lt;code&gt;T&lt;/code&gt; （默认为 &lt;code&gt;Float64&lt;/code&gt; ）中精确表示的最大连续整数值浮点数。</target>
        </trans-unit>
        <trans-unit id="45d85758b569bacb3008f9cd5ec57f8b5348a342" translate="yes" xml:space="preserve">
          <source>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call &lt;code&gt;free&lt;/code&gt; on the data pointer when the array is no longer referenced.</source>
          <target state="translated">最后一个参数是一个布尔值，指示Julia是否应拥有该数据的所有权。如果此参数为非零值，则当不再引用该数组时，GC将在数据指针上调用 &lt;code&gt;free&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c54e90c8086ffbb492a0993d80791c5e4dea811" translate="yes" xml:space="preserve">
          <source>The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.</source>
          <target state="translated">最后一个参数是保存对象的表达式。前面的参数是要保存的对象。</target>
        </trans-unit>
        <trans-unit id="ea0fbbe9568bcd71edf3e46185498b21db11849e" translate="yes" xml:space="preserve">
          <source>The last definition of &lt;code&gt;addone&lt;/code&gt; handles any type supporting &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; (which returns 1 in the same type as &lt;code&gt;x&lt;/code&gt;, which avoids unwanted type promotion) and the &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; function with those arguments. The key thing to realize is that there is &lt;em&gt;no performance penalty&lt;/em&gt; to defining &lt;em&gt;only&lt;/em&gt; the general &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt;, because Julia will automatically compile specialized versions as needed. For example, the first time you call &lt;code&gt;addone(12)&lt;/code&gt;, Julia will automatically compile a specialized &lt;code&gt;addone&lt;/code&gt; function for &lt;code&gt;x::Int&lt;/code&gt; arguments, with the call to &lt;code&gt;oneunit&lt;/code&gt; replaced by its inlined value &lt;code&gt;1&lt;/code&gt;. Therefore, the first three definitions of &lt;code&gt;addone&lt;/code&gt; above are completely redundant with the fourth definition.</source>
          <target state="translated">&lt;code&gt;addone&lt;/code&gt; 的最后一个定义处理任何支持&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; 的&lt;/a&gt;类型（返回与 &lt;code&gt;x&lt;/code&gt; 相同类型的1，避免不必要的类型提升）和带有这些参数的&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;函数。要意识到的关键是，&lt;em&gt;仅&lt;/em&gt;定义通用 &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt; &lt;em&gt;不会对性能&lt;/em&gt;造成&lt;em&gt;任何影响&lt;/em&gt;，因为Julia会根据需要自动编译专用版本。例如，第一次调用 &lt;code&gt;addone(12)&lt;/code&gt; 时，Julia将自动为 &lt;code&gt;x::Int&lt;/code&gt; 参数编译一个专门的 &lt;code&gt;addone&lt;/code&gt; 函数，并调用 &lt;code&gt;oneunit&lt;/code&gt; &lt;em&gt;&lt;/em&gt;替换为其内联值 &lt;code&gt;1&lt;/code&gt; 。因此，上述 &lt;code&gt;addone&lt;/code&gt; 的前三个定义与第四个定义完全无关。</target>
        </trans-unit>
        <trans-unit id="ce1654d58ffca436a4c577b1711a64e839d84f92" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; can also look for a character literal.</source>
          <target state="translated">最后一个例子表明，&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;也可以查找字符文字。</target>
        </trans-unit>
        <trans-unit id="c71585d1662e0c9426691e517fa7355c40e4926e" translate="yes" xml:space="preserve">
          <source>The last index, used in &lt;code&gt;X[end]&lt;/code&gt;</source>
          <target state="translated">最后一个索引，用在 &lt;code&gt;X[end]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85a1c4b01d2974399d332fe3cfffd4d1b569afd3" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="translated">元组类型&lt;a href=&quot;#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;的最后一个参数可以是特殊类型 &lt;code&gt;Vararg&lt;/code&gt; ，它表示任意数量的尾随元素。 &lt;code&gt;Vararg{T,N}&lt;/code&gt; 类型恰好对应于 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;N&lt;/code&gt; 个元素。 &lt;code&gt;Vararg{T}&lt;/code&gt; 对应于零个或多个类型 &lt;code&gt;T&lt;/code&gt; 的元素。 &lt;code&gt;Vararg&lt;/code&gt; 元组类型用于表示varargs方法接受的参数（请参见手册中有关&lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs函数&lt;/a&gt;的部分。）</target>
        </trans-unit>
        <trans-unit id="acef1648e92638f5fc5abaed16365a6d53367ba2" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type can be the special type &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;, which denotes any number of trailing elements:</source>
          <target state="translated">元组类型的最后一个参数可以是特殊类型&lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt;，它表示任意数量的尾随元素：</target>
        </trans-unit>
        <trans-unit id="1d6eefa466648c5ff477244c5653b68c2b829837" translate="yes" xml:space="preserve">
          <source>The last point is potentially surprising and thus worth noting:</source>
          <target state="translated">最后一点有可能令人吃惊,因此值得注意。</target>
        </trans-unit>
        <trans-unit id="e7ffcc1d6667c70bd8fd7c442814f44c7c9628ab" translate="yes" xml:space="preserve">
          <source>The last rule applies for immutable objects even if the variable binding would change, e.g.:</source>
          <target state="translated">最后一条规则适用于不可变的对象,即使变量绑定会发生变化,例如。</target>
        </trans-unit>
        <trans-unit id="ac541895cad74a09061e0e8e7752d4412b01c909" translate="yes" xml:space="preserve">
          <source>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A &lt;code&gt;ClusterManager&lt;/code&gt; is responsible for</source>
          <target state="translated">Julia进程到集群中的启动，管理和联网是通过集群管理器完成的。一个 &lt;code&gt;ClusterManager&lt;/code&gt; 负责</target>
        </trans-unit>
        <trans-unit id="88412ce5eb2e0660d566bcac5d3d266756d5e5a6" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;s&lt;/code&gt; must be even, and the returned array has half of the length of &lt;code&gt;s&lt;/code&gt;. See also &lt;a href=&quot;#Base.hex2bytes!&quot;&gt;&lt;code&gt;hex2bytes!&lt;/code&gt;&lt;/a&gt; for an in-place version, and &lt;a href=&quot;#Base.bytes2hex&quot;&gt;&lt;code&gt;bytes2hex&lt;/code&gt;&lt;/a&gt; for the inverse.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 的长度必须为偶数，并且返回的数组的长度为 &lt;code&gt;s&lt;/code&gt; 的一半。另请参见&lt;a href=&quot;#Base.hex2bytes!&quot;&gt; &lt;code&gt;hex2bytes!&lt;/code&gt; &lt;/a&gt;用于就地版本，而&lt;a href=&quot;#Base.bytes2hex&quot;&gt; &lt;code&gt;bytes2hex&lt;/code&gt; &lt;/a&gt;用于反向版本。</target>
        </trans-unit>
        <trans-unit id="82277dc04b6a3c445e6b9754a249fdcb23f3c7cf" translate="yes" xml:space="preserve">
          <source>The line number in the file containing the execution context.</source>
          <target state="translated">文件中包含执行背景的行号。</target>
        </trans-unit>
        <trans-unit id="8e34d0276593663d51db2e1008617c96b00222ff" translate="yes" xml:space="preserve">
          <source>The location &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contains the value at &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt;. All dimensions indexed with scalars are dropped. For example, if &lt;code&gt;J&lt;/code&gt; is an array of indices, then the result of &lt;code&gt;A[2, J, 3]&lt;/code&gt; is an array with size &lt;code&gt;size(J)&lt;/code&gt;. Its &lt;code&gt;j&lt;/code&gt;th element is populated by &lt;code&gt;A[2, J[j], 3]&lt;/code&gt;.</source>
          <target state="translated">位置 &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; 包含 &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt; 。标量索引的所有尺寸都将删除。例如，如果 &lt;code&gt;J&lt;/code&gt; 是索引数组，则 &lt;code&gt;A[2, J, 3]&lt;/code&gt; 是大小为 &lt;code&gt;size(J)&lt;/code&gt; 的数组。其第 &lt;code&gt;j&lt;/code&gt; 个元素由 &lt;code&gt;A[2, J[j], 3]&lt;/code&gt; 填充。</target>
        </trans-unit>
        <trans-unit id="8ba9cf6bb4f8397cc28a79b830f4f985b9ab3a34" translate="yes" xml:space="preserve">
          <source>The location information can be accessed by referencing &lt;code&gt;__source__.line&lt;/code&gt; and &lt;code&gt;__source__.file&lt;/code&gt;:</source>
          <target state="translated">可以通过引用 &lt;code&gt;__source__.line&lt;/code&gt; 和 &lt;code&gt;__source__.file&lt;/code&gt; 来访问位置信息：</target>
        </trans-unit>
        <trans-unit id="3cb51b112926a1dd81d50332e9952ca8853bb8d8" translate="yes" xml:space="preserve">
          <source>The location of both the &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):</source>
          <target state="translated">作用域块中 &lt;code&gt;local&lt;/code&gt; 和 &lt;code&gt;global&lt;/code&gt; 关键字的位置均无关紧要。以下等价于最后一个示例（尽管从风格上讲更糟）：</target>
        </trans-unit>
        <trans-unit id="98682ff20b7c08341d3c5e15b38c14b9a4d16f28" translate="yes" xml:space="preserve">
          <source>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</source>
          <target state="translated">日志级别提供了一个关键,在构建日志记录数据结构本身的任何其他工作之前,可以根据这个关键过滤潜在的日志记录。</target>
        </trans-unit>
        <trans-unit id="318d32e896560b8d7266b2f324ddc4a3093ac0b9" translate="yes" xml:space="preserve">
          <source>The loop body must be straight-line code. Therefore, &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; is currently needed for all array accesses. The compiler can sometimes turn short &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt; expressions into straight-line code if it is safe to evaluate all operands unconditionally. Consider using the &lt;a href=&quot;#Core.ifelse&quot;&gt;&lt;code&gt;ifelse&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;?:&lt;/code&gt; in the loop if it is safe to do so.</source>
          <target state="translated">循环体必须是直线代码。因此，所有阵列访问当前都需要&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;。编译器有时可以将 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;||&lt;/code&gt; 缩写。和 &lt;code&gt;?:&lt;/code&gt; 如果可以安全地无条件评估所有操作数，则将表达式转换为直线代码。如果可以安全地考虑在循环中使用&lt;a href=&quot;#Core.ifelse&quot;&gt; &lt;code&gt;ifelse&lt;/code&gt; &lt;/a&gt;函数而不是 &lt;code&gt;?:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1520d8e0dbae93326950f00e9cb69f3cae60938" translate="yes" xml:space="preserve">
          <source>The loop must be an innermost loop</source>
          <target state="translated">循环必须是最里面的循环</target>
        </trans-unit>
        <trans-unit id="1417d30bb5a87b95ed3077cbfd4cd113b702f8de" translate="yes" xml:space="preserve">
          <source>The lowest value representable by the given (real) numeric DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">可以通过给定（实际）数字DataType &lt;code&gt;T&lt;/code&gt; 表示的最小值。</target>
        </trans-unit>
        <trans-unit id="73472042c68fe0e8852a29376bec0fce0bf44289" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. Arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">宏&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;生成C兼容函数指针，用于对Julia函数的调用。&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; 的&lt;/a&gt;参数如下：</target>
        </trans-unit>
        <trans-unit id="a90d2d040a67a205cdeab40f74d8c8876f85fbd9" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; (or its function variant &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt;) can sometimes be helpful in diagnosing type-related problems. Here's an example:</source>
          <target state="translated">宏&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;（或其功能变体&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt;）有时可能有助于诊断与类型相关的问题。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="9e7d84ccb0a328a62c08d6f8b7389ef525b8bb84" translate="yes" xml:space="preserve">
          <source>The macro may be chained with &lt;code&gt;@test&lt;/code&gt; to also test the returned value:</source>
          <target state="translated">该宏可以与 &lt;code&gt;@test&lt;/code&gt; 链接在一起，以也测试返回的值：</target>
        </trans-unit>
        <trans-unit id="ee8a907ab8fbfe293b4dae0afdde54a8eeab9dd2" translate="yes" xml:space="preserve">
          <source>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</source>
          <target state="translated">这个构造函数的主要目的是直观的从卡提斯索引到线性索引的转换。</target>
        </trans-unit>
        <trans-unit id="525b6c6d88eda51b84031a3e53a3435af961ebe7" translate="yes" xml:space="preserve">
          <source>The master process does not listen on any port. It only connects out to the workers.</source>
          <target state="translated">主进程不监听任何端口。它只连接到工人。</target>
        </trans-unit>
        <trans-unit id="2ed15f9d452fe7aa2e8f8976ab10c5922bcca0ff" translate="yes" xml:space="preserve">
          <source>The master process parses this information and sets up TCP/IP connections to each worker.</source>
          <target state="translated">主进程解析这些信息,并为每个工作者建立TCP/IP连接。</target>
        </trans-unit>
        <trans-unit id="c61856ffa89efc2e6c1d6b663bec6b092cbe224f" translate="yes" xml:space="preserve">
          <source>The meaning of prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via &lt;code&gt;mutable struct&lt;/code&gt;). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, &lt;code&gt;&amp;amp;&lt;/code&gt; may be used with any expression, such as &lt;code&gt;&amp;amp;0&lt;/code&gt; or &lt;code&gt;&amp;amp;f(x)&lt;/code&gt;.</source>
          <target state="translated">前缀 &lt;code&gt;&amp;amp;&lt;/code&gt; 的含义与 C中的含义并不完全相同。尤其是，除非类型是可变的（通过 &lt;code&gt;mutable struct&lt;/code&gt; 声明），否则在Julia中将看不到对引用变量的任何更改。但是，即使对于不可变的结构，尝试进行此类修改（即通过传递的指针进行写操作）的调用函数也不会造成任何损害。此外， &lt;code&gt;&amp;amp;&lt;/code&gt; 可以与任何表达式一起使用，例如 &lt;code&gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;&amp;amp;f(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebdb2209b7357825841deb8a7b0ab3a885d17542" translate="yes" xml:space="preserve">
          <source>The meaning of this form is that &lt;code&gt;F(x,y,...)&lt;/code&gt; is evaluated with the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like &lt;code&gt;1:n&lt;/code&gt; or &lt;code&gt;2:(n-1)&lt;/code&gt;, or explicit arrays of values like &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt;. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges &lt;code&gt;rx&lt;/code&gt;, &lt;code&gt;ry&lt;/code&gt;, etc. and each &lt;code&gt;F(x,y,...)&lt;/code&gt; evaluation returns a scalar.</source>
          <target state="translated">这种形式的含义是使用变量 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 等对 &lt;code&gt;F(x,y,...)&lt;/code&gt; 求值，这些变量采用给定值列表中的每个值。可以将值指定为任何可迭代对象，但通常将是范围如 &lt;code&gt;1:n&lt;/code&gt; 或 &lt;code&gt;2:(n-1)&lt;/code&gt; 或值的显式数组，例如 &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt; 。结果是一个Nd密集数组，其维数是变量范围 &lt;code&gt;rx&lt;/code&gt; ， &lt;code&gt;ry&lt;/code&gt; 等的维数的串联，并且每个 &lt;code&gt;F(x,y,...)&lt;/code&gt; 评估都返回一个标量。</target>
        </trans-unit>
        <trans-unit id="094836238d056b1580750e9abbf5cfe48e515f79" translate="yes" xml:space="preserve">
          <source>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;code&gt;Base.Sort.defalg&lt;/code&gt; function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt;&lt;code&gt;sort.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">朱莉娅选择默认排序算法的机制是通过 &lt;code&gt;Base.Sort.defalg&lt;/code&gt; 函数实现的。它允许将特定算法注册为特定数组的所有排序函数中的默认算法。例如，这是&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt; &lt;code&gt;sort.jl&lt;/code&gt; &lt;/a&gt;中的两个默认方法：</target>
        </trans-unit>
        <trans-unit id="43db34e5821153c9a137e29694256181086c27e9" translate="yes" xml:space="preserve">
          <source>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; then we have:</source>
          <target state="translated">组合环境堆栈组件的根，图和路径数据结构的机制很简单：将它们合并为字典，在键冲突的情况下，较早的条目优先于较晚的条目。换句话说，如果我们有 &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; 则我们有：</target>
        </trans-unit>
        <trans-unit id="ec55008649a0dc54bad05f3e8bc19d30ce40563f" translate="yes" xml:space="preserve">
          <source>The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (&lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt;) is implemented with the following innocuous-looking macro:</source>
          <target state="translated">用户定义的字符串文字的机制非常强大。不仅可以使用它来实现Julia的非标准文字，而且还可以使用以下看起来无害的宏来实现命令文字语法（ &lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="bcd798f681426c31836c9fda7a95d8d4ad32f495" translate="yes" xml:space="preserve">
          <source>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</source>
          <target state="translated">内存消耗估计是对象内部结构大小的近似下限。</target>
        </trans-unit>
        <trans-unit id="131ca4486e37b369d3e30c30d5b64041c99a698f" translate="yes" xml:space="preserve">
          <source>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</source>
          <target state="translated">重构数组的内存共享行为被预编译忽略了(每个视图都有自己的副本)。</target>
        </trans-unit>
        <trans-unit id="298da21a7dd2cc02f54513ff13a66eb673f4dedf" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="translated">将根据全局最低级别（通过&lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt; &lt;code&gt;disable_logging&lt;/code&gt; &lt;/a&gt;设置）检查消息日志级别。这是一个简陋但极其廉价的全球环境。</target>
        </trans-unit>
        <trans-unit id="8ee1b8c607641ce31a518860743fee60270b010d" translate="yes" xml:space="preserve">
          <source>The message-processing loop waits on an &lt;code&gt;IO&lt;/code&gt; object (for example, a &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt; in the default implementation), reads an entire message, processes it and waits for the next one.</source>
          <target state="translated">消息处理循环等待 &lt;code&gt;IO&lt;/code&gt; 对象（例如，默认实现中的&lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; &lt;/a&gt;），读取整个消息，对其进行处理，然后等待下一条消息。</target>
        </trans-unit>
        <trans-unit id="34b07feb0bdcab65a9fbeace753dff1c13bab9a7" translate="yes" xml:space="preserve">
          <source>The method defined above adds parentheses around the call to &lt;code&gt;show&lt;/code&gt; when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as &lt;code&gt;:($a + 2)&lt;/code&gt; and &lt;code&gt;:($a == 2)&lt;/code&gt;) to omit them when printing:</source>
          <target state="translated">上面定义的方法在调用周围添加括号，以 &lt;code&gt;show&lt;/code&gt; 调用运算符的优先级何时高于或等于乘法的优先级。此检查允许在不带括号的情况下正确解析的表达式（例如 &lt;code&gt;:($a + 2)&lt;/code&gt; 和 &lt;code&gt;:($a == 2)&lt;/code&gt; ）在打印时忽略它们：</target>
        </trans-unit>
        <trans-unit id="480991bedb511928dce09fcfa14be4d26a369c2c" translate="yes" xml:space="preserve">
          <source>The method which accepts a predicate function requires Julia 1.2 or later.</source>
          <target state="translated">接受谓词函数的方法需要Julia 1.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="f940b926f7e3b612433e90295b463c51a97504f9" translate="yes" xml:space="preserve">
          <source>The methods in &lt;code&gt;Profile&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;Profile.print()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Profile&lt;/code&gt; 中的方法不会导出，需要调用，例如 &lt;code&gt;Profile.print()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a65046dfbce016e3be9d63dceb54432e4f789ee8" translate="yes" xml:space="preserve">
          <source>The microsecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;Time&lt;/code&gt; 的微秒。</target>
        </trans-unit>
        <trans-unit id="f9daf874100ff7e0440c12dfc313262d02c86576" translate="yes" xml:space="preserve">
          <source>The microsecond part of a Time as a &lt;code&gt;Microsecond&lt;/code&gt;.</source>
          <target state="translated">一时间作为的微秒部分 &lt;code&gt;Microsecond&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0211eebcec0e70acc996cc19c6867555ed469b5e" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="translated">中间表达式只计算一次，而不是表达式被写为 &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt; 两倍。但是，链式比较中的评估顺序是不确定的。强烈建议在链式比较中不要使用具有副作用（例如打印）的表达式。如果需要副作用，则应明确使用短路 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符（请参阅&amp;ldquo; &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;短路评估&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0dd44e8ebcb71bf9c89ef76d2d2682687dc6d684" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的毫秒数。</target>
        </trans-unit>
        <trans-unit id="a912f50c335b4d49dd33d6b3bdff08954f636271" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;Time&lt;/code&gt; 的毫秒数。</target>
        </trans-unit>
        <trans-unit id="8b6a7eeee369dc2111377df37522ca806e23ee00" translate="yes" xml:space="preserve">
          <source>The millisecond part of a DateTime as a &lt;code&gt;Millisecond&lt;/code&gt;.</source>
          <target state="translated">DateTime的毫秒部分，以 &lt;code&gt;Millisecond&lt;/code&gt; 为单位。</target>
        </trans-unit>
        <trans-unit id="0efc4b9b581f6e3f5cda1b69fb5ed353c8f838e4" translate="yes" xml:space="preserve">
          <source>The minimum and maximum representable values of primitive numeric types such as integers are given by the &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">基本数字类型（例如整数）的最小和最大可表示值由&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;函数给出：</target>
        </trans-unit>
        <trans-unit id="85c14b13e4a83e3f641ac750e22da88ea684c364" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 的分钟，作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe1f5f0a330c1e54ad4dd4510d655f5340eec1c4" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;的分钟。</target>
        </trans-unit>
        <trans-unit id="c946111c81e7adfe6af7b762fccd905ec8f88a87" translate="yes" xml:space="preserve">
          <source>The minute part of a DateTime as a &lt;code&gt;Minute&lt;/code&gt;.</source>
          <target state="translated">DateTime的分钟部分，作为 &lt;code&gt;Minute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="847c706add1091574c034eb4a9e1b16f126a1aa6" translate="yes" xml:space="preserve">
          <source>The month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 或 &lt;code&gt;DateTime&lt;/code&gt; 的月份，作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ffed8c4cf30ae11b37e19dbd7e317d781c6a99d" translate="yes" xml:space="preserve">
          <source>The most basic Julia workflows involve using a text editor in conjunction with the &lt;code&gt;julia&lt;/code&gt; command line. A common pattern includes the following elements:</source>
          <target state="translated">最基本的Julia工作流程涉及将文本编辑器与 &lt;code&gt;julia&lt;/code&gt; 命令行结合使用。常见模式包括以下元素：</target>
        </trans-unit>
        <trans-unit id="d8d0db7f857485bf8537d6760d93ea9e3026a18d" translate="yes" xml:space="preserve">
          <source>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</source>
          <target state="translated">在Julia中最常用的一种类型是结构体,用名称和一组字段来指定。</target>
        </trans-unit>
        <trans-unit id="bd6910dc7e6ab3eb744adf6e8b4dbbd2635bda90" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="translated">使整数算术静默溢出的最合理替代方法是到处进行检查的算术，在加，减，乘溢出时产生错误，从而产生值不正确的值。在这篇&lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;博客中&lt;/a&gt;，Dan Luu对此进行了分析，发现这种方法没有理论上的琐碎成本，而是由于编译器（LLVM和GCC）没有适当地围绕添加的溢出检查进行优化而最终产生了巨大的成本。如果将来这种情况有所改善，我们可以考虑在Julia中将其默认为检查的整数算法，但就目前而言，我们不得不忍受溢出的可能性。</target>
        </trans-unit>
        <trans-unit id="5c96614bea2c2a0370b72e64ab597c56a3607929" translate="yes" xml:space="preserve">
          <source>The most significant departures of Julia from typical dynamic languages are:</source>
          <target state="translated">茱莉亚与典型的动态语言最显著的背离是:。</target>
        </trans-unit>
        <trans-unit id="227e81ea680d9761105bfdd7a757c011a63d4676" translate="yes" xml:space="preserve">
          <source>The most useful log pattern is a simple tuple of the form &lt;code&gt;(level,message)&lt;/code&gt;. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to &lt;code&gt;AbstractLogger&lt;/code&gt; via the &lt;code&gt;handle_message&lt;/code&gt; function: &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt;. Elements which are present will be matched pairwise with the log record fields using &lt;code&gt;==&lt;/code&gt; by default, with the special cases that &lt;code&gt;Symbol&lt;/code&gt;s may be used for the standard log levels, and &lt;code&gt;Regex&lt;/code&gt;s in the pattern will match string or Symbol fields using &lt;code&gt;occursin&lt;/code&gt;.</source>
          <target state="translated">最有用的日志模式是 &lt;code&gt;(level,message)&lt;/code&gt; 形式的简单元组。可以使用不同数量的元组元素来匹配其他日志元数据，这些元数据对应于通过 &lt;code&gt;handle_message&lt;/code&gt; 函数传递给 &lt;code&gt;AbstractLogger&lt;/code&gt; 的参数： &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt; 。默认情况下，存在的元素将使用 &lt;code&gt;==&lt;/code&gt; 与日志记录字段成对匹配，在特殊情况下， &lt;code&gt;Symbol&lt;/code&gt; 可以用于标准日志级别，而模式中的 &lt;code&gt;Regex&lt;/code&gt; 可以使用 &lt;code&gt;occursin&lt;/code&gt; 匹配字符串或Symbol字段。</target>
        </trans-unit>
        <trans-unit id="3b7050ead4b7f2406a51989e3a96dcd274b5c4dc" translate="yes" xml:space="preserve">
          <source>The name of &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; 的名称（例如 &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aac1a5f61cbf21e0f76584158e2b1aa448b0700a" translate="yes" xml:space="preserve">
          <source>The name of the function containing the execution context.</source>
          <target state="translated">包含执行上下文的函数名称。</target>
        </trans-unit>
        <trans-unit id="0b15e5d3b4e9ddd6442998593016569d415621b0" translate="yes" xml:space="preserve">
          <source>The nanosecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;表示的 &lt;code&gt;Time&lt;/code&gt; 的纳秒。</target>
        </trans-unit>
        <trans-unit id="aad1073892a176543a30631fd9ae9393da61cbfc" translate="yes" xml:space="preserve">
          <source>The nanosecond part of a Time as a &lt;code&gt;Nanosecond&lt;/code&gt;.</source>
          <target state="translated">时间的纳秒部分作为 &lt;code&gt;Nanosecond&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82e0de7b0a951b098e85d827d86686abc302c514" translate="yes" xml:space="preserve">
          <source>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; it is possible that the &lt;code&gt;options&lt;/code&gt; structure also contains a value for &lt;code&gt;width&lt;/code&gt;. In such a case the rightmost occurrence takes precedence; in this example, &lt;code&gt;width&lt;/code&gt; is certain to have the value &lt;code&gt;2&lt;/code&gt;. However, explicitly specifying the same keyword argument multiple times, for example &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt;, is not allowed and results in a syntax error.</source>
          <target state="translated">关键字参数的性质使得可以多次指定同一参数。例如，在调用 &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; 中， &lt;code&gt;options&lt;/code&gt; 结构也可能包含 &lt;code&gt;width&lt;/code&gt; 的值。在这种情况下，最右边的事件优先。在此示例中， &lt;code&gt;width&lt;/code&gt; 确定为具有值 &lt;code&gt;2&lt;/code&gt; 。但是，不允许多次明确指定相同的关键字参数，例如 &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt; ，这会导致语法错误。</target>
        </trans-unit>
        <trans-unit id="314d66ff5662511b17e76bf3864e0515f7414401" translate="yes" xml:space="preserve">
          <source>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a &lt;code&gt;:&lt;/code&gt;, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array &lt;code&gt;A&lt;/code&gt;. The total number of elements must not change.</source>
          <target state="translated">可以将新尺寸指定为参数列表或形状元组。最多可以用 &lt;code&gt;:&lt;/code&gt; 来指定一个维，在这种情况下，其长度应计算为使得其所有指定维的乘积等于原始数组 &lt;code&gt;A&lt;/code&gt; 的长度。元素总数不得更改。</target>
        </trans-unit>
        <trans-unit id="3ec82b325e399ba219250018d4cd45bb47824912" translate="yes" xml:space="preserve">
          <source>The next example composes three functions and maps the result over an array of strings:</source>
          <target state="translated">下一个例子由三个函数组成,并将结果映射到一个字符串数组上。</target>
        </trans-unit>
        <trans-unit id="0141922960db98bd617ee28c2bf6139f8261ae58" translate="yes" xml:space="preserve">
          <source>The next step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;parse&lt;/a&gt; each string into an object called an expression, represented by the Julia type &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">下一步是将每个字符串&lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;解析&lt;/a&gt;为一个称为表达式的对象，该对象由Julia类型&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; 表示&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="571a7acf064deadfa35e0bae63b5faada78832c9" translate="yes" xml:space="preserve">
          <source>The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</source>
          <target state="translated">下一步是设置项目,找到Julia的包含文件和库。重要的是要知道Julia安装的是32位还是64位。在继续之前,删除任何不符合Julia安装的平台配置。</target>
        </trans-unit>
        <trans-unit id="87d90798d58eeb7d4e5d75a87f02bc64256ab91b" translate="yes" xml:space="preserve">
          <source>The next two higher-order methods, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;tonext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;toprev&lt;/code&gt;&lt;/a&gt;, generalize working with temporal expressions by taking a &lt;code&gt;DateFunction&lt;/code&gt; as first argument, along with a starting &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;DateFunction&lt;/code&gt; is just a function, usually anonymous, that takes a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and returns a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; indicating a satisfied adjustment criterion. For example:</source>
          <target state="translated">接下来的两个高阶方法&lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;tonext&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;toprev&lt;/code&gt; &lt;/a&gt;通过以 &lt;code&gt;DateFunction&lt;/code&gt; 作为第一个参数以及开始的&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; 来&lt;/a&gt;概括使用时间表达式。一个 &lt;code&gt;DateFunction&lt;/code&gt; 仅仅是一个函数，通常是匿名的，接受单个&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;作为输入，并返回一个&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;true&lt;/code&gt; 表示满意的调整标准。例如：</target>
        </trans-unit>
        <trans-unit id="bfdcd43295ca16b8983e8ac5f09ed7f5b30bbe1e" translate="yes" xml:space="preserve">
          <source>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer &amp;mdash; the &quot;destination style&quot;.</source>
          <target state="translated">接下来的两个步骤（选择输出数组和实现）取决于确定给定参数集的单个答案。广播必须采用其参数的所有不同类型，并将其折叠为一个输出数组和一个实现。广播称此单个答案为&amp;ldquo;样式&amp;rdquo;。每个可广播对象都有其自己的首选样式，并且使用类似促销的系统将这些样式组合为一个单一的答案-&amp;ldquo;目标样式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aa11e7d901418eb60c69c43212182dad6fd572f8" translate="yes" xml:space="preserve">
          <source>The no-equilibration, no-transpose simplification of &lt;code&gt;gesvx!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gesvx!&lt;/code&gt; 的无平衡，无换位简化！。</target>
        </trans-unit>
        <trans-unit id="a3be6317f46ece197572e4701784f6328c75ca21" translate="yes" xml:space="preserve">
          <source>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is serialized to a worker, the node pointed to by the reference is notified. And every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular &lt;code&gt;IO&lt;/code&gt; objects is not supported.</source>
          <target state="translated">存储值的节点会跟踪哪些工人对其有引用。每次将&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;或（未获取的）&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;序列化为工作线程时，都会通知该引用所指向的节点。每次在本地对&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;或（未提取的）&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;进行垃圾回收时，都会再次通知拥有该值的节点。这是在内部群集感知串行器中实现的。远程引用仅在正在运行的群集的上下文中有效。不支持对常规 &lt;code&gt;IO&lt;/code&gt; 对象的引用进行序列化和反序列化。</target>
        </trans-unit>
        <trans-unit id="1ee269a033086fa0f88e3b8bd43c4d1005189ba4" translate="yes" xml:space="preserve">
          <source>The node which owns the value frees it once all references to it are cleared.</source>
          <target state="translated">一旦对该值的所有引用被清除,拥有该值的节点就会释放它。</target>
        </trans-unit>
        <trans-unit id="9c9581a565bb9e56cce70d93ca5c19c14a7d3c0d" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="translated">符号 &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; 可用于表达的朱类似物&lt;em&gt;协变&lt;/em&gt;型，而 &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; 一个的类似物&lt;em&gt;逆变&lt;/em&gt;型，但在技术上这些代表&lt;em&gt;组&lt;/em&gt;的类型（参见&lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll类型&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4d8a556b93d1842772dc7f76de931e723dfee64b" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;T(x)&lt;/code&gt; or &lt;code&gt;convert(T,x)&lt;/code&gt; converts &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">符号 &lt;code&gt;T(x)&lt;/code&gt; 或 &lt;code&gt;convert(T,x)&lt;/code&gt; 将 &lt;code&gt;x&lt;/code&gt; 转换为类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="fe139a73bee792b672a69d44b859332e9c6820f5" translate="yes" xml:space="preserve">
          <source>The notifications are done via sending of &quot;tracking&quot; messages&amp;ndash;an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</source>
          <target state="translated">通知是通过发送&amp;ldquo;跟踪&amp;rdquo;消息来完成的，当引用被序列化到另一个进程时，该消息是&amp;ldquo;添加引用&amp;rdquo;消息，而在本地对引用进行垃圾回收时，则是&amp;ldquo;删除引用&amp;rdquo;消息。</target>
        </trans-unit>
        <trans-unit id="2cbf1f552e1a2901fc74809693aa1d1ec7161dbc" translate="yes" xml:space="preserve">
          <source>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</source>
          <target state="translated">UT秒的概念实际上是非常基本的。通常存在两种基本的时间概念，一种基于地球的物理旋转（一个完整的旋转= 1天），另一个基于SI秒（一个固定的恒定值）。这些根本不同！考虑一下，相对于地球自转定义的&amp;ldquo; UT秒&amp;rdquo;可能会因天而异！无论如何，&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;基于UT秒这一事实是一种简化而又诚实的假设，因此可以避免avoided秒等问题及其所有复杂性。时间的基础正式称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt;或UT1。基于UT秒的类型基本上意味着每分钟有60秒，每天有24小时，因此在处理日历日期时可以进行更自然的计算。</target>
        </trans-unit>
        <trans-unit id="abccc41a26dc7addb4c68d102fecb6865b6fa56f" translate="yes" xml:space="preserve">
          <source>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</source>
          <target state="translated">名称后的数字表示该类型需要多少存储位。当前，仅支持8位倍数的大小。的&lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;声明显示了如何一个基本类型可任选地声明为一些超类型的子类型。</target>
        </trans-unit>
        <trans-unit id="375b6efd3979207393378302c9f41c7a21121f28" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="translated">位数表明类型需要多少存储空间，名称为新类型提供了名称。可以选择将基本类型声明为某些超类型的子类型。如果省略了超类型，则该类型默认为将 &lt;code&gt;Any&lt;/code&gt; 作为其直接超类型。因此，上面的&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;声明意味着一个布尔值需要八位存储，并将&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;作为其直接超类型。当前，仅支持8位倍数的大小。因此，布尔值尽管实际上只需要一个位，但是不能声明为小于8位的任何值。</target>
        </trans-unit>
        <trans-unit id="e47d85b6b66b2f56b7aa9e07418e7bd219677af8" translate="yes" xml:space="preserve">
          <source>The number of characters in string &lt;code&gt;s&lt;/code&gt; from indices &lt;code&gt;i&lt;/code&gt; through &lt;code&gt;j&lt;/code&gt;. This is computed as the number of code unit indices from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt; which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; arguments it computes the number of indices between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; inclusive that are valid indices in the string &lt;code&gt;s&lt;/code&gt;. In addition to in-bounds values, &lt;code&gt;i&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">从索引 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; 中的字符数。这是作为有效字符索引从 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt; 的代码单元索引的数量来计算的。仅使用一个字符串参数，就可以计算整个字符串中的字符数。使用 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 自变量，它计算 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 之间（含在内）的索引数，这些索引是字符串 &lt;code&gt;s&lt;/code&gt; 中的有效索引。除了入站值之外， &lt;code&gt;i&lt;/code&gt; 可以取出站值 &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 可以取入站值 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad86f1d6f640919b745cf8a5f2bdcf26fd5ffb5" translate="yes" xml:space="preserve">
          <source>The number of hard links to the file</source>
          <target state="translated">文件的硬链接数量</target>
        </trans-unit>
        <trans-unit id="24a208f4a834f5901bdf25637d96fa3b819cf46a" translate="yes" xml:space="preserve">
          <source>The number of items in each dimension, if known</source>
          <target state="translated">每个方面的项目数量,如果知道的话;</target>
        </trans-unit>
        <trans-unit id="eba5aa4a440d944ee0ac4bd42c3f98d0088c8d6f" translate="yes" xml:space="preserve">
          <source>The number of items, if known</source>
          <target state="translated">项目数量(如果知道)</target>
        </trans-unit>
        <trans-unit id="fd0b7f33e8f96892366bb012a5417e87ca9ea66f" translate="yes" xml:space="preserve">
          <source>The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hyper-threading&lt;/a&gt;.</source>
          <target state="translated">系统中可用的逻辑CPU内核数，即CPU可以同时运行的线程数。注意，例如在存在&lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;超线程&lt;/a&gt;的情况下，这不一定是CPU内核的数量。</target>
        </trans-unit>
        <trans-unit id="e345fe9c2de9253c74f924ce4e5ac488569c4e0e" translate="yes" xml:space="preserve">
          <source>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; in the worker process's environment. Relevant only when using TCP/IP as transport.</source>
          <target state="translated">可以通过工作进程中环境中的变量 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 来指定新启动的工作线程等待主服务器建立连接的秒数。仅在使用TCP / IP进行传输时相关。</target>
        </trans-unit>
        <trans-unit id="401c50950c464431455634fa5427d8b16913972d" translate="yes" xml:space="preserve">
          <source>The number of such blocks allocated</source>
          <target state="translated">分配的此类区块数量</target>
        </trans-unit>
        <trans-unit id="e8e81fb72f02f0f0604e2587ad1458b114eaf4e4" translate="yes" xml:space="preserve">
          <source>The number of threads Julia starts up with is controlled by an environment variable called &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;. Now, let's start up Julia with 4 threads:</source>
          <target state="translated">Julia开始使用的线程数由一个名为 &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt; 的环境变量控制。现在，让我们用4个线程启动Julia：</target>
        </trans-unit>
        <trans-unit id="d85834b4873990e0b8a9335e254e4dd1dde6aed2" translate="yes" xml:space="preserve">
          <source>The number of times a generated function is generated &lt;em&gt;might&lt;/em&gt; be only once, but it &lt;em&gt;might&lt;/em&gt; also be more often, or appear to not happen at all. As a consequence, you should &lt;em&gt;never&lt;/em&gt; write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, so it is disallowed.</source>
          <target state="translated">生成函数的生成次数&lt;em&gt;可能&lt;/em&gt;只有一次，但也&lt;em&gt;可能&lt;/em&gt;更频繁，或者根本没有发生。因此，&lt;em&gt;永远不要&lt;/em&gt;编写带有副作用的生成函数-副作用的发生时间和频率是不确定的。（这也适用于宏-就像宏一样，在生成的函数中使用&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;表示您正在以错误的方式进行操作。）但是，与宏不同，运行时系统无法正确处理对&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;，因此不允许使用。</target>
        </trans-unit>
        <trans-unit id="0ae813381c0022ace29605243aaae816db8d2b62" translate="yes" xml:space="preserve">
          <source>The object has three fields:</source>
          <target state="translated">该对象有三个字段:</target>
        </trans-unit>
        <trans-unit id="f26db4e1766d8278e77cd687e2593b52ae02c589" translate="yes" xml:space="preserve">
          <source>The object has two fields:</source>
          <target state="translated">该对象有两个字段:</target>
        </trans-unit>
        <trans-unit id="4d6829e15fd876880334e8233e7664c2c9a74a93" translate="yes" xml:space="preserve">
          <source>The object iterated over in a &lt;code&gt;@simd for&lt;/code&gt; loop should be a one-dimensional range. By using &lt;code&gt;@simd&lt;/code&gt;, you are asserting several properties of the loop:</source>
          <target state="translated">在 &lt;code&gt;@simd for&lt;/code&gt; 循环中迭代的对象应为一维范围。通过使用 &lt;code&gt;@simd&lt;/code&gt; ，您可以声明循环的几个属性：</target>
        </trans-unit>
        <trans-unit id="30a81b0cbf6e9a0a37ccae194bb527cb1e3d2158" translate="yes" xml:space="preserve">
          <source>The objects called do not have matching dimensionality. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">被调用的对象没有匹配的维度。可选参数 &lt;code&gt;msg&lt;/code&gt; 是描述性错误字符串。</target>
        </trans-unit>
        <trans-unit id="c67a85d00391dfa4e34905a89b16c12f29c02b01" translate="yes" xml:space="preserve">
          <source>The one-line sentence should use the imperative form (&quot;Do this&quot;, &quot;Return that&quot;) instead of the third person (do not write &quot;Returns the length...&quot;) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).</source>
          <target state="translated">在记录函数时,单行句应使用命令形式(&quot;做这个&quot;、&quot;返回那个&quot;)而不是第三人称(不要写 &quot;返回长度......&quot;)。它应该以句号结束。如果一个函数的含义不容易概括,将其分割成单独的可组成的部分可能是有益的(但这不应被视为每一种情况的绝对要求)。</target>
        </trans-unit>
        <trans-unit id="b6ddf67182af91ce5f2d607a93387a34e5a2b0e5" translate="yes" xml:space="preserve">
          <source>The only exception to the use of &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</source>
          <target state="translated">使用 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 作为四舍五入的唯一例外是四舍五入到几周时。四舍五入到最接近的星期将始终返回星期一（ISO 8601指定的星期的第一天）。因此，在四舍五入为几周时，我们使用 &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; （0000年第一周的第一天，由ISO 8601定义）作为基础。</target>
        </trans-unit>
        <trans-unit id="9363f36d4f2b17a0031fe8893a1c08b698e154a6" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of built-in statements:</source>
          <target state="translated">唯一明确不允许的变量名称是内置语句的名称。</target>
        </trans-unit>
        <trans-unit id="b0a96430cabd292322cdf6d0ab2a28460461ca0e" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;=&lt;/code&gt; always returns the right-hand side, therefore:</source>
          <target state="translated">运算符 &lt;code&gt;=&lt;/code&gt; 始终返回右侧，因此：</target>
        </trans-unit>
        <trans-unit id="61c61a08879a6bdf3c24805cb6233ff2beffb8f1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; are non-associative. &lt;code&gt;a + b + c&lt;/code&gt; is parsed as &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt;. However, the fallback methods for &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; and &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; both default to left-associative evaluation.</source>
          <target state="translated">运算符 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 是非关联的。 &lt;code&gt;a + b + c&lt;/code&gt; 被解析为 &lt;code&gt;+(a, b, c)&lt;/code&gt; 而不是 &lt;code&gt;+(+(a, b), c)&lt;/code&gt; 。但是， &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; 和 &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; 的后备方法都默认为左关联评估。</target>
        </trans-unit>
        <trans-unit id="107f84ddc83f3132ac9e7c776c3ad804db96f800" translate="yes" xml:space="preserve">
          <source>The optimal choice of absolute (&lt;code&gt;atol&lt;/code&gt;) and relative tolerance (&lt;code&gt;rtol&lt;/code&gt;) varies both with the value of &lt;code&gt;M&lt;/code&gt; and the intended application of the pseudoinverse. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">绝对（ &lt;code&gt;atol&lt;/code&gt; ）和相对公差（ &lt;code&gt;rtol&lt;/code&gt; ）的最佳选择随 &lt;code&gt;M&lt;/code&gt; 的值和拟逆的预期应用而变化。默认相对公差是 &lt;code&gt;n*ϵ&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是的最小尺寸的大小 &lt;code&gt;M&lt;/code&gt; ，和 &lt;code&gt;ϵ&lt;/code&gt; 是&lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;的元素类型的 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2df9f292c890ebf432c888dc85d326e28ff79fa" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</source>
          <target state="translated">可选的 &lt;code&gt;chars&lt;/code&gt; 参数指定要删除的字符：它可以是单个字符，也可以是向量或字符集。</target>
        </trans-unit>
        <trans-unit id="58713c9681927cdb79ff5aaa798bc3500eccfa8e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, vector or set of characters.</source>
          <target state="translated">可选的 &lt;code&gt;chars&lt;/code&gt; 参数指定要删除的字符：它可以是单个字符，向量或字符集。</target>
        </trans-unit>
        <trans-unit id="7d04d2d866b93a37d08384445eed5a33ef5a6c88" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;esc&lt;/code&gt; argument specifies any additional characters that should also be escaped by a prepending backslash (&lt;code&gt;&quot;&lt;/code&gt; is also escaped by default in the first form).</source>
          <target state="translated">可选的 &lt;code&gt;esc&lt;/code&gt; 参数指定任何其他也应由前置反斜杠转义的字符（默认情况下，第一种形式也转义为 &lt;code&gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="194efabb3b5dd2732e2e6600190698fedd3b0069" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;procs&lt;/code&gt; allows specifying a subset of all processes to have execute the expression.</source>
          <target state="translated">可选参数 &lt;code&gt;procs&lt;/code&gt; 允许指定所有进程的子集来执行表达式。</target>
        </trans-unit>
        <trans-unit id="880714bb7ddfa7f3f83801253a212b4edc50e2e9" translate="yes" xml:space="preserve">
          <source>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</source>
          <target state="translated">可选声明字符串包含了llvm编译IR字符串所需的外部函数声明。可以用换行符将多个声明分开来传递。</target>
        </trans-unit>
        <trans-unit id="d319e50b1de0ad66b05495c666753f05c93c4fb2" translate="yes" xml:space="preserve">
          <source>The optional flags argument is a bitwise-or of zero or more of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;, &lt;code&gt;RTLD_GLOBAL&lt;/code&gt;, &lt;code&gt;RTLD_LAZY&lt;/code&gt;, &lt;code&gt;RTLD_NOW&lt;/code&gt;, &lt;code&gt;RTLD_NODELETE&lt;/code&gt;, &lt;code&gt;RTLD_NOLOAD&lt;/code&gt;, &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt;, and &lt;code&gt;RTLD_FIRST&lt;/code&gt;. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default &lt;code&gt;dlopen&lt;/code&gt; flags are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; while on other platforms the defaults are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt;. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</source>
          <target state="translated">可选标志参数是 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; ， &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; ， &lt;code&gt;RTLD_LAZY&lt;/code&gt; ， &lt;code&gt;RTLD_NOW&lt;/code&gt; ， &lt;code&gt;RTLD_NODELETE&lt;/code&gt; ， &lt;code&gt;RTLD_NOLOAD&lt;/code&gt; ， &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt; 和 &lt;code&gt;RTLD_FIRST&lt;/code&gt; 的按位或零或零以上。如果可能的话，这些将转换为POSIX（和/或GNU libc和/或MacOS）dlopen命令的相应标志，或者如果指定的功能在当前平台上不可用，则将其忽略。默认标志是特定于平台的。在MacOS上，默认的 &lt;code&gt;dlopen&lt;/code&gt; 标志是 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; 而在其他平台上，默认的 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt; 是RTLD_LAZY | RTLD_DEEPBIND | RTLD_LOCAL。这些标志的一个重要用法是为动态库加载器将库引用绑定到导出的符号以及将绑定的引用放入本地或全局范围时指定非默认行为。例如， &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; 允许在其他共享库中使用该库的符号，从而解决共享库之间存在依赖性的情况。</target>
        </trans-unit>
        <trans-unit id="6852910866895c99e590be9b40672a6aa6893cd3" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;f&lt;/code&gt;. The optional &lt;code&gt;sizehint&lt;/code&gt; is a suggested size (in bytes) to allocate for the buffer used to write the string.</source>
          <target state="translated">可以将可选的关键字参数 &lt;code&gt;context&lt;/code&gt; 设置为 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 对，或者将 &lt;code&gt;IO&lt;/code&gt; 或&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;对象的属性用于传递给 &lt;code&gt;f&lt;/code&gt; 的I / O流。可选的 &lt;code&gt;sizehint&lt;/code&gt; 是建议的大小（以字节为单位），用于分配用于写入字符串的缓冲区。</target>
        </trans-unit>
        <trans-unit id="dcac34ba486f2b65b96a033b6cb20a0748bc3d60" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">可以将可选的关键字参数 &lt;code&gt;context&lt;/code&gt; 设置为 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 对，或者将 &lt;code&gt;IO&lt;/code&gt; 或&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;对象的属性用于传递给 &lt;code&gt;show&lt;/code&gt; 的I / O流。</target>
        </trans-unit>
        <trans-unit id="f5605ad644c7f46c7d640d10514c1e111f9c1381" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">可以将可选的关键字参数 &lt;code&gt;context&lt;/code&gt; 设置为 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 对，或者将 &lt;code&gt;IO&lt;/code&gt; 或&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;对象的属性用于传递给 &lt;code&gt;show&lt;/code&gt; 的I / O流。</target>
        </trans-unit>
        <trans-unit id="b019c5488e0a6b54b72c3dc4970022b5261bd3cf" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;writefunc&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">可以将可选的关键字参数 &lt;code&gt;context&lt;/code&gt; 设置为 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 对或 &lt;code&gt;IO&lt;/code&gt; 或&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;对象，其属性用于传递给 &lt;code&gt;writefunc&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 的I / O流。</target>
        </trans-unit>
        <trans-unit id="79723906c1f968e609f55475d1035da056cea38f" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">可以将可选的关键字参数 &lt;code&gt;context&lt;/code&gt; 设置为 &lt;code&gt;IO&lt;/code&gt; 或&lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;对象，这些对象的属性用于传递给 &lt;code&gt;show&lt;/code&gt; 的I / O流。</target>
        </trans-unit>
        <trans-unit id="1d024d8ad27a045cd403adcafbb8a97939e2259d" translate="yes" xml:space="preserve">
          <source>The optional keyword arguments are:</source>
          <target state="translated">可选的关键字参数有:</target>
        </trans-unit>
        <trans-unit id="7277b33c208d262f473b8b03d8c039301737232a" translate="yes" xml:space="preserve">
          <source>The optional list of &lt;code&gt;key=value&lt;/code&gt; pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record. If only a &lt;code&gt;value&lt;/code&gt; expression is supplied, a key representing the expression will be generated using &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;x=x&lt;/code&gt;, and &lt;code&gt;foo(10)&lt;/code&gt; becomes &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt;. For splatting a list of key value pairs, use the normal splatting syntax, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key=value&lt;/code&gt; 对的可选列表支持任意用户定义的元数据，这些元数据将作为日志记录的一部分传递到日志记录后端。如果仅提供 &lt;code&gt;value&lt;/code&gt; 表达式，则将使用&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;生成表示该表达式的键。例如， &lt;code&gt;x&lt;/code&gt; 变成 &lt;code&gt;x=x&lt;/code&gt; ，而 &lt;code&gt;foo(10)&lt;/code&gt; 变成 &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt; 。对于泼洒键值对的列表，使用正常泼洒语法， &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01ff66cb9afdd1acbcec4725d95eb63b3a880ae3" translate="yes" xml:space="preserve">
          <source>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</source>
          <target state="translated">可选的第二个参数将搜索限制在一个特定的模块或函数中(默认是所有顶层模块)。</target>
        </trans-unit>
        <trans-unit id="d7be768e27f40f1d8f5725cc3b53d8120d8d7888" translate="yes" xml:space="preserve">
          <source>The order of the output here is non-deterministic because the two &lt;code&gt;echo&lt;/code&gt; processes are started nearly simultaneously, and race to make the first write to the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; descriptor they share with each other and the &lt;code&gt;julia&lt;/code&gt; parent process. Julia lets you pipe the output from both of these processes to another program:</source>
          <target state="translated">这里的输出顺序是不确定的，因为两个 &lt;code&gt;echo&lt;/code&gt; 进程几乎同时开始，并且竞相对彼此和 &lt;code&gt;julia&lt;/code&gt; 父进程共享的&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;描述符进行第一次写入。 Julia使您可以将这两个过程的输出通过管道传输到另一个程序：</target>
        </trans-unit>
        <trans-unit id="7e6b1ba87ceb124ce09bfd4687b3d3e543a9688a" translate="yes" xml:space="preserve">
          <source>The ordinary way to index into an &lt;code&gt;N&lt;/code&gt;-dimensional array is to use exactly &lt;code&gt;N&lt;/code&gt; indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt;, &lt;code&gt;A[2, 3, 1]&lt;/code&gt; will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as &lt;em&gt;cartesian indexing&lt;/em&gt;.</source>
          <target state="translated">索引到 &lt;code&gt;N&lt;/code&gt; 维数组的普通方法是使用 &lt;code&gt;N&lt;/code&gt; 个索引。每个索引都会选择其特定维度中的位置。例如，在三维数组 &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt; ， &lt;code&gt;A[2, 3, 1]&lt;/code&gt; 将选择数组第一页中第三列第二行中的数字。这通常称为&lt;em&gt;笛卡尔索引&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="337d87d83fb3b26581b3bec9243dd5ba69ee3d14" translate="yes" xml:space="preserve">
          <source>The overflow protection may impose a perceptible performance penalty.</source>
          <target state="translated">溢出保护可能会带来可察觉的性能惩罚。</target>
        </trans-unit>
        <trans-unit id="01d86a00557c452d14c3435e0e6cf89aff65b0c2" translate="yes" xml:space="preserve">
          <source>The parameters to a function call do not match a valid signature. Argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">函数调用的参数与有效签名不匹配。参数 &lt;code&gt;msg&lt;/code&gt; 是一个描述性错误字符串。</target>
        </trans-unit>
        <trans-unit id="5cd165da81710969d9eacb18af008ac2650e61e9" translate="yes" xml:space="preserve">
          <source>The path to the file containing the execution context.</source>
          <target state="translated">包含执行背景的文件路径。</target>
        </trans-unit>
        <trans-unit id="cd91887e0e75258a20a4164a826e358b38427c66" translate="yes" xml:space="preserve">
          <source>The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire &lt;code&gt;X&lt;/code&gt; by looking up &lt;code&gt;paths[uuid,:X]&lt;/code&gt; in the environment. Including this file should define a module named &lt;code&gt;X&lt;/code&gt;. Once this package is loaded, any subsequent import resolving to the same &lt;code&gt;uuid&lt;/code&gt; will create a new binding to the already-loaded package module.</source>
          <target state="translated">路径映射为每个程序包UUID名称对分配该程序包入口点源文件的位置。经过身份 &lt;code&gt;X&lt;/code&gt; 的 &lt;code&gt;import X&lt;/code&gt; 已经通过根或图形（取决于它是否从主项目或依赖加载）解析为UUID，朱莉娅确定哪些文件来加载收购 &lt;code&gt;X&lt;/code&gt; 通过查找 &lt;code&gt;paths[uuid,:X]&lt;/code&gt; 在环境中。包括该文件应定义一个名为 &lt;code&gt;X&lt;/code&gt; 的模块。加载此软件包后，解析到同一 &lt;code&gt;uuid&lt;/code&gt; 的所有后续导入都会为已加载的软件包模块创建新的绑定。</target>
        </trans-unit>
        <trans-unit id="b2b8c82c38ec794200c611dc44cc4f20a1bd32a9" translate="yes" xml:space="preserve">
          <source>The pipe operator can also be used with broadcasting, as &lt;code&gt;.|&amp;gt;&lt;/code&gt;, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</source>
          <target state="translated">管道运算符也可以与广播一起使用，例如 &lt;code&gt;.|&amp;gt;&lt;/code&gt; ，以提供链接/管道和点矢量化语法的有用组合（如下所述）。</target>
        </trans-unit>
        <trans-unit id="597af63e387a0238ac0d63febd38bda10ccc2c0b" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try/catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; functions for more advanced error handling.</source>
          <target state="translated">在的力量 &lt;code&gt;try/catch&lt;/code&gt; 结构在于立即放松身心的深度嵌套计算在调用函数的栈更高水平的能力。在某些情况下不会发生任何错误，但是希望能够展开堆栈并将值传递给更高的级别。朱莉娅提供了&lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt; &lt;code&gt;rethrow&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt;更高级的错误处理功能。</target>
        </trans-unit>
        <trans-unit id="8f828dfaf86a71af5078c4fd81a7efaae2debb74" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</source>
          <target state="translated">在的力量 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 结构在于立即放松身心的深度嵌套计算在调用函数的栈更高水平的能力。</target>
        </trans-unit>
        <trans-unit id="8c0dcb26b25cdb065ec42a8e6b69fc74bd648292" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So &lt;code&gt;-2x&lt;/code&gt; is parsed as &lt;code&gt;(-2) * x&lt;/code&gt; and &lt;code&gt;&amp;radic;2x&lt;/code&gt; is parsed as &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt;. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example &lt;code&gt;2^3x&lt;/code&gt; is parsed as &lt;code&gt;2^(3x)&lt;/code&gt;, and &lt;code&gt;2x^3&lt;/code&gt; is parsed as &lt;code&gt;2*(x^3)&lt;/code&gt;.</source>
          <target state="translated">数字文字系数的优先级略低于一元运算符（例如，取反）的优先级。因此 &lt;code&gt;-2x&lt;/code&gt; 被解析为 &lt;code&gt;(-2) * x&lt;/code&gt; ， &lt;code&gt;&amp;radic;2x&lt;/code&gt; 被解析为 &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt; 。但是，与指数运算结合时，数字文字系数的解析与一元运算符相似。例如 &lt;code&gt;2^3x&lt;/code&gt; 被解析为 &lt;code&gt;2^(3x)&lt;/code&gt; ，而 &lt;code&gt;2x^3&lt;/code&gt; 被解析为 &lt;code&gt;2*(x^3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8950edc0252b4e5921bc89b4f858ec39c03063d6" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (&lt;code&gt;*&lt;/code&gt;), and division (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;//&lt;/code&gt;). This means, for example, that &lt;code&gt;1 / 2im&lt;/code&gt; equals &lt;code&gt;-0.5im&lt;/code&gt; and &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; equals &lt;code&gt;1 // 1&lt;/code&gt;.</source>
          <target state="translated">用于隐式乘法的数字文字系数的优先级高于其他二进制运算符，例如乘法（ &lt;code&gt;*&lt;/code&gt; ）和除法（ &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;\&lt;/code&gt; 和 &lt;code&gt;//&lt;/code&gt; ）。例如，这意味着 &lt;code&gt;1 / 2im&lt;/code&gt; 等于 &lt;code&gt;-0.5im&lt;/code&gt; ， &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; 等于 &lt;code&gt;1 // 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6252a13083e6a8d33233a629a05884040274a8ff" translate="yes" xml:space="preserve">
          <source>The precedence rules are defined by binary &lt;code&gt;BroadcastStyle&lt;/code&gt; calls:</source>
          <target state="translated">优先级规则由二进制 &lt;code&gt;BroadcastStyle&lt;/code&gt; 调用定义：</target>
        </trans-unit>
        <trans-unit id="56837dd60f637c33dd3845553e8ea84690fc189a" translate="yes" xml:space="preserve">
          <source>The preferred style is to use instances by default, and only add methods involving &lt;code&gt;Type{MyType}&lt;/code&gt; later if they become necessary to solve some problem.</source>
          <target state="translated">首选样式是默认情况下使用实例，并且仅在以后需要解决某些问题的情况下才添加涉及 &lt;code&gt;Type{MyType}&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="279b514949e6ab10ca4a0b3d36a0afc9aa5e5bfd" translate="yes" xml:space="preserve">
          <source>The prefix operator &lt;code&gt;∛&lt;/code&gt; is equivalent to &lt;code&gt;cbrt&lt;/code&gt;.</source>
          <target state="translated">前缀运算符 &lt;code&gt;∛&lt;/code&gt; 等同于 &lt;code&gt;cbrt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93ebef4458176844838b02e2b993df5f493f0829" translate="yes" xml:space="preserve">
          <source>The primary function used to obtain a stack trace is &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">用于获取堆栈跟踪的主要功能是&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e24543b8a6898ccaa9bbcf1e800fb858e73daf75" translate="yes" xml:space="preserve">
          <source>The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, which applies a function to each value of an array and returns a new array containing the resulting values:</source>
          <target state="translated">匿名函数的主要用途是将其传递给以其他函数为参数的函数。一个经典的例子是&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;，它对一个数组的每个值应用一个函数，并返回一个包含结果值的新数组：</target>
        </trans-unit>
        <trans-unit id="fc2c54892fd31e8ed27deff8fd6635a872466a56" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; depends on the &lt;code&gt;Pub&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages.</source>
          <target state="translated">私有 &lt;code&gt;Priv&lt;/code&gt; 取决于 &lt;code&gt;Pub&lt;/code&gt; 和 &lt;code&gt;Zebra&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="8f74ae0037646d4d3ed052aa7f6f3acf520af197" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; package is &quot;&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt;&quot; inside the &lt;code&gt;App&lt;/code&gt; repository.</source>
          <target state="translated">私有 &lt;code&gt;Priv&lt;/code&gt; 软件包在 &lt;code&gt;App&lt;/code&gt; 存储库中被&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;供应&lt;/a&gt; &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="661f073fc5da6760e6d7e4ab5f75f9c8ff27e153" translate="yes" xml:space="preserve">
          <source>The problem is that now any other module that uses &lt;code&gt;Base.*&lt;/code&gt; will also see this definition. Since &lt;code&gt;Symbol&lt;/code&gt; is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the &lt;code&gt;Symbol&lt;/code&gt;s in another type that you define.</source>
          <target state="translated">问题在于，现在任何其他使用 &lt;code&gt;Base.*&lt;/code&gt; 模块也将看到此定义。由于 &lt;code&gt;Symbol&lt;/code&gt; 是在Base中定义的，并且由其他模块使用，因此这可能会意外更改无关代码的行为。这里有几种选择，包括使用不同的函数名称，或将 &lt;code&gt;Symbol&lt;/code&gt; s包装为您定义的另一种类型。</target>
        </trans-unit>
        <trans-unit id="285d72365829e919fd96051079cd8653575f8845" translate="yes" xml:space="preserve">
          <source>The problem is that users of this type can write &lt;code&gt;x[i]&lt;/code&gt; without realizing that the operation is unsafe, and then be susceptible to memory bugs.</source>
          <target state="translated">问题在于，这种类型的用户可以写 &lt;code&gt;x[i]&lt;/code&gt; 而没有意识到该操作是不安全的，然后容易受到内存错误的影响。</target>
        </trans-unit>
        <trans-unit id="645c5293b137aedcba8417381b97d9b765e077f5" translate="yes" xml:space="preserve">
          <source>The problem is that we want &lt;code&gt;S&lt;/code&gt; to be a larger type than &lt;code&gt;T&lt;/code&gt;, so that we can sum many elements with less information loss. For example, when &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we would like &lt;code&gt;S&lt;/code&gt; to be &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. Therefore we want to avoid an interface that allows the user to construct instances of the type &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt;. One way to do this is to provide a constructor only for &lt;code&gt;SummedArray&lt;/code&gt;, but inside the &lt;code&gt;struct&lt;/code&gt; definition block to suppress generation of default constructors:</source>
          <target state="translated">问题是我们希望 &lt;code&gt;S&lt;/code&gt; 是大于 &lt;code&gt;T&lt;/code&gt; 的类型，以便我们可以求和很多元素而信息损失更少。例如，当 &lt;code&gt;T&lt;/code&gt; 为&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; 时&lt;/a&gt;，我们希望 &lt;code&gt;S&lt;/code&gt; 为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。因此，我们希望避免使用一个允许用户构造 &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt; 类型的实例的接口。一种方法是仅为 &lt;code&gt;SummedArray&lt;/code&gt; 提供构造函数，但在 &lt;code&gt;struct&lt;/code&gt; 定义块内部以抑制默认构造函数的生成：</target>
        </trans-unit>
        <trans-unit id="fa9c416e3dd0eb96ee39260398af255d4af83ab0" translate="yes" xml:space="preserve">
          <source>The process id, &lt;code&gt;pid&lt;/code&gt;, associated with a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; identifies the process where the backing store, i.e., the backing &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; exists.</source>
          <target state="translated">与&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;关联的进程id &lt;code&gt;pid&lt;/code&gt; 标识后备存储（即后备&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; )&lt;/a&gt;所在的进程。</target>
        </trans-unit>
        <trans-unit id="e5711338a1a6b237dd10b96c18908bc64ecaf369" translate="yes" xml:space="preserve">
          <source>The process was stopped by a terminal interrupt (CTRL+C).</source>
          <target state="translated">进程被终端中断(CTRL+C)停止。</target>
        </trans-unit>
        <trans-unit id="333bddf0932a24c46f8668b521deb6c3a862550f" translate="yes" xml:space="preserve">
          <source>The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:</source>
          <target state="translated">命令中的程序名和各个参数可以像命令是一个字符串数组一样被访问和迭代。</target>
        </trans-unit>
        <trans-unit id="50007e3abed58b9e198eabc930fa126c0f7f28e5" translate="yes" xml:space="preserve">
          <source>The promotion mechanism ensures that combinations of operands of different types just work:</source>
          <target state="translated">晋升机制保证了不同类型操作数的组合只是工作。</target>
        </trans-unit>
        <trans-unit id="970007866f1b490fa6101a3c913eb7623d70c629" translate="yes" xml:space="preserve">
          <source>The protection mode of the file</source>
          <target state="translated">文件的保护模式</target>
        </trans-unit>
        <trans-unit id="717c22bfef5d2282d64a55d9c60b43bea19c9cf1" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</source>
          <target state="translated">公用的 &lt;code&gt;Priv&lt;/code&gt; 和 &lt;code&gt;Zebra&lt;/code&gt; 软件包位于系统软件仓库中，系统管理员可以在其中安装和管理软件包。这些可供系统上的所有用户使用。</target>
        </trans-unit>
        <trans-unit id="1a1630b90939dc1ab04b673570b84792ee8ae787" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; has no dependencies.</source>
          <target state="translated">公共 &lt;code&gt;Priv&lt;/code&gt; 没有依赖性。</target>
        </trans-unit>
        <trans-unit id="3a76e9ce5367492b5b8cf13bb66130558721cade" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; or &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="translated">欧几里德除法的商和余数。等效于 &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; 或 &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c852eff7359c80d607981a449403f86f7a08aae5" translate="yes" xml:space="preserve">
          <source>The quotient from Euclidean division. Computes &lt;code&gt;x/y&lt;/code&gt;, truncated to an integer.</source>
          <target state="translated">欧几里得除法的商。计算 &lt;code&gt;x/y&lt;/code&gt; ，将其截断为整数。</target>
        </trans-unit>
        <trans-unit id="b4ff83a45750ab4a00521d3b0c9044c246c68431" translate="yes" xml:space="preserve">
          <source>The rationale for this behavior is that &lt;code&gt;eps&lt;/code&gt; bounds the floating point rounding error. Under the default &lt;code&gt;RoundNearest&lt;/code&gt; rounding mode, if $y$ is a real number and $x$ is the nearest floating point number to $y$, then</source>
          <target state="translated">此行为的基本原理是 &lt;code&gt;eps&lt;/code&gt; 限制了浮点舍入误差。在默认的 &lt;code&gt;RoundNearest&lt;/code&gt; 舍入模式下，如果$ y $是实数，$ x $是最接近$ y $的浮点数，则</target>
        </trans-unit>
        <trans-unit id="fb9190d6f027ae9e2de06d7e334ba64d5fd44e85" translate="yes" xml:space="preserve">
          <source>The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use &lt;code&gt;import&lt;/code&gt;, then you'll replace the other module's implementation of &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</source>
          <target state="translated">之所以要使用单独的语法足够重要，是因为您不想意外扩展一个您不知道的功能，因为这很容易导致错误。这很可能发生在采用诸如字符串或整数之类的通用类型的方法上，因为您和另一个模块都可以定义一个方法来处理这种通用类型。如果您使用 &lt;code&gt;import&lt;/code&gt; ，那么您将用新的实现替换其他模块的 &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; 的实现，这可以轻松地做一些完全不同的事情（并中断Foo模块中其他功能的所有/很多将来使用）取决于调用栏）。</target>
        </trans-unit>
        <trans-unit id="234a82c9299a864e20ceee7dc728fbbfc62b4ff9" translate="yes" xml:space="preserve">
          <source>The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt;&lt;code&gt;closures&lt;/code&gt;&lt;/a&gt; which have private state, for instance the &lt;code&gt;state&lt;/code&gt; variable in the following example:</source>
          <target state="translated">允许在嵌套函数中修改父作用域的局部变量的原因是允许构造具有私有状态的&lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt; &lt;code&gt;closures&lt;/code&gt; &lt;/a&gt;，例如以下示例中的 &lt;code&gt;state&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="d42e24ea3d0e2aa6d81b7dd3b153611807fc05f4" translate="yes" xml:space="preserve">
          <source>The reasoning is that &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;, and likewise, the value of &lt;code&gt;a || b&lt;/code&gt; must be true if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;. Both &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; associate to the right, but &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; has higher precedence than &lt;code&gt;||&lt;/code&gt; does. It's easy to experiment with this behavior:</source>
          <target state="translated">其理由是 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 一定是 &lt;code&gt;false&lt;/code&gt; ，如果 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; ，不管价值 &lt;code&gt;b&lt;/code&gt; ，同样地，价值 &lt;code&gt;a || b&lt;/code&gt; 如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则b必须为true，而不管 &lt;code&gt;b&lt;/code&gt; 的值如何。无论 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 关联到右边，但是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 的优先级高于 &lt;code&gt;||&lt;/code&gt; 做。尝试这种行为很容易：</target>
        </trans-unit>
        <trans-unit id="179e487486d1af4b87de97016bef8d4656b4ec67" translate="yes" xml:space="preserve">
          <source>The recommended ways to iterate over a whole array are</source>
          <target state="translated">推荐的对整个数组进行迭代的方法是</target>
        </trans-unit>
        <trans-unit id="d82c055defbd84ff03cc2e56fef7d08819740213" translate="yes" xml:space="preserve">
          <source>The reduction of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;y&lt;/code&gt;, or equivalently, the remainder of &lt;code&gt;x&lt;/code&gt; after floored division by &lt;code&gt;y&lt;/code&gt;, i.e. &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; if computed without intermediate rounding.</source>
          <target state="translated">的还原 &lt;code&gt;x&lt;/code&gt; 模 &lt;code&gt;y&lt;/code&gt; ，或等价的，其余的 &lt;code&gt;x&lt;/code&gt; 后地板除法 &lt;code&gt;y&lt;/code&gt; ，即 &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; 如果没有计算中间舍入。</target>
        </trans-unit>
        <trans-unit id="c7a083bb1a1b10ec23125171dedac6f03596ea4e" translate="yes" xml:space="preserve">
          <source>The relation defined by &lt;code&gt;isless&lt;/code&gt; is transitive, i.e., &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implies &lt;code&gt;isless(x, z)&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;isless&lt;/code&gt; 定义的关系是可传递的，即 &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; 表示 &lt;code&gt;isless(x, z)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae50d1ec149a5bb325ee3ed684413be8beb00545" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 之间的关系是</target>
        </trans-unit>
        <trans-unit id="f134ecdeee3cfa777ccd458bfed97ec72082e75e" translate="yes" xml:space="preserve">
          <source>The remote cache is maintained for the lifetime of the returned &lt;code&gt;CachingPool&lt;/code&gt; object. To clear the cache earlier, use &lt;code&gt;clear!(pool)&lt;/code&gt;.</source>
          <target state="translated">在返回的 &lt;code&gt;CachingPool&lt;/code&gt; 对象的生存期内，将维护远程缓存。要更早清除缓存，请使用 &lt;code&gt;clear!(pool)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df901bb294129f7627dac22ff5e80e400643c39f" translate="yes" xml:space="preserve">
          <source>The required keyword argument &lt;code&gt;var&lt;/code&gt; was not assigned in a function call.</source>
          <target state="translated">未在函数调用中分配必需的关键字参数 &lt;code&gt;var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f7acaee551d1164b11cacdb547b0da33902de6" translate="yes" xml:space="preserve">
          <source>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果是一个给出值地址的指针。可以使用&lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt;通过此指针操纵该值！。</target>
        </trans-unit>
        <trans-unit id="03cc3e3ef7a55f891b2fdc37e1dca5251bee7ee1" translate="yes" xml:space="preserve">
          <source>The result is of type &lt;code&gt;Bool&lt;/code&gt;, except when one of the operands is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;). For collections, &lt;code&gt;missing&lt;/code&gt; is returned if at least one of the operands contains a &lt;code&gt;missing&lt;/code&gt; value and all non-missing values are equal. Use &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; to always get a &lt;code&gt;Bool&lt;/code&gt; result.</source>
          <target state="translated">结果是 &lt;code&gt;Bool&lt;/code&gt; 类型的，除非其中一个操作数&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;，在这种情况下，将返回 &lt;code&gt;missing&lt;/code&gt; （&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;）。对于收藏， &lt;code&gt;missing&lt;/code&gt; 如果操作数的至少一个包含返回 &lt;code&gt;missing&lt;/code&gt; 值和所有非缺失值相等。使用&lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;始终获得 &lt;code&gt;Bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c007650ed1d2ab98bda9d8f6e9d2a6696a562053" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;nextfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;prevfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，则 &lt;code&gt;nextfloat&lt;/code&gt; 对 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 个迭代应用的结果；如果 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，则对 &lt;code&gt;prevfloat&lt;/code&gt; 进行 &lt;code&gt;-n&lt;/code&gt; 的应用。</target>
        </trans-unit>
        <trans-unit id="94b46c3b276e64ea98bedcc1b3f79ab9ebee8c1f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;prevfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;nextfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，则 &lt;code&gt;prevfloat&lt;/code&gt; 对 &lt;code&gt;x&lt;/code&gt; 进行 &lt;code&gt;n&lt;/code&gt; 次迭代应用的结果；如果 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，则对 &lt;code&gt;nextfloat&lt;/code&gt; 进行 &lt;code&gt;-n&lt;/code&gt; 应用。</target>
        </trans-unit>
        <trans-unit id="3b9604e81f6338ca5014cd5645d78240588116b2" translate="yes" xml:space="preserve">
          <source>The result of an expression is too large for the specified type and will cause a wraparound.</source>
          <target state="translated">表达式的结果对于指定的类型来说太大了,会造成包围。</target>
        </trans-unit>
        <trans-unit id="5e37838dee3788d25d7398516d199b796b585b2f" translate="yes" xml:space="preserve">
          <source>The result of indexing an &lt;code&gt;AbstractArray&lt;/code&gt; can itself be an array (for instance when indexing by an &lt;code&gt;AbstractRange&lt;/code&gt;). The &lt;code&gt;AbstractArray&lt;/code&gt; fallback methods use &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; to allocate an &lt;code&gt;Array&lt;/code&gt; of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</source>
          <target state="translated">对 &lt;code&gt;AbstractArray&lt;/code&gt; 进行索引的结果本身可以是一个数组（例如，当通过 &lt;code&gt;AbstractRange&lt;/code&gt; 进行索引时）。所述 &lt;code&gt;AbstractArray&lt;/code&gt; 回退方法使用&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;分配一个 &lt;code&gt;Array&lt;/code&gt; 的合适的尺寸和元素类型，其被填充在使用上述基本索引方法的。但是，在实现数组包装器时，您通常也希望将结果包装起来：</target>
        </trans-unit>
        <trans-unit id="9dddd93bc0d8f1d83b952a56d60f4d4d4dde4922" translate="yes" xml:space="preserve">
          <source>The result will have the same sign as &lt;code&gt;y&lt;/code&gt;, and magnitude less than &lt;code&gt;abs(y)&lt;/code&gt; (with some exceptions, see note below).</source>
          <target state="translated">结果将具有与 &lt;code&gt;y&lt;/code&gt; 相同的符号，并且幅度小于 &lt;code&gt;abs(y)&lt;/code&gt; （有一些例外，请参见下面的注释）。</target>
        </trans-unit>
        <trans-unit id="f568e8a5a2b842636c272653d157a8edcd885b90" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="translated">结果的数组类型取决于计算元素的类型。为了明确地控制类型,可以在理解前加上一个类型。例如,我们可以写下单精度的结果。</target>
        </trans-unit>
        <trans-unit id="ccd36a28a2ffb3965813bdc3900b2e91091344fd" translate="yes" xml:space="preserve">
          <source>The resulting container type is established by the following rules:</source>
          <target state="translated">由此产生的容器类型由以下规则确定:</target>
        </trans-unit>
        <trans-unit id="1fe1a92416b8011a58e509306cdd809a4d7403bb" translate="yes" xml:space="preserve">
          <source>The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</source>
          <target state="translated">结果是一样的,Julia的插值行为模仿了shell的行为,并做了一些改进,这是因为Julia支持一级可迭代对象,而大多数shell都使用空格上拆分的字符串来实现,这就引入了歧义。当尝试将shell命令移植到Julia时,先尝试剪切和粘贴。由于Julia会在运行命令之前向你展示命令,你可以轻松安全地只检查它的解释,而不会造成任何损害。</target>
        </trans-unit>
        <trans-unit id="0e9c7956c24febdcf914d416fae3a917b2f39e3e" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size, and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. For all other arguments, a common return type is found to which all arguments are promoted.</source>
          <target state="translated">对于小于系统字大小的有符号整数，返回类型为 &lt;code&gt;Int&lt;/code&gt; ,对于小于系统字大小的无符号整数，返回类型为 &lt;code&gt;UInt&lt;/code&gt; 。对于所有其他参数，找到一个通用的返回类型，所有参数都提升为该类型。</target>
        </trans-unit>
        <trans-unit id="2bdd15fbc5eeeea487e741f6815e78f1d57eeca2" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">返回值是找到匹配序列的索引范围，使得 &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="296596adaa4e2ffb872d464b197ffa89509d78f4" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">返回值是找到匹配序列的索引范围，使得 &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9c4a1e6fb47e3491c23ed68634d665b86e2b1224" translate="yes" xml:space="preserve">
          <source>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</source>
          <target state="translated">返回值将是一个新的对象,初始化为包含被引用内存内容的副本。被引用的内存可以安全地被释放或释放。</target>
        </trans-unit>
        <trans-unit id="995e85d8c74168d9b1cb80ff9be361035188ad05" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.</source>
          <target state="translated">返回的&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;可以在 &lt;code&gt;for&lt;/code&gt; 循环中用作可迭代对象，在这种情况下，循环变量将采用所有产生的值。通道关闭时，循环终止。</target>
        </trans-unit>
        <trans-unit id="4905fa2086f7e7025e1f1fb3e602f0309c36c38d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="76989de74c6183b202bef17365490bd9a3d31c70" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="f5913ac9f9933573cc3f45ba086fb826464beb36" translate="yes" xml:space="preserve">
          <source>The returned object &lt;code&gt;F&lt;/code&gt; stores the factorization in a packed format:</source>
          <target state="translated">返回的对象 &lt;code&gt;F&lt;/code&gt; 以打包格式存储分解：</target>
        </trans-unit>
        <trans-unit id="5b6b30b85a24f3b9aaa6b8733a6c0289157aac3b" translate="yes" xml:space="preserve">
          <source>The returned tuple must only contain either &lt;code&gt;Int&lt;/code&gt;s or &lt;code&gt;AbstractArray&lt;/code&gt;s of scalar indices that are supported by array &lt;code&gt;A&lt;/code&gt;. It will error upon encountering a novel index type that it does not know how to process.</source>
          <target state="translated">返回的元组只能包含数组 &lt;code&gt;A&lt;/code&gt; 支持的标量索引的 &lt;code&gt;Int&lt;/code&gt; 或 &lt;code&gt;AbstractArray&lt;/code&gt; 。遇到不知道如何处理的新型索引类型时，它将出错。</target>
        </trans-unit>
        <trans-unit id="d9c1e00640a368c30e904f9290ae3dcb10bd1ec3" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of watching the file.</source>
          <target state="translated">返回的值是一个对象，其中的布尔字段已 &lt;code&gt;changed&lt;/code&gt; ， &lt;code&gt;renamed&lt;/code&gt; 和 &lt;code&gt;timedout&lt;/code&gt; ，从而提供了查看文件的结果。</target>
        </trans-unit>
        <trans-unit id="0aae9d904638273f671fc4e418a0190f5b8a389f" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of the polling.</source>
          <target state="translated">返回的值是与布尔字段的对象 &lt;code&gt;readable&lt;/code&gt; ， &lt;code&gt;writable&lt;/code&gt; ，以及 &lt;code&gt;timedout&lt;/code&gt; ，赋予轮询的结果。</target>
        </trans-unit>
        <trans-unit id="49b2889cf141c81986b5559befd286291492017c" translate="yes" xml:space="preserve">
          <source>The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the event.</source>
          <target state="translated">返回值是一对，其中第一个字段是更改后的文件的名称（如果可用），第二个字段是一个对象，该对象的布尔字段 &lt;code&gt;changed&lt;/code&gt; ， &lt;code&gt;renamed&lt;/code&gt; 和 &lt;code&gt;timedout&lt;/code&gt; ，从而产生事件。</target>
        </trans-unit>
        <trans-unit id="8636f9ac58bcf28e3d16135d951b8ff3e218cbd7" translate="yes" xml:space="preserve">
          <source>The reverse operation (writing data to a &lt;code&gt;Ptr{T}&lt;/code&gt;), can be performed using &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt;&lt;/a&gt;. Currently, this is only supported for primitive types or other pointer-free (&lt;code&gt;isbits&lt;/code&gt;) immutable struct types.</source>
          <target state="translated">可以使用&lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt; &lt;/a&gt;执行相反的操作（将数据写入 &lt;code&gt;Ptr{T}&lt;/code&gt; ）。当前，仅原始类型或其他无指针（ &lt;code&gt;isbits&lt;/code&gt; ）不可变结构类型支持此功能。</target>
        </trans-unit>
        <trans-unit id="b7d58ee9a7a86e6aad0f59e6f9ed658c820e2192" translate="yes" xml:space="preserve">
          <source>The roots, graph and paths maps of a project environment are defined as follows:</source>
          <target state="translated">项目环境的根、图和路径图定义如下。</target>
        </trans-unit>
        <trans-unit id="8db1c63f81410ece76ca99d9ff0064394f7701c3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">与&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。一个&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;如果分解产生许多不通过的元素类型可表示的则抛出异常 &lt;code&gt;A&lt;/code&gt; 整数类型，例如。</target>
        </trans-unit>
        <trans-unit id="7ac8db3a8fce7e45f1c23cbd8542a5bd84c64ad8" translate="yes" xml:space="preserve">
          <source>The same best practices also work for container types:</source>
          <target state="translated">同样的最佳实践也适用于容器类型。</target>
        </trans-unit>
        <trans-unit id="7644c0d871ce59114cf83dbd0542336b1d1077e8" translate="yes" xml:space="preserve">
          <source>The same thing can be done using recursion:</source>
          <target state="translated">同样的事情也可以用递归来完成。</target>
        </trans-unit>
        <trans-unit id="499f37304cc2bf38bfc1e123fdaa79c60bea1de4" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;julia-config.jl&lt;/code&gt; was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</source>
          <target state="translated">创建脚本 &lt;code&gt;julia-config.jl&lt;/code&gt; 是为了帮助确定使用嵌入式Julia的程序需要哪些构建参数。该脚本使用特定的Julia发行版的构建参数和系统配置，通过调用该脚本，可以导出必要的编译器标志，以使嵌入程序与该发行版进行交互。该脚本位于Julia共享数据目录中。</target>
        </trans-unit>
        <trans-unit id="6f8fe32c72b2738c988d9f8c4881f931f1ba36f2" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;p&lt;/code&gt; is not necessarily a part of the interface for &lt;code&gt;norm&lt;/code&gt;, i.e. a custom type may only implement &lt;code&gt;norm(A)&lt;/code&gt; without second argument.</source>
          <target state="translated">第二个参数 &lt;code&gt;p&lt;/code&gt; 不一定是 &lt;code&gt;norm&lt;/code&gt; 的接口的一部分，即自定义类型只能实现没有第二个参数的 &lt;code&gt;norm(A)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b22778842445d7f70d31b000bce7d6cc33096518" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: &lt;code&gt;stdcall&lt;/code&gt;, &lt;code&gt;cdecl&lt;/code&gt;, &lt;code&gt;fastcall&lt;/code&gt;, and &lt;code&gt;thiscall&lt;/code&gt; (no-op on 64-bit Windows). For example (from &lt;code&gt;base/libc.jl&lt;/code&gt;) we see the same &lt;code&gt;gethostname&lt;/code&gt;&lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; as above, but with the correct signature for Windows:</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的第二个参数可以选择是调用约定说明符（紧邻返回类型）。没有任何说明符，将使用平台默认的C调用约定。其他受支持的约定是： &lt;code&gt;stdcall&lt;/code&gt; ， &lt;code&gt;cdecl&lt;/code&gt; ， &lt;code&gt;fastcall&lt;/code&gt; 和 &lt;code&gt;thiscall&lt;/code&gt; （在64位Windows上为no-op）。例如（从 &lt;code&gt;base/libc.jl&lt;/code&gt; ），我们看到与上面相同的 &lt;code&gt;gethostname&lt;/code&gt; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;，但具有Windows的正确签名：</target>
        </trans-unit>
        <trans-unit id="0ae8f7c6c5ae9107bf9df78309eaedb266fcdbc6" translate="yes" xml:space="preserve">
          <source>The second form is also often better style and can lead to more code reuse.</source>
          <target state="translated">第二种形式往往也是更好的风格,可以带来更多的代码重用。</target>
        </trans-unit>
        <trans-unit id="f5a1001e237b6ff86cbef193ea1ae22360accd73" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 的第二个作为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d31d476948ba89a2e9e64c6b33fad2cd0a026a5" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A的第二 &lt;code&gt;Time&lt;/code&gt; 为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; 的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="325c1f846c581874b3b9e8bdbf898464d53c77a6" translate="yes" xml:space="preserve">
          <source>The second part of a DateTime as a &lt;code&gt;Second&lt;/code&gt;.</source>
          <target state="translated">DateTime的第二部分作为 &lt;code&gt;Second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a3329a718673195a0538b1050837014e0187920" translate="yes" xml:space="preserve">
          <source>The second statement in the test program evaluates a Julia statement using a call to &lt;code&gt;jl_eval_string&lt;/code&gt;.</source>
          <target state="translated">测试程序中的第二条语句使用对 &lt;code&gt;jl_eval_string&lt;/code&gt; 的调用来评估Julia语句。</target>
        </trans-unit>
        <trans-unit id="9cc4451185981f40556584c6f362b372cf0d2413" translate="yes" xml:space="preserve">
          <source>The second syntactic purpose of the &lt;code&gt;:&lt;/code&gt; character is to create expression objects without using the explicit &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. This is referred to as &lt;em&gt;quoting&lt;/em&gt;. The &lt;code&gt;:&lt;/code&gt; character, followed by paired parentheses around a single statement of Julia code, produces an &lt;code&gt;Expr&lt;/code&gt; object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 字符的第二个语法目的是在不使用显式&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;构造函数的情况下创建表达式对象。这称为&lt;em&gt;报价&lt;/em&gt;。的 &lt;code&gt;:&lt;/code&gt; 字符，后面跟配对括号周围的朱代码单个语句，产生一个 &lt;code&gt;Expr&lt;/code&gt; 的基础上，封闭代码对象。这是用于引用算术表达式的简短形式的示例：</target>
        </trans-unit>
        <trans-unit id="915184092841becb822c9871efbbca52119b3359" translate="yes" xml:space="preserve">
          <source>The second version will convert &lt;code&gt;x&lt;/code&gt; to an appropriate type, instead of always the same type.</source>
          <target state="translated">第二个版本会将 &lt;code&gt;x&lt;/code&gt; 转换为适当的类型，而不是始终相同的类型。</target>
        </trans-unit>
        <trans-unit id="21005babd7e775084c5d9f5bf289076cc05e5e92" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discussed the execution of multiple functions in a co-operative manner. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s can be quite useful to pass data between running tasks, particularly those involving I/O operations.</source>
          <target state="translated">在部分&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; S IN &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;控制流&lt;/a&gt;在一个合作的方式讨论的多个功能的执行。&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;对于在正在运行的任务之间传递数据非常有用，尤其是那些涉及I / O操作的任务。</target>
        </trans-unit>
        <trans-unit id="b8192d7c492df82ef09042dd5374aa1f14711d23" translate="yes" xml:space="preserve">
          <source>The shared array is valid as long as a reference to the &lt;code&gt;SharedArray&lt;/code&gt; object exists on the node which created the mapping.</source>
          <target state="translated">只要在创建映射的节点上存在对 &lt;code&gt;SharedArray&lt;/code&gt; 对象的引用，共享数组就有效。</target>
        </trans-unit>
        <trans-unit id="5dc8475813b4cdc5d96eb3c4625fbd7b58d50c66" translate="yes" xml:space="preserve">
          <source>The shortest complete expression after the &lt;code&gt;$&lt;/code&gt; is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 之后的最短的完整表达式作为其值将被插入到字符串中的表达式。因此，您可以使用括号将任何表达式插入到字符串中：</target>
        </trans-unit>
        <trans-unit id="3d9f8e8412af884c31e022248ea444c48500d8b3" translate="yes" xml:space="preserve">
          <source>The simplest way to create a sparse array is to use a function equivalent to the &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an &lt;code&gt;sp&lt;/code&gt; prefix:</source>
          <target state="translated">创建稀疏数组的最简单方法是使用等效于Julia提供的用于处理密集数组的&lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt;函数的函数。要生成一个稀疏数组，可以使用带有 &lt;code&gt;sp&lt;/code&gt; 前缀的相同名称：</target>
        </trans-unit>
        <trans-unit id="b5c1b2cacc149914d1f87944b2e673b55e75f540" translate="yes" xml:space="preserve">
          <source>The singleton instance of &lt;code&gt;Colon&lt;/code&gt; is also a function used to construct ranges; see &lt;a href=&quot;../math/index#Base.::&quot;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Colon&lt;/code&gt; 的单例实例也是用于构造范围的函数。看&lt;a href=&quot;../math/index#Base.::&quot;&gt; &lt;code&gt;:&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69dbdef625126b35b49d3d64442b9b0a176ab7d3" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt; representing a missing value.</source>
          <target state="translated">类型&lt;a href=&quot;#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt;的单例实例表示缺少的值。</target>
        </trans-unit>
        <trans-unit id="d89078042c9eb6d352a7eb66e0b88b0400546bfa" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, used by convention when there is no value to return (as in a C &lt;code&gt;void&lt;/code&gt; function) or when a variable or field holds no value.</source>
          <target state="translated">约定No &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;的单例实例，约定在没有值要返回时（如在C &lt;code&gt;void&lt;/code&gt; 函数中）或在变量或字段不包含任何值时使用。</target>
        </trans-unit>
        <trans-unit id="98c477c6e9d21cf836746a2bcff1d62c547964d7" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of the file</source>
          <target state="translated">文件的大小(以字节为单位)。</target>
        </trans-unit>
        <trans-unit id="b66123090eeef1135c4d4375118f6396f24e2b0e" translate="yes" xml:space="preserve">
          <source>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter &lt;code&gt;T&lt;/code&gt; is not used in the definition of the type itself &amp;ndash; it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, &lt;code&gt;Ptr{Float64}&lt;/code&gt; and &lt;code&gt;Ptr{Int64}&lt;/code&gt; are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">与典型的参数组合类型相比，这些声明的略微奇怪之处在于，类型参数 &lt;code&gt;T&lt;/code&gt; 在类型本身的定义中未使用&amp;ndash;它只是一个抽象标记，本质上定义了具有相同结构的整个类型族，仅通过其类型参数进行区分。因此， &lt;code&gt;Ptr{Float64}&lt;/code&gt; 和 &lt;code&gt;Ptr{Int64}&lt;/code&gt; 是不同的类型，即使它们具有相同的表示形式。当然，所有特定的指针类型都是伞&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;类型的子类型：</target>
        </trans-unit>
        <trans-unit id="b70321f704716a765747450fd9a29400a288057e" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;a^n&lt;/code&gt; not less than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">最小 &lt;code&gt;a^n&lt;/code&gt; 不小于 &lt;code&gt;x&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是非负整数。 &lt;code&gt;a&lt;/code&gt; 必须大于1， &lt;code&gt;x&lt;/code&gt; 必须大于0。</target>
        </trans-unit>
        <trans-unit id="8e217f5379986c6dbb724913b9402b2744112320" translate="yes" xml:space="preserve">
          <source>The smallest in absolute value non-subnormal value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">给定浮点数据类型 &lt;code&gt;T&lt;/code&gt; 可以表示的绝对值非次级值的最小值。</target>
        </trans-unit>
        <trans-unit id="25349e0ef0dc3df135e9bbaceeafe9aedb6a8cb7" translate="yes" xml:space="preserve">
          <source>The so-called &quot;ternary operator&quot;, &lt;code&gt;?:&lt;/code&gt;, is closely related to the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</source>
          <target state="translated">所谓的&amp;ldquo;三元运算符&amp;rdquo; &lt;code&gt;?:&lt;/code&gt; 与 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 语法密切相关，但是用于需要在单个表达式值之间进行条件选择的情况，而不是条件地执行较长的代码块。它是大多数语言中唯一采用以下三个操作数的运算符而得名：</target>
        </trans-unit>
        <trans-unit id="466b5c814e2cc3e14c74b0b3d7f3038223cc5afa" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;CartesianIndex{N}&lt;/code&gt; object represents a scalar index that behaves like an &lt;code&gt;N&lt;/code&gt;-tuple of integers spanning multiple dimensions. For example:</source>
          <target state="translated">特殊的 &lt;code&gt;CartesianIndex{N}&lt;/code&gt; 对象表示一个标量索引，其行为类似于跨多个维度的 &lt;code&gt;N&lt;/code&gt; 个整数元组。例如：</target>
        </trans-unit>
        <trans-unit id="762a1096309b147153ae61442ac8f98b5b44d380" translate="yes" xml:space="preserve">
          <source>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, &lt;code&gt;@distributed&lt;/code&gt; performs local reductions on each worker with a final reduction on the calling process.</source>
          <target state="translated">指定的范围已分区，并在所有工作程序中本地执行。如果指定了可选的reducer函数，则 &lt;code&gt;@distributed&lt;/code&gt; 在每个工作程序上执行本地缩减，并在调用过程中进行最终缩减。</target>
        </trans-unit>
        <trans-unit id="af76c7aa8adb68998b2eccf29c56d714b4910790" translate="yes" xml:space="preserve">
          <source>The stack of current exceptions can be accessed using the experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; function. For example,</source>
          <target state="translated">可以使用实验性的&lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt;函数访问当前异常的堆栈。例如，</target>
        </trans-unit>
        <trans-unit id="b314da4796576e2f7b71a666741e2ef66714401f" translate="yes" xml:space="preserve">
          <source>The standard way to obtain a value of a certain type &lt;code&gt;T&lt;/code&gt; is to call the type's constructor, &lt;code&gt;T(x)&lt;/code&gt;. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Vector{Float64}&lt;/code&gt;, the expression &lt;code&gt;A[1] = 2&lt;/code&gt; should work by automatically converting the &lt;code&gt;2&lt;/code&gt; from &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Float64&lt;/code&gt;, and storing the result in the array. This is done via the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">获取某个特定类型 &lt;code&gt;T&lt;/code&gt; 的值的标准方法是调用该类型的构造函数 &lt;code&gt;T(x)&lt;/code&gt; 。但是，在某些情况下，无需程序员明确要求即可将值从一种类型转换为另一种类型很方便。一个示例是将值分配给数组：如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;Vector{Float64}&lt;/code&gt; ，则表达式 &lt;code&gt;A[1] = 2&lt;/code&gt; 应该通过将 &lt;code&gt;2&lt;/code&gt; 从 &lt;code&gt;Int&lt;/code&gt; 自动转换为 &lt;code&gt;Float64&lt;/code&gt; 并将结果存储在数组中来工作。这是通过&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;功能完成的。</target>
        </trans-unit>
        <trans-unit id="09c9759ec2f73e324d46f0dc859670daa106989a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; brings just the identifiers &lt;code&gt;thing1&lt;/code&gt; and &lt;code&gt;thing2&lt;/code&gt; into scope from module &lt;code&gt;BigLib&lt;/code&gt;. If these names refer to functions, adding methods to them will not be allowed (you may only &quot;use&quot; them, not extend them).</source>
          <target state="translated">&lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; 的语句：Thing1，Thing2仅将标识符 &lt;code&gt;thing1&lt;/code&gt; 和 &lt;code&gt;thing2&lt;/code&gt; 引入模块 &lt;code&gt;BigLib&lt;/code&gt; 的作用域中。如果这些名称涉及函数，则不允许在其中添加方法（您只能&amp;ldquo;使用&amp;rdquo;它们，而不能扩展它们）。</target>
        </trans-unit>
        <trans-unit id="495d86d0b4d05239c00e12e65404916397e09df9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using Lib&lt;/code&gt; means that a module called &lt;code&gt;Lib&lt;/code&gt; will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by &lt;code&gt;Lib&lt;/code&gt; and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in &lt;code&gt;Lib&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;using Lib&lt;/code&gt; 的语句意味着称为 &lt;code&gt;Lib&lt;/code&gt; 的模块将可用于根据需要解析名称。当遇到在当前模块中没有定义的全局变量时，系统将在 &lt;code&gt;Lib&lt;/code&gt; 导出的变量中搜索该变量并将其导入（如果在其中找到）。这意味着当前模块中对该全局变量的所有使用将解析为 &lt;code&gt;Lib&lt;/code&gt; 中该变量的定义。</target>
        </trans-unit>
        <trans-unit id="e69251ee5ae969dde76ae7aecf53b32517ef054f" translate="yes" xml:space="preserve">
          <source>The stride should be unit stride.</source>
          <target state="translated">步伐应该是单位步伐。</target>
        </trans-unit>
        <trans-unit id="b5f6cb2eda0183a3a023b5793fbbc533b8630c5f" translate="yes" xml:space="preserve">
          <source>The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt;. In contrast, preprocessor &quot;macro&quot; systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; capabilities are available to explore the internals of a program and its types just like any other data.</source>
          <target state="translated">Lisp在Julia语言中最强大的遗产就是它的元编程支持。像Lisp一样，Julia将自己的代码表示为语言本身的数据结构。由于代码由可以从语言内部创建和操作的对象表示，因此程序可以转换并生成自己的代码。这允许复杂的代码生成而无需额外的构建步骤，并且还允许在&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;抽象语法树&lt;/a&gt;级别上运行真正的Lisp风格的宏。相反，预处理器&amp;ldquo;宏&amp;rdquo;系统（如C和C ++）在执行任何实际的解析或解释之前执行文本操作和替换。由于Julia中的所有数据类型和代码均由Julia数据结构表示，因此强大的&lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;反射功能&lt;/a&gt; 与其他任何数据一样，可以使用这些功能来探索程序的内部及其类型。</target>
        </trans-unit>
        <trans-unit id="5e569356ccc37557b3dd3a4c9eb2b13531bfa9b1" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format such that &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">对角线部分包含以打包格式存储的反射器$ v_i $，使得 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0c6aba56e3888ce8991d8adbbc0407169b7c0c0" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">对角线部分包含以打包格式存储的反射器$ v_i $，其中$ v_i $是矩阵 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; 第$ i $列。</target>
        </trans-unit>
        <trans-unit id="7e2a34ecc15f647be67c38e382f5d48daa6d45c2" translate="yes" xml:space="preserve">
          <source>The subscripted &lt;code&gt;rootsᵢ&lt;/code&gt;, &lt;code&gt;graphᵢ&lt;/code&gt; and &lt;code&gt;pathsᵢ&lt;/code&gt; variables correspond to the subscripted environments, &lt;code&gt;envᵢ&lt;/code&gt;, contained in &lt;code&gt;stack&lt;/code&gt;. The &lt;code&gt;reverse&lt;/code&gt; is present because &lt;code&gt;merge&lt;/code&gt; favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</source>
          <target state="translated">下标 &lt;code&gt;rootsᵢ&lt;/code&gt; ， &lt;code&gt;graphᵢ&lt;/code&gt; 和 &lt;code&gt;pathsᵢ&lt;/code&gt; 变量对应于 &lt;code&gt;stack&lt;/code&gt; 中包含的下标环境 &lt;code&gt;envᵢ&lt;/code&gt; 。该 &lt;code&gt;reverse&lt;/code&gt; 存在，因为 &lt;code&gt;merge&lt;/code&gt; 有利于最后一个参数，而不是先当有它的参数字典键之间的碰撞。此设计有几个值得注意的功能：</target>
        </trans-unit>
        <trans-unit id="996fc71a38fd366e817f73bce0377ef4ace5919b" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;code&gt;AbstractArray&lt;/code&gt; typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are of the same type:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 的子类型通常实现两种方法来实现此目的：一种将输入数组转换为特定 &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; 抽象类型的子类型的方法；以及使用特定元素类型制作新的未初始化数组的方法。这些示例实现可以在Julia Base中找到。这是它们的基本示例用法，保证 &lt;code&gt;input&lt;/code&gt; 和 &lt;code&gt;output&lt;/code&gt; 为相同类型：</target>
        </trans-unit>
        <trans-unit id="63699aa33be9f33f21d62b86441a8ff8e274be42" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;M.x = y&lt;/code&gt; does not work to assign a global in another module; global assignment is always module-local.</source>
          <target state="translated">语法 &lt;code&gt;M.x = y&lt;/code&gt; 无法在另一个模块中分配全局变量；全局分配始终是模块本地的。</target>
        </trans-unit>
        <trans-unit id="8aef45ce051e500a72b345ef2f22cdbfc5692cd9" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">语法 &lt;code&gt;[A, B, C, ...]&lt;/code&gt; 构造其参数的1-d数组（即向量）。如果所有参数都具有通用的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;提升类型，&lt;/a&gt;则可以使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 将&lt;/a&gt;其转换为该类型。</target>
        </trans-unit>
        <trans-unit id="e625bef095d2c8eb72ebaeebbec92f580bcf9df3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b = c&lt;/code&gt; calls &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt;.</source>
          <target state="translated">语法 &lt;code&gt;a.b = c&lt;/code&gt; 调用 &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb9de73fee4d35f05a94de3650ba9db8d2743f66" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b&lt;/code&gt; calls &lt;code&gt;getproperty(a, :b)&lt;/code&gt;.</source>
          <target state="translated">语法 &lt;code&gt;a.b&lt;/code&gt; 调用 &lt;code&gt;getproperty(a, :b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00608410463d33a3565dc12e2221379a6b79beb5" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;catch e&lt;/code&gt; (where &lt;code&gt;e&lt;/code&gt; is any variable) assigns the thrown exception object to the given variable within the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">语法 &lt;code&gt;catch e&lt;/code&gt; （其中 &lt;code&gt;e&lt;/code&gt; 是任何变量）将引发的异常对象分配给 &lt;code&gt;catch&lt;/code&gt; 块内的给定变量。</target>
        </trans-unit>
        <trans-unit id="fbb021dba0d683eea0a7e9eec6250ba19720138f" translate="yes" xml:space="preserve">
          <source>The syntax for images is similar to the link syntax mentioned above. Prepending a &lt;code&gt;!&lt;/code&gt; character to a link will display an image from the specified URL rather than a link to it.</source>
          <target state="translated">图像的语法类似于上面提到的链接语法。在前面加一个 &lt;code&gt;!&lt;/code&gt; 链接的字符将显示来自指定URL的图像，而不是指向该URL的链接。</target>
        </trans-unit>
        <trans-unit id="4706abb51ce58ba5921e55c75731359f252d532a" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;remotecall&lt;/code&gt; is not especially convenient. The macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; 的语法不是特别方便。宏&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;使事情变得更容易。它对表达式而不是函数进行运算，并为您选择在何处进行运算：</target>
        </trans-unit>
        <trans-unit id="e63059505e9b54a2aa7f6f114401eafe55571016" translate="yes" xml:space="preserve">
          <source>The syntaxes &lt;code&gt;A[end]&lt;/code&gt; and &lt;code&gt;A[end, end]&lt;/code&gt; lower to &lt;code&gt;A[lastindex(A)]&lt;/code&gt; and &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt;, respectively.</source>
          <target state="translated">语法 &lt;code&gt;A[end]&lt;/code&gt; 和 &lt;code&gt;A[end, end]&lt;/code&gt; 低于 &lt;code&gt;A[lastindex(A)]&lt;/code&gt; 和 &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76ff0041a09cb9e2761ca760c9e89d92dece6223" translate="yes" xml:space="preserve">
          <source>The system also generates some standard information for each event:</source>
          <target state="translated">系统还会为每个事件生成一些标准信息。</target>
        </trans-unit>
        <trans-unit id="1291d08b43c51644b75972a68949c78194cf4ab6" translate="yes" xml:space="preserve">
          <source>The system provides several advantages over peppering your source code with calls to &lt;code&gt;println()&lt;/code&gt;. First, it allows you to control the visibility and presentation of messages without editing the source code. For example, in contrast to the &lt;code&gt;@warn&lt;/code&gt; above</source>
          <target state="translated">与通过调用 &lt;code&gt;println()&lt;/code&gt; 来添加源代码相比，该系统具有多个优点。首先，它允许您控制消息的可见性和显示方式，而无需编辑源代码。例如，与上面的 &lt;code&gt;@warn&lt;/code&gt; 相反</target>
        </trans-unit>
        <trans-unit id="35ef5183de88aa885d43235fbe1c95c14449a9c3" translate="yes" xml:space="preserve">
          <source>The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:</source>
          <target state="translated">标签键也可以用来用它们的Unicode等价物替代LaTeX数学符号,并获得LaTeX匹配列表。</target>
        </trans-unit>
        <trans-unit id="b6bb24eed2bccbd623888cb79506fd88f02fa796" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes-1&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="translated">与脚注关联的文本可以在与脚注参考相同的页面中的任何位置编写。下面的&amp;ldquo; &lt;a href=&quot;#Footnotes-1&quot;&gt;脚注&amp;rdquo;&lt;/a&gt;部分将讨论用于定义脚注文本的语法。</target>
        </trans-unit>
        <trans-unit id="89803a19d844f78ae00674dace9498726fc7f334" translate="yes" xml:space="preserve">
          <source>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called &lt;em&gt;environment stacks&lt;/em&gt;. The Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global defines an environment stack&amp;mdash;the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in &lt;code&gt;LOAD_PATH&lt;/code&gt;. It is often quite useful, however, to have access to some of your favorite tools&amp;mdash;standard libraries, profilers, debuggers, personal utilities, etc.&amp;mdash;even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</source>
          <target state="translated">第三种也是最后一种环境是通过覆盖其他环境来组合其他环境，从而使每个环境中的软件包都可以在单个复合环境中使用。这些复合环境称​​为&lt;em&gt;环境堆栈&lt;/em&gt;。 Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; 全局变量定义了一个环境堆栈-Julia进程在其中运行的环境。如果要让Julia进程仅访问一个项目或包目录中的包，请使其成为 &lt;code&gt;LOAD_PATH&lt;/code&gt; 中的唯一条目。但是，访问一些您喜欢的工具（标准库，分析器，调试器，个人实用程序等）通常非常有用，即使它们不是您正在处理的项目的依赖项。通过将包含这些工具的环境添加到加载路径，您可以立即以顶级代码访问它们，而无需将其添加到项目中。</target>
        </trans-unit>
        <trans-unit id="2e5e0709035da59f79f484697f8e3df4d573f5fc" translate="yes" xml:space="preserve">
          <source>The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</source>
          <target state="translated">前面几节讨论的三种类型(抽象、原始、复合)其实都是密切相关的。它们有着相同的关键属性。</target>
        </trans-unit>
        <trans-unit id="96a22cbc00a4020163f8bf8451c0cb52f4fe8ed1" translate="yes" xml:space="preserve">
          <source>The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; operator return &lt;code&gt;missing&lt;/code&gt; whenever the result cannot be determined without knowing the actual value of the &lt;code&gt;missing&lt;/code&gt; entry. In practice, this means that &lt;code&gt;missing&lt;/code&gt; is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)</source>
          <target state="translated">上面为逻辑运算符描述的三值逻辑也被应用于数组的逻辑函数使用。因此，只要不知道 &lt;code&gt;missing&lt;/code&gt; 项的实际值就无法确定结果，使用&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;运算符的数组相等性测试将返回 &lt;code&gt;missing&lt;/code&gt; 。在实践中，这意味着 &lt;code&gt;missing&lt;/code&gt; 如果所比较的阵列的所有非缺失值相等则返回，但一个或两个阵列包含缺失值（可能在不同的位置）</target>
        </trans-unit>
        <trans-unit id="7bb480c16cbf47fe55bf38e90f5861a483a884fb" translate="yes" xml:space="preserve">
          <source>The tuple must be the same size as the SIMD type. For example, a tuple representing an &lt;code&gt;__m128&lt;/code&gt; on x86 must have a size of 16 bytes.</source>
          <target state="translated">元组的大小必须与SIMD类型的大小相同。例如，在x86上代表 &lt;code&gt;__m128&lt;/code&gt; 的元组的大小必须为16个字节。</target>
        </trans-unit>
        <trans-unit id="d71d89013d2d694c3c90bff3726394654345117f" translate="yes" xml:space="preserve">
          <source>The two expressions constructed above &amp;ndash; by parsing and by direct construction &amp;ndash; are equivalent:</source>
          <target state="translated">上面构造的两个表达式（通过解析和直接构造）是等效的：</target>
        </trans-unit>
        <trans-unit id="3b3360fde4989c6fe95a691dce2016abf50d9177" translate="yes" xml:space="preserve">
          <source>The two uses of the &lt;code&gt;...&lt;/code&gt; operator: slurping and splatting</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 运算符的两种用法：吸食和泼洒</target>
        </trans-unit>
        <trans-unit id="b96a5c8aeea4ce2a16e47711028fe9eaf98f3763" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; 类型是其坐标是64位浮点值的点，而 &lt;code&gt;Point{AbstractString}&lt;/code&gt; 类型是其&amp;ldquo;坐标&amp;rdquo;是字符串对象的&amp;ldquo;点&amp;rdquo;（请参见&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b7369108ecd55df4b36265309c9d17ce4d10c19" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;NTuple{N,T}&lt;/code&gt; is a convenient alias for &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt;, i.e. a tuple type containing exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vararg{T,N}&lt;/code&gt; 类型恰好对应于 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;N&lt;/code&gt; 个元素。 &lt;code&gt;NTuple{N,T}&lt;/code&gt; 是 &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt; 的方便别名，即，一个元组类型恰好包含 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;N&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="5bedae316814d6156803443fcc9c13d8c64877a4" translate="yes" xml:space="preserve">
          <source>The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with &lt;code&gt;let&lt;/code&gt; blocks as follows.</source>
          <target state="translated">类型注释可以部分地恢复由于捕获而导致的性能损失，因为解析器可以将具体类型与框中的对象相关联。更进一步，如果捕获的变量根本不需要装箱（因为在创建闭包后将不会重新分配它），则可以用 &lt;code&gt;let&lt;/code&gt; 块表示如下。</target>
        </trans-unit>
        <trans-unit id="6fbcbd4db01a84d712a7283dfeb43aba8b033041" translate="yes" xml:space="preserve">
          <source>The type application syntax &lt;code&gt;A{B,C}&lt;/code&gt; requires &lt;code&gt;A&lt;/code&gt; to be a &lt;code&gt;UnionAll&lt;/code&gt; type, and first substitutes &lt;code&gt;B&lt;/code&gt; for the outermost type variable in &lt;code&gt;A&lt;/code&gt;. The result is expected to be another &lt;code&gt;UnionAll&lt;/code&gt; type, into which &lt;code&gt;C&lt;/code&gt; is then substituted. So &lt;code&gt;A{B,C}&lt;/code&gt; is equivalent to &lt;code&gt;A{B}{C}&lt;/code&gt;. This explains why it is possible to partially instantiate a type, as in &lt;code&gt;Array{Float64}&lt;/code&gt;: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit &lt;code&gt;where&lt;/code&gt; syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as &lt;code&gt;Array{T,1} where T&lt;/code&gt;.</source>
          <target state="translated">应用类型语法 &lt;code&gt;A{B,C}&lt;/code&gt; 需要 &lt;code&gt;A&lt;/code&gt; 是一个 &lt;code&gt;UnionAll&lt;/code&gt; 类型，以及第一替代 &lt;code&gt;B&lt;/code&gt; 用于在最外层的类型变量 &lt;code&gt;A&lt;/code&gt; 。预期结果将是另一个 &lt;code&gt;UnionAll&lt;/code&gt; 类型，然后将 &lt;code&gt;C&lt;/code&gt; 替换为该类型。因此 &lt;code&gt;A{B,C}&lt;/code&gt; 等效于 &lt;code&gt;A{B}{C}&lt;/code&gt; 。这解释了为什么可以像 &lt;code&gt;Array{Float64}&lt;/code&gt; 那样部分实例化类型：第一个参数值已固定，但第二个参数值仍在所有可能的值范围内。 &lt;code&gt;where&lt;/code&gt; 使用显式语法，参数的任何子集都可以固定。例如，所有的一维数组的类型可被写为 &lt;code&gt;Array{T,1} where T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffb66b4dabff5050a74ff3cadfb7762c384071e4" translate="yes" xml:space="preserve">
          <source>The type arguments to &lt;code&gt;ccall&lt;/code&gt; and &lt;code&gt;@cfunction&lt;/code&gt; are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</source>
          <target state="translated">当定义包含用法的方法时，将静态评估 &lt;code&gt;ccall&lt;/code&gt; 和 &lt;code&gt;@cfunction&lt;/code&gt; 的类型参数。因此，它们必须采用文字元组而不是变量的形式，并且不能引用局部变量。</target>
        </trans-unit>
        <trans-unit id="1a668fb8c29cba9ffa772e3e0ec9a1a70c5fa795" translate="yes" xml:space="preserve">
          <source>The type is an &lt;code&gt;Array{T,N}&lt;/code&gt; with a bits-type element of &lt;code&gt;T&lt;/code&gt; and dimension &lt;code&gt;N&lt;/code&gt; that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</source>
          <target state="translated">类型是一个 &lt;code&gt;Array{T,N}&lt;/code&gt; ，它的位类型元素为 &lt;code&gt;T&lt;/code&gt; ，维数 &lt;code&gt;N&lt;/code&gt; 决定了如何解释数组的字节。请注意，该文件必须以二进制格式存储，并且无法进行格式转换（这是操作系统的限制，而不是Julia的限制）。</target>
        </trans-unit>
        <trans-unit id="7d5dd90cb0f8495d6d15c26b83250961e3145b2f" translate="yes" xml:space="preserve">
          <source>The type of field &lt;code&gt;a&lt;/code&gt; can be readily determined from the type of &lt;code&gt;m&lt;/code&gt;, but not from the type of &lt;code&gt;t&lt;/code&gt;. Indeed, in &lt;code&gt;t&lt;/code&gt; it's possible to change the type of the field &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">字段 &lt;code&gt;a&lt;/code&gt; 的类型可以很容易地根据 &lt;code&gt;m&lt;/code&gt; 的类型确定，而不能根据 &lt;code&gt;t&lt;/code&gt; 的类型确定。事实上，在 &lt;code&gt;t&lt;/code&gt; 有可能改变字段的类型 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="282394fd5d6e1d690607a98e995ab7809b63cd8e" translate="yes" xml:space="preserve">
          <source>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). &lt;code&gt;Symbol&lt;/code&gt;s can be entered using the &lt;code&gt;:&lt;/code&gt; quote operator:</source>
          <target state="translated">用于表示已解析的茱莉亚代码（AST）中的标识符的对象类型。也常用作名称或标签来标识实体（例如，作为字典键）。可以使用 &lt;code&gt;:&lt;/code&gt; 引号运算符输入 &lt;code&gt;Symbol&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9d435d74348a381158dd6b8006d6bf402fcef60" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="translated">告诫的类型可以是任何单词，但是有些类型会产生特殊的样式，即（按严重程度从高到低的顺序排列）： &lt;code&gt;danger&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ， &lt;code&gt;info&lt;/code&gt; / &lt;code&gt;note&lt;/code&gt; 和 &lt;code&gt;tip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cde77f6d397a5966075de74e297cbf03487660" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="translated">类型该方法的第一个参数是一个&lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;单类型&lt;/a&gt;， &lt;code&gt;Type{MyType}&lt;/code&gt; ，唯一的实例，它的是 &lt;code&gt;MyType&lt;/code&gt; 。因此，仅当第一个参数是类型值 &lt;code&gt;MyType&lt;/code&gt; 时才调用此方法。注意第一个参数的语法：在 &lt;code&gt;::&lt;/code&gt; 符号之前省略参数名称，只给出类型。这是Julia在Julian中定义的函数参数的语法，该函数参数的类型已指定但其值不需要按名称引用。在此示例中，由于类型是单例，因此我们已经知道它的值而无需引用参数名称。</target>
        </trans-unit>
        <trans-unit id="3cdf4225b7d8119f12b6f1e72fd124d403b4e26b" translate="yes" xml:space="preserve">
          <source>The type of the first entry of the tuple returned by &lt;code&gt;iterate()&lt;/code&gt;</source>
          <target state="translated">由 &lt;code&gt;iterate()&lt;/code&gt; 返回的元组的第一个条目的类型</target>
        </trans-unit>
        <trans-unit id="5aa022df5697534e05992976fa7f76aa1feeee08" translate="yes" xml:space="preserve">
          <source>The types &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;'s direct supertype is &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt;. All other differences between &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; are matters of behavior &amp;ndash; the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; behave any differently than &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;都有相同的表示形式：它们是八位内存块。由于Julia的类型系统是主格，因此尽管结构相同，但它们是不可互换的。它们之间的根本区别是它们具有不同的超类型：&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;的直接超类型是&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;的是&lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;的是&lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;之间的所有其他区别与行为有关&amp;ndash;当将这些类型的给定对象作为参数时，函数定义的行为方式。这就是为什么必须使用名词性类型系统的原因：如果结构确定了类型，而类型又决定了行为，那么就不可能使&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; 的&lt;/a&gt;行为与&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;有所不同。</target>
        </trans-unit>
        <trans-unit id="b0109db562376dbf272015811ad8745f34d0c123" translate="yes" xml:space="preserve">
          <source>The types of keyword arguments can be made explicit as follows:</source>
          <target state="translated">关键字参数的类型可以明确如下。</target>
        </trans-unit>
        <trans-unit id="150a26f4f49fe87245564e04ceb960fcfbaf40b2" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;code&gt;++&lt;/code&gt;, etc. Other compositions of unary operators are parsed with right-associativity, e. g., &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt;.</source>
          <target state="translated">一元运算符 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 要求在其参数周围带有明确的括号，以将其与运算符 &lt;code&gt;++&lt;/code&gt; 等 &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; 。一元运算符的其他组成与右关联性一起解析，例如&amp;radic;&amp;radic;-a为 &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6715363fde6cdd7a1a24ce6e74d2c35a82ab804" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; can be used as digit separator:</source>
          <target state="translated">下划线 &lt;code&gt;_&lt;/code&gt; 可用作数字分隔符：</target>
        </trans-unit>
        <trans-unit id="5dc9c5b98b8ad88332e71a97e793e826e1cab445" translate="yes" xml:space="preserve">
          <source>The uniform scaling operator</source>
          <target state="translated">统一比例运算符</target>
        </trans-unit>
        <trans-unit id="37b7ee86ac667d6f86c0ad3037e31cb90445aa51" translate="yes" xml:space="preserve">
          <source>The updating versions of all the binary arithmetic and bitwise operators are:</source>
          <target state="translated">所有二进制算术和位智运算符的更新版本是:。</target>
        </trans-unit>
        <trans-unit id="1cf2be628194a336d3bbb72bed6445464a756995" translate="yes" xml:space="preserve">
          <source>The upper triangular part contains the elements of $R$, that is &lt;code&gt;R = triu(F.factors)&lt;/code&gt; for a &lt;code&gt;QR&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">上三角部分包含$ R $，即中的元素 &lt;code&gt;R = triu(F.factors)&lt;/code&gt; 用于 &lt;code&gt;QR&lt;/code&gt; 对象 &lt;code&gt;F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="227320fa312076c32b3808304d06cb30fbcb2399" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 用于表达式插值的用途故意使人联想到&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;字符串插值&lt;/a&gt;和&lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;命令插值&lt;/a&gt;。表达式内插允许对复杂的Julia表达式进行方便，可读的程序构造。</target>
        </trans-unit>
        <trans-unit id="414780375a6643e2453e6d8634fae95c5ade2420" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; keyword is exactly the same as in other languages, but is often optional. A function without an explicit &lt;code&gt;return&lt;/code&gt; statement will return the last expression in the function body.</source>
          <target state="translated">&lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt;关键字的使用与其他语言完全相同，但是通常是可选的。没有显式 &lt;code&gt;return&lt;/code&gt; 语句的函数将返回函数主体中的最后一个表达式。</target>
        </trans-unit>
        <trans-unit id="a2d597104e09bc0cd5d3b4e8b871fd483fedc685" translate="yes" xml:space="preserve">
          <source>The user id of the owner of the file</source>
          <target state="translated">文件所有者的用户ID</target>
        </trans-unit>
        <trans-unit id="6c6699f50d2afb2e82521e06f95a5e242ef5260f" translate="yes" xml:space="preserve">
          <source>The usual representation of a &lt;code&gt;quote&lt;/code&gt; form in an AST is an &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; with head &lt;code&gt;:quote&lt;/code&gt;:</source>
          <target state="translated">AST中 &lt;code&gt;quote&lt;/code&gt; 形式的通常表示形式是&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;，其头部为 &lt;code&gt;:quote&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="35f0445ac7033162f95af7dffff6b9386fa1de30" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; is used to construct the expression &lt;code&gt;ex&lt;/code&gt; which applies the &lt;code&gt;+&lt;/code&gt; function to the value 1 and the variable &lt;code&gt;b&lt;/code&gt;. Note the important distinction between the way &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are used:</source>
          <target state="translated">的值 &lt;code&gt;a&lt;/code&gt; 被用来构建表达 &lt;code&gt;ex&lt;/code&gt; 施加的 &lt;code&gt;+&lt;/code&gt; 函数为值1和变量 &lt;code&gt;b&lt;/code&gt; 。请注意 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的使用方式之间的重要区别：</target>
        </trans-unit>
        <trans-unit id="62de8f816c4cc9e366c76d8b6179874f1c02891f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is only valid immediately after a &lt;code&gt;ccall&lt;/code&gt; to a C library routine that sets it. Specifically, you cannot call &lt;code&gt;errno&lt;/code&gt; at the next prompt in a REPL, because lots of code is executed between prompts.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 的值仅在 &lt;code&gt;ccall&lt;/code&gt; 设置它的C库例程后立即有效。特别是，您不能在REPL中的下一个提示处调用 &lt;code&gt;errno&lt;/code&gt; ，因为在提示之间执行了大量代码。</target>
        </trans-unit>
        <trans-unit id="aa580957fe65ae6ff4c7a945625a32e87a3c4957" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;variable&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; at expression construction time is used as an immediate value in the expression. Thus, the value of &lt;code&gt;a&lt;/code&gt; when the expression is evaluated no longer matters: the value in the expression is already &lt;code&gt;1&lt;/code&gt;, independent of whatever the value of &lt;code&gt;a&lt;/code&gt; might be.</source>
          <target state="translated">表达式构造时&lt;em&gt;变量&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; 的值用作表达式中的立即数。因此，对表达式求值时的 &lt;code&gt;a&lt;/code&gt; 值不再重要：表达式中的值已经为 &lt;code&gt;1&lt;/code&gt; ，而与 &lt;code&gt;a&lt;/code&gt; 的值无关。</target>
        </trans-unit>
        <trans-unit id="9712274625a8ada140a13908f35f8b798b923a70" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As in C and most other imperative or functional languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="translated">函数返回的值是最后一个表达式的值，默认情况下，它是函数定义主体中的最后一个表达式。在上一部分的示例函数 &lt;code&gt;f&lt;/code&gt; 中，这是表达式 &lt;code&gt;x + y&lt;/code&gt; 的值。与C语言以及大多数其他命令式或函数式语言一样， &lt;code&gt;return&lt;/code&gt; 关键字使函数立即返回，并提供返回其值的表达式：</target>
        </trans-unit>
        <trans-unit id="c36bf156fd24214b4253de2ab2fb9c5aaef1f580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field &lt;code&gt;a&lt;/code&gt;, the fact that the memory representation of a &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; differs from a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 的值具有相同的类型，但是它们在内存中的基础数据表示形式却非常不同。即使您仅在字段 &lt;code&gt;a&lt;/code&gt; 中存储了数值，&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;的内存表示形式与Float64的表示形式不同的&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;也意味着CPU需要使用两种不同的指令来处理它们。由于所需的信息在该类型中不可用，因此必须在运行时做出此类决定。这会降低性能。</target>
        </trans-unit>
        <trans-unit id="8485dbcd7c0bda629f4ab2a94790ee6bae11f052" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;返回的值始终是给定的参数类型。（上面的表达式使用了尚未引入的几个功能，包括&lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for循环&lt;/a&gt;，&lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;和&lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;，但对于具有一些已有编程经验的用户来说，应该足够容易理解。）</target>
        </trans-unit>
        <trans-unit id="10056f49c16766ab5a7d038814128061f1bc2774" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;relation&lt;/code&gt; is declared inside the &lt;code&gt;if&lt;/code&gt; block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</source>
          <target state="translated">变量 &lt;code&gt;relation&lt;/code&gt; 在 &lt;code&gt;if&lt;/code&gt; 块内部声明，但在外部使用。但是，根据这种行为，请确保所有可能的代码路径都为变量定义了一个值。对以上函数的以下更改导致运行时错误</target>
        </trans-unit>
        <trans-unit id="67a867d229f7011e541a374fedf8ebf1c9e53637" translate="yes" xml:space="preserve">
          <source>The variable bound defaults to &lt;a href=&quot;#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; if it is omitted:</source>
          <target state="translated">如果省略变量bound，则默认为&lt;a href=&quot;#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e448ca292ee1dbe02f872083148deaa835508c61" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are bound to the first two argument values as usual, and the variable &lt;code&gt;x&lt;/code&gt; is bound to an iterable collection of the zero or more values passed to &lt;code&gt;bar&lt;/code&gt; after its first two arguments:</source>
          <target state="translated">变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 照常绑定到前两个参数值，变量 &lt;code&gt;x&lt;/code&gt; 绑定到前两个参数后传递给 &lt;code&gt;bar&lt;/code&gt; 的零个或多个值的可迭代集合：</target>
        </trans-unit>
        <trans-unit id="4a9e1ff901c13ad87d154ae8aa5cd1e9d49a1456" translate="yes" xml:space="preserve">
          <source>The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.</source>
          <target state="translated">绝大多数函数不会接受上面列出的每一种参数;数字只是表示函数中任何适用参数的优先级。</target>
        </trans-unit>
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">对于指针数组来说,直接更新其数据时,也需要设置写入障碍。例如:</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 或 &lt;code&gt;DateTime&lt;/code&gt; 的年份为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">然后，如果环境变量 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 设置为 &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; ，则可以执行输出 &lt;code&gt;test&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">然后导航到包含您的测试文件的目录（此处假定为 &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; ）并执行以下操作：</target>
        </trans-unit>
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">然后，内部方法 &lt;code&gt;_fA&lt;/code&gt; 和 &lt;code&gt;_fB&lt;/code&gt; 可以在 &lt;code&gt;y&lt;/code&gt; 上分派，而不必担心相对于 &lt;code&gt;x&lt;/code&gt; 的歧义。</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">然后,将项目中的main()函数替换成这段代码。</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">不存在</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">存在</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">还有一个宏&lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt;，它可能比 &lt;code&gt;macroexpand&lt;/code&gt; 函数更方便：</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">我们可以扩展更多的方法来为Julia提供有关此可迭代集合的更多信息。我们知道 &lt;code&gt;Squares&lt;/code&gt; 序列中的元素将始终为 &lt;code&gt;Int&lt;/code&gt; 。通过扩展&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;方法，我们可以将该信息提供给Julia，并帮助它在更复杂的方法中编写更专业的代码。我们还知道序列中元素的数量，因此我们也可以扩展&lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">关于茱莉亚的手串,有几个值得注意的高级功能。</target>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">交互式工作有许多独特的有用功能。除了显示结果之外，REPL还将结果绑定到变量 &lt;code&gt;ans&lt;/code&gt; 。行尾的分号可以用作禁止显示结果的标志。</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">还有两个带有 &lt;code&gt;mime&lt;/code&gt; 参数的变体（MIME类型字符串，例如 &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; ），它们尝试&lt;em&gt;仅&lt;/em&gt;使用请求的MIME类型显示 &lt;code&gt;x&lt;/code&gt; ，如果两个display（）都不支持此类型，则抛出 &lt;code&gt;MethodError&lt;/code&gt; 。 s）或 &lt;code&gt;x&lt;/code&gt; 。使用这些变体，还可以通过传递 &lt;code&gt;x::AbstractString&lt;/code&gt; （适用于具有基于文本的存储的MIME类型，例如text / html或application / postscript）或 &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; （用于二进制MIME类型）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">目前在基础Julia中有四种排序算法。</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; 和&lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt;之间有区别。</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">构造函数与 &lt;code&gt;convert&lt;/code&gt; 不同的一般情况有四种：</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">您可以对程序进行更多有趣的测量，要获取全面的列表，请阅读&lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux性能示例页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">当然也有一些例外。例如，在&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 中&lt;/a&gt;，类型应始终排在第一位。在&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;，该值位于索引之前，因此可以将这些索引提供为varargs。</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">有几种不同的方式来考虑这个迭代器包装器。</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">有几个特殊的类型需要注意,因为没有其他类型可以被定义为同样的行为。</target>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">在某些情况下，您想构造一个字符串或使用字符串语义，但是标准字符串构造的行为并不是所需要的。对于这种情况，Julia提供了&lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;非标准的字符串文字&lt;/a&gt;。非标准字符串文字看起来像常规的双引号字符串文字，但是会立即加上一个标识符作为前缀，并且其行为与普通的字符串文字并不完全相同。如下所述，正则表达式，字节数组文字和版本号文字是非标准字符串文字的一些示例。&lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;元编程&lt;/a&gt;部分中提供了其他示例。</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">在某些情况下，类型参数在所有可能的类型上自由范围可能没有意义。在这种情况下，可以像这样限制 &lt;code&gt;T&lt;/code&gt; 的范围：</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">有一些功能可以控制GC。在正常使用情况下,这些功能应该是不必要的。</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">有一些键允许自动生成的日志数据被覆盖。</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">有三个重要的标准模块。</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">该库提供了三种记录器类型。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;是启动REPL时看到的默认记录器。它以可读的文本格式显示事件，并尝试对格式和过滤进行简单但用户友好的控制。&lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;是在必要时删除所有消息的便捷方法。它是&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;流的日志记录等效项。&lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;是一种非常简单的文本格式记录器，主要用于调试日志记录系统本身。</target>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">此函数有三个可能的返回点，取决于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值，返回三个不同表达式的值。由于最后一行是最后一个表达式，因此可以省略最后一行的 &lt;code&gt;return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">有三个指定的标准浮点值,它们不对应实数线上的任何一点。</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">有两类：从类型（例如 &lt;code&gt;rand(Int)&lt;/code&gt; ）或集合（例如 &lt;code&gt;rand(1:3)&lt;/code&gt; ）生成值。首先说明简单的情况，然后介绍更高级的用法。我们在这里假设算法的选择与RNG无关，因此我们在签名中使用 &lt;code&gt;AbstractRNG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">有两种重复计算表达式的构造： &lt;code&gt;while&lt;/code&gt; 循环和 &lt;code&gt;for&lt;/code&gt; 循环。这是一个 &lt;code&gt;while&lt;/code&gt; 循环的示例：</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">应用程序使用两种不同的名为 &lt;code&gt;Priv&lt;/code&gt; 的软件包。它使用私有包（它是根依赖项）和公共包（这是通过 &lt;code&gt;Pub&lt;/code&gt; 的间接依赖项）。这些通过各自不同的UUID进行区分，并且具有不同的dep：</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">扩展 &lt;code&gt;Random&lt;/code&gt; 功能的方法主要有两种：</target>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">有多种运行Julia代码和提供选项的方式，类似于可用于 &lt;code&gt;perl&lt;/code&gt; 和 &lt;code&gt;ruby&lt;/code&gt; 程序的方式：</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">不存在循环携带的内存依赖性</target>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">有一种方便的语法来命名这类类型,类似于函数定义语法的简式。</target>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">引用第二种语法形式是对多个表达式进行引用： &lt;code&gt;quote ... end&lt;/code&gt; 包含的代码块。</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">在Julia中定义函数有第二种更简洁的语法。上面演示的传统函数声明语法相当于下面的紧凑 &quot;赋值形式&quot;。</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">这里必须提到一种特殊的抽象参数类型：单例类型。对于每种类型的， &lt;code&gt;T&lt;/code&gt; 中，&amp;ldquo;单型&amp;rdquo; &lt;code&gt;Type{T}&lt;/code&gt; 是一个抽象的类型，其仅是实例对象 &lt;code&gt;T&lt;/code&gt; 。由于定义有点难以解析，因此让我们看一些示例：</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">还有一个&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;函数和一个更通用的&lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt;函数，该函数返回将 &lt;code&gt;y&lt;/code&gt; 转换为 &lt;code&gt;x&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">嵌套 &lt;code&gt;where&lt;/code&gt; 表达式也有一种简洁的语法。例如，这：</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">还有一种方法 &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; 对流 &lt;code&gt;io&lt;/code&gt; 的 &lt;code&gt;nb&lt;/code&gt; 个字节进行校验和，或者使用 &lt;code&gt;crc32c(io, crc)&lt;/code&gt; 对所有剩余字节进行校验和。因此，您可以执行&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt;校验和整个文件，或执行 &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; 校验&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;而不调用 &lt;code&gt;take!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">关于如何创建复合类型的实例还有更多的话要说，但是这种讨论既取决于&lt;a href=&quot;#Parametric-Types-1&quot;&gt;参数类型&lt;/a&gt;也取决于&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;，并且非常重要，因此可以在其自己的章节：&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;构造函数中解决&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">在对象值和非对象值之间没有划分:在Julia中,所有的值都是真正的对象,其类型属于一个单一的、完全连接的类型图,所有的节点都同样是类型的一级。</target>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">在Julia中没有无效的（NULL） &lt;code&gt;Ref&lt;/code&gt; ，但是 &lt;code&gt;Ptr&lt;/code&gt; 的 &lt;code&gt;C_NULL&lt;/code&gt; 实例可以传递给 &lt;code&gt;ccall&lt;/code&gt; Ref参数。</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">没有一个有意义的 &quot;编译时类型 &quot;的概念:一个值的唯一类型是它在程序运行时的实际类型。在面向对象的语言中,这被称为 &quot;运行时类型&quot;,静态编译与多态性的结合使这种区别变得重要。</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的实现仅此而已。Julia的标准库中的某些函数接受 &lt;code&gt;Val&lt;/code&gt; 实例作为参数，您也可以使用它编写自己的函数。例如：</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">还有一个额外的特殊调用约定&lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt;，它允许直接插入对LLVM内部函数的调用。在针对不常见的平台（例如GPGPU）时，这尤其有用。例如，对于&lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;，我们需要能够读取线程索引：</target>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">只有一个区别，表面上（语法上）似乎很小。之间的区别 &lt;code&gt;using&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 的是，与 &lt;code&gt;using&lt;/code&gt; 你需要说 &lt;code&gt;function Foo.bar(..&lt;/code&gt; 用一种新的方法扩展模块Foo的功能栏，但与 &lt;code&gt;import Foo.bar&lt;/code&gt; ，你只需要说 &lt;code&gt;function bar(...&lt;/code&gt; 并自动扩展模块Foo的功能栏。</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">这些规则之间有些重叠，因为前两个规则都覆盖了 &lt;code&gt;\x&lt;/code&gt; 和小于0x80（128）的八进制转义符的行为，但是在这里这些规则是一致的。这些规则一起使人们可以轻松地使用ASCII字符，任意字节值和UTF-8序列来生成字节数组。这是使用这三个示例的示例：</target>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">实际 &lt;code&gt;@assert&lt;/code&gt; 宏还会处理另一种情况：如果除了打印&amp;ldquo; a应该等于b&amp;rdquo;之外，我们还想打印其值怎么办？可能会天真地尝试在自定义消息中使用字符串插值，例如， &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; ，但这无法与上述宏一起正常工作。你知道为什么吗？从&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;字符串插值&lt;/a&gt;中回想起，将插值的字符串重写为对&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;的调用。比较：</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">还有一些具有传统意义的键值对。</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">因此，如果 &lt;code&gt;Array&lt;/code&gt; 包含错误格式的数据，则必须使用诸如 &lt;code&gt;trunc(Int32, a)&lt;/code&gt; 类的调用将其显式转换。</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">这些都是单参数函数， &lt;code&gt;atan&lt;/code&gt; 还接受与传统&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;函数相对应的两个参数。</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">这些都是一些小的点,可能会对紧密的内循环有所帮助。</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">这些是标准的系统mutexes,用于锁定逻辑的关键部分。</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">这些构件用于创建常规同步对象。</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">可以将它们混合&lt;strong&gt;在一起&lt;/strong&gt;以创建&lt;strong&gt;一个堆叠的环境&lt;/strong&gt;：一组有序的项目环境和软件包目录，它们叠加&lt;strong&gt;在一起&lt;/strong&gt;构成一个单一的复合环境。然后，优先级和可见性规则组合在一起，以确定哪些软件包可用以及从何处加载它们。例如，茱莉亚（Julia）的装载路径形成了一个堆叠的环境。</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">这些环境各有不同的作用。</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">仅当Julia是使用垃圾回收调试进行编译时（即，如果在构建配置中 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 时)，这些环境变量才有效。</target>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">这些示例有望有助于说明生成的函数在定义端和调用站点如何工作。但是，由于以下原因，&lt;em&gt;请勿复制它们&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">这些函数在&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数值比较&lt;/a&gt;中很有用，可避免不必要的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;类型转换带来的&lt;/a&gt;开销。</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">这些方法定义表明，在没有用于对数字值进行加，减，乘和除的更具体规则的情况下，将这些值提升为通用类型，然后重试。这就是全部内容：无需再担心升级为用于算术运算的通用数字类型了-它会自动发生。还有的涵盖所有在许多其他的算术和数学函数的推广方法定义&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt;，但除此之外，很难有任何呼叫 &lt;code&gt;promote&lt;/code&gt; 要求朱莉娅基地。 &lt;code&gt;promote&lt;/code&gt; 的最常见用法为方便起见，在外部构造函数方法中会发生这种情况，以允许具有混合类型的构造函数调用委派给内部类型，并将字段提升为适当的公共类型。例如，回想一下&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;提供了以下外部构造方法：</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">通过在&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 中&lt;/a&gt;列出的项目环境中搜索项目文件（ &lt;code&gt;Project.toml&lt;/code&gt; 或 &lt;code&gt;JuliaProject.toml&lt;/code&gt; ），清单文件（ &lt;code&gt;Manifest.toml&lt;/code&gt; 或 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ）或源文件的文件夹来回答这些问题。</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">这些规则表明，将 &lt;code&gt;SparseVecStyle&lt;/code&gt; 与0或1维数组结合使用会产生另一个 &lt;code&gt;SparseVecStyle&lt;/code&gt; ，将其与2维数组结合使用会产生 &lt;code&gt;SparseMatStyle&lt;/code&gt; ，而任何更高维度的对象都将退回到密集的任意维度框架中。这些规则允许广播保留操作的稀疏表示，以产生一维或二维输出，但为任何其他维生成一个 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">这些值分别为 &lt;code&gt;2.0^-23&lt;/code&gt; 和 &lt;code&gt;2.0^-52&lt;/code&gt; ，分别为&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值。的&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;功能也可以采取一个浮点值作为参数，并给出该值和下一个可表示浮点值之间的绝对差。也就是说， &lt;code&gt;eps(x)&lt;/code&gt; 产生与 &lt;code&gt;x&lt;/code&gt; 相同类型的值，使得 &lt;code&gt;x + eps(x)&lt;/code&gt; 是下一个可表示的大于 &lt;code&gt;x&lt;/code&gt; 的浮点值：</target>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">它们是明文规定的。</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">他们已经明确声明了超级类型。</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">他们有名字。</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">它们可能有参数。</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">稀薄空间</target>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">这种 &quot;声明 &quot;行为只发生在特定的语境中。</target>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">这样先把数字相加,再找出结果的平方根。</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">这允许 &lt;code&gt;a&lt;/code&gt; 为任何类型。这通常是有用的，但它确实有一个缺点：对于 &lt;code&gt;MyAmbiguousType&lt;/code&gt; 类型的对象，编译器将无法生成高性能代码。原因是编译器使用对象的类型而不是它们的值来确定如何构建代码。不幸的是，关于 &lt;code&gt;MyAmbiguousType&lt;/code&gt; 类型的对象的推断很少：</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">这使得类型断言可以就地附加到任何表达式上。</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">这样就可以进行下面这样的调用。</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">这允许对索引进行操作的函数与 &lt;code&gt;skipmissing&lt;/code&gt; 结合使用。搜索和查找功能尤其如此，它们返回对通过 &lt;code&gt;skipmissing&lt;/code&gt; 返回的对象有效的索引，这些索引&lt;em&gt;也是父数组中&lt;/em&gt;匹配项的索引&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">这种方法非常有效：编译器可以确定 &lt;code&gt;A&lt;/code&gt; 是一个 &lt;code&gt;Array{Float64,2}&lt;/code&gt; 因为它知道填充值的类型（ &lt;code&gt;5.0::Float64&lt;/code&gt; ）和维数（ &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; ）。这意味着编译器可以为将来在同一函数中使用 &lt;code&gt;A&lt;/code&gt; 生成非常有效的代码。</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">这个参数将在编译时,即定义包含方法时被评估。</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">这避免了需要连续检查 &lt;code&gt;null&lt;/code&gt; 值的需要。但是，并非所有对象字段都是引用。 Julia认为某些类型是&amp;ldquo;普通数据&amp;rdquo;，这意味着它们的所有数据都是自包含的，不引用其他对象。普通数据类型由基本类型（例如 &lt;code&gt;Int&lt;/code&gt; ）和其他普通数据类型的不可变结构组成。普通数据类型的初始内容是不确定的：</target>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">此行为是类型稳定性要求的不便后果。对于 &lt;code&gt;sqrt&lt;/code&gt; ，大多数用户都希望 &lt;code&gt;sqrt(2.0)&lt;/code&gt; 给出一个实数，如果生成的复数为 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 这将是不满意的。只有传递负数（这是 &lt;code&gt;sqrt&lt;/code&gt; 在某些其他语言中所做的事情）时，才可以编写 &lt;code&gt;sqrt&lt;/code&gt; 函数以切换到复数值输出，但是结果将不会是&lt;a href=&quot;#man-type-stability-1&quot;&gt;类型稳定的&lt;/a&gt;，并且 &lt;code&gt;sqrt&lt;/code&gt; 函数的性能会很差。</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">这种行为是基于这样的观察,即当我们使用无符号十六进制字元来表示整数值时,通常是用它们来表示一个固定的数字字节序列,而不仅仅是一个整数值。</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">在Julia中经常使用此行为，以替代非常短的 &lt;code&gt;if&lt;/code&gt; 语句。代替写 &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; ，可以编写 &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; （可以读为：&amp;lt;cond&amp;gt; &lt;em&gt;然后是&lt;/em&gt; &amp;lt;statement&amp;gt;）。同样，代替 &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; ，可以写 &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; （可以读取为：&amp;lt;cond&amp;gt; &lt;em&gt;或&lt;/em&gt; &amp;lt;statement&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">对于普通变量来说，这种行为似乎有些奇怪，但是允许在命名函数使用之前就使用命名函数，这些函数只是保存函数对象的普通变量。这允许以直观且方便的顺序定义函数，而不是强制自下而上排序或要求向前声明，只要它们在实际调用时定义即可。例如，这是一种无效的，相互递归的方法来测试正整数是偶数还是奇数：</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">此功能的行为在不同平台上略有不同。有关更多详细信息，请参见&lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">这个调用看起来什么都不做。但是,可以检查是否有异常被抛出。</target>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">这可以通过&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;点广播&lt;/a&gt;并将其与常规整数索引结合起来（而不是从 &lt;code&gt;A&lt;/code&gt; 提取第一 &lt;code&gt;page&lt;/code&gt; 作为单独的步骤）来更简单地表示。它甚至可以与 &lt;code&gt;:&lt;/code&gt; 组合使用，以同时从两个页面中提取两个对角线：</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">这可以与Julia代码中存在的签名相同（例如 &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ），也可以是简化形式。可能的话，可选参数应使用其默认值（即 &lt;code&gt;f(x, y=1)&lt;/code&gt; ）表示，并遵循实际的Julia语法。没有默认值的可选参数应放在方括号中（即 &lt;code&gt;f(x[, y])&lt;/code&gt; 和 &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ）。另一种解决方案是使用几行：一个不带可选参数，另一些带可选参数。该解决方案还可用于记录给定功能的几种相关方法。当函数接受许多关键字参数时，签名中仅包含 &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; 占位符（即 &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; ），并在 &lt;code&gt;# Arguments&lt;/code&gt; 部分下提供完整列表（请参见下面的第4点）。</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">这可以通过将&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;的结果传递给&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 来解决&lt;/a&gt;。&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; 不&lt;/a&gt;返回当前上下文的调用堆栈信息，而是返回最近异常的上下文的堆栈信息：</target>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">可以更简洁有效地写成:</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">如果另一个进程获得了相同的文件名并在能够之前创建了文件，则可能导致争用情况。使用&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;代替建议。</target>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">这个总括方法比任何其他可能的方法定义都要少,所以它只对没有其他方法定义的参数对进行调用。</target>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">本章介绍了程序包加载的技术细节。要安装软件包，请使用Julia的内置软件包管理器&lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; &lt;/a&gt;将软件包添加到活动环境中。要在您的活动环境，写已经使用套餐 &lt;code&gt;import X&lt;/code&gt; 或 &lt;code&gt;using X&lt;/code&gt; ，作为中所描述&lt;a href=&quot;../modules/index#modules-1&quot;&gt;的模块文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">此代码不会初始化所有的 &lt;code&gt;a&lt;/code&gt; ，因为每个进程都会有它的一个单独的副本。必须避免此类并行循环。幸运的是，可以使用&lt;a href=&quot;#man-shared-arrays-1&quot;&gt;共享阵列&lt;/a&gt;来解决此限制：</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">此构造实现了将迭代分配给多个进程，并将其与指定的约简（在这种情况下为 &lt;code&gt;(+)&lt;/code&gt; ）组合在一起的模式。每次迭代的结果将作为循环内最后一个表达式的值。整个并行循环表达式本身将得出最终答案。</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">这种结构避免了乘法和加法运算。</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">该构造函数将由语法 &lt;code&gt;SummedArray(a)&lt;/code&gt; 调用。语法 &lt;code&gt;new{T,S}&lt;/code&gt; 允许为要构造的类型指定参数，即此调用将返回 &lt;code&gt;SummedArray{T,S}&lt;/code&gt; 。 &lt;code&gt;new{T,S}&lt;/code&gt; 可以在任何构造函数定义中使用，但是为了方便起见， &lt;code&gt;new{}&lt;/code&gt; 的参数在可能的情况下自动从正在构造的类型中派生。</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">此便利函数返回一个迭代器，该迭代器可有效过滤掉 &lt;code&gt;missing&lt;/code&gt; 值。因此，它可以与任何支持迭代器的函数一起使用</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">这种对数组进行排序的约定在许多语言（例如Fortran，Matlab和R）中很常见。列优先排序的替代方法是行优先排序，这是C和Python（ &lt;code&gt;numpy&lt;/code&gt; ）在其他语言中采用的约定。记住，遍历数组时，数组的顺序可能会对性能产生重大影响。要记住的一个经验法则是，对于以列为主的数组，第一个索引的变化最快。从本质上讲，这意味着如果最里面的循环索引是第一个出现在切片表达式中的，则循环会更快。</target>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">这将创建一个25&amp;times;30000 &lt;code&gt;BitArray&lt;/code&gt; ，链接到与流 &lt;code&gt;io&lt;/code&gt; 关联的文件。</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">这将创建一个函数，该函数接受一个参数 &lt;code&gt;x&lt;/code&gt; 并以该值返回多项式 &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; 的值。请注意，结果是一个泛型函数，但是具有基于连续编号的编译器生成的名称。</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">该声明定义了一个新的参数类型 &lt;code&gt;Point{T}&lt;/code&gt; ，其中包含两个 &lt;code&gt;T&lt;/code&gt; 类型的&amp;ldquo;坐标&amp;rdquo; 。也许有人会问，是 &lt;code&gt;T&lt;/code&gt; 吗？好吧，这正是参数类型的要点：它可以是任何类型（实际上，也可以是任何位类型的值，尽管在这里它显然用作类型）。 &lt;code&gt;Point{Float64}&lt;/code&gt; 是一个具体类型等效于通过更换所定义的类型 &lt;code&gt;T&lt;/code&gt; 中的定义 &lt;code&gt;Point&lt;/code&gt; 与&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。因此，该单个声明实际上声明了无限数量的类型： &lt;code&gt;Point{Float64}&lt;/code&gt; ， &lt;code&gt;Point{AbstractString}&lt;/code&gt; ， &lt;code&gt;Point{Int64}&lt;/code&gt; 等。这些类型现在都是可用的具体类型：</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">如果没有显式的内部构造方法，此声明与 &lt;code&gt;Foo&lt;/code&gt; 类型的早期定义具有相同的效果。以下两种类型是等效的-一种具有默认构造函数，另一种具有显式构造函数：</target>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">这个依赖关系图用字典表示,看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种区别确定了类型必须定义的标量索引方法。 &lt;code&gt;IndexLinear()&lt;/code&gt; 数组很简单：只需定义 &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; 。当数组随后使用多维索引集进行索引时，后备 &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; 有效地将索引转换为一个线性索引，然后调用上述方法。另一方面， &lt;code&gt;IndexCartesian()&lt;/code&gt; 数组要求使用 &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 索引为每个受支持的维度定义方法。例如，来自 &lt;code&gt;SparseArrays&lt;/code&gt; 标准库模块的&lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;仅支持二维，因此它仅定义 &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; 。&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;同样适用！。</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">这不适用于 &lt;code&gt;function&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 声明。但是，绑定到全局变量的匿名函数将被序列化，如下所示。</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">这个环境变量只有在Julia编译时支持JIT剖析的情况下才会产生影响,在编译时使用</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">仅当Julia是使用垃圾回收调试进行编译时（即，在构建配置 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 时)，此环境变量才有效。</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误表明条件的类型错误：&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;而不是必需的&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">为了引入或操纵用户变量，可以在必要时使用这种转义机制来&amp;ldquo;违反&amp;rdquo;卫生要求。例如，以下宏在调用环境中将 &lt;code&gt;x&lt;/code&gt; 设置为零：</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">此示例演示了一种强大且经常使用的并行编程模式。许多迭代在多个进程中独立运行，然后使用某些函数将其结果合并。组合过程称为&lt;em&gt;减少&lt;/em&gt;，因为它通常是张量秩减少：将数字向量简化为单个数字，或者将矩阵简化为单个行或列，等等。在代码中，这通常看起来像模式 &lt;code&gt;x = f(x,v[i])&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是累加器， &lt;code&gt;f&lt;/code&gt; 是归约函数， &lt;code&gt;v[i]&lt;/code&gt; 是要归约的元素。希望 &lt;code&gt;f&lt;/code&gt; 是关联的，以便执行操作的顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">此示例首先分配一个字节数组，然后调用C库函数 &lt;code&gt;gethostname&lt;/code&gt; 以用主机名填充该数组，获取指向主机名缓冲区的指针，然后将指针转换为Julia字符串（假定它是NUL终止） C字符串。 C库通常使用这种模式，要求调用者分配要传递给被调用者并填充的内存。像这样从Julia分配内存通常是通过创建未初始化的数组并将指向其数据的指针传递给C函数。这就是为什么我们在这里不使用 &lt;code&gt;Cstring&lt;/code&gt; 类型的原因：由于数组未初始化，因此它可能包含NUL字节。作为 &lt;code&gt;Cstring&lt;/code&gt; 一部分转换为&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 检查包含的NUL字节，因此可能引发转换错误。</target>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">本实施例中生成许多次正规数因为在值 &lt;code&gt;a&lt;/code&gt; 成为一个指数递减曲线，随着时间的推移慢慢变平。</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">这个例子强调了相邻可表示的浮点数也有相邻的二进制整数表示的一般原则。</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">这个例子和上一个例子类似,只是有两个阶段的消费者,各阶段的延迟不同,所以他们使用不同数量的并行工作者,以维持饱和的吞吐量。</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">这个示例地图包括三种不同的软件包位置(第一种和第三种是默认加载路径的一部分)。</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">这个实验性接口支持Julia的多线程功能。这里描述的类型和功能可能(而且很可能会)在未来发生变化。</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该表达式使用 &lt;code&gt;string&lt;/code&gt; 构造一个名称，然后将该名称替换为新的&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;表达式，然后对其求值。请记住， &lt;code&gt;eval&lt;/code&gt; 仅在最高级别上运行，因此在该表达式内本地变量将不可用（除非其值用 &lt;code&gt;$&lt;/code&gt; 代替）。因此， &lt;code&gt;eval&lt;/code&gt; 通常仅用于形成顶级定义，例如在包装包含许多相似功能的库时。可以为&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;构造类似的示例。</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">此表达式以三个单词作为参数调用 &lt;code&gt;echo&lt;/code&gt; 命令： &lt;code&gt;hello&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;sort&lt;/code&gt; 。结果是只打印了一行： &lt;code&gt;hello | sort&lt;/code&gt; 。那么，如何构造管道？代替使用 &lt;code&gt;'|'&lt;/code&gt; 在反引号内部，使用 &lt;code&gt;pipeline&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">此功能是实验性的，在Julia的未来版本中可能会更改或消失。错误使用 &lt;code&gt;@simd&lt;/code&gt; 宏可能会导致意外结果。</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">这个功能很有用,可以避免在变量的一个赋值意外改变其类型时发生的性能 &quot;卡奇&quot;。</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">这种形式经常出现在方法签名上。</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">此格式不应与较早的&lt;em&gt;WY&lt;/em&gt;表示相混淆&lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">此功能可用于实现事务语义。在交易之前，将值记录在 &lt;code&gt;x&lt;/code&gt; 中。交易后，仅当 &lt;code&gt;x&lt;/code&gt; 同时未修改时才存储新值。</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">该函数计算除以数值精确的 &lt;code&gt;2&amp;pi;&lt;/code&gt; 后的模数的浮点表示形式，因此与 &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; 并不完全相同，后者将计算 &lt;code&gt;x&lt;/code&gt; 的相对于除以浮点数 &lt;code&gt;2&amp;pi;&lt;/code&gt; 的模数。</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此函数定义仅适用于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;类型的值的调用：</target>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">此功能是&amp;ldquo;不安全的&amp;rdquo;。请注意，只要使用此指针，就必须确保存在Julia对 &lt;code&gt;array&lt;/code&gt; 引用。该&lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt;宏应该被用来保护 &lt;code&gt;array&lt;/code&gt; 从垃圾收集参数给定的代码块中。</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">这个功能是&lt;em&gt;懒惰的&lt;/em&gt; ; 也就是说，保证返回$&amp;Theta;（1）$时间并使用$&amp;Theta;（1）$额外空间，并且调用 &lt;code&gt;filter&lt;/code&gt; 不会调用 &lt;code&gt;flt&lt;/code&gt; 。迭代返回的可迭代对象时，将调用 &lt;code&gt;flt&lt;/code&gt; 。这些调用不会被缓存，并且在重复时将进行重复调用。</target>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">这个功能从Julia 1.2开始提供。</target>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">这个功能在Julia 1.1中是试验性的,可能会在未来的版本中重新命名(见https://github.com/JuliaLang/julia/pull/29901)。</target>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">该功能被标记为&amp;ldquo;不安全&amp;rdquo;，因为如果 &lt;code&gt;p&lt;/code&gt; 不是所请求长度的数据的有效存储地址，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">该函数被标记为&amp;ldquo;不安全&amp;rdquo;，因为如果 &lt;code&gt;pointer&lt;/code&gt; 不是所请求长度数据的有效内存地址，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">如果 &lt;code&gt;Main&lt;/code&gt; 中尚未定义模块，则此功能是&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;实现的一部分。也可以直接调用它以强制重新加载模块，而不管模块之前是否已加载（例如，以交互方式开发库时）。</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">这个函数不能在不可变的对象上调用,因为它们没有稳定的内存地址。</target>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">在不支持软符号链接的操作系统下,如Windows XP,该功能会引发错误。</target>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">这个功能至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">该功能至少需要Julia 1.1。在Julia 1.0中，可以从标准库 &lt;code&gt;InteractiveUtils&lt;/code&gt; 中获得它。</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">这个功能至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">无论 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型如何，此函数将始终返回 &lt;code&gt;Int8&lt;/code&gt; 。有关返回类型的更多信息，请参见&lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;类型声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">该功能至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">该功能至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">这给出了一个类似于</target>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">本指南依靠Pkg REPL执行Pkg命令。对于非交互使用，我们建议使用Pkg API。Pkg API完整记录在Pkg文档的&amp;ldquo; &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API参考&amp;rdquo;&lt;/a&gt;部分中。</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">本指南应帮助您开始使用 &lt;code&gt;Pkg&lt;/code&gt; 。 &lt;code&gt;Pkg&lt;/code&gt; 在强大的软件包管理方面提供了更多功能，请阅读完整手册以了解更多信息！</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;foo&lt;/code&gt; 的先前定义完全相同。</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">这说明了默认的 &quot;树形 &quot;转储;另一种选择是 &quot;平面 &quot;转储,它积累的计数与它们的嵌套无关。</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">这将从 &lt;code&gt;Foo&lt;/code&gt; 导入所有符号，但仅导入 &lt;code&gt;Bar&lt;/code&gt; 模块内部。</target>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">该界面提供了一种机制，可以在不同的集群环境中启动和管理Julia工作者。Base中存在两种管理器： &lt;code&gt;LocalManager&lt;/code&gt; （用于在同一主机上启动其他工作程序）和 &lt;code&gt;SSHManager&lt;/code&gt; （用于通过 &lt;code&gt;ssh&lt;/code&gt; 在远程主机上启动）。TCP / IP套接字用于在进程之间连接和传输消息。群集管理器可以提供其他传输。</target>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">这是Julia封装器，指向&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">这是一个更好的选择,比</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">这是一个典型的示例，其中一个生产者为两个并发的消费者提供食物：一个 &lt;code&gt;perl&lt;/code&gt; 进程在其上生成数字为0到5的行，而两个并行进程在该输出中使用该行，一个前缀行带有字母&amp;ldquo; A&amp;rdquo;，另一个前缀行带有字母&amp;ldquo; A&amp;rdquo;。字母&amp;ldquo; B&amp;rdquo;。哪个消费者获得第一条线是不确定的，但是一旦赢得了这场比赛，这些线将由一个进程交替使用，然后由另一个进程替代。 （在Perl中设置 &lt;code&gt;$|=1&lt;/code&gt; 会使每个print语句刷新&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;句柄，这对于本示例来说是必需的。否则，所有输出将被缓冲并立即打印到管道中，仅由一个使用者进程读取。 ）</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">这是一种常见的模式,当从一个较大的类型类转换到算法实际支持的一个特定参数类型时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">这是一个有些人为的示例，因为我们可以通过消除条件并将 &lt;code&gt;println&lt;/code&gt; 调用放在 &lt;code&gt;if&lt;/code&gt; 块内来更清楚地产生相同的行为。在实际使用中，在 &lt;code&gt;continue&lt;/code&gt; 之后还有更多代码需要评估，并且通常有多个要点从一个点 &lt;code&gt;continue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">这是 &lt;code&gt;@time&lt;/code&gt; 宏的详细版本。它首先输出与 &lt;code&gt;@time&lt;/code&gt; 相同的信息，然后输出任何非零内存分配计数器，然后返回表达式的值。</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">这在整个Julia Base中是一个非常常见的模式:一小套所需的方法定义了一个非正式的接口,可以实现许多更高级的行为。在某些情况下,当类型知道在它们的特定情况下可以使用更有效的算法时,它们会想要额外地专门化那些额外的行为。</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">这是通过以下定义实现的。</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">这是通过 &lt;code&gt;base/boot.jl&lt;/code&gt; 中的以下代码完成的：</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">对于本地节点上的远程调用也是如此,如下例所示。</target>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">这是更好的样式，因为 &lt;code&gt;foo&lt;/code&gt; 并不真正接受所有类型的数字。它确实需要 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">这相当于 &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; 。编写 &lt;code&gt;Vector{Float64}&lt;/code&gt; 等效于编写 &lt;code&gt;Array{Float64,1}&lt;/code&gt; ，并且伞型 &lt;code&gt;Vector&lt;/code&gt; 作为实例具有所有 &lt;code&gt;Array&lt;/code&gt; 对象，其中第二个参数（数组维数）为1，无论元素类型是什么。在必须始终完整指定参数类型的语言中，这并不是特别有用，但是在Julia中，这允许人们只为抽象类型编写 &lt;code&gt;Vector&lt;/code&gt; ，包括任何元素类型的所有一维密集数组。</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">这等效于较丑的测试 &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; 。提供多个表达式是错误的，除非第一个表达式是调用表达式，其余的都是赋值（ &lt;code&gt;k=v&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">如果已经存在影响转换的命名函数作为&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的第一个参数传递，这很好。但是，通常不存在即用型命名功能。在这种情况下，匿名函数构造无需名称即可轻松创建一次性函数对象：</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">发生这种情况的原因是，虽然 &lt;code&gt;write&lt;/code&gt; 调用是同步的，但是在等待I / O的那部分完成时，每个参数的写操作都会屈服于其他任务。</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">旨在使用 &lt;code&gt;do&lt;/code&gt; 块语法进行调用</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">可以使用 &lt;code&gt;do&lt;/code&gt; block语法来调用它：</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">这很可能是一个非常昂贵的操作。考虑到Julia中所有其他原子操作都已经有获取/释放的语义,在大多数情况下,显式围栏应该是没有必要的。</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">这更具可读性和便利性，并且等效于上述字符串连接-系统将此明显的单个字符串文字重写为调用 &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">在工作线程（ &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ）上不需要这样做，因为 &lt;code&gt;InterruptException&lt;/code&gt; 仅会传递给主线程。不调用julia代码或julia运行时的外部函数在执行过程中会自动禁用sigint。</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">这通常是正确的策略;但是,在某些情况下,盲目地遵循这一建议可能会适得其反。特别是,一个通用函数的方法越多,出现歧义的可能性就越大。当你的方法层次结构变得比这个简单的例子更复杂时,值得你仔细考虑其他策略。</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">仅当您的模块依赖于未通过&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;使用的文件时，才需要这样做。它在编译之外没有任何作用。</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;使用的默认比较。</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">这是Julia中保留关键字的列表： &lt;code&gt;baremodule&lt;/code&gt; ， &lt;code&gt;begin&lt;/code&gt; ， &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;continue&lt;/code&gt; ， &lt;code&gt;do&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;elseif&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;export&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;finally&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;function&lt;/code&gt; ， &lt;code&gt;global&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;import&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;local&lt;/code&gt; ， &lt;code&gt;macro&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;quote&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;try&lt;/code&gt; ， &lt;code&gt;using&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 。这些关键字不允许用作变量名。</target>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">这对于更复杂的时间表达式的do-block语法是很有用的。</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">当维度变大时，这是浪费的，因此Julia提供了&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;，它在不使用额外内存的情况下扩展了数组参数中的单例维度以匹配另一个数组中的对应维度，并逐个应用给定的函数：</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">这个迭代器是&amp;ldquo;懒惰的&amp;rdquo;，因为它不会复制该集合以使其反向。请参阅 &lt;code&gt;Base.reverse&lt;/code&gt; 以获取急切的实现。</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">这使事情变得简单,同时允许编译器在所有情况下生成优化的代码。</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">这种控制流可以使某些问题的解决变得更加容易。在某些问题中,所需的各种工作并不是天然地通过函数调用联系在一起的,在需要完成的工作中并没有明显的 &quot;调用者 &quot;或 &quot;被调用者&quot;。一个例子是生产者-消费者问题,一个复杂的过程在生成值,另一个复杂的过程在消耗值。消费者不能简单地调用生产者函数来获取一个值,因为生产者可能有更多的值要生成,所以可能还没有准备好返回。有了任务,生产者和消费者都可以根据自己的需要运行,必要时来回传递值。</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">通过分派对功能行为的这种定义在Julia中非常普遍，甚至是惯用的。方法类型参数不限于用作参数类型：它们可以在函数签名或函数主体中的任何值处使用。这是一个示例，其中方法类型参数 &lt;code&gt;T&lt;/code&gt; 用作方法签名中参数类型 &lt;code&gt;Vector{T}&lt;/code&gt; 的类型参数：</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">这种对变量的操作应谨慎使用,但偶尔也很方便。</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">最后这一点是&lt;em&gt;非常&lt;/em&gt;重要的：即使 &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; ，我们&lt;strong&gt;不要&lt;/strong&gt;有 &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">这利用了 &lt;code&gt;copyto!&lt;/code&gt; 的后备实现！将包装器转换为 &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; 。因此，专注于 &lt;code&gt;DestType&lt;/code&gt; 的优先级低于专注于 &lt;code&gt;DestStyle&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">这将加载模块 &lt;code&gt;Foo&lt;/code&gt; 并定义一个引用该模块的变量 &lt;code&gt;Foo&lt;/code&gt; ，但是不会将任何其他符号从该模块导入当前名称空间。您可以通过 &lt;code&gt;Foo&lt;/code&gt; 符号的合格名称 &lt;code&gt;Foo.bar&lt;/code&gt; 等来引用Foo符号。</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">这个宏可以这样使用。</target>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">此宏采用一个参数： &lt;code&gt;name&lt;/code&gt; 。当 &lt;code&gt;@sayhello&lt;/code&gt; 遇到，所引用的表达&lt;em&gt;扩展&lt;/em&gt;到插值参数到最终表达式的值：</target>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">这使得使用任意对象（这里是 &lt;code&gt;raw&lt;/code&gt; 字符串）作为文档字符串变得容易。</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">这使编写许多基本的整数算法变得很困难，因为许多常用技术都依赖于与溢出相加的机器&lt;em&gt;是&lt;/em&gt;关联的事实。考虑使用表达式 &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; 在Julia中找到整数值 &lt;code&gt;lo&lt;/code&gt; 和 &lt;code&gt;hi&lt;/code&gt; 之间的中点：</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">这使得docstrings的开始和结束更加清晰。</target>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">这使得堆栈跟踪信息可以以编程方式用于日志记录、错误处理等。</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">此清单文件描述了 &lt;code&gt;App&lt;/code&gt; 项目可能的完整依赖关系图：</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">这听起来像是一个奇怪的限制,但请记住,由于C语言不是像Julia那样的动态语言,它的函数只能接受静态已知的、固定签名的参数类型。</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">这意味着调用 &lt;code&gt;f()&lt;/code&gt; 等同于调用 &lt;code&gt;f(1,2)&lt;/code&gt; 。在这种情况下，结果为 &lt;code&gt;5&lt;/code&gt; ，因为 &lt;code&gt;f(1,2)&lt;/code&gt; 调用了上面 &lt;code&gt;f&lt;/code&gt; 的第一个方法。但是，并非总是如此。如果您定义了第四种更适合于整数的方法：</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">这意味着新的 &lt;code&gt;Number&lt;/code&gt; 类型仅需要定义构造函数，因为此定义将为它们处理 &lt;code&gt;convert&lt;/code&gt; 。还提供标识转换以处理参数已为请求的类型的情况：</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">这意味着将&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;舍入为秒，分钟，小时或年的偶数倍（因为ISO 8601规范包括零年）将导致&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;在该字段中具有偶数，而将&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;舍入为偶数。数月将导致月份字段具有奇数值。由于月份和年份都可能包含不规则的天数，因此不确定将天数舍入为偶数天是否会导致天数字段中的偶数。</target>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">这意味着我们还必须定义相应的 &lt;code&gt;similar&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">通过编写&lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; &lt;/a&gt;的方式，该机制可以通过自定义异常类型轻松实现：</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">这种机制也是Julia中类型构造器和闭包(引用其周围环境的内部函数)如何工作的关键。</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">当然，随机数组生成的默认实现会使用此机制（例如 &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）。为了对自定义类型实现这种解耦，可以使用辅助类型。回到我们的 &lt;code&gt;Die&lt;/code&gt; 示例： &lt;code&gt;rand(::Die)&lt;/code&gt; 使用某个范围内的随机生成，因此有机会进行优化：</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">每次调用时，此方法都会创建一个 &lt;code&gt;DateFormat&lt;/code&gt; 对象。如果要解析许多相同格式的日期字符串，请考虑一次创建一个&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象，并将其用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">每次调用时，此方法都会创建一个 &lt;code&gt;DateFormat&lt;/code&gt; 对象。如果要解析许多相同格式的日期时间字符串，请考虑一次创建一个&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象，并将其用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">此方法定义适用于作为&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;实例的任何一对参数。它们不必是同一类型，只要它们都是数字值即可。处理不同数值类型的问题在表达式 &lt;code&gt;2x - y&lt;/code&gt; 委托给算术运算。</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">这个方法从Julia 1.1开始就有了。</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">此方法需要Julia 1.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">这个方法至少需要Julia 1.1的版本。</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">这个方法至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">此方法使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;函数将 &lt;code&gt;x&lt;/code&gt; 显式转换为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;，然后在两个参数均为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;的情况下，将构造委托给常规构造函数。使用此方法定义，以前的&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;现在可以成功创建 &lt;code&gt;Point{Float64}&lt;/code&gt; 类型的点：</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">当以下情况之一为真时,可能值得一试。</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">此模块定义类型 &lt;code&gt;MyType&lt;/code&gt; 和两个函数。函数 &lt;code&gt;foo&lt;/code&gt; 和类型 &lt;code&gt;MyType&lt;/code&gt; 已导出，因此可用于导入其他模块。功能 &lt;code&gt;bar&lt;/code&gt; 是 &lt;code&gt;MyModule&lt;/code&gt; 专用的。</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">当传递的IO流是设置了 &lt;code&gt;:compact&lt;/code&gt; 属性的 &lt;code&gt;IOContext&lt;/code&gt; 对象时，将使用此新的紧凑表示形式。特别是在打印具有多列的数组（水平空间有限）的情况下：</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">这种整数比率的标准化形式是唯一的，因此可以通过检查分子和分母的相等性来测试有理值的相等性。可以使用&lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt;函数来提取有理值的标准化分子和分母：</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">该对象不是线程安全的。有关线程安全版本，请参见&lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">此操作旨在用于线性代数-有关常规数据操作，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;，这是非递归的。</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此操作旨在用于线性代数-有关常规数据操作，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">此运算符遵循IEEE语义的浮点数： &lt;code&gt;0.0 == -0.0&lt;/code&gt; 和 &lt;code&gt;NaN != NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">此输出告诉我们 &lt;code&gt;f&lt;/code&gt; 是具有两个方法的函数对象。要找出这些方法的签名是什么，请使用&lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">这种模式是通过定义一个通用函数来实现的,该函数为函数参数可能所属的每个trait-set计算不同的单子值(或类型)。如果这个函数是纯粹的,那么与普通的调度相比,对性能没有影响。</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">这种模式是如此频繁，以至于有一个名为 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; 的助手类型可用，从而为我们节省了 &lt;code&gt;SamplerDie&lt;/code&gt; 的定义：我们可以通过以下方式实现解耦：</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">在Julia Base的多个地方都使用了这种模式。例如，看到 &lt;code&gt;vcat&lt;/code&gt; 和 &lt;code&gt;hcat&lt;/code&gt; 在&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; &lt;/a&gt;，或&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; &lt;/a&gt;函数，我们可以用它代替编写自己的 &lt;code&gt;fill_twos!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">这会将 &lt;code&gt;echo&lt;/code&gt; 命令的输出通过管道传递到 &lt;code&gt;sort&lt;/code&gt; 命令。当然，这并不是很有趣，因为只有一行可以排序，但是我们当然可以做更多有趣的事情：</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">这将在UNIX系统上打印出最高的五个用户ID。该 &lt;code&gt;cut&lt;/code&gt; ， &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 命令都催生作为当前的直系子弟 &lt;code&gt;julia&lt;/code&gt; 过程，中间没有shell进程。Julia本身负责设置管道和连接文件描述符，这通常是由Shell完成的。由于Julia自己执行此操作，因此它保留了更好的控制能力，并且可以执行Shell无法执行的某些操作。</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">这个项目文件意味着下面的根图,如果它是由Julia字典表示的话。</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">这个量在文献中又被称为鲍尔条件数、相对条件数或分量相对条件数。</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">这个regex启用了前三个标志。</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">这种关系也是不变的。</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">这将返回 &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; ，现在可以将其传递给其他线性代数函数（例如本 &lt;code&gt;Bidiagonal&lt;/code&gt; 解器），这些函数将对Bidiagonal类型使用专门的方法。</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">本节介绍了Julia的Markdown语法,它是由Markdown标准库启用的。支持以下Markdown元素。</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">这似乎是显而易见的,因为这些时期中的每一个时期中的两个时期仍然均匀地划分到下一个更大的顺序时期。但在两个月的情况下(仍然平均分为一年),答案可能令人吃惊。</target>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">这将设置&lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math标志&lt;/a&gt;，并与clang中的 &lt;code&gt;-ffast-math&lt;/code&gt; 选项相对应。有关更多详细信息，请参见&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;性能注释的注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">此设置将导致 &lt;code&gt;MyArray&lt;/code&gt; 上的 &lt;code&gt;eachindex&lt;/code&gt; 迭代使用整数。如果未指定此特征，则使用默认值 &lt;code&gt;IndexCartesian()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">这应该写成:</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">这种情况只可能发生在无效的UTF-8字符串上。对于有效的UTF-8字符串,连接可以保留字符串中的所有字符和字符串长度的加性。</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">少量的升级规则，再加上类型的构造函数和默认的数字 &lt;code&gt;convert&lt;/code&gt; 方法，足以使有理数与Julia的所有其他数字类型（整数，浮点数和复数）完全自然地互操作。通过以相同的方式提供适当的转换方法和升级规则，任何用户定义的数字类型都可以自然地与Julia的预定义数字进行互操作。</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">但是，使用 &lt;code&gt;eval(quote(...))&lt;/code&gt; 模式进行这种语言内代码生成非常普遍，Julia附带了一个宏来缩写该模式：</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">这种代码风格给语言带来了性能挑战。解析器在将其转换为低级指令时，通过将内部函数提取到单独的代码块中，从而实质上重新组织了上述代码。 &amp;ldquo;俘获&amp;rdquo;的变量，如 &lt;code&gt;r&lt;/code&gt; 由内部函数和它们的封闭范围共享也被提取到堆分配的&amp;ldquo;盒子&amp;rdquo;来内外功能访问，因为该语言指定对 &lt;code&gt;r&lt;/code&gt; 在内部范围必须是相同的 &lt;code&gt;r&lt;/code&gt; 即使在外部作用域（或另一个内部函数）修改了 &lt;code&gt;r&lt;/code&gt; 之后，也可以在外部作用域中使用。</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">此样式点与函数参数特别相关。例如，如果参数实际上可以是用抽象类型&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;表示的整数，则不要将其声明为 &lt;code&gt;Int&lt;/code&gt; 或&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;类型。实际上，在很多情况下，除非需要与其他方法定义进行歧义，否则可以完全省略参数类型，因为如果传递的类型不支持任何必需的操作，则无论如何都会抛出&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;。（这被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;鸭子打字&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">此语法与&lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote引用&lt;/a&gt;的内联语法配对。确保也阅读该部分。</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">对于&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions中&lt;/a&gt;引入的简洁的单行函数定义形式，此语法特别有用。尽管很典型，但并不要求 &lt;code&gt;begin&lt;/code&gt; 块必须是多行或 &lt;code&gt;(;)&lt;/code&gt; 链必须是单行：</target>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">由于调用看起来像普通的代码块，因此此语法使使用函数更有效地扩展语言变得更加容易。与&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 相比&lt;/a&gt;，有许多可能的用途，例如管理系统状态。例如，有一个&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;版本，该版本运行代码以确保最终关闭打开的文件：</target>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">该表可能会在第二列中出现缺失的字符,甚至显示与Julia REPL中渲染的字符不一致的字符。在这些情况下,强烈建议用户检查他们在浏览器和 REPL 环境中选择的字体,因为许多字体的字形存在已知的问题。</target>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">这个特质一般用于在预分配特定类型结果的算法和根据产值类型挑选结果类型的算法之间进行选择。</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">这个特性一般用于在为其结果预分配空间的算法和以增量方式调整其结果大小的算法之间进行选择。</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">这种基于特征的方法也存在于标量 &lt;code&gt;+&lt;/code&gt; 的&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;机制中。它使用&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;，在给定两种类型的操作数的情况下，该函数将返回最佳通用类型以计算操作。这样可以减少为每对可能的类型实参对实现每个函数的问题，也可以减少为实现从每种类型到通用类型的转换操作以及首选成对升级规则表的小得多的问题。</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型旨在用于线性代数-有关常规数据处理，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">在人们考虑如何构造它的实例之前，这种类型可能看起来足够无害。如果 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;SelfReferential&lt;/code&gt; 的实例，则可以通过调用创建第二个实例：</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">这通常意味着存在自定义 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;isequal&lt;/code&gt; 方法的类型必须实现相应的 &lt;code&gt;hash&lt;/code&gt; 方法（反之亦然）。集合通常通过对所有内容进行递归调用 &lt;code&gt;isequal&lt;/code&gt; 来实现 &lt;code&gt;isequal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">这将继续在后台跟踪 &lt;code&gt;path&lt;/code&gt; 更改，直到在同一 &lt;code&gt;path&lt;/code&gt; 上调用 &lt;code&gt;unwatch_folder&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">这将在生成的文档中创建指向&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;文档（具有有关此函数实际功能的更多信息）和&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;文档的链接。最好包括对函数的变异/非变异版本的交叉引用，或者突出显示两个相似函数之间的差异。</target>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">这将返回 &lt;code&gt;(-1, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">这将会触犯一个供给默认padding的方法。</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">这通常是 &lt;code&gt;gitdir(repo)&lt;/code&gt; 的父目录，但在某些情况下可能会有所不同：例如，如果设置了 &lt;code&gt;core.worktree&lt;/code&gt; 配置变量或 &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">此作品，但（你可以使用验证自己 &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; 的问题是，输出类型不能被推断）：参数 &lt;code&gt;N&lt;/code&gt; 是一个&lt;em&gt;价值&lt;/em&gt;型的 &lt;code&gt;Int&lt;/code&gt; ，和类型推断不会（和无法）预先预测其价值。这意味着使用该函数输出的代码必须是保守的，检查 &lt;code&gt;A&lt;/code&gt; 每次访问的类型；这样的代码将非常慢。</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">这将提供具有特定新元素类型的矢量的自定义显示。进行诱人时，应避免这种情况。问题在于用户会期望诸如 &lt;code&gt;Vector()&lt;/code&gt; 之类的知名类型以某种方式运行，而过度自定义其行为会使其更难使用。</target>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">尽管大多数代码都可以用Julia编写，但是已经有很多高质量的，成熟的数字计算库已经用C和Fortran编写。为了轻松使用此现有代码，Julia使调用C和Fortran函数变得简单高效。 Julia具有&amp;ldquo;没有样板&amp;rdquo;的理念：可以直接从Julia调用函数，而无需任何&amp;ldquo;胶合&amp;rdquo;代码，代码生成或编译-甚至从交互式提示中也可以。只需使用&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;语法进行适当的调用即可完成，这看起来像是普通的函数调用。</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">思想气球</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">三个连续的等号</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">三维角度</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">三个向左箭头</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">三个向右箭头</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">除非 &lt;code&gt;x isa type&lt;/code&gt; ,否则抛出&lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。语法 &lt;code&gt;x::type&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">如果 &lt;code&gt;cond&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则抛出&lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;。编写断言的首选语法。断言失败时可以选择显示消息 &lt;code&gt;text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果指定索引 &lt;code&gt;I&lt;/code&gt; 不在给定数组 &lt;code&gt;A&lt;/code&gt; 的范围内，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">抛出一个对象作为异常。</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">抛出一个对象而不更改当前的异常回溯。默认参数是当前异常（如果在 &lt;code&gt;catch&lt;/code&gt; 块中调用）。</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">抛出Julia异常</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">拇指向下的标志</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">竖起大拇指签名</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">因此，&lt;em&gt;词法作用域&lt;/em&gt;意味着可以仅从源代码推断变量的范围。</target>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">因此全局变量只继承读,不继承写。</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">因此，程序应谨慎地在远程调用中引用全局变量。实际上，如果可能的话，最好完全避免使用它们。如果必须引用全局变量，请考虑使用 &lt;code&gt;let&lt;/code&gt; 块来本地化全局变量。</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">因此,一个最小的集群管理器需要。</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">因此，执行&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的任务有效地阻止了Julia调度程序执行任何其他任务，直到调用返回。对于所有对外部库的调用都是如此。例外情况是对自定义C代码的调用，这些代码又返回Julia（可能会产生yield），或者是调用 &lt;code&gt;jl_yield()&lt;/code&gt; 的 C代码（等效于&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; 的&lt;/a&gt; C ）。</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">因此,抽象类型允许程序员编写通用函数,这些函数以后可以被许多具体类型的组合用作默认方法。由于多调度,程序员可以完全控制是使用默认方法还是更具体的方法。</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">因此，尽管 &lt;code&gt;⊘&lt;/code&gt; 运算符通常返回OurRational的实例， &lt;code&gt;OurRational&lt;/code&gt; 如果其两个参数中的任何一个都是复数整数，它都会返回 &lt;code&gt;Complex{OurRational}&lt;/code&gt; 的实例。有兴趣的读者应该考虑细读&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;的其余部分：它简短，自包含，并且实现了整个基本的Julia类型。</target>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">因此，具有Julia整数的算术实际上是&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;模数算术的&lt;/a&gt;一种形式。这反映了在现代计算机上实现的整数基础算法的特征。在可能发生溢出的应用中，显式检查溢出产生的环绕是必不可少的。否则，建议改用&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;任意精度算法中&lt;/a&gt;的&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">因此，解析器不知道 &lt;code&gt;r&lt;/code&gt; 具有固定类型（ &lt;code&gt;Int&lt;/code&gt; ）。也不是说 &lt;code&gt;r&lt;/code&gt; 一旦创建内部函数不改变值（使得盒是不需要的）。因此，解析器为box发出代码，该代码包含具有抽象类型（例如 &lt;code&gt;Any&lt;/code&gt; )的对象，该对象需要为 &lt;code&gt;r&lt;/code&gt; 的每次出现进行运行时类型分配。可以通过将 &lt;code&gt;@code_warntype&lt;/code&gt; 应用于上述函数来验证这一点。装箱和运行时类型分派都可能导致性能下降。</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">因此，在可能的情况下，请使用 &lt;code&gt;Int&lt;/code&gt; 文字，并将 &lt;code&gt;Rational{Int}&lt;/code&gt; 用于文字非整数数字，以便更轻松地使用代码。</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">因此,虽然Julia中默认提供的隐式类型参数构造器相当严格,但可以很容易地让它们以更轻松但合理的方式表现出来。此外,由于构造函数可以利用类型系统、方法和多重调度的所有力量,因此定义复杂的行为通常是相当简单的。</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">虎头蛇尾</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">Tilde操作员</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">向左箭头上方的倾斜操作员</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">倾斜式操作员,上面有圆点</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">倾斜的操作员与上升的圆点</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">签名时间。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">时间类型-周期算术</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">计时结果。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">疲惫的脸</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">要访问编码的原始代码单位（用于UTF-8的字节），可以使用&lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt;函数，其中索引 &lt;code&gt;i&lt;/code&gt; 从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ncodeunits(s)&lt;/code&gt; 连续运行。所述&lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt;函数返回一个 &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; 包装，可以访问这些原始CODEUNITS（字节）为一个数组。</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">要添加软件包，请使用 &lt;code&gt;add&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">为了允许使用任意精度的整数和浮点数进行计算，Julia分别包装了&lt;a href=&quot;https://gmplib.org&quot;&gt;GNU多精度算术库（GMP）&lt;/a&gt;和&lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR库&lt;/a&gt;。该&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 有&lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;类型在朱莉娅可供任意精度的整数和分别浮点数。</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">为了允许创建未完全初始化的对象，Julia允许使用少于类型具有的字段数的&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;函数来调用新函数，并返回未初始化未指定字段的对象。然后，内部构造函数方法可以使用不完整的对象，在返回之前完成其初始化。例如，这是定义 &lt;code&gt;SelfReferential&lt;/code&gt; 类型的另一种尝试，这次使用零参数内部构造函数返回实例，该实例具有指向自己的 &lt;code&gt;obj&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">再放大一点,考虑以下函数。</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">为了避免甚至不必定义命名函数，可以使用 &lt;code&gt;do&lt;/code&gt; 语法，该语法可以动态创建一个匿名函数：</target>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要检查正则表达式是否与字符串匹配，请使用&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">要在第一维（&amp;ldquo;垂直&amp;rdquo;）中进行连接，请使用&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt;或以分号（ &lt;code&gt;[x; y; z]&lt;/code&gt; ）分隔。</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">要连接第二个（&amp;ldquo;水平&amp;rdquo;）维，请使用&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt;或以空格分隔（ &lt;code&gt;[x y z]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">要构造块矩阵（在前两个维度中串联），请使用&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt;或组合空格和分号（ &lt;code&gt;[a b; c d]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">要使用多种方法定义一个函数，只需简单地多次定义函数，并使用不同数量和类型的参数即可。函数的第一个方法定义创建函数对象，随后的方法定义将新方法添加到现有函数对象。应用该函数时，将执行与参数的数量和类型匹配的最具体的方法定义。因此，以上两个方法定义共同定义了抽象类型 &lt;code&gt;Number&lt;/code&gt; 的所有实例对上 &lt;code&gt;f&lt;/code&gt; 的行为-但具有特定于&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值对的不同行为。如果参数之一是64位浮点数，而另一个不是，则 &lt;code&gt;f(Float64,Float64)&lt;/code&gt; 无法调用该方法，必须使用更通用的 &lt;code&gt;f(Number,Number)&lt;/code&gt; 方法：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
