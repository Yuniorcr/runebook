<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">对于指针数组来说,直接更新其数据时,也需要设置写入障碍。例如:</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 或 &lt;code&gt;DateTime&lt;/code&gt; 的年份为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">然后，如果环境变量 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 设置为 &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; ，则可以执行输出 &lt;code&gt;test&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="4e05fcf9067a3ef56f500e5010a1c790b20af02a" translate="yes" xml:space="preserve">
          <source>Then if you call &lt;code&gt;Hinter.only_int&lt;/code&gt; on something that isn't an &lt;code&gt;Int&lt;/code&gt; (thereby triggering a &lt;code&gt;MethodError&lt;/code&gt;), it issues the hint:</source>
          <target state="translated">然后，如果您在不是 &lt;code&gt;Int&lt;/code&gt; 的 &lt;code&gt;Hinter.only_int&lt;/code&gt; 上调用Hinter.only_int（从而触发 &lt;code&gt;MethodError&lt;/code&gt; ），它将发出提示：</target>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">然后导航到包含您的测试文件的目录（此处假定为 &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; ）并执行以下操作：</target>
        </trans-unit>
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">然后，内部方法 &lt;code&gt;_fA&lt;/code&gt; 和 &lt;code&gt;_fB&lt;/code&gt; 可以在 &lt;code&gt;y&lt;/code&gt; 上分派，而不必担心相对于 &lt;code&gt;x&lt;/code&gt; 的歧义。</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">然后,将项目中的main()函数替换成这段代码。</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">不存在</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">存在</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">还有一个宏&lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt;，它可能比 &lt;code&gt;macroexpand&lt;/code&gt; 函数更方便：</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">我们可以扩展更多的方法来为Julia提供有关此可迭代集合的更多信息。我们知道 &lt;code&gt;Squares&lt;/code&gt; 序列中的元素将始终为 &lt;code&gt;Int&lt;/code&gt; 。通过扩展&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;方法，我们可以将该信息提供给Julia，并帮助它在更复杂的方法中编写更专业的代码。我们还知道序列中元素的数量，因此我们也可以扩展&lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">关于茱莉亚的手串,有几个值得注意的高级功能。</target>
        </trans-unit>
        <trans-unit id="34b3b70591c85cc9c9daac918201c51d400becd5" translate="yes" xml:space="preserve">
          <source>There are a few specific limitations and warnings to be aware of when using threads in Julia:</source>
          <target state="translated">在Julia中使用线程时,有一些特定的限制和警告需要注意。</target>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">交互式工作有许多独特的有用功能。除了显示结果之外，REPL还将结果绑定到变量 &lt;code&gt;ans&lt;/code&gt; 。行尾的分号可以用作禁止显示结果的标志。</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">还有两个带有 &lt;code&gt;mime&lt;/code&gt; 参数的变体（MIME类型字符串，例如 &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; ），它们尝试&lt;em&gt;仅&lt;/em&gt;使用请求的MIME类型显示 &lt;code&gt;x&lt;/code&gt; ，如果两个display（）都不支持此类型，则抛出 &lt;code&gt;MethodError&lt;/code&gt; 。 s）或 &lt;code&gt;x&lt;/code&gt; 。使用这些变体，还可以通过传递 &lt;code&gt;x::AbstractString&lt;/code&gt; （适用于具有基于文本的存储的MIME类型，例如text / html或application / postscript）或 &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; （用于二进制MIME类型）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">目前在基础Julia中有四种排序算法。</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; 和&lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt;之间有区别。</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">构造函数与 &lt;code&gt;convert&lt;/code&gt; 不同的一般情况有四种：</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">您可以对程序进行更多有趣的测量，要获取全面的列表，请阅读&lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux性能示例页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d680424432e24c9faadefbc8f1cb532ede6d65ad" translate="yes" xml:space="preserve">
          <source>There are no classes in Julia. Instead they are structures (mutable or immutable), containing data but no methods.</source>
          <target state="translated">Julia中没有类。相反,它们是结构(可变或不可变),包含数据但没有方法。</target>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">当然也有一些例外。例如，在&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 中&lt;/a&gt;，类型应始终排在第一位。在&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;，该值位于索引之前，因此可以将这些索引提供为varargs。</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">有几种不同的方式来考虑这个迭代器包装器。</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">有几个特殊的类型需要注意,因为没有其他类型可以被定义为同样的行为。</target>
        </trans-unit>
        <trans-unit id="9288c1a0f0901c4cadcdfe9e40efa95dc47fcf27" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">在某些情况下，您想构造一个字符串或使用字符串语义，但是标准字符串构造的行为并不是所需要的。对于此类情况，Julia提供了&lt;a href=&quot;#non-standard-string-literals&quot;&gt;非标准的字符串文字&lt;/a&gt;。非标准字符串文字看起来像常规的双引号字符串文字，但是会立即加上一个标识符作为前缀，并且其行为与普通的字符串文字并不完全相同。如下所述，正则表达式，字节数组文字和版本号文字是非标准字符串文字的一些示例。&lt;a href=&quot;../metaprogramming/index#Metaprogramming&quot;&gt;元编程&lt;/a&gt;部分中提供了其他示例。</target>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">在某些情况下，您想构造一个字符串或使用字符串语义，但是标准字符串构造的行为并不是所需要的。对于这种情况，Julia提供了&lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;非标准的字符串文字&lt;/a&gt;。非标准字符串文字看起来像常规的双引号字符串文字，但是会立即加上一个标识符作为前缀，并且其行为与普通的字符串文字并不完全相同。如下所述，正则表达式，字节数组文字和版本号文字是非标准字符串文字的一些示例。&lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;元编程&lt;/a&gt;部分中提供了其他示例。</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">在某些情况下，类型参数在所有可能的类型上自由范围可能没有意义。在这种情况下，可以像这样限制 &lt;code&gt;T&lt;/code&gt; 的范围：</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">有一些功能可以控制GC。在正常使用情况下,这些功能应该是不必要的。</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">有一些键允许自动生成的日志数据被覆盖。</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">有三个重要的标准模块。</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">该库提供了三种记录器类型。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;是启动REPL时看到的默认记录器。它以可读的文本格式显示事件，并尝试对格式和过滤进行简单但用户友好的控制。&lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;是在必要时删除所有消息的便捷方法。它是&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;流的日志记录等效项。&lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;是一种非常简单的文本格式记录器，主要用于调试日志记录系统本身。</target>
        </trans-unit>
        <trans-unit id="5e690eabf31525aac327d09327076212853ab17f" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Logging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Logging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">该库提供了三种记录器类型。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;是启动REPL时看到的默认记录器。它以可读的文本格式显示事件，并尝试对格式和过滤进行简单但友好的控制。&lt;a href=&quot;#Logging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;是在必要时删除所有消息的便捷方法。它是&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;流的日志记录等效项。&lt;a href=&quot;#Logging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;是一种非常简单的文本格式记录器，主要用于调试日志记录系统本身。</target>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">此函数有三个可能的返回点，取决于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值，返回三个不同表达式的值。由于最后一行是最后一个表达式，因此可以省略最后一行的 &lt;code&gt;return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">有三个指定的标准浮点值,它们不对应实数线上的任何一点。</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">有两类：从类型（例如 &lt;code&gt;rand(Int)&lt;/code&gt; ）或集合（例如 &lt;code&gt;rand(1:3)&lt;/code&gt; ）生成值。首先说明简单的情况，然后介绍更高级的用法。我们在这里假设算法的选择与RNG无关，因此我们在签名中使用 &lt;code&gt;AbstractRNG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">有两种重复计算表达式的构造： &lt;code&gt;while&lt;/code&gt; 循环和 &lt;code&gt;for&lt;/code&gt; 循环。这是一个 &lt;code&gt;while&lt;/code&gt; 循环的示例：</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">应用程序使用两种不同的名为 &lt;code&gt;Priv&lt;/code&gt; 的软件包。它使用私有包（它是根依赖项）和公共包（这是通过 &lt;code&gt;Pub&lt;/code&gt; 的间接依赖项）。这些通过各自不同的UUID进行区分，并且具有不同的dep：</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">扩展 &lt;code&gt;Random&lt;/code&gt; 功能的方法主要有两种：</target>
        </trans-unit>
        <trans-unit id="d2e30fededfc9e0acc9aec32cc305e4b3edfd71f" translate="yes" xml:space="preserve">
          <source>There are two possible shortened forms for the &lt;code&gt;return nothing&lt;/code&gt; expression. On the one hand, the &lt;code&gt;return&lt;/code&gt; keyword implicitly returns &lt;code&gt;nothing&lt;/code&gt;, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, &lt;code&gt;nothing&lt;/code&gt; can be used alone when it's the last expression. The preference for the expression &lt;code&gt;return nothing&lt;/code&gt; as opposed to &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; alone is a matter of coding style.</source>
          <target state="translated">对于 &lt;code&gt;return nothing&lt;/code&gt; 表达式，有两种可能的简化形式。一方面， &lt;code&gt;return&lt;/code&gt; 关键字隐式不返回 &lt;code&gt;nothing&lt;/code&gt; ，因此可以单独使用。在另一方面，由于功能含蓄地返回自己的最后一个表达式， &lt;code&gt;nothing&lt;/code&gt; 时候是最后一个表达式可以单独使用。为表达偏好 &lt;code&gt;return nothing&lt;/code&gt; ，而不是 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;nothing&lt;/code&gt; 单独的编码风格的问题。</target>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">有多种运行Julia代码和提供选项的方式，类似于可用于 &lt;code&gt;perl&lt;/code&gt; 和 &lt;code&gt;ruby&lt;/code&gt; 程序的方式：</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">不存在循环携带的内存依赖性</target>
        </trans-unit>
        <trans-unit id="167978b2ab5201a534fdd8a54c05583e0811193a" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../base/collections/index#Base.Pair&quot;&gt;&lt;code&gt;Pair&lt;/code&gt;&lt;/a&gt; type, but it is not meant to be used as a &lt;code&gt;COMMON-LISP:CONS&lt;/code&gt;. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). &lt;code&gt;Tuple&lt;/code&gt;s are the closest to Common Lisp lists for &lt;em&gt;short&lt;/em&gt; collections of heterogeneous elements. Use &lt;code&gt;NamedTuple&lt;/code&gt;s in place of alists. For larger collections of homogeneous types, &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Dict&lt;/code&gt;s should be used.</source>
          <target state="translated">有一个&lt;a href=&quot;../../base/collections/index#Base.Pair&quot;&gt; &lt;code&gt;Pair&lt;/code&gt; &lt;/a&gt;类型，但它不打算用作 &lt;code&gt;COMMON-LISP:CONS&lt;/code&gt; 。各种可迭代集合可在语言的大多数部分（例如，splatting，tuple等）互换使用。对于异类元素的&lt;em&gt;简短&lt;/em&gt;集合， &lt;code&gt;Tuple&lt;/code&gt; 最接近Common Lisp列表。使用 &lt;code&gt;NamedTuple&lt;/code&gt; 代替列表。对于更大的同类类型集合，应使用 &lt;code&gt;Array&lt;/code&gt; 和 &lt;code&gt;Dict&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">有一种方便的语法来命名这类类型,类似于函数定义语法的简式。</target>
        </trans-unit>
        <trans-unit id="c4273d4f01461968327256a1b4317f5663291a1c" translate="yes" xml:space="preserve">
          <source>There is a global named &lt;code&gt;s&lt;/code&gt;, so &lt;code&gt;s = t&lt;/code&gt; assigns to it.</source>
          <target state="translated">有一个名为 &lt;code&gt;s&lt;/code&gt; 的全局变量，因此 &lt;code&gt;s = t&lt;/code&gt; 为其分配。</target>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">引用第二种语法形式是对多个表达式进行引用： &lt;code&gt;quote ... end&lt;/code&gt; 包含的代码块。</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">在Julia中定义函数有第二种更简洁的语法。上面演示的传统函数声明语法相当于下面的紧凑 &quot;赋值形式&quot;。</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">这里必须提到一种特殊的抽象参数类型：单例类型。对于每种类型的， &lt;code&gt;T&lt;/code&gt; 中，&amp;ldquo;单型&amp;rdquo; &lt;code&gt;Type{T}&lt;/code&gt; 是一个抽象的类型，其仅是实例对象 &lt;code&gt;T&lt;/code&gt; 。由于定义有点难以解析，因此让我们看一些示例：</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">还有一个&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;函数和一个更通用的&lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt;函数，该函数返回将 &lt;code&gt;y&lt;/code&gt; 转换为 &lt;code&gt;x&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">嵌套 &lt;code&gt;where&lt;/code&gt; 表达式也有一种简洁的语法。例如，这：</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">还有一种方法 &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; 对流 &lt;code&gt;io&lt;/code&gt; 的 &lt;code&gt;nb&lt;/code&gt; 个字节进行校验和，或者使用 &lt;code&gt;crc32c(io, crc)&lt;/code&gt; 对所有剩余字节进行校验和。因此，您可以执行&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt;校验和整个文件，或执行 &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; 校验&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;而不调用 &lt;code&gt;take!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="923a006c576c90e740ad341ee467086ea5813910" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">关于如何创建复合类型的实例还有更多的话要说，但是这种讨论既取决于&lt;a href=&quot;#Parametric-Types&quot;&gt;参数类型&lt;/a&gt;也取决于&lt;a href=&quot;../methods/index#Methods&quot;&gt;方法&lt;/a&gt;，并且非常重要，因此可以在其自己的章节：&lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;构造函数中进行讨论&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">关于如何创建复合类型的实例还有更多的话要说，但是这种讨论既取决于&lt;a href=&quot;#Parametric-Types-1&quot;&gt;参数类型&lt;/a&gt;也取决于&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;，并且非常重要，因此可以在其自己的章节：&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;构造函数中解决&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">在对象值和非对象值之间没有划分:在Julia中,所有的值都是真正的对象,其类型属于一个单一的、完全连接的类型图,所有的节点都同样是类型的一级。</target>
        </trans-unit>
        <trans-unit id="d4c6baab6e4cf883e88c1aedd0d9bd2aa047689e" translate="yes" xml:space="preserve">
          <source>There is no global named &lt;code&gt;t&lt;/code&gt;, so &lt;code&gt;t = s + i&lt;/code&gt; creates a new &lt;code&gt;t&lt;/code&gt; that is local to the &lt;code&gt;for&lt;/code&gt; loop;</source>
          <target state="translated">没有全局名为 &lt;code&gt;t&lt;/code&gt; 的全局变量，因此 &lt;code&gt;t = s + i&lt;/code&gt; 创建一个新的 &lt;code&gt;for&lt;/code&gt; 循环本地的 &lt;code&gt;t&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">在Julia中没有无效的（NULL） &lt;code&gt;Ref&lt;/code&gt; ，但是 &lt;code&gt;Ptr&lt;/code&gt; 的 &lt;code&gt;C_NULL&lt;/code&gt; 实例可以传递给 &lt;code&gt;ccall&lt;/code&gt; Ref参数。</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">没有一个有意义的 &quot;编译时类型 &quot;的概念:一个值的唯一类型是它在程序运行时的实际类型。在面向对象的语言中,这被称为 &quot;运行时类型&quot;,静态编译与多态性的结合使这种区别变得重要。</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的实现仅此而已。Julia的标准库中的某些函数接受 &lt;code&gt;Val&lt;/code&gt; 实例作为参数，您也可以使用它编写自己的函数。例如：</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">还有一个额外的特殊调用约定&lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt;，它允许直接插入对LLVM内部函数的调用。在针对不常见的平台（例如GPGPU）时，这尤其有用。例如，对于&lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;，我们需要能够读取线程索引：</target>
        </trans-unit>
        <trans-unit id="15a160baa2fcd00f2095be3f6987dc4bfa73177f" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;https://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">还有一个额外的特殊调用约定&lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt;，它允许直接插入对LLVM内部函数的调用。当针对不常见的平台（例如GPGPU）时，这尤其有用。例如，对于&lt;a href=&quot;https://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;，我们需要能够读取线程索引：</target>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">只有一个区别，表面上（语法上）似乎很小。之间的区别 &lt;code&gt;using&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 的是，与 &lt;code&gt;using&lt;/code&gt; 你需要说 &lt;code&gt;function Foo.bar(..&lt;/code&gt; 用一种新的方法扩展模块Foo的功能栏，但与 &lt;code&gt;import Foo.bar&lt;/code&gt; ，你只需要说 &lt;code&gt;function bar(...&lt;/code&gt; 并自动扩展模块Foo的功能栏。</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">这些规则之间有些重叠，因为前两个规则都覆盖了 &lt;code&gt;\x&lt;/code&gt; 和小于0x80（128）的八进制转义符的行为，但是在这里这些规则是一致的。这些规则一起使人们可以轻松地使用ASCII字符，任意字节值和UTF-8序列来生成字节数组。这是使用这三个示例的示例：</target>
        </trans-unit>
        <trans-unit id="9a0371b0510547518bd685c0ced89d4cf0d5a48b" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">实际 &lt;code&gt;@assert&lt;/code&gt; 宏还会处理另一种情况：如果除了打印&amp;ldquo; a应该等于b&amp;rdquo;之外，我们还想打印其值怎么办？可能会天真地尝试在自定义消息中使用字符串插值，例如， &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; ，但这无法与上述宏一起正常工作。你知道为什么吗？从&lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;字符串插值&lt;/a&gt;中回想起，将插值的字符串重写为对&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;的调用。比较：</target>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">实际 &lt;code&gt;@assert&lt;/code&gt; 宏还会处理另一种情况：如果除了打印&amp;ldquo; a应该等于b&amp;rdquo;之外，我们还想打印其值怎么办？可能会天真地尝试在自定义消息中使用字符串插值，例如， &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; ，但这无法与上述宏一起正常工作。你知道为什么吗？从&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;字符串插值&lt;/a&gt;中回想起，将插值的字符串重写为对&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;的调用。比较：</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">还有一些具有传统意义的键值对。</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">因此，如果 &lt;code&gt;Array&lt;/code&gt; 包含错误格式的数据，则必须使用诸如 &lt;code&gt;trunc(Int32, a)&lt;/code&gt; 类的调用将其显式转换。</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">这些都是单参数函数， &lt;code&gt;atan&lt;/code&gt; 还接受与传统&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;函数相对应的两个参数。</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">这些都是一些小的点,可能会对紧密的内循环有所帮助。</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">这些是标准的系统mutexes,用于锁定逻辑的关键部分。</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">这些构件用于创建常规同步对象。</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">可以将它们混合&lt;strong&gt;在一起&lt;/strong&gt;以创建&lt;strong&gt;一个堆叠的环境&lt;/strong&gt;：一组有序的项目环境和软件包目录，它们叠加&lt;strong&gt;在一起&lt;/strong&gt;构成一个单一的复合环境。然后，优先级和可见性规则组合在一起，以确定哪些软件包可用以及从何处加载它们。例如，茱莉亚（Julia）的装载路径形成了一个堆叠的环境。</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">这些环境各有不同的作用。</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">仅当Julia是使用垃圾回收调试进行编译时（即，如果在构建配置中 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 时)，这些环境变量才有效。</target>
        </trans-unit>
        <trans-unit id="8da007debd6546e5bcd6fdc6a81faf692113b0dd" translate="yes" xml:space="preserve">
          <source>These events are disabled by default.</source>
          <target state="translated">这些事件默认为禁用。</target>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">这些示例有望有助于说明生成的函数在定义端和调用站点如何工作。但是，由于以下原因，&lt;em&gt;请勿复制它们&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="aa722e52b03e87753d276a993e9d5484f0d06210" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">这些函数在&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;数值比较&lt;/a&gt;中很有用，可避免不必要的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;类型转换带来的&lt;/a&gt;开销。</target>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">这些函数在&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数值比较&lt;/a&gt;中很有用，可避免不必要的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;类型转换带来的&lt;/a&gt;开销。</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">这些方法定义表明，在没有用于对数字值进行加，减，乘和除的更具体规则的情况下，将这些值提升为通用类型，然后重试。这就是全部内容：无需再担心升级为用于算术运算的通用数字类型了-它会自动发生。还有的涵盖所有在许多其他的算术和数学函数的推广方法定义&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt;，但除此之外，很难有任何呼叫 &lt;code&gt;promote&lt;/code&gt; 要求朱莉娅基地。 &lt;code&gt;promote&lt;/code&gt; 的最常见用法为方便起见，在外部构造函数方法中会发生这种情况，以允许具有混合类型的构造函数调用委派给内部类型，并将字段提升为适当的公共类型。例如，回想一下&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;提供了以下外部构造方法：</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">通过在&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 中&lt;/a&gt;列出的项目环境中搜索项目文件（ &lt;code&gt;Project.toml&lt;/code&gt; 或 &lt;code&gt;JuliaProject.toml&lt;/code&gt; ），清单文件（ &lt;code&gt;Manifest.toml&lt;/code&gt; 或 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ）或源文件的文件夹来回答这些问题。</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">这些规则表明，将 &lt;code&gt;SparseVecStyle&lt;/code&gt; 与0或1维数组结合使用会产生另一个 &lt;code&gt;SparseVecStyle&lt;/code&gt; ，将其与2维数组结合使用会产生 &lt;code&gt;SparseMatStyle&lt;/code&gt; ，而任何更高维度的对象都将退回到密集的任意维度框架中。这些规则允许广播保留操作的稀疏表示，以产生一维或二维输出，但为任何其他维生成一个 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">这些值分别为 &lt;code&gt;2.0^-23&lt;/code&gt; 和 &lt;code&gt;2.0^-52&lt;/code&gt; ，分别为&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值。的&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;功能也可以采取一个浮点值作为参数，并给出该值和下一个可表示浮点值之间的绝对差。也就是说， &lt;code&gt;eps(x)&lt;/code&gt; 产生与 &lt;code&gt;x&lt;/code&gt; 相同类型的值，使得 &lt;code&gt;x + eps(x)&lt;/code&gt; 是下一个可表示的大于 &lt;code&gt;x&lt;/code&gt; 的浮点值：</target>
        </trans-unit>
        <trans-unit id="b3b947ad0ffcb0e9ad54a5598ed57c34a7f7c5d4" translate="yes" xml:space="preserve">
          <source>These will not specialize:</source>
          <target state="translated">这些不会专门。</target>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">它们是明文规定的。</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">他们已经明确声明了超级类型。</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">他们有名字。</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">它们可能有参数。</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">稀薄空间</target>
        </trans-unit>
        <trans-unit id="b917e561d5e2ee00e3622e65889d344d78e37e20" translate="yes" xml:space="preserve">
          <source>Think of it as an alternative to using &lt;code&gt;println&lt;/code&gt; directly.</source>
          <target state="translated">可以将其视为直接使用 &lt;code&gt;println&lt;/code&gt; 的替代方法。</target>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">这种 &quot;声明 &quot;行为只发生在特定的语境中。</target>
        </trans-unit>
        <trans-unit id="41a800e609852a7906e603a30a74797aa896d16f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;errno&lt;/code&gt; symbol may not be found in a library named &quot;libc&quot;, as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the &lt;code&gt;errno&lt;/code&gt; symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.</source>
          <target state="translated">在名为&amp;ldquo; libc&amp;rdquo;的库中可能找不到此 &lt;code&gt;errno&lt;/code&gt; 符号，因为这是系统编译器的实现细节。通常，仅应按名称访问标准库符号，从而允许编译器填写正确的符号。而且，此示例中显示的 &lt;code&gt;errno&lt;/code&gt; 符号在大多数编译器中都是特殊的，因此此处看到的值可能不是您期望或想要的值。在任何具有多线程功能的系统上用C编译等效代码通常会实际上调用一个不同的函数（通过宏预处理器重载），并且给出的结果可能不同于此处打印的旧值。</target>
        </trans-unit>
        <trans-unit id="6e55b956134479b369056b6e59411296357349dc" translate="yes" xml:space="preserve">
          <source>This addresses both issues while preserving the &quot;programming at scale&quot; benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don't have any issues; any time someone either forgets a &lt;code&gt;global&lt;/code&gt; annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.</source>
          <target state="translated">这既解决了这两个问题，又保留了1.0行为的&amp;ldquo;按比例编程&amp;rdquo;的好处：全局变量对可能遥远的代码的含义没有怪异的影响；在REPL复制粘贴调试工作中，初学者没有任何问题；每当有人忘记 &lt;code&gt;global&lt;/code&gt; 注释或在软范围内用局部变量意外遮盖现有全局变量时（无论如何都会造成混淆），他们会收到一个很好的明确警告。</target>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">这样先把数字相加,再找出结果的平方根。</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">这允许 &lt;code&gt;a&lt;/code&gt; 为任何类型。这通常是有用的，但它确实有一个缺点：对于 &lt;code&gt;MyAmbiguousType&lt;/code&gt; 类型的对象，编译器将无法生成高性能代码。原因是编译器使用对象的类型而不是它们的值来确定如何构建代码。不幸的是，关于 &lt;code&gt;MyAmbiguousType&lt;/code&gt; 类型的对象的推断很少：</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">这使得类型断言可以就地附加到任何表达式上。</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">这样就可以进行下面这样的调用。</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">这允许对索引进行操作的函数与 &lt;code&gt;skipmissing&lt;/code&gt; 结合使用。搜索和查找功能尤其如此，它们返回对通过 &lt;code&gt;skipmissing&lt;/code&gt; 返回的对象有效的索引，这些索引&lt;em&gt;也是父数组中&lt;/em&gt;匹配项的索引&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">这种方法非常有效：编译器可以确定 &lt;code&gt;A&lt;/code&gt; 是一个 &lt;code&gt;Array{Float64,2}&lt;/code&gt; 因为它知道填充值的类型（ &lt;code&gt;5.0::Float64&lt;/code&gt; ）和维数（ &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; ）。这意味着编译器可以为将来在同一函数中使用 &lt;code&gt;A&lt;/code&gt; 生成非常有效的代码。</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">这个参数将在编译时,即定义包含方法时被评估。</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">这避免了需要连续检查 &lt;code&gt;null&lt;/code&gt; 值的需要。但是，并非所有对象字段都是引用。 Julia认为某些类型是&amp;ldquo;普通数据&amp;rdquo;，这意味着它们的所有数据都是自包含的，不引用其他对象。普通数据类型由基本类型（例如 &lt;code&gt;Int&lt;/code&gt; ）和其他普通数据类型的不可变结构组成。普通数据类型的初始内容是不确定的：</target>
        </trans-unit>
        <trans-unit id="ce41dd9c15eebc75ffb2137b16913cc2ba4e006d" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">此行为是类型稳定性要求的不便后果。对于 &lt;code&gt;sqrt&lt;/code&gt; ，大多数用户希望 &lt;code&gt;sqrt(2.0)&lt;/code&gt; 给出一个实数，如果生成的复数为 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 这将是不满意的。只有传递负数（这是 &lt;code&gt;sqrt&lt;/code&gt; 在某些其他语言中的用法）时，才可以编写 &lt;code&gt;sqrt&lt;/code&gt; 函数以切换到复数值输出，但是结果将不会是&lt;a href=&quot;#man-type-stability&quot;&gt;类型稳定的&lt;/a&gt;，并且 &lt;code&gt;sqrt&lt;/code&gt; 函数的性能会很差。</target>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">此行为是类型稳定性要求的不便后果。对于 &lt;code&gt;sqrt&lt;/code&gt; ，大多数用户都希望 &lt;code&gt;sqrt(2.0)&lt;/code&gt; 给出一个实数，如果生成的复数为 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 这将是不满意的。只有传递负数（这是 &lt;code&gt;sqrt&lt;/code&gt; 在某些其他语言中所做的事情）时，才可以编写 &lt;code&gt;sqrt&lt;/code&gt; 函数以切换到复数值输出，但是结果将不会是&lt;a href=&quot;#man-type-stability-1&quot;&gt;类型稳定的&lt;/a&gt;，并且 &lt;code&gt;sqrt&lt;/code&gt; 函数的性能会很差。</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">这种行为是基于这样的观察,即当我们使用无符号十六进制字元来表示整数值时,通常是用它们来表示一个固定的数字字节序列,而不仅仅是一个整数值。</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">在Julia中经常使用此行为，以替代非常短的 &lt;code&gt;if&lt;/code&gt; 语句。代替写 &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; ，可以编写 &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; （可以读为：&amp;lt;cond&amp;gt; &lt;em&gt;然后是&lt;/em&gt; &amp;lt;statement&amp;gt;）。同样，代替 &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; ，可以写 &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; （可以读取为：&amp;lt;cond&amp;gt; &lt;em&gt;或&lt;/em&gt; &amp;lt;statement&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">对于普通变量来说，这种行为似乎有些奇怪，但是允许在命名函数使用之前就使用命名函数，这些函数只是保存函数对象的普通变量。这允许以直观且方便的顺序定义函数，而不是强制自下而上排序或要求向前声明，只要它们在实际调用时定义即可。例如，这是一种无效的，相互递归的方法来测试正整数是偶数还是奇数：</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">此功能的行为在不同平台上略有不同。有关更多详细信息，请参见&lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">这个调用看起来什么都不做。但是,可以检查是否有异常被抛出。</target>
        </trans-unit>
        <trans-unit id="60083a6ef6ec3da96fc4da91379010508c3c9d6d" translate="yes" xml:space="preserve">
          <source>This calls the C standard library function:</source>
          <target state="translated">这将调用C标准库函数。</target>
        </trans-unit>
        <trans-unit id="d143c9aa138ee903b0f4b83e6fabab2460ecb668" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">这可以通过&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;点广播&lt;/a&gt;并将其与常规整数索引结合起来（而不是从 &lt;code&gt;A&lt;/code&gt; 提取第一 &lt;code&gt;page&lt;/code&gt; 作为单独的步骤）来更简单地表示。它甚至可以与 &lt;code&gt;:&lt;/code&gt; 组合使用，以同时从两个页面中提取两个对角线：</target>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">这可以通过&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;点广播&lt;/a&gt;并将其与常规整数索引结合起来（而不是从 &lt;code&gt;A&lt;/code&gt; 提取第一 &lt;code&gt;page&lt;/code&gt; 作为单独的步骤）来更简单地表示。它甚至可以与 &lt;code&gt;:&lt;/code&gt; 组合使用，以同时从两个页面中提取两个对角线：</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">这可以与Julia代码中存在的签名相同（例如 &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ），也可以是简化形式。可能的话，可选参数应使用其默认值（即 &lt;code&gt;f(x, y=1)&lt;/code&gt; ）表示，并遵循实际的Julia语法。没有默认值的可选参数应放在方括号中（即 &lt;code&gt;f(x[, y])&lt;/code&gt; 和 &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ）。另一种解决方案是使用几行：一个不带可选参数，另一些带可选参数。该解决方案还可用于记录给定功能的几种相关方法。当函数接受许多关键字参数时，签名中仅包含 &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; 占位符（即 &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; ），并在 &lt;code&gt;# Arguments&lt;/code&gt; 部分下提供完整列表（请参见下面的第4点）。</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">这可以通过将&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;的结果传递给&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 来解决&lt;/a&gt;。&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; 不&lt;/a&gt;返回当前上下文的调用堆栈信息，而是返回最近异常的上下文的堆栈信息：</target>
        </trans-unit>
        <trans-unit id="31e05199a1305748953864ea5a4fca890bd60950" translate="yes" xml:space="preserve">
          <source>This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the &lt;code&gt;R&lt;/code&gt; variable &lt;code&gt;draw.segments&lt;/code&gt;, you can use &lt;code&gt;var&quot;draw.segments&quot;&lt;/code&gt; in your Julia code.</source>
          <target state="translated">这对于与具有不同的有效标识符构造规则的编程语言进行互操作性很有用。例如，要引用 &lt;code&gt;R&lt;/code&gt; 变量 &lt;code&gt;draw.segments&lt;/code&gt; ，可以在Julia代码中使用 &lt;code&gt;var&quot;draw.segments&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">可以更简洁有效地写成:</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">如果另一个进程获得了相同的文件名并在能够之前创建了文件，则可能导致争用情况。使用&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;代替建议。</target>
        </trans-unit>
        <trans-unit id="705c957d58f550245aaa4f046fe3e92349850b38" translate="yes" xml:space="preserve">
          <source>This can lead to security holes if another process obtains the same file name and creates the file before you are able to. Open the file with &lt;code&gt;JL_O_EXCL&lt;/code&gt; if this is a concern. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is also recommended instead.</source>
          <target state="translated">如果另一个进程获得了相同的文件名并在能够之前创建了文件，则可能导致安全漏洞。如果有问题，请使用 &lt;code&gt;JL_O_EXCL&lt;/code&gt; 打开文件。使用&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;还建议来代替。</target>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">这个总括方法比任何其他可能的方法定义都要少,所以它只对没有其他方法定义的参数对进行调用。</target>
        </trans-unit>
        <trans-unit id="687032e0ca0291c6f37d903f4b4a585e263d0c23" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">本章介绍了程序包加载的技术细节。要安装软件包，请使用Julia的内置软件包管理器&lt;a href=&quot;../../stdlib/pkg/index#Pkg&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; &lt;/a&gt;将软件包添加到活动环境中。要在您的活动环境，写已经使用套餐 &lt;code&gt;import X&lt;/code&gt; 或 &lt;code&gt;using X&lt;/code&gt; ，作为中所描述&lt;a href=&quot;../modules/index#modules&quot;&gt;的模块文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">本章介绍了程序包加载的技术细节。要安装软件包，请使用Julia的内置软件包管理器&lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; &lt;/a&gt;将软件包添加到活动环境中。要在您的活动环境，写已经使用套餐 &lt;code&gt;import X&lt;/code&gt; 或 &lt;code&gt;using X&lt;/code&gt; ，作为中所描述&lt;a href=&quot;../modules/index#modules-1&quot;&gt;的模块文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a06224a21aa063e4c9f046613bebaabd39494a6" translate="yes" xml:space="preserve">
          <source>This check is usually &lt;em&gt;costless&lt;/em&gt;, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an &lt;a href=&quot;../constructors/index#man-outer-constructor-methods&quot;&gt;outer constructor method&lt;/a&gt; that performs this calculation:</source>
          <target state="translated">该检查通常是&lt;em&gt;无成本的&lt;/em&gt;，因为编译器可以取消对有效具体类型的检查。如果还计算了第二个参数，则提供执行此计算的&lt;a href=&quot;../constructors/index#man-outer-constructor-methods&quot;&gt;外部构造方法&lt;/a&gt;可能是有利的：</target>
        </trans-unit>
        <trans-unit id="f560041e9c1b16deb7ab6bd9aff4671ee86058bc" translate="yes" xml:space="preserve">
          <source>This code is an implementation of the algorithm described in: An Improved Algorithm for &lt;code&gt;hypot(a,b)&lt;/code&gt; by Carlos F. Borges The article is available online at ArXiv at the link https://arxiv.org/abs/1904.09481</source>
          <target state="translated">该代码是以下算法的实现：Carlos F. Borges的关于 &lt;code&gt;hypot(a,b)&lt;/code&gt; 的改进算法。Borges本文可从ArXiv在线获得，链接为https://arxiv.org/abs/1904.09481。</target>
        </trans-unit>
        <trans-unit id="5d88d1d0a18f5d7f665080e348536b07fa18d945" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">此代码不会初始化所有的 &lt;code&gt;a&lt;/code&gt; ，因为每个进程都会有它的一个单独的副本。必须避免此类并行循环。幸运的是，可以使用&lt;a href=&quot;#man-shared-arrays&quot;&gt;共享阵列&lt;/a&gt;来解决此限制：</target>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">此代码不会初始化所有的 &lt;code&gt;a&lt;/code&gt; ，因为每个进程都会有它的一个单独的副本。必须避免此类并行循环。幸运的是，可以使用&lt;a href=&quot;#man-shared-arrays-1&quot;&gt;共享阵列&lt;/a&gt;来解决此限制：</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">此构造实现了将迭代分配给多个进程，并将其与指定的约简（在这种情况下为 &lt;code&gt;(+)&lt;/code&gt; ）组合在一起的模式。每次迭代的结果将作为循环内最后一个表达式的值。整个并行循环表达式本身将得出最终答案。</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">这种结构避免了乘法和加法运算。</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">该构造函数将由语法 &lt;code&gt;SummedArray(a)&lt;/code&gt; 调用。语法 &lt;code&gt;new{T,S}&lt;/code&gt; 允许为要构造的类型指定参数，即此调用将返回 &lt;code&gt;SummedArray{T,S}&lt;/code&gt; 。 &lt;code&gt;new{T,S}&lt;/code&gt; 可以在任何构造函数定义中使用，但是为了方便起见， &lt;code&gt;new{}&lt;/code&gt; 的参数在可能的情况下自动从正在构造的类型中派生。</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">此便利函数返回一个迭代器，该迭代器可有效过滤掉 &lt;code&gt;missing&lt;/code&gt; 值。因此，它可以与任何支持迭代器的函数一起使用</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">这种对数组进行排序的约定在许多语言（例如Fortran，Matlab和R）中很常见。列优先排序的替代方法是行优先排序，这是C和Python（ &lt;code&gt;numpy&lt;/code&gt; ）在其他语言中采用的约定。记住，遍历数组时，数组的顺序可能会对性能产生重大影响。要记住的一个经验法则是，对于以列为主的数组，第一个索引的变化最快。从本质上讲，这意味着如果最里面的循环索引是第一个出现在切片表达式中的，则循环会更快。</target>
        </trans-unit>
        <trans-unit id="1645b7896bc037bdea36ccff78d78a2be6b15f8e" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression. Keep in mind that indexing an array with &lt;code&gt;:&lt;/code&gt; is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.</source>
          <target state="translated">这种对数组排序的约定在许多语言（例如Fortran，Matlab和R）中很常见。列优先排序的替代方法是行优先排序，这是C和Python（ &lt;code&gt;numpy&lt;/code&gt; ）在其他语言中采用的约定。在数组上循环时，记住数组的顺序可能会对性能产生重大影响。要记住的一条经验法则是，对于以列为主的数组，第一个索引的更改速度最快。从本质上讲，这意味着如果最里面的循环索引是第一个出现在切片表达式中的，则循环会更快。请记住，用 &lt;code&gt;:&lt;/code&gt; 索引数组是一个隐式循环，它迭代地访问特定维度内的所有元素；例如，提取列可能比行要快。</target>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">这将创建一个25&amp;times;30000 &lt;code&gt;BitArray&lt;/code&gt; ，链接到与流 &lt;code&gt;io&lt;/code&gt; 关联的文件。</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">这将创建一个函数，该函数接受一个参数 &lt;code&gt;x&lt;/code&gt; 并以该值返回多项式 &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; 的值。请注意，结果是一个泛型函数，但是具有基于连续编号的编译器生成的名称。</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">该声明定义了一个新的参数类型 &lt;code&gt;Point{T}&lt;/code&gt; ，其中包含两个 &lt;code&gt;T&lt;/code&gt; 类型的&amp;ldquo;坐标&amp;rdquo; 。也许有人会问，是 &lt;code&gt;T&lt;/code&gt; 吗？好吧，这正是参数类型的要点：它可以是任何类型（实际上，也可以是任何位类型的值，尽管在这里它显然用作类型）。 &lt;code&gt;Point{Float64}&lt;/code&gt; 是一个具体类型等效于通过更换所定义的类型 &lt;code&gt;T&lt;/code&gt; 中的定义 &lt;code&gt;Point&lt;/code&gt; 与&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。因此，该单个声明实际上声明了无限数量的类型： &lt;code&gt;Point{Float64}&lt;/code&gt; ， &lt;code&gt;Point{AbstractString}&lt;/code&gt; ， &lt;code&gt;Point{Int64}&lt;/code&gt; 等。这些类型现在都是可用的具体类型：</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">如果没有显式的内部构造方法，此声明与 &lt;code&gt;Foo&lt;/code&gt; 类型的早期定义具有相同的效果。以下两种类型是等效的-一种具有默认构造函数，另一种具有显式构造函数：</target>
        </trans-unit>
        <trans-unit id="e6768dfeff6ea03f38de8deb6433998fc2233bac" translate="yes" xml:space="preserve">
          <source>This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression &lt;code&gt;s = t&lt;/code&gt; in the loop causes &lt;code&gt;s&lt;/code&gt; to be local to the loop, which means that it is also local when it appears on the right hand side of &lt;code&gt;t = s + i&lt;/code&gt;, even though that expression appears first and is evaluated first. One might imagine that the &lt;code&gt;s&lt;/code&gt; on the first line of the loop could be global while the &lt;code&gt;s&lt;/code&gt; on the second line of the loop is local, but that's not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.</source>
          <target state="translated">这说明了作用域的一些重要方面：在作用域中，每个变量只能具有一种含义，并且无论表达式的顺序如何，其含义都是确定的。表达式 &lt;code&gt;s = t&lt;/code&gt; 在循环中的存在使 &lt;code&gt;s&lt;/code&gt; 在循环中是局部的，这意味着，当它出现在 &lt;code&gt;t = s + i&lt;/code&gt; 的右侧时，它也是局部的，即使该表达式先出现且为首先评估。可以想象的是， &lt;code&gt;s&lt;/code&gt; 环路的第一行可能是全球性的，而 &lt;code&gt;s&lt;/code&gt; 环路的第二条线是本地的，但是这是不可能的，因为这两条线都在同一范围块和每个变量只能意味着一在给定范围内的事物。</target>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">这个依赖关系图用字典表示,看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种区别确定了类型必须定义的标量索引方法。 &lt;code&gt;IndexLinear()&lt;/code&gt; 数组很简单：只需定义 &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; 。当数组随后使用多维索引集进行索引时，后备 &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; 有效地将索引转换为一个线性索引，然后调用上述方法。另一方面， &lt;code&gt;IndexCartesian()&lt;/code&gt; 数组要求使用 &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 索引为每个受支持的维度定义方法。例如，来自 &lt;code&gt;SparseArrays&lt;/code&gt; 标准库模块的&lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;仅支持二维，因此它仅定义 &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; 。&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;同样适用！。</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">这不适用于 &lt;code&gt;function&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 声明。但是，绑定到全局变量的匿名函数将被序列化，如下所示。</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">这个环境变量只有在Julia编译时支持JIT剖析的情况下才会产生影响,在编译时使用</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">仅当Julia是使用垃圾回收调试进行编译时（即，在构建配置 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 时)，此环境变量才有效。</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误表明条件的类型错误：&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;而不是必需的&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">为了引入或操纵用户变量，可以在必要时使用这种转义机制来&amp;ldquo;违反&amp;rdquo;卫生要求。例如，以下宏在调用环境中将 &lt;code&gt;x&lt;/code&gt; 设置为零：</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">此示例演示了一种强大且经常使用的并行编程模式。许多迭代在多个进程中独立运行，然后使用某些函数将其结果合并。组合过程称为&lt;em&gt;减少&lt;/em&gt;，因为它通常是张量秩减少：将数字向量简化为单个数字，或者将矩阵简化为单个行或列，等等。在代码中，这通常看起来像模式 &lt;code&gt;x = f(x,v[i])&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是累加器， &lt;code&gt;f&lt;/code&gt; 是归约函数， &lt;code&gt;v[i]&lt;/code&gt; 是要归约的元素。希望 &lt;code&gt;f&lt;/code&gt; 是关联的，以便执行操作的顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">此示例首先分配一个字节数组，然后调用C库函数 &lt;code&gt;gethostname&lt;/code&gt; 以用主机名填充该数组，获取指向主机名缓冲区的指针，然后将指针转换为Julia字符串（假定它是NUL终止） C字符串。 C库通常使用这种模式，要求调用者分配要传递给被调用者并填充的内存。像这样从Julia分配内存通常是通过创建未初始化的数组并将指向其数据的指针传递给C函数。这就是为什么我们在这里不使用 &lt;code&gt;Cstring&lt;/code&gt; 类型的原因：由于数组未初始化，因此它可能包含NUL字节。作为 &lt;code&gt;Cstring&lt;/code&gt; 一部分转换为&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 检查包含的NUL字节，因此可能引发转换错误。</target>
        </trans-unit>
        <trans-unit id="81f56d42721e023666b42ce5d20872f19e3f3c1b" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes. It then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">此示例首先分配一个字节数组。然后，它调用C库函数 &lt;code&gt;gethostname&lt;/code&gt; ，以该主机名填充数组。最后，假定它是一个以NUL终止的C字符串，它将获取指向主机名缓冲区的指针，并将该指针转换为Julia字符串。 C库通常使用这种模式，要求调用者分配要传递给被调用者并填充的内存。通常通过创建未初始化的数组并将指向其数据的指针传递到C函数来完成从Julia分配内存的操作。这就是为什么我们在这里不使用 &lt;code&gt;Cstring&lt;/code&gt; 类型的原因：由于数组未初始化，因此它可能包含NUL字节。作为 &lt;code&gt;Cstring&lt;/code&gt; 一部分转换为&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 检查包含的NUL字节，因此可能引发转换错误。</target>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">本实施例中生成许多次正规数因为在值 &lt;code&gt;a&lt;/code&gt; 成为一个指数递减曲线，随着时间的推移慢慢变平。</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">这个例子强调了相邻可表示的浮点数也有相邻的二进制整数表示的一般原则。</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">这个例子和上一个例子类似,只是有两个阶段的消费者,各阶段的延迟不同,所以他们使用不同数量的并行工作者,以维持饱和的吞吐量。</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">这个示例地图包括三种不同的软件包位置(第一种和第三种是默认加载路径的一部分)。</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">这个实验性接口支持Julia的多线程功能。这里描述的类型和功能可能(而且很可能会)在未来发生变化。</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该表达式使用 &lt;code&gt;string&lt;/code&gt; 构造一个名称，然后将该名称替换为新的&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;表达式，然后对其求值。请记住， &lt;code&gt;eval&lt;/code&gt; 仅在最高级别上运行，因此在该表达式内本地变量将不可用（除非其值用 &lt;code&gt;$&lt;/code&gt; 代替）。因此， &lt;code&gt;eval&lt;/code&gt; 通常仅用于形成顶级定义，例如在包装包含许多相似功能的库时。可以为&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;构造类似的示例。</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">此表达式以三个单词作为参数调用 &lt;code&gt;echo&lt;/code&gt; 命令： &lt;code&gt;hello&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;sort&lt;/code&gt; 。结果是只打印了一行： &lt;code&gt;hello | sort&lt;/code&gt; 。那么，如何构造管道？代替使用 &lt;code&gt;'|'&lt;/code&gt; 在反引号内部，使用 &lt;code&gt;pipeline&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">此功能是实验性的，在Julia的未来版本中可能会更改或消失。错误使用 &lt;code&gt;@simd&lt;/code&gt; 宏可能会导致意外结果。</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">这个功能很有用,可以避免在变量的一个赋值意外改变其类型时发生的性能 &quot;卡奇&quot;。</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">这种形式经常出现在方法签名上。</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">此格式不应与较早的&lt;em&gt;WY&lt;/em&gt;表示相混淆&lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5430a5df9a2060598aa23b84f7a5871adf25fad" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;sup&gt;&lt;a href=&quot;#footnote-Bischof1987&quot; id=&quot;citeref-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">此格式不应与较早的&lt;em&gt;WY&lt;/em&gt;表示相混淆&lt;sup&gt;&lt;a href=&quot;#footnote-Bischof1987&quot; id=&quot;citeref-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="c12c069ce178f9d50647ca11f433a6b7234b2e36" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and returns the value of the last expression evaluated, which is &lt;code&gt;x + y&lt;/code&gt;.</source>
          <target state="translated">该函数接受两个参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ,并返回最后一个求值表达式的值 &lt;code&gt;x + y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">此功能可用于实现事务语义。在交易之前，将值记录在 &lt;code&gt;x&lt;/code&gt; 中。交易后，仅当 &lt;code&gt;x&lt;/code&gt; 同时未修改时才存储新值。</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">该函数计算除以数值精确的 &lt;code&gt;2&amp;pi;&lt;/code&gt; 后的模数的浮点表示形式，因此与 &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; 并不完全相同，后者将计算 &lt;code&gt;x&lt;/code&gt; 的相对于除以浮点数 &lt;code&gt;2&amp;pi;&lt;/code&gt; 的模数。</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此函数定义仅适用于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;类型的值的调用：</target>
        </trans-unit>
        <trans-unit id="de80929c3e71c9bc153a3794af9f7a9ac61e7bc0" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;Base&lt;/code&gt; with Julia 1.1, consider using &lt;code&gt;copy!(dst, src)&lt;/code&gt; instead. &lt;code&gt;Future.copy!&lt;/code&gt; will be deprecated in the future.</source>
          <target state="translated">此功能已随Julia 1.1一起移至 &lt;code&gt;Base&lt;/code&gt; ，请考虑改用 &lt;code&gt;copy!(dst, src)&lt;/code&gt; 。 &lt;code&gt;Future.copy!&lt;/code&gt; 将来将不推荐使用。</target>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">此功能是&amp;ldquo;不安全的&amp;rdquo;。请注意，只要使用此指针，就必须确保存在Julia对 &lt;code&gt;array&lt;/code&gt; 引用。该&lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt;宏应该被用来保护 &lt;code&gt;array&lt;/code&gt; 从垃圾收集参数给定的代码块中。</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">这个功能是&lt;em&gt;懒惰的&lt;/em&gt; ; 也就是说，保证返回$&amp;Theta;（1）$时间并使用$&amp;Theta;（1）$额外空间，并且调用 &lt;code&gt;filter&lt;/code&gt; 不会调用 &lt;code&gt;flt&lt;/code&gt; 。迭代返回的可迭代对象时，将调用 &lt;code&gt;flt&lt;/code&gt; 。这些调用不会被缓存，并且在重复时将进行重复调用。</target>
        </trans-unit>
        <trans-unit id="df83e0cd3a021e2eda678d29363b61d1d821ffd0" translate="yes" xml:space="preserve">
          <source>This function is a backwards-compatibility wrapper around &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt;. New applications should use &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此函数是围绕&lt;a href=&quot;#Sockets.getipaddrs&quot;&gt; &lt;code&gt;getipaddrs&lt;/code&gt; &lt;/a&gt;的向后兼容包装器。新应用程序应改用&lt;a href=&quot;#Sockets.getipaddrs&quot;&gt; &lt;code&gt;getipaddrs&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">这个功能从Julia 1.2开始提供。</target>
        </trans-unit>
        <trans-unit id="da85261a4de72bb648f4ec6ce0ef1d4e3e0d885c" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.4.</source>
          <target state="translated">这个功能从Julia 1.4开始提供。</target>
        </trans-unit>
        <trans-unit id="c744a1e60d0343bb54950e43c44ab4cd5d6e31b7" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.5.</source>
          <target state="translated">这个功能从Julia 1.5开始提供。</target>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">这个功能在Julia 1.1中是试验性的,可能会在未来的版本中重新命名(见https://github.com/JuliaLang/julia/pull/29901)。</target>
        </trans-unit>
        <trans-unit id="8f852b6c88a2b121cce224d6c4d1adc0aba50b5c" translate="yes" xml:space="preserve">
          <source>This function is exported as of Julia 1.3.</source>
          <target state="translated">这个函数从Julia 1.3开始导出。</target>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">该功能被标记为&amp;ldquo;不安全&amp;rdquo;，因为如果 &lt;code&gt;p&lt;/code&gt; 不是所请求长度的数据的有效存储地址，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">该函数被标记为&amp;ldquo;不安全&amp;rdquo;，因为如果 &lt;code&gt;pointer&lt;/code&gt; 不是所请求长度数据的有效内存地址，它将崩溃。</target>
        </trans-unit>
        <trans-unit id="5b892b839448ad3b615e4b9ec54defee6e074b87" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.</source>
          <target state="translated">这个函数不是线程安全的。它将影响在所有线程上运行的代码,但如果与使用该设置的计算同时调用,它的行为将未被定义。</target>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">如果 &lt;code&gt;Main&lt;/code&gt; 中尚未定义模块，则此功能是&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;实现的一部分。也可以直接调用它以强制重新加载模块，而不管模块之前是否已加载（例如，以交互方式开发库时）。</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">这个函数不能在不可变的对象上调用,因为它们没有稳定的内存地址。</target>
        </trans-unit>
        <trans-unit id="5de59bd4497cdb331716cc233726a0a8b9678b01" translate="yes" xml:space="preserve">
          <source>This function only affects the current thread.</source>
          <target state="translated">该功能只影响当前线程。</target>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">在不支持软符号链接的操作系统下,如Windows XP,该功能会引发错误。</target>
        </trans-unit>
        <trans-unit id="e2895f8ba02c0856affa3262c2ea2aa12ea82abd" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.4 or later.</source>
          <target state="translated">该功能需要Julia 1.4或更高版本。</target>
        </trans-unit>
        <trans-unit id="f6c4fed1257bdc9c86a6438d7c81f0cba15e713a" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.5 or later.</source>
          <target state="translated">该功能需要Julia 1.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">这个功能至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">该功能至少需要Julia 1.1。在Julia 1.0中，可以从标准库 &lt;code&gt;InteractiveUtils&lt;/code&gt; 中获得它。</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">这个功能至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="1aebd8ffdb83e4dbea00c26626665df625006081" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.4.</source>
          <target state="translated">这个功能至少需要Julia 1.4。</target>
        </trans-unit>
        <trans-unit id="2a51a88fd91e95896285adef28ef9c196b5c4360" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.5.</source>
          <target state="translated">这个功能至少需要Julia 1.5。</target>
        </trans-unit>
        <trans-unit id="7b7503036b2b1d5c6cdd3e30a18b4569d18e9b3d" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">无论 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型如何，此函数将始终返回 &lt;code&gt;Int8&lt;/code&gt; 。有关返回类型的更多信息，请参见&lt;a href=&quot;../types/index#Type-Declarations&quot;&gt;类型声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">无论 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型如何，此函数将始终返回 &lt;code&gt;Int8&lt;/code&gt; 。有关返回类型的更多信息，请参见&lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;类型声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b364264e31d49453fa585f561786364c3d08cfe" translate="yes" xml:space="preserve">
          <source>This functionality exists to allow Julia to bootstrap the standard primitive types that LLVM supports. Once they are defined, there is very little reason to define more.</source>
          <target state="translated">这个功能的存在是为了让Julia能够引导LLVM支持的标准基元类型。一旦定义了这些类型,就没有什么理由再定义更多。</target>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">该功能至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">该功能至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">这给出了一个类似于</target>
        </trans-unit>
        <trans-unit id="4351de18141317da8dc4e7b0765ffdf10ccf9585" translate="yes" xml:space="preserve">
          <source>This guide provides a comprehensive overview of how to attach documentation to all Julia syntax constructs for which providing documentation is possible.</source>
          <target state="translated">本指南全面介绍了如何为所有可以提供文档的Julia语法结构附加文档。</target>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">本指南依靠Pkg REPL执行Pkg命令。对于非交互使用，我们建议使用Pkg API。Pkg API完整记录在Pkg文档的&amp;ldquo; &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API参考&amp;rdquo;&lt;/a&gt;部分中。</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">本指南应帮助您开始使用 &lt;code&gt;Pkg&lt;/code&gt; 。 &lt;code&gt;Pkg&lt;/code&gt; 在强大的软件包管理方面提供了更多功能，请阅读完整手册以了解更多信息！</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;foo&lt;/code&gt; 的先前定义完全相同。</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">这说明了默认的 &quot;树形 &quot;转储;另一种选择是 &quot;平面 &quot;转储,它积累的计数与它们的嵌套无关。</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">这将从 &lt;code&gt;Foo&lt;/code&gt; 导入所有符号，但仅导入 &lt;code&gt;Bar&lt;/code&gt; 模块内部。</target>
        </trans-unit>
        <trans-unit id="a6c62d5f28832b263b7519c969320ae1bece54d1" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice.</source>
          <target state="translated">本界面为实验性界面,如有变更或删除,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="0e598599b0d95357e3968722563ce2a0da7930f2" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice. To insulate yourself against changes, consider putting any registrations inside an &lt;code&gt;if isdefined(Base.Experimental, :register_error_hint) ... end&lt;/code&gt; block.</source>
          <target state="translated">此界面是实验性的，如有更改或删除，恕不另行通知。为了使自己免受更改的影响，请考虑将所有注册放入 &lt;code&gt;if isdefined(Base.Experimental, :register_error_hint) ... end&lt;/code&gt; 块内。</target>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">该界面提供了一种机制，可以在不同的集群环境中启动和管理Julia工作者。Base中存在两种管理器： &lt;code&gt;LocalManager&lt;/code&gt; （用于在同一主机上启动其他工作程序）和 &lt;code&gt;SSHManager&lt;/code&gt; （用于通过 &lt;code&gt;ssh&lt;/code&gt; 在远程主机上启动）。TCP / IP套接字用于在进程之间连接和传输消息。群集管理器可以提供其他传输。</target>
        </trans-unit>
        <trans-unit id="962b26b87665c4f3df59ad9f2395deca95b45d10" translate="yes" xml:space="preserve">
          <source>This is a &lt;em&gt;convention&lt;/em&gt; in the sense that &lt;code&gt;nothing&lt;/code&gt; is not a Julia keyword but a only singleton object of type &lt;code&gt;Nothing&lt;/code&gt;. Also, you may notice that the &lt;code&gt;printx&lt;/code&gt; function example above is contrived, because &lt;code&gt;println&lt;/code&gt; already returns &lt;code&gt;nothing&lt;/code&gt;, so that the &lt;code&gt;return&lt;/code&gt; line is redundant.</source>
          <target state="translated">从某种意义上来说，这是一种&lt;em&gt;约定&lt;/em&gt;， &lt;code&gt;nothing&lt;/code&gt; 不是Julia关键字，而是 &lt;code&gt;Nothing&lt;/code&gt; 类型的唯一单例对象。同样，您可能会注意到上面的 &lt;code&gt;printx&lt;/code&gt; 函数示例是人为设计的，因为 &lt;code&gt;println&lt;/code&gt; 已经不返回 &lt;code&gt;nothing&lt;/code&gt; ，因此 &lt;code&gt;return&lt;/code&gt; 行是多余的。</target>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">这是Julia封装器，指向&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">这是一个更好的选择,比</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">这是一个典型的示例，其中一个生产者为两个并发的消费者提供食物：一个 &lt;code&gt;perl&lt;/code&gt; 进程在其上生成数字为0到5的行，而两个并行进程在该输出中使用该行，一个前缀行带有字母&amp;ldquo; A&amp;rdquo;，另一个前缀行带有字母&amp;ldquo; A&amp;rdquo;。字母&amp;ldquo; B&amp;rdquo;。哪个消费者获得第一条线是不确定的，但是一旦赢得了这场比赛，这些线将由一个进程交替使用，然后由另一个进程替代。 （在Perl中设置 &lt;code&gt;$|=1&lt;/code&gt; 会使每个print语句刷新&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;句柄，这对于本示例来说是必需的。否则，所有输出将被缓冲并立即打印到管道中，仅由一个使用者进程读取。 ）</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">这是一种常见的模式,当从一个较大的类型类转换到算法实际支持的一个特定参数类型时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">这是一个有些人为的示例，因为我们可以通过消除条件并将 &lt;code&gt;println&lt;/code&gt; 调用放在 &lt;code&gt;if&lt;/code&gt; 块内来更清楚地产生相同的行为。在实际使用中，在 &lt;code&gt;continue&lt;/code&gt; 之后还有更多代码需要评估，并且通常有多个要点从一个点 &lt;code&gt;continue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">这是 &lt;code&gt;@time&lt;/code&gt; 宏的详细版本。它首先输出与 &lt;code&gt;@time&lt;/code&gt; 相同的信息，然后输出任何非零内存分配计数器，然后返回表达式的值。</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">这在整个Julia Base中是一个非常常见的模式:一小套所需的方法定义了一个非正式的接口,可以实现许多更高级的行为。在某些情况下,当类型知道在它们的特定情况下可以使用更有效的算法时,它们会想要额外地专门化那些额外的行为。</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">这是通过以下定义实现的。</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">这是通过 &lt;code&gt;base/boot.jl&lt;/code&gt; 中的以下代码完成的：</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">对于本地节点上的远程调用也是如此,如下例所示。</target>
        </trans-unit>
        <trans-unit id="57f9c64c4e06a92a8accdfe0153dcfbc237317b8" translate="yes" xml:space="preserve">
          <source>This is best seen in the following example:</source>
          <target state="translated">这一点在下面的例子中体现得淋漓尽致。</target>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">这是更好的样式，因为 &lt;code&gt;foo&lt;/code&gt; 并不真正接受所有类型的数字。它确实需要 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c63a317e555926f5cec6415634c44654066c6532" translate="yes" xml:space="preserve">
          <source>This is effectively a lazy version of &lt;a href=&quot;../arrays/index#Base.accumulate&quot;&gt;&lt;code&gt;Base.accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这实际上是&lt;a href=&quot;../arrays/index#Base.accumulate&quot;&gt; &lt;code&gt;Base.accumulate&lt;/code&gt; &lt;/a&gt;的惰性版本。</target>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">这相当于 &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; 。编写 &lt;code&gt;Vector{Float64}&lt;/code&gt; 等效于编写 &lt;code&gt;Array{Float64,1}&lt;/code&gt; ，并且伞型 &lt;code&gt;Vector&lt;/code&gt; 作为实例具有所有 &lt;code&gt;Array&lt;/code&gt; 对象，其中第二个参数（数组维数）为1，无论元素类型是什么。在必须始终完整指定参数类型的语言中，这并不是特别有用，但是在Julia中，这允许人们只为抽象类型编写 &lt;code&gt;Vector&lt;/code&gt; ，包括任何元素类型的所有一维密集数组。</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">这等效于较丑的测试 &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; 。提供多个表达式是错误的，除非第一个表达式是调用表达式，其余的都是赋值（ &lt;code&gt;k=v&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">如果已经存在影响转换的命名函数作为&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的第一个参数传递，这很好。但是，通常不存在即用型命名功能。在这种情况下，匿名函数构造无需名称即可轻松创建一次性函数对象：</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">发生这种情况的原因是，虽然 &lt;code&gt;write&lt;/code&gt; 调用是同步的，但是在等待I / O的那部分完成时，每个参数的写操作都会屈服于其他任务。</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">旨在使用 &lt;code&gt;do&lt;/code&gt; 块语法进行调用</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">可以使用 &lt;code&gt;do&lt;/code&gt; block语法来调用它：</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">这很可能是一个非常昂贵的操作。考虑到Julia中所有其他原子操作都已经有获取/释放的语义,在大多数情况下,显式围栏应该是没有必要的。</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">这更具可读性和便利性，并且等效于上述字符串连接-系统将此明显的单个字符串文字重写为调用 &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">在工作线程（ &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ）上不需要这样做，因为 &lt;code&gt;InterruptException&lt;/code&gt; 仅会传递给主线程。不调用julia代码或julia运行时的外部函数在执行过程中会自动禁用sigint。</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">这通常是正确的策略;但是,在某些情况下,盲目地遵循这一建议可能会适得其反。特别是,一个通用函数的方法越多,出现歧义的可能性就越大。当你的方法层次结构变得比这个简单的例子更复杂时,值得你仔细考虑其他策略。</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">仅当您的模块依赖于未通过&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;使用的文件时，才需要这样做。它在编译之外没有任何作用。</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;使用的默认比较。</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">这是Julia中保留关键字的列表： &lt;code&gt;baremodule&lt;/code&gt; ， &lt;code&gt;begin&lt;/code&gt; ， &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;continue&lt;/code&gt; ， &lt;code&gt;do&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;elseif&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;export&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;finally&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;function&lt;/code&gt; ， &lt;code&gt;global&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;import&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;local&lt;/code&gt; ， &lt;code&gt;macro&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;quote&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;try&lt;/code&gt; ， &lt;code&gt;using&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 。这些关键字不允许用作变量名。</target>
        </trans-unit>
        <trans-unit id="96c2e84d8dd228822a97cd0751dcb6c1eebd84d2" translate="yes" xml:space="preserve">
          <source>This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;).</source>
          <target state="translated">这是标准库中也使用的机制，例如通过随机数组生成的默认实现（例如 &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59c8784ecdd309ab380e1280eddd527fe7e9db81" translate="yes" xml:space="preserve">
          <source>This is useful for preventing the propagation of &lt;code&gt;NaN&lt;/code&gt; values in quantities that are known to be zero. See &lt;a href=&quot;https://arxiv.org/abs/math/9205211&quot;&gt;Knuth (1992)&lt;/a&gt; for motivation.</source>
          <target state="translated">这对于防止 &lt;code&gt;NaN&lt;/code&gt; 值以已知为零的数量传播非常有用。动机参见&lt;a href=&quot;https://arxiv.org/abs/math/9205211&quot;&gt;Knuth（1992）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">这对于更复杂的时间表达式的do-block语法是很有用的。</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">当维度变大时，这是浪费的，因此Julia提供了&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;，它在不使用额外内存的情况下扩展了数组参数中的单例维度以匹配另一个数组中的对应维度，并逐个应用给定的函数：</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">这个迭代器是&amp;ldquo;懒惰的&amp;rdquo;，因为它不会复制该集合以使其反向。请参阅 &lt;code&gt;Base.reverse&lt;/code&gt; 以获取急切的实现。</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">这使事情变得简单,同时允许编译器在所有情况下生成优化的代码。</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">这种控制流可以使某些问题的解决变得更加容易。在某些问题中,所需的各种工作并不是天然地通过函数调用联系在一起的,在需要完成的工作中并没有明显的 &quot;调用者 &quot;或 &quot;被调用者&quot;。一个例子是生产者-消费者问题,一个复杂的过程在生成值,另一个复杂的过程在消耗值。消费者不能简单地调用生产者函数来获取一个值,因为生产者可能有更多的值要生成,所以可能还没有准备好返回。有了任务,生产者和消费者都可以根据自己的需要运行,必要时来回传递值。</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">通过分派对功能行为的这种定义在Julia中非常普遍，甚至是惯用的。方法类型参数不限于用作参数类型：它们可以在函数签名或函数主体中的任何值处使用。这是一个示例，其中方法类型参数 &lt;code&gt;T&lt;/code&gt; 用作方法签名中参数类型 &lt;code&gt;Vector{T}&lt;/code&gt; 的类型参数：</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">这种对变量的操作应谨慎使用,但偶尔也很方便。</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">最后这一点是&lt;em&gt;非常&lt;/em&gt;重要的：即使 &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; ，我们&lt;strong&gt;不要&lt;/strong&gt;有 &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">这利用了 &lt;code&gt;copyto!&lt;/code&gt; 的后备实现！将包装器转换为 &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; 。因此，专注于 &lt;code&gt;DestType&lt;/code&gt; 的优先级低于专注于 &lt;code&gt;DestStyle&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">这将加载模块 &lt;code&gt;Foo&lt;/code&gt; 并定义一个引用该模块的变量 &lt;code&gt;Foo&lt;/code&gt; ，但是不会将任何其他符号从该模块导入当前名称空间。您可以通过 &lt;code&gt;Foo&lt;/code&gt; 符号的合格名称 &lt;code&gt;Foo.bar&lt;/code&gt; 等来引用Foo符号。</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">这个宏可以这样使用。</target>
        </trans-unit>
        <trans-unit id="d3a5424713c4662a407bbf558841062e07735c84" translate="yes" xml:space="preserve">
          <source>This macro gives a more convenient syntax for declaring &lt;code&gt;NamedTuple&lt;/code&gt; types. It returns a &lt;code&gt;NamedTuple&lt;/code&gt; type with the given keys and types, equivalent to &lt;code&gt;NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}&lt;/code&gt;. If the &lt;code&gt;::Type&lt;/code&gt; declaration is omitted, it is taken to be &lt;code&gt;Any&lt;/code&gt;. The &lt;code&gt;begin ... end&lt;/code&gt; form allows the declarations to be split across multiple lines (similar to a &lt;code&gt;struct&lt;/code&gt; declaration), but is otherwise equivalent.</source>
          <target state="translated">该宏为声明 &lt;code&gt;NamedTuple&lt;/code&gt; 类型提供了更方便的语法。它返回一个 &lt;code&gt;NamedTuple&lt;/code&gt; 用给定的密钥和类型，相当于类型 &lt;code&gt;NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}&lt;/code&gt; 。如果省略 &lt;code&gt;::Type&lt;/code&gt; 声明，则将其视为 &lt;code&gt;Any&lt;/code&gt; 。的 &lt;code&gt;begin ... end&lt;/code&gt; 形式允许声明来跨多个行（类似的分裂 &lt;code&gt;struct&lt;/code&gt; 声明），但在其他方面等价的。</target>
        </trans-unit>
        <trans-unit id="8d42881c0e50cef46bcd4335722e2d4da406ce4c" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.3.</source>
          <target state="translated">这个宏从Julia 1.3开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="801b86f68b3c0cefd135f8c96330176952188ece" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.5.</source>
          <target state="translated">这个宏从Julia 1.5开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">此宏采用一个参数： &lt;code&gt;name&lt;/code&gt; 。当 &lt;code&gt;@sayhello&lt;/code&gt; 遇到，所引用的表达&lt;em&gt;扩展&lt;/em&gt;到插值参数到最终表达式的值：</target>
        </trans-unit>
        <trans-unit id="fb5cd3420a15fab4676b11324ac55221c551d00f" translate="yes" xml:space="preserve">
          <source>This makes it clearer where docstrings start and end.</source>
          <target state="translated">这使得docstrings的开始和结束更加清晰。</target>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">这使得使用任意对象（这里是 &lt;code&gt;raw&lt;/code&gt; 字符串）作为文档字符串变得容易。</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">这使编写许多基本的整数算法变得很困难，因为许多常用技术都依赖于与溢出相加的机器&lt;em&gt;是&lt;/em&gt;关联的事实。考虑使用表达式 &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; 在Julia中找到整数值 &lt;code&gt;lo&lt;/code&gt; 和 &lt;code&gt;hi&lt;/code&gt; 之间的中点：</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">这使得docstrings的开始和结束更加清晰。</target>
        </trans-unit>
        <trans-unit id="f1fb07e562617380cc2e285350641983b6f7d13d" translate="yes" xml:space="preserve">
          <source>This makes it possible to use expressions other than normal string literals (such as the &lt;code&gt;raw&quot;&quot;&lt;/code&gt; string macro) as a docstring.</source>
          <target state="translated">这样就可以将普通字符串文字以外的表达式（例如 &lt;code&gt;raw&quot;&quot;&lt;/code&gt; 字符串宏）用作文档字符串。</target>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">这使得堆栈跟踪信息可以以编程方式用于日志记录、错误处理等。</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">此清单文件描述了 &lt;code&gt;App&lt;/code&gt; 项目可能的完整依赖关系图：</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">这听起来像是一个奇怪的限制,但请记住,由于C语言不是像Julia那样的动态语言,它的函数只能接受静态已知的、固定签名的参数类型。</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">这意味着调用 &lt;code&gt;f()&lt;/code&gt; 等同于调用 &lt;code&gt;f(1,2)&lt;/code&gt; 。在这种情况下，结果为 &lt;code&gt;5&lt;/code&gt; ，因为 &lt;code&gt;f(1,2)&lt;/code&gt; 调用了上面 &lt;code&gt;f&lt;/code&gt; 的第一个方法。但是，并非总是如此。如果您定义了第四种更适合于整数的方法：</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">这意味着新的 &lt;code&gt;Number&lt;/code&gt; 类型仅需要定义构造函数，因为此定义将为它们处理 &lt;code&gt;convert&lt;/code&gt; 。还提供标识转换以处理参数已为请求的类型的情况：</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">这意味着将&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;舍入为秒，分钟，小时或年的偶数倍（因为ISO 8601规范包括零年）将导致&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;在该字段中具有偶数，而将&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;舍入为偶数。数月将导致月份字段具有奇数值。由于月份和年份都可能包含不规则的天数，因此不确定将天数舍入为偶数天是否会导致天数字段中的偶数。</target>
        </trans-unit>
        <trans-unit id="e022c0c027f7431615a2e6bfce810bd80d7f71b8" translate="yes" xml:space="preserve">
          <source>This means that the &lt;code&gt;pointer&lt;/code&gt; for &lt;code&gt;V&lt;/code&gt; is actually pointing into the middle of &lt;code&gt;A&lt;/code&gt;'s memory block, and it refers to elements both backwards and forwards in memory. See the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays&quot;&gt;interface guide for strided arrays&lt;/a&gt; for more details on defining your own strided arrays. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">这意味着 &lt;code&gt;pointer&lt;/code&gt; 为 &lt;code&gt;V&lt;/code&gt; 实际上指向的中间 &lt;code&gt;A&lt;/code&gt; 的存储块，并且它是指元件都向后和向前在存储器中。有关定义自己的跨步数组的更多详细信息，请参见&lt;a href=&quot;../interfaces/index#man-interface-strided-arrays&quot;&gt;跨步数​​组&lt;/a&gt;的接口指南。&lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;是许多内置数组类型的方便别名，这些内置数组类型被视为跨步数组，允许它们分派选择仅使用指针和跨距调用高度优化和优化的BLAS和LAPACK函数的专用实现。</target>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">这意味着我们还必须定义相应的 &lt;code&gt;similar&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">通过编写&lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; &lt;/a&gt;的方式，该机制可以通过自定义异常类型轻松实现：</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">这种机制也是Julia中类型构造器和闭包(引用其周围环境的内部函数)如何工作的关键。</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">当然，随机数组生成的默认实现会使用此机制（例如 &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）。为了对自定义类型实现这种解耦，可以使用辅助类型。回到我们的 &lt;code&gt;Die&lt;/code&gt; 示例： &lt;code&gt;rand(::Die)&lt;/code&gt; 使用某个范围内的随机生成，因此有机会进行优化：</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">每次调用时，此方法都会创建一个 &lt;code&gt;DateFormat&lt;/code&gt; 对象。如果要解析许多相同格式的日期字符串，请考虑一次创建一个&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象，并将其用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">每次调用时，此方法都会创建一个 &lt;code&gt;DateFormat&lt;/code&gt; 对象。如果要解析许多相同格式的日期时间字符串，请考虑一次创建一个&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象，并将其用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">此方法定义适用于作为&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;实例的任何一对参数。它们不必是同一类型，只要它们都是数字值即可。处理不同数值类型的问题在表达式 &lt;code&gt;2x - y&lt;/code&gt; 委托给算术运算。</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">这个方法从Julia 1.1开始就有了。</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">此方法需要Julia 1.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">这个方法至少需要Julia 1.1的版本。</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">这个方法至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="a7dd277ce3d58fa80c3ba1f6a270f1433aab79aa" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.3.</source>
          <target state="translated">这个方法至少需要Julia 1.3。</target>
        </trans-unit>
        <trans-unit id="287181424f41545827889fe6d1cd971c13deceb7" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.4.</source>
          <target state="translated">这个方法至少需要Julia 1.4的版本。</target>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">此方法使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;函数将 &lt;code&gt;x&lt;/code&gt; 显式转换为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;，然后在两个参数均为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;的情况下，将构造委托给常规构造函数。使用此方法定义，以前的&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;现在可以成功创建 &lt;code&gt;Point{Float64}&lt;/code&gt; 类型的点：</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">当以下情况之一为真时,可能值得一试。</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">此模块定义类型 &lt;code&gt;MyType&lt;/code&gt; 和两个函数。函数 &lt;code&gt;foo&lt;/code&gt; 和类型 &lt;code&gt;MyType&lt;/code&gt; 已导出，因此可用于导入其他模块。功能 &lt;code&gt;bar&lt;/code&gt; 是 &lt;code&gt;MyModule&lt;/code&gt; 专用的。</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">当传递的IO流是设置了 &lt;code&gt;:compact&lt;/code&gt; 属性的 &lt;code&gt;IOContext&lt;/code&gt; 对象时，将使用此新的紧凑表示形式。特别是在打印具有多列的数组（水平空间有限）的情况下：</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">这种整数比率的标准化形式是唯一的，因此可以通过检查分子和分母的相等性来测试有理值的相等性。可以使用&lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt;函数来提取有理值的标准化分子和分母：</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">该对象不是线程安全的。有关线程安全版本，请参见&lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd76756319b3c7370a847bd7b93c70cdd9b67ec0" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;../multi-threading/index#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">该对象不是线程安全的。有关线程安全版本，请参见&lt;a href=&quot;../multi-threading/index#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">此操作旨在用于线性代数-有关常规数据操作，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;，这是非递归的。</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此操作旨在用于线性代数-有关常规数据操作，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">此运算符遵循IEEE语义的浮点数： &lt;code&gt;0.0 == -0.0&lt;/code&gt; 和 &lt;code&gt;NaN != NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">此输出告诉我们 &lt;code&gt;f&lt;/code&gt; 是具有两个方法的函数对象。要找出这些方法的签名是什么，请使用&lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">这种模式是通过定义一个通用函数来实现的,该函数为函数参数可能所属的每个trait-set计算不同的单子值(或类型)。如果这个函数是纯粹的,那么与普通的调度相比,对性能没有影响。</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">这种模式是如此频繁，以至于有一个名为 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; 的助手类型可用，从而为我们节省了 &lt;code&gt;SamplerDie&lt;/code&gt; 的定义：我们可以通过以下方式实现解耦：</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">在Julia Base的多个地方都使用了这种模式。例如，看到 &lt;code&gt;vcat&lt;/code&gt; 和 &lt;code&gt;hcat&lt;/code&gt; 在&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; &lt;/a&gt;，或&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; &lt;/a&gt;函数，我们可以用它代替编写自己的 &lt;code&gt;fill_twos!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">这会将 &lt;code&gt;echo&lt;/code&gt; 命令的输出通过管道传递到 &lt;code&gt;sort&lt;/code&gt; 命令。当然，这并不是很有趣，因为只有一行可以排序，但是我们当然可以做更多有趣的事情：</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">这将在UNIX系统上打印出最高的五个用户ID。该 &lt;code&gt;cut&lt;/code&gt; ， &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 命令都催生作为当前的直系子弟 &lt;code&gt;julia&lt;/code&gt; 过程，中间没有shell进程。Julia本身负责设置管道和连接文件描述符，这通常是由Shell完成的。由于Julia自己执行此操作，因此它保留了更好的控制能力，并且可以执行Shell无法执行的某些操作。</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">这个项目文件意味着下面的根图,如果它是由Julia字典表示的话。</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">这个量在文献中又被称为鲍尔条件数、相对条件数或分量相对条件数。</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">这个regex启用了前三个标志。</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">这种关系也是不变的。</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">这将返回 &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; ，现在可以将其传递给其他线性代数函数（例如本 &lt;code&gt;Bidiagonal&lt;/code&gt; 解器），这些函数将对Bidiagonal类型使用专门的方法。</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">本节介绍了Julia的Markdown语法,它是由Markdown标准库启用的。支持以下Markdown元素。</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">这似乎是显而易见的,因为这些时期中的每一个时期中的两个时期仍然均匀地划分到下一个更大的顺序时期。但在两个月的情况下(仍然平均分为一年),答案可能令人吃惊。</target>
        </trans-unit>
        <trans-unit id="a3589971fa43934068938b8a676f4699efd4cc5b" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">这将设置&lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math标志&lt;/a&gt;，并与clang中的 &lt;code&gt;-ffast-math&lt;/code&gt; 选项相对应。有关更多详细信息，请参见&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;性能注释的注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">这将设置&lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math标志&lt;/a&gt;，并与clang中的 &lt;code&gt;-ffast-math&lt;/code&gt; 选项相对应。有关更多详细信息，请参见&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;性能注释的注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a320d47b1e4321c23069852a2c2baadde10da388" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">这将设置&lt;a href=&quot;https://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math标志&lt;/a&gt;，并与clang中的 &lt;code&gt;-ffast-math&lt;/code&gt; 选项相对应。有关更多详细信息，请参见&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;性能注释的注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">此设置将导致 &lt;code&gt;MyArray&lt;/code&gt; 上的 &lt;code&gt;eachindex&lt;/code&gt; 迭代使用整数。如果未指定此特征，则使用默认值 &lt;code&gt;IndexCartesian()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">这应该写成:</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">这种情况只可能发生在无效的UTF-8字符串上。对于有效的UTF-8字符串,连接可以保留字符串中的所有字符和字符串长度的加性。</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">少量的升级规则，再加上类型的构造函数和默认的数字 &lt;code&gt;convert&lt;/code&gt; 方法，足以使有理数与Julia的所有其他数字类型（整数，浮点数和复数）完全自然地互操作。通过以相同的方式提供适当的转换方法和升级规则，任何用户定义的数字类型都可以自然地与Julia的预定义数字进行互操作。</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">但是，使用 &lt;code&gt;eval(quote(...))&lt;/code&gt; 模式进行这种语言内代码生成非常普遍，Julia附带了一个宏来缩写该模式：</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">这种代码风格给语言带来了性能挑战。解析器在将其转换为低级指令时，通过将内部函数提取到单独的代码块中，从而实质上重新组织了上述代码。 &amp;ldquo;俘获&amp;rdquo;的变量，如 &lt;code&gt;r&lt;/code&gt; 由内部函数和它们的封闭范围共享也被提取到堆分配的&amp;ldquo;盒子&amp;rdquo;来内外功能访问，因为该语言指定对 &lt;code&gt;r&lt;/code&gt; 在内部范围必须是相同的 &lt;code&gt;r&lt;/code&gt; 即使在外部作用域（或另一个内部函数）修改了 &lt;code&gt;r&lt;/code&gt; 之后，也可以在外部作用域中使用。</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">此样式点与函数参数特别相关。例如，如果参数实际上可以是用抽象类型&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;表示的整数，则不要将其声明为 &lt;code&gt;Int&lt;/code&gt; 或&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;类型。实际上，在很多情况下，除非需要与其他方法定义进行歧义，否则可以完全省略参数类型，因为如果传递的类型不支持任何必需的操作，则无论如何都会抛出&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;。（这被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;鸭子打字&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="02f73861f45f55f4dfd018f62afadda932fbecbd" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to &lt;code&gt;if a; b else c end&lt;/code&gt;, but is often used to emphasize the value &lt;code&gt;b&lt;/code&gt;-or-&lt;code&gt;c&lt;/code&gt; which is being used as part of a larger expression, rather than the side effects that evaluating &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; may have.</source>
          <target state="translated">此语法等效于 &lt;code&gt;if a; b else c end&lt;/code&gt; ，但通常用于强调值 &lt;code&gt;b&lt;/code&gt; -or- &lt;code&gt;c&lt;/code&gt; ，该值被用作较大表达式的一部分，而不是评估 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 可能产生的副作用。</target>
        </trans-unit>
        <trans-unit id="4b85e4944b2e592e05f80877bae9cf75b7c4b64c" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">此语法与&lt;a href=&quot;#Footnote-references&quot;&gt;Footnote引用&lt;/a&gt;的内联语法配对。确保也阅读该部分。</target>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">此语法与&lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote引用&lt;/a&gt;的内联语法配对。确保也阅读该部分。</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">对于&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions中&lt;/a&gt;引入的简洁的单行函数定义形式，此语法特别有用。尽管很典型，但并不要求 &lt;code&gt;begin&lt;/code&gt; 块必须是多行或 &lt;code&gt;(;)&lt;/code&gt; 链必须是单行：</target>
        </trans-unit>
        <trans-unit id="83194f70ea7b6512bb44658828e86b5786ad5bb1" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;;&lt;/code&gt; chains be single-line:</source>
          <target state="translated">对于&lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions中&lt;/a&gt;引入的简洁的单行函数定义形式，此语法特别有用。尽管很典型，但并不要求 &lt;code&gt;begin&lt;/code&gt; 块必须是多行的 &lt;code&gt;;&lt;/code&gt; 链为单行：</target>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">由于调用看起来像普通的代码块，因此此语法使使用函数更有效地扩展语言变得更加容易。与&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 相比&lt;/a&gt;，有许多可能的用途，例如管理系统状态。例如，有一个&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;版本，该版本运行代码以确保最终关闭打开的文件：</target>
        </trans-unit>
        <trans-unit id="f43fea58e0ae0e5d3bca8325c7f2571bc765f36f" translate="yes" xml:space="preserve">
          <source>This syntax requires at least Julia 1.3.</source>
          <target state="translated">这个语法至少需要Julia 1.3。</target>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">该表可能会在第二列中出现缺失的字符,甚至显示与Julia REPL中渲染的字符不一致的字符。在这些情况下,强烈建议用户检查他们在浏览器和 REPL 环境中选择的字体,因为许多字体的字形存在已知的问题。</target>
        </trans-unit>
        <trans-unit id="a5ba3b718070c3a0261004f71106e6c8df784735" translate="yes" xml:space="preserve">
          <source>This task will wait for five seconds, and then print &lt;code&gt;done&lt;/code&gt;. However, it has not started running yet. We can run it whenever we're ready by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">该任务将等待五秒钟，然后 &lt;code&gt;done&lt;/code&gt; 打印。但是，它尚未开始运行。我们可以随时通过调用&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;运行它：</target>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">这个特质一般用于在预分配特定类型结果的算法和根据产值类型挑选结果类型的算法之间进行选择。</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">这个特性一般用于在为其结果预分配空间的算法和以增量方式调整其结果大小的算法之间进行选择。</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">这种基于特征的方法也存在于标量 &lt;code&gt;+&lt;/code&gt; 的&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;机制中。它使用&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;，在给定两种类型的操作数的情况下，该函数将返回最佳通用类型以计算操作。这样可以减少为每对可能的类型实参对实现每个函数的问题，也可以减少为实现从每种类型到通用类型的转换操作以及首选成对升级规则表的小得多的问题。</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型旨在用于线性代数-有关常规数据处理，请参见&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">在人们考虑如何构造它的实例之前，这种类型可能看起来足够无害。如果 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;SelfReferential&lt;/code&gt; 的实例，则可以通过调用创建第二个实例：</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">这通常意味着存在自定义 &lt;code&gt;==&lt;/code&gt; 或 &lt;code&gt;isequal&lt;/code&gt; 方法的类型必须实现相应的 &lt;code&gt;hash&lt;/code&gt; 方法（反之亦然）。集合通常通过对所有内容进行递归调用 &lt;code&gt;isequal&lt;/code&gt; 来实现 &lt;code&gt;isequal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b28a88f90eb34855ebcb028f2694d128ce6e0f54" translate="yes" xml:space="preserve">
          <source>This version returns &lt;code&gt;s&lt;/code&gt; as before but it also uses the &lt;code&gt;@isdefined&lt;/code&gt; macro to return a boolean indicating whether there is a local variable named &lt;code&gt;t&lt;/code&gt; defined in the function's outermost local scope. As you can see, there is no &lt;code&gt;t&lt;/code&gt; defined outside of the &lt;code&gt;for&lt;/code&gt; loop body. This is because of the hard scope rule again: since the assignment to &lt;code&gt;t&lt;/code&gt; occurs inside of a function, which introduces a hard scope, the assignment causes &lt;code&gt;t&lt;/code&gt; to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named &lt;code&gt;t&lt;/code&gt;, it would make no difference&amp;mdash;the hard scope rule isn't affected by anything in global scope.</source>
          <target state="translated">这个版本像以前一样返回 &lt;code&gt;s&lt;/code&gt; ，但是它也使用 &lt;code&gt;@isdefined&lt;/code&gt; 宏返回一个布尔值，该布尔值指示在函数的最外部局部作用域中是否定义了名为 &lt;code&gt;t&lt;/code&gt; 的局部变量。如您所见，在 &lt;code&gt;for&lt;/code&gt; 循环主体之外没有定义 &lt;code&gt;t&lt;/code&gt; 。这又是由于硬作用域规则所致：由于对 &lt;code&gt;t&lt;/code&gt; 的赋值发生在引入硬作用域的函数内部，因此赋值使 &lt;code&gt;t&lt;/code&gt; 成为出现它的局部范围（即循环内部）中的新局部变量。身体。即使有一个名为 &lt;code&gt;t&lt;/code&gt; 的全局变量，这没有什么区别-硬作用域规则不受全局作用域的任何影响。</target>
        </trans-unit>
        <trans-unit id="732e45fbae13bbb344c9807714543561cca2e0ec" translate="yes" xml:space="preserve">
          <source>This view is similarly selecting every other column from our original &lt;code&gt;A&lt;/code&gt; &amp;mdash; and thus it needs to skip the equivalent of two five-element columns when moving between indices in the second dimension:</source>
          <target state="translated">该视图类似地从原始 &lt;code&gt;A&lt;/code&gt; 中选择其他每列，因此，在第二维的索引之间移动时，它需要跳过等效的两个五元素列：</target>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">这将继续在后台跟踪 &lt;code&gt;path&lt;/code&gt; 更改，直到在同一 &lt;code&gt;path&lt;/code&gt; 上调用 &lt;code&gt;unwatch_folder&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">这将在生成的文档中创建指向&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;文档（具有有关此函数实际功能的更多信息）和&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;文档的链接。最好包括对函数的变异/非变异版本的交叉引用，或者突出显示两个相似函数之间的差异。</target>
        </trans-unit>
        <trans-unit id="b96927e2f1de092a211a143e54dd74f41007bb3e" translate="yes" xml:space="preserve">
          <source>This will not specialize:</source>
          <target state="translated">这不会专门。</target>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">这将返回 &lt;code&gt;(-1, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">这将会触犯一个供给默认padding的方法。</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">这通常是 &lt;code&gt;gitdir(repo)&lt;/code&gt; 的父目录，但在某些情况下可能会有所不同：例如，如果设置了 &lt;code&gt;core.worktree&lt;/code&gt; 配置变量或 &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">此作品，但（你可以使用验证自己 &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; 的问题是，输出类型不能被推断）：参数 &lt;code&gt;N&lt;/code&gt; 是一个&lt;em&gt;价值&lt;/em&gt;型的 &lt;code&gt;Int&lt;/code&gt; ，和类型推断不会（和无法）预先预测其价值。这意味着使用该函数输出的代码必须是保守的，检查 &lt;code&gt;A&lt;/code&gt; 每次访问的类型；这样的代码将非常慢。</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">这将提供具有特定新元素类型的矢量的自定义显示。进行诱人时，应避免这种情况。问题在于用户会期望诸如 &lt;code&gt;Vector()&lt;/code&gt; 之类的知名类型以某种方式运行，而过度自定义其行为会使其更难使用。</target>
        </trans-unit>
        <trans-unit id="ce93190f2d45e03cc3d832dd1dbdeefa914b4a96" translate="yes" xml:space="preserve">
          <source>Those that are parsed like &lt;code&gt;*&lt;/code&gt; (in terms of precedence) include &lt;code&gt;* / &amp;divide; % &amp;amp; &amp;sdot; ∘ &amp;times; |\\| &amp;cap; &amp;and; &amp;otimes; ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ &amp;lowast; ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗&lt;/code&gt; and those that are parsed like &lt;code&gt;+&lt;/code&gt; include &lt;code&gt;+ - |\|| &amp;oplus; ⊖ ⊞ ⊟ |++| &amp;cup; &amp;or; ⊔ &amp;plusmn; ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣&lt;/code&gt; There are many others that are related to arrows, comparisons, and powers.</source>
          <target state="translated">像 &lt;code&gt;*&lt;/code&gt; （按优先级）一样被解析的那些包括 &lt;code&gt;* / &amp;divide; % &amp;amp; &amp;sdot; ∘ &amp;times; |\\| &amp;cap; &amp;and; &amp;otimes; ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ &amp;lowast; ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗&lt;/code&gt; ⩟⩠⫛⊍▷⨝⟕⟖⟗和那些像解析 &lt;code&gt;+&lt;/code&gt; 包括 &lt;code&gt;+ - |\|| &amp;oplus; ⊖ ⊞ ⊟ |++| &amp;cup; &amp;or; ⊔ &amp;plusmn; ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣&lt;/code&gt; many与箭头，比较和功效有关的其他内容。</target>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">尽管大多数代码都可以用Julia编写，但是已经有很多高质量的，成熟的数字计算库已经用C和Fortran编写。为了轻松使用此现有代码，Julia使调用C和Fortran函数变得简单高效。 Julia具有&amp;ldquo;没有样板&amp;rdquo;的理念：可以直接从Julia调用函数，而无需任何&amp;ldquo;胶合&amp;rdquo;代码，代码生成或编译-甚至从交互式提示中也可以。只需使用&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;语法进行适当的调用即可完成，这看起来像是普通的函数调用。</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">思想气球</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">三个连续的等号</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">三维角度</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">三个向左箭头</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">三个向右箭头</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">除非 &lt;code&gt;x isa type&lt;/code&gt; ,否则抛出&lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。语法 &lt;code&gt;x::type&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">如果 &lt;code&gt;cond&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则抛出&lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;。编写断言的首选语法。断言失败时可以选择显示消息 &lt;code&gt;text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果指定索引 &lt;code&gt;I&lt;/code&gt; 不在给定数组 &lt;code&gt;A&lt;/code&gt; 的范围内，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">抛出一个对象作为异常。</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">抛出一个对象而不更改当前的异常回溯。默认参数是当前异常（如果在 &lt;code&gt;catch&lt;/code&gt; 块中调用）。</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">抛出Julia异常</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">拇指向下的标志</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">竖起大拇指签名</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">因此，&lt;em&gt;词法作用域&lt;/em&gt;意味着可以仅从源代码推断变量的范围。</target>
        </trans-unit>
        <trans-unit id="ff70b958cdd14735d439df7f031d3f90247ced00" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can &quot;see&quot; variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.</source>
          <target state="translated">因此，&lt;em&gt;词法作用域&lt;/em&gt;意味着可以从单独出现在代码中的变量中推断出变量所指的含义，而不依赖于程序的执行方式。嵌套在另一个作用域内的作用域可以&amp;ldquo;查看&amp;rdquo;包含该作用域的所有外部作用域中的变量。另一方面，外部作用域看不到内部作用域中的变量。</target>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">因此全局变量只继承读,不继承写。</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">因此，程序应谨慎地在远程调用中引用全局变量。实际上，如果可能的话，最好完全避免使用它们。如果必须引用全局变量，请考虑使用 &lt;code&gt;let&lt;/code&gt; 块来本地化全局变量。</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">因此,一个最小的集群管理器需要。</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">因此，执行&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的任务有效地阻止了Julia调度程序执行任何其他任务，直到调用返回。对于所有对外部库的调用都是如此。例外情况是对自定义C代码的调用，这些代码又返回Julia（可能会产生yield），或者是调用 &lt;code&gt;jl_yield()&lt;/code&gt; 的 C代码（等效于&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; 的&lt;/a&gt; C ）。</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">因此,抽象类型允许程序员编写通用函数,这些函数以后可以被许多具体类型的组合用作默认方法。由于多调度,程序员可以完全控制是使用默认方法还是更具体的方法。</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">因此，尽管 &lt;code&gt;⊘&lt;/code&gt; 运算符通常返回OurRational的实例， &lt;code&gt;OurRational&lt;/code&gt; 如果其两个参数中的任何一个都是复数整数，它都会返回 &lt;code&gt;Complex{OurRational}&lt;/code&gt; 的实例。有兴趣的读者应该考虑细读&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;的其余部分：它简短，自包含，并且实现了整个基本的Julia类型。</target>
        </trans-unit>
        <trans-unit id="d4a7cf3884ed1ab47ea12e5c77940efcf3a6f460" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">因此，具有Julia整数的算术实际上是&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;模数算术的&lt;/a&gt;一种形式。这反映了在现代计算机上实现的整数基础算术的特征。在可能发生溢出的应用中，显式检查溢出产生的环绕是必不可少的。否则，建议改用&lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;任意精度算法中&lt;/a&gt;的&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">因此，具有Julia整数的算术实际上是&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;模数算术的&lt;/a&gt;一种形式。这反映了在现代计算机上实现的整数基础算法的特征。在可能发生溢出的应用中，显式检查溢出产生的环绕是必不可少的。否则，建议改用&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;任意精度算法中&lt;/a&gt;的&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">因此，解析器不知道 &lt;code&gt;r&lt;/code&gt; 具有固定类型（ &lt;code&gt;Int&lt;/code&gt; ）。也不是说 &lt;code&gt;r&lt;/code&gt; 一旦创建内部函数不改变值（使得盒是不需要的）。因此，解析器为box发出代码，该代码包含具有抽象类型（例如 &lt;code&gt;Any&lt;/code&gt; )的对象，该对象需要为 &lt;code&gt;r&lt;/code&gt; 的每次出现进行运行时类型分配。可以通过将 &lt;code&gt;@code_warntype&lt;/code&gt; 应用于上述函数来验证这一点。装箱和运行时类型分派都可能导致性能下降。</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">因此，在可能的情况下，请使用 &lt;code&gt;Int&lt;/code&gt; 文字，并将 &lt;code&gt;Rational{Int}&lt;/code&gt; 用于文字非整数数字，以便更轻松地使用代码。</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">因此,虽然Julia中默认提供的隐式类型参数构造器相当严格,但可以很容易地让它们以更轻松但合理的方式表现出来。此外,由于构造函数可以利用类型系统、方法和多重调度的所有力量,因此定义复杂的行为通常是相当简单的。</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">虎头蛇尾</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">Tilde操作员</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">向左箭头上方的倾斜操作员</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">倾斜式操作员,上面有圆点</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">倾斜的操作员与上升的圆点</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">签名时间。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">时间类型-周期算术</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">计时结果。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">疲惫的脸</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">要访问编码的原始代码单位（用于UTF-8的字节），可以使用&lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt;函数，其中索引 &lt;code&gt;i&lt;/code&gt; 从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ncodeunits(s)&lt;/code&gt; 连续运行。所述&lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt;函数返回一个 &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; 包装，可以访问这些原始CODEUNITS（字节）为一个数组。</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">要添加软件包，请使用 &lt;code&gt;add&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fca3c84bc7bcf6dfd1b3203ec788903367443803" translate="yes" xml:space="preserve">
          <source>To address these scenarios, Julia provides &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s (also known by several other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations). When a piece of computing work (in practice, executing a particular function) is designated as a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, it becomes possible to interrupt it by switching to another &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;. The original &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.</source>
          <target state="translated">为了解决这些情况，Julia提供了&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;（也有几个其他名称，例如对称协程，轻量级线程，协作式多任务处理或单次执行）。当一项计算工作（实际上是执行特定功能）指定为&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 时&lt;/a&gt;，可以通过切换到另一个&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;来中断它。原始&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;稍后可以恢复，届时它将在停下来的地方重新拾起。起初，这似乎类似于函数调用。但是，有两个主要区别。首先，切换任务不占用任何空间，因此可以在不消耗调用堆栈的情况下进行任意数量的任务切换。其次，任务切换可以以任何顺序发生，这与函数调用不同，在函数调用之前，被调用的函数必须先完成执行，然后控制权才能返回到调用函数。</target>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">为了允许使用任意精度的整数和浮点数进行计算，Julia分别包装了&lt;a href=&quot;https://gmplib.org&quot;&gt;GNU多精度算术库（GMP）&lt;/a&gt;和&lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR库&lt;/a&gt;。该&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 有&lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;类型在朱莉娅可供任意精度的整数和分别浮点数。</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">为了允许创建未完全初始化的对象，Julia允许使用少于类型具有的字段数的&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;函数来调用新函数，并返回未初始化未指定字段的对象。然后，内部构造函数方法可以使用不完整的对象，在返回之前完成其初始化。例如，这是定义 &lt;code&gt;SelfReferential&lt;/code&gt; 类型的另一种尝试，这次使用零参数内部构造函数返回实例，该实例具有指向自己的 &lt;code&gt;obj&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">再放大一点,考虑以下函数。</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">为了避免甚至不必定义命名函数，可以使用 &lt;code&gt;do&lt;/code&gt; 语法，该语法可以动态创建一个匿名函数：</target>
        </trans-unit>
        <trans-unit id="7511ec9a398ed68674d80480ecea6a9ca91ed0f1" translate="yes" xml:space="preserve">
          <source>To call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Threads.Condition&lt;/code&gt;, you must first call &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; on it. When &lt;code&gt;wait&lt;/code&gt; is called, the lock is atomically released during blocking, and will be reacquired before &lt;code&gt;wait&lt;/code&gt; returns. Therefore idiomatic use of a &lt;code&gt;Threads.Condition&lt;/code&gt;&lt;code&gt;c&lt;/code&gt; looks like the following:</source>
          <target state="translated">要在 &lt;code&gt;Threads.Condition&lt;/code&gt; 上调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;，必须首先对其调用&lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;。当 &lt;code&gt;wait&lt;/code&gt; 被调用时，锁以原子拦截过程中释放，在此之前将重新获得 &lt;code&gt;wait&lt;/code&gt; 回报。因此， &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 的惯用用法如下所示：</target>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要检查正则表达式是否与字符串匹配，请使用&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">要在第一维（&amp;ldquo;垂直&amp;rdquo;）中进行连接，请使用&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt;或以分号（ &lt;code&gt;[x; y; z]&lt;/code&gt; ）分隔。</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">要连接第二个（&amp;ldquo;水平&amp;rdquo;）维，请使用&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt;或以空格分隔（ &lt;code&gt;[x y z]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">要构造块矩阵（在前两个维度中串联），请使用&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt;或组合空格和分号（ &lt;code&gt;[a b; c d]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c9dbf08e7476ec37f2720092790ffb3b8fd03ca2" translate="yes" xml:space="preserve">
          <source>To customize how instances of a type are displayed, overload &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; rather than &lt;code&gt;display&lt;/code&gt;, as explained in the manual section on &lt;a href=&quot;../../manual/types/index#man-custom-pretty-printing&quot;&gt;custom pretty-printing&lt;/a&gt;.</source>
          <target state="translated">要自定义类型实例的显示方式，请重载&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;display&lt;/code&gt; ，如有关&lt;a href=&quot;../../manual/types/index#man-custom-pretty-printing&quot;&gt;自定义漂亮打印&lt;/a&gt;的手册部分所述。</target>
        </trans-unit>
        <trans-unit id="99653d877bbee5b290b6ca0e94590ab093ad658f" translate="yes" xml:space="preserve">
          <source>To customize human-readable text output for objects of type &lt;code&gt;T&lt;/code&gt;, define &lt;code&gt;show(io::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; instead. Checking the &lt;code&gt;:compact&lt;/code&gt;&lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; property of &lt;code&gt;io&lt;/code&gt; in such methods is recommended, since some containers show their elements by calling this method with &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt;.</source>
          <target state="translated">要为类型 &lt;code&gt;T&lt;/code&gt; 的对象自定义人类可读的文本输出，请改为定义 &lt;code&gt;show(io::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; 。建议使用这种方法检查 &lt;code&gt;io&lt;/code&gt; 的 &lt;code&gt;:compact&lt;/code&gt; &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;属性，因为某些容器通过使用 &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; 调用此方法来显示其元素。</target>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">要使用多种方法定义一个函数，只需简单地多次定义函数，并使用不同数量和类型的参数即可。函数的第一个方法定义创建函数对象，随后的方法定义将新方法添加到现有函数对象。应用该函数时，将执行与参数的数量和类型匹配的最具体的方法定义。因此，以上两个方法定义共同定义了抽象类型 &lt;code&gt;Number&lt;/code&gt; 的所有实例对上 &lt;code&gt;f&lt;/code&gt; 的行为-但具有特定于&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值对的不同行为。如果参数之一是64位浮点数，而另一个不是，则 &lt;code&gt;f(Float64,Float64)&lt;/code&gt; 无法调用该方法，必须使用更通用的 &lt;code&gt;f(Number,Number)&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="021f78e4d9ed5f18a45c45e25c0e08e2b86fc477" translate="yes" xml:space="preserve">
          <source>To define a new &lt;code&gt;rand&lt;/code&gt; method for an hypothetical &lt;code&gt;MyRNG&lt;/code&gt; generator, and a value specification &lt;code&gt;s&lt;/code&gt; (e.g. &lt;code&gt;s == Int&lt;/code&gt;, or &lt;code&gt;s == 1:10&lt;/code&gt;) of type &lt;code&gt;S==typeof(s)&lt;/code&gt; or &lt;code&gt;S==Type{s}&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is a type, the same two methods as we saw before must be defined:</source>
          <target state="translated">定义一个新的 &lt;code&gt;rand&lt;/code&gt; 用于假想方法 &lt;code&gt;MyRNG&lt;/code&gt; 发生器，和一个值规范 &lt;code&gt;s&lt;/code&gt; （例如 &lt;code&gt;s == Int&lt;/code&gt; ，或 &lt;code&gt;s == 1:10&lt;/code&gt; ）类型的 &lt;code&gt;S==typeof(s)&lt;/code&gt; 或 &lt;code&gt;S==Type{s}&lt;/code&gt; 如果 &lt;code&gt;s&lt;/code&gt; 是一个类型，必须定义与我们之前看到的相同的两个方法：</target>
        </trans-unit>
        <trans-unit id="3e9f8911771a0e2e2a0a5444620f45dabaeaf75f" translate="yes" xml:space="preserve">
          <source>To demonstrate these issues, let us consider writing a &lt;code&gt;@time&lt;/code&gt; macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:</source>
          <target state="translated">为了演示这些问题，让我们考虑编写一个 &lt;code&gt;@time&lt;/code&gt; 宏，该宏将表达式作为参数，记录时间，对表达式求值，再次记录时间，打印之前和之后时间之间的差，然后得到值表达式作为最终值。宏可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="1e958f0a47bef2b5712e58abc88f1cd0cfc60a1f" translate="yes" xml:space="preserve">
          <source>To demonstrate, we might rewrite the &lt;code&gt;@time&lt;/code&gt; example above as:</source>
          <target state="translated">为了演示，我们可以将上面的 &lt;code&gt;@time&lt;/code&gt; 示例重写为：</target>
        </trans-unit>
        <trans-unit id="e21d833954293a006de2f75f7b9609e75185bac1" translate="yes" xml:space="preserve">
          <source>To determine when a file was modified, compare &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; to detect notification of changes. However, using &lt;a href=&quot;#FileWatching.watch_file&quot;&gt;&lt;code&gt;watch_file&lt;/code&gt;&lt;/a&gt; for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.</source>
          <target state="translated">要确定何时修改文件，请比较 &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; 以检测更改通知。但是，首选使用&lt;a href=&quot;#FileWatching.watch_file&quot;&gt; &lt;code&gt;watch_file&lt;/code&gt; &lt;/a&gt;进行此操作，因为它在某些情况下可能不可用，因为它更可靠，更有效。</target>
        </trans-unit>
        <trans-unit id="8be4728a2375d8712deda132de2e0a083b597cad" translate="yes" xml:space="preserve">
          <source>To determine whether an item is not in a given collection, see &lt;a href=&quot;#Base.:%E2%88%89&quot;&gt;&lt;code&gt;:&amp;notin;&lt;/code&gt;&lt;/a&gt;. You may also negate the &lt;code&gt;in&lt;/code&gt; by doing &lt;code&gt;!(a in b)&lt;/code&gt; which is logically similar to &quot;not in&quot;.</source>
          <target state="translated">要确定某项是否不在给定的集合中，请参阅&lt;a href=&quot;#Base.:%E2%88%89&quot;&gt; &lt;code&gt;:&amp;notin;&lt;/code&gt; &lt;/a&gt;。您也可以通过执行 &lt;code&gt;!(a in b)&lt;/code&gt; 来取反 &lt;code&gt;in&lt;/code&gt; ，这在逻辑上类似于&amp;ldquo; not in&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f95f5439d369c4ea0678d04f0efd9b2968e81782" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="translated">为了方便地对数学运算和其他运算进行矢量化，Julia&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;提供了点语法&lt;/a&gt; &lt;code&gt;f.(args...)&lt;/code&gt; ，例如 &lt;code&gt;sin.(x)&lt;/code&gt; 或 &lt;code&gt;min.(x,y)&lt;/code&gt; ，用于对数组或数组和标量的混合进行逐元素运算（&lt;a href=&quot;#Broadcasting&quot;&gt;广播&lt;/a&gt;操作）；当与其他点调用（例如 &lt;code&gt;sin.(cos.(x))&lt;/code&gt; 结合使用时，这些方法还具有&amp;ldquo;融合&amp;rdquo;到单个循环中的附加优点。</target>
        </trans-unit>
        <trans-unit id="aeb1602cac2df929c4186b626049a5c2b1947830" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="translated">为了方便数学和其他运算的矢量化，Julia &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;提供了点语法&lt;/a&gt; &lt;code&gt;f.(args...)&lt;/code&gt; ，例如 &lt;code&gt;sin.(x)&lt;/code&gt; 或 &lt;code&gt;min.(x,y)&lt;/code&gt; ，用于对数组或数组和标量的混合进行元素式运算（&lt;a href=&quot;#Broadcasting-1&quot;&gt;广播&lt;/a&gt;操作）；当与其他点调用（例如 &lt;code&gt;sin.(cos.(x))&lt;/code&gt; 结合使用时，这些方法还具有&amp;ldquo;融合&amp;rdquo;到单个循环中的附加优点。</target>
        </trans-unit>
        <trans-unit id="4881f7b56909ffe39aad882ec50ca3bf70065833" translate="yes" xml:space="preserve">
          <source>To end this short exposure to external packages, we can consider &lt;code&gt;MPI.jl&lt;/code&gt;, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.</source>
          <target state="translated">为了结束对外部程序包的短暂了解，我们可以考虑 &lt;code&gt;MPI.jl&lt;/code&gt; （MPI协议的Julia包装器）。考虑到每个内部功能都将花费很长时间，因此最好是简单地了解用于实现协议的方法。</target>
        </trans-unit>
        <trans-unit id="c43fc002027f4db455fa1bdf710dfb8409261bff" translate="yes" xml:space="preserve">
          <source>To ensure that the file can be opened at the given line, you may need to call &lt;code&gt;define_editor&lt;/code&gt; first.</source>
          <target state="translated">为了确保可以在给定的行中打开文件，您可能需要先调用 &lt;code&gt;define_editor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="489d97da9ae4b28c1ee31bbdf2fe4066c4d9aee9" translate="yes" xml:space="preserve">
          <source>To evaluate expressions written in a source file &lt;code&gt;file.jl&lt;/code&gt;, write &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">要评估写在源文件 &lt;code&gt;file.jl&lt;/code&gt; 中的表达式，请编写 &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="962778343f824ab64f6e67f07132dd6412ec3b62" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;CTRL-D&lt;/code&gt; (press the Control/&lt;code&gt;^&lt;/code&gt; key together with the &lt;code&gt;d&lt;/code&gt; key), or type &lt;code&gt;exit()&lt;/code&gt;. When run in interactive mode, &lt;code&gt;julia&lt;/code&gt; displays a banner and prompts the user for input. Once the user has entered a complete expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and hits enter, the interactive session evaluates the expression and shows its value. If an expression is entered into an interactive session with a trailing semicolon, its value is not shown. The variable &lt;code&gt;ans&lt;/code&gt; is bound to the value of the last evaluated expression whether it is shown or not. The &lt;code&gt;ans&lt;/code&gt; variable is only bound in interactive sessions, not when Julia code is run in other ways.</source>
          <target state="translated">要退出交互式会话，请键入 &lt;code&gt;CTRL-D&lt;/code&gt; （同时按Control / &lt;code&gt;^&lt;/code&gt; 键和 &lt;code&gt;d&lt;/code&gt; 键），或键入 &lt;code&gt;exit()&lt;/code&gt; 。在交互模式下运行时， &lt;code&gt;julia&lt;/code&gt; 将显示横幅，并提示用户输入。用户输入完整的表达式（例如 &lt;code&gt;1 + 2&lt;/code&gt; ）并按回车后，交互式会话将评估该表达式并显示其值。如果表达式以尾部分号输入到交互式会话中，则不会显示其值。无论是否显示，变量 &lt;code&gt;ans&lt;/code&gt; 都绑定到最后一个求值表达式的值。该 &lt;code&gt;ans&lt;/code&gt; 变量仅在交互式会话中绑定，而在以其他方式运行Julia代码时则不绑定。</target>
        </trans-unit>
        <trans-unit id="efa7a75658fed01212612bb6890412e7df41c343" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;^D&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;d&lt;/code&gt; key on a blank line &amp;ndash; or type &lt;code&gt;exit()&lt;/code&gt; followed by the return or enter key. The REPL greets you with a banner and a &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">要退出交互式会话，请键入 &lt;code&gt;^D&lt;/code&gt; （控制键以及空白行上的 &lt;code&gt;d&lt;/code&gt; 键），或键入 &lt;code&gt;exit()&lt;/code&gt; ,后跟return或Enter键。REPL用标语和 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 提示向您致意。</target>
        </trans-unit>
        <trans-unit id="112540091595511d77b03fc13bb20dcaf3704da2" translate="yes" xml:space="preserve">
          <source>To extend &lt;code&gt;round&lt;/code&gt; to new numeric types, it is typically sufficient to define &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt;.</source>
          <target state="translated">为了将 &lt;code&gt;round&lt;/code&gt; 入扩展到新的数字类型，通常只需定义 &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195ad355d3d21e9f09e35cca5f9f687ede9688d3" translate="yes" xml:space="preserve">
          <source>To facilitate chaining, the operator associates from right to left.</source>
          <target state="translated">为了方便连锁,操作者从右到左联想。</target>
        </trans-unit>
        <trans-unit id="0b86b2585faadb1e7b87fb8f83afa86601547bb7" translate="yes" xml:space="preserve">
          <source>To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a &lt;em&gt;method&lt;/em&gt;. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.</source>
          <target state="translated">为了方便顺利地使用同一概念的许多不同实现，不需要一次定义所有函数，而可以通过为参数类型和计数的某些组合提供特定行为来分段定义函数。一种功能可能的行为的定义称为&lt;em&gt;方法&lt;/em&gt;。到目前为止，我们仅介绍了用单个方法定义的函数示例，这些函数适用于所有类型的参数。但是，可以对方法定义的签名进行注释，以指示参数的类型以及它们的数量，并且可以提供多个方法定义。将函数应用于特定的参数元组时，将应用适用于这些参数的最特定的方法。因此，功能的整体行为是其各种方法定义的行为的拼凑而成。如果拼凑而成的设计得当，即使方法的实现可能完全不同，该函数的向外行为也将显得无缝且一致。</target>
        </trans-unit>
        <trans-unit id="685da3713fd32cec996f6d8bc31bd51d482869ca" translate="yes" xml:space="preserve">
          <source>To get your TTY size,</source>
          <target state="translated">要获得你的TTY尺寸。</target>
        </trans-unit>
        <trans-unit id="18e5dfa5bee5af4e19ea61c8f359c20a393fe69f" translate="yes" xml:space="preserve">
          <source>To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia's &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</source>
          <target state="translated">为了给出一个实际的示例，说明如何使用所有这些参数类型的机器，这是Julia的&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;不可变类型的实际定义（除了为简单起见，这里省略了构造函数），它表示整数的精确比例：</target>
        </trans-unit>
        <trans-unit id="75c2b4412f89f47fcb218ff2c8fc9993a26854fc" translate="yes" xml:space="preserve">
          <source>To implement this specialization for &lt;code&gt;MyRNG&lt;/code&gt; and for a specification &lt;code&gt;s&lt;/code&gt;, producing elements of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt;, where &lt;code&gt;SamplerS&lt;/code&gt; is the type of the sampler returned by &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt;. Instead of &lt;code&gt;AbstractArray&lt;/code&gt;, it's possible to implement the functionality only for a subtype, e.g. &lt;code&gt;Array{S}&lt;/code&gt;. The non-mutating array method of &lt;code&gt;rand&lt;/code&gt; will automatically call this specialization internally.</source>
          <target state="translated">为了对 &lt;code&gt;MyRNG&lt;/code&gt; 和规格 &lt;code&gt;s&lt;/code&gt; 实现这种特殊化，产生类型 &lt;code&gt;S&lt;/code&gt; 的元素，可以定义以下方法： &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt; ，其中 &lt;code&gt;SamplerS&lt;/code&gt; 是 &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt; 返回的采样器类型。除了 &lt;code&gt;AbstractArray&lt;/code&gt; 之外，还可以仅对子类型（例如 &lt;code&gt;Array{S}&lt;/code&gt; 实现功能。 &lt;code&gt;rand&lt;/code&gt; 的非变异数组方法将在内部自动调用此专业化。</target>
        </trans-unit>
        <trans-unit id="5abb5f441f651501d418ed7d715b551afc8ae682" translate="yes" xml:space="preserve">
          <source>To include a backtick character within literal text use three backticks rather than one to enclose the text.</source>
          <target state="translated">要在字面文本中包含一个回车键字符,请使用三个回车键而不是一个回车键来包围文本。</target>
        </trans-unit>
        <trans-unit id="57aafd915b8744c5b807fb8c566670246a4bbec8" translate="yes" xml:space="preserve">
          <source>To include a literal &lt;code&gt;$&lt;/code&gt; in a string literal, escape it with a backslash:</source>
          <target state="translated">要将文字 &lt;code&gt;$&lt;/code&gt; 包含在字符串文字中，请使用反斜杠对其进行转义：</target>
        </trans-unit>
        <trans-unit id="911d758b9209b3d7402bd8133b67ca7a1ddf60e0" translate="yes" xml:space="preserve">
          <source>To indicate that the output result is truncated, you may write &lt;code&gt;[...]&lt;/code&gt; at the line where checking should stop. This is useful to hide a stacktrace (which contains non-permanent references to lines of julia code) when the doctest shows that an exception is thrown, for example:</source>
          <target state="translated">为了指示输出结果被截断，您可以在应停止检查的行上写入 &lt;code&gt;[...]&lt;/code&gt; 。当doctest显示抛出异常时，这对于隐藏stacktrace（包含对julia代码行的非永久引用）很有用，例如：</target>
        </trans-unit>
        <trans-unit id="bc826a295b20ebe4ca4b7027a22bd794fb5707c0" translate="yes" xml:space="preserve">
          <source>To insert &lt;code&gt;replacement&lt;/code&gt; before an index &lt;code&gt;n&lt;/code&gt; without removing any items, use &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt;.</source>
          <target state="translated">要在索引 &lt;code&gt;n&lt;/code&gt; 之前插入 &lt;code&gt;replacement&lt;/code&gt; 项而不删除任何项目，请使用 &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1254256d236772cc78d0a2e9b923db6bf919f9ea" translate="yes" xml:space="preserve">
          <source>To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:</source>
          <target state="translated">为了保持简单,我们从一个1D数组开始。创建一个包含长度为10的Float64元素的数组的方法是:。</target>
        </trans-unit>
        <trans-unit id="8199f62d4f59aa3fc75b15e0a259ff3e40e0a51d" translate="yes" xml:space="preserve">
          <source>To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute &lt;code&gt;addprocs&lt;/code&gt; in its own task.</source>
          <target state="translated">要在不阻止REPL的情况下启动工作程序，或者如果以编程方式启动工作程序， &lt;code&gt;addprocs&lt;/code&gt; 包含包含功能，请在其自己的任务中执行addprocs。</target>
        </trans-unit>
        <trans-unit id="00ab4bffe8af922f0b9025c505c1b0b45cd720f2" translate="yes" xml:space="preserve">
          <source>To list all the instances of an enum use &lt;code&gt;instances&lt;/code&gt;, e.g.</source>
          <target state="translated">要列出一个枚举的所有实例，请使用 &lt;code&gt;instances&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="7c1bcc9adb11774306436860ba8fa8832de24b31" translate="yes" xml:space="preserve">
          <source>To load a module, two main keywords can be used: &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;. To understand their differences, consider the following example:</source>
          <target state="translated">要加载模块，可以使用两个主要关键字： &lt;code&gt;using&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 。要了解它们之间的差异，请考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="1484daa3c86481c79c70bc5444871ebf78a284a7" translate="yes" xml:space="preserve">
          <source>To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</source>
          <target state="translated">为了使常见的数字公式和表达式更加清晰,Julia允许变量前面立即加上数字文字,意味着乘法。这使得多项式表达式的书写更加简洁。</target>
        </trans-unit>
        <trans-unit id="e9809512202b8f4f9e1d3eed9dff9a39e7fbe9d3" translate="yes" xml:space="preserve">
          <source>To make it easier to write documentation, the parser treats the macro name &lt;code&gt;@doc&lt;/code&gt; specially: if a call to &lt;code&gt;@doc&lt;/code&gt; has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro. Therefore the following syntax is parsed as a 2-argument call to &lt;code&gt;@doc&lt;/code&gt;:</source>
          <target state="translated">为了使编写文档更容易，解析器将对宏名称 &lt;code&gt;@doc&lt;/code&gt; 进行特殊处理：如果对 &lt;code&gt;@doc&lt;/code&gt; 的调用具有一个参数，但在换行符后出现另一个表达式，则该附加表达式将作为该参数添加到宏中。因此，以下语法被解析为 &lt;code&gt;@doc&lt;/code&gt; 的2参数调用：</target>
        </trans-unit>
        <trans-unit id="83af23997915ae15ff2f3b65db53b150559fdcfe" translate="yes" xml:space="preserve">
          <source>To make things easier, the symbol &lt;code&gt;:any&lt;/code&gt; can be passed to [&lt;code&gt;@spawnat&lt;/code&gt;], which picks where to do the operation for you:</source>
          <target state="translated">为了使事情变得容易，可以将符号 &lt;code&gt;:any&lt;/code&gt; 传递给[ &lt;code&gt;@spawnat&lt;/code&gt; ]，该符号为您选择在何处进行操作：</target>
        </trans-unit>
        <trans-unit id="7f47e315ab3527a05dae0afbff5487e713054912" translate="yes" xml:space="preserve">
          <source>To measure allocation line-by-line, start Julia with the &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; command-line option, for which you can choose &lt;code&gt;none&lt;/code&gt; (the default, do not measure allocation), &lt;code&gt;user&lt;/code&gt; (measure memory allocation everywhere except Julia's core code), or &lt;code&gt;all&lt;/code&gt; (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with &lt;code&gt;.mem&lt;/code&gt; appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The &lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt;&lt;code&gt;Coverage&lt;/code&gt; package&lt;/a&gt; contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.</source>
          <target state="translated">要逐行测量分配，请使用 &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; 命令行选项启动Julia ，为此您可以选择 &lt;code&gt;none&lt;/code&gt; 选择（默认，不测量分配）， &lt;code&gt;user&lt;/code&gt; （在所有位置测量内存分配，除了朱莉娅的核心代码），或 &lt;code&gt;all&lt;/code&gt; （测量朱莉娅代码每一行的内存分配）。分配将针对已编译代码的每一行进行度量。退出Julia时，累积结果将写入文件名称后附加 &lt;code&gt;.mem&lt;/code&gt; 的文本文件中，该文件与源文件位于同一目录中。每行列出分配的字节总数。该&lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt; &lt;code&gt;Coverage&lt;/code&gt; 包&lt;/a&gt; 包含一些基本分析工具，例如，按分配的字节数顺序对行进行排序。</target>
        </trans-unit>
        <trans-unit id="55a59a811688ae0a09c9c081d6eacd92c8c0ce25" translate="yes" xml:space="preserve">
          <source>To orchestrate more advanced work distribution patterns, &lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; can be used in conjunction with &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructors to explicitly link a set of channels with a set of producer/consumer tasks.</source>
          <target state="translated">为了编排更高级的工作分配模式，可以将&lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;构造函数结合使用，以将一组通道与一组生产者/消费者任务显式链接。</target>
        </trans-unit>
        <trans-unit id="88891fe439361664a726897679e596b4ddf0b648" translate="yes" xml:space="preserve">
          <source>To override these defaults, you can define a custom &lt;code&gt;BroadcastStyle&lt;/code&gt; for your object:</source>
          <target state="translated">要覆盖这些默认值，可以为对象定义自定义的 &lt;code&gt;BroadcastStyle&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e77e7d4476c074003412309908eb0f580d2e357" translate="yes" xml:space="preserve">
          <source>To pass an array &lt;code&gt;A&lt;/code&gt; as a pointer of a different type &lt;em&gt;without&lt;/em&gt; converting the data beforehand (for example, to pass a &lt;code&gt;Float64&lt;/code&gt; array to a function that operates on uninterpreted bytes), you can declare the argument as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;.</source>
          <target state="translated">要将数组 &lt;code&gt;A&lt;/code&gt; 作为不同类型的指针传递&lt;em&gt;而无需&lt;/em&gt;事先转换数据（例如，将 &lt;code&gt;Float64&lt;/code&gt; 数组传递给对未解释字节进行操作的函数），可以将参数声明为 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a6e640cde5e775ecaa007f5b2352c84dabd421" translate="yes" xml:space="preserve">
          <source>To provide extra type information to the compiler, which can then improve performance in some cases</source>
          <target state="translated">为编译器提供额外的类型信息,从而在某些情况下提高性能。</target>
        </trans-unit>
        <trans-unit id="0378c13c470b1c82f603ba161f8d44139e199b76" translate="yes" xml:space="preserve">
          <source>To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要随机置换任意向量，请参见&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41ee867278b2aedd0d53b55cf8896f331cca7dbe" translate="yes" xml:space="preserve">
          <source>To read every line from &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt;&lt;code&gt;eachline&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要从&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; 中&lt;/a&gt;读取每一行，可以使用&lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt; &lt;code&gt;eachline&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b518f1536e23e8203566d1b1cfa014affb065edc" translate="yes" xml:space="preserve">
          <source>To recap, two essential properties define immutability in Julia:</source>
          <target state="translated">概括地说,在Julia中,有两个基本属性定义了不变性。</target>
        </trans-unit>
        <trans-unit id="3337fde1fe683c82cc86c991764b6058738e2732" translate="yes" xml:space="preserve">
          <source>To remove packages, use &lt;code&gt;rm&lt;/code&gt;:</source>
          <target state="translated">要删除软件包，请使用 &lt;code&gt;rm&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="14bc0723b7cb80976b33a13b7846798f89f200c9" translate="yes" xml:space="preserve">
          <source>To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments must be passed to the call invoked on the local node. Calls on remote nodes will always operate on copies of arguments.</source>
          <target state="translated">重复一下,在一般情况下,这不是一个问题。如果本地节点也被用作计算节点,并且调用后使用的参数,则需要考虑到这种行为,如果需要,必须将参数的深层副本传递给在本地节点上调用。远程节点上的调用将始终在参数的副本上操作。</target>
        </trans-unit>
        <trans-unit id="0f95a56d7e12d8a1364b795c70b8b074db4e5914" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="translated">要从统计意义上表示丢失的数据（R中为 &lt;code&gt;NA&lt;/code&gt; 或SQL中为 &lt;code&gt;NULL&lt;/code&gt; ），请使用&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;对象。有关更多详细信息，请参见&amp;ldquo;&lt;a href=&quot;../missing/index#missing&quot;&gt; &lt;code&gt;Missing Values&lt;/code&gt; &lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="aae4959b7ce22135d2a8a5e52c24ae41734ed81e" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing-1&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="translated">要从统计意义上表示丢失的数据（R中为 &lt;code&gt;NA&lt;/code&gt; 或SQL中为 &lt;code&gt;NULL&lt;/code&gt; ），请使用&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;对象。有关更多详细信息，请参见&amp;ldquo; &lt;a href=&quot;../missing/index#missing-1&quot;&gt; &lt;code&gt;Missing Values&lt;/code&gt; &lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="7a42a57073f63eda82c8f34e187355b8a55592f7" translate="yes" xml:space="preserve">
          <source>To return a new permutation, use &lt;code&gt;v[p]&lt;/code&gt;. Note that this is generally faster than &lt;code&gt;permute!(v,p)&lt;/code&gt; for large vectors.</source>
          <target state="translated">要返回新的排列，请使用 &lt;code&gt;v[p]&lt;/code&gt; 。请注意，对于大向量而言，这通常比 &lt;code&gt;permute!(v,p)&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="b43086127fab6b61eddd060c4ab1a5c67fe3f40b" translate="yes" xml:space="preserve">
          <source>To run code in a file non-interactively, you can give it as the first argument to the &lt;code&gt;julia&lt;/code&gt; command:</source>
          <target state="translated">要以非交互方式在文件中运行代码，可以将其作为 &lt;code&gt;julia&lt;/code&gt; 命令的第一个参数：</target>
        </trans-unit>
        <trans-unit id="31db79e8dfaa63f030f5e043edf7eb3288ba9c8b" translate="yes" xml:space="preserve">
          <source>To see the &lt;code&gt;UniformScaling&lt;/code&gt; operator in action:</source>
          <target state="translated">要查看运行中的 &lt;code&gt;UniformScaling&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="14eeb4620d461f92f19ad75b427c889e5f871fa2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there are several graphical browsers. One &quot;family&quot; of visualizers is based on &lt;a href=&quot;https://github.com/timholy/FlameGraphs.jl&quot;&gt;FlameGraphs.jl&lt;/a&gt;, with each family member providing a different user interface:</source>
          <target state="translated">要查看分析结果，有几种图形浏览器。可视化工具的一个&amp;ldquo;家族&amp;rdquo;基于&lt;a href=&quot;https://github.com/timholy/FlameGraphs.jl&quot;&gt;FlameGraphs.jl&lt;/a&gt;，每个家族成员提供一个不同的用户界面：</target>
        </trans-unit>
        <trans-unit id="acf8c3f0dc9d9a3a4b278d4d342f1e20d2ccbfc2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there is a &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;graphical browser&lt;/a&gt; available, but here we'll use the text-based display that comes with the standard library:</source>
          <target state="translated">要查看分析结果，可以使用&lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;图形浏览器&lt;/a&gt;，但是这里我们将使用标准库随附的基于文本的显示：</target>
        </trans-unit>
        <trans-unit id="ec3664c20b57cfea56dfe265259865dc89ffd6ee" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these constructors, consider the following examples:</source>
          <target state="translated">为了了解我们可以将维度传递给这些构造函数的各种方式,请考虑以下例子。</target>
        </trans-unit>
        <trans-unit id="b562caf38673e98867f8d24249d28785455823ef" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these functions, consider the following examples:</source>
          <target state="translated">为了了解我们可以将维度传递给这些函数的各种方式,请考虑以下例子。</target>
        </trans-unit>
        <trans-unit id="dd84751a56be507d9887116a70caf40018058b32" translate="yes" xml:space="preserve">
          <source>To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions. Applied to the &lt;code&gt;sub2ind&lt;/code&gt; example above, it would look like this:</source>
          <target state="translated">为了解决此问题，该语言提供了用于编写正常的，非生成的生成函数的替代实现的语法。应用于上面的 &lt;code&gt;sub2ind&lt;/code&gt; 示例，它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="54282ab58b68c2496b0103219b8718109152a291" translate="yes" xml:space="preserve">
          <source>To sort an array in-place, use the &quot;bang&quot; version of the sort function:</source>
          <target state="translated">要对一个数组进行原地排序,请使用 &quot;bang &quot;版本的排序函数。</target>
        </trans-unit>
        <trans-unit id="7211b367ac9e62dd165b6cef64e18a2d04d92c28" translate="yes" xml:space="preserve">
          <source>To sort slices of an array, refer to &lt;a href=&quot;#Base.sortslices&quot;&gt;&lt;code&gt;sortslices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要对数组的切片进行排序，请参考&lt;a href=&quot;#Base.sortslices&quot;&gt; &lt;code&gt;sortslices&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6eff1f59edaf0f06ebb9ad646cdc71f40b39d99" translate="yes" xml:space="preserve">
          <source>To test whether an array element is defined, use &lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt;&lt;code&gt;isassigned&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">要测试是否定义了数组元素，请使用&lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt; &lt;code&gt;isassigned&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01c8720e122ebab6d2066fc725c6565609e09aa5" translate="yes" xml:space="preserve">
          <source>To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to &lt;code&gt;listen&lt;/code&gt; will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:</source>
          <target state="translated">对于熟悉Unix套接字API的人来说，方法名称会感到很熟悉，尽管它们的用法比原始的Unix套接字API更简单。在这种情况下，第一个 &lt;code&gt;listen&lt;/code&gt; 调用将创建一个服务器，等待指定端口（2000）上的传入连接。相同的功能也可以用于创建其他各种服务器：</target>
        </trans-unit>
        <trans-unit id="86225ac570f468a04ae4083e4730243b1b54f060" translate="yes" xml:space="preserve">
          <source>To turn debug logging on from the REPL, set &lt;code&gt;ENV[&quot;JULIA_DEBUG&quot;]&lt;/code&gt; to the name of the module of interest. Functions defined in the REPL belong to module &lt;code&gt;Main&lt;/code&gt;; logging for them can be enabled like this:</source>
          <target state="translated">要从REPL打开调试日志，请将 &lt;code&gt;ENV[&quot;JULIA_DEBUG&quot;]&lt;/code&gt; 设置为目标模块的名称。REPL中定义的功能属于 &lt;code&gt;Main&lt;/code&gt; 模块；可以像这样启用它们的日志记录：</target>
        </trans-unit>
        <trans-unit id="37782f88e79a30a638fe1c4b17869179913336be" translate="yes" xml:space="preserve">
          <source>To update all installed packages, use &lt;code&gt;update&lt;/code&gt; without any arguments:</source>
          <target state="translated">要更新所有已安装的软件包，请使用不带任何参数的 &lt;code&gt;update&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f5d769d3a6a2a22d1c9a917d6ffd8d8e3ba2035" translate="yes" xml:space="preserve">
          <source>To use module functions, use &lt;code&gt;import Module&lt;/code&gt; to import the module, and &lt;code&gt;Module.fn(x)&lt;/code&gt; to use the functions.</source>
          <target state="translated">要使用模块功能，请使用 &lt;code&gt;import Module&lt;/code&gt; 导入模块，并使用 &lt;code&gt;Module.fn(x)&lt;/code&gt; 来使用功能。</target>
        </trans-unit>
        <trans-unit id="c9e2a6c247a0a520e69b509cc364e0a77e00dcc4" translate="yes" xml:space="preserve">
          <source>Together, these two methods generate an infinite recursion with &lt;code&gt;A&lt;/code&gt; constantly growing bigger.</source>
          <target state="translated">这两种方法一起产生无限递归，而 &lt;code&gt;A&lt;/code&gt; 不断增大。</target>
        </trans-unit>
        <trans-unit id="0a527316e82cb18df4aebd0b111b71ab441d9fae" translate="yes" xml:space="preserve">
          <source>Toilet</source>
          <target state="translated">Toilet</target>
        </trans-unit>
        <trans-unit id="3068a31d1f4455b374321b9ea25711d164d193a2" translate="yes" xml:space="preserve">
          <source>Tokyo Tower</source>
          <target state="translated">东京塔</target>
        </trans-unit>
        <trans-unit id="85cd2366c323520d4f6ca54daa5ce7108263ec82" translate="yes" xml:space="preserve">
          <source>Tomato</source>
          <target state="translated">Tomato</target>
        </trans-unit>
        <trans-unit id="2c0af9c54fe52a8117bb6a8ffd7c31c20e12b7e9" translate="yes" xml:space="preserve">
          <source>Tongue</source>
          <target state="translated">Tongue</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a47d5ff7493944bba18ff7a622f259b12c79f21f" translate="yes" xml:space="preserve">
          <source>Tools for collecting and manipulating stack traces. Mainly used for building errors.</source>
          <target state="translated">收集和操作堆栈痕迹的工具。主要用于建立错误。</target>
        </trans-unit>
        <trans-unit id="3e83cb174ec130f0f93f810a0b44e22e6201ed95" translate="yes" xml:space="preserve">
          <source>Top Curly Bracket</source>
          <target state="translated">顶部卷曲支架</target>
        </trans-unit>
        <trans-unit id="f2d046811da3fdc34f49d7fc3a74c1883f787a1c" translate="yes" xml:space="preserve">
          <source>Top Hat</source>
          <target state="translated">帽子</target>
        </trans-unit>
        <trans-unit id="fc078810ae21519f9debbccf082738a4563290fe" translate="yes" xml:space="preserve">
          <source>Top Left Corner</source>
          <target state="translated">左上角</target>
        </trans-unit>
        <trans-unit id="c1653a7564996eb5d9b98bcaeb8e7f6800ad78ed" translate="yes" xml:space="preserve">
          <source>Top Right Corner</source>
          <target state="translated">右上角</target>
        </trans-unit>
        <trans-unit id="0db2fdee55ffa3d8617249d91bb7c7e0a1fd08cd" translate="yes" xml:space="preserve">
          <source>Top Square Bracket</source>
          <target state="translated">顶方支架</target>
        </trans-unit>
        <trans-unit id="feae3638873ff76a7d306f4a128884d7a27289e2" translate="yes" xml:space="preserve">
          <source>Top With Upwards Arrow Above</source>
          <target state="translated">上方有向上的箭头</target>
        </trans-unit>
        <trans-unit id="7d0d5998569f1576a0f2ba8a5349d65f84435b8c" translate="yes" xml:space="preserve">
          <source>Toplevel elements</source>
          <target state="translated">Toplevel要素</target>
        </trans-unit>
        <trans-unit id="38c33375ac13545f89d5e835135e4a9e0cee1eb3" translate="yes" xml:space="preserve">
          <source>Tractor</source>
          <target state="translated">Tractor</target>
        </trans-unit>
        <trans-unit id="77b5fefa8d9a6d18651c91b1b665b4e10f4d869e" translate="yes" xml:space="preserve">
          <source>Trade Mark Sign / Trademark</source>
          <target state="translated">商标标志/商标</target>
        </trans-unit>
        <trans-unit id="425d15442171bfb5ea100947c75ec0ba9c146e2c" translate="yes" xml:space="preserve">
          <source>Trailing whitespace is left unaltered.</source>
          <target state="translated">后面的空白处不作改动。</target>
        </trans-unit>
        <trans-unit id="3b278ea9e74a042719a58f33d9cbb403be99f4ca" translate="yes" xml:space="preserve">
          <source>Train</source>
          <target state="translated">Train</target>
        </trans-unit>
        <trans-unit id="d912f0acc1b118c025b1345d633ba920615f5571" translate="yes" xml:space="preserve">
          <source>Trait-based dispatch</source>
          <target state="translated">基于特征的调度</target>
        </trans-unit>
        <trans-unit id="d5838baf7a0cdd2c01f0b9aad26d4b577472aeb0" translate="yes" xml:space="preserve">
          <source>Tram</source>
          <target state="translated">Tram</target>
        </trans-unit>
        <trans-unit id="fd49baa6a07af107b147f6c54ee8d0e9b28fd8ce" translate="yes" xml:space="preserve">
          <source>Tram Car</source>
          <target state="translated">缆车</target>
        </trans-unit>
        <trans-unit id="742b78a52f1ec6f46ea0e8ce25d61611232abdad" translate="yes" xml:space="preserve">
          <source>Transform an array to its complex conjugate in-place.</source>
          <target state="translated">将一个数组就地转化为其复数共轭。</target>
        </trans-unit>
        <trans-unit id="fe67b43b94628556bbf8a1979e5bb4a616c981e5" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element using available workers and tasks.</source>
          <target state="translated">通过使用可用的工作程序和任务将 &lt;code&gt;f&lt;/code&gt; 应用于每个元素来变换集合 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53273d7443cc45adf7bcb374bbb1ed108fc37052" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element. For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">通过将 &lt;code&gt;f&lt;/code&gt; 应用于每个元素来变换集合 &lt;code&gt;c&lt;/code&gt; 。对于多个集合参数，请逐个应用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c3a64c4f09f42065e08d17127a4cf1dbd8b1a80" translate="yes" xml:space="preserve">
          <source>Transform the eigenvectors &lt;code&gt;V&lt;/code&gt; of a matrix balanced using &lt;code&gt;gebal!&lt;/code&gt; to the unscaled/unpermuted eigenvectors of the original matrix. Modifies &lt;code&gt;V&lt;/code&gt; in-place. &lt;code&gt;side&lt;/code&gt; can be &lt;code&gt;L&lt;/code&gt; (left eigenvectors are transformed) or &lt;code&gt;R&lt;/code&gt; (right eigenvectors are transformed).</source>
          <target state="translated">使用 &lt;code&gt;gebal!&lt;/code&gt; 变换矩阵的特征向量 &lt;code&gt;V&lt;/code&gt; 到原始矩阵的未缩放/未置换特征向量。就地修改 &lt;code&gt;V&lt;/code&gt; 。 &lt;code&gt;side&lt;/code&gt; 可以是 &lt;code&gt;L&lt;/code&gt; （对本征向量进行变换）或 &lt;code&gt;R&lt;/code&gt; （对本征向量进行变换）。</target>
        </trans-unit>
        <trans-unit id="589e1ff32866be5e43daf649cc6902633fad511a" translate="yes" xml:space="preserve">
          <source>Transform the given dimensions of array &lt;code&gt;A&lt;/code&gt; using function &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is called on each slice of &lt;code&gt;A&lt;/code&gt; of the form &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;[1,2]&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is 4-dimensional, &lt;code&gt;f&lt;/code&gt; is called on &lt;code&gt;A[:,:,i,j]&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">使用函数 &lt;code&gt;f&lt;/code&gt; 变换数组 &lt;code&gt;A&lt;/code&gt; 的给定维数。在形式 &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt; 的 &lt;code&gt;A&lt;/code&gt; 的每个切片上调用 &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;dims&lt;/code&gt; 是一个整数向量，指定冒号在此表达式中的位置。结果沿其余维度合并在一起。例如，如果 &lt;code&gt;dims&lt;/code&gt; 为 &lt;code&gt;[1,2]&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; 为4维，则对所有 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 都在 &lt;code&gt;A[:,:,i,j]&lt;/code&gt; 上调用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50cedbb47d15ee34a2d802bd7d89f363094704e1" translate="yes" xml:space="preserve">
          <source>Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.</source>
          <target state="translated">将一个可索引的容器转换为相同数据的Dictionary-view。修改基础数据的键空间可能会使这个对象无效。</target>
        </trans-unit>
        <trans-unit id="66a40eda3c1161ed62ea96e24adba8e71d0ba78c" translate="yes" xml:space="preserve">
          <source>Transforms the upper trapezoidal matrix &lt;code&gt;A&lt;/code&gt; to upper triangular form in-place. Returns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;tau&lt;/code&gt;, the scalar parameters for the elementary reflectors of the transformation.</source>
          <target state="translated">将上梯形矩阵 &lt;code&gt;A&lt;/code&gt; 转换为就地上三角形式。返回 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;tau&lt;/code&gt; ，即转换的基本反射器的标量参数。</target>
        </trans-unit>
        <trans-unit id="fc4c2841798d8e2d6fab4f58a0bd8b1dde31ae90" translate="yes" xml:space="preserve">
          <source>Transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">转置数组 &lt;code&gt;src&lt;/code&gt; 并将结果存储在预分配的数组 &lt;code&gt;dest&lt;/code&gt; 中，该数组的大小应对应于 &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; 。不支持就地换位，如果 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 具有重叠的内存区域，则会发生意外结果。</target>
        </trans-unit>
        <trans-unit id="8f90329c80aba7f64de39c4d167572bb26f230b8" translate="yes" xml:space="preserve">
          <source>Transpose current line with line above</source>
          <target state="translated">将当前线与上面的线进行换位</target>
        </trans-unit>
        <trans-unit id="3687a79c6f0057ebfb38f5f6a37b95eeaa41c961" translate="yes" xml:space="preserve">
          <source>Transpose current line with line below</source>
          <target state="translated">将当前线与下面的线换位</target>
        </trans-unit>
        <trans-unit id="48be66c4f5c89d5b655d081c49787c6dc2120182" translate="yes" xml:space="preserve">
          <source>Transpose the characters about the cursor</source>
          <target state="translated">转换光标周围的字符</target>
        </trans-unit>
        <trans-unit id="fb403df4dd376fe10346f5998fcc78a8bb44e0b5" translate="yes" xml:space="preserve">
          <source>Transposition Operation</source>
          <target state="translated">换位操作</target>
        </trans-unit>
        <trans-unit id="e59e9a12661e6b012b7d657cf12b62dc5b571082" translate="yes" xml:space="preserve">
          <source>Transposition operation</source>
          <target state="translated">换位操作</target>
        </trans-unit>
        <trans-unit id="ecfd8b1ba3d62f7ad1ee66b9f0fb873cb6da8327" translate="yes" xml:space="preserve">
          <source>Transversal Intersection</source>
          <target state="translated">横向交叉口</target>
        </trans-unit>
        <trans-unit id="7cde555988492eea4432149156cbe06f0b076e67" translate="yes" xml:space="preserve">
          <source>Traverse the entries in &lt;code&gt;tree&lt;/code&gt; and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree's leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.</source>
          <target state="translated">按后顺序或前顺序遍历 &lt;code&gt;tree&lt;/code&gt; 及其子树中的条目。预排序意味着从根开始，然后遍历最左边的子树（然后递归地向下穿过该子树的最左边的子树），然后向右移动整个子树。后顺序表示从最左边的子树的底部开始，向上遍历整个树，然后遍历下一个右边的子树（同样从底部开始），最后最后访问所有树的根。</target>
        </trans-unit>
        <trans-unit id="791e68e780c0f86ed7620277a18ccb7b2f0900e4" translate="yes" xml:space="preserve">
          <source>Treat Subnormal Numbers as Zeros</source>
          <target state="translated">将次常数视为零</target>
        </trans-unit>
        <trans-unit id="c4fadb4fd45f206006c2e243d850b8c3f0ed9575" translate="yes" xml:space="preserve">
          <source>Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as &lt;code&gt;x-y == 0&lt;/code&gt; implies &lt;code&gt;x == y&lt;/code&gt;:</source>
          <target state="translated">应谨慎使用次正规量为零，因为这样做会破坏某些身份，例如 &lt;code&gt;x-y == 0&lt;/code&gt; 意味着 &lt;code&gt;x == y&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9c9ca807bb2ab4244216bbe667dca9d54adffd7f" translate="yes" xml:space="preserve">
          <source>Triangle Referencing</source>
          <target state="translated">三角引用</target>
        </trans-unit>
        <trans-unit id="2bb3f66057a0bac3d2fe069941cb9f2a05c4b5bc" translate="yes" xml:space="preserve">
          <source>Triangle With Dot Above</source>
          <target state="translated">三角形,上面有点</target>
        </trans-unit>
        <trans-unit id="b7c13ac265c6665e49bdb94db0d8083d9f778bcb" translate="yes" xml:space="preserve">
          <source>Triangle With Underbar</source>
          <target state="translated">三角形带下杆</target>
        </trans-unit>
        <trans-unit id="160c26397adf4988e0b7455c4f857604b9fb8d0d" translate="yes" xml:space="preserve">
          <source>Triangle referencing</source>
          <target state="translated">三角形参考</target>
        </trans-unit>
        <trans-unit id="8fc6199243314b8c0c53ed674ea486fd217ade89" translate="yes" xml:space="preserve">
          <source>Triangular</source>
          <target state="translated">Triangular</target>
        </trans-unit>
        <trans-unit id="6d90e2fedf2c3a69bc762b826e673df767a24a84" translate="yes" xml:space="preserve">
          <source>Triangular Flag On Post</source>
          <target state="translated">三角旗在邮政上</target>
        </trans-unit>
        <trans-unit id="35a961685d74e87fb2defd8c3eaff910ff2eb0eb" translate="yes" xml:space="preserve">
          <source>Triangular Ruler</source>
          <target state="translated">三角尺</target>
        </trans-unit>
        <trans-unit id="9e336984f920581ee4ce0df13dfa14b0e2ae3a42" translate="yes" xml:space="preserve">
          <source>Tricky? Perhaps. What is an innocent &lt;code&gt;Dates&lt;/code&gt; user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the &quot;joys&quot; of dealing with daylight savings, leap seconds, etc.).</source>
          <target state="translated">棘手的？也许。无辜的 &lt;code&gt;Dates&lt;/code&gt; 用户要做什么？底线是要知道，在处理数月时，显式强制某种关联性可能会导致一些意想不到的结果，但否则，一切都会按预期进行。幸运的是，在UT中处理时间时，这几乎是日期周期算术中奇数情况的程度（避免了处理夏时制，leap秒等的&amp;ldquo;乐趣&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="98200808753c64066fca0c2f60e6540c2f9304ca" translate="yes" xml:space="preserve">
          <source>Tricolon</source>
          <target state="translated">Tricolon</target>
        </trans-unit>
        <trans-unit id="4b05482034189f500d70df4463d2dbc3fd792fa1" translate="yes" xml:space="preserve">
          <source>Trident Emblem</source>
          <target state="translated">三叉戟徽记</target>
        </trans-unit>
        <trans-unit id="0f0fe0b102122af9b3e1aa3066e10188316b7e80" translate="yes" xml:space="preserve">
          <source>Tridiagonal</source>
          <target state="translated">Tridiagonal</target>
        </trans-unit>
        <trans-unit id="4f23fdcbf978b1f174f1f0150b4e839f69d24afc" translate="yes" xml:space="preserve">
          <source>Tridiagonal matrix</source>
          <target state="translated">三边形矩阵</target>
        </trans-unit>
        <trans-unit id="e789c19841ebe0317ebcd28434e36e772dc7a83d" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions</source>
          <target state="translated">三角函数和双曲函数</target>
        </trans-unit>
        <trans-unit id="f20cc8cf4fba3cc7d93846dfbed75994f6215f36" translate="yes" xml:space="preserve">
          <source>Triple Colon Operator</source>
          <target state="translated">三层结肠操作员</target>
        </trans-unit>
        <trans-unit id="4a03809cfb647189e67fad647f769643426eb524" translate="yes" xml:space="preserve">
          <source>Triple Integral</source>
          <target state="translated">三元积分</target>
        </trans-unit>
        <trans-unit id="4c843fa3d064b1637b9a934e39f0951786b86357" translate="yes" xml:space="preserve">
          <source>Triple Nested Greater-Than</source>
          <target state="translated">三重嵌套大于等于</target>
        </trans-unit>
        <trans-unit id="bc48dc85d97fd346bea02435f83eacf69e6b6aa3" translate="yes" xml:space="preserve">
          <source>Triple Nested Less-Than</source>
          <target state="translated">三重嵌套小于</target>
        </trans-unit>
        <trans-unit id="10e187cab7bb4c297ed3b8b0dc8a7e7c1b437b6e" translate="yes" xml:space="preserve">
          <source>Triple Plus</source>
          <target state="translated">三加</target>
        </trans-unit>
        <trans-unit id="e4107a129a477eb4305d09a04ff620342e6d5a39" translate="yes" xml:space="preserve">
          <source>Triple Prime</source>
          <target state="translated">三层楼</target>
        </trans-unit>
        <trans-unit id="f91ac0ecf21472d6ccd15f4ba9af28d149dc8f7d" translate="yes" xml:space="preserve">
          <source>Triple Tilde</source>
          <target state="translated">三层楼</target>
        </trans-unit>
        <trans-unit id="9aad96f795695616a77fd0b86856873ada33c081" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Binary Relation</source>
          <target state="translated">三竖条二元关系</target>
        </trans-unit>
        <trans-unit id="5aa94f488e3751771f1642dc28467e3117351ee0" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Delimiter</source>
          <target state="translated">三垂直条形分隔器</target>
        </trans-unit>
        <trans-unit id="3be66a3b16b2414eeb14c7e1589bb01ace3385b3" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Right Turnstile</source>
          <target state="translated">三层垂直杆式右转门</target>
        </trans-unit>
        <trans-unit id="15fb453f3bd4fb6b3dc4c8fc111b98e0cb966ca8" translate="yes" xml:space="preserve">
          <source>Triple-Quoted String Literals</source>
          <target state="translated">三重引号字符串识字</target>
        </trans-unit>
        <trans-unit id="2920ab57511d06b8770e0cbbb95a3cbbf0a249d1" translate="yes" xml:space="preserve">
          <source>Triple-quoted regex strings, of the form &lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt;, are also supported (and may be convenient for regular expressions containing quotation marks or newlines).</source>
          <target state="translated">还支持格式为 &lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt; 三引号正则表达式字符串（对于包含引号或换行符的正则表达式而言，可能很方便）。</target>
        </trans-unit>
        <trans-unit id="b54e3c85f204b81397a7c84b48965d41b5754fba" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; characters without escaping.</source>
          <target state="translated">三引号字符串常量可以包含 &lt;code&gt;&quot;&lt;/code&gt; 字符不进行转义。</target>
        </trans-unit>
        <trans-unit id="01aa9c142c3bf18faaea1950666658f968f3131c" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; symbols without escaping.</source>
          <target state="translated">用三引号引起来的字符串文字可以包含 &lt;code&gt;&quot;&lt;/code&gt; 符号而无需转义。</target>
        </trans-unit>
        <trans-unit id="957886bc006fb19c37ca4b45b5f2e8ebf53008e7" translate="yes" xml:space="preserve">
          <source>Trolleybus</source>
          <target state="translated">Trolleybus</target>
        </trans-unit>
        <trans-unit id="1075c086b703df3b01e8d6013dae65668d6d865d" translate="yes" xml:space="preserve">
          <source>Trophy</source>
          <target state="translated">Trophy</target>
        </trans-unit>
        <trans-unit id="f27ecef221139e5fd432ae45c48c9d80fb89e7df" translate="yes" xml:space="preserve">
          <source>Tropical Drink</source>
          <target state="translated">热带饮料</target>
        </trans-unit>
        <trans-unit id="2983c072197329832df76d88b69aef1b73478110" translate="yes" xml:space="preserve">
          <source>Tropical Fish</source>
          <target state="translated">热带鱼</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="63bc99348fac41157f28181105c7b5ea6bb7afd2" translate="yes" xml:space="preserve">
          <source>True if the code is from C.</source>
          <target state="translated">如果代码来自C语言,则为真。</target>
        </trans-unit>
        <trans-unit id="ec75cc300e047be39d0a9fb14737dd15be5276d7" translate="yes" xml:space="preserve">
          <source>True if the code is from an inlined frame.</source>
          <target state="translated">如果代码来自内联框架,则为真。</target>
        </trans-unit>
        <trans-unit id="66c3284825be09870b41244ed701aea7191cb82e" translate="yes" xml:space="preserve">
          <source>Trumpet</source>
          <target state="translated">Trumpet</target>
        </trans-unit>
        <trans-unit id="4b46414e1c27f9b8937db64044b2e81c89c3c481" translate="yes" xml:space="preserve">
          <source>Truncates the value of &lt;code&gt;dt&lt;/code&gt; according to the provided &lt;code&gt;Period&lt;/code&gt; type.</source>
          <target state="translated">根据提供的&amp;ldquo; &lt;code&gt;Period&lt;/code&gt; 类型截断 &lt;code&gt;dt&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="1ab5d704e1ea0cac99a119ecd2665b6a98ac90ba" translate="yes" xml:space="preserve">
          <source>Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.</source>
          <target state="translated">尽量避免在一份文件中使用太多层次的页眉。嵌套过多的文件可能表明需要调整文件的结构,或将其分成若干页,分别讨论不同的主题。</target>
        </trans-unit>
        <trans-unit id="a5782807a1634c799255f28c6609330ea2948623" translate="yes" xml:space="preserve">
          <source>Trying to construct a &lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; rational value, however, is invalid:</source>
          <target state="translated">但是，尝试构造&lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt;有理值是无效的：</target>
        </trans-unit>
        <trans-unit id="0a45f936f6d904e3db7eb90ebb14b6146ce40542" translate="yes" xml:space="preserve">
          <source>Tulip</source>
          <target state="translated">Tulip</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="845b33803adcb6fd7b83aa05a48e2e532cdedbb3" translate="yes" xml:space="preserve">
          <source>Tuple and NTuple arguments</source>
          <target state="translated">Tuple和NTuple参数</target>
        </trans-unit>
        <trans-unit id="1d7518da5e57e98af113ed9ca0544eae23ceace9" translate="yes" xml:space="preserve">
          <source>Tuple types are &lt;em&gt;covariant&lt;/em&gt; in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are.</source>
          <target state="translated">元组类型的参数是&lt;em&gt;协变&lt;/em&gt;的： &lt;code&gt;Tuple{Int}&lt;/code&gt; 是 &lt;code&gt;Tuple{Any}&lt;/code&gt; 的子类型。因此， &lt;code&gt;Tuple{Any}&lt;/code&gt; 被认为是抽象类型，并且元组类型只有在其参数正确的情况下才是具体的。</target>
        </trans-unit>
        <trans-unit id="f158b42c8df38fba7edc2516cf30067a6f3c3fd2" translate="yes" xml:space="preserve">
          <source>Tuple types are covariant in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">元组类型的参数是协变的： &lt;code&gt;Tuple{Int}&lt;/code&gt; 是 &lt;code&gt;Tuple{Any}&lt;/code&gt; 的子类型。因此， &lt;code&gt;Tuple{Any}&lt;/code&gt; 被认为是抽象类型，并且元组类型只有在其参数正确的情况下才是具体的。元组没有字段名称；字段只能按索引访问。</target>
        </trans-unit>
        <trans-unit id="c3dd2cf49e1c762ee0d977a8827179a18862e514" translate="yes" xml:space="preserve">
          <source>Tuple types may have any number of parameters.</source>
          <target state="translated">Tuple类型可以有任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="436cabb920e9afcb6c39fb96f4c8e856c77ac70f" translate="yes" xml:space="preserve">
          <source>Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</source>
          <target state="translated">元组值用括号和逗号书写。当构造一个元组时,会根据需要生成一个适当的元组类型。</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="2b853ab04d00cf57d1ce546398e1b79f3f051f32" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</source>
          <target state="translated">元组是函数参数的抽象，而没有函数本身。函数参数的主要方面是它们的顺序和类型。因此，元组类型类似于参数化的不可变类型，其中每个参数都是一个字段的类型。例如，2元素元组类型类似于以下不可变类型：</target>
        </trans-unit>
        <trans-unit id="38f517ecb99a7d22ca712e684653b53d2da013e1" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</source>
          <target state="translated">元组是函数参数的抽象，而没有函数本身。函数参数的主要方面是它们的顺序和类型。因此，元组类型类似于参数化的不可变类型，其中每个参数都是一个字段的类型。元组类型可以具有任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="10a000d9419f2a05d7ec82307740cfc2f368764c" translate="yes" xml:space="preserve">
          <source>Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">图元组没有字段名,字段只能通过索引访问。</target>
        </trans-unit>
        <trans-unit id="d475d0ed8dbda37de3962c553ee1cf6bad5acd73" translate="yes" xml:space="preserve">
          <source>Turned Ampersand</source>
          <target state="translated">转动的安打</target>
        </trans-unit>
        <trans-unit id="44e7aa783e6e21961447d92fabcb381a889f661a" translate="yes" xml:space="preserve">
          <source>Turned Angle</source>
          <target state="translated">转角</target>
        </trans-unit>
        <trans-unit id="8b3464100be6c8cfd6483bbda164ded5b9f3dda5" translate="yes" xml:space="preserve">
          <source>Turned Capital F / Turned F</source>
          <target state="translated">转为资本F/转为F</target>
        </trans-unit>
        <trans-unit id="c0d9680d54a56600626a6e13ab971c5a7946bf28" translate="yes" xml:space="preserve">
          <source>Turned Greek Small Letter Iota</source>
          <target state="translated">转为希腊语小字Iota</target>
        </trans-unit>
        <trans-unit id="a0d677f4e8b54c3e427ed668e6e7e5fb71640f1b" translate="yes" xml:space="preserve">
          <source>Turned Not Sign</source>
          <target state="translated">已转为非标</target>
        </trans-unit>
        <trans-unit id="65de22879a9e05c48035f0650a2aba5faf638568" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital G</source>
          <target state="translated">转为无衬线大写字母G</target>
        </trans-unit>
        <trans-unit id="a0b3c92d57fcbd9e284b1f1bc355f9c62a47e627" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital L</source>
          <target state="translated">转为无衬线大写字母L</target>
        </trans-unit>
        <trans-unit id="c98f94d5a7cb8446bd8b48114b19424f10405e51" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital Y</source>
          <target state="translated">转为无衬线大写字母Y</target>
        </trans-unit>
        <trans-unit id="7039da614328dbb74b73091f274ceec249a388f5" translate="yes" xml:space="preserve">
          <source>Turtle</source>
          <target state="translated">Turtle</target>
        </trans-unit>
        <trans-unit id="eaef77aca961ecc2cacd2ed540321a53b86f2c60" translate="yes" xml:space="preserve">
          <source>Tweaks</source>
          <target state="translated">Tweaks</target>
        </trans-unit>
        <trans-unit id="2c47ac9f8b779ed312982f36375e817cfd461a0d" translate="yes" xml:space="preserve">
          <source>Twisted Rightwards Arrows</source>
          <target state="translated">扭曲的向右箭头</target>
        </trans-unit>
        <trans-unit id="850aa4e89f36cf847f4d161726e5625623c23118" translate="yes" xml:space="preserve">
          <source>Two Consecutive Equals Signs</source>
          <target state="translated">两个连续的等号</target>
        </trans-unit>
        <trans-unit id="d41d4a075c8d174ebb10603c708c639e709f0109" translate="yes" xml:space="preserve">
          <source>Two Hearts</source>
          <target state="translated">两颗心</target>
        </trans-unit>
        <trans-unit id="7a3530233c722f61a2c0d529c3b9d5062536abc0" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical And</source>
          <target state="translated">两个相交的逻辑和</target>
        </trans-unit>
        <trans-unit id="55266f0a48713c6bc0f773b39d521dc70499465f" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical Or</source>
          <target state="translated">两个相交的逻辑或</target>
        </trans-unit>
        <trans-unit id="66b2f43372d062ff8e38e2e1c1860db370e78e02" translate="yes" xml:space="preserve">
          <source>Two Logical And Operator</source>
          <target state="translated">两个逻辑和运算符</target>
        </trans-unit>
        <trans-unit id="12c9295bb902c2fb14793da783a921da3fd8054a" translate="yes" xml:space="preserve">
          <source>Two Logical Or Operator</source>
          <target state="translated">两个逻辑或运算符</target>
        </trans-unit>
        <trans-unit id="fd1eb7f02c8f49a97ad1aaa21bd916045738c759" translate="yes" xml:space="preserve">
          <source>Two Men Holding Hands</source>
          <target state="translated">两个男人手拉手</target>
        </trans-unit>
        <trans-unit id="ea9b8150660b031f305860c61406c3d6161a7b06" translate="yes" xml:space="preserve">
          <source>Two Women Holding Hands</source>
          <target state="translated">两个女人牵手</target>
        </trans-unit>
        <trans-unit id="14a1f210884121dab1e048ee8ff43a770883c685" translate="yes" xml:space="preserve">
          <source>Two dimensional &lt;a href=&quot;#Base.StridedArray&quot;&gt;&lt;code&gt;StridedArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">元素类型为 &lt;code&gt;T&lt;/code&gt; 的二维&lt;a href=&quot;#Base.StridedArray&quot;&gt; &lt;code&gt;StridedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8f09c4cf86a87bcead55bcb46b75740b635c442" translate="yes" xml:space="preserve">
          <source>Two other handy string functions are &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">另外两个方便的字符串函数是&lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="19a22abb2af2528acd0706b6d05a99511e3cad19" translate="yes" xml:space="preserve">
          <source>Two typical uses of &lt;code&gt;__init__&lt;/code&gt; are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries. For example, suppose that we are calling a C library &lt;code&gt;libfoo&lt;/code&gt; that requires us to call a &lt;code&gt;foo_init()&lt;/code&gt; initialization function at runtime. Suppose that we also want to define a global constant &lt;code&gt;foo_data_ptr&lt;/code&gt; that holds the return value of a &lt;code&gt;void *foo_data()&lt;/code&gt; function defined by &lt;code&gt;libfoo&lt;/code&gt; &amp;ndash; this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run. You could accomplish this by defining the following &lt;code&gt;__init__&lt;/code&gt; function in your module:</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 的两种典型用法是调用外部C库的运行时初始化函数，以及初始化涉及外部库返回的指针的全局常量。例如，假设我们正在调用一个C库 &lt;code&gt;libfoo&lt;/code&gt; ，该库要求我们在运行时调用 &lt;code&gt;foo_init()&lt;/code&gt; 初始化函数。假设我们还想定义一个全局常量 &lt;code&gt;foo_data_ptr&lt;/code&gt; ，该常量保存由 &lt;code&gt;libfoo&lt;/code&gt; 定义的 &lt;code&gt;void *foo_data()&lt;/code&gt; 函数的返回值&amp;ndash;该常量必须在运行时（而不是在编译时）初始化，因为指针地址将从运行更改为跑。您可以通过定义以下 &lt;code&gt;__init__&lt;/code&gt; 来完成此操作 模块中的功能：</target>
        </trans-unit>
        <trans-unit id="34e8818ff6722512c7d2d5bdcca9e688c6d5dbba" translate="yes" xml:space="preserve">
          <source>Two-dimensional &lt;a href=&quot;#Core.DenseArray&quot;&gt;&lt;code&gt;DenseArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;. Alias for &lt;code&gt;DenseArray{T,2}&lt;/code&gt;.</source>
          <target state="translated">元素类型为 &lt;code&gt;T&lt;/code&gt; 的二维&lt;a href=&quot;#Core.DenseArray&quot;&gt; &lt;code&gt;DenseArray&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;DenseArray{T,2}&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="520563ee1cb32d20148c405d4ac444576ac80929" translate="yes" xml:space="preserve">
          <source>Two-dimensional dense array with elements of type &lt;code&gt;T&lt;/code&gt;, often used to represent a mathematical matrix. Alias for &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array{T,2}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">元素类型为 &lt;code&gt;T&lt;/code&gt; 的二维密集数组，通常用于表示数学矩阵。&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array{T,2}&lt;/code&gt; &lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="699c321e34c4b272cb0e92dbf84b36d8841e2209" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T1&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type &lt;code&gt;T2&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type. Note that &lt;code&gt;T2&lt;/code&gt; is an abstract type, e.g., &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt;, whereas &lt;code&gt;T1&lt;/code&gt; is a concrete type. As a consequence, &lt;code&gt;T1&lt;/code&gt; can be constructed with a zero-argument constructor &lt;code&gt;a=T1()&lt;/code&gt; but &lt;code&gt;T2&lt;/code&gt; cannot.</source>
          <target state="translated">类型 &lt;code&gt;T1&lt;/code&gt; 定义了1维数组的1维数组；每个内部数组都由相同类型的对象组成，但是此类型可能因一个内部数组而异。另一方面，类型 &lt;code&gt;T2&lt;/code&gt; 定义了1维数组的1维数组，其所有内部数组必须具有相同的类型。请注意， &lt;code&gt;T2&lt;/code&gt; 是抽象类型，例如 &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt; ，而 &lt;code&gt;T1&lt;/code&gt; 是具体类型。因此， &lt;code&gt;T1&lt;/code&gt; 可以用一个无参数构造来构造 &lt;code&gt;a=T1()&lt;/code&gt; ，但 &lt;code&gt;T2&lt;/code&gt; 不能。</target>
        </trans-unit>
        <trans-unit id="9336947ff1fcdc631e771b9b86afd198836eb20c" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;VecElement{T}&lt;/code&gt; is intended for building libraries of SIMD operations. Practical use of it requires using &lt;code&gt;llvmcall&lt;/code&gt;. The type is defined as:</source>
          <target state="translated">类型 &lt;code&gt;VecElement{T}&lt;/code&gt; 用于构建SIMD操作库。实际使用它需要使用 &lt;code&gt;llvmcall&lt;/code&gt; 。该类型定义为：</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="1242b5a7bcfba49f41a8936f551747918a7040c3" translate="yes" xml:space="preserve">
          <source>Type Correspondences</source>
          <target state="translated">类型对应</target>
        </trans-unit>
        <trans-unit id="e9fa287d5611bc4f8123b770126f1a09136ca477" translate="yes" xml:space="preserve">
          <source>Type Correspondences:</source>
          <target state="translated">类型对应:</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">类型声明</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="translated">类型参数</target>
        </trans-unit>
        <trans-unit id="3984fbe729382dd2cebe0b8952bf750232d09730" translate="yes" xml:space="preserve">
          <source>Type Unions</source>
          <target state="translated">联合会类型</target>
        </trans-unit>
        <trans-unit id="7ab532ff895c9c41984a98ec53a2137840835c70" translate="yes" xml:space="preserve">
          <source>Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:</source>
          <target state="translated">如果类型是在运行时构造的,那么类型注释不会提高(实际上可能会阻碍)性能。这是因为编译器不能使用注释来对后续代码进行特殊化,而类型检查本身也需要时间。例如,在代码中。</target>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="translated">类型声明</target>
        </trans-unit>
        <trans-unit id="d823421474b9921ea903ae47a40988974efcaac1" translate="yes" xml:space="preserve">
          <source>Type parameters are introduced immediately after the type name, surrounded by curly braces:</source>
          <target state="translated">类型参数紧接在类型名称之后引入,周围用大括号包围。</target>
        </trans-unit>
        <trans-unit id="7b5326008bc0cc9fa7f08d020855f5918767c17c" translate="yes" xml:space="preserve">
          <source>Type parameters for parametric composite types can be restricted in the same manner:</source>
          <target state="translated">参数复合类型的类型参数可以用同样的方式进行限制。</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">类型关系</target>
        </trans-unit>
        <trans-unit id="12d64d97cdd4d210c956404867f73d6285cb3aa2" translate="yes" xml:space="preserve">
          <source>Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.</source>
          <target state="translated">类型系统传统上分为两个截然不同的阵营:静态类型系统,即每个程序表达式在程序执行前必须有一个可计算的类型;动态类型系统,即在运行时才知道类型的任何信息,这时程序所操纵的实际值才会出现。面向对象使静态类型语言具有一定的灵活性,它允许在编译时不知道值的精确类型的情况下编写代码。编写可以操作不同类型的代码的能力称为多态性。在经典的动态类型语言中,所有的代码都是多态的:只有通过显式检查类型,或者当对象在运行时不支持操作时,任何值的类型才会受到限制。</target>
        </trans-unit>
        <trans-unit id="7972379a3c2cbad083d2ed614182962961c71c72" translate="yes" xml:space="preserve">
          <source>Type used by &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:</source>
          <target state="translated">键入使用&lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; &lt;/a&gt; s到添加到他们的集群控制工人。所有集群管理器都使用某些字段来访问主机：</target>
        </trans-unit>
        <trans-unit id="9fbab0c4a9d7c9cb4f0cf6a2eb051a99d0b23d5d" translate="yes" xml:space="preserve">
          <source>Type variables can be restricted with subtype relations. &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; refers to all arrays whose element type is some kind of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. The syntax &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; is a convenient shorthand for &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt;. Type variables can have both lower and upper bounds. &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; refers to all arrays of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;s that are able to contain &lt;code&gt;Int&lt;/code&gt;s (since &lt;code&gt;T&lt;/code&gt; must be at least as big as &lt;code&gt;Int&lt;/code&gt;). The syntax &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; also works to specify only the lower bound of a type variable, and &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; is equivalent to &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt;.</source>
          <target state="translated">类型变量可以受子类型关系限制。 &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; 元素类型为某种&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; 的&lt;/a&gt;所有数组。语法 &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; 是 &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; 的便捷缩写，其中T &amp;lt;：Integer。类型变量可以具有上限和下限。 &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; 表示能够包含 &lt;code&gt;Int&lt;/code&gt; 的&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;的所有数组（因为 &lt;code&gt;T&lt;/code&gt; 必须至少与 &lt;code&gt;Int&lt;/code&gt; 一样大）。 &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; 的语法也仅用于指定类型变量的下限，而 &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; 等效于 &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b58c015fd584b426ddd183d3bd379a95d6be97" translate="yes" xml:space="preserve">
          <source>Typed array initializers</source>
          <target state="translated">类型化的数组初始化器</target>
        </trans-unit>
        <trans-unit id="cf7a25a9e02171630e17f66a177ae70ee69aaf9a" translate="yes" xml:space="preserve">
          <source>Typed array literals</source>
          <target state="translated">类型化的数组文字</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="fbe557b5793644a7901cb800d76030ed78f31ec9" translate="yes" xml:space="preserve">
          <source>Types can be declared without specifying the types of their fields:</source>
          <target state="translated">可以声明类型而不指定其字段的类型。</target>
        </trans-unit>
        <trans-unit id="fdedb89e25bef406c502b07b3fc7f90af76076d3" translate="yes" xml:space="preserve">
          <source>Types in module &lt;code&gt;Main&lt;/code&gt; cannot be redefined.</source>
          <target state="translated">无法重新定义模块 &lt;code&gt;Main&lt;/code&gt; 中的类型。</target>
        </trans-unit>
        <trans-unit id="650af697d6f97ac31d8e939763f2089920715297" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; are often a sign that some design could be cleaner.</source>
          <target state="translated">诸如 &lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; 类型通常是某些设计可能更简洁的标志。</target>
        </trans-unit>
        <trans-unit id="06e7787daf9f1b80047a5404b114c43c5fe951aa" translate="yes" xml:space="preserve">
          <source>Types with values-as-parameters</source>
          <target state="translated">以数值为参数的类型</target>
        </trans-unit>
        <trans-unit id="3f3f5c7adeb5ad8f6d9e378b2333ccf650b57cd7" translate="yes" xml:space="preserve">
          <source>Types, type declarations, and constructors</source>
          <target state="translated">类型、类型声明和构造函数。</target>
        </trans-unit>
        <trans-unit id="eaef1931ed9538c659ce53165ed9d4e8ce061afe" translate="yes" xml:space="preserve">
          <source>Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.</source>
          <target state="translated">通常情况下,大量的测试被用来确保函数在输入范围内正确工作。如果一个测试失败,默认的行为是立即抛出一个异常。然而,通常情况下,最好是先运行其余的测试,以便更好地了解被测试的代码中存在多少错误。</target>
        </trans-unit>
        <trans-unit id="bc0c2b73a898cd3376224f049c214a04bf91c4ec" translate="yes" xml:space="preserve">
          <source>Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.</source>
          <target state="translated">通常情况下,Julia对象是由垃圾收集器(GC)释放的,但GC不会自动知道我们持有一个来自C的Julia值的引用,这意味着GC可以从你的下面释放对象,使指针无效。</target>
        </trans-unit>
        <trans-unit id="7419e2c7a1164809fb8ab4ac690a6e5483811275" translate="yes" xml:space="preserve">
          <source>U+000A1</source>
          <target state="translated">U+000A1</target>
        </trans-unit>
        <trans-unit id="f732db6bfaceaf0fc8ce5731c40779ee88385e6b" translate="yes" xml:space="preserve">
          <source>U+000A3</source>
          <target state="translated">U+000A3</target>
        </trans-unit>
        <trans-unit id="833d790d7abefa68b4017fdb2b0846169ce6efb2" translate="yes" xml:space="preserve">
          <source>U+000A5</source>
          <target state="translated">U+000A5</target>
        </trans-unit>
        <trans-unit id="58a6aa3f7f66e4affa4c092d7c6f847968ea3de9" translate="yes" xml:space="preserve">
          <source>U+000A6</source>
          <target state="translated">U+000A6</target>
        </trans-unit>
        <trans-unit id="211d177d90638c1a066376a7be8af6d0d158c6a4" translate="yes" xml:space="preserve">
          <source>U+000A7</source>
          <target state="translated">U+000A7</target>
        </trans-unit>
        <trans-unit id="d9dc28f2fa7e30eb9c0f439b5750f3838f2cee87" translate="yes" xml:space="preserve">
          <source>U+000A9</source>
          <target state="translated">U+000A9</target>
        </trans-unit>
        <trans-unit id="513de6b2fcc5e7696ac5c1feba0bb18320067443" translate="yes" xml:space="preserve">
          <source>U+000AA</source>
          <target state="translated">U+000AA</target>
        </trans-unit>
        <trans-unit id="d300f7fa4371b181daf488187043f16662716af6" translate="yes" xml:space="preserve">
          <source>U+000AC</source>
          <target state="translated">U+000AC</target>
        </trans-unit>
        <trans-unit id="c7280374ed3343e39969c2ac82c6ddd1f10b831b" translate="yes" xml:space="preserve">
          <source>U+000AE</source>
          <target state="translated">U+000AE</target>
        </trans-unit>
        <trans-unit id="2edb7755d90188c4712771ad592728075ed41e24" translate="yes" xml:space="preserve">
          <source>U+000AF</source>
          <target state="translated">U+000AF</target>
        </trans-unit>
        <trans-unit id="aa7cc7286046f5dd25504a6c0d0a12491fbeda0f" translate="yes" xml:space="preserve">
          <source>U+000B0</source>
          <target state="translated">U+000B0</target>
        </trans-unit>
        <trans-unit id="bc0c6ac2a505a0f8f6872d9acdc254342e989518" translate="yes" xml:space="preserve">
          <source>U+000B1</source>
          <target state="translated">U+000B1</target>
        </trans-unit>
        <trans-unit id="5f6be68884bd3dff697042668c570d5fe480e75c" translate="yes" xml:space="preserve">
          <source>U+000B2</source>
          <target state="translated">U+000B2</target>
        </trans-unit>
        <trans-unit id="e628cf09ed074b1079cb8eb5dd91967d983f7444" translate="yes" xml:space="preserve">
          <source>U+000B3</source>
          <target state="translated">U+000B3</target>
        </trans-unit>
        <trans-unit id="bb8b943f43a734647d4be7fbdf8e9aeb6abe4e97" translate="yes" xml:space="preserve">
          <source>U+000B6</source>
          <target state="translated">U+000B6</target>
        </trans-unit>
        <trans-unit id="6600a279e4eb4336043915244350bcee45219d89" translate="yes" xml:space="preserve">
          <source>U+000B7</source>
          <target state="translated">U+000B7</target>
        </trans-unit>
        <trans-unit id="d0581e625d32999da8ec6ad1c102f7b084fb10d0" translate="yes" xml:space="preserve">
          <source>U+000B9</source>
          <target state="translated">U+000B9</target>
        </trans-unit>
        <trans-unit id="6a0b7c9ae3d95116839c792180becb32a4eb1aa2" translate="yes" xml:space="preserve">
          <source>U+000BA</source>
          <target state="translated">U+000BA</target>
        </trans-unit>
        <trans-unit id="af8d71e515f3816902d8621058dd0a1fffb02d28" translate="yes" xml:space="preserve">
          <source>U+000BC</source>
          <target state="translated">U+000BC</target>
        </trans-unit>
        <trans-unit id="f7929245fb046770d68bd353f0cb56d884faeaf8" translate="yes" xml:space="preserve">
          <source>U+000BD</source>
          <target state="translated">U+000BD</target>
        </trans-unit>
        <trans-unit id="1e389602653ddaef9088ff864e19a57a118668f8" translate="yes" xml:space="preserve">
          <source>U+000BE</source>
          <target state="translated">U+000BE</target>
        </trans-unit>
        <trans-unit id="abf751d4270b495290ba758290cd8cc30e0fc2c2" translate="yes" xml:space="preserve">
          <source>U+000BF</source>
          <target state="translated">U+000BF</target>
        </trans-unit>
        <trans-unit id="1163f1afd4392e3fdc01f33aa911294c9e5579f3" translate="yes" xml:space="preserve">
          <source>U+000C5</source>
          <target state="translated">U+000C5</target>
        </trans-unit>
        <trans-unit id="05b7168d4a3b7e544c07ac7dfac1a23c612ebfa4" translate="yes" xml:space="preserve">
          <source>U+000C6</source>
          <target state="translated">U+000C6</target>
        </trans-unit>
        <trans-unit id="8aefab16dcf0ed235064441308b0156f4f0781b0" translate="yes" xml:space="preserve">
          <source>U+000D0</source>
          <target state="translated">U+000D0</target>
        </trans-unit>
        <trans-unit id="43ca4d9749dbf2b9ba07bbe85b9d3a57230866e2" translate="yes" xml:space="preserve">
          <source>U+000D7</source>
          <target state="translated">U+000D7</target>
        </trans-unit>
        <trans-unit id="b55c75bf336976c87a823de7eaf0c105decaf9ea" translate="yes" xml:space="preserve">
          <source>U+000D8</source>
          <target state="translated">U+000D8</target>
        </trans-unit>
        <trans-unit id="fa31076aac4fc077167ef6b42f2541b7c25f0ff9" translate="yes" xml:space="preserve">
          <source>U+000DE</source>
          <target state="translated">U+000DE</target>
        </trans-unit>
        <trans-unit id="6d8c7be3aae9c7877583cf61703efbfcea6ad185" translate="yes" xml:space="preserve">
          <source>U+000DF</source>
          <target state="translated">U+000DF</target>
        </trans-unit>
        <trans-unit id="2988d0457d6c48a8f06d801f595d2dcef851a96f" translate="yes" xml:space="preserve">
          <source>U+000E5</source>
          <target state="translated">U+000E5</target>
        </trans-unit>
        <trans-unit id="f332510ba8dac469b6d1212966044bf56a7112d6" translate="yes" xml:space="preserve">
          <source>U+000E6</source>
          <target state="translated">U+000E6</target>
        </trans-unit>
        <trans-unit id="12dccbd7c4e0fb222ddd7db261fdf7b54ea85979" translate="yes" xml:space="preserve">
          <source>U+000F0</source>
          <target state="translated">U+000F0</target>
        </trans-unit>
        <trans-unit id="cb2c136f402df9ed86e130e84f1e76ce52a3a8f6" translate="yes" xml:space="preserve">
          <source>U+000F7</source>
          <target state="translated">U+000F7</target>
        </trans-unit>
        <trans-unit id="0de3d46a54055e956c406646c96350c1711258d5" translate="yes" xml:space="preserve">
          <source>U+000F8</source>
          <target state="translated">U+000F8</target>
        </trans-unit>
        <trans-unit id="774a36f37882c565b6e1a8c6da68506e50495f70" translate="yes" xml:space="preserve">
          <source>U+000FE</source>
          <target state="translated">U+000FE</target>
        </trans-unit>
        <trans-unit id="1291de41445c70b8167722b4bad48913e7b5a4a9" translate="yes" xml:space="preserve">
          <source>U+00110</source>
          <target state="translated">U+00110</target>
        </trans-unit>
        <trans-unit id="e389d4dfa1ae96bce106b3994f574f843dc801fb" translate="yes" xml:space="preserve">
          <source>U+00111</source>
          <target state="translated">U+00111</target>
        </trans-unit>
        <trans-unit id="b3a3814c99d325b6730ca42d3cc8cc2b51ceec87" translate="yes" xml:space="preserve">
          <source>U+00127</source>
          <target state="translated">U+00127</target>
        </trans-unit>
        <trans-unit id="4968e90007db7224e93699b7f20b461717d5eb8c" translate="yes" xml:space="preserve">
          <source>U+00131</source>
          <target state="translated">U+00131</target>
        </trans-unit>
        <trans-unit id="88ad15ac149402ea9f1a9bd9fd8ea887293d266a" translate="yes" xml:space="preserve">
          <source>U+00141</source>
          <target state="translated">U+00141</target>
        </trans-unit>
        <trans-unit id="bf6e35a30049db640ab91f1494f1f612637ffe04" translate="yes" xml:space="preserve">
          <source>U+00142</source>
          <target state="translated">U+00142</target>
        </trans-unit>
        <trans-unit id="e7d287bba0dfb9de5eade077b23014aa729f3d6e" translate="yes" xml:space="preserve">
          <source>U+0014A</source>
          <target state="translated">U+0014A</target>
        </trans-unit>
        <trans-unit id="18ae38fd4e2b56f6c821f408380a109cb6acfa94" translate="yes" xml:space="preserve">
          <source>U+0014B</source>
          <target state="translated">U+0014B</target>
        </trans-unit>
        <trans-unit id="39dff18eca38d64db46a57f8de43d0e39f2f1235" translate="yes" xml:space="preserve">
          <source>U+00152</source>
          <target state="translated">U+00152</target>
        </trans-unit>
        <trans-unit id="8651e7b8fce35fd0351a57eb44a27ae9ff54049a" translate="yes" xml:space="preserve">
          <source>U+00153</source>
          <target state="translated">U+00153</target>
        </trans-unit>
        <trans-unit id="2d435468173be8bdfd61aa039618e08e954d15ab" translate="yes" xml:space="preserve">
          <source>U+00195</source>
          <target state="translated">U+00195</target>
        </trans-unit>
        <trans-unit id="a36a973f10dd16c9e619f6603156d35894ce21e0" translate="yes" xml:space="preserve">
          <source>U+0019E</source>
          <target state="translated">U+0019E</target>
        </trans-unit>
        <trans-unit id="d00bad4253303e09a738476636ce66202011ebe4" translate="yes" xml:space="preserve">
          <source>U+001B5</source>
          <target state="translated">U+001B5</target>
        </trans-unit>
        <trans-unit id="3d2010424160248324bda296e63dc5baa5abccc3" translate="yes" xml:space="preserve">
          <source>U+001C2</source>
          <target state="translated">U+001C2</target>
        </trans-unit>
        <trans-unit id="a97e1fa68e72b7a67a42424ce121072cd94ed47f" translate="yes" xml:space="preserve">
          <source>U+00237</source>
          <target state="translated">U+00237</target>
        </trans-unit>
        <trans-unit id="4d69ba9aeef07b7e6aec00ad39a4d321bc1283b1" translate="yes" xml:space="preserve">
          <source>U+00250</source>
          <target state="translated">U+00250</target>
        </trans-unit>
        <trans-unit id="22d1c75b25948d29404ba4763f03160a217f8ce1" translate="yes" xml:space="preserve">
          <source>U+00252</source>
          <target state="translated">U+00252</target>
        </trans-unit>
        <trans-unit id="af8bd3d4ba63fc745ea3e4420a61bdd3a064ee4a" translate="yes" xml:space="preserve">
          <source>U+00254</source>
          <target state="translated">U+00254</target>
        </trans-unit>
        <trans-unit id="e2f72aadbe54071d147f6341efdb29de9ad14e4b" translate="yes" xml:space="preserve">
          <source>U+00256</source>
          <target state="translated">U+00256</target>
        </trans-unit>
        <trans-unit id="3b743298c3105d1e76b2ef99bd922992ca69eb0b" translate="yes" xml:space="preserve">
          <source>U+00259</source>
          <target state="translated">U+00259</target>
        </trans-unit>
        <trans-unit id="f6b5e244fb522c59115f69c715d0354897fe151d" translate="yes" xml:space="preserve">
          <source>U+00263</source>
          <target state="translated">U+00263</target>
        </trans-unit>
        <trans-unit id="84a38ffd2f818a690ebf8ad3c32a0dee3976d3c2" translate="yes" xml:space="preserve">
          <source>U+00264</source>
          <target state="translated">U+00264</target>
        </trans-unit>
        <trans-unit id="ce22b1cc1b063128eb38973ddd4dc12b732b062a" translate="yes" xml:space="preserve">
          <source>U+00265</source>
          <target state="translated">U+00265</target>
        </trans-unit>
        <trans-unit id="3feda74990460ad97bf2af797b4de92ad4e69377" translate="yes" xml:space="preserve">
          <source>U+0026C</source>
          <target state="translated">U+0026C</target>
        </trans-unit>
        <trans-unit id="fb8940a89678648a62ccaeecc567280d198499bf" translate="yes" xml:space="preserve">
          <source>U+0026D</source>
          <target state="translated">U+0026D</target>
        </trans-unit>
        <trans-unit id="30b320089b0ebe1dc924fabdc7959e07f9017558" translate="yes" xml:space="preserve">
          <source>U+0026F</source>
          <target state="translated">U+0026F</target>
        </trans-unit>
        <trans-unit id="7c8f384244ed4d4f3a67d4b88a379a42a62a3450" translate="yes" xml:space="preserve">
          <source>U+00270</source>
          <target state="translated">U+00270</target>
        </trans-unit>
        <trans-unit id="ba23d082c51d02d4d3b0cf3c417e7b0d5b1882fb" translate="yes" xml:space="preserve">
          <source>U+00271</source>
          <target state="translated">U+00271</target>
        </trans-unit>
        <trans-unit id="7636f3f9673f30014a2fdc6478383d9c87614698" translate="yes" xml:space="preserve">
          <source>U+00272</source>
          <target state="translated">U+00272</target>
        </trans-unit>
        <trans-unit id="01dddefc8eae304db1b7e88736a5587a1268359c" translate="yes" xml:space="preserve">
          <source>U+00273</source>
          <target state="translated">U+00273</target>
        </trans-unit>
        <trans-unit id="ce39969ebf02b230d2ba87bed283105fbe1cea59" translate="yes" xml:space="preserve">
          <source>U+00277</source>
          <target state="translated">U+00277</target>
        </trans-unit>
        <trans-unit id="b96d46c699a7e2987266871732af97ce398adc70" translate="yes" xml:space="preserve">
          <source>U+00278</source>
          <target state="translated">U+00278</target>
        </trans-unit>
        <trans-unit id="3d8fcb3eaf7d68d0996ce6a5c5b10bd3f138dc0b" translate="yes" xml:space="preserve">
          <source>U+00279</source>
          <target state="translated">U+00279</target>
        </trans-unit>
        <trans-unit id="295b04b25d0a4364b7d20624bbfd762a1ac2d24d" translate="yes" xml:space="preserve">
          <source>U+0027A</source>
          <target state="translated">U+0027A</target>
        </trans-unit>
        <trans-unit id="428b00c9bfc76f2d3f7e81dbafdef44c81f9383c" translate="yes" xml:space="preserve">
          <source>U+0027B</source>
          <target state="translated">U+0027B</target>
        </trans-unit>
        <trans-unit id="85987a0454fb312e830cb7309532a52d7afc75db" translate="yes" xml:space="preserve">
          <source>U+0027C</source>
          <target state="translated">U+0027C</target>
        </trans-unit>
        <trans-unit id="2558e38e8474acc53ec4982d93e9d13a4bc63041" translate="yes" xml:space="preserve">
          <source>U+0027D</source>
          <target state="translated">U+0027D</target>
        </trans-unit>
        <trans-unit id="42b6e861ffe437b44baf1c237ce68646f708c277" translate="yes" xml:space="preserve">
          <source>U+0027E</source>
          <target state="translated">U+0027E</target>
        </trans-unit>
        <trans-unit id="0e54c84a5b06d72b3c31654eaf05f17a286c77ab" translate="yes" xml:space="preserve">
          <source>U+00282</source>
          <target state="translated">U+00282</target>
        </trans-unit>
        <trans-unit id="9542be08bf2ba79f4ea69b9dce257338ef18751d" translate="yes" xml:space="preserve">
          <source>U+00283</source>
          <target state="translated">U+00283</target>
        </trans-unit>
        <trans-unit id="adab2604f6d1b888adaca2bbfe3af33ea3792f5d" translate="yes" xml:space="preserve">
          <source>U+00287</source>
          <target state="translated">U+00287</target>
        </trans-unit>
        <trans-unit id="b301021720610d1741fdf78006f7bb45c6daee9a" translate="yes" xml:space="preserve">
          <source>U+00288</source>
          <target state="translated">U+00288</target>
        </trans-unit>
        <trans-unit id="57b25fd29c3fe282486ef4b1be0821f6d50446df" translate="yes" xml:space="preserve">
          <source>U+0028A</source>
          <target state="translated">U+0028A</target>
        </trans-unit>
        <trans-unit id="ec9d1ded054e0129d538fb38e06b9d0ce47f8ebf" translate="yes" xml:space="preserve">
          <source>U+0028B</source>
          <target state="translated">U+0028B</target>
        </trans-unit>
        <trans-unit id="801b02166c700cd7542c1d28cc993933d11b5412" translate="yes" xml:space="preserve">
          <source>U+0028C</source>
          <target state="translated">U+0028C</target>
        </trans-unit>
        <trans-unit id="6681e52b2ad820f3911c74349c0ab85b44080f65" translate="yes" xml:space="preserve">
          <source>U+0028D</source>
          <target state="translated">U+0028D</target>
        </trans-unit>
        <trans-unit id="4a3deac43610c6162ac1cb41f886e09400fe08b8" translate="yes" xml:space="preserve">
          <source>U+0028E</source>
          <target state="translated">U+0028E</target>
        </trans-unit>
        <trans-unit id="331e4ea4162519246372acf31bcfccd90b5f2e19" translate="yes" xml:space="preserve">
          <source>U+00290</source>
          <target state="translated">U+00290</target>
        </trans-unit>
        <trans-unit id="73e3b7292e0a22832e3cc4ddc5bb2d2599af142c" translate="yes" xml:space="preserve">
          <source>U+00292</source>
          <target state="translated">U+00292</target>
        </trans-unit>
        <trans-unit id="80d635cdf633fe7e924dbe4468906dbbf7629a1d" translate="yes" xml:space="preserve">
          <source>U+00294</source>
          <target state="translated">U+00294</target>
        </trans-unit>
        <trans-unit id="c16d5472652ef43bd638938bd480a057e0eaacab" translate="yes" xml:space="preserve">
          <source>U+00295</source>
          <target state="translated">U+00295</target>
        </trans-unit>
        <trans-unit id="0e52c441e19ba3e888d10d423e575efde3a6bafa" translate="yes" xml:space="preserve">
          <source>U+00296</source>
          <target state="translated">U+00296</target>
        </trans-unit>
        <trans-unit id="2b16c81e0802bf6f6afb5177341c611f360783b5" translate="yes" xml:space="preserve">
          <source>U+0029E</source>
          <target state="translated">U+0029E</target>
        </trans-unit>
        <trans-unit id="6cb9c239aa546e0dcfb7a419346c4206a2606b50" translate="yes" xml:space="preserve">
          <source>U+002A4</source>
          <target state="translated">U+002A4</target>
        </trans-unit>
        <trans-unit id="097c8d622a507f2de93f19daada70e15265cf1fb" translate="yes" xml:space="preserve">
          <source>U+002A7</source>
          <target state="translated">U+002A7</target>
        </trans-unit>
        <trans-unit id="e877d7918f1b3d8d701dd59cba562a8efd857b1f" translate="yes" xml:space="preserve">
          <source>U+002B0</source>
          <target state="translated">U+002B0</target>
        </trans-unit>
        <trans-unit id="3bf87c668ddfeeee7c2060cef24e5ab77904adaf" translate="yes" xml:space="preserve">
          <source>U+002B2</source>
          <target state="translated">U+002B2</target>
        </trans-unit>
        <trans-unit id="42fd5c55674fbddf51d7de0aefcd3b3fc495919d" translate="yes" xml:space="preserve">
          <source>U+002B3</source>
          <target state="translated">U+002B3</target>
        </trans-unit>
        <trans-unit id="4192c941cf326b515a30c940185e4c0d9c126830" translate="yes" xml:space="preserve">
          <source>U+002B7</source>
          <target state="translated">U+002B7</target>
        </trans-unit>
        <trans-unit id="25b13743aa073ff8722db26721538f49723e0b90" translate="yes" xml:space="preserve">
          <source>U+002B8</source>
          <target state="translated">U+002B8</target>
        </trans-unit>
        <trans-unit id="1d752823fa407500f75196a49ca86514c3c0879d" translate="yes" xml:space="preserve">
          <source>U+002BC</source>
          <target state="translated">U+002BC</target>
        </trans-unit>
        <trans-unit id="03ac95360c12f8887b17b20232d25679453703b0" translate="yes" xml:space="preserve">
          <source>U+002C8</source>
          <target state="translated">U+002C8</target>
        </trans-unit>
        <trans-unit id="a4c78134d2d7d185a40523250f9ee8fd16257a9b" translate="yes" xml:space="preserve">
          <source>U+002CC</source>
          <target state="translated">U+002CC</target>
        </trans-unit>
        <trans-unit id="cccb2ff7d94994055f3a3dc0fc58deb9a341d036" translate="yes" xml:space="preserve">
          <source>U+002D0</source>
          <target state="translated">U+002D0</target>
        </trans-unit>
        <trans-unit id="e29b1c1aafd6ed8fcd9e87c84945aea8b226d734" translate="yes" xml:space="preserve">
          <source>U+002D1</source>
          <target state="translated">U+002D1</target>
        </trans-unit>
        <trans-unit id="6831363163e11e2d59a8ededebfeb95a465ee8fd" translate="yes" xml:space="preserve">
          <source>U+002D2</source>
          <target state="translated">U+002D2</target>
        </trans-unit>
        <trans-unit id="bdda9736ee6f277af7b3ffe1fa983f66286cabef" translate="yes" xml:space="preserve">
          <source>U+002D3</source>
          <target state="translated">U+002D3</target>
        </trans-unit>
        <trans-unit id="25c327b01ba9d5d7d0871dd085d8e57b1c54b413" translate="yes" xml:space="preserve">
          <source>U+002D4</source>
          <target state="translated">U+002D4</target>
        </trans-unit>
        <trans-unit id="ff8fb6fd2ceb7bfc04a2d2559bfa93174d5bae88" translate="yes" xml:space="preserve">
          <source>U+002D5</source>
          <target state="translated">U+002D5</target>
        </trans-unit>
        <trans-unit id="d2c582a407b6e9ccfef06f8f3fde0d05fb039e9e" translate="yes" xml:space="preserve">
          <source>U+002D8</source>
          <target state="translated">U+002D8</target>
        </trans-unit>
        <trans-unit id="129d476bea61b7592a6ca0cf4b20c1135330db3f" translate="yes" xml:space="preserve">
          <source>U+002DC</source>
          <target state="translated">U+002DC</target>
        </trans-unit>
        <trans-unit id="78ecb83484352a8149143cfcb7d53f21893e4267" translate="yes" xml:space="preserve">
          <source>U+002E1</source>
          <target state="translated">U+002E1</target>
        </trans-unit>
        <trans-unit id="4e596f80ec8c828f1336b9e07b3601d2574beafa" translate="yes" xml:space="preserve">
          <source>U+002E2</source>
          <target state="translated">U+002E2</target>
        </trans-unit>
        <trans-unit id="96ca94df5b58f7b819b3d05821fec1d621c2c31b" translate="yes" xml:space="preserve">
          <source>U+002E3</source>
          <target state="translated">U+002E3</target>
        </trans-unit>
        <trans-unit id="5af3e022587eadb32cb8956bc9e0cb23febc482d" translate="yes" xml:space="preserve">
          <source>U+00300</source>
          <target state="translated">U+00300</target>
        </trans-unit>
        <trans-unit id="57384dd962625f4e707ca83219aa4026ba580823" translate="yes" xml:space="preserve">
          <source>U+00301</source>
          <target state="translated">U+00301</target>
        </trans-unit>
        <trans-unit id="25622a25320793f31198afe1e84dd14cdbd7db4e" translate="yes" xml:space="preserve">
          <source>U+00302</source>
          <target state="translated">U+00302</target>
        </trans-unit>
        <trans-unit id="2e2e115497d6c34b4c651551de95cf99f558cf7a" translate="yes" xml:space="preserve">
          <source>U+00303</source>
          <target state="translated">U+00303</target>
        </trans-unit>
        <trans-unit id="b9ad39d07e9c200699b65f3ac1b38bf322374704" translate="yes" xml:space="preserve">
          <source>U+00304</source>
          <target state="translated">U+00304</target>
        </trans-unit>
        <trans-unit id="5fb9f31fe383aad4cb9d7441b9ec3371efa9a4fd" translate="yes" xml:space="preserve">
          <source>U+00305</source>
          <target state="translated">U+00305</target>
        </trans-unit>
        <trans-unit id="186bb579588f3cce4563a9889e2b8107ea903a5d" translate="yes" xml:space="preserve">
          <source>U+00306</source>
          <target state="translated">U+00306</target>
        </trans-unit>
        <trans-unit id="35e6b9edc64633750dd2847c1350f0fa7f18500d" translate="yes" xml:space="preserve">
          <source>U+00307</source>
          <target state="translated">U+00307</target>
        </trans-unit>
        <trans-unit id="df91588955565e56b0ea5b0159eb8b0b6cd086bc" translate="yes" xml:space="preserve">
          <source>U+00308</source>
          <target state="translated">U+00308</target>
        </trans-unit>
        <trans-unit id="3ee774a3cc0cc9fdb1cec91598b3ab8b5a0bea72" translate="yes" xml:space="preserve">
          <source>U+00309</source>
          <target state="translated">U+00309</target>
        </trans-unit>
        <trans-unit id="73c4bfa5fcc98a4fe52861638ccbe57da12866f9" translate="yes" xml:space="preserve">
          <source>U+0030A</source>
          <target state="translated">U+0030A</target>
        </trans-unit>
        <trans-unit id="d80abf6f2f5f7c03b83b0c4bf773a1f3ecf6c879" translate="yes" xml:space="preserve">
          <source>U+0030B</source>
          <target state="translated">U+0030B</target>
        </trans-unit>
        <trans-unit id="cc7bed5251d91f923160d5275b3eeb6ed9309bd4" translate="yes" xml:space="preserve">
          <source>U+0030C</source>
          <target state="translated">U+0030C</target>
        </trans-unit>
        <trans-unit id="464a998232158c39793943141d5b367027d70b0c" translate="yes" xml:space="preserve">
          <source>U+00310</source>
          <target state="translated">U+00310</target>
        </trans-unit>
        <trans-unit id="7b7776208309e402b95172dc44806b4dbde6e413" translate="yes" xml:space="preserve">
          <source>U+00312</source>
          <target state="translated">U+00312</target>
        </trans-unit>
        <trans-unit id="d4b942fd861993b03dab4cdaada7e7c5372e6fcc" translate="yes" xml:space="preserve">
          <source>U+00315</source>
          <target state="translated">U+00315</target>
        </trans-unit>
        <trans-unit id="8ae80e88513cf6d54ed7f44fe46aaa1be02aa584" translate="yes" xml:space="preserve">
          <source>U+0031A</source>
          <target state="translated">U+0031A</target>
        </trans-unit>
        <trans-unit id="c54642fb58a9554774c76d94a3ef8aff97628f55" translate="yes" xml:space="preserve">
          <source>U+00321</source>
          <target state="translated">U+00321</target>
        </trans-unit>
        <trans-unit id="51bca611401ba8b89892496564622660d07ec3bc" translate="yes" xml:space="preserve">
          <source>U+00322</source>
          <target state="translated">U+00322</target>
        </trans-unit>
        <trans-unit id="be27d3066a012f06854ab1f51e9fb893211b8eff" translate="yes" xml:space="preserve">
          <source>U+00327</source>
          <target state="translated">U+00327</target>
        </trans-unit>
        <trans-unit id="3a8260b15bb83ec16781a5d3f77fc9967bd74f0f" translate="yes" xml:space="preserve">
          <source>U+00328</source>
          <target state="translated">U+00328</target>
        </trans-unit>
        <trans-unit id="48692a94d00d38eeb8507caed4505142e3cc14c6" translate="yes" xml:space="preserve">
          <source>U+0032A</source>
          <target state="translated">U+0032A</target>
        </trans-unit>
        <trans-unit id="8fd859998199d54e4fb3893eef33aea9481ac2b6" translate="yes" xml:space="preserve">
          <source>U+00330</source>
          <target state="translated">U+00330</target>
        </trans-unit>
        <trans-unit id="2891e8e914f9f7325c955665fb7eff0a6c27e22d" translate="yes" xml:space="preserve">
          <source>U+00332</source>
          <target state="translated">U+00332</target>
        </trans-unit>
        <trans-unit id="5a7ed7dca2330883f5f7e084a758cf0ca813fb63" translate="yes" xml:space="preserve">
          <source>U+00336</source>
          <target state="translated">U+00336</target>
        </trans-unit>
        <trans-unit id="7a273ba8594fdb20158946bf6a254a0fe61dd80c" translate="yes" xml:space="preserve">
          <source>U+00338</source>
          <target state="translated">U+00338</target>
        </trans-unit>
        <trans-unit id="cd0fb4dc0279677094a443b5ec744ef27bd89968" translate="yes" xml:space="preserve">
          <source>U+0034D</source>
          <target state="translated">U+0034D</target>
        </trans-unit>
        <trans-unit id="7966a98e38de21d2e4a6a2f262d7b3918dcd199c" translate="yes" xml:space="preserve">
          <source>U+00391</source>
          <target state="translated">U+00391</target>
        </trans-unit>
        <trans-unit id="d0b8a82183aad42e701c39ceba7d360218063df9" translate="yes" xml:space="preserve">
          <source>U+00392</source>
          <target state="translated">U+00392</target>
        </trans-unit>
        <trans-unit id="21e769d07a8bac0374b5e1ff35fcdc525c3a0570" translate="yes" xml:space="preserve">
          <source>U+00393</source>
          <target state="translated">U+00393</target>
        </trans-unit>
        <trans-unit id="7f904e2ee1a348881515f7decd9e3f23bf6dc26c" translate="yes" xml:space="preserve">
          <source>U+00394</source>
          <target state="translated">U+00394</target>
        </trans-unit>
        <trans-unit id="874f226781592e1532ed7436b4e42bc8d2623b30" translate="yes" xml:space="preserve">
          <source>U+00395</source>
          <target state="translated">U+00395</target>
        </trans-unit>
        <trans-unit id="cedf61e542d13a336c2a628c1099326c0f63969a" translate="yes" xml:space="preserve">
          <source>U+00396</source>
          <target state="translated">U+00396</target>
        </trans-unit>
        <trans-unit id="3ca968a155717e85467418e67d2610ba368a4d66" translate="yes" xml:space="preserve">
          <source>U+00397</source>
          <target state="translated">U+00397</target>
        </trans-unit>
        <trans-unit id="87ed7c2231196be8910d2431694088b68771153f" translate="yes" xml:space="preserve">
          <source>U+00398</source>
          <target state="translated">U+00398</target>
        </trans-unit>
        <trans-unit id="b51e81c4c9e7a0cd5d61c3962bd3e7e9d53cbad6" translate="yes" xml:space="preserve">
          <source>U+00399</source>
          <target state="translated">U+00399</target>
        </trans-unit>
        <trans-unit id="97851e883fe3fac9942cb0f36a8ececcff49f289" translate="yes" xml:space="preserve">
          <source>U+0039A</source>
          <target state="translated">U+0039A</target>
        </trans-unit>
        <trans-unit id="2d0db6ebb502514c3a6895893038af4b7f8a9fa0" translate="yes" xml:space="preserve">
          <source>U+0039B</source>
          <target state="translated">U+0039B</target>
        </trans-unit>
        <trans-unit id="2af5164dc2a9ba06dbb73864082e76909bdb9cb0" translate="yes" xml:space="preserve">
          <source>U+0039C</source>
          <target state="translated">U+0039C</target>
        </trans-unit>
        <trans-unit id="191917b63fcaf534c3267b3fedac596812b92fa8" translate="yes" xml:space="preserve">
          <source>U+0039D</source>
          <target state="translated">U+0039D</target>
        </trans-unit>
        <trans-unit id="7608890a629a72f35fa9c49e4ddbfc577d3144e8" translate="yes" xml:space="preserve">
          <source>U+0039E</source>
          <target state="translated">U+0039E</target>
        </trans-unit>
        <trans-unit id="8993ed83e6a2420ffd66e48a8e14ff67abfb34a7" translate="yes" xml:space="preserve">
          <source>U+0039F</source>
          <target state="translated">U+0039F</target>
        </trans-unit>
        <trans-unit id="6647e8df9733081f6109aa97088862e0e4abcc2f" translate="yes" xml:space="preserve">
          <source>U+003A0</source>
          <target state="translated">U+003A0</target>
        </trans-unit>
        <trans-unit id="9ade840b2eaccf8824bb01b9a58355de5a4db766" translate="yes" xml:space="preserve">
          <source>U+003A1</source>
          <target state="translated">U+003A1</target>
        </trans-unit>
        <trans-unit id="48c088188b148514e71e0c8cdbaf794530759dde" translate="yes" xml:space="preserve">
          <source>U+003A3</source>
          <target state="translated">U+003A3</target>
        </trans-unit>
        <trans-unit id="251b1650fa3e7210ec229397ee6d7a5700ee5e52" translate="yes" xml:space="preserve">
          <source>U+003A4</source>
          <target state="translated">U+003A4</target>
        </trans-unit>
        <trans-unit id="b76ffee0ec8b7f087677c31f6b2a5f52458a9800" translate="yes" xml:space="preserve">
          <source>U+003A5</source>
          <target state="translated">U+003A5</target>
        </trans-unit>
        <trans-unit id="19ede9f206390ad0ddee6b1fb38a306428305f60" translate="yes" xml:space="preserve">
          <source>U+003A6</source>
          <target state="translated">U+003A6</target>
        </trans-unit>
        <trans-unit id="3ac9debd3d56489ff8cc8f1aceb7a3959cf30586" translate="yes" xml:space="preserve">
          <source>U+003A7</source>
          <target state="translated">U+003A7</target>
        </trans-unit>
        <trans-unit id="f8c95dbd6c98b96c44b7187f2136d2df5b80baa4" translate="yes" xml:space="preserve">
          <source>U+003A8</source>
          <target state="translated">U+003A8</target>
        </trans-unit>
        <trans-unit id="b5b49f6804dd1027a3b1b1149fc05e55ea028657" translate="yes" xml:space="preserve">
          <source>U+003A9</source>
          <target state="translated">U+003A9</target>
        </trans-unit>
        <trans-unit id="7df4c4d8574e0257f7b554e72154b40a4f961e40" translate="yes" xml:space="preserve">
          <source>U+003B1</source>
          <target state="translated">U+003B1</target>
        </trans-unit>
        <trans-unit id="38b05037dfcca16e3bc0aec40a79fe5f3f7a6bae" translate="yes" xml:space="preserve">
          <source>U+003B2</source>
          <target state="translated">U+003B2</target>
        </trans-unit>
        <trans-unit id="2017af14c2418d90536823e9c1cfb41a73a97387" translate="yes" xml:space="preserve">
          <source>U+003B3</source>
          <target state="translated">U+003B3</target>
        </trans-unit>
        <trans-unit id="8489235bd9087a3790bb0c0a99390be264d8d42d" translate="yes" xml:space="preserve">
          <source>U+003B4</source>
          <target state="translated">U+003B4</target>
        </trans-unit>
        <trans-unit id="0ad7e02862c7e6a2b120177c0a5806e81ecd90fa" translate="yes" xml:space="preserve">
          <source>U+003B5</source>
          <target state="translated">U+003B5</target>
        </trans-unit>
        <trans-unit id="f86fb3232412afb5ca7a0568cb934725d5ae2571" translate="yes" xml:space="preserve">
          <source>U+003B6</source>
          <target state="translated">U+003B6</target>
        </trans-unit>
        <trans-unit id="ad44f693fd33cb248ddd8ec41a912b824b27afa8" translate="yes" xml:space="preserve">
          <source>U+003B7</source>
          <target state="translated">U+003B7</target>
        </trans-unit>
        <trans-unit id="1c8798670c5f19f4d4b30e3ea0398df6f3da0e38" translate="yes" xml:space="preserve">
          <source>U+003B8</source>
          <target state="translated">U+003B8</target>
        </trans-unit>
        <trans-unit id="a514df160b479280b550a9dbd13772aa1835ad42" translate="yes" xml:space="preserve">
          <source>U+003B9</source>
          <target state="translated">U+003B9</target>
        </trans-unit>
        <trans-unit id="104b9e81ad12eeb0661deea9dda2b3c4723787b1" translate="yes" xml:space="preserve">
          <source>U+003BA</source>
          <target state="translated">U+003BA</target>
        </trans-unit>
        <trans-unit id="b4a242d16cea0ddfebf1382603d6d19208d8cae8" translate="yes" xml:space="preserve">
          <source>U+003BB</source>
          <target state="translated">U+003BB</target>
        </trans-unit>
        <trans-unit id="50db9f12fc5a232bf3528c5a10d947e05c5f9c2a" translate="yes" xml:space="preserve">
          <source>U+003BC</source>
          <target state="translated">U+003BC</target>
        </trans-unit>
        <trans-unit id="7635ce1de66b2503108277821ff32585538c38f6" translate="yes" xml:space="preserve">
          <source>U+003BD</source>
          <target state="translated">U+003BD</target>
        </trans-unit>
        <trans-unit id="ed86215a643340439e73b43c12ec22cd74a09342" translate="yes" xml:space="preserve">
          <source>U+003BE</source>
          <target state="translated">U+003BE</target>
        </trans-unit>
        <trans-unit id="5b74cb8e40d2b1ed841b6067924c1bb3f3081218" translate="yes" xml:space="preserve">
          <source>U+003BF</source>
          <target state="translated">U+003BF</target>
        </trans-unit>
        <trans-unit id="8cf73e2899a7d36e9f5bbd4b5a425f706ef33084" translate="yes" xml:space="preserve">
          <source>U+003C0</source>
          <target state="translated">U+003C0</target>
        </trans-unit>
        <trans-unit id="ee39537c45109587e3c6142781d56c0bd39af74c" translate="yes" xml:space="preserve">
          <source>U+003C1</source>
          <target state="translated">U+003C1</target>
        </trans-unit>
        <trans-unit id="fc117fba7f15ba9d71216e3c390473eee4d9691d" translate="yes" xml:space="preserve">
          <source>U+003C2</source>
          <target state="translated">U+003C2</target>
        </trans-unit>
        <trans-unit id="eaabe77bc0eacfab586dd67830aa955b7ecb2abb" translate="yes" xml:space="preserve">
          <source>U+003C3</source>
          <target state="translated">U+003C3</target>
        </trans-unit>
        <trans-unit id="886f6e97a866bf8552f82f80b5cd54d69deb6edc" translate="yes" xml:space="preserve">
          <source>U+003C4</source>
          <target state="translated">U+003C4</target>
        </trans-unit>
        <trans-unit id="37f57a526420b1b434ced0d421633312bfacb43a" translate="yes" xml:space="preserve">
          <source>U+003C5</source>
          <target state="translated">U+003C5</target>
        </trans-unit>
        <trans-unit id="47fa09bd231213c6ef064645c7a9a37d01d7a340" translate="yes" xml:space="preserve">
          <source>U+003C6</source>
          <target state="translated">U+003C6</target>
        </trans-unit>
        <trans-unit id="05bd5f84778ecbe4800ec121d5cff09af25879b2" translate="yes" xml:space="preserve">
          <source>U+003C7</source>
          <target state="translated">U+003C7</target>
        </trans-unit>
        <trans-unit id="721198dd581f50ac452dd324cdd78024e3f0ea83" translate="yes" xml:space="preserve">
          <source>U+003C8</source>
          <target state="translated">U+003C8</target>
        </trans-unit>
        <trans-unit id="cb5185c50b8e1cc18ef11fcd725b6f5f34fbd6be" translate="yes" xml:space="preserve">
          <source>U+003C9</source>
          <target state="translated">U+003C9</target>
        </trans-unit>
        <trans-unit id="9f6a8ca363f10b4b3b309c17eaadf1051f19e694" translate="yes" xml:space="preserve">
          <source>U+003D0</source>
          <target state="translated">U+003D0</target>
        </trans-unit>
        <trans-unit id="bc5c825b8dc84bc4cd8b8d4ea4013440a734f35d" translate="yes" xml:space="preserve">
          <source>U+003D1</source>
          <target state="translated">U+003D1</target>
        </trans-unit>
        <trans-unit id="7aea0cab7b710b4d843d21594fbe14aefcfed4b0" translate="yes" xml:space="preserve">
          <source>U+003D5</source>
          <target state="translated">U+003D5</target>
        </trans-unit>
        <trans-unit id="b4f7595d714f72bfe55c1fcb84a3e89af7755a50" translate="yes" xml:space="preserve">
          <source>U+003D6</source>
          <target state="translated">U+003D6</target>
        </trans-unit>
        <trans-unit id="4401a4d25fbd6623fc6012216b21bcd1a2a739e3" translate="yes" xml:space="preserve">
          <source>U+003D8</source>
          <target state="translated">U+003D8</target>
        </trans-unit>
        <trans-unit id="e478f2f51e8d87db9b42731a4f38cfdf153a1ab7" translate="yes" xml:space="preserve">
          <source>U+003D9</source>
          <target state="translated">U+003D9</target>
        </trans-unit>
        <trans-unit id="fd18e42bf717cf4641f290ef53660e47279580ad" translate="yes" xml:space="preserve">
          <source>U+003DA</source>
          <target state="translated">U+003DA</target>
        </trans-unit>
        <trans-unit id="b675867190ca1ec0938e31a984cdf05979ecd3e0" translate="yes" xml:space="preserve">
          <source>U+003DB</source>
          <target state="translated">U+003DB</target>
        </trans-unit>
        <trans-unit id="92b09d13f646288f372d15ca7398b72236d3e04b" translate="yes" xml:space="preserve">
          <source>U+003DC</source>
          <target state="translated">U+003DC</target>
        </trans-unit>
        <trans-unit id="3ade589f9dd6d374474593df9134c7efebec6b94" translate="yes" xml:space="preserve">
          <source>U+003DD</source>
          <target state="translated">U+003DD</target>
        </trans-unit>
        <trans-unit id="0a92af0f627aa4fcc46123b87ceee9c99b396e0e" translate="yes" xml:space="preserve">
          <source>U+003DE</source>
          <target state="translated">U+003DE</target>
        </trans-unit>
        <trans-unit id="59c206717250d5c1b1abee82cd488c369d4eae18" translate="yes" xml:space="preserve">
          <source>U+003DF</source>
          <target state="translated">U+003DF</target>
        </trans-unit>
        <trans-unit id="5b469342b60deb763e4d94f943821445e3cd4910" translate="yes" xml:space="preserve">
          <source>U+003E0</source>
          <target state="translated">U+003E0</target>
        </trans-unit>
        <trans-unit id="0f3e4bc0231981c839c803015c8410b20dfc4bcd" translate="yes" xml:space="preserve">
          <source>U+003E1</source>
          <target state="translated">U+003E1</target>
        </trans-unit>
        <trans-unit id="07fc86395ddc909da4d31f240fb5e1cb0c418d8e" translate="yes" xml:space="preserve">
          <source>U+003F0</source>
          <target state="translated">U+003F0</target>
        </trans-unit>
        <trans-unit id="07cd0547b13165fe26a097f326f44a691e487328" translate="yes" xml:space="preserve">
          <source>U+003F1</source>
          <target state="translated">U+003F1</target>
        </trans-unit>
        <trans-unit id="7b7b6789e29307728ee9f301af1e0d351e536bf5" translate="yes" xml:space="preserve">
          <source>U+003F4</source>
          <target state="translated">U+003F4</target>
        </trans-unit>
        <trans-unit id="4901bc1852316df9e9dc777fdb7aad5592a6a0f7" translate="yes" xml:space="preserve">
          <source>U+003F5</source>
          <target state="translated">U+003F5</target>
        </trans-unit>
        <trans-unit id="92620f957c75e73c58904d8b0538e74afadfb90c" translate="yes" xml:space="preserve">
          <source>U+003F6</source>
          <target state="translated">U+003F6</target>
        </trans-unit>
        <trans-unit id="c5566e46f42aac1f8e11d42dcfc259d87a7a10fb" translate="yes" xml:space="preserve">
          <source>U+01D2C</source>
          <target state="translated">U+01D2C</target>
        </trans-unit>
        <trans-unit id="37b10b6a06b252506911945e6db92b0b9c6d95f4" translate="yes" xml:space="preserve">
          <source>U+01D2E</source>
          <target state="translated">U+01D2E</target>
        </trans-unit>
        <trans-unit id="a00d8269be4c3eb9f91c1b40696ae76cc8589071" translate="yes" xml:space="preserve">
          <source>U+01D30</source>
          <target state="translated">U+01D30</target>
        </trans-unit>
        <trans-unit id="5c29e525faf0a50aecb6fb3a5f9b7e486e1ef1e9" translate="yes" xml:space="preserve">
          <source>U+01D31</source>
          <target state="translated">U+01D31</target>
        </trans-unit>
        <trans-unit id="99eec604971e8c65be4840320e7a69306ad535a6" translate="yes" xml:space="preserve">
          <source>U+01D33</source>
          <target state="translated">U+01D33</target>
        </trans-unit>
        <trans-unit id="440561aa92670ad776b4e75b23fad5219dee516a" translate="yes" xml:space="preserve">
          <source>U+01D34</source>
          <target state="translated">U+01D34</target>
        </trans-unit>
        <trans-unit id="fbb7a3bc03c96572e4387ff20df34fbc05f8fb3f" translate="yes" xml:space="preserve">
          <source>U+01D35</source>
          <target state="translated">U+01D35</target>
        </trans-unit>
        <trans-unit id="eb47bce466c235deca517ea5540e4d147ebe1a9e" translate="yes" xml:space="preserve">
          <source>U+01D36</source>
          <target state="translated">U+01D36</target>
        </trans-unit>
        <trans-unit id="17959ef44c1b0741106ba78930d26a1c07a3caf0" translate="yes" xml:space="preserve">
          <source>U+01D37</source>
          <target state="translated">U+01D37</target>
        </trans-unit>
        <trans-unit id="cb222e37dc1ee67b19e08f29dd06ed5347e1fa23" translate="yes" xml:space="preserve">
          <source>U+01D38</source>
          <target state="translated">U+01D38</target>
        </trans-unit>
        <trans-unit id="f848ac41c0abe672127b3606e9d0c9b2c905c84b" translate="yes" xml:space="preserve">
          <source>U+01D39</source>
          <target state="translated">U+01D39</target>
        </trans-unit>
        <trans-unit id="156f084d069ee73bdf463b033eff3e6fc5d68a08" translate="yes" xml:space="preserve">
          <source>U+01D3A</source>
          <target state="translated">U+01D3A</target>
        </trans-unit>
        <trans-unit id="c6774c926ad79fecccfd4abca40531a24c3b7a55" translate="yes" xml:space="preserve">
          <source>U+01D3C</source>
          <target state="translated">U+01D3C</target>
        </trans-unit>
        <trans-unit id="20d904a6751c57b2859b8c67b0b30073b01cc53b" translate="yes" xml:space="preserve">
          <source>U+01D3E</source>
          <target state="translated">U+01D3E</target>
        </trans-unit>
        <trans-unit id="d053d05169ebb281dedc9ae9dfe2590a6c369c1d" translate="yes" xml:space="preserve">
          <source>U+01D3F</source>
          <target state="translated">U+01D3F</target>
        </trans-unit>
        <trans-unit id="9b2ab1ad7be189b75bfb7de1714d1ad8a985c107" translate="yes" xml:space="preserve">
          <source>U+01D40</source>
          <target state="translated">U+01D40</target>
        </trans-unit>
        <trans-unit id="34aae8c7365b76e9e21ce5f42ad04f1e94b1f3b8" translate="yes" xml:space="preserve">
          <source>U+01D41</source>
          <target state="translated">U+01D41</target>
        </trans-unit>
        <trans-unit id="441ba9dede9005279c903a6e57f96fe78206c8d8" translate="yes" xml:space="preserve">
          <source>U+01D42</source>
          <target state="translated">U+01D42</target>
        </trans-unit>
        <trans-unit id="163b08686ee14dbd18f23a98a52a47fd62d588ee" translate="yes" xml:space="preserve">
          <source>U+01D43</source>
          <target state="translated">U+01D43</target>
        </trans-unit>
        <trans-unit id="30fdf3ad9db991dd0466575db2f89a26a852c7ee" translate="yes" xml:space="preserve">
          <source>U+01D45</source>
          <target state="translated">U+01D45</target>
        </trans-unit>
        <trans-unit id="797e81a34a07bac310482131acefad71a5abef2d" translate="yes" xml:space="preserve">
          <source>U+01D47</source>
          <target state="translated">U+01D47</target>
        </trans-unit>
        <trans-unit id="a411f60238db6f6b63261d8c07617746ca432266" translate="yes" xml:space="preserve">
          <source>U+01D48</source>
          <target state="translated">U+01D48</target>
        </trans-unit>
        <trans-unit id="c9fb343fc16c5b72e32f29927937a89b7af099fb" translate="yes" xml:space="preserve">
          <source>U+01D49</source>
          <target state="translated">U+01D49</target>
        </trans-unit>
        <trans-unit id="27b54333a235194c6ac53a272d181cb739911513" translate="yes" xml:space="preserve">
          <source>U+01D4B</source>
          <target state="translated">U+01D4B</target>
        </trans-unit>
        <trans-unit id="afb04e59e5d5261a7404bb86c49e2dda11e7d50f" translate="yes" xml:space="preserve">
          <source>U+01D4D</source>
          <target state="translated">U+01D4D</target>
        </trans-unit>
        <trans-unit id="0455ff4d12b80da3fab3d52ffb0b623e56441abb" translate="yes" xml:space="preserve">
          <source>U+01D4F</source>
          <target state="translated">U+01D4F</target>
        </trans-unit>
        <trans-unit id="dbee94c172667d77dbb460fe05b105b373ed9eb9" translate="yes" xml:space="preserve">
          <source>U+01D50</source>
          <target state="translated">U+01D50</target>
        </trans-unit>
        <trans-unit id="ca425c53e63ac2819b4b1438353c6f41043d7a41" translate="yes" xml:space="preserve">
          <source>U+01D52</source>
          <target state="translated">U+01D52</target>
        </trans-unit>
        <trans-unit id="1510ed9914e77d0f8fd3e94ad0c76b070ae53d74" translate="yes" xml:space="preserve">
          <source>U+01D56</source>
          <target state="translated">U+01D56</target>
        </trans-unit>
        <trans-unit id="39f62505bed4b421bf0728e1b93111477d77435c" translate="yes" xml:space="preserve">
          <source>U+01D57</source>
          <target state="translated">U+01D57</target>
        </trans-unit>
        <trans-unit id="8b29aea27d0cf669223fb74be47e4710519173e1" translate="yes" xml:space="preserve">
          <source>U+01D58</source>
          <target state="translated">U+01D58</target>
        </trans-unit>
        <trans-unit id="88779dd2e4508d37bd39f537906180eb80a4ba7b" translate="yes" xml:space="preserve">
          <source>U+01D5B</source>
          <target state="translated">U+01D5B</target>
        </trans-unit>
        <trans-unit id="6c05ec71eeb4ed95030bc369513a9c776e552879" translate="yes" xml:space="preserve">
          <source>U+01D5D</source>
          <target state="translated">U+01D5D</target>
        </trans-unit>
        <trans-unit id="435d4825e1c943f064c7a47783bfcbdf7cde0725" translate="yes" xml:space="preserve">
          <source>U+01D5E</source>
          <target state="translated">U+01D5E</target>
        </trans-unit>
        <trans-unit id="0aa39de854d3a50b9b10d2e69c0d4d92bc238432" translate="yes" xml:space="preserve">
          <source>U+01D5F</source>
          <target state="translated">U+01D5F</target>
        </trans-unit>
        <trans-unit id="4a0cee142db79062d3341c0f8505515c14d123fe" translate="yes" xml:space="preserve">
          <source>U+01D60</source>
          <target state="translated">U+01D60</target>
        </trans-unit>
        <trans-unit id="e741d8c3aa7d60204eda169c57106e15f8882d08" translate="yes" xml:space="preserve">
          <source>U+01D61</source>
          <target state="translated">U+01D61</target>
        </trans-unit>
        <trans-unit id="d4bc07109e6ceceb3eaccbb2b8e8939ab0efbd49" translate="yes" xml:space="preserve">
          <source>U+01D62</source>
          <target state="translated">U+01D62</target>
        </trans-unit>
        <trans-unit id="50763e8cb88d2a94fbd6e8bbf258ac2f3d205929" translate="yes" xml:space="preserve">
          <source>U+01D63</source>
          <target state="translated">U+01D63</target>
        </trans-unit>
        <trans-unit id="346d9c11c21d1b7105090de2749717a2d445a941" translate="yes" xml:space="preserve">
          <source>U+01D64</source>
          <target state="translated">U+01D64</target>
        </trans-unit>
        <trans-unit id="da208e5126e0afc89dce4184ae73f645f4278d97" translate="yes" xml:space="preserve">
          <source>U+01D65</source>
          <target state="translated">U+01D65</target>
        </trans-unit>
        <trans-unit id="822153e6da7056909aa3045783b805c02b93fbc4" translate="yes" xml:space="preserve">
          <source>U+01D66</source>
          <target state="translated">U+01D66</target>
        </trans-unit>
        <trans-unit id="38a14ca2e36f22c3c3809fa99933315f23f92ccc" translate="yes" xml:space="preserve">
          <source>U+01D67</source>
          <target state="translated">U+01D67</target>
        </trans-unit>
        <trans-unit id="20f1483de267b860c85f652204cd1f93f696da21" translate="yes" xml:space="preserve">
          <source>U+01D68</source>
          <target state="translated">U+01D68</target>
        </trans-unit>
        <trans-unit id="233d5e218fc2a0060e8c1bc038d1a74beeb754ce" translate="yes" xml:space="preserve">
          <source>U+01D69</source>
          <target state="translated">U+01D69</target>
        </trans-unit>
        <trans-unit id="5ffdf6e6becfd7d7a6907d2806ba362cb32ee7ab" translate="yes" xml:space="preserve">
          <source>U+01D6A</source>
          <target state="translated">U+01D6A</target>
        </trans-unit>
        <trans-unit id="54a5801c603f0530be0e5268e32f06e62414e7cc" translate="yes" xml:space="preserve">
          <source>U+01D9C</source>
          <target state="translated">U+01D9C</target>
        </trans-unit>
        <trans-unit id="e2edeb19ea8e681fefbd9a4bcbfe98ba0e602949" translate="yes" xml:space="preserve">
          <source>U+01DA0</source>
          <target state="translated">U+01DA0</target>
        </trans-unit>
        <trans-unit id="c8b08720266cd22f34f16a43a75856cd70610c2e" translate="yes" xml:space="preserve">
          <source>U+01DA5</source>
          <target state="translated">U+01DA5</target>
        </trans-unit>
        <trans-unit id="c4ee296bbf06e4d45d1ea5ed87a8a04b75e1e207" translate="yes" xml:space="preserve">
          <source>U+01DB2</source>
          <target state="translated">U+01DB2</target>
        </trans-unit>
        <trans-unit id="a44d758f0df9a4bfd941e5517bb24c8174dacfc6" translate="yes" xml:space="preserve">
          <source>U+01DBB</source>
          <target state="translated">U+01DBB</target>
        </trans-unit>
        <trans-unit id="9465fb99cea4715205a1c75bb4fce4ef25e41dcd" translate="yes" xml:space="preserve">
          <source>U+01DBF</source>
          <target state="translated">U+01DBF</target>
        </trans-unit>
        <trans-unit id="3de5f445040ec9f82e5d0f7be1114da98b3824e9" translate="yes" xml:space="preserve">
          <source>U+02002</source>
          <target state="translated">U+02002</target>
        </trans-unit>
        <trans-unit id="7ed4f9267e6ab7118d848989813ef0313baef1c1" translate="yes" xml:space="preserve">
          <source>U+02003</source>
          <target state="translated">U+02003</target>
        </trans-unit>
        <trans-unit id="42f12996d3ec39f6df05c0141c3c1c2960e3b4d3" translate="yes" xml:space="preserve">
          <source>U+02005</source>
          <target state="translated">U+02005</target>
        </trans-unit>
        <trans-unit id="dc54e003671d7d9356c197db1df194b01cdc025f" translate="yes" xml:space="preserve">
          <source>U+02009</source>
          <target state="translated">U+02009</target>
        </trans-unit>
        <trans-unit id="6d199f8b861652f6b03dd0371fdf6cef0a20bb9e" translate="yes" xml:space="preserve">
          <source>U+0200A</source>
          <target state="translated">U+0200A</target>
        </trans-unit>
        <trans-unit id="54b2c267ddbbf1a38b0df143b7feae19c2b3b675" translate="yes" xml:space="preserve">
          <source>U+02013</source>
          <target state="translated">U+02013</target>
        </trans-unit>
        <trans-unit id="91a455cf9bf5641d8dcb36e61a713b743388b2b9" translate="yes" xml:space="preserve">
          <source>U+02014</source>
          <target state="translated">U+02014</target>
        </trans-unit>
        <trans-unit id="871fd5b4639ffc22262b27271eebe1f5a15dfa8b" translate="yes" xml:space="preserve">
          <source>U+02016</source>
          <target state="translated">U+02016</target>
        </trans-unit>
        <trans-unit id="01237e76c48f125ae7368ff228668715b09fd166" translate="yes" xml:space="preserve">
          <source>U+02018</source>
          <target state="translated">U+02018</target>
        </trans-unit>
        <trans-unit id="0eb233c9d60b05a1ebd74cbe88384226b43cdb6d" translate="yes" xml:space="preserve">
          <source>U+02019</source>
          <target state="translated">U+02019</target>
        </trans-unit>
        <trans-unit id="27981c42fbe101279cd9112d5d0e4a5967f72e54" translate="yes" xml:space="preserve">
          <source>U+0201B</source>
          <target state="translated">U+0201B</target>
        </trans-unit>
        <trans-unit id="fec2f513e523c411070eaf46be64b07cf927cbba" translate="yes" xml:space="preserve">
          <source>U+0201C</source>
          <target state="translated">U+0201C</target>
        </trans-unit>
        <trans-unit id="05b273439e23dbd70de0618defd73bd52fafefd8" translate="yes" xml:space="preserve">
          <source>U+0201D</source>
          <target state="translated">U+0201D</target>
        </trans-unit>
        <trans-unit id="d9a8337f65d4bfe3fdd44241cb7c936971b12090" translate="yes" xml:space="preserve">
          <source>U+02020</source>
          <target state="translated">U+02020</target>
        </trans-unit>
        <trans-unit id="51e65c64dccac09993ecb39aba5db77093ced71a" translate="yes" xml:space="preserve">
          <source>U+02021</source>
          <target state="translated">U+02021</target>
        </trans-unit>
        <trans-unit id="6a89805f557530dd85e0f992fd6f2b9ab2119a0f" translate="yes" xml:space="preserve">
          <source>U+02022</source>
          <target state="translated">U+02022</target>
        </trans-unit>
        <trans-unit id="606d247e38e4f88d07ac7af7b3a2988d674ab100" translate="yes" xml:space="preserve">
          <source>U+02026</source>
          <target state="translated">U+02026</target>
        </trans-unit>
        <trans-unit id="7069c8a14244c42d1eb9eeafe2a54d3707e415a2" translate="yes" xml:space="preserve">
          <source>U+02030</source>
          <target state="translated">U+02030</target>
        </trans-unit>
        <trans-unit id="51ee0c647f9e7d54d78c0bca676090c3ed3a58ab" translate="yes" xml:space="preserve">
          <source>U+02031</source>
          <target state="translated">U+02031</target>
        </trans-unit>
        <trans-unit id="d35b0db70efbcf055ebe5d255382dac5a8c513a9" translate="yes" xml:space="preserve">
          <source>U+02032</source>
          <target state="translated">U+02032</target>
        </trans-unit>
        <trans-unit id="aff69f7e2c75a413ebf0ae8e5e2e3274abef57cf" translate="yes" xml:space="preserve">
          <source>U+02033</source>
          <target state="translated">U+02033</target>
        </trans-unit>
        <trans-unit id="5d913be71042ef8f5aaec8feff826a19c6bafa80" translate="yes" xml:space="preserve">
          <source>U+02034</source>
          <target state="translated">U+02034</target>
        </trans-unit>
        <trans-unit id="16c2015f83babb15b41b582ae1ad4b93020c1e8e" translate="yes" xml:space="preserve">
          <source>U+02035</source>
          <target state="translated">U+02035</target>
        </trans-unit>
        <trans-unit id="7e44d236062ccca1c221b6d032404da42950e91e" translate="yes" xml:space="preserve">
          <source>U+02036</source>
          <target state="translated">U+02036</target>
        </trans-unit>
        <trans-unit id="2844451d093078b267408c29d08b80334758c880" translate="yes" xml:space="preserve">
          <source>U+02037</source>
          <target state="translated">U+02037</target>
        </trans-unit>
        <trans-unit id="98711fdfbbcf42c62a5faf024882880528e15cf8" translate="yes" xml:space="preserve">
          <source>U+02039</source>
          <target state="translated">U+02039</target>
        </trans-unit>
        <trans-unit id="41ffd3912c77f96e037ea691fad61cdbf02c8b23" translate="yes" xml:space="preserve">
          <source>U+0203A</source>
          <target state="translated">U+0203A</target>
        </trans-unit>
        <trans-unit id="b8dc2d1d755a5fdfbc9b3bf3479d34e1c241cadf" translate="yes" xml:space="preserve">
          <source>U+0203C</source>
          <target state="translated">U+0203C</target>
        </trans-unit>
        <trans-unit id="09fd53c1a858647b42d511d9c015fee67fb9445c" translate="yes" xml:space="preserve">
          <source>U+02040</source>
          <target state="translated">U+02040</target>
        </trans-unit>
        <trans-unit id="b477796eb380471732cec950b3b8f7940a1e7e45" translate="yes" xml:space="preserve">
          <source>U+02049</source>
          <target state="translated">U+02049</target>
        </trans-unit>
        <trans-unit id="ca926b0118288b830cb51c220e41ee7e352a28a9" translate="yes" xml:space="preserve">
          <source>U+02057</source>
          <target state="translated">U+02057</target>
        </trans-unit>
        <trans-unit id="1bc69948707de37d18ec28f69dd19f065541aae7" translate="yes" xml:space="preserve">
          <source>U+0205D</source>
          <target state="translated">U+0205D</target>
        </trans-unit>
        <trans-unit id="d39d51da22a7906847da6453bde31ff3b754dfa9" translate="yes" xml:space="preserve">
          <source>U+02060</source>
          <target state="translated">U+02060</target>
        </trans-unit>
        <trans-unit id="1efdd22dc573d2edef8ee5ea3382e63d224d137e" translate="yes" xml:space="preserve">
          <source>U+02070</source>
          <target state="translated">U+02070</target>
        </trans-unit>
        <trans-unit id="1dc71366ffb5b8b3e001f3a9aa2f6bb12d28be57" translate="yes" xml:space="preserve">
          <source>U+02071</source>
          <target state="translated">U+02071</target>
        </trans-unit>
        <trans-unit id="4dd066f38efb209c9f79538e5a2ea272214b954d" translate="yes" xml:space="preserve">
          <source>U+02074</source>
          <target state="translated">U+02074</target>
        </trans-unit>
        <trans-unit id="f9ddb001c9f5fd2e27fbae237f25c28b8f5ae871" translate="yes" xml:space="preserve">
          <source>U+02075</source>
          <target state="translated">U+02075</target>
        </trans-unit>
        <trans-unit id="cdd7f27ef18f2611da391c880f368056e0477cc1" translate="yes" xml:space="preserve">
          <source>U+02076</source>
          <target state="translated">U+02076</target>
        </trans-unit>
        <trans-unit id="1aef93443bcba12e0e269ea6437722a5efd9165b" translate="yes" xml:space="preserve">
          <source>U+02077</source>
          <target state="translated">U+02077</target>
        </trans-unit>
        <trans-unit id="9dff77c28d6e4f9f9a7a07a1a99dbfde46ad0e2d" translate="yes" xml:space="preserve">
          <source>U+02078</source>
          <target state="translated">U+02078</target>
        </trans-unit>
        <trans-unit id="ca05f7941a68cd5dbe4ad921bce62a99bc20a13e" translate="yes" xml:space="preserve">
          <source>U+02079</source>
          <target state="translated">U+02079</target>
        </trans-unit>
        <trans-unit id="18a3eef792215619326e47c5780075df279de886" translate="yes" xml:space="preserve">
          <source>U+0207A</source>
          <target state="translated">U+0207A</target>
        </trans-unit>
        <trans-unit id="6859918ed86a97585a8af7827424e777f0012f32" translate="yes" xml:space="preserve">
          <source>U+0207B</source>
          <target state="translated">U+0207B</target>
        </trans-unit>
        <trans-unit id="4f9765389af5519dc7a0d091c472c04d25872e51" translate="yes" xml:space="preserve">
          <source>U+0207C</source>
          <target state="translated">U+0207C</target>
        </trans-unit>
        <trans-unit id="dbd3025a6eeefb504b83034db7784310cd98a7b8" translate="yes" xml:space="preserve">
          <source>U+0207D</source>
          <target state="translated">U+0207D</target>
        </trans-unit>
        <trans-unit id="2a01a9a590ac5e58a83b33d92499326aa532de31" translate="yes" xml:space="preserve">
          <source>U+0207E</source>
          <target state="translated">U+0207E</target>
        </trans-unit>
        <trans-unit id="522f4f2ebb95bd280743693b122524e8e120ca0b" translate="yes" xml:space="preserve">
          <source>U+0207F</source>
          <target state="translated">U+0207F</target>
        </trans-unit>
        <trans-unit id="854460d95686b5484c63e7b1c97dc7aec182f465" translate="yes" xml:space="preserve">
          <source>U+02080</source>
          <target state="translated">U+02080</target>
        </trans-unit>
        <trans-unit id="bb66a953411c5a7aa98e0ccd90b088e7efca0359" translate="yes" xml:space="preserve">
          <source>U+02081</source>
          <target state="translated">U+02081</target>
        </trans-unit>
        <trans-unit id="0c9776b8d8584f3558900c0e35ed1c199b85dc56" translate="yes" xml:space="preserve">
          <source>U+02082</source>
          <target state="translated">U+02082</target>
        </trans-unit>
        <trans-unit id="188629784648ed64f4880102c6ef53e00c48260f" translate="yes" xml:space="preserve">
          <source>U+02083</source>
          <target state="translated">U+02083</target>
        </trans-unit>
        <trans-unit id="ced37ed4c1992fa0c2e4792186605cdbbfe0813b" translate="yes" xml:space="preserve">
          <source>U+02084</source>
          <target state="translated">U+02084</target>
        </trans-unit>
        <trans-unit id="1c6821bf6c9d056467564e078d12132617914b74" translate="yes" xml:space="preserve">
          <source>U+02085</source>
          <target state="translated">U+02085</target>
        </trans-unit>
        <trans-unit id="f2c71c2c5946e5589ab2fbec4497aea575670406" translate="yes" xml:space="preserve">
          <source>U+02086</source>
          <target state="translated">U+02086</target>
        </trans-unit>
        <trans-unit id="f8b7a8d02fe7d8fd1e4e41165a96012f3085e3aa" translate="yes" xml:space="preserve">
          <source>U+02087</source>
          <target state="translated">U+02087</target>
        </trans-unit>
        <trans-unit id="e83c0c08dcd85b6a1d1e03d24eb32bfacef748a3" translate="yes" xml:space="preserve">
          <source>U+02088</source>
          <target state="translated">U+02088</target>
        </trans-unit>
        <trans-unit id="88afb3350de2e79fc09ed34801b089b50c323102" translate="yes" xml:space="preserve">
          <source>U+02089</source>
          <target state="translated">U+02089</target>
        </trans-unit>
        <trans-unit id="477cf57fceee603207b7029bea84e0d917ed01f2" translate="yes" xml:space="preserve">
          <source>U+0208A</source>
          <target state="translated">U+0208A</target>
        </trans-unit>
        <trans-unit id="23ef044b8d9c1cffcbe8f0bcd2bcd3dc5402e505" translate="yes" xml:space="preserve">
          <source>U+0208B</source>
          <target state="translated">U+0208B</target>
        </trans-unit>
        <trans-unit id="c6576c517955cbddf0fd30aec93e93789c487e12" translate="yes" xml:space="preserve">
          <source>U+0208C</source>
          <target state="translated">U+0208C</target>
        </trans-unit>
        <trans-unit id="d8029bd98cc0ac6ce5f6867fe9af4fb3de6a6b00" translate="yes" xml:space="preserve">
          <source>U+0208D</source>
          <target state="translated">U+0208D</target>
        </trans-unit>
        <trans-unit id="26b965df9ca2cbda682041b8cec3843d73d50b3d" translate="yes" xml:space="preserve">
          <source>U+0208E</source>
          <target state="translated">U+0208E</target>
        </trans-unit>
        <trans-unit id="da03f3f8ee238f200d4eddc0c4bd224192f75622" translate="yes" xml:space="preserve">
          <source>U+02090</source>
          <target state="translated">U+02090</target>
        </trans-unit>
        <trans-unit id="e7a5cb7c2c27388b416316e0acd0df63aef6d4f3" translate="yes" xml:space="preserve">
          <source>U+02091</source>
          <target state="translated">U+02091</target>
        </trans-unit>
        <trans-unit id="1a07878c5fdec82f99db1dc83ca11685edb72205" translate="yes" xml:space="preserve">
          <source>U+02092</source>
          <target state="translated">U+02092</target>
        </trans-unit>
        <trans-unit id="d85957c055f87ab66f8bb33e718c3eaf011c2d48" translate="yes" xml:space="preserve">
          <source>U+02093</source>
          <target state="translated">U+02093</target>
        </trans-unit>
        <trans-unit id="fc73e56e067c604fb38ed9d86ccf090e38a9f7c9" translate="yes" xml:space="preserve">
          <source>U+02094</source>
          <target state="translated">U+02094</target>
        </trans-unit>
        <trans-unit id="f890547c349527828a298f56e7fdc0da52c6e83a" translate="yes" xml:space="preserve">
          <source>U+02095</source>
          <target state="translated">U+02095</target>
        </trans-unit>
        <trans-unit id="5fd296e5bda2cce5c69dd8bd57d96e1e0d22b9b2" translate="yes" xml:space="preserve">
          <source>U+02096</source>
          <target state="translated">U+02096</target>
        </trans-unit>
        <trans-unit id="5c1c15f178eb0b654388c5f6475b3ba25b33c6dd" translate="yes" xml:space="preserve">
          <source>U+02097</source>
          <target state="translated">U+02097</target>
        </trans-unit>
        <trans-unit id="9d30a621292caf7bece2e9ce2d8b9581d55c8f2e" translate="yes" xml:space="preserve">
          <source>U+02098</source>
          <target state="translated">U+02098</target>
        </trans-unit>
        <trans-unit id="7e31400a5922fae3a81d4a1c28d6ad22d2bb926a" translate="yes" xml:space="preserve">
          <source>U+02099</source>
          <target state="translated">U+02099</target>
        </trans-unit>
        <trans-unit id="b8e32228d0b21d4afdfb09b9eb01835c4488956d" translate="yes" xml:space="preserve">
          <source>U+0209A</source>
          <target state="translated">U+0209A</target>
        </trans-unit>
        <trans-unit id="4ae8c33eeb20b986b3a68dd5c8f755537da0cc35" translate="yes" xml:space="preserve">
          <source>U+0209B</source>
          <target state="translated">U+0209B</target>
        </trans-unit>
        <trans-unit id="22883db9c2eae90f058a6ec060a0a1d7934fc524" translate="yes" xml:space="preserve">
          <source>U+0209C</source>
          <target state="translated">U+0209C</target>
        </trans-unit>
        <trans-unit id="a770d073d828312a3f412b4d196fcea78f022c6b" translate="yes" xml:space="preserve">
          <source>U+020A7</source>
          <target state="translated">U+020A7</target>
        </trans-unit>
        <trans-unit id="cec998138ab5bb31b2262d17296ad23086f8304d" translate="yes" xml:space="preserve">
          <source>U+020AC</source>
          <target state="translated">U+020AC</target>
        </trans-unit>
        <trans-unit id="be69f61217e1f1748ad03bdc4546176950dda473" translate="yes" xml:space="preserve">
          <source>U+020D0</source>
          <target state="translated">U+020D0</target>
        </trans-unit>
        <trans-unit id="ce511e7f9775929b60852032b4fa5b32681c7cb8" translate="yes" xml:space="preserve">
          <source>U+020D1</source>
          <target state="translated">U+020D1</target>
        </trans-unit>
        <trans-unit id="91b07feaa744c6688774083feb3443b13189fb5f" translate="yes" xml:space="preserve">
          <source>U+020D2</source>
          <target state="translated">U+020D2</target>
        </trans-unit>
        <trans-unit id="af681668f18319aab998e021e28763dd7d0f3f17" translate="yes" xml:space="preserve">
          <source>U+020D6</source>
          <target state="translated">U+020D6</target>
        </trans-unit>
        <trans-unit id="570c4c40f536d880f35d90049a5fc80334ded35b" translate="yes" xml:space="preserve">
          <source>U+020D7</source>
          <target state="translated">U+020D7</target>
        </trans-unit>
        <trans-unit id="f9c8acbccb3bb9e59c23842d6854d6ffe3cda209" translate="yes" xml:space="preserve">
          <source>U+020DB</source>
          <target state="translated">U+020DB</target>
        </trans-unit>
        <trans-unit id="124a18fae2c40bf7ad2fc342bead50ee6a3edb2e" translate="yes" xml:space="preserve">
          <source>U+020DC</source>
          <target state="translated">U+020DC</target>
        </trans-unit>
        <trans-unit id="9fcbf1d8195b405d6c289e7de0d461ccdeb5126d" translate="yes" xml:space="preserve">
          <source>U+020DD</source>
          <target state="translated">U+020DD</target>
        </trans-unit>
        <trans-unit id="12f776f6e3a074855f26553b489117cb5664c07d" translate="yes" xml:space="preserve">
          <source>U+020DE</source>
          <target state="translated">U+020DE</target>
        </trans-unit>
        <trans-unit id="476a6d0d44d7e0ee0c7a1eb7300c6ccb5e8e8819" translate="yes" xml:space="preserve">
          <source>U+020DF</source>
          <target state="translated">U+020DF</target>
        </trans-unit>
        <trans-unit id="36a22cb9ea7baffde06e396cfebdc0661c04e913" translate="yes" xml:space="preserve">
          <source>U+020E1</source>
          <target state="translated">U+020E1</target>
        </trans-unit>
        <trans-unit id="4fd6aa654f40bc0d1fec9761c3b30fa972c4b26e" translate="yes" xml:space="preserve">
          <source>U+020E4</source>
          <target state="translated">U+020E4</target>
        </trans-unit>
        <trans-unit id="e63bdbad9a6fbf0dbf6715d8bec7bcd775432592" translate="yes" xml:space="preserve">
          <source>U+020E7</source>
          <target state="translated">U+020E7</target>
        </trans-unit>
        <trans-unit id="b1a6163cfe2122326bc02c224adf7f8d6e5ffba7" translate="yes" xml:space="preserve">
          <source>U+020E8</source>
          <target state="translated">U+020E8</target>
        </trans-unit>
        <trans-unit id="3850520adad69b9d57a55e0a79e674a7bf6967c2" translate="yes" xml:space="preserve">
          <source>U+020E9</source>
          <target state="translated">U+020E9</target>
        </trans-unit>
        <trans-unit id="e45a7120fdc5d1b21987b099aeed9919e3d159bf" translate="yes" xml:space="preserve">
          <source>U+020EC</source>
          <target state="translated">U+020EC</target>
        </trans-unit>
        <trans-unit id="96a99a0c9bbd7eaa955fe8b3d30fe4dfec582fd9" translate="yes" xml:space="preserve">
          <source>U+020ED</source>
          <target state="translated">U+020ED</target>
        </trans-unit>
        <trans-unit id="3babb4708c5e4b432d55e2eff2f03ed9b62870db" translate="yes" xml:space="preserve">
          <source>U+020EE</source>
          <target state="translated">U+020EE</target>
        </trans-unit>
        <trans-unit id="fc835fa7d02a8c817884cb00384b5e9922183683" translate="yes" xml:space="preserve">
          <source>U+020EF</source>
          <target state="translated">U+020EF</target>
        </trans-unit>
        <trans-unit id="0c6129bb507bb470263fc68a8d02831a53adfac3" translate="yes" xml:space="preserve">
          <source>U+020F0</source>
          <target state="translated">U+020F0</target>
        </trans-unit>
        <trans-unit id="2adc2c6bebe3339c446d7e23907f1dc655e420a2" translate="yes" xml:space="preserve">
          <source>U+02102</source>
          <target state="translated">U+02102</target>
        </trans-unit>
        <trans-unit id="2afc9e72e8df124d80b35edc62c73cb1f19c10d6" translate="yes" xml:space="preserve">
          <source>U+02107</source>
          <target state="translated">U+02107</target>
        </trans-unit>
        <trans-unit id="ebfed4281bd65acfa46591c8ddd1317cfd1b5242" translate="yes" xml:space="preserve">
          <source>U+0210A</source>
          <target state="translated">U+0210A</target>
        </trans-unit>
        <trans-unit id="024787cf22bf2842dba0be7847ca8f38dc5fa7b4" translate="yes" xml:space="preserve">
          <source>U+0210B</source>
          <target state="translated">U+0210B</target>
        </trans-unit>
        <trans-unit id="2feefe2362663ee1ffb0fc6da3896a6df35b143e" translate="yes" xml:space="preserve">
          <source>U+0210C</source>
          <target state="translated">U+0210C</target>
        </trans-unit>
        <trans-unit id="663f2a23d864546260f30cd2d124b343002e3958" translate="yes" xml:space="preserve">
          <source>U+0210D</source>
          <target state="translated">U+0210D</target>
        </trans-unit>
        <trans-unit id="fbc22138cd7a815897649944bd0296b4b1707e29" translate="yes" xml:space="preserve">
          <source>U+0210E</source>
          <target state="translated">U+0210E</target>
        </trans-unit>
        <trans-unit id="8258fdd464e12d5471e5dccf50cccae82495f1a1" translate="yes" xml:space="preserve">
          <source>U+0210F</source>
          <target state="translated">U+0210F</target>
        </trans-unit>
        <trans-unit id="517e7c3cf117e768d82906bdea2b9d73b0d093b9" translate="yes" xml:space="preserve">
          <source>U+02110</source>
          <target state="translated">U+02110</target>
        </trans-unit>
        <trans-unit id="bca7eb892f1a6edce7356fe44b05b07629e09e34" translate="yes" xml:space="preserve">
          <source>U+02111</source>
          <target state="translated">U+02111</target>
        </trans-unit>
        <trans-unit id="bee1d61c619164abe275a3c3556fbb2ac4e97e19" translate="yes" xml:space="preserve">
          <source>U+02112</source>
          <target state="translated">U+02112</target>
        </trans-unit>
        <trans-unit id="342959e0e16070b1247f1f44564ecb3ec9396b91" translate="yes" xml:space="preserve">
          <source>U+02113</source>
          <target state="translated">U+02113</target>
        </trans-unit>
        <trans-unit id="298b156c4985cc6f1df475cf209f863ef4cc4b3a" translate="yes" xml:space="preserve">
          <source>U+02115</source>
          <target state="translated">U+02115</target>
        </trans-unit>
        <trans-unit id="456a13c7b9fab48f48291b017dd4ee50155f5964" translate="yes" xml:space="preserve">
          <source>U+02116</source>
          <target state="translated">U+02116</target>
        </trans-unit>
        <trans-unit id="325b4a2c0faae3a209a87bf5e3a5c83401a0aaff" translate="yes" xml:space="preserve">
          <source>U+02118</source>
          <target state="translated">U+02118</target>
        </trans-unit>
        <trans-unit id="dae9b18d73050b644687a61effdf17b8f841e040" translate="yes" xml:space="preserve">
          <source>U+02119</source>
          <target state="translated">U+02119</target>
        </trans-unit>
        <trans-unit id="8288406fd14e141f15c517704db3a02746c05fba" translate="yes" xml:space="preserve">
          <source>U+0211A</source>
          <target state="translated">U+0211A</target>
        </trans-unit>
        <trans-unit id="a23b5f3fd36ff2842b6c25933ff3f70b6fd66af2" translate="yes" xml:space="preserve">
          <source>U+0211B</source>
          <target state="translated">U+0211B</target>
        </trans-unit>
        <trans-unit id="72a9ec39387b201efc778708d7f6d52069ad7b13" translate="yes" xml:space="preserve">
          <source>U+0211C</source>
          <target state="translated">U+0211C</target>
        </trans-unit>
        <trans-unit id="9dfccf15a23a02ba3b953d1c7d7f6abc05fa682c" translate="yes" xml:space="preserve">
          <source>U+0211D</source>
          <target state="translated">U+0211D</target>
        </trans-unit>
        <trans-unit id="6c51822bf19550c0ee6d5a384cc0cf486b30a8f4" translate="yes" xml:space="preserve">
          <source>U+0211E</source>
          <target state="translated">U+0211E</target>
        </trans-unit>
        <trans-unit id="0a39b4ce2d86e268da567ab2a2a342737157f4f7" translate="yes" xml:space="preserve">
          <source>U+02122</source>
          <target state="translated">U+02122</target>
        </trans-unit>
        <trans-unit id="ff13fb5cd296523bc4b707cf6e46dc6766380430" translate="yes" xml:space="preserve">
          <source>U+02124</source>
          <target state="translated">U+02124</target>
        </trans-unit>
        <trans-unit id="f037e7e6304e03a5f7f4aac86130df6dc576311a" translate="yes" xml:space="preserve">
          <source>U+02126</source>
          <target state="translated">U+02126</target>
        </trans-unit>
        <trans-unit id="7d2655b3517935e484d6b1a4e997ff5843a31e87" translate="yes" xml:space="preserve">
          <source>U+02127</source>
          <target state="translated">U+02127</target>
        </trans-unit>
        <trans-unit id="cb7b969c3501850a4060cfd7e7f59c0da7c3cb7c" translate="yes" xml:space="preserve">
          <source>U+02128</source>
          <target state="translated">U+02128</target>
        </trans-unit>
        <trans-unit id="b79f1ccc58a0757660d0bc91a00ac119559e2338" translate="yes" xml:space="preserve">
          <source>U+02129</source>
          <target state="translated">U+02129</target>
        </trans-unit>
        <trans-unit id="239a3c1c1d9c7ae49e284a49968bcabd8c5b7042" translate="yes" xml:space="preserve">
          <source>U+0212B</source>
          <target state="translated">U+0212B</target>
        </trans-unit>
        <trans-unit id="92faddf2df3101e2ea354ca32e0b3f3543850210" translate="yes" xml:space="preserve">
          <source>U+0212C</source>
          <target state="translated">U+0212C</target>
        </trans-unit>
        <trans-unit id="36e6bb2196feb03f4b43d924bb79e3c8be31b9a9" translate="yes" xml:space="preserve">
          <source>U+0212D</source>
          <target state="translated">U+0212D</target>
        </trans-unit>
        <trans-unit id="16660c15da1843f5c1a0edfd5cb7b5a695e2e521" translate="yes" xml:space="preserve">
          <source>U+0212F</source>
          <target state="translated">U+0212F</target>
        </trans-unit>
        <trans-unit id="aaeb74116b049a77e6ec9ce1d001dfd92cbaf0c5" translate="yes" xml:space="preserve">
          <source>U+02130</source>
          <target state="translated">U+02130</target>
        </trans-unit>
        <trans-unit id="8dd9faccb501c29739c49458d2a93b67ef810716" translate="yes" xml:space="preserve">
          <source>U+02131</source>
          <target state="translated">U+02131</target>
        </trans-unit>
        <trans-unit id="e099608b2d63cb110f6dac82c14749c62295dc74" translate="yes" xml:space="preserve">
          <source>U+02132</source>
          <target state="translated">U+02132</target>
        </trans-unit>
        <trans-unit id="7fce3e99b8d386428a44b9ba9cd77168f4a90b54" translate="yes" xml:space="preserve">
          <source>U+02133</source>
          <target state="translated">U+02133</target>
        </trans-unit>
        <trans-unit id="0fc13fe64d053aa6289ea319c71a4691d5ed6634" translate="yes" xml:space="preserve">
          <source>U+02134</source>
          <target state="translated">U+02134</target>
        </trans-unit>
        <trans-unit id="1563aedef419208c50595e16109be4c42f5a4364" translate="yes" xml:space="preserve">
          <source>U+02135</source>
          <target state="translated">U+02135</target>
        </trans-unit>
        <trans-unit id="3891e0fc176e12065431c43db1f74fc494411f82" translate="yes" xml:space="preserve">
          <source>U+02136</source>
          <target state="translated">U+02136</target>
        </trans-unit>
        <trans-unit id="a593920648b7a0628980af8818432607aee2b26b" translate="yes" xml:space="preserve">
          <source>U+02137</source>
          <target state="translated">U+02137</target>
        </trans-unit>
        <trans-unit id="09c96fc69d62f78396fe578ae0a734946ca45119" translate="yes" xml:space="preserve">
          <source>U+02138</source>
          <target state="translated">U+02138</target>
        </trans-unit>
        <trans-unit id="9fd776e8fb45b0a99d86b77b183c64b5128e4853" translate="yes" xml:space="preserve">
          <source>U+02139</source>
          <target state="translated">U+02139</target>
        </trans-unit>
        <trans-unit id="d0888576b0913d65a8450a31d9441aaccf7e4435" translate="yes" xml:space="preserve">
          <source>U+0213C</source>
          <target state="translated">U+0213C</target>
        </trans-unit>
        <trans-unit id="fb3fbd77e803f3bf4cab253f0bf3f908c7ad718c" translate="yes" xml:space="preserve">
          <source>U+0213D</source>
          <target state="translated">U+0213D</target>
        </trans-unit>
        <trans-unit id="e440bfd991013a84e4602155792d47bba2093ba8" translate="yes" xml:space="preserve">
          <source>U+0213E</source>
          <target state="translated">U+0213E</target>
        </trans-unit>
        <trans-unit id="29227106656a985eab84a0e228e588ed042c2b81" translate="yes" xml:space="preserve">
          <source>U+0213F</source>
          <target state="translated">U+0213F</target>
        </trans-unit>
        <trans-unit id="fb9d15cdeb6082c60f875c40cf5bf8071c89e5a0" translate="yes" xml:space="preserve">
          <source>U+02140</source>
          <target state="translated">U+02140</target>
        </trans-unit>
        <trans-unit id="25c33074d8075a29f499832613c3cbf490c765f4" translate="yes" xml:space="preserve">
          <source>U+02141</source>
          <target state="translated">U+02141</target>
        </trans-unit>
        <trans-unit id="8d593c3ede8a900f775ba49e99e44b2441f0a82a" translate="yes" xml:space="preserve">
          <source>U+02142</source>
          <target state="translated">U+02142</target>
        </trans-unit>
        <trans-unit id="e15e780412bb80d5134e94a8aaf019527b157036" translate="yes" xml:space="preserve">
          <source>U+02143</source>
          <target state="translated">U+02143</target>
        </trans-unit>
        <trans-unit id="0985adfd896a1876bf4859487cc1416a43097be3" translate="yes" xml:space="preserve">
          <source>U+02144</source>
          <target state="translated">U+02144</target>
        </trans-unit>
        <trans-unit id="e5df3ea43ae68e5c9216957b9ac77eebbf312d22" translate="yes" xml:space="preserve">
          <source>U+02145</source>
          <target state="translated">U+02145</target>
        </trans-unit>
        <trans-unit id="aad47338d4f31abfaf8fecb938a8c63fc984db6b" translate="yes" xml:space="preserve">
          <source>U+02146</source>
          <target state="translated">U+02146</target>
        </trans-unit>
        <trans-unit id="4836d6e98db2972df1e4babecc7404f8bc565dec" translate="yes" xml:space="preserve">
          <source>U+02147</source>
          <target state="translated">U+02147</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
