<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">与点点</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">而使用该测试集的样子。</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">愤怒的象征</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">内有S的角度</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">角度,带下杆</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">愤怒的脸</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">Angstrom标志/Angstrom单元</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">痛苦的脸</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">注释一个 &lt;code&gt;for&lt;/code&gt; 循环，以允许编译器获得更多的自由，以允许循环重新排序</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">注释取自非类型化位置的值。</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将表达式 &lt;code&gt;blk&lt;/code&gt; 注释为边界检查块，从而允许&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;消除它。</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">匿名函数</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">另一个常见的解决方案是将管道的读取器和写入器分成单独的&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">当前，在其他情况下可以使用另一种帮助程序类型 &lt;code&gt;Random.SamplerTag&lt;/code&gt; ，但它被视为内部API，并且可以在没有适当弃用的情况下随时中断。</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">另一种非标准版本规范扩展允许使用尾随 &lt;code&gt;+&lt;/code&gt; 表示构建版本的上限，例如 &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; 可用于表示 &lt;code&gt;0.2-rc1&lt;/code&gt; 以上的任何版本及其任何构建：将返回 &lt;code&gt;false&lt;/code&gt; 的版本 &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; ，并 &lt;code&gt;true&lt;/code&gt; 为 &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">适用于某些类型的另一种操作是&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;，它揭示了类型的超类型。只有声明的类型（ &lt;code&gt;DataType&lt;/code&gt; ）具有明确的超类型：</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">下面是另一种可能性，它可能适用于需要更窄地匹配参数 &lt;code&gt;T&lt;/code&gt; 的情况：</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">另一个有用的非标准字符串文字是字节数组字符串文字： &lt;code&gt;b&quot;...&quot;&lt;/code&gt; 。这种形式使您可以使用字符串表示法来表示只读的文字字节数组，即&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;值的数组。这些对象的类型为 &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; 。字节数组文字的规则如下：</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">创建稀疏数组的另一种方法是使用&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;函数将密集数组转换为稀疏数组：</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">查看表达式的另一种方法是使用 &lt;code&gt;Meta.show_sexpr&lt;/code&gt; ，它显示给定 &lt;code&gt;Expr&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S表达式&lt;/a&gt;形式，对于Lisp的用户来说可能看起来非常熟悉。以下示例说明了嵌套 &lt;code&gt;Expr&lt;/code&gt; 上的显示：</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">另一种方式,在Julia v0.6的三角调度出现之前,这曾经是唯一正确的方式。</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">天线带条</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">逆时针等高线积分</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">逆时针向下和向上的开环箭头</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">逆时针整合</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">逆时针开环箭头</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">逆时针方向的顶部半圆箭头。</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">您对数组值所做的任何更改（例如 &lt;code&gt;A[3] = 0&lt;/code&gt; ）也会更改磁盘上的值</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">任何对性能至关重要的代码或正在进行基准测试的代码都应该在一个函数里面。</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">标量索引的任何自定义数组，它是 &lt;code&gt;AbstractArray&lt;/code&gt; 的子类型</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">可以给出任何自定义测试集类型（ &lt;code&gt;AbstractTestSet&lt;/code&gt; 的子类型），它也将用于任何嵌套的 &lt;code&gt;@testset&lt;/code&gt; 调用。给定的选项仅应用于给出它们的测试集。默认测试集类型不包含任何选项。</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">任何错误都会使 &lt;code&gt;pmap&lt;/code&gt; 停止处理集合的其余部分。要覆盖此行为，您可以通过参数 &lt;code&gt;on_error&lt;/code&gt; 指定一个错误处理函数，该函数接受单个参数，即异常。该函数可以通过重新抛出错误来停止处理，或者继续执行，然后将返回的任何值与结果内联地返回给调用方。</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 抛出的任何异常都将打印到远程工作器上的&lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">传递给 &lt;code&gt;eigen&lt;/code&gt; 任何关键字参数都将传递给下层&lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">这样可以将任意数量的表达式一起记录下来。当两个函数（例如，非变异版本和变异版本 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;f!&lt;/code&gt; )相关时，此语法很有用。。</target>
        </trans-unit>
        <trans-unit id="0687dd78d1b30c2783be213375797ef6105a33d2" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">定义此函数的任何对象都是可迭代的，并且可以在&lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;依赖迭代&lt;/a&gt;的许多函数中使用。由于以下语法，它也可以直接在&lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;循环中使用：</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">任何不是类型的对象都不是 &lt;code&gt;Type&lt;/code&gt; 的实例：</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">任何抛出错误的操作目前可能都没有实现,应该作为一个bug发布,以便解决。</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">任何引用&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 的过程&lt;/a&gt;都可以从通道中放置和取出项目。数据会自动发送到与&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;关联的进程（或从中检索）。</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Apl功能符号反斜杠</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl 功能性符号 圆圈四边形</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Apl功能符号I-Beam</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Apl功能符号四题</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl 功能性符号四向上的Caret</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl功能符号斜杠</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">追加 &lt;code&gt;!&lt;/code&gt; 修改其参数的函数名称</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">将项目 &lt;code&gt;v&lt;/code&gt; 附加到通道 &lt;code&gt;c&lt;/code&gt; 。如果频道已满，则阻止。</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">应用于函数参数名,提示编译器,该方法不应对该参数的不同类型进行专门化,而是对每个参数精确使用声明的类型。这只是为了避免产生过多的代码而做出的提示。可以应用于形式化参数列表中的一个参数,也可以应用于函数体中。当应用于一个参数时,宏必须包裹整个参数表达式。当在函数体中使用时,宏必须出现在语句位置,并且在任何代码之前。</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">应用于函数或宏调用时，它将对指定调用的参数求值，并返回一个元组 &lt;code&gt;(filename,line)&lt;/code&gt; ，该元组给出将为这些参数调用的方法的位置。它调出 &lt;code&gt;functionloc&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">应用于函数或宏调用时，它将评估指定调用的参数，并返回将为这些参数调用的方法的 &lt;code&gt;Method&lt;/code&gt; 对象。应用于变量，它返回绑定了变量的模块。它调出 &lt;code&gt;which&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">将一个函数应用于前面的参数。这允许简单的函数链。</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">将函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;itrs&lt;/code&gt; 中的每个元素，然后使用二进制函数 &lt;code&gt;op&lt;/code&gt; 减少结果。如果提供，则 &lt;code&gt;init&lt;/code&gt; 必须是 &lt;code&gt;op&lt;/code&gt; 的中性元素，它将为空集合返回。不确定是否将 &lt;code&gt;init&lt;/code&gt; 用于非空集合。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">应用功能 &lt;code&gt;f&lt;/code&gt; 到Git仓库 &lt;code&gt;repo&lt;/code&gt; ，拍摄&lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt;应用之前 &lt;code&gt;f&lt;/code&gt; 。如果 &lt;code&gt;f&lt;/code&gt; 内发生错误，则 &lt;code&gt;repo&lt;/code&gt; 将使用&lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; 恢复&lt;/a&gt;到快照状态。发生的错误将被重新抛出，但是 &lt;code&gt;repo&lt;/code&gt; 的状态不会被破坏。</target>
        </trans-unit>
        <trans-unit id="f6b68e61d0fe49a5c4e043952feeeef90f5166fd" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of array &lt;code&gt;A&lt;/code&gt; and take the mean over dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">将函数 &lt;code&gt;f&lt;/code&gt; 应用于集合 &lt;code&gt;itr&lt;/code&gt; 的每个元素，并取均值。</target>
        </trans-unit>
        <trans-unit id="939711ce79fa9b7db5fc7f83d19a0a73f949253d" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">将函数 &lt;code&gt;f&lt;/code&gt; 应用于&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; &lt;/a&gt;的结果，并在完成后删除临时文件。</target>
        </trans-unit>
        <trans-unit id="2dbf8268105b7901616a7ac6d30feda3dbda5ed9" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">将函数 &lt;code&gt;f&lt;/code&gt; 应用于&lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt;的结果，并在完成后删除临时目录的所有内容。</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">将函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; 的结果，并在完成时关闭生成的文件描述符。</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">将其应用于任何其他类型的参数将导致&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">接近极限</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">近似浮点数 &lt;code&gt;x&lt;/code&gt; 为&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;，具有给定整数类型的组件。结果与 &lt;code&gt;x&lt;/code&gt; 的差异不超过 &lt;code&gt;tol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">近似但实际上不等于</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">约等于或等于</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">约等于</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">约等于或形象</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">任意精度算术</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">任意精度浮点数类型。</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">任意精度的整数类型。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">参数 &lt;code&gt;waitfor&lt;/code&gt; 指定等待工人关闭多长时间：</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">争论传递行为</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">论据重构</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">要传递给LLVM后端的参数。</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">算术运算符</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Julia中 &lt;code&gt;Ptr&lt;/code&gt; 类型的算术（例如，使用 &lt;code&gt;+&lt;/code&gt; ）的行为与C的指针算术不同。在Julia中向 &lt;code&gt;Ptr&lt;/code&gt; 添加一个整数总是会将指针移动一定数量的&lt;em&gt;字节&lt;/em&gt;，而不是元素。这样，从指针算术获得的地址值不依赖于指针的元素类型。</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">稀疏矩阵的算术运算也与稠密矩阵的算术运算一样。稀疏矩阵的索引，赋值和级联的工作方式与密集矩阵相同。当一次执行一个元素时，索引操作（尤其是赋值）很昂贵。在许多情况下，最好使用&lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt;将稀疏矩阵转换为 &lt;code&gt;(I,J,V)&lt;/code&gt; 格式，操纵密集向量 &lt;code&gt;(I,J,V)&lt;/code&gt; 中的值或结构，然后重建稀疏矩阵。</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">阵列和向量化操作符和函数</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">阵列功能</target>
        </trans-unit>
        <trans-unit id="051f0d6bd098df06454138ddf1bfe22d07625d2a" translate="yes" xml:space="preserve">
          <source>Array literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">阵列特征</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">缺少值的数组</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">可以使用标准语法构造允许缺少值的数组。使用 &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; 创建由缺失值填充的数组：</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">数组连续存储在内存中,有利于CPU的向量化,并且由于缓存的原因,减少了对内存的访问。这也是建议按列主序访问数组的原因(见上文)。不规则的访问模式和不连续的视图会因为非顺序的内存访问而大大减慢数组的计算速度。</target>
        </trans-unit>
        <trans-unit id="2cd16e2399bb6c0b0c5a0ea05fbdc7c6bf1a6ee2" translate="yes" xml:space="preserve">
          <source>Arrays can also be directly constructed with square braces; the syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its &lt;code&gt;eltype&lt;/code&gt;. If they all have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; and that type is the array's &lt;code&gt;eltype&lt;/code&gt;. Otherwise, a heterogeneous array that can hold anything &amp;mdash; a &lt;code&gt;Vector{Any}&lt;/code&gt; &amp;mdash; is constructed; this includes the literal &lt;code&gt;[]&lt;/code&gt; where no arguments are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">可以使用以下函数来构造数组和连接数组。</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">数组可以很容易地根据其值的任意变换进行排序。</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">含有缺失值的数组可以像其他数组一样被创建。</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 数组（有关更多详细信息，请参见下文）</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">还支持 &lt;code&gt;CartesianIndex{N}&lt;/code&gt; 数组。它们代表了标量索引的集合，每个标量索引跨越 &lt;code&gt;N&lt;/code&gt; 个维度，从而实现了有时被称为逐点索引的一种索引形式。例如，它允许从上方从 &lt;code&gt;A&lt;/code&gt; 的第一个&amp;ldquo;页面&amp;rdquo;访问对角线元素：</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">布尔数组，以其 &lt;code&gt;true&lt;/code&gt; 索引选择元素（有关更多详细信息，请参见下文）</target>
        </trans-unit>
        <trans-unit id="36fa144c795f904dbf232a8e653525a3d0ba71b7" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;. For example, the struct in C notation written as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">参数数组可以用 &lt;code&gt;NTuple&lt;/code&gt; 表示：</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">纯数据类型的数组表现出同样的行为。</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">不直接支持未知大小的数组（由 &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;[0]&lt;/code&gt; 指定的C99兼容可变长度结构）。通常，处理这些错误的最佳方法是直接处理字节偏移。例如，如果C库声明了正确的字符串类型并返回了指向它的指针：</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">箭头向右指向,然后向下弯曲。</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">箭头向右指向,然后向上弯曲。</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">亚瑟&amp;middot;克拉克（Arthur C. Clarke），&lt;em&gt;《未来概况》&lt;/em&gt;（1961）：克拉克的第三定律。</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">铰接式卡车</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">艺术家调色板</target>
        </trans-unit>
        <trans-unit id="07d39beaf4ec4f6ab344410b6e2ddcbafeee07b5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard math operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">由于 &lt;code&gt;missing&lt;/code&gt; 普通的Julia对象，因此此传播规则仅适用于已选择实现此行为的功能。这可以通过为 &lt;code&gt;Missing&lt;/code&gt; 类型的参数定义的特定方法来实现，也可以仅通过接受此类型的参数并将其传递给传播它们的函数（例如标准运算符）来实现。包应考虑在定义新函数时传播缺失值是否有意义，并在这种情况下适当地定义方法。像 &lt;code&gt;missing&lt;/code&gt; 任何其他类型一样，将缺失值传递给没有定义任何方法来接受 &lt;code&gt;Missing&lt;/code&gt; 类型参数的函数的方法会抛出&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">由于Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;值是根据ISO 8601标准表示的，因此选择 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 作为基础（或&amp;ldquo;舍入纪元&amp;rdquo;），从该基数开始计算舍入所用的天数（毫秒）。计算。（请注意，这与Julia 使用Rata Die表示法对&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的内部表示形式略有不同；但是由于ISO 8601标准对于最终用户最为可见，因此选择 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 作为舍入历元而不是 &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; 内部使用，以最大程度地减少混乱。）</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">作为奖励,所有的周期运算对象都可以直接与范围工作。</target>
        </trans-unit>
        <trans-unit id="1d37396b19dff556a9f0928d3fb79a1f9a87b4bb" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library on most Unix-derived systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">作为一个完整但简单的示例，以下代码从标准C库中调用 &lt;code&gt;clock&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">为方便起见，从数组构造 &lt;code&gt;CartesianIndices&lt;/code&gt; 会产生一系列索引。</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">作为一般规则,Base库在适用的情况下,使用以下函数的参数顺序。</target>
        </trans-unit>
        <trans-unit id="0aeaa033e5a0e531782e60f4be3543a306118072" translate="yes" xml:space="preserve">
          <source>As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases: &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Vararg&lt;/code&gt;. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/functions/#compiler-efficiency-issues&quot;&gt;improves compiler performance&lt;/a&gt;. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">作为一个更复杂的示例，让我们定义在&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt;之上构建的自己的玩具N维类似稀疏数组类型：</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">作为一个更加扩展和复杂的例子,考虑并行运行以下 &quot;内核&quot;。</target>
        </trans-unit>
        <trans-unit id="abc7b3fc409ca00052233fccf9f3605c7724641a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">根据经验，单行 &lt;code&gt;show&lt;/code&gt; 方法应打印有效的Julia表达式以创建显示的对象。当此 &lt;code&gt;show&lt;/code&gt; 方法包含infix运算符时，例如上述用于 &lt;code&gt;Polar&lt;/code&gt; 的单行 &lt;code&gt;show&lt;/code&gt; 方法中的乘法运算符（ &lt;code&gt;*&lt;/code&gt; ），当作为另一个对象的一部分打印时，它可能无法正确解析。要查看这一点，请考虑表达式对象（请参阅&lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;程序表示法&lt;/a&gt;），该对象采用 &lt;code&gt;Polar&lt;/code&gt; 类型的特定实例的平方：</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">作为一种特殊情况， &lt;code&gt;Main&lt;/code&gt; 中定义的所有名称都被视为&amp;ldquo;已导出&amp;rdquo;，因为从 &lt;code&gt;Main&lt;/code&gt; 显式导出名称并不是惯用的。</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">作为一种特殊情况,函数只有在匿名的情况下才能被实际深层复制,否则只是被复制。这种区别只适用于闭包的情况,即可能包含隐藏的内部引用的函数。</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">作为一种特殊情况，如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;AbstractString&lt;/code&gt; （对于文本MIME类型）或 &lt;code&gt;Vector{UInt8}&lt;/code&gt; （对于二进制MIME类型），则 &lt;code&gt;repr&lt;/code&gt; 函数假定 &lt;code&gt;x&lt;/code&gt; 已经是所请求的 &lt;code&gt;mime&lt;/code&gt; 格式，并仅返回 &lt;code&gt;x&lt;/code&gt; 。此特殊情况不适用于 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME类型。这很有用，因此原始数据可以传递给 &lt;code&gt;display(m::MIME, x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">作为此语法的特殊部分，可以使用 &lt;code&gt;end&lt;/code&gt; 关键字表示索引括号内每个维的最后索引，该索引由要索引的最里面的数组的大小确定。没有 &lt;code&gt;end&lt;/code&gt; 关键字的索引语法等效于对&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;的调用：</target>
        </trans-unit>
        <trans-unit id="bae7191c8b712d7ed7a7918d6d667ad51becb2b6" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">正如&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;《朱莉娅REPL》中&lt;/a&gt;已经阐述的那样，朱莉娅的REPL提供了丰富的功能，可促进高效的交互式工作流程。这里有一些技巧，可能会进一步增强您在命令行上的体验。</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">作为非常简单的情况的替代方法，可以仅创建一个 &lt;code&gt;Vector{Any}&lt;/code&gt; 类型的全局容器，并在必要时从中获取元素，甚至可以使用以下方法为每个指针创建一个全局变量</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">作为一个断言,以帮助确认你的程序以你期望的方式工作。</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">作为示例，让我们看看如何实现 &lt;code&gt;LocalManager&lt;/code&gt; ，该经理负责在同一主机上启动工作程序：</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">作为非TCP / IP传输的示例，实现可以选择使用MPI，在这种情况下，不得指定 &lt;code&gt;--worker&lt;/code&gt; 。相反，新启动的工作程序应在使用任何并行构造之前调用 &lt;code&gt;init_worker(cookie)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab91e9f8f6b72a78ebd5768f4d6d25cd797012df" translate="yes" xml:space="preserve">
          <source>As an example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fdf4e4340eb940fd457afeeed7b812831f6609" translate="yes" xml:space="preserve">
          <source>As an example, consider this call to &lt;a href=&quot;../../base/collections/index#Base.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">举个例子,假设一个包目录的结构和内容如下。</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">举个例子,假设你想在一个模块中定义符号的乘法。</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">例如，内置的 &lt;code&gt;AbstractRange&lt;/code&gt; 对象使用此机制来优化广播表达式的片段，这些片段可以纯粹根据开始，步长和长度（或停止）来急切地求值，而不用计算每个元素。就像所有其他机器一样， &lt;code&gt;broadcasted&lt;/code&gt; 也可以计算并公开其参数的组合广播样式，因此，您可以专注于 &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; ，而不是专门使用广播的（f，args ...）。 。）用于样式，函数和参数的任何组合。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">对此的扩展，在算法需要输入数组副本的情况下，由于返回值可能会混淆原始输入，因此&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;不足。组合&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;（以使输出数组）和&lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt;（用输入数据填充）是表达对输入参数的可变副本的要求的一种通用方法：</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">作为另一个例子,这里有一个函数,它可以将任何数字参数翻倍,但不考虑表达式。</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">由于对浮点值的计算可能不精确，因此您可以使用 &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; （其中 &lt;code&gt;&amp;asymp;&lt;/code&gt; ，通过制表符 &lt;code&gt;\approx&lt;/code&gt; 键入，是&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;函数）执行近似相等检查，或直接使用&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">再一次可以看到,对本地节点的远程调用就像直接调用一样。调用会修改作为参数传递的本地对象,在远程调用中,它对参数的副本进行操作。在远程调用中,它对参数的副本进行操作。</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">可以看出， &lt;code&gt;A&lt;/code&gt; 更改为排序后的数组 &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 。请注意，Julia知道如何将数组转换为 &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; ，如何以字节为单位计算类型的大小（与C的 &lt;code&gt;sizeof&lt;/code&gt; 运算符相同），等等。为了好玩，尝试插入 &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 行成 &lt;code&gt;mycompare&lt;/code&gt; ，这将让你看到比较 &lt;code&gt;qsort&lt;/code&gt; 的执行（并验证它是否真的调用朱莉娅功能，你传递对此）。</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">可以看到， &lt;code&gt;put!&lt;/code&gt; 在本地拥有的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 上&lt;/a&gt;，在两次调用之间修改了相同的对象 &lt;code&gt;v&lt;/code&gt; 会导致存储相同的单个对象实例。与拥有 &lt;code&gt;rc&lt;/code&gt; 的节点是另一个节点时创建 &lt;code&gt;v&lt;/code&gt; 的副本相反。</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">可以看出，全局变量 &lt;code&gt;A&lt;/code&gt; 是在工作程序2上定义的，但是 &lt;code&gt;B&lt;/code&gt; 被捕获为局部变量，因此工作程序2上不存在 &lt;code&gt;B&lt;/code&gt; 的绑定。</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">与日期周期算术一样方便，通常，日期所需的各种计算具有&lt;em&gt;日历&lt;/em&gt;或&lt;em&gt;时间&lt;/em&gt;性质，而不是固定的周期数。假期就是一个很好的例子。大多数人遵循&amp;ldquo;纪念日=五月的最后一个星期一&amp;rdquo;或&amp;ldquo;感恩节=十一月的第四个星期四&amp;rdquo;之类的规则。这些类型的时间表达式处理与日历相关的规则，例如每月的第一天或最后一天，下一个星期二或第一个和第三个星期三，等等。</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">不出所料，我们看到了《 Hello World》。因此，让我们实际分析幕后发生的事情。当我们调用 &lt;code&gt;connect&lt;/code&gt; 时，我们连接到刚刚创建的服务器。同时，accept函数将服务器端连接返回到新创建的套接字，并打印&amp;ldquo; Hello World&amp;rdquo;以指示连接成功。</target>
        </trans-unit>
        <trans-unit id="a7387cbdd9f992b642e060d8d4bc6f44c8177451" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">至于&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;SparseVector&lt;/code&gt; 类型还可以包含显式存储的零。（请参阅&lt;a href=&quot;#man-csc-1&quot;&gt;稀疏矩阵存储&lt;/a&gt;。）。</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">至于十六进制文字，二进制和八进制文字产生无符号整数类型。如果文字的前导数字不为 &lt;code&gt;0&lt;/code&gt; ，则二进制数据项的大小为所需的最小大小。在前导零的情况下，大小由文字的最小所需大小决定，该文本具有相同的长度，但前导数字为 &lt;code&gt;1&lt;/code&gt; 。这使用户可以控制大小。无法存储在 &lt;code&gt;UInt128&lt;/code&gt; 中的值不能写为此类文字。</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">至于数字数组,对于稳定排序概念没有意义的数组类型(即两个值比较相等无法区分时),选择非稳定的默认算法可能是有意义的。</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">至于单值，使用&lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;对待 &lt;code&gt;missing&lt;/code&gt; 值等于其他 &lt;code&gt;missing&lt;/code&gt; 值，但来自非缺失值不同</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">如上所述，Julia的一个非常有用的功能是能够在Julia自身内部生成和操纵Julia代码的功能。我们已经看到了一个返回&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;对象的函数示例：&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;函数，该函数接受一串Julia代码并返回相应的 &lt;code&gt;Expr&lt;/code&gt; 。函数还可以将一个或多个 &lt;code&gt;Expr&lt;/code&gt; 对象用作参数，然后返回另一个 &lt;code&gt;Expr&lt;/code&gt; 。这是一个简单的示例：</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">如以上示例所示， &lt;code&gt;|&lt;/code&gt; 的每一列 字符必须垂直对齐。</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">与Java中一样，字符串是不可变的：不能更改 &lt;code&gt;AbstractString&lt;/code&gt; 对象的值。要构造一个不同的字符串值，请从其他字符串的一部分构造一个新的字符串。</target>
        </trans-unit>
        <trans-unit id="10a53b8655071d9e82e3aaf67177dfbc302c86e3" translate="yes" xml:space="preserve">
          <source>As in keyword arguments, identifiers and dot expressions imply names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">和上面的例子一样,我们建议在编写文档时遵循一些简单的约定。</target>
        </trans-unit>
        <trans-unit id="a760e2170f972850310e9b6d50d6aa2fdbfb2289" translate="yes" xml:space="preserve">
          <source>As in the previous example, the first assignment to &lt;code&gt;s&lt;/code&gt; at the top of &lt;code&gt;sum_to&lt;/code&gt; causes &lt;code&gt;s&lt;/code&gt; to be a new local variable in the body of the function. The &lt;code&gt;for&lt;/code&gt; loop has its own inner local scope within the function scope. At the point where &lt;code&gt;s = s + i&lt;/code&gt; occurs, &lt;code&gt;s&lt;/code&gt; is already a local variable, so the assignment updates the existing &lt;code&gt;s&lt;/code&gt; instead of creating a new local. We can test this out by calling &lt;code&gt;sum_to&lt;/code&gt; in the REPL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">如前所述， &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; 类型的行为类似于 &lt;code&gt;UInt8&lt;/code&gt; 的只读数组，如果您需要标准向量，则可以使用 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 进行转换：</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">如上所述，还可以定义新的显示后端。例如，可以在窗口中显示PNG图像的模块可以向Julia注册此功能，以便在具有PNG表示形式的类型上调用&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;将使用该模块的窗口自动显示图像。</target>
        </trans-unit>
        <trans-unit id="9a3464c75addc4046f2d5407323c1df1db4f1784" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">如&lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Function&lt;/a&gt;中简要提到的，可选参数作为多种方法定义的语法实现。例如，此定义：</target>
        </trans-unit>
        <trans-unit id="be2578b9d9f02697184689069f4eff8d3539a32a" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, functions defined by &lt;code&gt;@deprecate&lt;/code&gt; do not print warning when &lt;code&gt;julia&lt;/code&gt; is run without the &lt;code&gt;--depwarn=yes&lt;/code&gt; flag set, as the default value of &lt;code&gt;--depwarn&lt;/code&gt; option is &lt;code&gt;no&lt;/code&gt;. The warnings are printed from tests run by &lt;code&gt;Pkg.test()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512c2f7db98f68697b03e7fce5871064de0272a9" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, this code works without the &lt;code&gt;global&lt;/code&gt; annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48e9ac18414a96f1e01471c6b6626466797c864" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+0000&lt;/code&gt; through &lt;code&gt;U+D7FF&lt;/code&gt; and &lt;code&gt;U+E000&lt;/code&gt; through &lt;code&gt;U+10FFFF&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">在撰写本文时，有效的Unicode代码点是 &lt;code&gt;U+00&lt;/code&gt; 至 &lt;code&gt;U+d7ff&lt;/code&gt; 和 &lt;code&gt;U+e000&lt;/code&gt; 至 &lt;code&gt;U+10ffff&lt;/code&gt; 。这些还没有全部被赋予可理解的含义，也没有必要被应用程序解释，但是所有这些值都被认为是有效的Unicode字符。</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">从这里可以看到，&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;仅返回true或false，指示在字符串中是否发生了与给定正则表达式匹配的事件。但是，通常，人们不仅想知道字符串是否匹配，还想&lt;em&gt;知道如何&lt;/em&gt;匹配。要捕获有关匹配的信息，请改用&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">如错误所述，远程节点上 &lt;code&gt;UndefVarError&lt;/code&gt; 的直接原因是不存在该名称的绑定。让我们探讨一些可能的原因。</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">如示例所示， &lt;code&gt;julia&lt;/code&gt; 的以下命令行参数被解释为程序 &lt;code&gt;script.jl&lt;/code&gt; 的命令行参数，该参数在全局常量 &lt;code&gt;ARGS&lt;/code&gt; 中传递。脚本本身的名称作为全局 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 传入。请注意，当在命令行上使用 &lt;code&gt;-e&lt;/code&gt; 选项给出Julia表达式时，也会设置 &lt;code&gt;ARGS&lt;/code&gt; （请参见下面的 &lt;code&gt;julia&lt;/code&gt; 帮助输出），但 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 将为空。例如，仅打印提供给脚本的参数，您可以这样做：</target>
        </trans-unit>
        <trans-unit id="109c1f4fb3ce88e11db771658301b6b14b390770" translate="yes" xml:space="preserve">
          <source>As the example shows, the original Julia array &lt;code&gt;A&lt;/code&gt; has now been sorted: &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia &lt;a href=&quot;#automatic-type-conversion&quot;&gt;takes care of converting the array to a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;&lt;/a&gt;), computing the size of the element type in bytes, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">如本示例所示，此类数组的元素类型为 &lt;code&gt;Union{Missing, T}&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 为非缺失值的类型。这只是反映了一个事实，即数组条目可以是 &lt;code&gt;T&lt;/code&gt; 类型（此处为 &lt;code&gt;Int64&lt;/code&gt; ），也可以是 &lt;code&gt;Missing&lt;/code&gt; 类型。这种数组使用等效的 &lt;code&gt;Array{T}&lt;/code&gt; 保存有效值，该 &lt;code&gt;Array{UInt8}&lt;/code&gt; 包含实际值，并与Array {UInt8}组合以指示条目的类型（即， &lt;code&gt;Missing&lt;/code&gt; 还是 &lt;code&gt;T&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ed6ee60a4bf819b8376da694ce11cd02fe61b3bd" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">通常，复数的绝对值（&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;）是其到零的距离。&lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt;给出绝对值的平方，并且对于复数特别有用，因为它避免了平方根。&lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;返回以弧度表示的相位角（也称为自&lt;em&gt;变量&lt;/em&gt;或&lt;em&gt;arg&lt;/em&gt;函数）。还为复数定义了其他&lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;基本功能&lt;/a&gt;的全部色域：</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">一如既往,推广系统让与其他数字类型的交互变得毫不费力。</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">与往常一样，这不会使 &lt;code&gt;DummyModule&lt;/code&gt; 进入任何需要 &lt;code&gt;using&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 的进程的范围。此外，将 &lt;code&gt;DummyModule&lt;/code&gt; 纳入某个进程的范围时，则不在其他任何进程上：</target>
        </trans-unit>
        <trans-unit id="98525fef666cf45bd35cbb0c018ea8c9988be2ad" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">正如在&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;调用C和Fortran代码中&lt;/a&gt;所看到的，Julia有一种简单有效的方法来调用用C编写的函数。但是在某些情况下则需要相反的情况：从C代码中调用Julia函数。这可用于将Julia代码集成到更大的C / C ++项目中，而无需用C / C ++重写所有内容。 Julia有一个C API使之成为可能。由于几乎所有的编程语言都有某种调用C函数的方法，因此Julia C API也可用于构建其他语言的桥梁（例如，从Python或C＃调用Julia）。</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">正如我们所看到的,Julia对象在C语言中被表示为指针。这就提出了谁来负责释放这些对象的问题。</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">如我们所见，典型的参数类型具有内部构造函数，这些构造函数在已知类型参数时会被调用。例如，它们适用于 &lt;code&gt;Point{Int}&lt;/code&gt; 但不适用于 &lt;code&gt;Point&lt;/code&gt; 。 （可选）可以添加自动确定类型参数的外部构造函数，例如，从调用 &lt;code&gt;Point(1,2)&lt;/code&gt; 构造 &lt;code&gt;Point{Int}&lt;/code&gt; 。外部构造函数调用内部构造函数来实际创建实例。但是，在某些情况下，宁愿不提供内部构造函数，因此无法手动请求特定类型的参数。</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">如我们所见，此类表达式支持使用 &lt;code&gt;$&lt;/code&gt; 进行插值。但是，在某些情况下，必须在&lt;em&gt;不&lt;/em&gt;执行插值的情况下引用代码。这种引用尚无语法，但在内部表示为 &lt;code&gt;QuoteNode&lt;/code&gt; 类型的对象。解析器为简单的带引号的项目（如符号）生成 &lt;code&gt;QuoteNode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8358ced5c8aa8043f6548995886cf6fc9b1c22a3" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">正如我们接下来会看到的那样,在调用带有特定参数的Julia函数时,需要进行装箱。</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">以及有关&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;的年份和季度的信息：</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">以及其他有用的操作,如寻找特征值或特征向量。</target>
        </trans-unit>
        <trans-unit id="4983ba754d4bcba44195d81235402b223d67bb4c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ccall&lt;/code&gt;, the return type and tuple of input types must be literal constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">与任何 &lt;code&gt;ccall&lt;/code&gt; 一样，必须使参数签名完全正确。另外，请注意，与 &lt;code&gt;Core.Intrinsics&lt;/code&gt; 公开的等效Julia函数不同，没有兼容性层可以确保内部函数有意义并可以在当前目标上运行。</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">与从构造函数返回的不完整对象一样，如果 &lt;code&gt;complete_me&lt;/code&gt; 或其任何被调用者在初始化 &lt;code&gt;Lazy&lt;/code&gt; 对象之前尝试访问其 &lt;code&gt;data&lt;/code&gt; 字段，则将立即引发错误。</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">如同上一节中的字词一样,如果字词回标需要写在双回标中,则使用大于2的偶数。请注意,如果在$/LaTeX$标记中需要包含一个单字的回标,那么使用两个回标就足够了。</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">与其他流一样，使用&lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;断开套接字：</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">与变量一样,Unicode也可以用于函数名。</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">正如你在例子中所看到的,日志记录语句没有提到日志事件的去向,也没有提到如何处理它们。这是一个关键的设计特征,它使系统可以组合,自然地并发使用。它通过分离两个不同的关注点来实现。</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">如您所见，对于具有显式类型参数的构造函数调用，参数将转换为隐含的字段类型： &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 有效，但 &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; 在转换 &lt;code&gt;2.5&lt;/code&gt; 时引发&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;到&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。当构造函数调用的参数隐含类型时，如 &lt;code&gt;Point(1,2)&lt;/code&gt; 所示，则参数的类型必须一致-否则无法确定 &lt;code&gt;T&lt;/code&gt; -但可以给出任何具有匹配类型的实参对到通用 &lt;code&gt;Point&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">正如你所看到的,如果spatted容器中的元素数量不对,那么函数调用就会失败,就像显式给出太多参数一样。</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">如您所见，在第一行中，我们要求过程2构造一个2&amp;times;2随机矩阵，在第二行中，我们要求它对其加1。两种计算的结果在两个期货 &lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;s&lt;/code&gt; 中可用。所述&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;宏评估在由第一参数指定的过程中的第二个参数的表达。</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">如您所见，参数必须精确地为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;类型。其他数字类型（例如整数或32位浮点值）不会自动转换为64位浮点，也不会将字符串解析为数字。由于 &lt;code&gt;Float64&lt;/code&gt; 是具体类型，而具体类型不能在Julia中进行子类化，因此此类定义只能应用于完全为 &lt;code&gt;Float64&lt;/code&gt; 类型的参数。但是，在声明的参数类型为抽象的情况下编写更通用的方法通常可能很有用：</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">如您所见，第二个版本使用了 &lt;code&gt;Int&lt;/code&gt; 文字，保留了输入参数的类型，而第一个则没有。这是因为，例如， &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; ，并且提升是通过乘法进行的。同样，&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;文字比&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;文字具有更少的类型破坏性，但比 &lt;code&gt;Int&lt;/code&gt; 更具破坏性：</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">如您所见， &lt;code&gt;path&lt;/code&gt; 变量中的空格已适当转义。但是，如果&lt;em&gt;要&lt;/em&gt;插入多个单词怎么办？在这种情况下，只需使用一个数组（或任何其他可迭代的容器）：</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">如您所见，附加元素的类型必须与附加元素的向量的元素类型匹配，否则会引发&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;。在以下示例中，方法类型参数 &lt;code&gt;T&lt;/code&gt; 用作返回值：</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">如您所见，如果不需要，可以省略归约运算符。在那种情况下，循环异步执行，即，它在所有可用的工作程序上产生独立的任务，并立即返回&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;数组，而无需等待完成。调用者可以通过调用 &lt;code&gt;fetch&lt;/code&gt; 在以后等待&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;完成，也可以在循环结束时使用&lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt;前缀来等待完成，例如 &lt;code&gt;@sync @distributed for&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">您可能已经意识到，虽然在全局对象上重新分配与全局变量关联的内存时，可能会收集这些内存，但是由于绑定继续有效，因此不会对工作线程执行此类操作。 &lt;code&gt;clear!&lt;/code&gt; 可用于到远程节点手动重新分配特定全局 &lt;code&gt;nothing&lt;/code&gt; 一旦它们不再需要。这将释放与它们关联的所有内存，这是常规垃圾回收周期的一部分。</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 分配给复合类型 &lt;code&gt;value&lt;/code&gt; 的命名字段。该 &lt;code&gt;value&lt;/code&gt; 必须是可变的，并且 &lt;code&gt;x&lt;/code&gt; 必须是 &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; 的子类型。另请参见&lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">为当前任务的任务本地存储中的键赋值。</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">分配 &lt;code&gt;[]&lt;/code&gt; 不会从集合中消除元素；而是使用&lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;a&lt;/code&gt; 分配给 &lt;code&gt;b&lt;/code&gt; 不会创建 &lt;code&gt;b&lt;/code&gt; 的副本；而是使用&lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">现在，将数字分配给 &lt;code&gt;a&lt;/code&gt; 会将其转换为 &lt;code&gt;Float64&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 将被存储为可以有效处理的64位浮点值的连续块。</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">赋值给对象的字段会转换为字段的声明类型。</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">分配给具有声明类型的变量（例如， &lt;code&gt;local x::T&lt;/code&gt; ）将转换为该类型。</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">赋值给数组会转换为数组的元素类型。</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">越界索引处的分配不会增加集合。如果集合是&lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; ,&lt;/a&gt;则可以通过&lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;来增长！或&lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">赋值可以并行地对多个变量进行操作,从一个可迭代的变量中取值。</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">赋值可以对多个变量进行串联操作,并将返回最右边的表达式的值。</target>
        </trans-unit>
        <trans-unit id="a4c2fee77618ccc921a63bc548e408d4da3037fb" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;s&lt;/code&gt; in soft scope is ambiguous because a global variable by the same name exists: &lt;code&gt;s&lt;/code&gt; will be treated as a new local. Disambiguate by using &lt;code&gt;local s&lt;/code&gt; to suppress this warning or &lt;code&gt;global s&lt;/code&gt; to assign to the existing global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;chnl&lt;/code&gt; 的生存期与任务相关联。任务终止时， &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; 自动关闭。任务中任何未捕获的异常都会传播到 &lt;code&gt;chnl&lt;/code&gt; 上的所有侍者。</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">关联集合（例如 &lt;code&gt;Dict&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; ）需要在 &lt;code&gt;__init__&lt;/code&gt; 中重新哈希。（将来，可能会提供一种机制来注册初始化函数。）</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">假定没有找到比上述方法更具体的方法，那么Julia会根据上面给出的泛型函数内部定义并编译一个名为 &lt;code&gt;myplus&lt;/code&gt; 的方法，该方法专门针对两个 &lt;code&gt;Int&lt;/code&gt; 参数，即隐式定义和编译：</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">Asterisk操作员</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">惊讶的脸</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">渐变等于</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="1b797bdd1bcf1af4799cd31c8e25a767ad70f14e" translate="yes" xml:space="preserve">
          <source>Asynchronous &quot;tasks&quot;, or coroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">异步IO和并发同步写。</target>
        </trans-unit>
        <trans-unit id="8148eff566285bcd48743fb742f972c7a1dd962f" translate="yes" xml:space="preserve">
          <source>Asynchronous Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">在 &lt;code&gt;-O3&lt;/code&gt; 处，编译器&lt;em&gt;可能会&lt;/em&gt;自动对此类元组的操作进行矢量化。例如，以下程序在用 &lt;code&gt;julia -O3&lt;/code&gt; 编译时会在x86系统上生成两条SIMD加法指令（ &lt;code&gt;addps&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">在较高层次上，每个环境从概念上定义了三个映射：根，图和路径。在解决 &lt;code&gt;import X&lt;/code&gt; 的含义时，根和图映射用于确定 &lt;code&gt;X&lt;/code&gt; 的身份，而路径映射用于定位 &lt;code&gt;X&lt;/code&gt; 的源代码。这三个地图的具体角色是：</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">乍一看，这似乎足够合理，因为9223372036854754775807比-9223372036854775808更接近9223372036854775808，并且整数仍然以与C和Fortran兼容的自然大小表示。但是，饱和整数算法存在很大的问题。第一个也是最明显的问题是这不是机器整数算法的工作方式，因此实现饱和操作需要在每个机器整数操作之后发出指令，以检查下溢或上溢并将结果替换为&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; &lt;/a&gt;作为适当的。仅此一项就将每个整数运算从一条快速指令扩展为六条指令（可能包括分支）。哎哟。但是，情况变得更糟&amp;ndash;饱和整数算术运算不是关联的。考虑以下Matlab计算：</target>
        </trans-unit>
        <trans-unit id="9939b5009359c95078c2105da459f4858711c0ae" translate="yes" xml:space="preserve">
          <source>At least Julia 1.4 is required for specifying a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">此功能的基础是&lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt;，它将执行适当的地址解析：</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">在顶部，该函数的推断返回类型显示为 &lt;code&gt;Body::Float64&lt;/code&gt; 。下一行以Julia的SSA IR形式表示 &lt;code&gt;f&lt;/code&gt; 的主体。编号的框是标签，代表代码中跳转的目标（通过 &lt;code&gt;goto&lt;/code&gt; ）。查看正文，您会看到发生的第一件事是调用了 &lt;code&gt;pos&lt;/code&gt; &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; 由于它是非具体类型，因此返回值已推断为大写的 &lt;code&gt;Union&lt;/code&gt; 类型UNION {FLOAT64，INT64}。这意味着我们无法根据输入类型知道 &lt;code&gt;pos&lt;/code&gt; 的确切返回类型。但是，无论 &lt;code&gt;y&lt;/code&gt; 是否为 &lt;code&gt;y*x&lt;/code&gt; 的结果都是 &lt;code&gt;Float64&lt;/code&gt; 是 &lt;code&gt;Float64&lt;/code&gt; 或 &lt;code&gt;Int64&lt;/code&gt; 的最终结果是，即使某些中间计算类型不稳定， &lt;code&gt;f(x::Float64)&lt;/code&gt; 的输出也不是类型不稳定的。</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">此时,项目应该构建并运行。</target>
        </trans-unit>
        <trans-unit id="07f4310d23db89112b431f6fd02d1ccd231d2fd9" translate="yes" xml:space="preserve">
          <source>At this time, most operations in the Julia runtime and standard libraries can be used in a thread-safe manner, if the user code is data-race free. However, in some areas work on stabilizing thread support is ongoing. Multi-threaded programming has many inherent difficulties, and if a program using threads exhibits unusual or undesirable behavior (e.g. crashes or mysterious results), thread interactions should typically be suspected first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">运动鞋</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">原子操作</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">可以使用 &lt;code&gt;[]&lt;/code&gt; 符号访问原子对象：</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">原子操作使用 &lt;code&gt;atomic_&lt;/code&gt; 前缀，例如&lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;等</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">以原子方式将 &lt;code&gt;val&lt;/code&gt; 添加到 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子按位-和 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子按位NAND（不和） &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子按位或 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;val&lt;/code&gt; 原子按位异或（异或） &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">原子比较并设置 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">以原子方式将 &lt;code&gt;x&lt;/code&gt; 中的值与 &lt;code&gt;cmp&lt;/code&gt; 进行比较。如果相等，写 &lt;code&gt;newval&lt;/code&gt; 到 &lt;code&gt;x&lt;/code&gt; 。否则，将 &lt;code&gt;x&lt;/code&gt; 保留不变。返回 &lt;code&gt;x&lt;/code&gt; 中的旧值。通过将返回值与 &lt;code&gt;cmp&lt;/code&gt; （通过 &lt;code&gt;===&lt;/code&gt; ）进行比较，可以知道 &lt;code&gt;x&lt;/code&gt; 是否已修改，现在保留了新值 &lt;code&gt;newval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">原子交换 &lt;code&gt;x&lt;/code&gt; 中的值</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">用 &lt;code&gt;newval&lt;/code&gt; 原子交换 &lt;code&gt;x&lt;/code&gt; 中的值。返回&lt;strong&gt;旧&lt;/strong&gt;值。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">以原子存储最大的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;val&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">以原子存储最小的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;val&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 原子减去 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">尝试从 &lt;code&gt;upstream&lt;/code&gt; 如果提供的话）或从上游跟踪分支的其他地方尝试当前分支的自动合并变基。 &lt;code&gt;newbase&lt;/code&gt; 是要重新建立基础的分支。默认情况下是 &lt;code&gt;upstream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">自动柜员机</target>
        </trans-unit>
        <trans-unit id="674ab38ea62e0b4a07e2dda58e235dd6968ef52f" translate="yes" xml:space="preserve">
          <source>Automatic Type Conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">为不同的参数类型自动生成高效、专门的代码。</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">可用于方法扩展</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">避免改变变量的类型</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">避免混淆某物是实例还是类型。</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">避免使用带有抽象类型参数的容器</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">避免复杂的容器类型</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">避免使用抽象容器的字段</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">避免使用抽象类型的字段</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">避免使用全局变量</target>
        </trans-unit>
        <trans-unit id="8c84ddcd06891b88969d0af7db4510b7be8ee56a" translate="yes" xml:space="preserve">
          <source>Avoid running top-level operations, e.g. &lt;code&gt;include&lt;/code&gt;, or &lt;code&gt;eval&lt;/code&gt; of type, method, and module definitions in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">避免奇怪型 &lt;code&gt;Union&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">避免对I/O进行字符串插值</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">避免类型盗版</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">避免不必要的数组。例如，使用 &lt;code&gt;x+y+z&lt;/code&gt; 代替&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">尽可能避免在通用代码中使用浮点数来表示数字字面。</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">避免在URL中使用密码。与凭证对象不同,Julia在使用后无法安全地将敏感数据归零或销毁,密码可能会留在内存中;可能会被未初始化的内存暴露。</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">避免写出过于具体的类型</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">避免管道中的僵局</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">许多人认为避免更改全局变量的值是编程的最佳实践。更改全局变量的值可能会导致&amp;ldquo;远距离操作&amp;rdquo;，从而使程序的行为更难以推论。这就是为什么引入局部作用域的作用域块要求 &lt;code&gt;global&lt;/code&gt; 关键字声明意图修改全局变量的原因。</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">避免球状物</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy和Nicholas J. Higham，&amp;ldquo;矩阵对数的改进的逆缩放和平方算法&amp;rdquo;，SIAM科学计算杂志，34（4），2012，C153-C169。&lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi：10.1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy，Nicholas J. Higham和Samuel D. Relton，&amp;ldquo;计算矩阵对数的Fr&amp;eacute;chet导数并估计条件数&amp;rdquo;，SIAM科学计算学报，35（4），2013，C394-C410。&lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi：10.1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">B&amp;eacute;zout系数&lt;em&gt;不是&lt;/em&gt;唯一定义的。 &lt;code&gt;gcdx&lt;/code&gt; 返回由扩展的欧几里得算法计算的最小B&amp;eacute;zout系数。 （参考：D。Knuth，TAoCP，2 / e，第325页，算法X。）对于有符号整数，这些系数 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 在$ | u |的意义上是最小值。 &amp;lt;| y / d | $和$ | v | &amp;lt;| x / d | $。此外，选择 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 的符号，使 &lt;code&gt;d&lt;/code&gt; 为正。对于无符号整数，系数 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 可能接近其 &lt;code&gt;typemax&lt;/code&gt; ，并且恒等式仅通过无符号整数的模运算保持。</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">BLAS字符参数</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS功能</target>
        </trans-unit>
        <trans-unit id="38726bba2d45fa38b747b2e7e3f161c3f4fb4718" translate="yes" xml:space="preserve">
          <source>BLAS character arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10410d90763f9147a245aec96798dc0ea5a38e4" translate="yes" xml:space="preserve">
          <source>BLAS functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">天使宝宝</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">婴儿奶瓶</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">小鸡</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">婴儿符号</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">向后,上面有向左箭头</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">背景和参考资料</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">反斜杠（ &lt;code&gt;\&lt;/code&gt; ）以双反斜杠（ &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ）进行转义。不可打印字符使用其标准C逸出代码进行转义，对于NUL（如果是明确的话）使用 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; ，Unicode代码点（ &lt;code&gt;&quot;\u&quot;&lt;/code&gt; 前缀）或十六进制（ &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 前缀）进行转义。</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">退格， &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">双峰驼</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">行李领取</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">在计算矩阵的 &lt;code&gt;A&lt;/code&gt; 征系统或Schur分解之前，对其进行平衡。 &lt;code&gt;job&lt;/code&gt; 可以是一个 &lt;code&gt;N&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; 不会被置换或缩放）， &lt;code&gt;P&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; 才会被置换）， &lt;code&gt;S&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; 才会被缩放），或 &lt;code&gt;B&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; 将两个置换和缩放）。就地修改 &lt;code&gt;A&lt;/code&gt; 并返回 &lt;code&gt;ilo&lt;/code&gt; ， &lt;code&gt;ihi&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 。如果启用了置换，则当 &lt;code&gt;j &amp;gt; i&lt;/code&gt; 且 &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; 或 &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; 时， &lt;code&gt;A[i,j] = 0&lt;/code&gt; 。 &lt;code&gt;scale&lt;/code&gt; 包含有关执行的缩放/排列的信息。</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">选票箱(带支票)</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">钞票与美元标志</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">带有欧元标志的纸币</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">带有英镑标志的纸币</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">有日元标志的纸币</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">条形图</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">理发杆</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">基础子模块</target>
        </trans-unit>
        <trans-unit id="13b575497d7efff2ec5b49faf71dbac3532ee190" translate="yes" xml:space="preserve">
          <source>Base collection types require manual locking if used simultaneously by multiple threads where at least one thread modifies the collection (common examples include &lt;code&gt;push!&lt;/code&gt; on arrays, or inserting items into a &lt;code&gt;Dict&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">基于此观察，我们可以得出结论，如果其中一个操作数为 &lt;code&gt;true&lt;/code&gt; ，而另一个 &lt;code&gt;missing&lt;/code&gt; ，则尽管对其中一个操作数的实际值存在不确定性，我们仍然知道结果为 &lt;code&gt;true&lt;/code&gt; 。如果我们能够观察到第二个操作数的实际值，则只能为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，在两种情况下结果均为 &lt;code&gt;true&lt;/code&gt; 。因此，在这种特殊情况下，missingness并&lt;em&gt;没有&lt;/em&gt;传播</target>
        </trans-unit>
        <trans-unit id="791f5b6a2aaabca7a2c4cad24b70f6e46c76fdcc" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Task&lt;/code&gt; operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">基本流I/O</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">基本单元测试</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">基本表可以使用下面描述的语法编写。请注意，降价表的功能有限，并且与上面讨论的其他元素不同，不能包含嵌套的顶级元素-仅允许内联元素。表必须始终包含带有列名的标题行。单元格不能跨越表的多个行或列。</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">基本用途</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">篮球和篮球</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="5efe26975abbced9003edb837133f3af03f436e7" translate="yes" xml:space="preserve">
          <source>Be aware of when Julia avoids specializing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">要注意什么时候一个宏真的可以是一个函数代替。</target>
        </trans-unit>
        <trans-unit id="f0826b18a2138cb79c2b1a66c614cdb664f937ef" translate="yes" xml:space="preserve">
          <source>Be aware that finalizers registered by a library may break if threads are enabled. This may require some transitional work across the ecosystem before threading can be widely adopted with confidence. See the next section for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">请注意，此策略至少有一个主要缺点：在许多情况下，用户无法通过定义导出函数 &lt;code&gt;f&lt;/code&gt; 的进一步特殊化来进一步自定义 &lt;code&gt;f&lt;/code&gt; 的行为。相反，他们必须为内部方法 &lt;code&gt;_fA&lt;/code&gt; 和 &lt;code&gt;_fB&lt;/code&gt; 定义特殊化，这模糊了导出方法和内部方法之间的界限。</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">只要使用此函数的结果，请小心确保存在对 &lt;code&gt;x&lt;/code&gt; 的Julia引用。因此，此函数的参数 &lt;code&gt;x&lt;/code&gt; 绝不能是表达式，而只能是变量名或字段引用。例如， &lt;code&gt;x=a.b.c&lt;/code&gt; 是可接受的，但 &lt;code&gt;x=[a,b,c]&lt;/code&gt; 是不可接受的。</target>
        </trans-unit>
        <trans-unit id="fe66257c8592b5cf4fc84f98162f41a3e02473c6" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;invoke&lt;/code&gt; for functions that you don't write. What definition is used for given &lt;code&gt;argtypes&lt;/code&gt; is an implementation detail unless the function is explicitly states that calling with certain &lt;code&gt;argtypes&lt;/code&gt; is a part of public API. For example, the change between &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-&lt;code&gt;invoke&lt;/code&gt;) call. However, the change is visible if you use &lt;code&gt;invoke&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590d4269627728c65164df59752ab3f2172388df" translate="yes" xml:space="preserve">
          <source>Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">要注意类型平等</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">有梁八分音符/无梁八分音符</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">熊脸</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">跳动的心</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">因为 &lt;code&gt;a&lt;/code&gt; 是一个抽象类型&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;的数组，所以它必须能够保存任何 &lt;code&gt;Real&lt;/code&gt; 值。由于 &lt;code&gt;Real&lt;/code&gt; 对象可以具有任意大小和结构，因此 &lt;code&gt;a&lt;/code&gt; 必须表示为指向单独分配的 &lt;code&gt;Real&lt;/code&gt; 对象的指针数组。但是，如果我们不是只允许同一类型，例如数字&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;，存储在 &lt;code&gt;a&lt;/code&gt; 这些可以更有效地存储：</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">因为C不支持多个返回值，所以C函数通常会使用指向该函数将修改的数据的指针。要在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 中&lt;/a&gt;完成此操作，您首先需要将该值封装在适当类型的&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;中。当您将此 &lt;code&gt;Ref&lt;/code&gt; 对象作为参数传递时，Julia将自动将C指针传递给封装的数据：</target>
        </trans-unit>
        <trans-unit id="d44d25a0390ec817de43e662485f00ec7ef00a32" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">由于Julia的编译器与Python或R等语言使用的解释器不同，因此您可能会发现Julia的性能起初并不直观。如果发现运行缓慢，我们强烈建议您先阅读&amp;ldquo; &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&amp;rdquo;&lt;/a&gt;部分，然后再尝试其他操作。一旦了解了Julia的工作原理，就可以轻松编写出与C一样快的代码。</target>
        </trans-unit>
        <trans-unit id="7d35da8223bf95881284388f273666759cae71cf" translate="yes" xml:space="preserve">
          <source>Because finalizers can interrupt any code, they must be very careful in how they interact with any global state. Unfortunately, the main reason that finalizers are used is to update global state (a pure function is generally rather pointless as a finalizer). This leads us to a bit of a conundrum. There are a few approaches to dealing with this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">由于具有这些共享的属性，这些类型在内部表示为具有相同概念 &lt;code&gt;DataType&lt;/code&gt; 的实例，该类型是以下任何类型的类型：</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">由于采用了可变长度编码，字符串中的字符数（由 &lt;code&gt;length(s)&lt;/code&gt; 给出）并不总是与最后一个索引相同。如果您遍历索引1到&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt;并索引到 &lt;code&gt;s&lt;/code&gt; ，则在未引发错误时返回的字符序列是组成字符串 &lt;code&gt;s&lt;/code&gt; 的字符序列。因此，我们具有 &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; 的标识，因为字符串中的每个字符都必须具有自己的索引。以下是迭代 &lt;code&gt;s&lt;/code&gt; 字符的效率低下和冗长的方法：</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">因为支持通用编程被认为比通过其他方式（例如，使用显式循环）可以实现的潜在性能优化更为重要，所以 &lt;code&gt;+=&lt;/code&gt; 和 &lt;code&gt;*=&lt;/code&gt; 之类的运算符通过重新绑定新值来工作。</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">由于&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;类型存储为单个&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;值，因此可以通过访问器函数检索日期部分或字段。小写访问器以整数形式返回该字段：</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">因为编译器知道整数加法和乘法是关联的，并且乘法是在加法上分配的，而饱和算术都不是这样，所以它可以将整个循环优化为乘法和加法。饱和算术完全不利于这种优化，因为关联性和分布性可能在每次循环迭代时失败，根据失败发生在哪个迭代中而导致不同的结果。编译器可以展开循环，但是不能代数地将多个操作简化为更少的等效操作。</target>
        </trans-unit>
        <trans-unit id="b0fb1c1b010730bc0463b629ac89a10341b04531" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">因为运算符 &lt;code&gt;^&lt;/code&gt; 的优先级高于 &lt;code&gt;*&lt;/code&gt; （请参阅&lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;运算符优先级和关联性&lt;/a&gt;），所以此输出未如实地表示表达式 &lt;code&gt;a ^ 2&lt;/code&gt; ，该表达式应等于 &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 。要解决此问题，我们必须为 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; 创建一个自定义方法，该方法在打印时由表达式对象在内部调用：</target>
        </trans-unit>
        <trans-unit id="f808dfd9f99fca14db2870360d26f322b8ed85e2" translate="yes" xml:space="preserve">
          <source>Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">啤酒杯</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">在Julia 1.2之前，此签名仅限于 &lt;code&gt;f::Function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">在运行Julia之前，请将环境变量 &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; 设置为1。</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">在执行 &lt;code&gt;@testset&lt;/code&gt; 的主体之前，有一个对 &lt;code&gt;Random.seed!(seed)&lt;/code&gt; 的隐式调用，其中 &lt;code&gt;seed&lt;/code&gt; 是全局RNG的当前种子。此外，在执行主体之后，全局RNG的状态将恢复为 &lt;code&gt;@testset&lt;/code&gt; 之前的状态。这意味着在出现故障的情况下可以简化重现性，并允许 &lt;code&gt;@testset&lt;/code&gt; 的无缝重新排列，而不考虑其对全局RNG状态的副作用。</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">程序终止之前，强烈建议调用 &lt;code&gt;jl_atexit_hook&lt;/code&gt; 。上面的示例程序在从 &lt;code&gt;main&lt;/code&gt; 返回之前调用了此方法。</target>
        </trans-unit>
        <trans-unit id="4b47e5d0ff5715fb37f74adf8fc2abb257a9578b" translate="yes" xml:space="preserve">
          <source>Beginners will write this kind of code without the &lt;code&gt;global&lt;/code&gt; and have no idea why their code doesn't work&amp;mdash;the error that they get is that &lt;code&gt;s&lt;/code&gt; is undefined, which does not seem to enlighten anyone who happens to make this mistake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">行为类似可以通过Julia GC管理其内存的 &lt;code&gt;Ptr{T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nextind&lt;/code&gt; 为对 &lt;code&gt;n==1&lt;/code&gt; 应用 &lt;code&gt;n&lt;/code&gt; 次nextind。唯一的区别是，如果 &lt;code&gt;n&lt;/code&gt; 太大，以至于应用 &lt;code&gt;nextind&lt;/code&gt; 会达到 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; ,则每个剩余​​的迭代会将返回值增加 &lt;code&gt;1&lt;/code&gt; 。这意味着在这种情况下， &lt;code&gt;nextind&lt;/code&gt; 可以返回大于 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">像施加的行为 &lt;code&gt;n&lt;/code&gt; 倍 &lt;code&gt;prevind&lt;/code&gt; 为 &lt;code&gt;n==1&lt;/code&gt; 。唯一的区别是，如果 &lt;code&gt;n&lt;/code&gt; 太大以至于应用 &lt;code&gt;prevind&lt;/code&gt; 将达到 &lt;code&gt;0&lt;/code&gt; ,则每个剩余​​的迭代会将返回值减少 &lt;code&gt;1&lt;/code&gt; 。这意味着在这种情况下， &lt;code&gt;prevind&lt;/code&gt; 可以返回负值。</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">带取消行程的钟声</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">下面是一个例子,在某些硬件上,次常态明显影响性能。</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">下面我们将讨论特定的挑战和解决这些问题的一些替代方法。</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">便当盒</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">苯环</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">苯环与圆环</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">除了用于&lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt;常量， &lt;code&gt;VersionNumber&lt;/code&gt; 对象还广泛用于 &lt;code&gt;Pkg&lt;/code&gt; 模块中，以指定软件包的版本及其依赖性。</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">赌注符号/第二变色龙</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">BigFloats和BigInts</target>
        </trans-unit>
        <trans-unit id="669a7400e7ecdc8abb5def5c2be2775fd1a39afb" translate="yes" xml:space="preserve">
          <source>Bignums are supported, but conversion is not automatic; ordinary integers &lt;a href=&quot;../faq/index#faq-integer-arithmetic&quot;&gt;overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">双向置换 &lt;code&gt;A&lt;/code&gt; ，返回 &lt;code&gt;PAQ&lt;/code&gt; （ &lt;code&gt;A[p,q]&lt;/code&gt; ）。列置换 &lt;code&gt;q&lt;/code&gt; 的长度必须匹配 &lt;code&gt;A&lt;/code&gt; 的列数（ &lt;code&gt;length(q) == A.n&lt;/code&gt; ）。行排列 &lt;code&gt;p&lt;/code&gt; 的长度必须匹配 &lt;code&gt;A&lt;/code&gt; 的行数（ &lt;code&gt;length(p) == A.m&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5033e83ebc769b610ff5842eedc3584eb861a747" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == size(A, 2)&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == size(A, 1)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">双向置换 &lt;code&gt;A&lt;/code&gt; ，将结果 &lt;code&gt;PAQ&lt;/code&gt; （ &lt;code&gt;A[p,q]&lt;/code&gt; ）存储在 &lt;code&gt;X&lt;/code&gt; 中。将中间结果 &lt;code&gt;(AQ)^T&lt;/code&gt; （ &lt;code&gt;transpose(A[:,q])&lt;/code&gt; ）存储在可选参数 &lt;code&gt;C&lt;/code&gt; 中(如果存在）。要求 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; （如果存在）都不互为别名；要将结果 &lt;code&gt;PAQ&lt;/code&gt; 存储回 &lt;code&gt;A&lt;/code&gt; 中，请使用缺少 &lt;code&gt;X&lt;/code&gt; 的以下方法：</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="c1d93ced1617078468dc67be83745c4934553581" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">诸如 &lt;code&gt;.+&lt;/code&gt; 类的二进制（或一元）运算符使用相同的机制处理：它们等效于 &lt;code&gt;broadcast&lt;/code&gt; 调用，并与其他嵌套的&amp;ldquo;点&amp;rdquo;调用融合。 &lt;code&gt;X .+= Y&lt;/code&gt; etcetera等效于 &lt;code&gt;X .= X .+ Y&lt;/code&gt; 并导致融合的就地分配；另请参阅&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;点运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">也支持二进制和八进制的文字。</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">二进制算术- - &lt;code&gt;-&lt;/code&gt; + ， &lt;code&gt;+&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c4e4b4e465473735caeea3bbe55395f833f831" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 11 exponent, 52 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2dc88cfba0517f9a198be3d135a4aa4ba4c99" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 5 exponent, 10 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b640f698cc5a43263f00b745c9489369b4eda" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 8 exponent, 23 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">二进制，八进制和十六进制文字可以在无符号文字之前紧跟 &lt;code&gt;-&lt;/code&gt; 。它们产生的无符号整数的大小与无符号文字的大小相同，并带有两个值的补数：</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">将 &lt;code&gt;socket&lt;/code&gt; 绑定到给定的 &lt;code&gt;host:port&lt;/code&gt; 。请注意， &lt;code&gt;0.0.0.0&lt;/code&gt; 将在所有设备上侦听。</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">生日蛋糕</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
        <trans-unit id="d102341c9ef55fb595a96df06da32dfabaf31707" translate="yes" xml:space="preserve">
          <source>Bits Types</source>
          <target state="translated">位数类型</target>
        </trans-unit>
        <trans-unit id="3d60896c2746f9344a7ec07d0c544abfbd6ac054" translate="yes" xml:space="preserve">
          <source>Bitshifts</source>
          <target state="translated">Bitshifts</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">位元运算符</target>
        </trans-unit>
        <trans-unit id="003769240202348f8c8c50c01088aea9a66d1338" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">按位与。实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果一个操作数 &lt;code&gt;missing&lt;/code&gt; 而另一个为 &lt;code&gt;true&lt;/code&gt; ，则返回&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39242907d8fbb94d63ee93aa69c2eae1e3bdde37" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;. Add parentheses for function application form: &lt;code&gt;(&amp;amp;)(x, y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8386afef0f71e44b527049e051999293a919fac" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one of the arguments is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的按位异或。实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;其中一个参数，则返回 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95edcf566466d2b1f53eaf47da115b29e2f2b799" translate="yes" xml:space="preserve">
          <source>Bitwise not.</source>
          <target state="translated">位上不。</target>
        </trans-unit>
        <trans-unit id="55d4c457eca0630bcbc6d9ef2deac549be6e9eb1" translate="yes" xml:space="preserve">
          <source>Bitwise or. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">按位或。实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果一个操作数 &lt;code&gt;missing&lt;/code&gt; 而另一个为 &lt;code&gt;false&lt;/code&gt; ，则返回&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbd4e8d6d33b0a0cb69eddf98c203dfb76b59494" translate="yes" xml:space="preserve">
          <source>Black Circle</source>
          <target state="translated">黑色圆环</target>
        </trans-unit>
        <trans-unit id="0548413521ae8836d60c83abbcac0b4ffd5b48c9" translate="yes" xml:space="preserve">
          <source>Black Circle With Two White Dots</source>
          <target state="translated">黑色圆圈配两个白点</target>
        </trans-unit>
        <trans-unit id="d7fd466be098000d71600e8371d0c45e2c49fceb" translate="yes" xml:space="preserve">
          <source>Black Circle With White Dot Right</source>
          <target state="translated">黑圈配白点右</target>
        </trans-unit>
        <trans-unit id="757cd02902cbeae20fd43d03ee03d7081baecb82" translate="yes" xml:space="preserve">
          <source>Black Club Suit</source>
          <target state="translated">黑色俱乐部套装</target>
        </trans-unit>
        <trans-unit id="9450d23785e56cc9d47bc85752234baaa5f58935" translate="yes" xml:space="preserve">
          <source>Black Diamond</source>
          <target state="translated">黑钻石</target>
        </trans-unit>
        <trans-unit id="1e863cdb2d578f5fa6a621df1fbd38ab6818ad43" translate="yes" xml:space="preserve">
          <source>Black Diamond Suit</source>
          <target state="translated">黑钻套装</target>
        </trans-unit>
        <trans-unit id="143603a649d02ce401e75e3d4b9853da1d1fab9f" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Double Triangle</source>
          <target state="translated">黑色下尖双三角</target>
        </trans-unit>
        <trans-unit id="7131227a767e1555b67aefca3c1775aaf0e8eee4" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle</source>
          <target state="translated">黑色下尖小三角/黑色下尖小三角。</target>
        </trans-unit>
        <trans-unit id="157034cbc1651891d53bf3735a8280c2c9e17261" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Triangle / Black Down Pointing Triangle</source>
          <target state="translated">黑色下点三角区/黑色下点三角区。</target>
        </trans-unit>
        <trans-unit id="79bb28413b3c0425fd63303d0da05ee06907711e" translate="yes" xml:space="preserve">
          <source>Black Heart Suit</source>
          <target state="translated">黑心套装</target>
        </trans-unit>
        <trans-unit id="84860fcb2778d5994fb2e1ec4ed5e1ff25be0c69" translate="yes" xml:space="preserve">
          <source>Black Hexagon</source>
          <target state="translated">黑色六边形</target>
        </trans-unit>
        <trans-unit id="eb3fe0b35214fe985deafdd4923cb6b5b71ecc00" translate="yes" xml:space="preserve">
          <source>Black Horizontal Ellipse</source>
          <target state="translated">黑色水平椭圆</target>
        </trans-unit>
        <trans-unit id="3d24dccec23ef173830493e234a9797701114f4b" translate="yes" xml:space="preserve">
          <source>Black Large Circle</source>
          <target state="translated">黑色大圆环</target>
        </trans-unit>
        <trans-unit id="546e54ab988bdc54b4d67a0c87d99ffab31da61d" translate="yes" xml:space="preserve">
          <source>Black Large Square</source>
          <target state="translated">黑色大方块</target>
        </trans-unit>
        <trans-unit id="6c8aa0f6c88d86e760e667a1cfc3b50d0980df03" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Double Triangle</source>
          <target state="translated">黑色左尖双三角</target>
        </trans-unit>
        <trans-unit id="cc1db57a30b84796696c95aebddd648e97e8d503" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Pointer / Black Left Pointing Pointer</source>
          <target state="translated">黑色左指向标/黑色左指向标。</target>
        </trans-unit>
        <trans-unit id="f5b4fdf2d1f644120341bc595bfdc32acb38d8d9" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle</source>
          <target state="translated">黑色左尖小三角/黑色左尖小三角</target>
        </trans-unit>
        <trans-unit id="394197a1901b539e852cc0120322c6a8cc9c8a83" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Triangle / Black Left Pointing Triangle</source>
          <target state="translated">黑色左尖三角形/黑色左尖三角形。</target>
        </trans-unit>
        <trans-unit id="651c14702ebcf7b7b2d5b2b8b2d4c78353cf3dc3" translate="yes" xml:space="preserve">
          <source>Black Lower Left Triangle</source>
          <target state="translated">黑色左下角三角形</target>
        </trans-unit>
        <trans-unit id="a993e08e4e58513d7c168e38a98af83c1b823e70" translate="yes" xml:space="preserve">
          <source>Black Lower Right Triangle</source>
          <target state="translated">黑色右下角三角形</target>
        </trans-unit>
        <trans-unit id="7784160f9d8de2c5b48e65c73c3ba7c32077d5d3" translate="yes" xml:space="preserve">
          <source>Black Lozenge</source>
          <target state="translated">黑菱形</target>
        </trans-unit>
        <trans-unit id="f51954be7eb46c9d2126809c883eed1d9b6af3da" translate="yes" xml:space="preserve">
          <source>Black Medium Diamond</source>
          <target state="translated">黑中钻</target>
        </trans-unit>
        <trans-unit id="e638cf3b3eda8a7622b5719c7bc597161ec84dff" translate="yes" xml:space="preserve">
          <source>Black Medium Lozenge</source>
          <target state="translated">黑色中号菱形</target>
        </trans-unit>
        <trans-unit id="7d1eb991c64f2c0aa6c491bf46495204bab8b980" translate="yes" xml:space="preserve">
          <source>Black Medium Small Square</source>
          <target state="translated">黑色 中号 小号 方形</target>
        </trans-unit>
        <trans-unit id="35e1e8816c4ad0b081b1abc5f0b5e6e68515fdd3" translate="yes" xml:space="preserve">
          <source>Black Medium Square</source>
          <target state="translated">黑色中号方块</target>
        </trans-unit>
        <trans-unit id="bd88cc2496f705279f693662165cafc22758e595" translate="yes" xml:space="preserve">
          <source>Black Nib</source>
          <target state="translated">黑尼伯</target>
        </trans-unit>
        <trans-unit id="17a74c499db585ffc78ad964cf24f74eeab12fbc" translate="yes" xml:space="preserve">
          <source>Black Parallelogram</source>
          <target state="translated">黑色平行四边形</target>
        </trans-unit>
        <trans-unit id="a5e0106e423905d56ce64cbee75d3dab7ab613a8" translate="yes" xml:space="preserve">
          <source>Black Pentagon</source>
          <target state="translated">黑五角大楼</target>
        </trans-unit>
        <trans-unit id="641e8ed8cc5074283080ad85521696fc93454500" translate="yes" xml:space="preserve">
          <source>Black Question Mark Ornament</source>
          <target state="translated">黑色问号装饰品</target>
        </trans-unit>
        <trans-unit id="d17f522d42443e1dee4d94f18ac22410a504bd60" translate="yes" xml:space="preserve">
          <source>Black Rectangle</source>
          <target state="translated">黑色长方形</target>
        </trans-unit>
        <trans-unit id="c7dbb16f8d25cc978eab91325f13bfbb34eb443b" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Double Triangle</source>
          <target state="translated">黑色直角双三角</target>
        </trans-unit>
        <trans-unit id="9a22fd5458a747bf2f8b9190b0800a8f327c6da4" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pentagon</source>
          <target state="translated">黑色右尖五角大楼</target>
        </trans-unit>
        <trans-unit id="08e8d8d34fe44b6c1da81bad30dfbb3dd0e4dc17" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pointer / Black Right Pointing Pointer</source>
          <target state="translated">黑色右指向标/黑色右指向标。</target>
        </trans-unit>
        <trans-unit id="356acd32b10439549774affb8876e75924c2d411" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle</source>
          <target state="translated">黑色直角小三角形/黑色直角小三角形</target>
        </trans-unit>
        <trans-unit id="91e55728177959f6eb733905e6d5d4b3b30df4c9" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Triangle / Black Right Pointing Triangle</source>
          <target state="translated">黑色直角三角形/黑色直角三角形</target>
        </trans-unit>
        <trans-unit id="7d35d74427ef7783600f70aed6734b005afcf3a5" translate="yes" xml:space="preserve">
          <source>Black Rightwards Arrow / Black Right Arrow</source>
          <target state="translated">黑色向右箭头/黑色右箭头</target>
        </trans-unit>
        <trans-unit id="4e1227a3b661c19e11075ce6c898353138a6cae4" translate="yes" xml:space="preserve">
          <source>Black Scissors</source>
          <target state="translated">黑剪刀</target>
        </trans-unit>
        <trans-unit id="3a1f9cf604664d5b2cfd7032309a96005ebcdd85" translate="yes" xml:space="preserve">
          <source>Black Small Diamond</source>
          <target state="translated">黑色小钻石</target>
        </trans-unit>
        <trans-unit id="560e8f05828a680fa9a4f86877ed9847156b94a9" translate="yes" xml:space="preserve">
          <source>Black Small Lozenge</source>
          <target state="translated">黑色小菱形</target>
        </trans-unit>
        <trans-unit id="2b77f77dfe2cfd17e674571a7ea6fb868ae1d0ef" translate="yes" xml:space="preserve">
          <source>Black Small Square</source>
          <target state="translated">黑色小方块</target>
        </trans-unit>
        <trans-unit id="53c256b922dbb0b4f34a326b72cef14e0af86c98" translate="yes" xml:space="preserve">
          <source>Black Small Star</source>
          <target state="translated">黑小星</target>
        </trans-unit>
        <trans-unit id="0ae1e3c46db08b1fb9b73728e2d7c428044fafa6" translate="yes" xml:space="preserve">
          <source>Black Smiling Face</source>
          <target state="translated">黑笑脸</target>
        </trans-unit>
        <trans-unit id="8e05108bb9601bfdc9ba0035253f2d64bdf60694" translate="yes" xml:space="preserve">
          <source>Black Spade Suit</source>
          <target state="translated">黑色黑桃套装</target>
        </trans-unit>
        <trans-unit id="a01d4a6e7dbc191a1cae5b3bc838a6150cf238dd" translate="yes" xml:space="preserve">
          <source>Black Square</source>
          <target state="translated">黑方块</target>
        </trans-unit>
        <trans-unit id="034b512bb5927fe50340904cd99432e1e4d73c3e" translate="yes" xml:space="preserve">
          <source>Black Square Button</source>
          <target state="translated">黑色方形纽扣</target>
        </trans-unit>
        <trans-unit id="fc626f5b71fcc01fb3ad79538a1fdd9c2c9068b3" translate="yes" xml:space="preserve">
          <source>Black Star</source>
          <target state="translated">黑星</target>
        </trans-unit>
        <trans-unit id="cb52335be163268292bf2e0b734ba8007620b51b" translate="yes" xml:space="preserve">
          <source>Black Sun With Rays</source>
          <target state="translated">黑太阳与射线</target>
        </trans-unit>
        <trans-unit id="337ee67e4218483768c29454b46d3636ae0684a9" translate="yes" xml:space="preserve">
          <source>Black Telephone</source>
          <target state="translated">黑色电话</target>
        </trans-unit>
        <trans-unit id="35536366f9217c4ba0ce04cd1f6ccbeed6b48c42" translate="yes" xml:space="preserve">
          <source>Black Universal Recycling Symbol</source>
          <target state="translated">黑色通用回收标志</target>
        </trans-unit>
        <trans-unit id="b63e9c12f3af70d3503bfb12a43507958e2cc9a3" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Double Triangle</source>
          <target state="translated">黑色上尖双三角</target>
        </trans-unit>
        <trans-unit id="5f6c177d2a76e96c788cfff6b45ea350fc5d5f85" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle</source>
          <target state="translated">黑色上尖小三角/黑色上尖小三角。</target>
        </trans-unit>
        <trans-unit id="b019fe1ecc9d7bb3e20c546241096de99470763e" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Triangle / Black Up Pointing Triangle</source>
          <target state="translated">黑色上尖三角形/黑色上尖三角形。</target>
        </trans-unit>
        <trans-unit id="fd38c797487c28729bfa7084dbd1bc7a8bd9f832" translate="yes" xml:space="preserve">
          <source>Black Upper Left Triangle</source>
          <target state="translated">黑色左上角三角形</target>
        </trans-unit>
        <trans-unit id="330a4e0eb7ba380f3677a102ba04f4ed4533c835" translate="yes" xml:space="preserve">
          <source>Black Upper Right Triangle</source>
          <target state="translated">黑色右上角三角形</target>
        </trans-unit>
        <trans-unit id="b5b860326f4e45d10acdc58e96248cded912b473" translate="yes" xml:space="preserve">
          <source>Black Vertical Ellipse</source>
          <target state="translated">黑色垂直椭圆</target>
        </trans-unit>
        <trans-unit id="12f762cae12dfd257dbcc1ff1c80f6e21ca05f3a" translate="yes" xml:space="preserve">
          <source>Black Vertical Rectangle</source>
          <target state="translated">黑色垂直长方形</target>
        </trans-unit>
        <trans-unit id="b6c6da3063676ec7403eb5eae23f28a26cc0a5b1" translate="yes" xml:space="preserve">
          <source>Black Very Small Square</source>
          <target state="translated">黑色超小方块</target>
        </trans-unit>
        <trans-unit id="f56700596b30b0c05182a7f770b5570cc76ca6d1" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital C / Black-Letter C</source>
          <target state="translated">黑体大写字母C/黑体字母C</target>
        </trans-unit>
        <trans-unit id="3212f9c9a227cc0ef9fc8c3906dee3d018e41215" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital H / Black-Letter H</source>
          <target state="translated">黑体大写字母H/黑体字母H</target>
        </trans-unit>
        <trans-unit id="882d2d7aaddec9c72be91b9b04d8760d1ae0ecd3" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital I / Black-Letter I</source>
          <target state="translated">黑体大写字母I/黑体字母 I</target>
        </trans-unit>
        <trans-unit id="8fc35324b6b0420a0444517c7f25614eb146dba4" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital R / Black-Letter R</source>
          <target state="translated">黑体大写字母R/黑体字母R</target>
        </trans-unit>
        <trans-unit id="4d139693ac24fa1ff39a927bee456e508f1aa95b" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital Z / Black-Letter Z</source>
          <target state="translated">黑体大写字母Z/黑体字母Z</target>
        </trans-unit>
        <trans-unit id="b847d9aaffd54e2b50551787d032091550aee835" translate="yes" xml:space="preserve">
          <source>Blank Symbol / Blank</source>
          <target state="translated">空白符号/空白</target>
        </trans-unit>
        <trans-unit id="9a1f6bbeb59612c3b0d54abe35a469485c6370c0" translate="yes" xml:space="preserve">
          <source>Block quotes</source>
          <target state="translated">块状报价</target>
        </trans-unit>
        <trans-unit id="413fe7b76bad922e0442b15508cafb42d749001b" translate="yes" xml:space="preserve">
          <source>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">在指定的秒数内阻止当前任务。最小睡眠时间为1毫秒或输入 &lt;code&gt;0.001&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da010911be728132526ebfb6c6611c41bf6de799" translate="yes" xml:space="preserve">
          <source>Block the current task until some event occurs, depending on the type of the argument:</source>
          <target state="translated">根据参数的类型,阻止当前任务,直到某些事件发生。</target>
        </trans-unit>
        <trans-unit id="53a69c53a3e2458ff176a179fec2def0b4121cba" translate="yes" xml:space="preserve">
          <source>Blossom</source>
          <target state="translated">Blossom</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="5963e560ae138684a55eeb248a0ec6a3d3e89c64" translate="yes" xml:space="preserve">
          <source>Blue Book</source>
          <target state="translated">蓝皮书</target>
        </trans-unit>
        <trans-unit id="a660e98a286d13e32848e06494a9c4e64598de77" translate="yes" xml:space="preserve">
          <source>Blue Heart</source>
          <target state="translated">蓝心</target>
        </trans-unit>
        <trans-unit id="30efd20f542ce356dcbbbbb0473393dd8189443b" translate="yes" xml:space="preserve">
          <source>Boar</source>
          <target state="translated">Boar</target>
        </trans-unit>
        <trans-unit id="19e07430eed6d97d6d73cb4a2967b1f316520f54" translate="yes" xml:space="preserve">
          <source>Bold</source>
          <target state="translated">Bold</target>
        </trans-unit>
        <trans-unit id="d5bf9d845ab97255cb3ab1100656db4f59731808" translate="yes" xml:space="preserve">
          <source>Bomb</source>
          <target state="translated">Bomb</target>
        </trans-unit>
        <trans-unit id="441da1bf0eb8dcaca895f5d48325eab484ada1e0" translate="yes" xml:space="preserve">
          <source>Bookmark</source>
          <target state="translated">Bookmark</target>
        </trans-unit>
        <trans-unit id="d51cc7068c060eda1ab4c1992e8e7188251dc5d0" translate="yes" xml:space="preserve">
          <source>Bookmark Tabs</source>
          <target state="translated">书签标签</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="9110e7395759cef34c9766cb75b920652e0ab037" translate="yes" xml:space="preserve">
          <source>Boolean not. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">布尔值不行。工具&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，返回&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;，如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29a8f9f9b6a1cad56addb73a669797d31b6ebe67" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e74670608867d2d5a7f2c19b7656691fac4def" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">布尔操作&lt;em&gt;没有&lt;/em&gt;短路评价可以在推出的按位布尔运算符来进行&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学运算和基本功能&lt;/a&gt;： &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 。这些是普通函数，碰巧支持中缀运算符语法，但始终会评估其参数：</target>
        </trans-unit>
        <trans-unit id="6aee8c1403b8f533d1b1cfe7c809aba2942d98a3" translate="yes" xml:space="preserve">
          <source>Boolean type, containing the values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">布尔类型，包含值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d3edec84ef05d40009ef42ad79a184127ff2d32" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">这两个&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;基本上是不可改变&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;包装。任一类型的单个 &lt;code&gt;instant&lt;/code&gt; 字段实际上都是 &lt;code&gt;UTInstant{P}&lt;/code&gt; 类型，它表示基于UT秒&lt;a href=&quot;#footnote-1&quot;&gt;[1]的&lt;/a&gt;机器时间线在不断增加。的&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;型是不知道时区（的&lt;em&gt;幼稚&lt;/em&gt;，在Python的说法），类似于一个&lt;em&gt;LocalDateTime&lt;/em&gt;用Java 8.附加时区的功能可以通过添加&lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl包&lt;/a&gt;，其编译&lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA时区数据库&lt;/a&gt;。这两个&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的基础上，&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;标准，遵循通用的公历。需要注意的是，ISO 8601标准是关于BC / BCE日期的。通常，BC / BCE时代的最后一天，BC / BCE 1-12-31，之后是AD / CE 1-1-1，因此不存在零年。但是，ISO标准规定1 BC / BCE为零年，因此 &lt;code&gt;0000-12-31&lt;/code&gt; 是 &lt;code&gt;0001-01-01&lt;/code&gt; 的前一天，而- &lt;code&gt;-0001&lt;/code&gt; （是，年份的负一）为2 BC / BCE。 ，年份 &lt;code&gt;-0002&lt;/code&gt; 为3 BC / BCE，依此类推。</target>
        </trans-unit>
        <trans-unit id="9bd9372ad6716aa533ad19c4f4344f9f861990d8" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bf1ed5d0b3dee373193977f771d3d28aa04eff" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fdot&lt;/code&gt; compute the same thing. However, &lt;code&gt;fdot&lt;/code&gt; (defined with the help of the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) is significantly faster when applied to an array:</source>
          <target state="translated">无论 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;fdot&lt;/code&gt; 计算同样的事情。但是，将 &lt;code&gt;fdot&lt;/code&gt; （在&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt;宏的帮助下定义）应用于数组的速度明显更快：</target>
        </trans-unit>
        <trans-unit id="894facd8272490d18ae36dfbd0aea23dbfd8d0be" translate="yes" xml:space="preserve">
          <source>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; returns true (essentially, things like numbers and bools that are stored like C types or &lt;code&gt;struct&lt;/code&gt;s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</source>
          <target state="translated">抽象类型和具体类型都可以由其他类型进行参数化。它们也可以通过符号，&lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt;返回其真值的任何类型的值（本质上，像数字和布尔值之类的东西，像C类型或 &lt;code&gt;struct&lt;/code&gt; 一样存储，而没有指向其他对象的指针）进行参数化，也可以通过其元组进行参数化。当不需要引用或限制类型参数时，可以将其省略。</target>
        </trans-unit>
        <trans-unit id="63dac16e286415a31cf4c5cfa7d67dab90fd4b82" translate="yes" xml:space="preserve">
          <source>Both concatenation and string interpolation call &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to convert objects into string form. However, &lt;code&gt;string&lt;/code&gt; actually just returns the output of &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, so new types should add methods to &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">串联和字符串插值都调用&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;以将对象转换为字符串形式。但是， &lt;code&gt;string&lt;/code&gt; 实际上只是返回&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;的输出，因此新类型应该添加用于&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;show&lt;/code&gt; 方法，而不是 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="007479614c6ddfc352db8c91872c6cdcf690ee04" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92cf62db18ffc6b16befca5871ba839cf28860c" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">这两个表达式都被解释为函数应用程序：任何非数字文字的表达式，当其后紧跟括号时，都被解释为应用于括号中值的&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;函数&lt;/a&gt;（有关函数的更多信息，请参见函数）。因此，在这两种情况下，由于左侧的值不是函数，因此会发生错误。</target>
        </trans-unit>
        <trans-unit id="fe2f60cb62bba939fc1814f0702994179d2cc9fd" translate="yes" xml:space="preserve">
          <source>Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</source>
          <target state="translated">这两种实现虽然不同,但本质上都是一样的:在数组的维度上进行运行时循环,将每个维度中的偏移量收集到最后的索引中。</target>
        </trans-unit>
        <trans-unit id="9c695a21716f0561a4e4e8d8969c9a67ff3ac14a" translate="yes" xml:space="preserve">
          <source>Bottom Curly Bracket</source>
          <target state="translated">底部卷曲支架</target>
        </trans-unit>
        <trans-unit id="5c381cbda1ed56fa362cad0521e4ca378f6df12d" translate="yes" xml:space="preserve">
          <source>Bottom Left Corner</source>
          <target state="translated">左下角</target>
        </trans-unit>
        <trans-unit id="8b91a1776362601aa94f5e511fc42880fb137818" translate="yes" xml:space="preserve">
          <source>Bottom Right Corner</source>
          <target state="translated">右下角</target>
        </trans-unit>
        <trans-unit id="408cb2c9aacb6c00f4eea9f155e68230edfc13be" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket</source>
          <target state="translated">底部方形托架</target>
        </trans-unit>
        <trans-unit id="b587f4044bf50468cb606a8c8b879cf7bf3a57b0" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket Over Top Square Bracket</source>
          <target state="translated">下方托架上方托架</target>
        </trans-unit>
        <trans-unit id="be63873217899f3efce2481a86c1d5a6e1aa9ff7" translate="yes" xml:space="preserve">
          <source>Bouquet</source>
          <target state="translated">Bouquet</target>
        </trans-unit>
        <trans-unit id="527e7050bb885ff38897eb7cbe0d818d6e05448e" translate="yes" xml:space="preserve">
          <source>Bowling</source>
          <target state="translated">Bowling</target>
        </trans-unit>
        <trans-unit id="df3f8f8f9dfd1bd2fca6e5c445d1a47fa385ede3" translate="yes" xml:space="preserve">
          <source>Bowtie</source>
          <target state="translated">Bowtie</target>
        </trans-unit>
        <trans-unit id="2365940089f0b35468618bed420a02ff8d78ea80" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right</source>
          <target state="translated">盒形图左上角至右下角的浅对角线/左上角至右下角的浅对角线形状。</target>
        </trans-unit>
        <trans-unit id="510ae6748e0c9b114a5f8b83c8badc7f63a16bc0" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left</source>
          <target state="translated">盒状图右上角至左下角的浅对角线/右上角至左下角的浅对角线形状。</target>
        </trans-unit>
        <trans-unit id="12f6d098ab5b7193c3d26b08f696b2a980dca3f4" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical</source>
          <target state="translated">盒型图 轻型三段式竖式/表格 轻型三段式竖式</target>
        </trans-unit>
        <trans-unit id="85230437c79e72b707969ab19fa9c93e520c40d0" translate="yes" xml:space="preserve">
          <source>Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy</source>
          <target state="translated">框图上轻下重/表格上轻下重。</target>
        </trans-unit>
        <trans-unit id="b9dc9d8cb52edb821b0da78df2b6682eb917d791" translate="yes" xml:space="preserve">
          <source>Boy</source>
          <target state="translated">Boy</target>
        </trans-unit>
        <trans-unit id="c61eb5df5d78529f719e752eeef8ece81e0caaa8" translate="yes" xml:space="preserve">
          <source>Bread</source>
          <target state="translated">Bread</target>
        </trans-unit>
        <trans-unit id="67334b607f6cd61759a7703ce073645a7bb380d4" translate="yes" xml:space="preserve">
          <source>Break functions into multiple definitions</source>
          <target state="translated">将函数分解为多个定义</target>
        </trans-unit>
        <trans-unit id="8a10e4a625ea22134f5962dee4da949a99868e13" translate="yes" xml:space="preserve">
          <source>Break out of a loop immediately.</source>
          <target state="translated">立即突破一个循环。</target>
        </trans-unit>
        <trans-unit id="392384778265e06187313603c1377439a8615e6f" translate="yes" xml:space="preserve">
          <source>Break the &lt;code&gt;ConfigEntry&lt;/code&gt; up to the following pieces: section, subsection, name, and value.</source>
          <target state="translated">将 &lt;code&gt;ConfigEntry&lt;/code&gt; 分为以下几部分：节，小节，名称和值。</target>
        </trans-unit>
        <trans-unit id="7632e2c1e249278468e77e6447234ae7607c5253" translate="yes" xml:space="preserve">
          <source>Breve / Spacing Breve</source>
          <target state="translated">布雷夫/间距 布雷夫</target>
        </trans-unit>
        <trans-unit id="daaf045cb7109dd158210ed8775987a60503bbb6" translate="yes" xml:space="preserve">
          <source>Bride With Veil</source>
          <target state="translated">新娘与面纱</target>
        </trans-unit>
        <trans-unit id="4e7371d09f6498019117c2fcbb67ffe9a940c17f" translate="yes" xml:space="preserve">
          <source>Bridge At Night</source>
          <target state="translated">桥在夜间</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">简要说明</target>
        </trans-unit>
        <trans-unit id="b11bca2ce38ace33f9cb3a0f0323440cce89dd0f" translate="yes" xml:space="preserve">
          <source>Briefcase</source>
          <target state="translated">Briefcase</target>
        </trans-unit>
        <trans-unit id="77ca3fc6500edac54d325df1bbb7ac8e363c54b5" translate="yes" xml:space="preserve">
          <source>Broadcast</source>
          <target state="translated">Broadcast</target>
        </trans-unit>
        <trans-unit id="5959941fc9ce31c144990539361b6855d239f922" translate="yes" xml:space="preserve">
          <source>Broadcast Styles</source>
          <target state="translated">广播风格</target>
        </trans-unit>
        <trans-unit id="cdaa679362eaad18a4a290d4b2177d1c9eddf091" translate="yes" xml:space="preserve">
          <source>Broadcast and vectorization</source>
          <target state="translated">广播和矢量化</target>
        </trans-unit>
        <trans-unit id="7df7947bfeebee1e64e3a5fe7acfcbaa176cd869" translate="yes" xml:space="preserve">
          <source>Broadcast the function &lt;code&gt;f&lt;/code&gt; over the arrays, tuples, collections, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt;s and/or scalars &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">在数组，元组，集合，&lt;a href=&quot;../c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt;和/或标量 &lt;code&gt;As&lt;/code&gt; 上广播函数 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="074efe61b6453184efecedf79f56223cb3b56a06" translate="yes" xml:space="preserve">
          <source>Broadcast.@__dot__</source>
          <target state="translated">Broadcast.@__dot__</target>
        </trans-unit>
        <trans-unit id="d9974c014c3e7a0c286c1e54c44afebb2e5a2605" translate="yes" xml:space="preserve">
          <source>Broadcast.AbstractArrayStyle</source>
          <target state="translated">Broadcast.AbstractArrayStyle</target>
        </trans-unit>
        <trans-unit id="e479e2fec9cd8edd73518e3aa9d740af4ffed128" translate="yes" xml:space="preserve">
          <source>Broadcast.ArrayStyle</source>
          <target state="translated">Broadcast.ArrayStyle</target>
        </trans-unit>
        <trans-unit id="46b115d26f9c6f955c31e3892d4b89859d8782ab" translate="yes" xml:space="preserve">
          <source>Broadcast.BroadcastStyle</source>
          <target state="translated">Broadcast.BroadcastStyle</target>
        </trans-unit>
        <trans-unit id="dfd372b601ba77b3813f2634bb5fb9643c14c102" translate="yes" xml:space="preserve">
          <source>Broadcast.DefaultArrayStyle</source>
          <target state="translated">Broadcast.DefaultArrayStyle</target>
        </trans-unit>
        <trans-unit id="6969d3cd7b2ed2ce0f9a60fb4945dade93d4e117" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast!()</source>
          <target state="translated">Broadcast.broadcast!()</target>
        </trans-unit>
        <trans-unit id="2d33589d08eead5af3fe72a94a8b53b3373f4645" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast()</source>
          <target state="translated">Broadcast.broadcast()</target>
        </trans-unit>
        <trans-unit id="d8be6debc5bb7fb35ee9eb11d215775cae452707" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcastable()</source>
          <target state="translated">Broadcast.broadcastable()</target>
        </trans-unit>
        <trans-unit id="48464259628c114acb1957dc941186fb95dc6984" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_axes()</source>
          <target state="translated">Broadcast.combine_axes()</target>
        </trans-unit>
        <trans-unit id="65a7f7386144353a37453858bdd5ecb6ccb1274f" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_styles()</source>
          <target state="translated">Broadcast.combine_styles()</target>
        </trans-unit>
        <trans-unit id="d36a0668f40c2a01499f97eb697585c01ce9b9ab" translate="yes" xml:space="preserve">
          <source>Broadcast.result_style()</source>
          <target state="translated">Broadcast.result_style()</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="0e83693fd8be7602fb86ef05c34ce5d03fd5fce4" translate="yes" xml:space="preserve">
          <source>Broadcasting applies the function &lt;code&gt;f&lt;/code&gt; over the elements of the container arguments and the scalars themselves in &lt;code&gt;As&lt;/code&gt;. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">广播将函数 &lt;code&gt;f&lt;/code&gt; 应用于容器参数的元素以及 &lt;code&gt;As&lt;/code&gt; 中的标量本身。通过虚拟地重复该值，可以扩展单例和缺失维以匹配其他参数的范围。默认情况下，仅将有限数量的类型视为标量，包括 &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ， &lt;code&gt;Type&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 以及一些常见的单例，如&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;。所有其他参数在元素上进行迭代或索引。</target>
        </trans-unit>
        <trans-unit id="7b246945f4825122c3abc36d497da5fe651d872b" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior of &lt;code&gt;SrcType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SrcType&lt;/code&gt; 的广播行为</target>
        </trans-unit>
        <trans-unit id="0e2fa4ca8541a569a98cefd4832f00fffb8a668a" translate="yes" xml:space="preserve">
          <source>Broadcasting of CartesianIndices requires at least Julia 1.1.</source>
          <target state="translated">广播CartesianIndices至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="de4b71257ec056201227e217cf933d2e092cf0c7" translate="yes" xml:space="preserve">
          <source>Broken Bar / Broken Vertical Bar</source>
          <target state="translated">断杆/垂直断杆</target>
        </trans-unit>
        <trans-unit id="0d35795616ab98cd5aa59673de45c7c6c73a4a9c" translate="yes" xml:space="preserve">
          <source>Broken Heart</source>
          <target state="translated">破碎的心</target>
        </trans-unit>
        <trans-unit id="79b7916b0d6bd1fa29180da64a852f6051cdd3b6" translate="yes" xml:space="preserve">
          <source>Broken Tests</source>
          <target state="translated">破碎的测试</target>
        </trans-unit>
        <trans-unit id="8cb75fd2f909d7fe2d9ebdd702d582785b35815a" translate="yes" xml:space="preserve">
          <source>Browser-based workflow</source>
          <target state="translated">基于浏览器的工作流程</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="a0ff1503de64d75563fdaa852cd66a5161072182" translate="yes" xml:space="preserve">
          <source>Build the output matrix as &lt;code&gt;similar(R, dims)&lt;/code&gt;, where &lt;code&gt;dims&lt;/code&gt; are the desired dimensions of the output array.</source>
          <target state="translated">将输出矩阵构建为 &lt;code&gt;similar(R, dims)&lt;/code&gt; ，其中 &lt;code&gt;dims&lt;/code&gt; 是输出数组的所需尺寸。</target>
        </trans-unit>
        <trans-unit id="9b68712d139bce25a7399715ee37cf5a89ca4787" translate="yes" xml:space="preserve">
          <source>Building a similar type with a different type parameter</source>
          <target state="translated">用不同的类型参数构建类似的类型</target>
        </trans-unit>
        <trans-unit id="472631cf7902fb6cb7b3cc2952c6a64c270752fa" translate="yes" xml:space="preserve">
          <source>Building an advanced macro</source>
          <target state="translated">建立一个先进的宏</target>
        </trans-unit>
        <trans-unit id="fe79fc1370416c81e94ca362477853ed355de172" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;Exception&lt;/code&gt;s</source>
          <target state="translated">内置 &lt;code&gt;Exception&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="b98da0ccc81f4f734434572f19ccc66972aae344" translate="yes" xml:space="preserve">
          <source>Bullet</source>
          <target state="translated">Bullet</target>
        </trans-unit>
        <trans-unit id="b2e3c9a189a187c73db37aa7676051a963459c1a" translate="yes" xml:space="preserve">
          <source>Bullet Operator</source>
          <target state="translated">子弹操作员</target>
        </trans-unit>
        <trans-unit id="ffb3a635db82436b5aade99cffc92370f3f7ed19" translate="yes" xml:space="preserve">
          <source>Bullseye</source>
          <target state="translated">Bullseye</target>
        </trans-unit>
        <trans-unit id="6380df8107fb2d9626efb1aee5cb211de2982cbd" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman (see &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Bunch-Kaufman（请参阅&lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d42c62a3c53679a83b69d0fce6f99bfd41a308aa" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman factorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56070a568367d5a4e9970cfff19cb97578ce1361" translate="yes" xml:space="preserve">
          <source>Bus</source>
          <target state="translated">Bus</target>
        </trans-unit>
        <trans-unit id="de2d017d398674ca4eafe20ca3761f2f657234b8" translate="yes" xml:space="preserve">
          <source>Bus Stop</source>
          <target state="translated">巴士站</target>
        </trans-unit>
        <trans-unit id="97d53e844a4148a55c4152e5e7736932ca111090" translate="yes" xml:space="preserve">
          <source>Bust In Silhouette</source>
          <target state="translated">半身像剪影</target>
        </trans-unit>
        <trans-unit id="45f0d298267aa05679aedb20cf6611cfa3d2a5d1" translate="yes" xml:space="preserve">
          <source>Busts In Silhouette</source>
          <target state="translated">半身像剪影</target>
        </trans-unit>
        <trans-unit id="e7a7510504bc122560ba5c8208e379522ff06902" translate="yes" xml:space="preserve">
          <source>But here is a thing you should pay attention to: suppose &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you can change its content. For example:</source>
          <target state="translated">但是这是您要注意的事情：假设 &lt;code&gt;x&lt;/code&gt; 绑定到 &lt;code&gt;Array&lt;/code&gt; 类型的对象（或任何其他&lt;em&gt;可变&lt;/em&gt;类型）。从函数内部，您不能从该数组中&amp;ldquo;解除绑定&amp;rdquo; &lt;code&gt;x&lt;/code&gt; ，但是可以更改其内容。例如：</target>
        </trans-unit>
        <trans-unit id="0adf28177ba73d224bb6721567052c88af510023" translate="yes" xml:space="preserve">
          <source>But how does one construct the first instance when no instance exists to provide as a valid value for its &lt;code&gt;obj&lt;/code&gt; field? The only solution is to allow creating an incompletely initialized instance of &lt;code&gt;SelfReferential&lt;/code&gt; with an unassigned &lt;code&gt;obj&lt;/code&gt; field, and using that incomplete instance as a valid value for the &lt;code&gt;obj&lt;/code&gt; field of another instance, such as, for example, itself.</source>
          <target state="translated">但是，当没有实例作为其 &lt;code&gt;obj&lt;/code&gt; 字段的有效值提供时，如何构造第一个实例？唯一的解决方案是允许使用未分配的 &lt;code&gt;obj&lt;/code&gt; 字段创建未完全初始化的 &lt;code&gt;SelfReferential&lt;/code&gt; 实例，并将该不完整的实例用作另一个实例（例如本身）的 &lt;code&gt;obj&lt;/code&gt; 字段的有效值。</target>
        </trans-unit>
        <trans-unit id="64b3ab17aa40196bbbe2b14cd1e8633f165597c6" translate="yes" xml:space="preserve">
          <source>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well &amp;ndash; assuming GNU make because of the use of the &lt;strong&gt;shell&lt;/strong&gt; macro expansions. Additionally, though many times &lt;code&gt;julia-config.jl&lt;/code&gt; may be found in the directory &lt;code&gt;/usr/local&lt;/code&gt;, this is not necessarily the case, but Julia can be used to locate &lt;code&gt;julia-config.jl&lt;/code&gt; too, and the makefile can be used to take advantage of that. The above example is extended to use a Makefile:</source>
          <target state="translated">但是总的来说，嵌入项目会比上面更复杂，因此以下内容也允许常规的makefile支持-假定由于使用&lt;strong&gt;shell&lt;/strong&gt;宏扩展而使GNU make 。此外，尽管可以在目录 &lt;code&gt;/usr/local&lt;/code&gt; 中找到 &lt;code&gt;julia-config.jl&lt;/code&gt; 很多次，但情况并非一定如此，但是Julia也可以用于查找 &lt;code&gt;julia-config.jl&lt;/code&gt; ，并且可以使用makefile来获取的优势。上面的示例已扩展为使用Makefile：</target>
        </trans-unit>
        <trans-unit id="26a3e909feee0f8ba5a7fedacb473c7c1f12eb3d" translate="yes" xml:space="preserve">
          <source>But now let's say you want to write a function that creates a 3&amp;times;3&amp;times;... array in arbitrary dimensions; you might be tempted to write a function</source>
          <target state="translated">但是，现在让我们说您想编写一个函数，该函数可以创建任意尺寸的3&amp;times;3&amp;times;...数组；您可能会想编写一个函数</target>
        </trans-unit>
        <trans-unit id="7e347dfe55eb3d3f84185c35ba67fdd467b54efe" translate="yes" xml:space="preserve">
          <source>But there's an exception: future calls to &lt;code&gt;newfun&lt;/code&gt;&lt;em&gt;from the REPL&lt;/em&gt; work as expected, being able to both see and call the new definition of &lt;code&gt;newfun&lt;/code&gt;.</source>
          <target state="translated">但是有一个例外：&lt;em&gt;REPL&lt;/em&gt;将来对 &lt;code&gt;newfun&lt;/code&gt; 的调用将按预期工作，并且能够看到并调用 &lt;code&gt;newfun&lt;/code&gt; 的新定义。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7dcbe9aaf1e0a6755fccfa933b76845ffa848937" translate="yes" xml:space="preserve">
          <source>But we are currently on the master thread. To check, we use the function &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt;&lt;code&gt;Threads.threadid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">但是我们目前在主线程上。要检查，我们使用函数&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt; &lt;code&gt;Threads.threadid&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c84f932b434e9c92f4f20cc3eb7ea04021d4d339" translate="yes" xml:space="preserve">
          <source>By convention, function names ending with an exclamation point (&lt;code&gt;!&lt;/code&gt;) modify their arguments. Some functions have both modifying (e.g., &lt;code&gt;sort!&lt;/code&gt;) and non-modifying (&lt;code&gt;sort&lt;/code&gt;) versions.</source>
          <target state="translated">按照约定，以惊叹号（ &lt;code&gt;!&lt;/code&gt; ）结尾的函数名称会修改其参数。一些功能同时具有修改（例如 &lt;code&gt;sort!&lt;/code&gt; ）和非修改（ &lt;code&gt;sort&lt;/code&gt; ）版本。</target>
        </trans-unit>
        <trans-unit id="b2d3b6d57737895d1e4453b18b72e5f94ecdeb4e" translate="yes" xml:space="preserve">
          <source>By convention, functions that modify their arguments have a &lt;code&gt;!&lt;/code&gt; at the end of the name, for example &lt;code&gt;push!&lt;/code&gt;.</source>
          <target state="translated">按照约定，修改其参数的函数带有 &lt;code&gt;!&lt;/code&gt; 在名称末尾，例如 &lt;code&gt;push!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab2ce248423f04c77b0bad395e4714e39c7fb937" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(itr)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760f93efed44d4a2ba0963c541f9ed0ec06bfb96" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(v)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a501bd6222e05849ace3fea85fb677e79bd185" translate="yes" xml:space="preserve">
          <source>By default a worker will listen on a free port at the address returned by a call to &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt;&lt;code&gt;getipaddr()&lt;/code&gt;&lt;/a&gt;. A specific address to listen on may be specified by optional argument &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt;. This is useful for multi-homed hosts.</source>
          <target state="translated">默认情况下，工作&lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt; &lt;code&gt;getipaddr()&lt;/code&gt; &lt;/a&gt;将在空闲端口上侦听对getipaddr（）的调用返回的地址。可以通过可选参数 &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt; 指定要监听的特定地址。这对于多宿主主机很有用。</target>
        </trans-unit>
        <trans-unit id="cb670232f9c9a08075052bf52fba2ffbf6b303ba" translate="yes" xml:space="preserve">
          <source>By default all exceptions are caught to prevent log message generation from crashing the program. This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</source>
          <target state="translated">默认情况下,所有的异常都会被捕获,以防止日志消息的生成导致程序崩溃。这让用户可以放心地在生产系统中切换很少使用的功能--比如调试日志。</target>
        </trans-unit>
        <trans-unit id="3274665bf281763d801f2b3f0f09acc363497f47" translate="yes" xml:space="preserve">
          <source>By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set &lt;code&gt;wait=true&lt;/code&gt; and julia will wait for the editor to close before resuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09501703ac8c23ae9a60cea7e5421daf3cd18b0" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;@testset&lt;/code&gt; macro will return the testset object itself, though this behavior can be customized in other testset types. If a &lt;code&gt;for&lt;/code&gt; loop is used then the macro collects and returns a list of the return values of the &lt;code&gt;finish&lt;/code&gt; method, which by default will return a list of the testset objects used in each iteration.</source>
          <target state="translated">默认情况下， &lt;code&gt;@testset&lt;/code&gt; 宏将返回测试集对象本身，尽管可以在其他测试集类型中自定义此行为。如果使用 &lt;code&gt;for&lt;/code&gt; 循环，则宏将收集并返回 &lt;code&gt;finish&lt;/code&gt; 方法的返回值列表，默认情况下，该方法将返回每次迭代中使用的testset对象的列表。</target>
        </trans-unit>
        <trans-unit id="62c321cdf328de0b934c0ed64ba600400a916f6d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pmap&lt;/code&gt; distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify &lt;code&gt;distributed=false&lt;/code&gt;. This is equivalent to using &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; is equivalent to &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</source>
          <target state="translated">默认情况下， &lt;code&gt;pmap&lt;/code&gt; 将计算分布在所有指定的工作程序上。要仅使用本地进程并通过任务进行 &lt;code&gt;distributed=false&lt;/code&gt; ，请指定distributed = false。这等效于使用&lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;。例如， &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; 等效于 &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="869bf1d13613c15994bb6c5a2998c89afa6bc5e7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;readdir&lt;/code&gt; sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use &lt;code&gt;readir(dir, sort=false)&lt;/code&gt; to opt out of sorting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f89fa8608376528e1d0c826b9825a253fbd041b" translate="yes" xml:space="preserve">
          <source>By default, Fortran compilers &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;generate mangled names&lt;/a&gt; (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</source>
          <target state="translated">默认情况下，Fortran编译器会&lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;生成错误的名称&lt;/a&gt;（例如，将函数名称转换为小写或大写，通常会附加下划线），因此要通过&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;调用Fortran函数，您必须传递与规则相对应的错误标识符，然后再执行Fortran编译器。同样，在调用Fortran函数时，所有输入都必须作为指向堆或堆栈上已分配值的指针传递。这不仅适用于通常是堆分配的数组和其他可变对象，而且还适用于标量值，例如整数和浮点数，它们通常是堆栈分配的，并且在使用C或Julia调用约定时通常在寄存器中传递。</target>
        </trans-unit>
        <trans-unit id="7b4db9ff202a42835afe09d8709e3f5d83b19913" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97954da2a37348f9b604be87e49342f9bb3f535a" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，Julia 从&lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;广播&lt;/a&gt;操作返回 &lt;code&gt;BitArrays&lt;/code&gt; ，该操作会生成布尔元素（包括 &lt;code&gt;.==&lt;/code&gt; 等点分比较）以及&lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="b61e736cef16f73d649bec40a1cb5e23234e0fb3" translate="yes" xml:space="preserve">
          <source>By default, Julia starts up with a single thread of execution. This can be verified by using the command &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt;&lt;code&gt;Threads.nthreads()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">默认情况下，Julia以一个执行线程启动。这可以通过使用&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt; &lt;code&gt;Threads.nthreads()&lt;/code&gt; &lt;/a&gt;命令来验证：</target>
        </trans-unit>
        <trans-unit id="a32e1e323d14dc3db4577d3f3c64972051fa6f1a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;redisplay&lt;/code&gt; functions simply call &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt;. However, some display backends may override &lt;code&gt;redisplay&lt;/code&gt; to modify an existing display of &lt;code&gt;x&lt;/code&gt; (if any). Using &lt;code&gt;redisplay&lt;/code&gt; is also a hint to the backend that &lt;code&gt;x&lt;/code&gt; may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</source>
          <target state="translated">默认情况下， &lt;code&gt;redisplay&lt;/code&gt; 功能仅调用&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt;。但是，某些显示后端可能会覆盖 &lt;code&gt;redisplay&lt;/code&gt; 以修改 &lt;code&gt;x&lt;/code&gt; 的现有显示（如果有）。使用 &lt;code&gt;redisplay&lt;/code&gt; 还向后端暗示 &lt;code&gt;x&lt;/code&gt; 可能会多次显示，并且后端可以选择将显示推迟到（例如）下一个交互式提示。</target>
        </trans-unit>
        <trans-unit id="3a789ab7e78cdd1c9fcc76d1aa6c29cc8860d633" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2434a57ba6bd0a71b3ac08a278b454d4192e915f" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;code&gt;Diagonal&lt;/code&gt; or &lt;code&gt;SymTridiagonal&lt;/code&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">默认情况下，特征值和向量通过 &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; 在字典上排序。可以将不同的比较函数 &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; 传递给 &lt;code&gt;sortby&lt;/code&gt; ，也可以传递 &lt;code&gt;sortby=nothing&lt;/code&gt; 以使特征值以任意顺序保留。一些特殊的矩阵类型（例如 &lt;code&gt;Diagonal&lt;/code&gt; 或 &lt;code&gt;SymTridiagonal&lt;/code&gt; ）可能实现自己的排序约定，并且不接受 &lt;code&gt;sortby&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="2a1522d8655f0697d6a68319f9a29fb0897d5118" translate="yes" xml:space="preserve">
          <source>By default, the relative tolerance &lt;code&gt;rtol&lt;/code&gt; is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">默认情况下，相对公差 &lt;code&gt;rtol&lt;/code&gt; 为 &lt;code&gt;n*ϵ&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;M&lt;/code&gt; 的最小尺寸的大小， &lt;code&gt;ϵ&lt;/code&gt; 是 &lt;code&gt;M&lt;/code&gt; 的元素类型的&lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36562c471751aaedc6db712652b89541573e3bb4" translate="yes" xml:space="preserve">
          <source>By extension any odd number of backticks may be used to enclose a lesser number of backticks.</source>
          <target state="translated">推而广之,任何奇数的背标都可以用来包围较少的背标。</target>
        </trans-unit>
        <trans-unit id="300c0d12698af77dc8e2c084d058d532e1315b6c" translate="yes" xml:space="preserve">
          <source>By printing the array, one can verify that the elements of &lt;code&gt;x&lt;/code&gt; are now reversed.</source>
          <target state="translated">通过打印数组，可以验证 &lt;code&gt;x&lt;/code&gt; 的元素现在是否反转了。</target>
        </trans-unit>
        <trans-unit id="760e88f232085bdc1aa9ba910e6eb19bee1e689b" translate="yes" xml:space="preserve">
          <source>By running &quot;infrequently&quot; there is very little performance overhead; while profiling, your code can run at nearly native speed.</source>
          <target state="translated">通过 &quot;不频繁运行&quot;,几乎没有什么性能开销;而剖析时,你的代码可以以接近原生的速度运行。</target>
        </trans-unit>
        <trans-unit id="95b6f4faddfdd9853ff8e907fd6f47265a9f07a0" translate="yes" xml:space="preserve">
          <source>By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times. However, a minor release of Julia (e.g. 1.3 to 1.4) &lt;em&gt;may change&lt;/em&gt; the sequence of pseudorandom numbers generated from a specific seed. (Even if the sequence produced by a low-level function like &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; does not change, the output of higher-level functions like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt; may change due to algorithm updates.) Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24780bfad6073c3cb5039801b32f126d34c1cde" translate="yes" xml:space="preserve">
          <source>Byte Array Literals</source>
          <target state="translated">字节阵列文字</target>
        </trans-unit>
        <trans-unit id="c950fe9e51a4a280dd4bb58c0d0951450fe7bbf3" translate="yes" xml:space="preserve">
          <source>C &lt;strong&gt;MUST NOT&lt;/strong&gt; modify the memory returned via &lt;code&gt;Ref{T}&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;isbits&lt;/code&gt; type</source>
          <target state="translated">&amp;Ccedil; &lt;strong&gt;必须不&lt;/strong&gt;修改经由返回的存储器 &lt;code&gt;Ref{T}&lt;/code&gt; 如果 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;isbits&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="a10776e7bb2378d8306c9c38209f9a25bdd03a13" translate="yes" xml:space="preserve">
          <source>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi:10.1137/0908009&lt;/a&gt;</source>
          <target state="translated">C Bischof和C Van Loan，&amp;ldquo; Householders矩阵的产品的WY表示形式&amp;rdquo;，SIAM J Sci Stat Comput 8（1987），s2-s13。&lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi：10.1137 / 0908009&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C接口</target>
        </trans-unit>
        <trans-unit id="6592ddb6b4a1a593e3571fb32f8e7a37a9f3a350" translate="yes" xml:space="preserve">
          <source>C Standard Library</source>
          <target state="translated">C标准库</target>
        </trans-unit>
        <trans-unit id="3a8599236e86a8cb6d00c7c55845e656c7c05673" translate="yes" xml:space="preserve">
          <source>C Wrapper Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e127f5f8d00244c8e1c9f0ff88de5ec4ac1783" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;credentials_callback&lt;/code&gt;</source>
          <target state="translated">对于C函数指针 &lt;code&gt;credentials_callback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c33ee7fd9016392ef47ce064a1a8200fb287dc56" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetchhead_foreach_callback&lt;/code&gt; 的 C函数指针</target>
        </trans-unit>
        <trans-unit id="bf80fd7e58e3463df2196d9d8b7daa3fb24795de" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;mirror_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mirror_callback&lt;/code&gt; 的 C函数指针</target>
        </trans-unit>
        <trans-unit id="5cb63f576281637ef8721a44852ed39bd47bda3e" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of the type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">可以通过在Julia中使用 &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; 类型来调用采用 &lt;code&gt;char**&lt;/code&gt; 类型参数的C函数。例如，C函数的形式为：</target>
        </trans-unit>
        <trans-unit id="eb931938945d732d0cc3c0bc381f1e2e03fc8a86" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272eaa6fb30cbc6d678d9c3342e07f66e1c123e0" translate="yes" xml:space="preserve">
          <source>C name</source>
          <target state="translated">C名称</target>
        </trans-unit>
        <trans-unit id="315194526a16e46e96fc7a6c9fe2f734e368a015" translate="yes" xml:space="preserve">
          <source>C shell on Linux/macOS, CMD on Windows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="7877de4c10096f42fa8b542b38a0c8abfeff2993" translate="yes" xml:space="preserve">
          <source>CFunction</source>
          <target state="translated">CFunction</target>
        </trans-unit>
        <trans-unit id="d6deb7587f97d7c2e002671a4a7ec9c17092aa98" translate="yes" xml:space="preserve">
          <source>CRC32c</source>
          <target state="translated">CRC32c</target>
        </trans-unit>
        <trans-unit id="946e46ea933373d5acfe718ba4c46ff0c631d8da" translate="yes" xml:space="preserve">
          <source>C_NULL</source>
          <target state="translated">C_NULL</target>
        </trans-unit>
        <trans-unit id="062c01810c7f050347900909c2a5c905fb7f6b61" translate="yes" xml:space="preserve">
          <source>Caches credential information for re-use</source>
          <target state="translated">缓存凭证信息以便重复使用</target>
        </trans-unit>
        <trans-unit id="9f296c645c05d20e8d397ba3c6535ccc69ae356d" translate="yes" xml:space="preserve">
          <source>Caching of native pointers.</source>
          <target state="translated">缓存本地指针。</target>
        </trans-unit>
        <trans-unit id="ffbcb973995142c82bf466dc886625f88d2fbcf8" translate="yes" xml:space="preserve">
          <source>Cactus</source>
          <target state="translated">Cactus</target>
        </trans-unit>
        <trans-unit id="ac32f232b7ff982020ec20b1d05cbfe41644842d" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result.</source>
          <target state="translated">计算矩阵矩阵乘积$ AB $，覆盖 &lt;code&gt;A&lt;/code&gt; ，然后返回结果。</target>
        </trans-unit>
        <trans-unit id="129c66daa23d40a052d78c17325451f781f1cd27" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result. Here, &lt;code&gt;B&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d41dc1e33975c5f259e3c41e3a555f7d4e2007c" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result.</source>
          <target state="translated">计算矩阵矩阵乘积$ AB $，覆盖 &lt;code&gt;B&lt;/code&gt; ，然后返回结果。</target>
        </trans-unit>
        <trans-unit id="f409cbcda5b59decdd240fd1a21ee0be89005565" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result. Here, &lt;code&gt;A&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c95fa1680ff9d2f9d27d1192e3762d37dafb02b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;-x&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;-typemin(Int)&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">计算 &lt;code&gt;-x&lt;/code&gt; ，在适用的情况下检查溢出错误。例如，标准二进制的补码有符号整数（例如 &lt;code&gt;Int&lt;/code&gt; ）不能表示 &lt;code&gt;-typemin(Int)&lt;/code&gt; ，从而导致溢出。</target>
        </trans-unit>
        <trans-unit id="6167c036f7bc22425fe096ac27be440fe0ac62c7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;abs(x)&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;abs(typemin(Int))&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">计算 &lt;code&gt;abs(x)&lt;/code&gt; ，在适用的情况下检查溢出错误。例如，标准二进制的补码有符号整数（例如 &lt;code&gt;Int&lt;/code&gt; ）不能表示 &lt;code&gt;abs(typemin(Int))&lt;/code&gt; ，从而导致溢出。</target>
        </trans-unit>
        <trans-unit id="28790cf90cf177147936302a9d1094b853b086f9" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;cld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;cld(x,y)&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="4c05dcdfe5d48ed5364bba76a8d88216a7900800" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;div(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;div(x,y)&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="a3d2d9753cdcfd6dd922be36bbcacaaf32453196" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;fld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;fld(x,y)&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="2c843612cbe327e35009726e8d036ba9b466e318" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;mod(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;mod(x,y)&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="3ff6965bc32424b3a4e9ae967a2b78b31c8687be" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x*y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">计算 &lt;code&gt;r = x*y&lt;/code&gt; ，其中标志 &lt;code&gt;f&lt;/code&gt; 指示是否发生了溢出。</target>
        </trans-unit>
        <trans-unit id="31af4e89c705ea1b47696c4b34bfb97a778c9f15" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x+y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">计算 &lt;code&gt;r = x+y&lt;/code&gt; ，其中标志 &lt;code&gt;f&lt;/code&gt; 指示是否发生了溢出。</target>
        </trans-unit>
        <trans-unit id="fd998eb3f6f3e0335eab6ff45b9ad97358dd0ca0" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x-y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">计算 &lt;code&gt;r = x-y&lt;/code&gt; ，并使用标志 &lt;code&gt;f&lt;/code&gt; 指示是否发生了溢出。</target>
        </trans-unit>
        <trans-unit id="efdf3f45f374c38b59fd728eaad712d7890f84ff" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x%y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;x%y&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="08676bba541f171d54d453c583476f048c4309ad" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x*y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;x*y&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="dd10e9d48c83e327a775e0dc3fbaa5b8a6d8c773" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x+y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;x+y&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="7bc22057d7126532dbb6ba4068b470e14e78325a" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x-y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">计算 &lt;code&gt;x-y&lt;/code&gt; ，在适用的情况下检查溢出错误。</target>
        </trans-unit>
        <trans-unit id="aba6566e0673d1e53c249760fa025027d921398e" translate="yes" xml:space="preserve">
          <source>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in &lt;code&gt;Y&lt;/code&gt;, overwriting the existing value of &lt;code&gt;Y&lt;/code&gt;. Note that &lt;code&gt;Y&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">计算矩阵中的矩阵或矩阵矢量乘积$ AB $并将结果存储 &lt;code&gt;Y&lt;/code&gt; ，覆盖的现有值 &lt;code&gt;Y&lt;/code&gt; 。需要注意的是 &lt;code&gt;Y&lt;/code&gt; 不得与任何的别名 &lt;code&gt;A&lt;/code&gt; 或 &lt;code&gt;B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="4ba307e0d2e402f172b3a88156165205934537c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;calloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">从C标准库调用 &lt;code&gt;calloc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56834381560a3dd99cb2329bb238ba01df160757" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;a href=&quot;#Base.Libc.malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, not on pointers retrieved from other C libraries. &lt;a href=&quot;../c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd40525129514b0914afc63feb30f354e65a4d9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;code&gt;malloc&lt;/code&gt;, not on pointers retrieved from other C libraries. &lt;code&gt;Ptr&lt;/code&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">从C标准库 &lt;code&gt;free&lt;/code&gt; 调用。仅在从 &lt;code&gt;malloc&lt;/code&gt; 获得的内存上使用它，而不在从其他C库获取的指针上使用。从C库获得的 &lt;code&gt;Ptr&lt;/code&gt; 对象应通过该库中定义的自由函数释放，以避免在系统上存在多个 &lt;code&gt;libc&lt;/code&gt; 库时断言失败的情况。</target>
        </trans-unit>
        <trans-unit id="9203b7a42060148350d2e8b3d4cff8d77d5adeaf" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;malloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">从C标准库调用 &lt;code&gt;malloc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d59c9f90d0e1176d4cad8b98ecd8773005b655fb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;realloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">从C标准库调用 &lt;code&gt;realloc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04826291b163107f55d0704047219ec8c7242923" translate="yes" xml:space="preserve">
          <source>Call C functions directly (no wrappers or special APIs needed)</source>
          <target state="translated">直接调用C函数(不需要封装器或特殊API)</target>
        </trans-unit>
        <trans-unit id="176405e1dde8747bb226b06f36937d8d5df0ebaf" translate="yes" xml:space="preserve">
          <source>Call LLVM IR string in the first argument. Similar to an LLVM function &lt;code&gt;define&lt;/code&gt; block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</source>
          <target state="translated">在第一个参数中调用LLVM IR字符串。与LLVM函数 &lt;code&gt;define&lt;/code&gt; 块类似，自变量可用作连续的未命名SSA变量（％0，％1等）。</target>
        </trans-unit>
        <trans-unit id="801735440ba4554b8dcf3670b61d4a15d05b05d1" translate="yes" xml:space="preserve">
          <source>Call a function &lt;code&gt;f&lt;/code&gt; asynchronously on the given arguments on the specified process. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">在指定进程的给定参数上异步调用函数 &lt;code&gt;f&lt;/code&gt; 。回报&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;。关键字参数（如果有）将传递给 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e66b49e037c9bfd84faa519573d27e88a8767628" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by &lt;code&gt;library.function_name&lt;/code&gt;, where &lt;code&gt;library&lt;/code&gt; is a string constant or literal. The library may be omitted, in which case the &lt;code&gt;function_name&lt;/code&gt; is resolved in the current process. Alternatively, &lt;code&gt;@ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;$function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a025fbe4a998cb1c2319eebb3e04b735a78fa3" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by the tuple &lt;code&gt;(function_name, library)&lt;/code&gt;, where each component is either a string or symbol. Instead of specifying a library, one can also use a &lt;code&gt;function_name&lt;/code&gt; symbol or string, which is resolved in the current process. Alternatively, &lt;code&gt;ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">在元组 &lt;code&gt;(function_name, library)&lt;/code&gt; 指定的C导出共享库中调用函数，其中每个组件都是字符串或符号。除了指定库外，还可以使用 &lt;code&gt;function_name&lt;/code&gt; 符号或字符串，该符号或字符串在当前进程中已解析。或者， &lt;code&gt;ccall&lt;/code&gt; 也可以用来调用函数指针 &lt;code&gt;function_pointer&lt;/code&gt; ，例如 &lt;code&gt;dlsym&lt;/code&gt; 返回的指针。</target>
        </trans-unit>
        <trans-unit id="d59f24dd0afcb729960eb267538b17e7042fcc85" translate="yes" xml:space="preserve">
          <source>Call function &lt;code&gt;f&lt;/code&gt; on each element of iterable &lt;code&gt;c&lt;/code&gt;. For multiple iterable arguments, &lt;code&gt;f&lt;/code&gt; is called elementwise. &lt;code&gt;foreach&lt;/code&gt; should be used instead of &lt;code&gt;map&lt;/code&gt; when the results of &lt;code&gt;f&lt;/code&gt; are not needed, for example in &lt;code&gt;foreach(println, array)&lt;/code&gt;.</source>
          <target state="translated">在可迭代 &lt;code&gt;c&lt;/code&gt; 的每个元素上调用函数 &lt;code&gt;f&lt;/code&gt; 。对于多个可迭代的参数，将 &lt;code&gt;f&lt;/code&gt; 按元素方式调用。当不需要 &lt;code&gt;f&lt;/code&gt; 的结果时，例如在 &lt;code&gt;foreach(println, array)&lt;/code&gt; 应使用 &lt;code&gt;foreach&lt;/code&gt; 而不是 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebb83c3d13bcfdfda803f0b35d77b6d7243cd9fe" translate="yes" xml:space="preserve">
          <source>Call the Win32 &lt;code&gt;GetLastError&lt;/code&gt; function [only available on Windows].</source>
          <target state="translated">调用Win32 &lt;code&gt;GetLastError&lt;/code&gt; 函数[仅在Windows上可用]。</target>
        </trans-unit>
        <trans-unit id="ce4eab5c7f440edfe5b683c8baa8b023cc553366" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;body&lt;/code&gt; with a modified task-local storage, in which &lt;code&gt;value&lt;/code&gt; is assigned to &lt;code&gt;key&lt;/code&gt;; the previous value of &lt;code&gt;key&lt;/code&gt;, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</source>
          <target state="translated">使用修改后的任务本地存储来调用函数 &lt;code&gt;body&lt;/code&gt; ，其中将 &lt;code&gt;value&lt;/code&gt; 分配给 &lt;code&gt;key&lt;/code&gt; ； &lt;code&gt;key&lt;/code&gt; 的先前值（或缺少key）将在之后恢复。用于模拟动态范围。</target>
        </trans-unit>
        <trans-unit id="eaa0c352f0575f82994206173cabc3866ad95796" translate="yes" xml:space="preserve">
          <source>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. &lt;code&gt;context&lt;/code&gt; can be either an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; whose properties will be used, or a &lt;code&gt;Pair&lt;/code&gt; specifying a property and its value. &lt;code&gt;sizehint&lt;/code&gt; suggests the capacity of the buffer (in bytes).</source>
          <target state="translated">使用I / O流和提供的额外参数调用给定函数。写入此I / O流的所有内容均以字符串形式返回。 &lt;code&gt;context&lt;/code&gt; 可以是一个&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;其属性将被使用，或者 &lt;code&gt;Pair&lt;/code&gt; 指定的属性和它的值。 &lt;code&gt;sizehint&lt;/code&gt; 建议缓冲区的容量（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="2664dee6a3ad5a12623406c5af1cda40ecf12ba0" translate="yes" xml:space="preserve">
          <source>Callback settings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt;&lt;code&gt;git_remote_callbacks&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">回调设置。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt; &lt;code&gt;git_remote_callbacks&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="c8256faf5b345c67f126415204dbd66a186005c2" translate="yes" xml:space="preserve">
          <source>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; has the effect of initializing a process as a worker using TCP/IP sockets for transport. &lt;code&gt;cookie&lt;/code&gt; is a &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt;&lt;code&gt;cluster_cookie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由实现自定义传输的群集管理器调用。它将新启动的进程初始化为工作进程。命令行参数 &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; 具有使用TCP / IP套接字进行传输将进程初始化为工作进程的作用。 &lt;code&gt;cookie&lt;/code&gt; 是&lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt; &lt;code&gt;cluster_cookie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caea39a5ffed5cf53b4f9992aa9aebdfdb841ef9" translate="yes" xml:space="preserve">
          <source>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two &lt;code&gt;IO&lt;/code&gt; objects, one for incoming messages and the other for messages addressed to the remote worker. If &lt;code&gt;incoming&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</source>
          <target state="translated">由集群管理器使用自定义传输进行调用。当自定义传输实现从远程工作程序接收到第一条消息时，应调用此方法。定制传输必须管理与远程工作程序的逻辑连接，并提供两个 &lt;code&gt;IO&lt;/code&gt; 对象，一个用于输入消息，另一个用于发送给远程工作程序的消息。如果 &lt;code&gt;incoming&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则远程对等方启动连接。该对中的任何一个发起连接都会发送集群cookie及其Julia版本号以执行身份验证握手。</target>
        </trans-unit>
        <trans-unit id="66dd1be7576a64af07b2ce99b1a2ed2a7c06b791" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#Core.Ref&quot;&gt;&lt;code&gt;Ref(array[, index])&lt;/code&gt;&lt;/a&gt; is generally preferable to this function as it guarantees validity.</source>
          <target state="translated">通常&lt;a href=&quot;#Core.Ref&quot;&gt; &lt;code&gt;Ref(array[, index])&lt;/code&gt; &lt;/a&gt;调用Ref（array [，index]）比此函数更可取，因为它可以确保有效性。</target>
        </trans-unit>
        <trans-unit id="0d16198678162c2927c2f17ed3e602251edd7089" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</source>
          <target state="translated">在宏内调用&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;是一个特别危险的警告信号。这意味着该宏仅在顶层调用时才起作用。如果将此类宏作为函数编写，则它自然可以访问所需的运行时值。</target>
        </trans-unit>
        <trans-unit id="b72748e09098c6bd97f55e59c563c3a122bb6331" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</source>
          <target state="translated">调用&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;在另一个模块中引起副作用。当设置了增量预编译标志时，这还将导致发出警告。</target>
        </trans-unit>
        <trans-unit id="41aa7e1fcfd92670fa5a846085d3341583baabcf" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s. For ease of use, the alias &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt;&lt;code&gt;StackTraces.StackTrace&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;code&gt;Vector{StackFrame}&lt;/code&gt;. (Examples with &lt;code&gt;[...]&lt;/code&gt; indicate that output may vary depending on how the code is run.)</source>
          <target state="translated">调用&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;的向量。为了易于使用，可以使用别名&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt; &lt;code&gt;StackTraces.StackTrace&lt;/code&gt; &lt;/a&gt;代替 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 。（与实施例 &lt;code&gt;[...]&lt;/code&gt; 表示输出可以根据代码是如何运行而有所不同。）</target>
        </trans-unit>
        <trans-unit id="4a4f549c9307f9b4d84be21408b77dbb68a1f198" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;rand&lt;/code&gt; and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt;&lt;code&gt;MersenneTwister&lt;/code&gt;&lt;/a&gt; (or other pseudorandom number generator) and pass it to the functions you are doctesting.</source>
          <target state="translated">在doctest中应避免调用 &lt;code&gt;rand&lt;/code&gt; 和其他与RNG相关的函数，因为它们在不同的Julia会话期间不会产生一致的输出。如果您想显示一些与随机数生成相关的功能，一种选择是显式构造并播种您自己的&lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt; &lt;code&gt;MersenneTwister&lt;/code&gt; &lt;/a&gt;（或其他伪随机数生成器）并将其传递给您正在进行文档测试的函数。</target>
        </trans-unit>
        <trans-unit id="2d7425b9bc6bdd37cfb5d8f6425582078c2424c2" translate="yes" xml:space="preserve">
          <source>Calling C and Fortran Code</source>
          <target state="translated">调用C和Fortran代码</target>
        </trans-unit>
        <trans-unit id="0a72734e5b9d7e776161f32d3bf09af339418e1e" translate="yes" xml:space="preserve">
          <source>Calling Convention</source>
          <target state="translated">召集公约</target>
        </trans-unit>
        <trans-unit id="9abfa6ddb5caaadbeab0376e3006f230505bfdea" translate="yes" xml:space="preserve">
          <source>Calling Julia Functions</source>
          <target state="translated">调用Julia函数</target>
        </trans-unit>
        <trans-unit id="85116a89bb1c5c01cfc46fa63875b231c5d2c577" translate="yes" xml:space="preserve">
          <source>Calling a method of a class in Python (&lt;code&gt;a = MyClass(x), x.func(y)&lt;/code&gt;) corresponds to a function call in Julia, e.g. &lt;code&gt;a = MyStruct(x), func(x::MyStruct, y)&lt;/code&gt;. In general, multiple dispatch is more flexible and powerful than the Python class system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49d09ca1110825e69afa568f7e07eeec5300e61" translate="yes" xml:space="preserve">
          <source>Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</source>
          <target state="translated">调用在生成函数主体之后定义的任何函数。对于增量加载的预编译模块,这个条件可以放宽,允许调用模块中的任何函数。</target>
        </trans-unit>
        <trans-unit id="41d74c50b2c67c3ddc7b0e22937873f076e4b22e" translate="yes" xml:space="preserve">
          <source>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</source>
          <target state="translated">调用这个函数是编写利用线性索引的算法的 &quot;安全 &quot;方法。</target>
        </trans-unit>
        <trans-unit id="0a19b7e26b2ba75ac27255f31f21e98a34d62953" translate="yes" xml:space="preserve">
          <source>Calls</source>
          <target state="translated">Calls</target>
        </trans-unit>
        <trans-unit id="19d45b5117925d478df6d24e3b83936bcd7c78e0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;f(args...; kwargs...)&lt;/code&gt;, but guarantees that the most recent method of &lt;code&gt;f&lt;/code&gt; will be executed. This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function &lt;code&gt;f&lt;/code&gt;. (The drawback is that &lt;code&gt;invokelatest&lt;/code&gt; is somewhat slower than calling &lt;code&gt;f&lt;/code&gt; directly, and the type of the result cannot be inferred by the compiler.)</source>
          <target state="translated">调用 &lt;code&gt;f(args...; kwargs...)&lt;/code&gt; ，但保证将执行 &lt;code&gt;f&lt;/code&gt; 的最新方法。这在特殊情况下很有用，例如长时间运行的事件循环或可能调用过时版本的函数 &lt;code&gt;f&lt;/code&gt; 的回调函数。（缺点是 &lt;code&gt;invokelatest&lt;/code&gt; 比直接调用 &lt;code&gt;f&lt;/code&gt; 慢一些，并且编译器无法推断结果的类型。）</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="f01f585ee537bca9460fb6cd89d91523ae410c34" translate="yes" xml:space="preserve">
          <source>Can I use &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; inside a function?</source>
          <target state="translated">我可以使用 &lt;code&gt;using&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 的一个函数里？</target>
        </trans-unit>
        <trans-unit id="07d6cb97820e052be2b530d0dd83bba8edfc5e64" translate="yes" xml:space="preserve">
          <source>Cancer</source>
          <target state="translated">Cancer</target>
        </trans-unit>
        <trans-unit id="dbffdf1f157a14a19d2c2aeb64068a16056948d8" translate="yes" xml:space="preserve">
          <source>Candy</source>
          <target state="translated">Candy</target>
        </trans-unit>
        <trans-unit id="f20a12fff18e89250e7a4fc78447ee7170895a65" translate="yes" xml:space="preserve">
          <source>Cannot exactly convert &lt;code&gt;val&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt; in a method of function &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">在函数 &lt;code&gt;name&lt;/code&gt; 的方法中，无法将 &lt;code&gt;val&lt;/code&gt; 精确地转换为 &lt;code&gt;T&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="91fe73e52f951e9f466713424d00ece47cdc7524" translate="yes" xml:space="preserve">
          <source>Canonicalize a path by expanding symbolic links and removing &quot;.&quot; and &quot;..&quot; entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.</source>
          <target state="translated">通过扩展符号链接和删除&quot;.&quot;和&quot;.&quot;条目来规范一个路径。在不区分大小写的文件系统中(通常是Mac和Windows),将返回文件系统中存储的路径大小写。</target>
        </trans-unit>
        <trans-unit id="90a16c05e849a5af3a6ddd19c2db0fa10e54dd2d" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of each word in &lt;code&gt;s&lt;/code&gt;; if &lt;code&gt;strict&lt;/code&gt; is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the &lt;code&gt;wordsep&lt;/code&gt; keyword to determine which characters should be considered as word separators. See also &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt;&lt;code&gt;uppercasefirst&lt;/code&gt;&lt;/a&gt; to capitalize only the first character in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;s&lt;/code&gt; 中每个单词的首字母大写；如果 &lt;code&gt;strict&lt;/code&gt; 为true，则所有其他字符都将转换为小写，否则将保持不变。默认情况下，所有非字母都被视为单词分隔符；可以将谓词作为 &lt;code&gt;wordsep&lt;/code&gt; 关键字传递，以确定哪些字符应视为单词分隔符。另请参见&lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt; &lt;code&gt;uppercasefirst&lt;/code&gt; &lt;/a&gt;以仅大写 &lt;code&gt;s&lt;/code&gt; 中的第一个字符。</target>
        </trans-unit>
        <trans-unit id="c9bf29452874274eefd7cb3833b9f64b68215e7a" translate="yes" xml:space="preserve">
          <source>Capricorn</source>
          <target state="translated">Capricorn</target>
        </trans-unit>
        <trans-unit id="7a60d3a75036d27b63be0e55a67bb26ec4e25de4" translate="yes" xml:space="preserve">
          <source>Captures can also be accessed by indexing the &lt;code&gt;RegexMatch&lt;/code&gt; object with the number or name of the capture group:</source>
          <target state="translated">也可以通过使用捕获组的编号或名称索引 &lt;code&gt;RegexMatch&lt;/code&gt; 对象来访问捕获：</target>
        </trans-unit>
        <trans-unit id="88b6c532d029fa2352cf701d32470679db245f1e" translate="yes" xml:space="preserve">
          <source>Captures can be referenced in a substitution string when using &lt;code&gt;replace&lt;/code&gt; by using &lt;code&gt;\n&lt;/code&gt; to refer to the nth capture group and prefixing the substitution string with &lt;code&gt;s&lt;/code&gt;. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">在使用 &lt;code&gt;replace&lt;/code&gt; 时，可以在替换字符串中引用捕获，方法是使用 &lt;code&gt;\n&lt;/code&gt; 引用第n个捕获组并在替换字符串前加上 &lt;code&gt;s&lt;/code&gt; 。捕获组0引用整个匹配对象。可以使用 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 替换引用命名的捕获组。例如：</target>
        </trans-unit>
        <trans-unit id="f2a9f7332f7a09946296f88c18131b92dbb1279f" translate="yes" xml:space="preserve">
          <source>Card Index</source>
          <target state="translated">卡片索引</target>
        </trans-unit>
        <trans-unit id="0cca55f8e3afeb49c40b1e95517a9c1135c7a560" translate="yes" xml:space="preserve">
          <source>Carousel Horse</source>
          <target state="translated">旋转木马</target>
        </trans-unit>
        <trans-unit id="255e5aac2127bb14392d1d0c859050548a802598" translate="yes" xml:space="preserve">
          <source>Carp Streamer</source>
          <target state="translated">鲤鱼流</target>
        </trans-unit>
        <trans-unit id="722d5852eba2640d07e63d26f677b7d3dce6d40c" translate="yes" xml:space="preserve">
          <source>Cartesian indexing</source>
          <target state="translated">笛卡尔索引</target>
        </trans-unit>
        <trans-unit id="2a2b1fd0558d005d15bb6a090f84de302c0d4517" translate="yes" xml:space="preserve">
          <source>Cartesian indices</source>
          <target state="translated">笛卡尔指数</target>
        </trans-unit>
        <trans-unit id="2111431e539d8078cb148dae299ad435bcf94b27" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">案例 &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f1c61da11e76b12eda645d65ffd7fe29682099" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 0&lt;/code&gt;</source>
          <target state="translated">情况 &lt;code&gt;n == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a059f07d864d6895c8f26aada84e3e2ae48daa" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 1&lt;/code&gt;</source>
          <target state="translated">情况 &lt;code&gt;n == 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5a951eefa4da8021cf83c2a312ac9db2161e292" translate="yes" xml:space="preserve">
          <source>Case Study: Rational</source>
          <target state="translated">案例研究。理性</target>
        </trans-unit>
        <trans-unit id="226c8be8625b7e7ff2acf9e7afa1f2c1a67ee20d" translate="yes" xml:space="preserve">
          <source>Case Study: Rational Promotions</source>
          <target state="translated">案例研究。理性促销</target>
        </trans-unit>
        <trans-unit id="cebe54c7626cb1cefaca5f7f5ea6c96b4a7a2882" translate="yes" xml:space="preserve">
          <source>Cat</source>
          <target state="translated">Cat</target>
        </trans-unit>
        <trans-unit id="e321d6511fec0b2a4b2f0a4b6c9161ea67d3b862" translate="yes" xml:space="preserve">
          <source>Cat Face</source>
          <target state="translated">猫的脸</target>
        </trans-unit>
        <trans-unit id="0304d8e66e7196a0cbe56d1a1e3f50a5d44586dc" translate="yes" xml:space="preserve">
          <source>Cat Face With Tears Of Joy</source>
          <target state="translated">猫的面孔与喜悦的泪水</target>
        </trans-unit>
        <trans-unit id="8694b8421f68b951f951f9af799f80af5160aedd" translate="yes" xml:space="preserve">
          <source>Cat Face With Wry Smile</source>
          <target state="translated">猫的脸,笑眯眯的</target>
        </trans-unit>
        <trans-unit id="34dfec8f22dde17704da94df2192063529be5d2d" translate="yes" xml:space="preserve">
          <source>Catalan's constant.</source>
          <target state="translated">加泰罗尼亚语的常。</target>
        </trans-unit>
        <trans-unit id="b8c6b9519d52cad00665d92e155963171c5e725d" translate="yes" xml:space="preserve">
          <source>Catch exceptions during event evaluation</source>
          <target state="translated">在事件评估过程中捕捉异常情况</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="1a80861772b0484c4f5af5303cebead59df45b86" translate="yes" xml:space="preserve">
          <source>Caution Sign</source>
          <target state="translated">警告标志</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="e4c530b1c24d3c230e2d840c8f5a4bd61e8f0170" translate="yes" xml:space="preserve">
          <source>Cchar</source>
          <target state="translated">Cchar</target>
        </trans-unit>
        <trans-unit id="98ea122cbe5434a5105ed227191d1c86da875820" translate="yes" xml:space="preserve">
          <source>Cdouble</source>
          <target state="translated">Cdouble</target>
        </trans-unit>
        <trans-unit id="ef6d3da178771ba00eefbc1133066d5d42ce7c22" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. The constructs introducing scope blocks are:</source>
          <target state="translated">该语言中的某些构造引入了&lt;em&gt;作用域块&lt;/em&gt;，这是有资格成为某些变量集范围的代码区域。变量的范围不能是源代码行的任意集合；相反，它将始终与这些块之一对齐。在Julia中，作用域主要有两种类型：&lt;em&gt;全局作用域&lt;/em&gt;和&lt;em&gt;局部作用域&lt;/em&gt;。后者可以嵌套。引入作用域块的构造为：</target>
        </trans-unit>
        <trans-unit id="79d6412ea668dd527aa9bd5226b88db41d88b00b" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. There is also a distinction in Julia between constructs which introduce a &quot;hard scope&quot; and those which only introduce a &quot;soft scope&quot;, which affects whether shadowing a global variable by the same name is allowed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a436f524b4f30d26cce25c6fb61307697fefc2aa" translate="yes" xml:space="preserve">
          <source>Certain operations make mathematical sense but result in errors:</source>
          <target state="translated">某些运算在数学上是有意义的,但却会产生错误。</target>
        </trans-unit>
        <trans-unit id="b83c053cc3abf67280351793fa40fe0857a1ef12" translate="yes" xml:space="preserve">
          <source>Cfloat</source>
          <target state="translated">Cfloat</target>
        </trans-unit>
        <trans-unit id="1bf8d41c6633f510ee163ba63fad81c499b65c06" translate="yes" xml:space="preserve">
          <source>Chaining comparisons</source>
          <target state="translated">链式比较</target>
        </trans-unit>
        <trans-unit id="e4b02f736800960ffeb31d1ce4d94bc68e9b3522" translate="yes" xml:space="preserve">
          <source>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator for scalar comparisons, and the &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; operator for elementwise comparisons, which allows them to work on arrays. For example, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; gives a boolean array whose entries are true where the corresponding elements of &lt;code&gt;A&lt;/code&gt; are between 0 and 1.</source>
          <target state="translated">链接比较在数字代码中通常非常方便。链式比较使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符进行标量比较，并使用&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;运算符进行元素比较，这使它们可以处理数组。例如， &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; 给出一个布尔数组，其条目为true，其中 &lt;code&gt;A&lt;/code&gt; 的对应元素在0和1之间。</target>
        </trans-unit>
        <trans-unit id="e392d2ea4fb56f31affc92a17a7f093445989a1e" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;T&lt;/code&gt; arithmetic precision (in bits) for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">在 &lt;code&gt;f&lt;/code&gt; 的持续时间内更改 &lt;code&gt;T&lt;/code&gt; 的算术精度（以位为单位）。从逻辑上讲，它等效于：</target>
        </trans-unit>
        <trans-unit id="aa7aae11d28e8bd4a1ac0973becf0187af2f72ff" translate="yes" xml:space="preserve">
          <source>Change the next word to lowercase</source>
          <target state="translated">把下一个字改成小写</target>
        </trans-unit>
        <trans-unit id="a9d00290564b5f132466d2d65a5760e410b77379" translate="yes" xml:space="preserve">
          <source>Change the next word to titlecase</source>
          <target state="translated">把下一个字改成titlecase</target>
        </trans-unit>
        <trans-unit id="a1848e10eea50d9a7d51e412b6c651b68fe304e4" translate="yes" xml:space="preserve">
          <source>Change the next word to uppercase</source>
          <target state="translated">把下一个字改成大写</target>
        </trans-unit>
        <trans-unit id="52116f45eb7f0166da051d04ad38b63f5e208b1f" translate="yes" xml:space="preserve">
          <source>Change the owner and/or group of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;owner&lt;/code&gt; and/or &lt;code&gt;group&lt;/code&gt;. If the value entered for &lt;code&gt;owner&lt;/code&gt; or &lt;code&gt;group&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; the corresponding ID will not change. Only integer &lt;code&gt;owner&lt;/code&gt;s and &lt;code&gt;group&lt;/code&gt;s are currently supported. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">将所有者和/或组 &lt;code&gt;path&lt;/code&gt; 更改为 &lt;code&gt;owner&lt;/code&gt; 和/或 &lt;code&gt;group&lt;/code&gt; 。如果为 &lt;code&gt;owner&lt;/code&gt; 或 &lt;code&gt;group&lt;/code&gt; 输入的值是 &lt;code&gt;-1&lt;/code&gt; ,则相应的ID不会更改。当前仅支持整数 &lt;code&gt;owner&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 。返回 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cadce06d0cab691571969b2bd50452957441f5" translate="yes" xml:space="preserve">
          <source>Change the permissions mode of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;mode&lt;/code&gt;. Only integer &lt;code&gt;mode&lt;/code&gt;s (e.g. &lt;code&gt;0o777&lt;/code&gt;) are currently supported. If &lt;code&gt;recursive=true&lt;/code&gt; and the path is a directory all permissions in that directory will be recursively changed. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;path&lt;/code&gt; 的权限模式更改为 &lt;code&gt;mode&lt;/code&gt; 。当前仅支持整数 &lt;code&gt;mode&lt;/code&gt; s（例如 &lt;code&gt;0o777&lt;/code&gt; ）。如果 &lt;code&gt;recursive=true&lt;/code&gt; 且路径为目录，则将递归更改该目录中的所有权限。返回 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a989fb98b8f1dbfc4dbfdbda4cfa7a8f5a564e" translate="yes" xml:space="preserve">
          <source>Change the rounding mode of floating point type &lt;code&gt;T&lt;/code&gt; for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">在 &lt;code&gt;f&lt;/code&gt; 的持续时间内更改浮点类型 &lt;code&gt;T&lt;/code&gt; 的舍入模式。从逻辑上讲，它等效于：</target>
        </trans-unit>
        <trans-unit id="6826b0c27162177562d5dac46bf63880b08e8521" translate="yes" xml:space="preserve">
          <source>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; interprets the 4 bytes corresponding to &lt;code&gt;UInt32(7)&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">更改内存块的类型解释。对于数组，这将使用与给定数组相同的二进制数据，但具有指定的元素类型来构造数组的视图。例如， &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; 将对应于 &lt;code&gt;UInt32(7)&lt;/code&gt; 的4个字节解释为&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4eec72c597c649417c08cf8310c3fd12582209e" translate="yes" xml:space="preserve">
          <source>Change to the first history entry (of the current session if it is before the current position in history)</source>
          <target state="translated">改为历史上的第一个历史记录(如果在历史上的当前位置之前,则为当前会话的第一个历史记录)。</target>
        </trans-unit>
        <trans-unit id="2d9790ce2e89644c1d5ef1d4178a0e20ffa229c9" translate="yes" xml:space="preserve">
          <source>Change to the last history entry</source>
          <target state="translated">改为最后的历史记录</target>
        </trans-unit>
        <trans-unit id="f00c73a7c5134c054bca76810185e125c387bc0a" translate="yes" xml:space="preserve">
          <source>Change to the next history entry</source>
          <target state="translated">更改到下一个历史条目</target>
        </trans-unit>
        <trans-unit id="cfe48d07ba26c0afb2979f42a242b38ee82c88da" translate="yes" xml:space="preserve">
          <source>Change to the previous history entry</source>
          <target state="translated">改为以前的历史记录</target>
        </trans-unit>
        <trans-unit id="879f0b1bef59eeebf78cfd3a22f6f8077810cecf" translate="yes" xml:space="preserve">
          <source>Channel</source>
          <target state="translated">Channel</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="5d2585d6b1ebe562ed90e098229697dd1edbced3" translate="yes" xml:space="preserve">
          <source>Channels and RemoteChannels</source>
          <target state="translated">频道和远程频道</target>
        </trans-unit>
        <trans-unit id="5de527ad4b50c6e5971cd0c9d1c61d30dff8242c" translate="yes" xml:space="preserve">
          <source>Channels are created via the &lt;code&gt;Channel{T}(sz)&lt;/code&gt; constructor. The channel will only hold objects of type &lt;code&gt;T&lt;/code&gt;. If the type is not specified, the channel can hold objects of any type. &lt;code&gt;sz&lt;/code&gt; refers to the maximum number of elements that can be held in the channel at any time. For example, &lt;code&gt;Channel(32)&lt;/code&gt; creates a channel that can hold a maximum of 32 objects of any type. A &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; can hold up to 64 objects of &lt;code&gt;MyType&lt;/code&gt; at any time.</source>
          <target state="translated">通道是通过 &lt;code&gt;Channel{T}(sz)&lt;/code&gt; 构造函数创建的。该通道将仅容纳类型 &lt;code&gt;T&lt;/code&gt; 的对象。如果未指定类型，则通道可以容纳任何类型的对象。 &lt;code&gt;sz&lt;/code&gt; 是指可以随时在通道中保留的最大元素数。例如， &lt;code&gt;Channel(32)&lt;/code&gt; 创建一个通道，最多可容纳32个任何类型的对象。甲 &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; 可以容纳多达64个对象 &lt;code&gt;MyType&lt;/code&gt; 随时。</target>
        </trans-unit>
        <trans-unit id="f0af2b3f98cdd8293e5cd590c14f3ad654402a21" translate="yes" xml:space="preserve">
          <source>Character Tie</source>
          <target state="translated">人物领带</target>
        </trans-unit>
        <trans-unit id="ed74ee0fd869597bc8b7e61e821510ccb8a627ec" translate="yes" xml:space="preserve">
          <source>Character literals use the same behavior.</source>
          <target state="translated">字符字形使用相同的行为。</target>
        </trans-unit>
        <trans-unit id="af451d4e9c685856e4c14256f0f0685adcf83857" translate="yes" xml:space="preserve">
          <source>Character(s)</source>
          <target state="translated">Character(s)</target>
        </trans-unit>
        <trans-unit id="69803692f05446db28128e4d652fcda3604ec718" translate="yes" xml:space="preserve">
          <source>Characteristics:</source>
          <target state="translated">Characteristics:</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="d9a77eec8cc54d9b9059ecff9f7f8b0c3d4a4b0c" translate="yes" xml:space="preserve">
          <source>Characters not listed above are normally treated as delimiters between date and time slots. For example a &lt;code&gt;dt&lt;/code&gt; string of &quot;1996-01-15T00:00:00.0&quot; would have a &lt;code&gt;format&lt;/code&gt; string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</source>
          <target state="translated">上面未列出的字符通常被视为日期和时隙之间的分隔符。例如， &lt;code&gt;dt&lt;/code&gt; 字符串&amp;ldquo; 1996-01-15T00：00：00.0&amp;rdquo;的 &lt;code&gt;format&lt;/code&gt; 字符串应为&amp;ldquo; ym-dTH：M：Ss&amp;rdquo;。如果您需要使用代码字符作为分隔符，则可以使用反斜杠对其进行转义。日期&amp;ldquo; 1995y01m&amp;rdquo;的格式为&amp;ldquo; y \ ym \ m&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ebef4e9d21d309d10e724345b9594679b3cd6e69" translate="yes" xml:space="preserve">
          <source>Chart With Downwards Trend</source>
          <target state="translated">下行趋势图</target>
        </trans-unit>
        <trans-unit id="fda4f4461a399f03823d93f75ef10112a332c903" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend</source>
          <target state="translated">有上升趋势的图表</target>
        </trans-unit>
        <trans-unit id="a4a446b006052a5af669c7f6d998cf1743a7f6f9" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend And Yen Sign</source>
          <target state="translated">有上升趋势和日元标志的图表</target>
        </trans-unit>
        <trans-unit id="73e89165960f554ff917c3b3ac9d3b096b8d5eaf" translate="yes" xml:space="preserve">
          <source>Check Mark</source>
          <target state="translated">检查标志</target>
        </trans-unit>
        <trans-unit id="6af7b65d95d1fd3d3c46eeef377ffa00fb6e86a4" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;ex&lt;/code&gt; is an expression with head &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cccac008dc853e30120df3e9a70c3898d9b2bee" translate="yes" xml:space="preserve">
          <source>Check if commit &lt;code&gt;id&lt;/code&gt; (which is a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) is in the repository.</source>
          <target state="translated">检查提交 &lt;code&gt;id&lt;/code&gt; （以字符串形式的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;）是否在存储库中。</target>
        </trans-unit>
        <trans-unit id="36465e7df054d1a8db11c41ceb01463ffd339488" translate="yes" xml:space="preserve">
          <source>Check if the current branch is an &quot;orphan&quot; branch, i.e. has no commits. The first commit to this branch will have no parents.</source>
          <target state="translated">检查当前分支是否是 &quot;孤儿 &quot;分支,即没有提交。该分支的第一次提交将没有父分支。</target>
        </trans-unit>
        <trans-unit id="b66e0b7684d9561bc0ff2976ce4bdbc130c0a5c9" translate="yes" xml:space="preserve">
          <source>Check if there have been any changes to tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">检查工作树（如果 &lt;code&gt;cached=false&lt;/code&gt; ）或索引（如果 &lt;code&gt;cached=true&lt;/code&gt; ）中跟踪文件是否有任何更改。 &lt;code&gt;pathspecs&lt;/code&gt; 是差异选项的规范。</target>
        </trans-unit>
        <trans-unit id="10941e2df89576fa668bf1f89fbe0ad9fb195edb" translate="yes" xml:space="preserve">
          <source>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</source>
          <target state="translated">检查一个矩阵是否为正方形,然后返回它的公维。对于多个参数,返回一个向量。</target>
        </trans-unit>
        <trans-unit id="6861a1cca611ecd76d506c1580f9dd38e9dfec32" translate="yes" xml:space="preserve">
          <source>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</source>
          <target state="translated">检查两个数组形状是否兼容,允许尾随单子维度,并返回哪个形状的维度多。</target>
        </trans-unit>
        <trans-unit id="5847f57e4c8ac4313a08831cbbd9321dc7c8aa94" translate="yes" xml:space="preserve">
          <source>Check whether the &lt;code&gt;lock&lt;/code&gt; is held by any task/thread. This should not be used for synchronization (see instead &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">检查 &lt;code&gt;lock&lt;/code&gt; 是否由任何任务/线程持有。这不应用于同步（请参阅&lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="387def941a675fd43bb90cd2f103bc1835695e36" translate="yes" xml:space="preserve">
          <source>Checked.add_with_overflow()</source>
          <target state="translated">Checked.add_with_overflow()</target>
        </trans-unit>
        <trans-unit id="5861f86d2198b43b150ea6be20eecd4f4ca194fb" translate="yes" xml:space="preserve">
          <source>Checked.checked_abs()</source>
          <target state="translated">Checked.checked_abs()</target>
        </trans-unit>
        <trans-unit id="0e340663d314653dc7f7258455c8c64ec865a402" translate="yes" xml:space="preserve">
          <source>Checked.checked_add()</source>
          <target state="translated">Checked.checked_add()</target>
        </trans-unit>
        <trans-unit id="793b46bf345ea840a66fc3ce7be504df87f6aad8" translate="yes" xml:space="preserve">
          <source>Checked.checked_cld()</source>
          <target state="translated">Checked.checked_cld()</target>
        </trans-unit>
        <trans-unit id="cbb75d95e9a638cb0354f430f1c41528c16d5f1e" translate="yes" xml:space="preserve">
          <source>Checked.checked_div()</source>
          <target state="translated">Checked.checked_div()</target>
        </trans-unit>
        <trans-unit id="10f25d8f5722c731db35c0585785eb14e0947047" translate="yes" xml:space="preserve">
          <source>Checked.checked_fld()</source>
          <target state="translated">Checked.checked_fld()</target>
        </trans-unit>
        <trans-unit id="844d8f377decea211f1aa04e5b41ffd6aa8ec8aa" translate="yes" xml:space="preserve">
          <source>Checked.checked_mod()</source>
          <target state="translated">Checked.checked_mod()</target>
        </trans-unit>
        <trans-unit id="6e287962b9c64e9790cebd017023df56a743a004" translate="yes" xml:space="preserve">
          <source>Checked.checked_mul()</source>
          <target state="translated">Checked.checked_mul()</target>
        </trans-unit>
        <trans-unit id="8cddbe8ee88213cf9e9d56a609fa85a89e086da7" translate="yes" xml:space="preserve">
          <source>Checked.checked_neg()</source>
          <target state="translated">Checked.checked_neg()</target>
        </trans-unit>
        <trans-unit id="e44667638c3a1dc209bda165095e1d1cd133cc75" translate="yes" xml:space="preserve">
          <source>Checked.checked_rem()</source>
          <target state="translated">Checked.checked_rem()</target>
        </trans-unit>
        <trans-unit id="0088d172f06fff6ea323397de23669a32c31474b" translate="yes" xml:space="preserve">
          <source>Checked.checked_sub()</source>
          <target state="translated">Checked.checked_sub()</target>
        </trans-unit>
        <trans-unit id="ab7e607ffaab3ede22444bf0bafb0736dd5575b5" translate="yes" xml:space="preserve">
          <source>Checked.mul_with_overflow()</source>
          <target state="translated">Checked.mul_with_overflow()</target>
        </trans-unit>
        <trans-unit id="44a69fd61235a11b4b6edaa45c7d2594c6702f55" translate="yes" xml:space="preserve">
          <source>Checked.sub_with_overflow()</source>
          <target state="translated">Checked.sub_with_overflow()</target>
        </trans-unit>
        <trans-unit id="f66ee858da2bed315f19a0831545acdc098092b9" translate="yes" xml:space="preserve">
          <source>Checking for equality with a singleton</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099aaa95277770b044f9e7efabb37f097dce362a" translate="yes" xml:space="preserve">
          <source>Checkout a new git branch in the &lt;code&gt;repo&lt;/code&gt; repository. &lt;code&gt;commit&lt;/code&gt; is the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt;, in string form, which will be the start of the new branch. If &lt;code&gt;commit&lt;/code&gt; is an empty string, the current HEAD will be used.</source>
          <target state="translated">结帐的一个新的分支的git &lt;code&gt;repo&lt;/code&gt; 库。 &lt;code&gt;commit&lt;/code&gt; 是字符串形式的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;，它将是新分支的开始。如果 &lt;code&gt;commit&lt;/code&gt; 是一个空字符串，将使用当前的HEAD。</target>
        </trans-unit>
        <trans-unit id="a01db35293e447e7dfa93e429ed3057a3d6edb4e" translate="yes" xml:space="preserve">
          <source>Checks if there are any differences between the tree specified by &lt;code&gt;treeish&lt;/code&gt; and the tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">检查 &lt;code&gt;treeish&lt;/code&gt; 指定的树与工作树中的跟踪文件（如果 &lt;code&gt;cached=false&lt;/code&gt; ）或索引（如果 &lt;code&gt;cached=true&lt;/code&gt; ）之间是否有任何区别。 &lt;code&gt;pathspecs&lt;/code&gt; 是差异选项的规范。</target>
        </trans-unit>
        <trans-unit id="80497c05495db1c1e51a0b937bd9ffa77fb142ff" translate="yes" xml:space="preserve">
          <source>Cheering Megaphone</source>
          <target state="translated">欢呼扩音器</target>
        </trans-unit>
        <trans-unit id="e81bedf047792fbe90c699c0d92561bd6df81796" translate="yes" xml:space="preserve">
          <source>Chequered Flag</source>
          <target state="translated">方格旗</target>
        </trans-unit>
        <trans-unit id="78bc6d7859d13eaa4171edc4973a040f60c5efa2" translate="yes" xml:space="preserve">
          <source>Cherries</source>
          <target state="translated">Cherries</target>
        </trans-unit>
        <trans-unit id="d980b2a4bed67957e89a2bfcbf9122253661d3b9" translate="yes" xml:space="preserve">
          <source>Cherry Blossom</source>
          <target state="translated">樱花</target>
        </trans-unit>
        <trans-unit id="c712b8835755410091fbe89cfba2f9989bcdddf1" translate="yes" xml:space="preserve">
          <source>Chestnut</source>
          <target state="translated">Chestnut</target>
        </trans-unit>
        <trans-unit id="baaa18844b8db958c57edddf824f4a8b5cd9e298" translate="yes" xml:space="preserve">
          <source>Chicken</source>
          <target state="translated">Chicken</target>
        </trans-unit>
        <trans-unit id="6684f920ddf587816828d0949794d536f2044d85" translate="yes" xml:space="preserve">
          <source>Children Crossing</source>
          <target state="translated">儿童穿越</target>
        </trans-unit>
        <trans-unit id="be60ee4f4851b8d244bba0827efe90ca53080f02" translate="yes" xml:space="preserve">
          <source>Chocolate Bar</source>
          <target state="translated">巧克力棒</target>
        </trans-unit>
        <trans-unit id="36f117bd7dd482a1010ab9584c224f54936b91cc" translate="yes" xml:space="preserve">
          <source>Cholesky (see &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;（请参阅cholesky）</target>
        </trans-unit>
        <trans-unit id="e3c96b15f464a32f9dbfcd9be5dcfbc00bda9510" translate="yes" xml:space="preserve">
          <source>Cholesky factorization</source>
          <target state="translated">Cholesky因式分解</target>
        </trans-unit>
        <trans-unit id="da141a0edd85453be825d6aa02b625b2d8b12905" translate="yes" xml:space="preserve">
          <source>Christmas Tree</source>
          <target state="translated">圣诞树</target>
        </trans-unit>
        <trans-unit id="e72e88ea6123b50e6208c2e997da2b67631286d6" translate="yes" xml:space="preserve">
          <source>Church</source>
          <target state="translated">Church</target>
        </trans-unit>
        <trans-unit id="f4ea571bfe0617f587935723651430356fc70f4c" translate="yes" xml:space="preserve">
          <source>Cinema</source>
          <target state="translated">Cinema</target>
        </trans-unit>
        <trans-unit id="20638d5f9a181ef513cf00b55dcce4c98adb55f7" translate="yes" xml:space="preserve">
          <source>Cint</source>
          <target state="translated">Cint</target>
        </trans-unit>
        <trans-unit id="810c53332cece6a0ba48a6c0ba3b4f10aa580f90" translate="yes" xml:space="preserve">
          <source>Cintmax_t</source>
          <target state="translated">Cintmax_t</target>
        </trans-unit>
        <trans-unit id="f012b4aef95600337cc3ea8a98c28a295ab93f2f" translate="yes" xml:space="preserve">
          <source>Circle With All But Upper Left Quadrant Black</source>
          <target state="translated">圆形,除左上角外全部为黑色</target>
        </trans-unit>
        <trans-unit id="e64a2f1f5550310ac4fcf3d82a1eba3eb03373e3" translate="yes" xml:space="preserve">
          <source>Circle With Left Half Black</source>
          <target state="translated">圆形,左半边黑色</target>
        </trans-unit>
        <trans-unit id="4242c36ce736c0ae2d9e13bbac4c03ddccb00e63" translate="yes" xml:space="preserve">
          <source>Circle With Lower Half Black</source>
          <target state="translated">圆形(下半部为黑色</target>
        </trans-unit>
        <trans-unit id="9946dda080b1d6f72432e4888afcc095dde79ea8" translate="yes" xml:space="preserve">
          <source>Circle With Right Half Black</source>
          <target state="translated">圆形,右半边黑色</target>
        </trans-unit>
        <trans-unit id="d869eafe06cb16bdb3bb0bc2e1be15db03901859" translate="yes" xml:space="preserve">
          <source>Circle With Upper Half Black</source>
          <target state="translated">圆形(上半部为黑色</target>
        </trans-unit>
        <trans-unit id="a8f7c61db4ce9bd030f686d3b28ef55edb06c05f" translate="yes" xml:space="preserve">
          <source>Circle With Upper Right Quadrant Black</source>
          <target state="translated">黑色右上象限的圆圈</target>
        </trans-unit>
        <trans-unit id="7ac2156e5b2912f2254d2f3ae90f1a8c149be7ab" translate="yes" xml:space="preserve">
          <source>Circle With Vertical Fill</source>
          <target state="translated">圆形,垂直填充</target>
        </trans-unit>
        <trans-unit id="bdade6bd883a792ea7c7650d2326b104f190c6db" translate="yes" xml:space="preserve">
          <source>Circled Anticlockwise-Rotated Division Sign</source>
          <target state="translated">逆时针旋转的圆环形分界线标志。</target>
        </trans-unit>
        <trans-unit id="288b0220ab4dfdbd33067b22c1e4248e5492c4f4" translate="yes" xml:space="preserve">
          <source>Circled Asterisk Operator</source>
          <target state="translated">圆圈星号操作员</target>
        </trans-unit>
        <trans-unit id="c23f14422e51f91da407f474f9afc3cc0d6b1a61" translate="yes" xml:space="preserve">
          <source>Circled Bullet</source>
          <target state="translated">圆形子弹</target>
        </trans-unit>
        <trans-unit id="317b273eb94a369a8c28e6bf5cd7c75c54af9e35" translate="yes" xml:space="preserve">
          <source>Circled Dash</source>
          <target state="translated">环形短跑</target>
        </trans-unit>
        <trans-unit id="f5d528c73ab76ab5f33f09420750954ff64b51f9" translate="yes" xml:space="preserve">
          <source>Circled Division Sign</source>
          <target state="translated">环形分割标志</target>
        </trans-unit>
        <trans-unit id="af5e4fc428d95afd21ff1ec53e8506a2bd73fb48" translate="yes" xml:space="preserve">
          <source>Circled Division Slash</source>
          <target state="translated">圈形分割斜线</target>
        </trans-unit>
        <trans-unit id="1540fdfaea096a26f649db63c8e3d97ec047096a" translate="yes" xml:space="preserve">
          <source>Circled Dot Operator</source>
          <target state="translated">圆点操作员</target>
        </trans-unit>
        <trans-unit id="13716b865f5fa5c0c59b298bdb824a0403d1d0a8" translate="yes" xml:space="preserve">
          <source>Circled Equals</source>
          <target state="translated">被圈起来的等于</target>
        </trans-unit>
        <trans-unit id="6fb20198e34869ba5357fb1484d789a4a9cf41a3" translate="yes" xml:space="preserve">
          <source>Circled Greater-Than</source>
          <target state="translated">环形大号</target>
        </trans-unit>
        <trans-unit id="768c6a3e34cf1fa1fe17c4122cd2eb756b5c8db1" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Accept</source>
          <target state="translated">圆圈表意文字接受</target>
        </trans-unit>
        <trans-unit id="cd7d8396b4543ec8eac2c933faab0d381b5eddf4" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Advantage</source>
          <target state="translated">圆圈表意文字的优势</target>
        </trans-unit>
        <trans-unit id="68de940ba4435005de139e8e8a3c0d351749a305" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Congratulation</source>
          <target state="translated">圆圈表意文字祝贺</target>
        </trans-unit>
        <trans-unit id="73f2e57c66e79ca73dc25a784afe3bf12db57991" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Secret</source>
          <target state="translated">循环表意文字的秘密</target>
        </trans-unit>
        <trans-unit id="a40a39ec3a6682d21b6ef060b4feb0021bb56a91" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter M</source>
          <target state="translated">圆形拉丁大写字母M</target>
        </trans-unit>
        <trans-unit id="0737d90c41767eac9bb882a65f60e50a52a763a4" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter S</source>
          <target state="translated">环形拉丁字母S</target>
        </trans-unit>
        <trans-unit id="3921273fcb7324637d2df323be0460e56b6c07e5" translate="yes" xml:space="preserve">
          <source>Circled Less-Than</source>
          <target state="translated">绕行小于</target>
        </trans-unit>
        <trans-unit id="11ab89c625b1e2be31e3ce88e58467e9d8b591d3" translate="yes" xml:space="preserve">
          <source>Circled Minus</source>
          <target state="translated">圈定的减号</target>
        </trans-unit>
        <trans-unit id="49fb7ea6102e3ddbe3f49605b323255242257db1" translate="yes" xml:space="preserve">
          <source>Circled Multiplication Sign With Circumflex Accent</source>
          <target state="translated">圆圈乘法标志,带圆环形饰条。</target>
        </trans-unit>
        <trans-unit id="b54193aa1a494f0d833f0a8740fb732847cecb8a" translate="yes" xml:space="preserve">
          <source>Circled Parallel</source>
          <target state="translated">环形平行线</target>
        </trans-unit>
        <trans-unit id="8f99a8867a889f5ea35c2600d3c7f7047a7990e2" translate="yes" xml:space="preserve">
          <source>Circled Plus</source>
          <target state="translated">循环加</target>
        </trans-unit>
        <trans-unit id="b2f2ab10cbdb08e806c050f7e4c9abf4807d102e" translate="yes" xml:space="preserve">
          <source>Circled Reverse Solidus</source>
          <target state="translated">环形反转的Solidus</target>
        </trans-unit>
        <trans-unit id="7a06e50e7385bdb39935cdfabe9072e82b9447d8" translate="yes" xml:space="preserve">
          <source>Circled Ring Operator</source>
          <target state="translated">环形环形操作员</target>
        </trans-unit>
        <trans-unit id="3118f0f5bf53391e1d64d00f6fd9c8f83519338c" translate="yes" xml:space="preserve">
          <source>Circled Times</source>
          <target state="translated">圈圈时代</target>
        </trans-unit>
        <trans-unit id="e0d7ab77f8105b38fa7df093b28a79c9646ca42a" translate="yes" xml:space="preserve">
          <source>Circled White Bullet</source>
          <target state="translated">圆形白色子弹</target>
        </trans-unit>
        <trans-unit id="9d61e5de58e6dee3981e042fcf23eeed9646f7cf" translate="yes" xml:space="preserve">
          <source>Circled White Star</source>
          <target state="translated">环形白星</target>
        </trans-unit>
        <trans-unit id="7748321d0967d869f81325b4585f9b2588000677" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in &lt;code&gt;src&lt;/code&gt;, storing the result in &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;shifts&lt;/code&gt; specifies the amount to shift in each dimension.</source>
          <target state="translated">循环移位（即旋转） &lt;code&gt;src&lt;/code&gt; 中的数据，并将结果存储在 &lt;code&gt;dest&lt;/code&gt; 中。 &lt;code&gt;shifts&lt;/code&gt; 指定每个维度上的偏移量。</target>
        </trans-unit>
        <trans-unit id="d8d1450c5aa55fa70cdef969d2aed9b6bea5b253" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</source>
          <target state="translated">对数组中的数据进行循环移动,即旋转。第二个参数是一个元组或向量,给出每个维度的移动量,或者一个整数,只在第一个维度移动。</target>
        </trans-unit>
        <trans-unit id="a48e6cb43386bd05dea50af46a123ad0d776b80b" translate="yes" xml:space="preserve">
          <source>Circulation Function</source>
          <target state="translated">循环功能</target>
        </trans-unit>
        <trans-unit id="37536a1d3cc9b23bf2b06cce0eca23c6a4e7e102" translate="yes" xml:space="preserve">
          <source>Circus Tent</source>
          <target state="translated">马戏团帐篷</target>
        </trans-unit>
        <trans-unit id="2db191558345453d3d04631fffed018826e9442e" translate="yes" xml:space="preserve">
          <source>Cityscape At Dusk</source>
          <target state="translated">黄昏的城市景观</target>
        </trans-unit>
        <trans-unit id="4010aa5c7daa771d33be51467b1f2b3303269a35" translate="yes" xml:space="preserve">
          <source>Clamp &lt;code&gt;x&lt;/code&gt; between &lt;code&gt;typemin(T)&lt;/code&gt; and &lt;code&gt;typemax(T)&lt;/code&gt; and convert the result to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cf0a77f6ee3236fe15d4a64163013e4f57ac86" translate="yes" xml:space="preserve">
          <source>Clapper Board</source>
          <target state="translated">挡板</target>
        </trans-unit>
        <trans-unit id="1a53c684edaeea21a3a7c9865bbc7c7a6b647d98" translate="yes" xml:space="preserve">
          <source>Clapping Hands Sign</source>
          <target state="translated">拍手势</target>
        </trans-unit>
        <trans-unit id="516efc45347d5f1d25705370de6f7e8790454c94" translate="yes" xml:space="preserve">
          <source>Clear any existing backtraces from the internal buffer.</source>
          <target state="translated">从内部缓冲区中清除现有的回溯。</target>
        </trans-unit>
        <trans-unit id="82280dd39a2e304ec7a95875634d07334aea409a" translate="yes" xml:space="preserve">
          <source>Clear console screen</source>
          <target state="translated">清除控制台屏幕</target>
        </trans-unit>
        <trans-unit id="fb1b9ef26d7247fef7acad9f0bc4d393aa69d604" translate="yes" xml:space="preserve">
          <source>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</source>
          <target state="translated">显然,这与数学整数的行为方式相去甚远,你可能会认为高级编程语言向用户暴露这一点并不理想。然而,对于效率和透明度都很重要的数值工作来说,替代方案更糟糕。</target>
        </trans-unit>
        <trans-unit id="ec4842b9335f240ce519c3e7eb35a6d7dd134038" translate="yes" xml:space="preserve">
          <source>Clears any stored memory allocation data when running julia with &lt;code&gt;--track-allocation&lt;/code&gt;. Execute the command(s) you want to test (to force JIT-compilation), then call &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;clear_malloc_data&lt;/code&gt;&lt;/a&gt;. Then execute your command(s) again, quit Julia, and examine the resulting &lt;code&gt;*.mem&lt;/code&gt; files.</source>
          <target state="translated">使用 &lt;code&gt;--track-allocation&lt;/code&gt; 运行julia时，清除所有存储的内存分配数据。执行要测试的命令（强制进行JIT编译），然后调用&lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;clear_malloc_data&lt;/code&gt; &lt;/a&gt;。然后再次执行您的命令，退出Julia，然后检查生成的 &lt;code&gt;*.mem&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f1508fb36867e2dc32f615b5c14b90813384914e" translate="yes" xml:space="preserve">
          <source>Clears global bindings in modules by initializing them to &lt;code&gt;nothing&lt;/code&gt;. &lt;code&gt;syms&lt;/code&gt; should be of type &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; or a collection of &lt;code&gt;Symbol&lt;/code&gt;s . &lt;code&gt;pids&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under &lt;code&gt;mod&lt;/code&gt; are cleared.</source>
          <target state="translated">它们初始化为清除模块全局绑定 &lt;code&gt;nothing&lt;/code&gt; 。 &lt;code&gt;syms&lt;/code&gt; 应类型的&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;或集合 &lt;code&gt;Symbol&lt;/code&gt; 秒。 &lt;code&gt;pids&lt;/code&gt; 和 &lt;code&gt;mod&lt;/code&gt; 标识将在其中重新初始化全局变量的进程和模块。仅清除那些在 &lt;code&gt;mod&lt;/code&gt; 下定义的名称。</target>
        </trans-unit>
        <trans-unit id="4a37999e16f7842ef3bf129008cd89f6cdc6cb0f" translate="yes" xml:space="preserve">
          <source>Clinking Beer Mugs</source>
          <target state="translated">叮叮当当的啤酒杯</target>
        </trans-unit>
        <trans-unit id="5efe0c9323a499a8546aeac42d4b659bd2a4039f" translate="yes" xml:space="preserve">
          <source>Clipboard</source>
          <target state="translated">Clipboard</target>
        </trans-unit>
        <trans-unit id="80b2a110ce7d7c4741fab08718b7b0bad1a6e22a" translate="yes" xml:space="preserve">
          <source>Clock Face Eight Oclock</source>
          <target state="translated">八点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="890e9e574fe3a811e9c99a391d98d07a63fc0336" translate="yes" xml:space="preserve">
          <source>Clock Face Eight-Thirty</source>
          <target state="translated">钟面八点半</target>
        </trans-unit>
        <trans-unit id="a9b707e0c691e0552e2f8bc3916fe311413cb1c1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven Oclock</source>
          <target state="translated">时钟面11点钟方向</target>
        </trans-unit>
        <trans-unit id="8ae5c10b2e512ab4d1e9f3ac4882a5accd7c7ae1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven-Thirty</source>
          <target state="translated">钟面11点半</target>
        </trans-unit>
        <trans-unit id="e22dfa89a765cf1fb21d2f5d1bc38f3ade0afd76" translate="yes" xml:space="preserve">
          <source>Clock Face Five Oclock</source>
          <target state="translated">五点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="3a7136e9fc05d844d8d22ef7e7a4065f750e1bbb" translate="yes" xml:space="preserve">
          <source>Clock Face Five-Thirty</source>
          <target state="translated">钟面五点半</target>
        </trans-unit>
        <trans-unit id="6c604425f0ef3b9a4e6a798a11e9cb980c5f5643" translate="yes" xml:space="preserve">
          <source>Clock Face Four Oclock</source>
          <target state="translated">钟面四时位置</target>
        </trans-unit>
        <trans-unit id="1d7bba61675982358fbf74be54ea171922d5d085" translate="yes" xml:space="preserve">
          <source>Clock Face Four-Thirty</source>
          <target state="translated">钟面四点半</target>
        </trans-unit>
        <trans-unit id="8effbf7e8f00a8276bde132d10680427c2d5ec2c" translate="yes" xml:space="preserve">
          <source>Clock Face Nine Oclock</source>
          <target state="translated">九点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="b0f219a4f731970988c8def9f6a9220234b63061" translate="yes" xml:space="preserve">
          <source>Clock Face Nine-Thirty</source>
          <target state="translated">钟面九点半</target>
        </trans-unit>
        <trans-unit id="2aa0624b2187d35a495fb74b7a70417ce4d8cdc6" translate="yes" xml:space="preserve">
          <source>Clock Face One Oclock</source>
          <target state="translated">时钟面 一点钟方向</target>
        </trans-unit>
        <trans-unit id="92624a0e738083d85292206e98f359ce3546ed05" translate="yes" xml:space="preserve">
          <source>Clock Face One-Thirty</source>
          <target state="translated">时钟面 1-30</target>
        </trans-unit>
        <trans-unit id="4ee4d2dec1cb5fcd6697bd397977fe18c3d4992c" translate="yes" xml:space="preserve">
          <source>Clock Face Seven Oclock</source>
          <target state="translated">七点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="17aef1804b57cd3ede0fe80570334485de56eaea" translate="yes" xml:space="preserve">
          <source>Clock Face Seven-Thirty</source>
          <target state="translated">钟面七点半</target>
        </trans-unit>
        <trans-unit id="f2ce5a71eefd68ceefa6e2f6811d47032f42f6eb" translate="yes" xml:space="preserve">
          <source>Clock Face Six Oclock</source>
          <target state="translated">六点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="78a9100a5f02623dca735f3dacc48fead261c2cd" translate="yes" xml:space="preserve">
          <source>Clock Face Six-Thirty</source>
          <target state="translated">钟面六点半</target>
        </trans-unit>
        <trans-unit id="29ed028a4b2d7ccf27a87e9aa08dd08fd6ebb1a6" translate="yes" xml:space="preserve">
          <source>Clock Face Ten Oclock</source>
          <target state="translated">十点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="288b3a0678ebc38844da6df6f1e87880c74baafc" translate="yes" xml:space="preserve">
          <source>Clock Face Ten-Thirty</source>
          <target state="translated">钟面十点半</target>
        </trans-unit>
        <trans-unit id="bb465de467c2b010bb6b846eb78c2a1229522242" translate="yes" xml:space="preserve">
          <source>Clock Face Three Oclock</source>
          <target state="translated">三点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="cfd958f3c422c51d841c78b6b7f3d9e44fc3ad75" translate="yes" xml:space="preserve">
          <source>Clock Face Three-Thirty</source>
          <target state="translated">钟面三点半</target>
        </trans-unit>
        <trans-unit id="7f669cae21a33d00c881936310a0c78e765a67d2" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve Oclock</source>
          <target state="translated">十二点钟面</target>
        </trans-unit>
        <trans-unit id="1ef2e813447d172d893056c5340a57fc6839f314" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve-Thirty</source>
          <target state="translated">十二点半钟面</target>
        </trans-unit>
        <trans-unit id="4f6902106020e062d23dd43ecf72cd67020b6c3e" translate="yes" xml:space="preserve">
          <source>Clock Face Two Oclock</source>
          <target state="translated">两点钟方向的钟面</target>
        </trans-unit>
        <trans-unit id="bcda9b95a7f9d026cc96f88e4ef6597b3948c3f5" translate="yes" xml:space="preserve">
          <source>Clock Face Two-Thirty</source>
          <target state="translated">钟面二点半</target>
        </trans-unit>
        <trans-unit id="3343394a9f3b65dd62d440bfd227fa40ca3918a2" translate="yes" xml:space="preserve">
          <source>Clockwise Contour Integral</source>
          <target state="translated">顺时针等高线整体式</target>
        </trans-unit>
        <trans-unit id="bef25f4fbfeb987aed2d95c207d8122fa87692e3" translate="yes" xml:space="preserve">
          <source>Clockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">顺时针向下和向上的开放圆箭头</target>
        </trans-unit>
        <trans-unit id="b8015a573f0320267e05a1e6968f148a65bd38e5" translate="yes" xml:space="preserve">
          <source>Clockwise Integral</source>
          <target state="translated">顺时针整体式</target>
        </trans-unit>
        <trans-unit id="7dcd16fa461353aaddde398802c410edb65684a9" translate="yes" xml:space="preserve">
          <source>Clockwise Open Circle Arrow</source>
          <target state="translated">顺时针开环箭头</target>
        </trans-unit>
        <trans-unit id="0de2e9fdaa78d1a87383fa303df054177c3eef28" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows</source>
          <target state="translated">顺时针向右和向左开圆箭头</target>
        </trans-unit>
        <trans-unit id="78f3f16a08531e7f8a413160ff88e095df7562f2" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay</source>
          <target state="translated">顺时针向右和向左开放的圆圈箭头与圆圈一叠加。</target>
        </trans-unit>
        <trans-unit id="5a2532914552dd4a4df03ca6c532a1cda0ad9c3e" translate="yes" xml:space="preserve">
          <source>Clockwise Top Semicircle Arrow</source>
          <target state="translated">顺时针上半圆箭头</target>
        </trans-unit>
        <trans-unit id="bd5a088aabea6d4dfe11cc8a8a32a9c1483fc8dd" translate="yes" xml:space="preserve">
          <source>Clone a remote repository located at &lt;code&gt;repo_url&lt;/code&gt; to the local filesystem location &lt;code&gt;repo_path&lt;/code&gt;.</source>
          <target state="translated">将位于 &lt;code&gt;repo_url&lt;/code&gt; 的远程存储库克隆到本地文件系统位置 &lt;code&gt;repo_path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c018fd37cc98046cd18021dbc1501935677a8d0b" translate="yes" xml:space="preserve">
          <source>Clone the remote repository at &lt;code&gt;repo_url&lt;/code&gt; (which can be a remote URL or a path on the local filesystem) to &lt;code&gt;repo_path&lt;/code&gt; (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt;&lt;code&gt;CloneOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将远程存储库中的 &lt;code&gt;repo_url&lt;/code&gt; （可以是远程URL或本地文件系统上的路径） &lt;code&gt;repo_path&lt;/code&gt; 到repo_path（必须是本地文件系统上的路径）。克隆选项（例如是否执行裸克隆）由&lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt; &lt;code&gt;CloneOptions&lt;/code&gt; &lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="03c26d678d2b5f993e8a4888363c7faf8f7499f8" translate="yes" xml:space="preserve">
          <source>Clong</source>
          <target state="translated">Clong</target>
        </trans-unit>
        <trans-unit id="ba9c34e2f3436e5d9b8a5291e72a776889a2ff30" translate="yes" xml:space="preserve">
          <source>Clonglong</source>
          <target state="translated">Clonglong</target>
        </trans-unit>
        <trans-unit id="b5209dad4d3f1bed9db6402ecbcc5727437490f8" translate="yes" xml:space="preserve">
          <source>Close a channel. An exception (optionally given by &lt;code&gt;excp&lt;/code&gt;), is thrown by:</source>
          <target state="translated">关闭频道。引发异常（可选地由 &lt;code&gt;excp&lt;/code&gt; 给出）：</target>
        </trans-unit>
        <trans-unit id="10c5d49bb09afa0ca8e3334711e18326dcf891af" translate="yes" xml:space="preserve">
          <source>Close an I/O stream. Performs a &lt;a href=&quot;#Base.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">关闭I / O流。首先执行&lt;a href=&quot;#Base.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="454adf74b3f6704e85f70c7ddf537bda059f03dd" translate="yes" xml:space="preserve">
          <source>Close shared library referenced by handle.</source>
          <target state="translated">关闭句柄引用的共享库。</target>
        </trans-unit>
        <trans-unit id="8170fa95b5dabb39e3ab1424d8d01e1c3b92e425" translate="yes" xml:space="preserve">
          <source>Closed Book</source>
          <target state="translated">闭卷</target>
        </trans-unit>
        <trans-unit id="f01ec4341502afd5ff0fd4449550b0f2d821118a" translate="yes" xml:space="preserve">
          <source>Closed Intersection With Serifs</source>
          <target state="translated">封闭式十字路口,有衬线</target>
        </trans-unit>
        <trans-unit id="f96d5b0a19b4b209a04614ed2d984814137842d3" translate="yes" xml:space="preserve">
          <source>Closed Lock With Key</source>
          <target state="translated">带钥匙的封闭锁</target>
        </trans-unit>
        <trans-unit id="fc6222181031539686fbc1981c6536202f4eebfd" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Lowered Flag</source>
          <target state="translated">关闭的邮箱,旗帜降低</target>
        </trans-unit>
        <trans-unit id="675cf6fab44f887f9851bda94e48adbe87600a21" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Raised Flag</source>
          <target state="translated">封闭式信箱与升旗</target>
        </trans-unit>
        <trans-unit id="deb82abc2edb75e5d2559fdc5e14496f68ebe0bb" translate="yes" xml:space="preserve">
          <source>Closed Subset</source>
          <target state="translated">封闭子集</target>
        </trans-unit>
        <trans-unit id="27f828ad61dfe0b96ce6597aa9645041a206cb0a" translate="yes" xml:space="preserve">
          <source>Closed Subset Or Equal To</source>
          <target state="translated">封闭子集或等于</target>
        </trans-unit>
        <trans-unit id="9ca1f162310be3f8fde01956aa333063b943a628" translate="yes" xml:space="preserve">
          <source>Closed Superset</source>
          <target state="translated">封闭式超集</target>
        </trans-unit>
        <trans-unit id="c1a77c6e35a02621888adfea720e18df739c611e" translate="yes" xml:space="preserve">
          <source>Closed Superset Or Equal To</source>
          <target state="translated">封闭式超集或等于</target>
        </trans-unit>
        <trans-unit id="1d0ef3df97ab3df50e949a9a1324005eda6b8edb" translate="yes" xml:space="preserve">
          <source>Closed Umbrella</source>
          <target state="translated">封闭式雨伞</target>
        </trans-unit>
        <trans-unit id="2509ab5953079af2e5239350a2c4c20c24bf4b87" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs</source>
          <target state="translated">带有衬线的封闭式联盟</target>
        </trans-unit>
        <trans-unit id="f8612daffee734ab8fe7ac27e4779293f47bd9f2" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs And Smash Product</source>
          <target state="translated">封闭式联盟与衬线和粉碎式产品</target>
        </trans-unit>
        <trans-unit id="6d5a3633bf3066d6ab42acadf4720d0c57381f8b" translate="yes" xml:space="preserve">
          <source>Closing a Library</source>
          <target state="translated">关闭图书馆</target>
        </trans-unit>
        <trans-unit id="aaaf708c53d56650e9ea07591d01dc353b945138" translate="yes" xml:space="preserve">
          <source>Closure &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a1d4177a6fdb9b5f67b13428352c7562697b82" translate="yes" xml:space="preserve">
          <source>Closure cfunctions</source>
          <target state="translated">闭合功能</target>
        </trans-unit>
        <trans-unit id="b2efeaa1a7d6d2185ea02473cf758203dfcea3fe" translate="yes" xml:space="preserve">
          <source>Cloud</source>
          <target state="translated">Cloud</target>
        </trans-unit>
        <trans-unit id="ac3f2b0304dbad8004f320d418e21b773f559bef" translate="yes" xml:space="preserve">
          <source>Cluster Cookie</source>
          <target state="translated">簇状饼干</target>
        </trans-unit>
        <trans-unit id="2719f92d9319470b062026857b1b798355606f18" translate="yes" xml:space="preserve">
          <source>Cluster Manager Interface</source>
          <target state="translated">集群管理界面</target>
        </trans-unit>
        <trans-unit id="24b40ea7b4c6d2a2754b767ef66941a1b621105f" translate="yes" xml:space="preserve">
          <source>Cluster Managers with Custom Transports</source>
          <target state="translated">具有自定义传输的群集管理器</target>
        </trans-unit>
        <trans-unit id="c66ed07e93160ccf42e9560935c19321d18456bf" translate="yes" xml:space="preserve">
          <source>ClusterManagers</source>
          <target state="translated">ClusterManagers</target>
        </trans-unit>
        <trans-unit id="36a5cc40f84a6918339448f7f9c84d698b78ed22" translate="yes" xml:space="preserve">
          <source>Cmd</source>
          <target state="translated">Cmd</target>
        </trans-unit>
        <trans-unit id="598ac4d5aadd51518cf7408c7b09c93d77fd77bc" translate="yes" xml:space="preserve">
          <source>Cocktail Glass</source>
          <target state="translated">鸡尾酒杯</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="a99f20e7919aa57d6d229cdc49d476b887823796" translate="yes" xml:space="preserve">
          <source>Code Availability and Loading Packages</source>
          <target state="translated">代码可用性和加载包</target>
        </trans-unit>
        <trans-unit id="d0078b16e6e193ac2fab2fcfbc625d4cc9fdb7f5" translate="yes" xml:space="preserve">
          <source>Code Generation</source>
          <target state="translated">代码生成</target>
        </trans-unit>
        <trans-unit id="f24dc61405e4a6ac1922198818e95b7dcd3db014" translate="yes" xml:space="preserve">
          <source>Code Loading</source>
          <target state="translated">代码加载</target>
        </trans-unit>
        <trans-unit id="b69ba088ce9ad1ce235332dd2372fe802609e0da" translate="yes" xml:space="preserve">
          <source>Code blocks</source>
          <target state="translated">代码块</target>
        </trans-unit>
        <trans-unit id="42113fe2d252dc34afb2007f91d2f4059784abe7" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a9d7c94aa1ad1ba8632efb3563e42b2453a554" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules-1&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">代码包含非常简单明了：它在调用者的上下文中评估给定的源文件。程序包加载建立在代码包含的基础上，并具有&lt;a href=&quot;../modules/index#modules-1&quot;&gt;不同的用途&lt;/a&gt;。本章的其余部分重点介绍软件包加载的行为和机制。</target>
        </trans-unit>
        <trans-unit id="35b9be6a9b072a2d90be1ca50990262602cae797" translate="yes" xml:space="preserve">
          <source>Code point(s)</source>
          <target state="translated">代码点</target>
        </trans-unit>
        <trans-unit id="33284c9a71b782e3478512a7869d4dc33c4b362d" translate="yes" xml:space="preserve">
          <source>Code should be as generic as possible. Instead of writing:</source>
          <target state="translated">代码应该尽可能的通用。而不是写。</target>
        </trans-unit>
        <trans-unit id="aae5cfaaacaac3a30cf57079dd346c86a7f7fc5e" translate="yes" xml:space="preserve">
          <source>Code using immutable objects can be easier to reason about.</source>
          <target state="translated">使用不可变对象的代码可以更容易推理。</target>
        </trans-unit>
        <trans-unit id="80674c31d4ab113b84f8bfda79f90e7c65f5531a" translate="yes" xml:space="preserve">
          <source>Collect a list of log records generated by &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;collect_test_logs&lt;/code&gt;, check that they match the sequence &lt;code&gt;log_patterns&lt;/code&gt;, and return the value of &lt;code&gt;expression&lt;/code&gt;. The &lt;code&gt;keywords&lt;/code&gt; provide some simple filtering of log records: the &lt;code&gt;min_level&lt;/code&gt; keyword controls the minimum log level which will be collected for the test, the &lt;code&gt;match_mode&lt;/code&gt; keyword defines how matching will be performed (the default &lt;code&gt;:all&lt;/code&gt; checks that all logs and patterns match pairwise; use &lt;code&gt;:any&lt;/code&gt; to check that the pattern matches at least once somewhere in the sequence.)</source>
          <target state="translated">使用 &lt;code&gt;collect_test_logs&lt;/code&gt; 收集由 &lt;code&gt;expression&lt;/code&gt; 生成的日志记录列表，检查它们是否与序列 &lt;code&gt;log_patterns&lt;/code&gt; 相匹配，然后返回 &lt;code&gt;expression&lt;/code&gt; 的值。的 &lt;code&gt;keywords&lt;/code&gt; 提供的日志记录一些简单的过滤：所述 &lt;code&gt;min_level&lt;/code&gt; 关键字控制哪些将被收集在测试中，最小日志级别 &lt;code&gt;match_mode&lt;/code&gt; 关键字定义匹配将如何被执行（缺省 &lt;code&gt;:all&lt;/code&gt; 检查的所有日志和模式匹配成对;使用 &lt;code&gt;:any&lt;/code&gt; ,以检查模式是否在序列中的某处至少匹配一次。）</target>
        </trans-unit>
        <trans-unit id="0a8af36fa1d1619f2da90f35bd9c11b35a37e433" translate="yes" xml:space="preserve">
          <source>Collect information about the status of each file in the git repository &lt;code&gt;repo&lt;/code&gt; (e.g. is the file modified, staged, etc.). &lt;code&gt;status_opts&lt;/code&gt; can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt;&lt;code&gt;StatusOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">每个文件在git仓库状态收集信息 &lt;code&gt;repo&lt;/code&gt; （例如是修改的文件，上演等）。 &lt;code&gt;status_opts&lt;/code&gt; 可用于设置各种选项，例如是否查看未跟踪的文件或是否包含子模块。有关更多信息，请参见&lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt; &lt;code&gt;StatusOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e2ef8c695440679e7d61620a3e6f58db57bb36f" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="translated">集合和数据结构</target>
        </trans-unit>
        <trans-unit id="b600a07f6e2a178ebfbe565ac70dc1d11d80d058" translate="yes" xml:space="preserve">
          <source>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)</source>
          <target state="translated">传递给函数的集合也不会被复制。函数可以修改(突变)其参数所指向的对象的内容。(这样做的函数名称通常以'!'为后缀)。</target>
        </trans-unit>
        <trans-unit id="7a2802907d31a8ef64806a9e6c2120bb1e4caacf" translate="yes" xml:space="preserve">
          <source>Collision Symbol</source>
          <target state="translated">碰撞符号</target>
        </trans-unit>
        <trans-unit id="ac30df75efbedb8442edcd22700caca733d79868" translate="yes" xml:space="preserve">
          <source>Colon</source>
          <target state="translated">Colon</target>
        </trans-unit>
        <trans-unit id="0a14c37ba89fcb5b7168d9ef916ce4e00e67937f" translate="yes" xml:space="preserve">
          <source>Colon Equals / Colon Equal</source>
          <target state="translated">冒号等于/冒号等于</target>
        </trans-unit>
        <trans-unit id="bb11dae2a053933f6bc7422a2373bf8281b97e57" translate="yes" xml:space="preserve">
          <source>Colons (:) are used to signify indexing entire objects or dimensions at once.</source>
          <target state="translated">冒号(:)用来表示一次索引整个对象或尺寸。</target>
        </trans-unit>
        <trans-unit id="f95263d15db043d5d52856caad1fadeda6d1c2bc" translate="yes" xml:space="preserve">
          <source>Combinatorics</source>
          <target state="translated">Combinatorics</target>
        </trans-unit>
        <trans-unit id="5350d59289c3e9b699c68a850143c7c2aca47e8e" translate="yes" xml:space="preserve">
          <source>Combined inplace matrix-matrix or matrix-vector multiply-add $A B &amp;alpha; + C &amp;beta;$. The result is stored in &lt;code&gt;C&lt;/code&gt; by overwriting it. Note that &lt;code&gt;C&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173cad0d0654b3f6eb52faa1ce6c93b0376b3f89" translate="yes" xml:space="preserve">
          <source>Combined multiply-add: computes &lt;code&gt;x*y+z&lt;/code&gt;, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt; if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">组合乘法-加法：计算 &lt;code&gt;x*y+z&lt;/code&gt; ，但允许将加法和乘法彼此合并或与周围的运算合并以提高性能。例如，如果硬件有效地支持它，则可以将其实现为&lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt;。由于不断传播或其他优化，结果在不同的计算机上可能会有所不同，在同一台计算机上也可能会有所不同。参见&lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4f01a71c42b25ea3da620732f8db11437dd099b" translate="yes" xml:space="preserve">
          <source>Combining Acute Accent / Non-Spacing Acute</source>
          <target state="translated">合并急性重音/非间隔性急性重音。</target>
        </trans-unit>
        <trans-unit id="0734b67961e0eb56239f8b7b60c539fb6834880e" translate="yes" xml:space="preserve">
          <source>Combining Annuity Symbol</source>
          <target state="translated">组合年金符号</target>
        </trans-unit>
        <trans-unit id="95ae63a999d098981e7621ee2008c43b0f6a60c6" translate="yes" xml:space="preserve">
          <source>Combining Asterisk Above</source>
          <target state="translated">结合上面的星号</target>
        </trans-unit>
        <trans-unit id="685cd2e09ad265192e0356f28e46509d84ab4d71" translate="yes" xml:space="preserve">
          <source>Combining Breve / Non-Spacing Breve</source>
          <target state="translated">组合式布雷夫/非间隔式布雷夫。</target>
        </trans-unit>
        <trans-unit id="8e2be6c64a88e84a6f429cab4bdb53ba4fe80660" translate="yes" xml:space="preserve">
          <source>Combining Bridge Below / Non-Spacing Bridge Below</source>
          <target state="translated">组合式桥下/非间隔式桥下。</target>
        </trans-unit>
        <trans-unit id="a3f38dbfee0a0277b8fc6dd5b6eb831595bf84a0" translate="yes" xml:space="preserve">
          <source>Combining Candrabindu / Non-Spacing Candrabindu</source>
          <target state="translated">合并坎德拉宾都/非间隔坎德拉宾都。</target>
        </trans-unit>
        <trans-unit id="8aff768b42edc639adecd3dd04d42d7aed791251" translate="yes" xml:space="preserve">
          <source>Combining Caron / Non-Spacing Hacek</source>
          <target state="translated">结合卡隆/无间隔的Hacek。</target>
        </trans-unit>
        <trans-unit id="3c4e117dd5db64357d4d73eb9cdd1ba25f04fdb1" translate="yes" xml:space="preserve">
          <source>Combining Cedilla / Non-Spacing Cedilla</source>
          <target state="translated">合并Cedilla/非间隔Cedilla。</target>
        </trans-unit>
        <trans-unit id="91f0dba538ac66d644d07a8387e2e7e115f196c5" translate="yes" xml:space="preserve">
          <source>Combining Circumflex Accent / Non-Spacing Circumflex</source>
          <target state="translated">合并环形弯曲口音/非间隔环形弯曲口音</target>
        </trans-unit>
        <trans-unit id="a43cbdb97b8f699aa2f8714ed59973b90ec0f295" translate="yes" xml:space="preserve">
          <source>Combining Comma Above Right / Non-Spacing Comma Above Right</source>
          <target state="translated">右上方的组合逗号/右上方的无间隔逗号。</target>
        </trans-unit>
        <trans-unit id="a33ec808d6857cd58bedcf6f6f9afde52f57d4fd" translate="yes" xml:space="preserve">
          <source>Combining Diaeresis / Non-Spacing Diaeresis</source>
          <target state="translated">组合式透析/非间隔式透析。</target>
        </trans-unit>
        <trans-unit id="becaf6a97e81c19ea9f31b976c527ddc1bbea3ee" translate="yes" xml:space="preserve">
          <source>Combining Dot Above / Non-Spacing Dot Above</source>
          <target state="translated">上面的组合点/上面的非间隔点</target>
        </trans-unit>
        <trans-unit id="d95e2893d2008e3fc0c1b9bc24115f37f1791066" translate="yes" xml:space="preserve">
          <source>Combining Double Acute Accent / Non-Spacing Double Acute</source>
          <target state="translated">组合式双锐口音/非间隔式双锐口音。</target>
        </trans-unit>
        <trans-unit id="f08f92ba4b2bb682dc3e2d5e9c8df57b5dedb3f6" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Circle / Enclosing Circle</source>
          <target state="translated">组合包围圈/包围圈。</target>
        </trans-unit>
        <trans-unit id="83f22c6a001242a5a561f3a7895cf7d7aaaebd0b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Diamond / Enclosing Diamond</source>
          <target state="translated">组合封闭式金刚石/封闭式金刚石。</target>
        </trans-unit>
        <trans-unit id="ec76e2f012d98e1337784adeec747df1b78cf15b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Square / Enclosing Square</source>
          <target state="translated">组合式围合方块/围合方块</target>
        </trans-unit>
        <trans-unit id="efc364102d3ca81f092b677aca701ad08ab10de7" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Upward Pointing Triangle</source>
          <target state="translated">合并包围上翘三角形</target>
        </trans-unit>
        <trans-unit id="22bab50c74edd0eb4d138ac01ac71ba994064528" translate="yes" xml:space="preserve">
          <source>Combining Four Dots Above / Non-Spacing Four Dots Above</source>
          <target state="translated">以上四点组合/以上四点非间隔组合</target>
        </trans-unit>
        <trans-unit id="38e73c84dac801257b0f5e15b8402de9de60fd4a" translate="yes" xml:space="preserve">
          <source>Combining Grave Accent / Non-Spacing Grave</source>
          <target state="translated">墓穴组合/非间隔式墓穴</target>
        </trans-unit>
        <trans-unit id="fb49a0f3994aaa3fea7e9d53f4e24c6dd93638a6" translate="yes" xml:space="preserve">
          <source>Combining Hook Above / Non-Spacing Hook Above</source>
          <target state="translated">上面的组合钩/上面的非间隔钩。</target>
        </trans-unit>
        <trans-unit id="4cb010ffd9ffa4a05013b3488b30c23afb01fdf1" translate="yes" xml:space="preserve">
          <source>Combining Left Angle Above / Non-Spacing Left Angle Above</source>
          <target state="translated">上方组合左角/上方无间隔左角组合</target>
        </trans-unit>
        <trans-unit id="08e42cf0385a0528419967690402d2f77fea8ecf" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Above / Non-Spacing Left Arrow Above</source>
          <target state="translated">上面的左箭头组合/上面的非间隔左箭头组合</target>
        </trans-unit>
        <trans-unit id="877d024a8659b4afa7238332933b7ad143528441" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Below</source>
          <target state="translated">组合左箭头下方</target>
        </trans-unit>
        <trans-unit id="8e6257e591a7e8d45ef0764ba2aea89c01420024" translate="yes" xml:space="preserve">
          <source>Combining Left Harpoon Above / Non-Spacing Left Harpoon Above</source>
          <target state="translated">组合式左鱼叉上方/非间隔式左鱼叉上方。</target>
        </trans-unit>
        <trans-unit id="98b334c8eb46b8b78fdd86ea856a3c01a529a309" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above</source>
          <target state="translated">上面的左右箭头组合/上面的左右箭头无间隔组合</target>
        </trans-unit>
        <trans-unit id="cedc5fa73afb530ac1a47e52244635331691700e" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Below</source>
          <target state="translated">左右组合下面的箭头</target>
        </trans-unit>
        <trans-unit id="3ecd111368eb8e38f96414851bb4b26f50509766" translate="yes" xml:space="preserve">
          <source>Combining Leftwards Harpoon With Barb Downwards</source>
          <target state="translated">向左的鱼叉与向下的倒钩相结合。</target>
        </trans-unit>
        <trans-unit id="0dfea306ba6d2c2199ba2e9e71aebfc34b9abf34" translate="yes" xml:space="preserve">
          <source>Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="9f887140bfcfd6f9e5fb967ba98a3207c8b16bb7" translate="yes" xml:space="preserve">
          <source>Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay</source>
          <target state="translated">组合式长条叠加/无间隔长条叠加。</target>
        </trans-unit>
        <trans-unit id="739259d807921f9f328b7781ee790a60e450a0a1" translate="yes" xml:space="preserve">
          <source>Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay</source>
          <target state="translated">组合长竖线叠加/无间隔长竖条叠加。</target>
        </trans-unit>
        <trans-unit id="2fa244bc31952195840fcfc3a299980dbf801f6f" translate="yes" xml:space="preserve">
          <source>Combining Low Line / Non-Spacing Underscore</source>
          <target state="translated">结合低线/无间隔的下划线。</target>
        </trans-unit>
        <trans-unit id="bf4b2a4b27fa69268427f002d7db69ac9dc2b07c" translate="yes" xml:space="preserve">
          <source>Combining Macron / Non-Spacing Macron</source>
          <target state="translated">组合Macron/无间隔Macron</target>
        </trans-unit>
        <trans-unit id="a27d4c9bf29370f4faabca36676f0b74743a74d7" translate="yes" xml:space="preserve">
          <source>Combining Ogonek / Non-Spacing Ogonek</source>
          <target state="translated">组合式Ogonek/非间隔式Ogonek。</target>
        </trans-unit>
        <trans-unit id="6d0be0f1d7e1edefb9f72a94ba4677970ba978c9" translate="yes" xml:space="preserve">
          <source>Combining Overline / Non-Spacing Overscore</source>
          <target state="translated">合并超线/无间隔超分。</target>
        </trans-unit>
        <trans-unit id="7fad7b377dc7ab955143e3c864e92020afd810c8" translate="yes" xml:space="preserve">
          <source>Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below</source>
          <target state="translated">合并下腭钩/非间隔下腭钩。</target>
        </trans-unit>
        <trans-unit id="a8de9e264b7b283c54023c71a0b50c54c5639e6e" translate="yes" xml:space="preserve">
          <source>Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below</source>
          <target state="translated">组合式折返钩下部/非间隔式折返钩下部。</target>
        </trans-unit>
        <trans-unit id="2ba0d1fd66790c9bf8dd50de28c5fd6f05110ed4" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Above / Non-Spacing Right Arrow Above</source>
          <target state="translated">上面的组合右箭头/上面的非间隔右箭头。</target>
        </trans-unit>
        <trans-unit id="8a30e8c07ae1959f3cd09497d8080f6227316b77" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Below</source>
          <target state="translated">结合下面的右箭头</target>
        </trans-unit>
        <trans-unit id="4befcc9e0a743f1dd40b3e9e50041b9252baebcb" translate="yes" xml:space="preserve">
          <source>Combining Right Harpoon Above / Non-Spacing Right Harpoon Above</source>
          <target state="translated">上面的组合右鱼叉/上面的非间隔右鱼叉。</target>
        </trans-unit>
        <trans-unit id="aeddc0f0eef5dd1ae0bb9d2d0caf8ade2b689afe" translate="yes" xml:space="preserve">
          <source>Combining Rightwards Harpoon With Barb Downwards</source>
          <target state="translated">向右的鱼叉与向下的倒钩相结合。</target>
        </trans-unit>
        <trans-unit id="59a9a29108a67d4f908b40c8ecffadfd41391c2c" translate="yes" xml:space="preserve">
          <source>Combining Ring Above / Non-Spacing Ring Above</source>
          <target state="translated">以上组合环/以上非间隔环。</target>
        </trans-unit>
        <trans-unit id="5111c307faa772b3a9538095159cefe4c37acd0e" translate="yes" xml:space="preserve">
          <source>Combining Three Dots Above / Non-Spacing Three Dots Above</source>
          <target state="translated">以上三点组合/以上非间隔三点组合。</target>
        </trans-unit>
        <trans-unit id="b28cdba8bdbc1c8dbf325c4c84adf50cfa7b9f07" translate="yes" xml:space="preserve">
          <source>Combining Tilde / Non-Spacing Tilde</source>
          <target state="translated">组合式倾角/非间隔式倾角。</target>
        </trans-unit>
        <trans-unit id="415941ac9a1882af5b80885af204940e2087908c" translate="yes" xml:space="preserve">
          <source>Combining Tilde Below / Non-Spacing Tilde Below</source>
          <target state="translated">下方组合式平底锅/下方非间隔式平底锅。</target>
        </trans-unit>
        <trans-unit id="890e5eec0caff7a7e81de77d0eefa045a1434041" translate="yes" xml:space="preserve">
          <source>Combining Triple Underdot</source>
          <target state="translated">三重底点组合</target>
        </trans-unit>
        <trans-unit id="308897e651f5347eeb783d7242b9d33cce1a8f1b" translate="yes" xml:space="preserve">
          <source>Combining Turned Comma Above / Non-Spacing Turned Comma Above</source>
          <target state="translated">合并上面的转折逗号/不间隔的上面的转折逗号。</target>
        </trans-unit>
        <trans-unit id="866e577b99c41379b3aa42c4489796f50fe38cc1" translate="yes" xml:space="preserve">
          <source>Combining Wide Bridge Above</source>
          <target state="translated">组合宽桥以上</target>
        </trans-unit>
        <trans-unit id="88113a7dbb8d79749cd6e0f0600302ccfd5aa3c0" translate="yes" xml:space="preserve">
          <source>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether &lt;code&gt;1.+x&lt;/code&gt; means &lt;code&gt;1. + x&lt;/code&gt; or &lt;code&gt;1 .+ x&lt;/code&gt;. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</source>
          <target state="translated">点运算符与数字文字的组合可能是不明确的。例如，不清楚 &lt;code&gt;1.+x&lt;/code&gt; 是 &lt;code&gt;1. + x&lt;/code&gt; 还是 &lt;code&gt;1 .+ x&lt;/code&gt; 。因此，不允许使用此语法，在这种情况下，必须在运算符周围使用空格。</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="8ddf0393cc298edc03dc88f0719f2655cd0574b7" translate="yes" xml:space="preserve">
          <source>Commit all currently buffered writes to the given stream.</source>
          <target state="translated">将当前所有缓冲的写入提交给给定的流。</target>
        </trans-unit>
        <trans-unit id="a347aae8b8a9fc1e2f6210e5e5378437485857d4" translate="yes" xml:space="preserve">
          <source>Commit the current patch to the rebase &lt;code&gt;rb&lt;/code&gt;, using &lt;code&gt;sig&lt;/code&gt; as the committer. Is silent if the commit has already been applied.</source>
          <target state="translated">使用 &lt;code&gt;sig&lt;/code&gt; 作为提交者，将当前补丁提交到rebase &lt;code&gt;rb&lt;/code&gt; 。如果已应用提交，则保持沉默。</target>
        </trans-unit>
        <trans-unit id="2be9168624323737db43ee381ca8992f9a73de9d" translate="yes" xml:space="preserve">
          <source>Common Operations</source>
          <target state="translated">共同行动</target>
        </trans-unit>
        <trans-unit id="a204c5d42b8380165174afefc8c02b676b132a6b" translate="yes" xml:space="preserve">
          <source>Communicating with Channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66508cd4da8f90000c3284eb64d70b8945911d14" translate="yes" xml:space="preserve">
          <source>Compact WY form of the QR factorization</source>
          <target state="translated">QR因子化的紧凑WY形式</target>
        </trans-unit>
        <trans-unit id="6bf1e82b56d17bf4bd651ed651f5ad4b9fb92d04" translate="yes" xml:space="preserve">
          <source>Compare how these results differ:</source>
          <target state="translated">比较这些结果有何不同。</target>
        </trans-unit>
        <trans-unit id="3937ff70415e32705a844575737929096286a5fd" translate="yes" xml:space="preserve">
          <source>Compare two strings. Return &lt;code&gt;0&lt;/code&gt; if both strings have the same length and the character at each index is the same in both strings. Return &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is a prefix of &lt;code&gt;b&lt;/code&gt;, or if &lt;code&gt;a&lt;/code&gt; comes before &lt;code&gt;b&lt;/code&gt; in alphabetical order. Return &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is a prefix of &lt;code&gt;a&lt;/code&gt;, or if &lt;code&gt;b&lt;/code&gt; comes before &lt;code&gt;a&lt;/code&gt; in alphabetical order (technically, lexicographical order by Unicode code points).</source>
          <target state="translated">比较两个字符串。如果两个字符串的长度相同并且两个字符串中每个索引的字符相同，则返回 &lt;code&gt;0&lt;/code&gt; 。返回 &lt;code&gt;-1&lt;/code&gt; 如果 &lt;code&gt;a&lt;/code&gt; 是一个前缀 &lt;code&gt;b&lt;/code&gt; ，或者如果 &lt;code&gt;a&lt;/code&gt; 到来之前 &lt;code&gt;b&lt;/code&gt; 在字母顺序排列。返回 &lt;code&gt;1&lt;/code&gt; ，如果 &lt;code&gt;b&lt;/code&gt; 是的前缀 &lt;code&gt;a&lt;/code&gt; ，或者如果 &lt;code&gt;b&lt;/code&gt; 到来之前 &lt;code&gt;a&lt;/code&gt; 按字母顺序（从技术上讲，词典编纂顺序由Unicode代码点）。</target>
        </trans-unit>
        <trans-unit id="058bad1213f1f21ce991a75b5be44ee324a930b6" translate="yes" xml:space="preserve">
          <source>Compared to using &lt;a href=&quot;../math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, directly constructing a &lt;code&gt;LinRange&lt;/code&gt; should have less overhead but won't try to correct for floating point errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294837eea456d1d9b5c37c0aa8f59ea86b3c495" translate="yes" xml:space="preserve">
          <source>Comparison &amp;ndash; &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;asymp;&lt;/code&gt; (&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;≉&lt;/code&gt;</source>
          <target state="translated">比较&amp;ndash; &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;asymp;&lt;/code&gt; （&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;）， &lt;code&gt;≉&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfbdf2ba206862934e1703fb9dabae9ccfe529b" translate="yes" xml:space="preserve">
          <source>Comparison with &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;比较</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="a1f782aa0dd22ca1d8ddd5007091a2531356eecb" translate="yes" xml:space="preserve">
          <source>Compile the given function &lt;code&gt;f&lt;/code&gt; for the argument tuple (of types) &lt;code&gt;args&lt;/code&gt;, but do not execute it.</source>
          <target state="translated">为参数元组（类型） &lt;code&gt;args&lt;/code&gt; 编译给定的函数 &lt;code&gt;f&lt;/code&gt; ，但不要执行它。</target>
        </trans-unit>
        <trans-unit id="d208cd655bc27c326dbf72e200351336cfc4e60e" translate="yes" xml:space="preserve">
          <source>Complement</source>
          <target state="translated">Complement</target>
        </trans-unit>
        <trans-unit id="05138c0edd56f7bbbd9cae9c6f481c62b93d161a" translate="yes" xml:space="preserve">
          <source>Completion of paths works for strings and julia's shell mode:</source>
          <target state="translated">完成路径对字符串和julia的shell模式有效。</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="ff549706d081e3e60cc13e4b49b48c707d5b0c58" translate="yes" xml:space="preserve">
          <source>Complex Example</source>
          <target state="translated">复杂的例子</target>
        </trans-unit>
        <trans-unit id="c73def212afdc811169afd7e77aebfbeecb5facc" translate="yes" xml:space="preserve">
          <source>Complex Numbers</source>
          <target state="translated">复数</target>
        </trans-unit>
        <trans-unit id="d92056b9511d12d7ca9a02729b4db7f33b444189" translate="yes" xml:space="preserve">
          <source>Complex and Rational Numbers</source>
          <target state="translated">复数和有理数</target>
        </trans-unit>
        <trans-unit id="4bf180d1d0870c204edb37eb372ac0df5d17b6dd" translate="yes" xml:space="preserve">
          <source>Complex blocks:</source>
          <target state="translated">复杂的区块。</target>
        </trans-unit>
        <trans-unit id="0a73edd8fc9653ee436727fd08c0b9f3b06b1113" translate="yes" xml:space="preserve">
          <source>Complex method &quot;cascades&quot; with default arguments</source>
          <target state="translated">带有默认参数的复杂方法 &quot;级联&quot;。</target>
        </trans-unit>
        <trans-unit id="f9ed4ba22fe6a41d861b48b53689d9f5e1620b3b" translate="yes" xml:space="preserve">
          <source>Complex number type with real and imaginary part of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">复数类型，类型为 &lt;code&gt;T&lt;/code&gt; 的实部和虚部。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="b4dd6b3b31c6eea3e9660b73bc2f3101abdfba71" translate="yes" xml:space="preserve">
          <source>Compose functions: i.e. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; means &lt;code&gt;f(g(args...))&lt;/code&gt;. The &lt;code&gt;∘&lt;/code&gt; symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">编写函数：即 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 表示 &lt;code&gt;f(g(args...))&lt;/code&gt; 。所述 &lt;code&gt;∘&lt;/code&gt; 符号可以在朱REPL（和大多数编辑器，适当地配置）通过打字输入 &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">复合型</target>
        </trans-unit>
        <trans-unit id="df2490ae2d6c4446ef7afd32a3da2e5ee7b69ac4" translate="yes" xml:space="preserve">
          <source>Composite objects declared with &lt;code&gt;struct&lt;/code&gt; are &lt;em&gt;immutable&lt;/em&gt;; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</source>
          <target state="translated">用 &lt;code&gt;struct&lt;/code&gt; 声明的复合对象是&lt;em&gt;不可变的&lt;/em&gt;；它们在构造后无法修改。乍一看这很奇怪，但是它有几个优点：</target>
        </trans-unit>
        <trans-unit id="01e0dcd858e537fe0307f2358a312f03c6681c12" translate="yes" xml:space="preserve">
          <source>Composite types are introduced with the &lt;a href=&quot;../../base/base/index#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; keyword followed by a block of field names, optionally annotated with types using the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">复合类型通过&lt;a href=&quot;../../base/base/index#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;关键字引入，后跟一个字段名称块，可以选择使用 &lt;code&gt;::&lt;/code&gt; 运算符对类型进行注释：</target>
        </trans-unit>
        <trans-unit id="9189e65c24f2bdb8de9b12a05127190c54ae9a3c" translate="yes" xml:space="preserve">
          <source>Composite types such as &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5701f0731819052a01bc826ae56db27fca5211d9" translate="yes" xml:space="preserve">
          <source>Composite types, aka &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">复合类型，也就是C中的 &lt;code&gt;struct&lt;/code&gt; 或Fortran90中的 &lt;code&gt;TYPE&lt;/code&gt; （或F77的某些变体中的 &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; ），可以通过创建具有相同字段布局的 &lt;code&gt;struct&lt;/code&gt; 定义在Julia中进行镜像。</target>
        </trans-unit>
        <trans-unit id="7544d508f3b0902a380eab3d1ae0e5d8d3c1b60c" translate="yes" xml:space="preserve">
          <source>CompositeException</source>
          <target state="translated">CompositeException</target>
        </trans-unit>
        <trans-unit id="79e03922c06b260c57343358b29b8c08b337403a" translate="yes" xml:space="preserve">
          <source>Composition of one function ∘(f) requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29eeb6459e95f17b9e773f8892492e90000d531" translate="yes" xml:space="preserve">
          <source>Compound Expressions</source>
          <target state="translated">复合表达式</target>
        </trans-unit>
        <trans-unit id="3c63c3a24b2a5e684ce3eb80765c227218a808f0" translate="yes" xml:space="preserve">
          <source>Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:</source>
          <target state="translated">提供了复合方法,因为在同时需要多个字段的情况下,这些方法提供了一种效率衡量标准。</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="c10ef362f781785063bbb997cd5031a5191aade1" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e547d2519645c376aaf30ba92bb6080596e3ef5" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">也可以在不包含方括号的情况下编写理解，从而产生称为生成器的对象。可以迭代此对象以根据需要产生值，而不是分配数组并预先存储它们（请参见&lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;）。例如，以下表达式将一个系列求和而不分配内存：</target>
        </trans-unit>
        <trans-unit id="908bf8150b71b44066207c270126a10d2c63b84b" translate="yes" xml:space="preserve">
          <source>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</source>
          <target state="translated">理解提供了一种通用且强大的构造数组的方法。理解语法类似于数学中的集合构造符号。</target>
        </trans-unit>
        <trans-unit id="41931e1bad3441e4fffdabe12a675d7a10ef5fe7" translate="yes" xml:space="preserve">
          <source>Compressed Sparse Column (CSC) Sparse Matrix Storage</source>
          <target state="translated">压缩稀疏列(CSC)稀疏矩阵存储</target>
        </trans-unit>
        <trans-unit id="df6e999370e627bd7fb17556cf85a2f9046d57dd" translate="yes" xml:space="preserve">
          <source>Compute $10^x$.</source>
          <target state="translated">计算10^x元。</target>
        </trans-unit>
        <trans-unit id="3440d15eee03e7b747a1a78d06bc04de26352e6b" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$ if $x \neq 0$, and $0$ if $x = 0$. This is the derivative of &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">如果$ x \ neq 0 $，则计算$ \ cos（\ pi x）/ x-\ sin（\ pi x）/（\ pi x ^ 2）$，如果$ x = 0 $，则计算$ 0 $。这是 &lt;code&gt;sinc(x)&lt;/code&gt; 的导数。</target>
        </trans-unit>
        <trans-unit id="641b97c82ee25690f10e6e7742dc51e5d15732ca" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x)$ more accurately than &lt;code&gt;cos(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">比 &lt;code&gt;cos(pi*x)&lt;/code&gt; 更准确地计算$ \ cos（\ pi x）$ ，尤其是对于大 &lt;code&gt;x&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="1b6e2580104ead79696c9bd035d3ea44c420e327" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x) / (\pi x)$ if $x \neq 0$, and $1$ if $x = 0$.</source>
          <target state="translated">如果$x=0$,计算$sin(/pi x)/(/pi x)$,如果$x=0$,计算$1$。</target>
        </trans-unit>
        <trans-unit id="5609ddf7e7650835bda46710354a43594cc254bb" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x)$ more accurately than &lt;code&gt;sin(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">比 &lt;code&gt;sin(pi*x)&lt;/code&gt; 更精确地计算$ \ sin（\ pi x）$ ，尤其是对于大 &lt;code&gt;x&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="929982bef54c338e6e35e28527b86375aafc50c8" translate="yes" xml:space="preserve">
          <source>Compute $x \times 2^n$.</source>
          <target state="translated">计算$x \times 2^n$。</target>
        </trans-unit>
        <trans-unit id="64de6f27384f256461bed9916267c818d5e5214a" translate="yes" xml:space="preserve">
          <source>Compute $x^p \pmod m$.</source>
          <target state="translated">计算$x^p pmod m$。</target>
        </trans-unit>
        <trans-unit id="19ceaddf89a47393966a49ad36ca860fe7e80321" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A / B&lt;/code&gt; in-place and overwriting &lt;code&gt;A&lt;/code&gt; to store the result.</source>
          <target state="translated">就地计算 &lt;code&gt;A / B&lt;/code&gt; 并覆盖 &lt;code&gt;A&lt;/code&gt; 以存储结果。</target>
        </trans-unit>
        <trans-unit id="7f0218a9f1bc487c2b5096445bf17474b3168d25" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and overwriting &lt;code&gt;B&lt;/code&gt; to store the result.</source>
          <target state="translated">就地计算 &lt;code&gt;A \ B&lt;/code&gt; 并覆盖 &lt;code&gt;B&lt;/code&gt; 以存储结果。</target>
        </trans-unit>
        <trans-unit id="fec3a07dc37940dceabb5be53b362461307a4c1d" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and store the result in &lt;code&gt;Y&lt;/code&gt;, returning the result.</source>
          <target state="translated">就地计算 &lt;code&gt;A \ B&lt;/code&gt; 并将结果存储在 &lt;code&gt;Y&lt;/code&gt; 中，返回结果。</target>
        </trans-unit>
        <trans-unit id="98e6c5fec537a69040a39ae887c67e4d70213543" translate="yes" xml:space="preserve">
          <source>Compute a convenient factorization of &lt;code&gt;A&lt;/code&gt;, based upon the type of the input matrix. &lt;code&gt;factorize&lt;/code&gt; checks &lt;code&gt;A&lt;/code&gt; to see if it is symmetric/triangular/etc. if &lt;code&gt;A&lt;/code&gt; is passed as a generic matrix. &lt;code&gt;factorize&lt;/code&gt; checks every element of &lt;code&gt;A&lt;/code&gt; to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt;.</source>
          <target state="translated">根据输入矩阵的类型，计算 &lt;code&gt;A&lt;/code&gt; 的便捷分解。 &lt;code&gt;factorize&lt;/code&gt; 检查 &lt;code&gt;A&lt;/code&gt; 以查看它是否是对称/三角形/等。如果 &lt;code&gt;A&lt;/code&gt; 作为通用矩阵传递。 &lt;code&gt;factorize&lt;/code&gt; 检查 &lt;code&gt;A&lt;/code&gt; 的每个元素以验证/排除每个属性。一旦排除对称/三角形结构，它将短路。可以将返回值重新用于有效解决多个系统。例如： &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="081b8630c615f09be39d92a0115c25e75916aff0" translate="yes" xml:space="preserve">
          <source>Compute a type that contains the intersection of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;. Usually this will be the smallest such type or one close to it.</source>
          <target state="translated">计算包含 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt; 的交集的类型。通常，这将是最小的此类类型或与其接近的一种。</target>
        </trans-unit>
        <trans-unit id="db62a7195b361bd27a6ab49b26fc5d995d7a85c5" translate="yes" xml:space="preserve">
          <source>Compute an &lt;code&gt;LDLt&lt;/code&gt; factorization of the real symmetric tridiagonal matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is a unit lower triangular matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;.</source>
          <target state="translated">计算实对称三对角矩阵 &lt;code&gt;S&lt;/code&gt; 的 &lt;code&gt;LDLt&lt;/code&gt; 分解，使 &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; ，其中 &lt;code&gt;L&lt;/code&gt; 是单位下三角矩阵， &lt;code&gt;d&lt;/code&gt; 是向量。 &lt;code&gt;LDLt&lt;/code&gt; 因式分解 &lt;code&gt;F = ldlt(S)&lt;/code&gt; 的主要用途是用 &lt;code&gt;F\b&lt;/code&gt; 求解方程 &lt;code&gt;Sx = b&lt;/code&gt; 的线性系统。</target>
        </trans-unit>
        <trans-unit id="5c1ac6c08b678223e4887392c381e9189c7ba93b" translate="yes" xml:space="preserve">
          <source>Compute an integer hash code such that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x)==hash(y)&lt;/code&gt;. The optional second argument &lt;code&gt;h&lt;/code&gt; is a hash code to be mixed with the result.</source>
          <target state="translated">计算整数哈希码，以使 &lt;code&gt;isequal(x,y)&lt;/code&gt; 意味着 &lt;code&gt;hash(x)==hash(y)&lt;/code&gt; 。可选的第二个参数 &lt;code&gt;h&lt;/code&gt; 是要与结果混合的哈希码。</target>
        </trans-unit>
        <trans-unit id="79e6e6b92700158abe5cbe60e135ba2eff400933" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</source>
          <target state="translated">一次性计算最小和最大元素,并以2-tuple形式返回。</target>
        </trans-unit>
        <trans-unit id="55674d923cbe36a00a2dcb12dc90008788433dbf" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in &lt;code&gt;itr&lt;/code&gt; and return them as a 2-tuple. Only one pass is made over &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">计算应用于 &lt;code&gt;itr&lt;/code&gt; 中每个元素的 &lt;code&gt;f&lt;/code&gt; 的最小值和最大值，并将它们作为2元组返回。只对 &lt;code&gt;itr&lt;/code&gt; 进行一次通过。</target>
        </trans-unit>
        <trans-unit id="9fc034d752a929a676df33e97329f28013afb4ac" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余弦，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="2812b6470b645598b89e13c27d80693c2571602e" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余弦值，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="ed29aab024d008c6bdfa953e7bd9ab905379d015" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="ec21c723d13f003816fe96579a7df0d489520259" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="ac3565a823d4a3efc52e74fc685ed86ae6db58a3" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲正切值。</target>
        </trans-unit>
        <trans-unit id="c3738eef2209a39b21f53d71ed43b07f931e624c" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的正弦值，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="6cf01364af065ae849f27852465a3d3bfe52089d" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的正弦值，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="c2d206b82e6db8e986bbbf98cbf0eb72129c224a" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的切线，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="202a93fa28b48e329210fdf808f2d1b87daa3ed4" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的切线，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="f664081b059842ba583be8e317e1608e46a53fd3" translate="yes" xml:space="preserve">
          <source>Compute the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbf493148049741c81504ff6b4e5ee8560f996f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;LQ&lt;/code&gt; 分解， &lt;code&gt;A = LQ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17538b08e9c154c3f5dd62072c8fa0ea05f963fc" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;LQ&lt;/code&gt; 分解， &lt;code&gt;A = LQ&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 包含标量，这些标量参数化分解的基本反射器。 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="6ad780cc4431af9be511082a782160bff6da4c65" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QL&lt;/code&gt; 分解， &lt;code&gt;A = QL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7a649b9c569a9a9a900055ad2e3e530ad769e9f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QL&lt;/code&gt; 分解， &lt;code&gt;A = QL&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 包含标量，这些标量参数化分解的基本反射器。 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="73e05a032664ce6a5bb59d6231727896e0d85677" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QR&lt;/code&gt; 分解， &lt;code&gt;A = QR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd5939dcb4cf796b127a8200b499f432e4d64b40" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QR&lt;/code&gt; 分解， &lt;code&gt;A = QR&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 包含标量，这些标量参数化分解的基本反射器。 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="14220f2b6c0b60f7df0cde02fa4f1c544028c987" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;RQ&lt;/code&gt; 分解， &lt;code&gt;A = RQ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="861e3be13c33c99b622d41916c8e070553b49f73" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;RQ&lt;/code&gt; 因式分解， &lt;code&gt;A = RQ&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 包含标量，这些标量参数化分解的基本反射器。 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="1941b58e1c7afe2d3c77d99152574462461df1db" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; factorization of a &lt;code&gt;Symmetric&lt;/code&gt; or &lt;code&gt;Hermitian&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; as $P'*U*D*U'*P$ or $P'*L*D*L'*P$, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;code&gt;BunchKaufman&lt;/code&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Symmetric&lt;/code&gt; 或 &lt;code&gt;Hermitian&lt;/code&gt; 矩阵 &lt;code&gt;A&lt;/code&gt; 的Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;分解为$ P'* U * D * U'* P $或$ P'* L * D * L'* P $，具体取决于哪个三角形存储在 &lt;code&gt;A&lt;/code&gt; 中，并返回 &lt;code&gt;BunchKaufman&lt;/code&gt; 对象。注意，如果 &lt;code&gt;A&lt;/code&gt; 是复对称的，则 &lt;code&gt;U'&lt;/code&gt; 和 &lt;code&gt;L'&lt;/code&gt; 表示未共轭的转置，即 &lt;code&gt;transpose(U)&lt;/code&gt; 和 &lt;code&gt;transpose(L)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24a7193e031893d923ed86bc5db45171f4b4182" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;sup&gt;&lt;a href=&quot;#footnote-Bunch1977&quot; id=&quot;citeref-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;&lt;/sup&gt; factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'*U*D*U'*P&lt;/code&gt; or &lt;code&gt;P'*L*D*L'*P&lt;/code&gt;, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;a href=&quot;#LinearAlgebra.BunchKaufman&quot;&gt;&lt;code&gt;BunchKaufman&lt;/code&gt;&lt;/a&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adc6e0822f31506444311768e4f6ded0f9f1c41" translate="yes" xml:space="preserve">
          <source>Compute the CRC-32c checksum of the given &lt;code&gt;data&lt;/code&gt;, which can be an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a contiguous subarray thereof, or a &lt;code&gt;String&lt;/code&gt;. Optionally, you can pass a starting &lt;code&gt;crc&lt;/code&gt; integer to be mixed in with the checksum. The &lt;code&gt;crc&lt;/code&gt; parameter can be used to compute a checksum on data divided into chunks: performing &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; is equivalent to the checksum of &lt;code&gt;[data1; data2]&lt;/code&gt;. (Technically, a little-endian checksum is computed.)</source>
          <target state="translated">计算给定 &lt;code&gt;data&lt;/code&gt; 的CRC-32c校验和，可以是 &lt;code&gt;Array{UInt8}&lt;/code&gt; ，其连续子数组或 &lt;code&gt;String&lt;/code&gt; 。 （可选）您可以传递一个起始 &lt;code&gt;crc&lt;/code&gt; 整数与校验和混合。的 &lt;code&gt;crc&lt;/code&gt; 参数可以被用来计算上分成块的数据的校验和：执行 &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; 是相当于校验 &lt;code&gt;[data1; data2]&lt;/code&gt; 。 （从技术上讲，将计算little-endian校验和。）</target>
        </trans-unit>
        <trans-unit id="451fab004d9b252be766b8c8da0ec9401bcb730d" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.Cholesky&quot;&gt;&lt;code&gt;Cholesky&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633c320407bd275302d618eed24d78f3e652466b" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Cholesky&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">计算稠密对称正定矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;Cholesky&lt;/code&gt; 分解，然后返回Cholesky分解。矩阵 &lt;code&gt;A&lt;/code&gt; 可以是&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 或&lt;em&gt;完全&lt;/em&gt;对称或Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 。可以从分解因子 &lt;code&gt;F&lt;/code&gt; 中获得 &lt;code&gt;F.L&lt;/code&gt; 和 &lt;code&gt;F.U&lt;/code&gt; 从而得出三角形的Cholesky因子。以下功能可用于 &lt;code&gt;Cholesky&lt;/code&gt; 对象：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3253df25b3b67c97f210c72aa2a93261e457fb" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; (of type &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt;) and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt; (of type &lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt;&lt;code&gt;UpperHessenberg&lt;/code&gt;&lt;/a&gt;), either of which may be converted to a regular matrix with &lt;code&gt;Matrix(F.H)&lt;/code&gt; or &lt;code&gt;Matrix(F.Q)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b962efd94ea393def73078100fff01edd4aab9" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的Hessenberg分解并返回一个 &lt;code&gt;Hessenberg&lt;/code&gt; 对象。如果 &lt;code&gt;F&lt;/code&gt; 是分解对象，则可以使用 &lt;code&gt;F.Q&lt;/code&gt; 访问the矩阵，使用 &lt;code&gt;F.H&lt;/code&gt; 访问Hessenberg矩阵。当 &lt;code&gt;Q&lt;/code&gt; 被提取，将得到的类型是 &lt;code&gt;HessenbergQ&lt;/code&gt; 对象，并且可以被转换为常规矩阵&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;Array(_)&lt;/code&gt; 的简称）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
