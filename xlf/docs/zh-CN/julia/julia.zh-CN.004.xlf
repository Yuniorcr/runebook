<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="f331d89838daabfff012fe727d742c8c8e673c8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exec&lt;/code&gt;: in case &lt;code&gt;REBASE_OPERATION_EXEC&lt;/code&gt; is used, the command to run during this step (for instance, running the test suite after each commit).</source>
          <target state="translated">&lt;code&gt;exec&lt;/code&gt; ：如果使用 &lt;code&gt;REBASE_OPERATION_EXEC&lt;/code&gt; ，则在此步骤中运行的命令（例如，每次提交后运行测试套件）。</target>
        </trans-unit>
        <trans-unit id="5d1522caf94cdbf9488832895b1e607324c5eadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt; &amp;ndash; flags to use when lauching Julia remotely</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; &amp;ndash;远程启动Julia时使用的标志</target>
        </trans-unit>
        <trans-unit id="4475ebb24c0e359de01708bc1d247a728f337715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt; should be set to the required command line arguments for new workers.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; 应该设置为新工作程序所需的命令行参数。</target>
        </trans-unit>
        <trans-unit id="05f09246b7fa073a7f1026d572e6e088740c6e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt;: additional flags passed to the worker processes.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; ：传递给工作进程的其他标志。</target>
        </trans-unit>
        <trans-unit id="3e8963f41f3051e232c8d5de842f5be607191c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; &amp;ndash; the path to the Julia executable on the host, defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; &amp;ndash;主机上Julia可执行文件的路径，默认为 &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbecc18bae8e3704699c9ddb2d2f6ee8f7947be3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; is the name of the &lt;code&gt;julia&lt;/code&gt; executable including the full path.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; 是 &lt;code&gt;julia&lt;/code&gt; 可执行文件的名称，包括完整路径。</target>
        </trans-unit>
        <trans-unit id="9e9777b51b1141d2eaeeb8767f03f02a288a8ebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt;: name of the &lt;code&gt;julia&lt;/code&gt; executable. Defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; as the case may be.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; ： &lt;code&gt;julia&lt;/code&gt; 可执行文件的名称。视情况而定，默认为 &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6dc7570f94249d865b09eb2a692da386f794499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 在模块内使用export来告诉Julia应该向用户提供哪些功能。例如： &lt;code&gt;export foo&lt;/code&gt; 使&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;模块时名称 &lt;code&gt;foo&lt;/code&gt; 可用。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="72d0445c62c1b3939fafe7b40795814fcba18b16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 在模块内使用export来告诉Julia应该向用户提供哪些功能。例如： &lt;code&gt;export foo&lt;/code&gt; 使&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;模块时名称 &lt;code&gt;foo&lt;/code&gt; 可用。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="6574aff1f598d8da6d01cfe7e24524b2c0a7bd1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a7471ee53c91775ff9ce42d242abe595bcfc7dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x)&lt;/code&gt; can be any call expression. Returns the result of &lt;code&gt;f(x)&lt;/code&gt; if the types match, and an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it finds different types.</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 可以是任何调用表达式。如果类型匹配，则返回 &lt;code&gt;f(x)&lt;/code&gt; 的 &lt;code&gt;Result&lt;/code&gt; 如果发现不同的类型，则返回 &lt;code&gt;Error&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="d0b49364119f011655f3a8d05e365aee509c9dd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not cause a task switch, which excludes most I/O operations such as &lt;code&gt;println&lt;/code&gt;. Using the &lt;code&gt;@async&lt;/code&gt; macro (to defer context switching to outside of the finalizer) or &lt;code&gt;ccall&lt;/code&gt; to directly invoke IO functions in C may be helpful for debugging purposes.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 一定不能引起任务切换，该任务切换将排除大多数I / O操作（例如 &lt;code&gt;println&lt;/code&gt; )。使用 &lt;code&gt;@async&lt;/code&gt; 宏（将上下文切换推迟到终结器之外）或使用 &lt;code&gt;ccall&lt;/code&gt; 直接调用C中的IO函数可能有助于调试。</target>
        </trans-unit>
        <trans-unit id="497f30aa399e54f4d4675a55c3eafb38181ea62b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt; is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; 是一个 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 矩阵。</target>
        </trans-unit>
        <trans-unit id="17c27552004d64395046d29795efee05dcc044c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt;, as in the &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt; type, is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; &lt;/a&gt;类型一样，因子是 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 矩阵。</target>
        </trans-unit>
        <trans-unit id="d807df0dedd6adab6f030655307f5490121a67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (0)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; （0）</target>
        </trans-unit>
        <trans-unit id="7c323dd694e4baf6f9a2d099639446439f70e26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fastforward::Bool=false&lt;/code&gt;: If &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return &lt;code&gt;false&lt;/code&gt;. This is equivalent to the git CLI option &lt;code&gt;--ff-only&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fastforward::Bool=false&lt;/code&gt; ：如果 &lt;code&gt;fastforward&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则仅当合并为快进（当前分支头是要合并的提交的祖先）时合并，否则拒绝合并并返回 &lt;code&gt;false&lt;/code&gt; 。这等效于git CLI选项 &lt;code&gt;--ff-only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c543b2d8b2065a2e5dc452819e6c3f937251e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 可以视为显式的数据移动操作，因为它直接要求将对象移动到本地计算机。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;（以及一些相关的构造）也可以移动数据，但这并不是很明显，因此可以将其称为隐式数据移动操作。考虑以下两种构造和平方随机矩阵的方法：</target>
        </trans-unit>
        <trans-unit id="441aed98e0f65cd26d43e6c836d252a8cc6789ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 可以视为显式的数据移动操作，因为它直接要求将对象移动到本地计算机。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;（以及一些相关的构造）也可以移动数据，但这并不那么明显，因此可以将其称为隐式数据移动操作。考虑以下两种构造和平方随机矩阵的方法：</target>
        </trans-unit>
        <trans-unit id="f304481efd9961734ed02019c52b7f122e9caadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch_opts&lt;/code&gt;: The options for performing the pre-checkout fetch of the remote as part of the clone.</source>
          <target state="translated">&lt;code&gt;fetch_opts&lt;/code&gt; ：用于作为克隆的一部分执行远程预检取的选项。</target>
        </trans-unit>
        <trans-unit id="b6fd3b698a115341e458d38e2ec7ad39b99bd28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_favor&lt;/code&gt;: how to handle conflicting file contents for the &lt;code&gt;text&lt;/code&gt; driver.</source>
          <target state="translated">&lt;code&gt;file_favor&lt;/code&gt; ：如何为 &lt;code&gt;text&lt;/code&gt; 驱动程序处理冲突的文件内容。</target>
        </trans-unit>
        <trans-unit id="4de1b4ec1dbc92d77323db107114a2663e47b3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_flags&lt;/code&gt;: guidelines for merging files.</source>
          <target state="translated">&lt;code&gt;file_flags&lt;/code&gt; ：合并文件的准则。</target>
        </trans-unit>
        <trans-unit id="3fbf2559a3914fd50a580c62f1bf3a524a1b31f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_mode&lt;/code&gt;: read/write/access mode for any files involved in the checkout. Default is &lt;code&gt;0755&lt;/code&gt; or &lt;code&gt;0644&lt;/code&gt;, depending on the blob.</source>
          <target state="translated">&lt;code&gt;file_mode&lt;/code&gt; ：检出所涉及的任何文件的读/写/访问模式。默认值为 &lt;code&gt;0755&lt;/code&gt; 或 &lt;code&gt;0644&lt;/code&gt; ，具体取决于blob。</target>
        </trans-unit>
        <trans-unit id="2c42aacc63e30d4330883c95cf718c8560278f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_open_flags&lt;/code&gt;: bitflags used to open any files during the checkout.</source>
          <target state="translated">&lt;code&gt;file_open_flags&lt;/code&gt; ：在签出期间用于打开任何文件的位标志。</target>
        </trans-unit>
        <trans-unit id="5a0fc1d82d9beeb03810443c1cef5731061c18c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt;, and it sets options for the diff. The default is to show files added, modified, or deleted.</source>
          <target state="translated">&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt; ，它设置了diff的选项。默认设置为显示添加，修改或删除的文件。</target>
        </trans-unit>
        <trans-unit id="f1902a68a69fa5a2286af83a34ec192b45a3e6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="705dcca1f483b5f410a7d024bf9ea5567a98d882" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a246350d082e2ecf351fc1a6227a9daf36f33939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;i &amp;lt;= start&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; ，使得 &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; 和 &lt;code&gt;i &amp;lt;= start&lt;/code&gt; ，或者 &lt;code&gt;nothing&lt;/code&gt; 如果无法比拟的。</target>
        </trans-unit>
        <trans-unit id="07de775ab3ffe3db837f89e66ab75d6248ad4f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;stop &amp;lt;= i&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; ,这样 &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; 并 &lt;code&gt;stop &amp;lt;= i&lt;/code&gt; ，如果不匹配则不执行 &lt;code&gt;nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6132598e6b7a6f7dbd326bd4b30b37bdb5c4535d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: Flags for the delta and the objects on each side. Determines whether to treat the file(s) as binary/text, whether they exist on each side of the diff, and whether the object ids are known to be correct.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ：增量和每侧对象的标志。确定是否将文件视为二进制文件/文本，文件是否在diff的每一侧以及是否知道对象ID正确。</target>
        </trans-unit>
        <trans-unit id="08dfea97d21ddfc07bbc16a2205aa96d1c822a29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: a combination of the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt;&lt;code&gt;git_diff_flag_t&lt;/code&gt;&lt;/a&gt; flags. The &lt;code&gt;i&lt;/code&gt;th bit of this integer sets the &lt;code&gt;i&lt;/code&gt;th flag.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ：&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt; &lt;code&gt;git_diff_flag_t&lt;/code&gt; &lt;/a&gt;标志的组合。该整数的第 &lt;code&gt;i&lt;/code&gt; 位设置第 &lt;code&gt;i&lt;/code&gt; 个标志。</target>
        </trans-unit>
        <trans-unit id="6a3f46c8ead4a96fd5e9f1735c77e01ac2e9df4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for flags describing merge behavior. Defined in &lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt;&lt;code&gt;git_merge_flag_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_MERGE&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ：用于描述合并行为的标志的 &lt;code&gt;enum&lt;/code&gt; 。在&lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt; &lt;code&gt;git_merge_flag_t&lt;/code&gt; 中&lt;/a&gt;定义。相应的Julia枚举是 &lt;code&gt;GIT_MERGE&lt;/code&gt; ，其值是：</target>
        </trans-unit>
        <trans-unit id="c7ad69674a910f1a345e02b973a2e9f13be3f925" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags controlling which files will appear in the diff. Defaults to &lt;code&gt;DIFF_NORMAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ：控制哪些文件将出现在差异文件中的标志。默认为 &lt;code&gt;DIFF_NORMAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac96c3420fc47ecbae6d81e79e8646bf681816a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags for controlling any callbacks used in a status call.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ：用于控制状态调用中​​使用的任何回调的标志。</target>
        </trans-unit>
        <trans-unit id="0f514fc00776f1753b3aa88448a24342da8ef48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: one of &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; or &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; (the other blame flags are not yet implemented by libgit2).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; ： &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; 或 &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; 中的一个（其他非自责标志尚未由libgit2实现）。</target>
        </trans-unit>
        <trans-unit id="e302baefdbfe650eed3e3989e00d95ff24420d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;floor(T, x)&lt;/code&gt; 将结果转换为 &lt;code&gt;T&lt;/code&gt; 类型，如果该值无法表示，则抛出 &lt;code&gt;InexactError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83862f9f9b336e858b86ef3cce875e4b50041164" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; that is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;floor(x)&lt;/code&gt; 返回相同类型的最接近的整数值 &lt;code&gt;x&lt;/code&gt; 小于或等于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="555deaa32601a989d7598bcb2f199e104d3181cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops repeatedly evaluate a block of statements while iterating over a sequence of values.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环在迭代值序列时反复评估语句块。</target>
        </trans-unit>
        <trans-unit id="ffc0eadc34c155040e86b2da693e68d65e15d861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops, and &lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;Comprehensions&lt;/a&gt; have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环， &lt;code&gt;while&lt;/code&gt; 循环和&lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;Comprehensions&lt;/a&gt;具有以下行为：在其主体作用域中引入的任何新变量都将为每次循环迭代新鲜分配，就像循环主体被 &lt;code&gt;let&lt;/code&gt; 块包围一样：</target>
        </trans-unit>
        <trans-unit id="bec35bbf9967b12c572f1318ed025dfeae186ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c53dd6aa8e8d475ff1ee618c1ee3d8f300a0e513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: determines if the push will be a force push, overwriting the remote branch.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; ：确定是否将强制推送，覆盖远程分支。</target>
        </trans-unit>
        <trans-unit id="4ffee3fe6299fc5a6f0fbcb9a6544eb7b084a999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, branch creation will be forced.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ，则将强制创建分支。</target>
        </trans-unit>
        <trans-unit id="26c5127fe157928b2cdc7f2f08c633baf7c246a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, existing references will be overwritten.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ，则现有引用将被覆盖。</target>
        </trans-unit>
        <trans-unit id="d8ce10e1bd1c57308264cfa8a02820161529c9d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, a force-push will occur, disregarding conflicts.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ，则将忽略冲突而进行强制推入。</target>
        </trans-unit>
        <trans-unit id="e46f672d0974765d0e4d253aed78bcd6e5d3db60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; &amp;ndash;确定回溯打印时是否使用（默认， &lt;code&gt;:tree&lt;/code&gt; ）缩进或不使用（ &lt;code&gt;:flat&lt;/code&gt; ）缩进来表示树结构。</target>
        </trans-unit>
        <trans-unit id="c5f38a1c899e88a0f23d1dfceaf7e3fd37e72169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Introduced above, determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; &amp;ndash;上面介绍的格式，确定打印的回溯记录是否带有（default， &lt;code&gt;:tree&lt;/code&gt; ）缩进或不带有（ &lt;code&gt;:flat&lt;/code&gt; ）缩进来表示树结构。</target>
        </trans-unit>
        <trans-unit id="07b58cbb5868ed67a3999d68cce4a5e6d8243fe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward&lt;/code&gt; &amp;ndash; the forwarding option used for &lt;code&gt;-L&lt;/code&gt; option of ssh</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; &amp;ndash;用于ssh的 &lt;code&gt;-L&lt;/code&gt; 选项的转发选项</target>
        </trans-unit>
        <trans-unit id="c9f61b7b48011ec894bf5fdc902e3b4b8a9fb28f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; must accept the bound channel as its only argument.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 必须接受绑定的通道作为其唯一参数。</target>
        </trans-unit>
        <trans-unit id="23fcdc8d4522728ad257672e40067d5a19c4c857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="0109f2ca671c98fc793c2888fdfb44cb05b2f484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global const&lt;/code&gt; statements from local scope after &lt;code&gt;__init__()&lt;/code&gt; has been started (see issue #12010 for plans to add an error for this)</source>
          <target state="translated">&lt;code&gt;global const&lt;/code&gt; 在启动 &lt;code&gt;__init__()&lt;/code&gt; 之后从本地范围访问全局const语句（有关为此添加错误的计划，请参阅问题＃12010）</target>
        </trans-unit>
        <trans-unit id="09097a47be30f38cda85035ead6ddf1a81219edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; 使 &lt;code&gt;x&lt;/code&gt; 在当前范围内，并且其内部范围引用该名称的全局变量。有关更多信息，请参见&lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;有关变量作用域&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="fbcb126bd8fbe56f4b5b16fa14c6c4a92e9cf8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; 使 &lt;code&gt;x&lt;/code&gt; 在当前范围内，其内部范围引用该名称的全局变量。有关更多信息，请参见&lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;有关变量作用域&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="6c2e813901bd2d8f12c7e3878d31c8f733486073" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a90e71a2c6d30f99d8ba5b28c6c2a5bb0f3aff1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash&lt;/code&gt; is a full (&lt;code&gt;GitHash&lt;/code&gt;) or partial (&lt;code&gt;GitShortHash&lt;/code&gt;) hash.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 是完整（ &lt;code&gt;GitHash&lt;/code&gt; ）或部分（ &lt;code&gt;GitShortHash&lt;/code&gt; ）哈希。</target>
        </trans-unit>
        <trans-unit id="6ab9710162b39252a4dfe60a21316f6a9dd04318" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;head_to_index&lt;/code&gt;: a pointer to a &lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt;&lt;code&gt;DiffDelta&lt;/code&gt;&lt;/a&gt; which encapsulates the difference(s) between the file as it exists in HEAD and in the index.</source>
          <target state="translated">&lt;code&gt;head_to_index&lt;/code&gt; ：一个指向&lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt; &lt;code&gt;DiffDelta&lt;/code&gt; &lt;/a&gt;它封装该文件之间的差异（一个或多个），因为它在HEAD和在索引中存在。</target>
        </trans-unit>
        <trans-unit id="a8fb6255646b88973be5d589e3e2cd202888275d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hessenberg!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;hessenberg!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。</target>
        </trans-unit>
        <trans-unit id="443aaa2d8a08dbab9eefb3c00c406e4d50854023" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;homedir&lt;/code&gt; determines the home directory via &lt;code&gt;libuv&lt;/code&gt;'s &lt;code&gt;uv_os_homedir&lt;/code&gt;. For details (for example on how to specify the home directory via environment variables), see the &lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt;&lt;code&gt;uv_os_homedir&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;homedir&lt;/code&gt; 通过 &lt;code&gt;libuv&lt;/code&gt; 的 &lt;code&gt;uv_os_homedir&lt;/code&gt; 确定主目录。有关详细信息（例如，有关如何通过环境变量指定主目录的信息），请参见&lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt; &lt;code&gt;uv_os_homedir&lt;/code&gt; 文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25471dd737a8db4cd226555668049cca23bf99f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt;: the hostname to use in the output. A hostname is required to be specified.</source>
          <target state="translated">&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt; ：在输出中使用的主机名。必须指定一个主机名。</target>
        </trans-unit>
        <trans-unit id="6b6378d9ceebd483400cddb31fa9c2a3c49dd015" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; &amp;ndash; the host address (either an &lt;code&gt;AbstractString&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; &amp;ndash;主机地址（ &lt;code&gt;AbstractString&lt;/code&gt; 或 &lt;code&gt;Nothing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="98f2590aab388123acc554ec9786e12f2ed78dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; enables case-insensitive matching</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 启用不区分大小写的匹配</target>
        </trans-unit>
        <trans-unit id="1ac86474612cc32f61718a325d8179094b3f029b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; is unique across all references created from the worker specified by &lt;code&gt;whence&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 在由 &lt;code&gt;whence&lt;/code&gt; 指定的工作程序创建的所有引用中都是唯一的。</target>
        </trans-unit>
        <trans-unit id="77683aec1c525b2fa7ea4282b18b2bfd743591a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the commit being worked on during this rebase step.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; ：在此变基步骤中正在处理的提交的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4632953193a9be88e4db3f78db33ec9c0b3e5355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the item in the diff. If the item is empty on this side of the diff (for instance, if the diff is of the removal of a file), this will be &lt;code&gt;GitHash(0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; ：&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;中项目的GitHash。如果该项目在diff的这一侧为空（例如，如果diff是删除文件的结果）， &lt;code&gt;GitHash(0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e890a5aeabd7d8ed2134402d7301e54269b9fea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: only present in LibGit2 versions newer than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. The length of the &lt;code&gt;id&lt;/code&gt; field when converted using &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Usually equal to &lt;code&gt;OID_HEXSZ&lt;/code&gt; (40).</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; ：仅存在于LibGit2版本中，其版本等于或大于 &lt;code&gt;0.25.0&lt;/code&gt; 。使用&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;转换时， &lt;code&gt;id&lt;/code&gt; 字段的长度。通常等于 &lt;code&gt;OID_HEXSZ&lt;/code&gt; （40）。</target>
        </trans-unit>
        <trans-unit id="3d569a64dd1d8d5f907282660e533f0925b4121f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: sets the length of the abbreviated &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to print. Default is &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; ：设置要打印的缩写&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;的长度。默认值为 &lt;code&gt;7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b126af9abc886e3ecfdde16a44fc1fd06cacab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ident&lt;/code&gt; &amp;ndash; worker as identified by the &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ident&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; &lt;/a&gt;标识的工作者</target>
        </trans-unit>
        <trans-unit id="63b00d5176640c38aab5edaa5b524b6e779cf1b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, so</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 块也返回一个值，对于来自许多其他语言的用户而言，这似乎是不直观的。该值只是所选分支中最后执行的语句的返回值，因此</target>
        </trans-unit>
        <trans-unit id="fcb2f9043fb5a6e861c26de7d9fc3e06f6279b43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks are &quot;leaky&quot;, i.e. they do not introduce a local scope. This means that new variables defined inside the &lt;code&gt;if&lt;/code&gt; clauses can be used after the &lt;code&gt;if&lt;/code&gt; block, even if they weren't defined before. So, we could have defined the &lt;code&gt;test&lt;/code&gt; function above as</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 块是&amp;ldquo;泄漏的&amp;rdquo;，即它们不引入局部作用域。这意味着在 &lt;code&gt;if&lt;/code&gt; 子句中定义的新变量可以在 &lt;code&gt;if&lt;/code&gt; 块之后使用，即使之前未定义也可以使用。因此，我们可以将上面的 &lt;code&gt;test&lt;/code&gt; 函数定义为</target>
        </trans-unit>
        <trans-unit id="4bf46a1a1630b72dba5a7f8db4ee562143b45f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 执行条件评估，这允许根据布尔表达式的值评估或不评估部分代码。这是 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 条件语法的剖析：</target>
        </trans-unit>
        <trans-unit id="566ebce021ad66c3334658155da253a262017f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b5d807151cf5fb7a277f815a71877f8ac2493dd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore_submodules&lt;/code&gt;: whether to look at files in submodules or not. Defaults to &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt;, which means the submodule's configuration will control whether it appears in the diff or not.</source>
          <target state="translated">&lt;code&gt;ignore_submodules&lt;/code&gt; ：是否查看子模块中的文件。默认为 &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt; ，这意味着子模块的配置将控制它是否出现在差异文件中。</target>
        </trans-unit>
        <trans-unit id="c7ec9971812e6bb11003c306876aa97764469071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignorestatus::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then the &lt;code&gt;Cmd&lt;/code&gt; will not throw an error if the return code is nonzero.</source>
          <target state="translated">&lt;code&gt;ignorestatus::Bool&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; （默认为 &lt;code&gt;false&lt;/code&gt; ），则如果返回码为非零，则 &lt;code&gt;Cmd&lt;/code&gt; 不会引发错误。</target>
        </trans-unit>
        <trans-unit id="b778f0523dec6fb0a23df4b4366a7735dc4e5360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;import Foo&lt;/code&gt; 将加载模块或包 &lt;code&gt;Foo&lt;/code&gt; 。可以使用点语法访问导入的 &lt;code&gt;Foo&lt;/code&gt; 模块中的名称（例如，使用 &lt;code&gt;Foo.foo&lt;/code&gt; 来访问名称 &lt;code&gt;foo&lt;/code&gt; ）。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="9d73230963993ccbecb868483fbaecb6157d6cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;import Foo&lt;/code&gt; 将加载模块或软件包 &lt;code&gt;Foo&lt;/code&gt; 。可以使用点语法访问导入的 &lt;code&gt;Foo&lt;/code&gt; 模块中的名称（例如，使用 &lt;code&gt;Foo.foo&lt;/code&gt; 访问名称 &lt;code&gt;foo&lt;/code&gt; ）。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="3a86299ce603a7643e3664ff35ca004b94ad86d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c35c5eb16c9e1c075a2a381e94cfe254e7dd0daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; the &lt;code&gt;tst.jl&lt;/code&gt; file in the Julia REPL with &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 在 &lt;code&gt;tst.jl&lt;/code&gt; 在朱莉娅REPL文件， &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f768295f60d5987df59c14346dbea6137535cca3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_to_workdir&lt;/code&gt;: a pointer to a &lt;code&gt;DiffDelta&lt;/code&gt; which encapsulates the difference(s) between the file as it exists in the index and in the &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index_to_workdir&lt;/code&gt; ：一个指向 &lt;code&gt;DiffDelta&lt;/code&gt; 它封装该文件之间的差异（一个或多个），因为它在索引中，在存在&lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="474f56e3f7f2db91f626ba947f94c8134a832be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inds&lt;/code&gt; can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;true&lt;/code&gt; indicating entries to delete.</source>
          <target state="translated">&lt;code&gt;inds&lt;/code&gt; 可以是迭代器，也可以是排序的和唯一的整数索引的集合，或者是与 &lt;code&gt;a&lt;/code&gt; 长度相同的布尔向量，其中 &lt;code&gt;true&lt;/code&gt; 表示要删除的条目。</target>
        </trans-unit>
        <trans-unit id="f4b74525a3214d8995b7de35723cd0e10aa9cc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; be called as part of worker process initialization.</source>
          <target state="translated">&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;作为工作进程初始化的一部分进行调用。</target>
        </trans-unit>
        <trans-unit id="062786138593a2c08d489ac7499ae90c9ac1b687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inmemory&lt;/code&gt;: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt; will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;inmemory&lt;/code&gt; ：启动inmemory底垫。进行重新配置的调用者可以执行其步骤并提交任何更改，但是不能倒回HEAD或更新存储库。工作&lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt;将不会被修改。仅存在于高于或等于0.24.0的libgit2版本上。</target>
        </trans-unit>
        <trans-unit id="43f0e964371142a5bdcf673bc58ad413b60b5576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;BOOL&lt;/code&gt; (C, typical)</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;BOOL&lt;/code&gt; （C，典型）</target>
        </trans-unit>
        <trans-unit id="8c6987d5f4b696d5dad48c78ec3bd108e4434880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interhunk_lines&lt;/code&gt;: the maximum number of &lt;em&gt;unchanged&lt;/em&gt; lines &lt;em&gt;between&lt;/em&gt; two separate hunks allowed before the hunks will be combined. Default is 0.</source>
          <target state="translated">&lt;code&gt;interhunk_lines&lt;/code&gt; ：在将大块合并之前，允许的两个单独大块&lt;em&gt;之间&lt;/em&gt;的最大&lt;em&gt;不变&lt;/em&gt;行数。默认值为0。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ac758c6df49f7e88cbaf72ed20736709216e27a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv(::Missing)&lt;/code&gt; requires at least Julia 1.2.</source>
          <target state="translated">&lt;code&gt;inv(::Missing)&lt;/code&gt; 至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="defccb8166cf527d394e34aea3f1751d7f3bf94e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f1625223f3bccb84ba7248a9f8ae3e5a6efc8f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fd375f58223ce99e67fd522a69ff52eeb0090c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; ， &lt;code&gt;sqrt&lt;/code&gt; ， &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb423dd8ec10d55f3420319afa3f79a334d2182d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; Allows you to save the results to a buffer, e.g. a file, but the default is to print to &lt;code&gt;stdout&lt;/code&gt; (the console).</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; &amp;ndash;允许您将结果保存到缓冲区（例如文件）中，但默认设置是打印到 &lt;code&gt;stdout&lt;/code&gt; （控制台）。</target>
        </trans-unit>
        <trans-unit id="5546bdb05f19d23dc367936cace4cab1b8200d3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; the connection used to access the worker (a subtype of &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; &amp;ndash;用于访问工作程序的连接（ &lt;code&gt;IO&lt;/code&gt; 或 &lt;code&gt;Nothing&lt;/code&gt; 的子类型）</target>
        </trans-unit>
        <trans-unit id="b8a259654f78220bfceb0da4679453a56d4d9938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isbare::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, clone the remote as a bare repository, which will make &lt;code&gt;repo_path&lt;/code&gt; itself the git directory instead of &lt;code&gt;repo_path/.git&lt;/code&gt;. This means that a working tree cannot be checked out. Plays the role of the git CLI argument &lt;code&gt;--bare&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isbare::Bool=false&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ，则将远程 &lt;code&gt;repo_path&lt;/code&gt; 为裸仓库，这将使repo_path本身成为git目录，而不是 &lt;code&gt;repo_path/.git&lt;/code&gt; 。这意味着无法检出工作树。扮演git CLI参数 &lt;code&gt;--bare&lt;/code&gt; 的角色。</target>
        </trans-unit>
        <trans-unit id="8f28ba244c2cc607da8b0fcf1f3367c037ee2322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; can also be used to distinguish signed zeros:</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 也可以用于区分有符号的零：</target>
        </trans-unit>
        <trans-unit id="6155f47b9568bd6b958ba232c62862f14186f428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; is the comparison function used by hash tables (&lt;code&gt;Dict&lt;/code&gt;). &lt;code&gt;isequal(x,y)&lt;/code&gt; must imply that &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 是哈希表（ &lt;code&gt;Dict&lt;/code&gt; ）使用的比较函数。 &lt;code&gt;isequal(x,y)&lt;/code&gt; 必须暗示 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c588e795f436dd4d05aaac17fde984ce26c5d8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ismerge&lt;/code&gt;: Boolean flag indicating whether the changes at the remote have been merged into the local copy yet or not. If &lt;code&gt;true&lt;/code&gt;, the local copy is up to date with the remote fetch head.</source>
          <target state="translated">&lt;code&gt;ismerge&lt;/code&gt; ：布尔值标志，指示远程的更改是否已合并到本地副本中。如果为 &lt;code&gt;true&lt;/code&gt; ，则本地副本是使用远程访存头更新的。</target>
        </trans-unit>
        <trans-unit id="cf09e161cb1b30fd41fdc4159954ec544ced0840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; - return false if a &lt;code&gt;take!&lt;/code&gt; on the pool would block, else true</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; -如果 &lt;code&gt;take!&lt;/code&gt; 则返回false ！在游泳池上会阻塞，否则为真</target>
        </trans-unit>
        <trans-unit id="7ad6e3363b26358cf09c26c458c64943918beb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; tests for the presence of any object in the channel, while &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; waits for an object to become available.</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; 测试通道中是否存在任何对象，而&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;等待对象变得可用。</target>
        </trans-unit>
        <trans-unit id="cf94b7544dc2a3713c698136abf41c0ffeb4bb19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_error&lt;/code&gt; takes a C string, and &lt;code&gt;jl_errorf&lt;/code&gt; is called like &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;jl_error&lt;/code&gt; 采用C字符串，并且 &lt;code&gt;jl_errorf&lt;/code&gt; 的调用类似于 &lt;code&gt;printf&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41fc079cf4386f9010ec6a2a6dcc4d336dfd5990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t**&lt;/code&gt; (a reference to a Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t**&lt;/code&gt; （对Julia类型的引用）</target>
        </trans-unit>
        <trans-unit id="c496bfdad90f2fcfcf408b69f7b755c0534067bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t*&lt;/code&gt; (any Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t*&lt;/code&gt; （任何Julia类型）</target>
        </trans-unit>
        <trans-unit id="a6119baf62a14c4942fa709be955c8698c7254e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jpvt&lt;/code&gt; is an integer vector of length &lt;code&gt;n&lt;/code&gt; corresponding to the permutation $P$.</source>
          <target state="translated">&lt;code&gt;jpvt&lt;/code&gt; 是与置换$ P $相对应的长度为 &lt;code&gt;n&lt;/code&gt; 的整数向量。</target>
        </trans-unit>
        <trans-unit id="5370bf4f79562ad85e01f701fe6974cf62dddd5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    pkg&amp;gt; generate MyPkg              # type ] to enter pkg mode    julia&amp;gt; push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode&lt;/code&gt; If you restart your Julia session you'll have to re-issue that command modifying &lt;code&gt;LOAD_PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;julia pkg&amp;gt; generate MyPkg # type ] to enter pkg mode julia&amp;gt; push!(LOAD_PATH, pwd()) # hit backspace to exit pkg mode&lt;/code&gt; 如果重新启动Julia会话，则必须重新发出修改 &lt;code&gt;LOAD_PATH&lt;/code&gt; 的命令。</target>
        </trans-unit>
        <trans-unit id="cdd73df7706c15ba69b8cb61854340ff6886bc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    using PkgTemplates    t = Template()    generate(&quot;MyPkg&quot;, t)&lt;/code&gt; This will create a blank package, &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt;, in your &lt;code&gt;.julia/dev&lt;/code&gt; directory. Note that PkgTemplates allows you to control many different options through its &lt;code&gt;Template&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;julia using PkgTemplates t = Template() generate(&quot;MyPkg&quot;, t)&lt;/code&gt; 这将在 &lt;code&gt;.julia/dev&lt;/code&gt; 目录中创建一个空白包 &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt; 。请注意，PkgTemplates允许您通过其 &lt;code&gt;Template&lt;/code&gt; 构造函数来控制许多不同的选项。</target>
        </trans-unit>
        <trans-unit id="625af536bb88ddf9aa5a8b9ba26a788c563e9774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keepempty&lt;/code&gt;: whether empty fields should be kept in the result. Default is &lt;code&gt;false&lt;/code&gt; without a &lt;code&gt;dlm&lt;/code&gt; argument, &lt;code&gt;true&lt;/code&gt; with a &lt;code&gt;dlm&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;keepempty&lt;/code&gt; ：是否应在结果中保留空白字段。默认是 &lt;code&gt;false&lt;/code&gt; 没有 &lt;code&gt;dlm&lt;/code&gt; 说法， &lt;code&gt;true&lt;/code&gt; 有 &lt;code&gt;dlm&lt;/code&gt; 的说法。</target>
        </trans-unit>
        <trans-unit id="9c6fd799a7cffc4157ed068f75896f2a6f68342b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; is called to remove a worker from the cluster. On the master process, the corresponding &lt;code&gt;IO&lt;/code&gt; objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an &lt;code&gt;exit()&lt;/code&gt; call on the specified remote worker.</source>
          <target state="translated">&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; 调用kill（manager，pid，config）从集群中删除一个工作线程。在主进程上，实现必须关闭相应的 &lt;code&gt;IO&lt;/code&gt; 对象，以确保正确清理。默认实现只是在指定的远程工作程序上执行 &lt;code&gt;exit()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="5bfba992423752658b61db87a6fc7a82071655e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;launched::Array&lt;/code&gt;: the array to append one or more &lt;code&gt;WorkerConfig&lt;/code&gt; objects to</source>
          <target state="translated">&lt;code&gt;launched::Array&lt;/code&gt; ：将一个或多个 &lt;code&gt;WorkerConfig&lt;/code&gt; 对象附加到的数组</target>
        </trans-unit>
        <trans-unit id="6c4472e72e5805ee9aa798ea6065a631b9f8120d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy&lt;/code&gt;: Applicable only with &lt;code&gt;topology=:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; ：仅适用于 &lt;code&gt;topology=:all_to_all&lt;/code&gt; 。如果为 &lt;code&gt;true&lt;/code&gt; ，则延迟建立worker-worker连接，即，它们是在worker之间的远程调用的第一个实例处建立的。默认为true。</target>
        </trans-unit>
        <trans-unit id="6ab3641b567d7550fa4574b7e9fcd59486edd69f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(iter)&lt;/code&gt; and &lt;code&gt;size(iter, [dim])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;length(iter)&lt;/code&gt; 和 &lt;code&gt;size(iter, [dim])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b82c15769674081bdc4b1e2732d829ab6f255a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str)&lt;/code&gt; the number of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str)&lt;/code&gt; 中的字符数 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="520336ce4b0d7ffb4223a859ab46df75e628bf97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str, i, j)&lt;/code&gt; the number of valid character indices in &lt;code&gt;str&lt;/code&gt; from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str, i, j)&lt;/code&gt; 从 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt; 的 &lt;code&gt;str&lt;/code&gt; 中有效字符索引的数量。</target>
        </trans-unit>
        <trans-unit id="45f8144db4b1abe106783e820484be829d5e84bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, &lt;code&gt;let&lt;/code&gt; creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The &lt;code&gt;let&lt;/code&gt; syntax accepts a comma-separated series of assignments and variable names:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 语句每次运行时都会分配新的变量绑定。尽管分配修改了现有的价值地点，但 &lt;code&gt;let&lt;/code&gt; 创建新的地点。仅当变量通过闭包超出其作用域时，才可以检测到这种差异。该 &lt;code&gt;let&lt;/code&gt; 语法接受一个逗号分隔的一系列任务和变量名：</target>
        </trans-unit>
        <trans-unit id="2857b88b57ff8e8634f1fd5411364f41533e5276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="6d34fd9ee3b3db157e9c05aba51e1a69d53562d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt;: the maximum size of the result. &lt;code&gt;limit=0&lt;/code&gt; implies no maximum (default)</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; ：结果的最大大小。 &lt;code&gt;limit=0&lt;/code&gt; 表示没有最大值（默认）</target>
        </trans-unit>
        <trans-unit id="4701fc63cc18d0bd4efa7e7a724aa45a91814bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the line number to open the editor at</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; -在以下位置打开编辑器的行号</target>
        </trans-unit>
        <trans-unit id="ee768c9c42d9eb36402e2084b6758909461265e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 引入了一个新的局部变量。有关更多信息，请参见&lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;有关变量作用域&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="5a949f1c99f2882cd291b76f59d11378f665e213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 引入了一个新的局部变量。有关更多信息，请参见&lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;有关变量作用域&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="f1237a0341e49a3e81f1f3559c045b64e25d095c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b2ace899c61be5098940595710c0631ed9e0f98f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localclone&lt;/code&gt;: Flag whether to clone a local object database or do a fetch. The default is to let git decide. It will not use the git-aware transport for a local clone, but will use it for URLs which begin with &lt;code&gt;file://&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;localclone&lt;/code&gt; ：标记是克隆本地对象数据库还是进行提取。默认是让git决定。它不会将git-aware传输用于本地克隆，而是将其用于以 &lt;code&gt;file://&lt;/code&gt; 开头的URL 。</target>
        </trans-unit>
        <trans-unit id="45419d31c5c3e877e8801855f33df8c42b91a13b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lu!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;lu!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。一个&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;如果分解产生许多不通过的元素类型可表示的则抛出异常 &lt;code&gt;A&lt;/code&gt; 整数类型，例如。</target>
        </trans-unit>
        <trans-unit id="80e7ecffd4874930679049a4efd39c31c359825a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt; treats the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; tokens as matching the start and end of individual lines, as opposed to the whole string.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 将 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 标记视为与单独的行的开头和结尾（而不是整个字符串）匹配。</target>
        </trans-unit>
        <trans-unit id="959d5f8f25ccf34278c7231d15d752b5420fe0a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 恒等矩阵</target>
        </trans-unit>
        <trans-unit id="f58713efbedd940089d6be8f8c2bd121e93d80c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. Requires &lt;code&gt;using LinearAlgebra&lt;/code&gt; for &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 单位矩阵。要求对&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt; &lt;code&gt;using LinearAlgebra&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0804fc37d749faa6c59c487dd0fd30a88f27145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machine_spec&lt;/code&gt; is a string of the form &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. If &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; is specified, other workers will connect to this worker at the specified &lt;code&gt;bind_addr&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;machine_spec&lt;/code&gt; 是 &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt; 形式的字符串。 &lt;code&gt;user&lt;/code&gt; 默认为当前用户， &lt;code&gt;port&lt;/code&gt; 为标准ssh端口。如果指定了 &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; ，其他工作程序将在指定的 &lt;code&gt;bind_addr&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 处连接到该工作程序。</target>
        </trans-unit>
        <trans-unit id="ae97bd7ed7d82dd19e12486744447e7aab4faa00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machines&lt;/code&gt; is a vector of machine specifications. Workers are started for each specification.</source>
          <target state="translated">&lt;code&gt;machines&lt;/code&gt; 是机器规格的向量。为每个规范启动工作人员。</target>
        </trans-unit>
        <trans-unit id="6b0e0fb4129a24815ec030736714dbdf7a492aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt; 定义了一种将生成的代码插入程序的方法。宏将参数表达式的序列映射到返回的表达式，并且在调用该宏时将结果表达式直接替换为程序。宏是一种运行生成的代码而无需调用&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 的方法&lt;/a&gt;，因为生成的代码只是变成了周围程序的一部分。宏参数可以包括表达式，文字值和符号。</target>
        </trans-unit>
        <trans-unit id="b776a97940ed8af56b4981f4f88255433cb44ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/init/#Base.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols. Macros can be defined for variable number of arguments (varargs), but do not accept keyword arguments.</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt; 定义了一种将生成的代码插入程序的方法。宏将参数表达式的序列映射到返回的表达式，并且在调用宏时，将所得的表达式直接替换到程序中。宏是一种无需调用&lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/init/#Base.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;即可运行生成的代码的方法，因为生成的代码只是变成了周围程序的一部分。宏参数可以包括表达式，文字值和符号。可以为可变数量的参数（varargs）定义宏，但不接受关键字参数。</target>
        </trans-unit>
        <trans-unit id="8484bf3ce18b73a3cab86759b8f006be25dfcef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="84b9fe4b3edfa78bd622af9c76d19c51a2ae7a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; is called at different times during the worker's lifetime with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; 在工人生命周期的不同时间使用适当的 &lt;code&gt;op&lt;/code&gt; 值调用manage（manager :: FooManager，id :: Integer，config :: WorkerConfig，op :: Symbol）：</target>
        </trans-unit>
        <trans-unit id="5a3811884df527d3a7abba9f083f81c97faa84f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manager::ClusterManager&lt;/code&gt;: the cluster manager that &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; is called with</source>
          <target state="translated">&lt;code&gt;manager::ClusterManager&lt;/code&gt; ：使用以下&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;调用addprocs的集群管理器</target>
        </trans-unit>
        <trans-unit id="8fdaf74a3de08a38b1e7873c2d0c9cc29c15317c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(f, values(dict::AbstractDict))&lt;/code&gt; requires Julia 1.2 or later.</source>
          <target state="translated">&lt;code&gt;map!(f, values(dict::AbstractDict))&lt;/code&gt; 需要Julia 1.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="f703846e4a33db719039e6bcacfcf60d0b7d137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapreduce&lt;/code&gt; with multiple iterators requires Julia 1.2 or later.</source>
          <target state="translated">&lt;code&gt;mapreduce&lt;/code&gt; 具有多个迭代器的mapreduce需要使用Julia 1.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="404b7144aa3a425a14deb38ee5cef8b003767781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_candidates_tags&lt;/code&gt;: consider this many most recent tags in &lt;code&gt;refs/tags&lt;/code&gt; to describe a commit. Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).</source>
          <target state="translated">&lt;code&gt;max_candidates_tags&lt;/code&gt; ：在 &lt;code&gt;refs/tags&lt;/code&gt; 中考虑这么多最新的标签来描述提交。默认值为10（这样将检查最近的10个标签以查看它们是否描述了提交）。</target>
        </trans-unit>
        <trans-unit id="72981d27e1ab22dbc583a1145b1621a961f192c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_line&lt;/code&gt;: the last line of the file to which to blame. The default is &lt;code&gt;0&lt;/code&gt;, meaning the last line of the file.</source>
          <target state="translated">&lt;code&gt;max_line&lt;/code&gt; ：文件的最后一行。默认值为 &lt;code&gt;0&lt;/code&gt; ，表示文件的最后一行。</target>
        </trans-unit>
        <trans-unit id="15cedd55ecf1ad91d90724912d371f1e5caa41be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt; &amp;ndash; the maximum number of workers to connect to in parallel on the host</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; &amp;ndash;主机上并行连接的最大工作程序数</target>
        </trans-unit>
        <trans-unit id="d995f39223c4bb9a999a43cfcca6c5681ab1ad1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt;: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; ：指定主机上并行连接的最大工作程序数。默认为10</target>
        </trans-unit>
        <trans-unit id="1b1d9f37af536ccd58c278c3e506d8652b8ac208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_size&lt;/code&gt;: the maximum file size of a blob. Above this size, it will be treated as a binary blob. The default is 512 MB.</source>
          <target state="translated">&lt;code&gt;max_size&lt;/code&gt; ：Blob的最大文件大小。超过此大小，它将被视为二进制斑点。默认值为512 MB。</target>
        </trans-unit>
        <trans-unit id="eaffe3704906f8467b046897a2780542aedcf5e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits frames at a depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; 以 &lt;code&gt;:tree&lt;/code&gt; 格式将帧限制在比 &lt;code&gt;maxdepth&lt;/code&gt; 更高的深度处。</target>
        </trans-unit>
        <trans-unit id="32491e760e7f18f6d8360a85f2a4709cc201ee79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits the depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; 以 &lt;code&gt;:tree&lt;/code&gt; 格式将深度限制为大于 &lt;code&gt;maxdepth&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f20d7bbc515704268a8c41e4ee1011847047e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxlog=integer&lt;/code&gt; should be used as a hint to the backend that the message should be displayed no more than &lt;code&gt;maxlog&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;maxlog=integer&lt;/code&gt; 应该使用maxlog = integer作为后端的提示，即消息的显示时间不得超过 &lt;code&gt;maxlog&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="234c5dd9163cc56272b3f54c2a5466c8b1f6eaee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxsize&lt;/code&gt;: specifies a size beyond which the buffer may not be grown.</source>
          <target state="translated">&lt;code&gt;maxsize&lt;/code&gt; ：指定一个大小，超出该大小可能无法增长缓冲区。</target>
        </trans-unit>
        <trans-unit id="98f6f1cd7ea6f9bdc2332e5a901da5db582cd3aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mean&lt;/code&gt; for empty arrays requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; 空数组的均值至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="2f22ee8634e701a2f38532448ed1c500b069efd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt;: options for how to perform the merge, including whether fastforwarding is allowed. See &lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt;&lt;code&gt;MergeOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt; ：有关如何执行合并的选项，包括是否允许快进。有关更多信息，请参见&lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt; &lt;code&gt;MergeOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71cc2e70735d9fd74fff0caeb5b8d510b36cbd2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt;: &lt;code&gt;merge_opts&lt;/code&gt; specifies options for the merge, such as merge strategy in case of conflicts.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt; ： &lt;code&gt;merge_opts&lt;/code&gt; 指定用于合并的选项，例如发生冲突时的合并策略。</target>
        </trans-unit>
        <trans-unit id="125e60bc501dba72f09f0b4976efe2ce6d4483cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts&lt;/code&gt;: merge options controlling how the trees will be merged at each rebase step. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;merge_opts&lt;/code&gt; ：合并选项，用于控制在每个变基步骤中如何合并树。仅存在于高于或等于0.24.0的libgit2版本上。</target>
        </trans-unit>
        <trans-unit id="a5c88c45c2e1535dc547029bf00d88024b7ab716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith!&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="translated">&lt;code&gt;mergewith!&lt;/code&gt; 需要Julia 1.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="19d6df524e25091e18c8beea5b75a95d3f719841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="translated">&lt;code&gt;mergewith&lt;/code&gt; 要求Julia 1.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="9b67314512e49ee15c92e5c7e9f6dbd1931dab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; should be an expression which evaluates to a string which is a human readable description of the log event. By convention, this string will be formatted as markdown when presented.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 应该是一个表达式，其结果为字符串，该字符串是日志事件的可读描述。按照惯例，此字符串在显示时将被格式化为markdown。</target>
        </trans-unit>
        <trans-unit id="b90e0c119e4dfcc2e9dd089d139594390c4da90a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta_formatter&lt;/code&gt; is a function which takes the log event metadata &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; and returns a color (as would be passed to printstyled), prefix and suffix for the log message. The default is to prefix with the log level and a suffix containing the module, file and line location.</source>
          <target state="translated">&lt;code&gt;meta_formatter&lt;/code&gt; 是一个函数，它接收日志事件元数据 &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; 并返回日志消息的颜色（将传递给printstyled的颜色），前缀和后缀。默认值为前缀日志级别和后缀，其中包含模块，文件和行的位置。</target>
        </trans-unit>
        <trans-unit id="793b666b763adfb5cbc980bd4657fe28ca8ebfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metric&lt;/code&gt;: optional custom function to use to determine the similarity between two files for rename detection.</source>
          <target state="translated">&lt;code&gt;metric&lt;/code&gt; ：可选的自定义函数，用于确定两个文件之间的相似性以进行重命名检测。</target>
        </trans-unit>
        <trans-unit id="ee731c731c0b59328238d9d827bb96b9a9284c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_line&lt;/code&gt;: the first line of the file from which to starting blaming. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min_line&lt;/code&gt; ：文件的第一行，从该行开始。默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b3253f765bb04e11f5c63333adab3ac5b42e254" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_match_characters&lt;/code&gt;: the minimum number of &lt;em&gt;alphanumeric&lt;/em&gt; characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; flags are used, which libgit2 does not implement yet.</source>
          <target state="translated">&lt;code&gt;min_match_characters&lt;/code&gt; ：在提交中进行较大更改以使更改与该提交相关联的最小&lt;em&gt;字母数字&lt;/em&gt;字符数。默认值为20。仅在使用 &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; 标志之一（libgit2尚未实现）时生效。</target>
        </trans-unit>
        <trans-unit id="5db057df9be404f6e7c104b6feff23b69ad90b59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits frames with less than &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; &amp;ndash;限制出现次数少于 &lt;code&gt;mincount&lt;/code&gt; 的帧。</target>
        </trans-unit>
        <trans-unit id="1560ab3a1270d2ec7101ba0ebabaa0d8741ee114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits the printout to only those lines with at least &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; &amp;ndash;将打印输出限制为仅出现最少 &lt;code&gt;mincount&lt;/code&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="7fc9303555177cabe6ff1fd33c9914d821e64acb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard mathematical operators and functions. For these functions, uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means a math operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 传递给标准数学运算符和函数时，缺失值会自动&lt;em&gt;传播&lt;/em&gt;。对于这些功能，操作数之一的值不确定会导致结果不确定。实际上，这意味着涉及 &lt;code&gt;missing&lt;/code&gt; 值的数学运算通常会返回 &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62fbe82d06f465bb8d2948bd22cf8237ee9a59c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod&lt;/code&gt; with offset 1; returns &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; for &lt;code&gt;y&amp;gt;0&lt;/code&gt; or &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; for &lt;code&gt;y&amp;lt;0&lt;/code&gt;, where &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 偏移量为1的mod ; 对于 &lt;code&gt;y&amp;gt;0&lt;/code&gt; 返回 &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; 或对于 &lt;code&gt;y&amp;lt;0&lt;/code&gt; 返回r&amp;isin; &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; ，其中 &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d4ee2c86fd7250e19c9601f24f28fca8d9bdc9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; must be one of &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;r+&quot;&lt;/code&gt;, &lt;code&gt;&quot;w+&quot;&lt;/code&gt;, or &lt;code&gt;&quot;a+&quot;&lt;/code&gt;, and defaults to &lt;code&gt;&quot;r+&quot;&lt;/code&gt; if the file specified by &lt;code&gt;filename&lt;/code&gt; already exists, or &lt;code&gt;&quot;w+&quot;&lt;/code&gt; if not. If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers. You cannot specify an &lt;code&gt;init&lt;/code&gt; function if the file is not writable.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 必须是 &lt;code&gt;&quot;r&quot;&lt;/code&gt; ， &lt;code&gt;&quot;r+&quot;&lt;/code&gt; ， &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;a+&quot;&lt;/code&gt; ，如果 &lt;code&gt;filename&lt;/code&gt; 所指定的文件已经存在，则默认为 &lt;code&gt;&quot;r+&quot;&lt;/code&gt; 否则，则默认为 &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 。如果指定了 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 类型的 &lt;code&gt;init&lt;/code&gt; 函数，则会在所有参与的worker上调用它。如果文件不可写，则不能指定 &lt;code&gt;init&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="9a097698641d5469c04e6f0f998cce8e958f0b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt;: the &lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode for the item.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; ：项目的&lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;模式。</target>
        </trans-unit>
        <trans-unit id="2698588e3b9b4ad6d810639c1a90db1327c88c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 声明一个&lt;a href=&quot;#Core.Module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;，它是一个单独的全局变量工作区。在一个模块内，您可以控制其他模块中的哪些名称可见（通过导入），并指定要将哪些名称公开（通过导出）。模块使您可以创建顶级定义，而不必担心将代码与其他人一起使用时的名称冲突。有关更多详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="5f5158bf646d4d27259805df6c3a41ba7e37637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 声明一个&lt;a href=&quot;#Core.Module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;，它是一个单独的全局变量工作区。在一个模块内，您可以控制其他模块中的哪些名称可见（通过导入），并指定要将哪些名称公开（通过导出）。模块使您可以创建顶级定义，而不必担心将代码与其他人一起使用时的名称冲突。有关更多详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="d6b46915fd1e85bc90eb5d56fd7bd927a43d2f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c95192ba3e3940cd0188a72ebb62589a75aa7d1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt;: the message for the tag.</source>
          <target state="translated">&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt; ：标记的消息。</target>
        </trans-unit>
        <trans-unit id="f4d691c48a28d2ce55d8a4698e4a2c1aee668e25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt;: a message to insert into the reflogs.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; ：一条消息插入到引用日志中。</target>
        </trans-unit>
        <trans-unit id="487395b1bdfc7e61d7447898d434b73b3a4f1f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_loop&lt;/code&gt;: loopback for multicast packets (default: &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_loop&lt;/code&gt; ：组播数据包的环回（默认值： &lt;code&gt;true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e99e21c3690f3dcdfa4d6c0fe75cee3eea8fe44c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_ttl&lt;/code&gt;: TTL for multicast packets (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_ttl&lt;/code&gt; ：组播数据包的TTL（默认值： &lt;code&gt;nothing&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="187344f44af903c3b6f0efb3f7498faa785d7c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use SSH multiplexing for tunneling) or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;multiplex&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; （使用SSH多路传输进行隧道传输）或 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f44fe996e6d08709a8c10b3979d511d5e4323b6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH multiplexing is used for SSH tunneling. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;multiplex&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ,则将SSH复用用于SSH隧道。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f56a3d584155f39e37a0ccc363839ae179552328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; 类似于&lt;a href=&quot;#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;，但另外允许的类型的字段来施工后进行设置。有关更多信息，请参见&amp;ldquo;&lt;a href=&quot;../../manual/types/index#Composite-Types&quot;&gt;复合类型&lt;/a&gt;&amp;rdquo;手册部分。</target>
        </trans-unit>
        <trans-unit id="85f441746093557e9ec7fe5f7c0d91f2ae4fdd6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; 类似于&lt;a href=&quot;#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;，但另外允许的类型的字段来施工后进行设置。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;复合类型&lt;/a&gt; &amp;rdquo;手册部分。</target>
        </trans-unit>
        <trans-unit id="112c939f3f1e9b5e8b278904ec6b0b49257b0632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="320c0e13d8c7b9ff51bc77d61fd9070c11bc1ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is the total number of instruction pointers you can store, with a default value of &lt;code&gt;10^6&lt;/code&gt;. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most applications.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 是您可以存储的指令指针总数，默认值为 &lt;code&gt;10^6&lt;/code&gt; 。如果您的典型回溯是20个指令指针，那么您可以收集50000个回溯，这表明统计不确定性小于1％。对于大多数应用程序来说，这可能已经足够了。</target>
        </trans-unit>
        <trans-unit id="e658555bc40ad43ec211978ec0729a0b02c58be6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The full name of the committer or author of the commit.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ：提交者或提交作者的全名。</target>
        </trans-unit>
        <trans-unit id="552e03fffa49ac0ec7ab0ea1aaa5c130fedf4f05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The name in the local reference database of the fetch head, for example, &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ：访存头的本地引用数据库中的名称，例如 &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d29f5a5c3f202febb2a81757e5b837859f3823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ncodeunits(str)&lt;/code&gt; number of &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;code units&lt;/a&gt; in a string.</source>
          <target state="translated">&lt;code&gt;ncodeunits(str)&lt;/code&gt; 字符串中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;代码单元&lt;/a&gt;数。</target>
        </trans-unit>
        <trans-unit id="f909eb780ec20a645e7ec717e2b09ab499055360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="735cb1802f16a2c6f76996e3fbd8153f32d4f6fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) after the changes.</source>
          <target state="translated">&lt;code&gt;new_file&lt;/code&gt; ：&lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; ,&lt;/a&gt;其中包含有关更改后文件的信息。</target>
        </trans-unit>
        <trans-unit id="7be2c96b12a02f7083c9d25ea7528ad8667d09e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_prefix&lt;/code&gt;: the virtual file directory in which to place new files on one side of the diff. Default is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_prefix&lt;/code&gt; ：虚拟文件目录，用于在diff的一侧放置新文件。默认值为 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8c2e95eb3130b139d44d439028bbbfabf438e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the newest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;newest_commit&lt;/code&gt; ：用于查看更改的最新提交的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f40f498efe7ceacbe5a57c6f819e21dd76050f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline2lf=true&lt;/code&gt;, &lt;code&gt;newline2ls=true&lt;/code&gt;, or &lt;code&gt;newline2ps=true&lt;/code&gt;: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively</source>
          <target state="translated">&lt;code&gt;newline2lf=true&lt;/code&gt; ， &lt;code&gt;newline2ls=true&lt;/code&gt; 或 &lt;code&gt;newline2ps=true&lt;/code&gt; ：分别将各种换行序列（LF，CRLF，CR，NEL）转换为换行符（LF），行分隔符（LS）或段落分隔符（PS）</target>
        </trans-unit>
        <trans-unit id="4ec45f42c32c00b527d28e030133b724dbf610e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nfiles&lt;/code&gt;: The number of files in the delta (for instance, if the delta was run on a submodule commit id, it may contain more than one file).</source>
          <target state="translated">&lt;code&gt;nfiles&lt;/code&gt; ：增量中的文件数（例如，如果增量是在子模块提交ID上运行的，则它可能包含多个文件）。</target>
        </trans-unit>
        <trans-unit id="13583c0cdd9e082972c1e68b453244539921d780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that are below the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash;限制样本启发式底噪以下的帧（仅适用于格式 &lt;code&gt;:tree&lt;/code&gt; ）。尝试此操作的建议值为2.0（默认值为0）。此参数隐藏 &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; 的样本，其中 &lt;code&gt;n&lt;/code&gt; 是该行上的样本数， &lt;code&gt;N&lt;/code&gt; 是被叫方的样本数。</target>
        </trans-unit>
        <trans-unit id="f539796532455743d77bf293cbd17e25f2f2dad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that exceed the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash;限制超出样本启发式本底噪声的帧（仅适用于格式 &lt;code&gt;:tree&lt;/code&gt; ）。尝试此操作的建议值为2.0（默认值为0）。此参数隐藏 &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; 的样本，其中 &lt;code&gt;n&lt;/code&gt; 是该行上的样本数， &lt;code&gt;N&lt;/code&gt; 是被叫方的样本数。</target>
        </trans-unit>
        <trans-unit id="7cccdf2a98a9aae590bd349512e62d461403b275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: An optional callback function to notify the user if a checkout conflict occurs. If this function returns a non-zero value, the checkout will be cancelled.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; ：可选的回调函数，用于在发生结帐冲突时通知用户。如果此函数返回非零值，则结帐将被取消。</target>
        </trans-unit>
        <trans-unit id="30392c812d865b5c68f24732d969c588932dc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: optional callback which will notify the user of changes to the diff as file deltas are added to it.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; ：可选回调，当添加文件增量时，它将通知用户对diff的更改。</target>
        </trans-unit>
        <trans-unit id="5d44c57c1841b302e1e4a4864a4e16016feedd35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_flags&lt;/code&gt;: Flags for what sort of conflicts the user should be notified about.</source>
          <target state="translated">&lt;code&gt;notify_flags&lt;/code&gt; ：有关应通知用户哪种冲突的标志。</target>
        </trans-unit>
        <trans-unit id="c444029454795fde1134c2d469857e669b1440c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_payload&lt;/code&gt;: Payload for the notify callback function.</source>
          <target state="translated">&lt;code&gt;notify_payload&lt;/code&gt; ：notify回调函数的有效负载。</target>
        </trans-unit>
        <trans-unit id="f8a72ff21213c5747c87230deb5736ece00049c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of &lt;code&gt;ntasks_func&lt;/code&gt; is less than the current number of tasks.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; 也可以将ntasks指定为零参数函数。在这种情况下，如果 &lt;code&gt;ntasks_func&lt;/code&gt; 的值小于当前任务数，则在处理每个元素之前检查要并行运行的任务数，并开始一个新任务。</target>
        </trans-unit>
        <trans-unit id="28a2d799c4775665ec0492395458a2421920f94b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; specifies the number of tasks to run concurrently. Depending on the length of the collections, if &lt;code&gt;ntasks&lt;/code&gt; is unspecified, up to 100 tasks will be used for concurrent mapping.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; 指定要同时运行的任务数。根据集合的长度，如果未指定 &lt;code&gt;ntasks&lt;/code&gt; ，则最多100个任务将用于并发映射。</target>
        </trans-unit>
        <trans-unit id="649eb66db0ac1d45f589aa8e9473637c03ceaed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; allows you to skip the specified number of bytes at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 使您可以跳过文件开头的指定字节数。</target>
        </trans-unit>
        <trans-unit id="f497a87199a32512c97994d5a18e9f772067d770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oid&lt;/code&gt;: The &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the tip of the fetch head.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; ：获取头尖端的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1944d05e865a7be7c70b13dc44ad49d6eef824c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) before the changes.</source>
          <target state="translated">&lt;code&gt;old_file&lt;/code&gt; ：&lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; ,&lt;/a&gt;其中包含有关更改之前的文件的信息。</target>
        </trans-unit>
        <trans-unit id="0c4e9a36bc861c7981c727529931615c5c12cf7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_prefix&lt;/code&gt;: the virtual file directory in which to place old files on one side of the diff. Default is &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_prefix&lt;/code&gt; ：虚拟文件目录，将旧文件放在diff的一侧。默认值为 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c31e5cf28678d5c969358670eb5133dd3159a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oldest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the oldest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;oldest_commit&lt;/code&gt; ：用于查看更改的最早提交的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ab08f6dbafd16b32ce5160a5db1168198264195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;only_follow_first_parent&lt;/code&gt;: when finding the distance from a matching reference to the described object, only consider the distance from the first parent.</source>
          <target state="translated">&lt;code&gt;only_follow_first_parent&lt;/code&gt; ：查找从匹配引用到所描述对象的距离时，仅考虑与第一个父对象的距离。</target>
        </trans-unit>
        <trans-unit id="cf7b1529623e34aaf3b56dcbaf1430c042e15e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimize&lt;/code&gt; controls whether additional optimizations, such as inlining, are also applied. &lt;code&gt;raw&lt;/code&gt; makes all metadata and dbg.* calls visible. &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; (default) or &lt;code&gt;:none&lt;/code&gt;, to specify the verbosity of code comments. &lt;code&gt;dump_module&lt;/code&gt; prints the entire module that encapsulates the function.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 控制是否还应用其他优化（例如内联）。 &lt;code&gt;raw&lt;/code&gt; 使所有元数据和dbg。*调用可见。 &lt;code&gt;debuginfo&lt;/code&gt; 可以是 &lt;code&gt;:source&lt;/code&gt; （默认）或 &lt;code&gt;:none&lt;/code&gt; 之一，以指定代码注释的详细程度。 &lt;code&gt;dump_module&lt;/code&gt; 将打印封装该函数的整个模块。</target>
        </trans-unit>
        <trans-unit id="5c0c73b16f432720504516e2f958debb7c0a4f9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the fetch, e.g. whether to prune afterwards. See &lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt;&lt;code&gt;FetchOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; ：确定获取的选项，例如，之后是否修剪。有关更多信息，请参见&lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt; &lt;code&gt;FetchOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a9ddb6ecff4eeaf4d380bca97b4dd6f7fde407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the push, e.g. which proxy headers to use. See &lt;a href=&quot;#LibGit2.PushOptions&quot;&gt;&lt;code&gt;PushOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; ：确定推送的选项，例如要使用的代理标头。有关更多信息，请参见&lt;a href=&quot;#LibGit2.PushOptions&quot;&gt; &lt;code&gt;PushOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7f25b0d9ee03294770f82dddd1bc7bcef0fb64c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optype&lt;/code&gt;: the type of rebase operation currently being performed. The options are:</source>
          <target state="translated">&lt;code&gt;optype&lt;/code&gt; ：当前正在执行的变基操作的类型。选项包括：</target>
        </trans-unit>
        <trans-unit id="d3e3a0e908208f76b5ccd84be51a34bb39927cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ospid&lt;/code&gt; &amp;ndash; the process ID according to the host OS, used to interrupt worker processes</source>
          <target state="translated">&lt;code&gt;ospid&lt;/code&gt; &amp;ndash;根据主机操作系统的进程ID，用于中断工作进程</target>
        </trans-unit>
        <trans-unit id="697de2c67496b1d84f2571e138792286e7da4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;our_label&lt;/code&gt;: In case of conflicts, the name of &quot;our&quot; side.</source>
          <target state="translated">&lt;code&gt;our_label&lt;/code&gt; ：如有冲突，请使用&amp;ldquo;我们的&amp;rdquo;一面的名称。</target>
        </trans-unit>
        <trans-unit id="6830be65e4ac77ca9e62be6dc5c7e0620fc0523a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, &lt;code&gt;norm(A, Inf)&lt;/code&gt; returns the largest value in &lt;code&gt;abs.(A)&lt;/code&gt;, whereas &lt;code&gt;norm(A, -Inf)&lt;/code&gt; returns the smallest. If &lt;code&gt;A&lt;/code&gt; is a matrix and &lt;code&gt;p=2&lt;/code&gt;, then this is equivalent to the Frobenius norm.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 可以假定任何数值（即使并非所有值都产生数学上有效的向量范数）。特别是， &lt;code&gt;norm(A, Inf)&lt;/code&gt; 返回 &lt;code&gt;abs.(A)&lt;/code&gt; 最大值，而 &lt;code&gt;norm(A, -Inf)&lt;/code&gt; 返回最小值。如果 &lt;code&gt;A&lt;/code&gt; 是矩阵且 &lt;code&gt;p=2&lt;/code&gt; ，则这等效于Frobenius范数。</target>
        </trans-unit>
        <trans-unit id="c1263f31af18883ad798ffeb9ebfc0a698a746ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallelism&lt;/code&gt;: if a pack file must be created, this variable sets the number of worker threads which will be spawned by the packbuilder. If &lt;code&gt;0&lt;/code&gt;, the packbuilder will auto-set the number of threads to use. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parallelism&lt;/code&gt; ：如果必须创建一个打包文件，则此变量设置将由packbuilder产生的工作线程数。如果为 &lt;code&gt;0&lt;/code&gt; ，packbuilder将自动设置要使用的线程数。默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="062dd574e97337bbf0642f566cbd632bf4e6858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params::Dict&lt;/code&gt;: all the keyword arguments passed to &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;params::Dict&lt;/code&gt; ：所有传递给&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;的关键字参数</target>
        </trans-unit>
        <trans-unit id="2c7beec041180be0f67a5413cf19dc80f87f5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; is a list of commits by &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.</source>
          <target state="translated">&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; 是&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;用作新提交的父提交的提交列表，可以为空。例如，如果一个提交是一个合并提交，则可能有多个父级。</target>
        </trans-unit>
        <trans-unit id="2aeba9857371fd4afaedeaa23fe9e52591dc0285" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parse(Bool, str)&lt;/code&gt; requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;parse(Bool, str)&lt;/code&gt; 至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="985febc2923b1ba06875dac2b326b7c44efb7b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt;: the password to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt; ：如果提供的话，在输出中使用的密码。</target>
        </trans-unit>
        <trans-unit id="7b2d565e6b56d3e37cd4a4c107b73f4f88a4add0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt;: the path to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt; ：如果提供的话，在输出中使用的路径。</target>
        </trans-unit>
        <trans-unit id="6bbb797e9183ff39fe99d21ff1e7ff0b15d193b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the path to the source file to open</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; -要打开的源文件的路径</target>
        </trans-unit>
        <trans-unit id="83a1cfd3ac44390db0e2939f5bb09d810d9dc716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt;: a &lt;code&gt;NULL&lt;/code&gt; terminated path to the item relative to the working directory of the repository.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; ：相对于存储库工作目录的项的 &lt;code&gt;NULL&lt;/code&gt; 终止路径。</target>
        </trans-unit>
        <trans-unit id="df78851e58e7c0164b5edaedb4aae38730252715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;: If not empty, describes which paths to search during the checkout. If empty, the checkout will occur over all files in the repository.</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt; ：如果不为空，则描述在结帐期间要搜索的路径。如果为空，则检出将在存储库中的所有文件上进行。</target>
        </trans-unit>
        <trans-unit id="aaac9c176103fbec24dd83078cf0783db26c54ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of &lt;code&gt;show&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; ：用于路径匹配的路径数组。路径匹配的行为将根据 &lt;code&gt;show&lt;/code&gt; 和 &lt;code&gt;flags&lt;/code&gt; 的值而变化。</target>
        </trans-unit>
        <trans-unit id="ff5de9b2330e81c1ec09cc2a025ec36b4958e8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: path to files to include in the diff. Default is to use all files in the repository.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; ：要包含在差异中的文件的路径。默认为使用存储库中的所有文件。</target>
        </trans-unit>
        <trans-unit id="5d5c79832426fbf09095f04929a254af7d30d839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt;: only consider tags which match &lt;code&gt;pattern&lt;/code&gt;. Supports glob expansion.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; ：仅考虑与 &lt;code&gt;pattern&lt;/code&gt; 匹配的标签。支持全局扩展。</target>
        </trans-unit>
        <trans-unit id="faa8387984da43a7639fa49609355dfec1758934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to be provided to the two callback functions.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; ：提供给两个回调函数的有效负载。</target>
        </trans-unit>
        <trans-unit id="66e76aa49d7a614c921c6cec0e182e1bd4a6645c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to pass to &lt;code&gt;notify_cb&lt;/code&gt; and &lt;code&gt;progress_cb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; ：传递给 &lt;code&gt;notify_cb&lt;/code&gt; 和 &lt;code&gt;progress_cb&lt;/code&gt; 的有效负载。</target>
        </trans-unit>
        <trans-unit id="2913a1a2626baab62573ae3ba9c2e917e2edec43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peakflops&lt;/code&gt; computes the peak flop rate of the computer by using double precision &lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt;&lt;code&gt;gemm!&lt;/code&gt;&lt;/a&gt;. By default, if no arguments are specified, it multiplies a matrix of size &lt;code&gt;n x n&lt;/code&gt;, where &lt;code&gt;n = 2000&lt;/code&gt;. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with &lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt;&lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;peakflops&lt;/code&gt; 通过使用双精度&lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt; &lt;code&gt;gemm!&lt;/code&gt; &lt;/a&gt;来计算计算机的峰值翻转率！。默认情况下，如果未指定任何参数，它将乘以大小为 &lt;code&gt;n x n&lt;/code&gt; 的矩阵，其中 &lt;code&gt;n = 2000&lt;/code&gt; 。如果基础的BLAS使用多个线程，则可以实现更高的翻牌率。可以使用&lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt; &lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt; &lt;/a&gt;设置BLAS线程数。</target>
        </trans-unit>
        <trans-unit id="87b91990e60f0a690dd7da2850cc5ea9cee3bec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_cb&lt;/code&gt;: An optional callback function to display performance data.</source>
          <target state="translated">&lt;code&gt;perfdata_cb&lt;/code&gt; ：显示性能数据的可选回调函数。</target>
        </trans-unit>
        <trans-unit id="e9d2d97fa30fe0159febc55e5a72c5956e0c05f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_payload&lt;/code&gt;: Payload for the performance callback.</source>
          <target state="translated">&lt;code&gt;perfdata_payload&lt;/code&gt; ：性能回调的有效负载。</target>
        </trans-unit>
        <trans-unit id="c5c86680e44cfade629b4ed2ebc1670d3a11ff31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pmap&lt;/code&gt; can also use a mix of processes and tasks via the &lt;code&gt;batch_size&lt;/code&gt; argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length &lt;code&gt;batch_size&lt;/code&gt; or less. A batch is sent as a single request to a free worker, where a local &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt; processes elements from the batch using multiple concurrent tasks.</source>
          <target state="translated">&lt;code&gt;pmap&lt;/code&gt; 也可以通过 &lt;code&gt;batch_size&lt;/code&gt; 参数混合使用进程和任务。对于大于1的批次大小，将以多个批次处理集合，每个批次的长度不超过 &lt;code&gt;batch_size&lt;/code&gt; 。批处理作为单个请求发送到一个免费的工作程序，其中本地&lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;使用多个并发任务处理该批处理中的元素。</target>
        </trans-unit>
        <trans-unit id="a6062089bc8ea7356a1c0e294144b992c9b0d190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt;: the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt; ：要提供的输出中使用的端口号。使用类似scp的语法时无法指定。</target>
        </trans-unit>
        <trans-unit id="3926b6e41c21bebec38e3305ee3aef86c0f67cdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; the port on the host used to connect to the worker (either an &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; &amp;ndash;主机上用于连接工作服务器的端口（ &lt;code&gt;Int&lt;/code&gt; 或 &lt;code&gt;Nothing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d7ae02e4311ab0f64e68f548cb0826d87786e864" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;power_method&lt;/code&gt; repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's see if it works with the aforementioned datatypes:</source>
          <target state="translated">&lt;code&gt;power_method&lt;/code&gt; 反复创建一个新向量并将其标准化。我们没有在函数声明中指定任何类型签名，让我们看看它是否适用于上述数据类型：</target>
        </trans-unit>
        <trans-unit id="9113fbab087ead22351138a5675e71d4cc277d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision&lt;/code&gt; as a keyword argument requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;precision&lt;/code&gt; is the second positional argument (&lt;code&gt;BigFloat(x, precision)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;precision&lt;/code&gt; 作为关键字参数至少需要Julia 1.1。在Julia 1.0中， &lt;code&gt;precision&lt;/code&gt; 是第二个位置参数（ &lt;code&gt;BigFloat(x, precision)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af54082b04f05e356fa41312f4ae5ca97f259a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt; declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; 声明一种具体类型，其数据仅由一系列位组成。基本类型的经典示例是整数和浮点值。内置原始类型声明的一些示例：</target>
        </trans-unit>
        <trans-unit id="d408d986573283a26cbda182d85b826b49383c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="ce0cc2b360368626a735bd2ae5d7c2a083fbb6e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; &quot;lock&quot; the stream during a call. Consequently changing &lt;code&gt;write&lt;/code&gt; to &lt;code&gt;println&lt;/code&gt; in the above example results in:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 在呼叫期间，print和 &lt;code&gt;println&lt;/code&gt; &amp;ldquo;锁定&amp;rdquo;流。因此，在以上示例中将对 &lt;code&gt;println&lt;/code&gt; 的 &lt;code&gt;write&lt;/code&gt; 更改为：</target>
        </trans-unit>
        <trans-unit id="1959b9f7871b156edd3a2de5e77463b33177e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; falls back to calling &lt;code&gt;show&lt;/code&gt;, so most types should just define &lt;code&gt;show&lt;/code&gt;. Define &lt;code&gt;print&lt;/code&gt; if your type has a separate &quot;plain&quot; representation. For example, &lt;code&gt;show&lt;/code&gt; displays strings with quotes, and &lt;code&gt;print&lt;/code&gt; displays strings without quotes.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 可以回溯到 &lt;code&gt;show&lt;/code&gt; 调用，因此大多数类型应该只定义 &lt;code&gt;show&lt;/code&gt; 。如果您的类型具有单独的&amp;ldquo;普通&amp;rdquo;表示形式，请定义 &lt;code&gt;print&lt;/code&gt; 。例如， &lt;code&gt;show&lt;/code&gt; 显示带引号的字符串，而 &lt;code&gt;print&lt;/code&gt; 显示不带引号的字符串。</target>
        </trans-unit>
        <trans-unit id="d0178c5df89eb967f462cc2e8445f025988bec10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;process&lt;/code&gt; &amp;ndash; the process which will be connected (usually the manager will assign this during &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; &amp;ndash;将要连接的流程（通常，经理将在&lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;期间分配该流程）</target>
        </trans-unit>
        <trans-unit id="c63a4f1761d5adacd1e7460b66b481bd63cdd398" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: An optional callback function to display checkout progress.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; ：可选的回调函数，用于显示结帐进度。</target>
        </trans-unit>
        <trans-unit id="7cb6a0f147459271d2a7a2a1bcb82b298199436d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: optional callback which will display diff progress. Only relevant on libgit2 versions at least as new as 0.24.0.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; ：可选的回调，将显示差异进度。仅与libgit2版本相关，至少新于0.24.0。</target>
        </trans-unit>
        <trans-unit id="a974da56e773f57fa11edfba525b0d17e70b3e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_payload&lt;/code&gt;: Payload for the progress callback.</source>
          <target state="translated">&lt;code&gt;progress_payload&lt;/code&gt; ：进度回调的有效负载。</target>
        </trans-unit>
        <trans-unit id="9656c555e40a59798ca04ab2a0fd64ef8fcd145d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propertynames(x)&lt;/code&gt; may return only &quot;public&quot; property names that are part of the documented interface of &lt;code&gt;x&lt;/code&gt;. If you want it to also return &quot;private&quot; fieldnames intended for internal use, pass &lt;code&gt;true&lt;/code&gt; for the optional second argument. REPL tab completion on &lt;code&gt;x.&lt;/code&gt; shows only the &lt;code&gt;private=false&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;propertynames(x)&lt;/code&gt; 可能返回是的文档接口部分仅&amp;ldquo;公共&amp;rdquo;属性名称 &lt;code&gt;x&lt;/code&gt; 。如果您还希望它返回供内部使用的&amp;ldquo;私有&amp;rdquo;字段名称，请为可选的第二个参数传递 &lt;code&gt;true&lt;/code&gt; 。在 &lt;code&gt;x.&lt;/code&gt; 完成REPL标签页。仅显示 &lt;code&gt;private=false&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="29d345329a2391a60fb2ebd4642c5f13f15f3a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: only relevant if the LibGit2 version is greater than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. Sets options for using a proxy to communicate with a remote. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; ：仅当LibGit2版本大于或等于 &lt;code&gt;0.25.0&lt;/code&gt; 时才相关。设置使用代理与遥控器通信的选项。有关更多信息，请参见&lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a1c2878a9100523ed8ddcdc2ca50b8e3e3accca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: options for connecting to the remote through a proxy. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt;. Only present on libgit2 versions newer than or equal to 0.25.0.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; ：通过代理连接到远程的选项。请参阅&lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; &lt;/a&gt;。仅存在于高于或等于0.25.0的libgit2版本上。</target>
        </trans-unit>
        <trans-unit id="2d1cca20f02fc7ef7b42d7136de423456f81b239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxytype&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for the type of proxy to use. Defined in &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt;&lt;code&gt;git_proxy_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_PROXY&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;proxytype&lt;/code&gt; ：要使用的代理类型的 &lt;code&gt;enum&lt;/code&gt; 。在&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt; &lt;code&gt;git_proxy_t&lt;/code&gt; 中&lt;/a&gt;定义。对应的Julia枚举是 &lt;code&gt;GIT_PROXY&lt;/code&gt; ，其值是：</target>
        </trans-unit>
        <trans-unit id="7c30e484bc5a233582234aa0eaf5f9ff4b81c5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prune&lt;/code&gt;: whether to perform a prune after the fetch or not. The default is to use the setting from the &lt;code&gt;GitConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; ：是否在获取后执行修剪。默认是使用 &lt;code&gt;GitConfig&lt;/code&gt; 中的设置。</target>
        </trans-unit>
        <trans-unit id="80d39971bfff573dc1ff9e1372624b262b5a7768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put!&lt;/code&gt; - put back a worker to the available pool</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; -将工人放回可用的游泳池</target>
        </trans-unit>
        <trans-unit id="a29ba5aea9b5cc34e1af996fefeb1a63d0872750" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;qr!&lt;/code&gt; 当 &lt;code&gt;A&lt;/code&gt; 是&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;的子类型时，它与&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。一个&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;如果分解产生许多不通过的元素类型可表示的则抛出异常 &lt;code&gt;A&lt;/code&gt; 整数类型，例如。</target>
        </trans-unit>
        <trans-unit id="5d064f8a98d481de062cba01c97539bfc2f0871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;StridedMatrix&lt;/code&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;qr!&lt;/code&gt; 当 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;StridedMatrix&lt;/code&gt; 的子类型时，它与&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。一个&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;如果分解产生许多不通过的元素类型可表示的则抛出异常 &lt;code&gt;A&lt;/code&gt; 整数类型，例如。</target>
        </trans-unit>
        <trans-unit id="cf9e4bad0fd4a4794a48064d48581af7033259a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr&lt;/code&gt; returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; matrices can be stored compactly rather as two separate dense matrices.</source>
          <target state="translated">&lt;code&gt;qr&lt;/code&gt; 返回多种类型，因为LAPACK使用几种表示形式来最小化Householder基本反射器产品的内存存储要求，因此 &lt;code&gt;Q&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 矩阵可以紧凑地存储，而不能作为两个单独的密集矩阵存储。</target>
        </trans-unit>
        <trans-unit id="fe298f4b4614717693aba0cf7548649332f44a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qsort&lt;/code&gt; expects a comparison function that return a C &lt;code&gt;int&lt;/code&gt;, so we annotate the return type to be &lt;code&gt;Cint&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;qsort&lt;/code&gt; 需要一个返回C &lt;code&gt;int&lt;/code&gt; 的比较函数，因此我们将返回类型注释为 &lt;code&gt;Cint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56b9466c550831a8245833d9e56b4ae895f63c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quiet&lt;/code&gt;: inform other git clients helping with/working on the rebase that the rebase should be done &quot;quietly&quot;. Used for interoperability. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; ：通知其他帮助/从事rebase工作的git客户说rebase应该&amp;ldquo;安静地&amp;rdquo;完成。用于互操作性。默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89148ab980d30701194964666d016c3558cde6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt; creates multiple expression objects in a block without using the explicit &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. For example:</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt; 在一个块中创建多个表达式对象，而无需使用显式的&lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;构造函数。例如：</target>
        </trans-unit>
        <trans-unit id="1f3b9755167388bcf3471ba197b6c40b6008de5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9096a143fba87878f860ce663f000649f6400ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; produces a regular expression object rather than a string</source>
          <target state="translated">&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 产生一个正则表达式对象而不是一个字符串</target>
        </trans-unit>
        <trans-unit id="6ec672446bd53c264182855affbe5a78b442fb6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;: restricts operations to the buffer; see &lt;code&gt;open&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;append&lt;/code&gt; ：限制对缓冲区的操作；有关详细信息，请参见 &lt;code&gt;open&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecf721b9c658fe1430c1a0d12d81daeb2549a2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recur&lt;/code&gt; &amp;ndash; Controls the recursion handling in &lt;code&gt;:tree&lt;/code&gt; format. &lt;code&gt;:off&lt;/code&gt; (default) prints the tree as normal. &lt;code&gt;:flat&lt;/code&gt; instead compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator. &lt;code&gt;:flatc&lt;/code&gt; does the same but also includes collapsing of C frames (may do odd things around &lt;code&gt;jl_apply&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;recur&lt;/code&gt; &amp;ndash;控制 &lt;code&gt;:tree&lt;/code&gt; 格式的递归处理。 &lt;code&gt;:off&lt;/code&gt; （默认）正常打印树。 &lt;code&gt;:flat&lt;/code&gt; 而是压缩任何递归（通过ip），显示将任何自递归转换为迭代器的近似效果。 &lt;code&gt;:flatc&lt;/code&gt; 可以做到这一点，但是还包括折叠C帧（可能在 &lt;code&gt;jl_apply&lt;/code&gt; 周围做一些奇怪的事情）。</target>
        </trans-unit>
        <trans-unit id="00fbd8f3deb831b9f5ec8b1264c745debaec29b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursion_limit&lt;/code&gt;: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; ：尝试为合并创建新的虚拟合并库而执行的公共祖先合并数的上限。默认值是没有限制。该字段仅出现在libgit2版本低于0.24.0的版本中。</target>
        </trans-unit>
        <trans-unit id="e3223e9226e352a329b29a7eace6c1d31eb0a618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt;: if not NULL, the name of the reference to update to point to the new commit. For example, &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; will update the HEAD of the current branch. If the reference does not yet exist, it will be created.</source>
          <target state="translated">&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt; ：如果不为NULL，则更新引用的名称以指向新提交。例如， &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; 将更新当前分支的HEAD。如果引用尚不存在，将创建该引用。</target>
        </trans-unit>
        <trans-unit id="7c7e2623afd5bf4ea28699952aaf1e41bf326a1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the fetch.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; ：确定获取的属性。</target>
        </trans-unit>
        <trans-unit id="cad51a938d649503c2ef46d1225a6fc56968236e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the push.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; ：确定推送的属性。</target>
        </trans-unit>
        <trans-unit id="789e0d7504799b3b38c290db69c2914eaa79a006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rejectna=true&lt;/code&gt;: throw an error if unassigned code points are found</source>
          <target state="translated">&lt;code&gt;rejectna=true&lt;/code&gt; ：如果找到未分配的代码点，则引发错误</target>
        </trans-unit>
        <trans-unit id="47c34491f7ee239ad33defe253fb1defd64e8594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: the name of the upstream remote to push to.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; ：要推送到的上游远程的名称。</target>
        </trans-unit>
        <trans-unit id="4b26ba19c7207aa3b208454b432a26db97e4da0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: which remote, specified by name, of &lt;code&gt;repo&lt;/code&gt; to fetch from. If this is empty, the URL will be used to construct an anonymous remote.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; ：要从其 &lt;code&gt;repo&lt;/code&gt; 远程存储（按名称指定）。如果为空，则将使用URL构造匿名远程。</target>
        </trans-unit>
        <trans-unit id="ffdcacc6e1483f4d462c34f2bea9360ca75d4db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt;: a callback which will be used to create the remote before it is cloned. If &lt;code&gt;C_NULL&lt;/code&gt; (the default), no attempt will be made to create the remote - it will be assumed to already exist.</source>
          <target state="translated">&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt; ：一个回调，将用于在克隆之前创建远程。如果 &lt;code&gt;C_NULL&lt;/code&gt; （默认值），则不尝试创建远程服务器-假定它已经存在。</target>
        </trans-unit>
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; ：一个可选的回调，用于在&lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt;进行克隆之前创建GitRemote。</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; ：远程回调的有效负载。</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; 是一个低级别的API返回一个 &lt;code&gt;RRID&lt;/code&gt; 对象包裹 &lt;code&gt;whence&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 的远程引用的值。</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; ： &lt;code&gt;remote&lt;/code&gt; 的URL 。</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; ： &lt;code&gt;remote&lt;/code&gt; 的URL 。如果未指定，则将基于给定的 &lt;code&gt;remote&lt;/code&gt; 假设。</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; ：两个文件必须如何相似才能将一个文件重命名为另一个文件。这是设置百分比相似度的整数。默认值为50。</target>
        </trans-unit>
        <trans-unit id="a1f245ca6c95e5deef1b0ce6ee0330ae1e9c18b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repetition&lt;/code&gt; can be &lt;code&gt;Val(1)&lt;/code&gt; or &lt;code&gt;Val(Inf)&lt;/code&gt;, and should be used as a suggestion for deciding the amount of precomputation, if applicable.</source>
          <target state="translated">&lt;code&gt;repetition&lt;/code&gt; 可以是 &lt;code&gt;Val(1)&lt;/code&gt; 或 &lt;code&gt;Val(Inf)&lt;/code&gt; ，并且应该用作确定预计算量的建议（如果适用）。</target>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; ：一个可选的回调，将用于创建克隆所建立的&lt;em&gt;新&lt;/em&gt;存储库。</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; ：存储库回调的有效负载。</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 以字符串形式返回 &lt;code&gt;show&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; 导致封闭函数提前退出，将给定值 &lt;code&gt;x&lt;/code&gt; 返回给其调用方。没有值的本身 &lt;code&gt;return&lt;/code&gt; 就等于 &lt;code&gt;return nothing&lt;/code&gt; （&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;没有看到）。</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; ：注释的引用名称，用于在完成基准库后重写提交注释。</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; 是对日志元数据进行右对齐的整数列。默认值为零（元数据单独显示）。</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 用这个舍入模式是一个别名&lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 用这个舍入模式是一个别名&lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 用这个舍入模式是一个别名&lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 允许 &lt;code&gt;.&lt;/code&gt; 修饰符以匹配换行符。</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; 已被标记为（实）对称的矩阵，因此对于以后可能在其上执行的操作（例如本征因数分解或计算矩阵向量乘积），仅参考其中的一半即可发现效率。例如：</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; ：URL模式，用于标识要使用的协议。对于HTTP，使用&amp;ldquo; http&amp;rdquo;，在SSH中使用&amp;ldquo; ssh&amp;rdquo;，等等。如果未提供 &lt;code&gt;scheme&lt;/code&gt; ,则输出格式将为&amp;ldquo; ssh&amp;rdquo;，但使用类似scp的语法。</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; ：如果 &lt;code&gt;:wrap&lt;/code&gt; 然后将光标环绕在顶部和底部，如果： &lt;code&gt;nowrap&lt;/code&gt; 不包装光标</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ，则在分支创建完成后，将分支头设置为 &lt;code&gt;repo&lt;/code&gt; 的HEAD 。</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; 可以加快某些硬件上的计算速度。但是，它可能破坏诸如 &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; 标识。</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; 接受类型为 &lt;code&gt;UInt8&lt;/code&gt; 的元素的 &lt;code&gt;AbstractString&lt;/code&gt; 和类似数组的对象（ &lt;code&gt;NTuple&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; ：一个标志，指示要检查的文件以及顺序。默认值为 &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; ：如果找不到描述提交的匹配参考，请显示提交的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;而不是抛出错误（默认行为）。</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; 通过在格式化期间设置 &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; 键，将大数据结构的打印限制为适合屏幕显示的内容。</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; ：标记者的签名。</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; ：用于指示文件是否已重命名或复制。</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7997da896750d945cfa8c2d3cb4698bd3a261b9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; ：项目的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; ：建议缓冲区的容量（ &lt;code&gt;data&lt;/code&gt; 必须实现 &lt;code&gt;sizehint!(data, size)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b8c3ba1857a9b0055e1e04c56e79b38b776b38ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples, and &lt;code&gt;:overhead&lt;/code&gt; sorts by the number of samples incurred by each function by itself.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash;以 &lt;code&gt;:flat&lt;/code&gt; 格式控制顺序。 &lt;code&gt;:filefuncline&lt;/code&gt; （默认）按源代码行排序， &lt;code&gt;:count&lt;/code&gt; 按收集的样本数顺序排序，而 &lt;code&gt;:overhead&lt;/code&gt; 按每个函数自身产生的样本数排序。</target>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash;以 &lt;code&gt;:flat&lt;/code&gt; 格式控制顺序。 &lt;code&gt;:filefuncline&lt;/code&gt; （默认）按源代码行排序，而 &lt;code&gt;:count&lt;/code&gt; 按收集的样本数顺序排序。</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; 自然会扩展到更高的维度。例如，如果 &lt;code&gt;A&lt;/code&gt; 是一个 2x2x2数组， &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; 将对第3维内的切片进行排序，并将2x2切片 &lt;code&gt;A[:, :, 1]&lt;/code&gt; 和 &lt;code&gt;A[:, :, 2]&lt;/code&gt; 传递给比较函数。请注意，虽然高维切片上没有默认顺序，但是您可以使用 &lt;code&gt;by&lt;/code&gt; 或 &lt;code&gt;lt&lt;/code&gt; 关键字参数来指定这样的顺序。</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 是文本规范：完整列表请参见&lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;git docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; &lt;code&gt;&amp;radic;x&lt;/code&gt; （x），&amp;radic;x</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash;用于建立SSH连接的标志</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; ：指定附加的ssh选项，例如 &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; ：强制执行Unicode版本控制稳定性</target>
        </trans-unit>
        <trans-unit id="c3f34cc201b5d8b2b94a13ec51d0f5a9bea4d457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode versioning stability (never introduce characters missing from earlier Unicode versions)</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; ：增强Unicode版本稳定性（切勿引入早期Unicode版本中缺少的字符）</target>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; 是一个内部函数，它是通过TCP / IP连接的工作进程的默认入口点。它将过程设置为Julia集群工作者。</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; 不会将锚点编译为正则表达式，而是将锚点作为 &lt;code&gt;match_option&lt;/code&gt; 传递给PCRE。如果摊销编译时间，则 &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; 的发生速度比 &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; 速度更快。</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; ： &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; 之一，指示是否已添加/修改/删除文件。</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; ：包含文件的状态标志，指示该文件是当前文件，还是已在索引或工作树中进行了某种更改。</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 因为位置参数至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 可以将stop指定为位置参数或关键字参数。</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 必须是 &lt;code&gt;TTY&lt;/code&gt; ， &lt;code&gt;Pipe&lt;/code&gt; 或套接字。</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 通常不应直接定义。而是定义一个方法 &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; 。如果某种类型的 &lt;code&gt;string(x)&lt;/code&gt; 需要高效，那么可以在 &lt;code&gt;string&lt;/code&gt; 中添加一个方法并定义 &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; 确保功能一致。</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; 可以是元素 &lt;code&gt;x&lt;/code&gt; 上任何可迭代的元素，这些元素可以通过 &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; 转换为字符串。 &lt;code&gt;strings&lt;/code&gt; 将被打印到 &lt;code&gt;io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; ：剥离控制字符；水平制表符和换页符将转换为空格；换行符也将转换为空格，除非指定了换行符转换标志</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; ：去除 Unicode的&amp;ldquo;默认可忽略&amp;rdquo;字符（例如，软连字符或从左到右的标记）</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; ：带变音符（例如重音符号）</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; （包括typedef到一个struct）</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 默认是不可变的；这些类型之一的实例在构造后无法修改。改用&lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt;来声明其实例可以修改的类型。</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; （子类型运算符的反向）</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; ：用于测试。如果为true，则不会将菜单打印到控制台。</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;相同，但是就地修改参数 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，而不是进行复制。</target>
        </trans-unit>
        <trans-unit id="5ac943a1020666f7a7da5c2717895ed9dd7a951a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;相同，但会就地修改参数 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，而不是进行复制。有关详细信息，请参见&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; 的&lt;/a&gt;文档。```</target>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。</target>
        </trans-unit>
        <trans-unit id="2f443b46f49f7a0ffb67743e11d80b3fef2023d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 与&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;相同，但是通过覆盖输入 &lt;code&gt;A&lt;/code&gt; 而不是创建副本来节省空间。有关详细信息，请参见&lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; 的&lt;/a&gt;文档。```</target>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; -从可用池中获取一个工作程序（用于远程功能执行）</target>
        </trans-unit>
        <trans-unit id="fbcd6c4d67df75ccaec5596e95f9f2b241b36c9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;a href=&quot;#Base.fetch-Tuple%7BTask%7D&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt; on an empty, closed channel.</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 并在一个空的，封闭的渠道上&lt;a href=&quot;#Base.fetch-Tuple%7BTask%7D&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 并且在关闭的通道上进行 &lt;code&gt;fetch&lt;/code&gt; （检索但不会删除该值）会成功返回所有现有值，直到将其清空。继续上面的示例：</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; ：如果不为空，则签出到该目录，而不是 &lt;code&gt;workdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; ：用于查找重命名的最大文件数。默认值为200。</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; 操作特定于当前任务的键值存储。</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; ：如果发生冲突，请以&amp;ldquo;其&amp;rdquo;一方的名称为准。</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; ：指定工作人员如何相互连接。在未连接的工作人员之间发送消息会导致错误。</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; ：所有进程都相互连接。默认值。</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; ：该 &lt;code&gt;launch&lt;/code&gt; 集群管理器的方法指定经由字段连接拓扑 &lt;code&gt;ident&lt;/code&gt; 和 &lt;code&gt;connect_idents&lt;/code&gt; 在 &lt;code&gt;WorkerConfig&lt;/code&gt; 。具有集群管理器标识 &lt;code&gt;ident&lt;/code&gt; 将连接到 &lt;code&gt;connect_idents&lt;/code&gt; 中指定的所有工作程序。</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; ：仅驱动程序进程（即 &lt;code&gt;pid&lt;/code&gt; 1）连接到worker。工人之间没有相互连接。</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; ：这个新分支应该跟踪的远程分支的名称（如果有）。如果为空（默认值），则不会跟踪任何远程分支。</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; 是用于创建提交的git树，显示了其祖先和与其他任何历史的关系。 &lt;code&gt;tree&lt;/code&gt; 必须属于 &lt;code&gt;repo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; （1）</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; 将结果转换为 &lt;code&gt;T&lt;/code&gt; 类型，如果该值无法表示，则抛出 &lt;code&gt;InexactError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; 返回类型相同的最接近的整数值 &lt;code&gt;x&lt;/code&gt; 的绝对值小于或等于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; ：将缓冲区大小截断为零长度。</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; 语句还允许将 &lt;code&gt;Exception&lt;/code&gt; 保存在变量中。如果 &lt;code&gt;x&lt;/code&gt; 是可索引的，下面的示例将计算 &lt;code&gt;x&lt;/code&gt; 的第二个元素的平方根，否则假设 &lt;code&gt;x&lt;/code&gt; 为实数并返回其平方根：</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; ：套接字上发送的数据包的生存时间（默认值： &lt;code&gt;nothing&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; （使用隧道）， &lt;code&gt;false&lt;/code&gt; （不使用隧道）或&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;（对管理器使用默认值）</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; 当需要ssh隧道从主进程连接到worker时，将使用tunnel， &lt;code&gt;bind_addr&lt;/code&gt; ， &lt;code&gt;sshflags&lt;/code&gt; 和 &lt;code&gt;max_parallel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; ,则将使用SSH隧道从主进程连接到worker。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; ：未检查的字符串</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; ：用于向上箭头的字符</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; ：提取后是否更新&lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt;。默认是执行更新，这是正常的git行为。</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; ：提取头的URL。</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; ：代理的URL。</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 为定制集群管理器提供了userdata来存储其自己的特定于工作人员的信息。</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; ：如果提供，则在输出中使用的用户名。</target>
        </trans-unit>
        <trans-unit id="7d104208af9cf68b573f7feb14b42536431e64fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; 将加载模块或软件包 &lt;code&gt;Foo&lt;/code&gt; ,并使其&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt;名称可直接使用。无论是否 &lt;code&gt;export&lt;/code&gt; ，也可以通过点语法使用名称（例如 &lt;code&gt;Foo.foo&lt;/code&gt; 来访问名称 &lt;code&gt;foo&lt;/code&gt; ）。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; 将加载模块或软件包 &lt;code&gt;Foo&lt;/code&gt; ,并使其&lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt;名称可直接使用。无论是否 &lt;code&gt;export&lt;/code&gt; ，也可以通过点语法使用名称（例如 &lt;code&gt;Foo.foo&lt;/code&gt; 来访问名称 &lt;code&gt;foo&lt;/code&gt; ）。有关详细信息，请参见&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;有关模块&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 现在通过 &lt;code&gt;put!&lt;/code&gt; as put &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;为通道的类型！叫做。</target>
        </trans-unit>
        <trans-unit id="49167f4be17e10d892b6cbc7f3c57602c873f166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; ：打印所有其他信息</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; ：正在使用的结构的版本，以防稍后更改。现在，始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; 是要搜索的特征值窗口的下限，而 &lt;code&gt;vu&lt;/code&gt; 是上限。</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 和 &lt;code&gt;[[noreturn]]&lt;/code&gt; 或 &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; ：一个&lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; ,&lt;/a&gt;指示何时将提交创作/提交到存储库中。</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; -引用创建远程引用的节点。请注意，这与实际引用的基础对象所在的节点不同。例如，从主进程调用 &lt;code&gt;RemoteChannel(2)&lt;/code&gt; 将导致 &lt;code&gt;where&lt;/code&gt; 值为2， &lt;code&gt;whence&lt;/code&gt; 值为1。</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; -指的是引用实际引用的基础对象/存储实际存在的节点。</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 循环重复计算条件表达式，并在表达式仍然为真时继续评估while循环的主体。如果在第一次到达while循环时条件表达式为false，则永远不会对主体进行求值。</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; （默认为 &lt;code&gt;false&lt;/code&gt; ），则在Windows 上执行 &lt;code&gt;Cmd&lt;/code&gt; 时不会显示新的控制台窗口。如果控制台已经打开或在非Windows系统上，则无效。</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; ：如果为 &lt;code&gt;true&lt;/code&gt; （默认为 &lt;code&gt;false&lt;/code&gt; ），则在Windows上， &lt;code&gt;Cmd&lt;/code&gt; 将向进程发送命令行字符串，且不带引号或转义参数，甚至不包含空格的参数。 （在Windows上，参数作为单个&amp;ldquo;命令行&amp;rdquo;字符串发送到程序，程序负责将其解析为参数。默认情况下，空参数以及带空格或制表符的参数在命令中用双引号引起来 &lt;code&gt;&quot;&lt;/code&gt; 行和 &lt;code&gt;\&lt;/code&gt; 或 &lt;code&gt;&quot;&lt;/code&gt; 之前加反斜杠 &lt;code&gt;windows_verbatim=true&lt;/code&gt; 对于启动以非标准方式解析其命令行的程序很有用。）在非Windows系统上无效。</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; 相反，write（io，c）可能会根据 &lt;code&gt;typeof(c)&lt;/code&gt; 发出编码，而 &lt;code&gt;read(io, typeof(c))&lt;/code&gt; 应该读取与 &lt;code&gt;write&lt;/code&gt; 相同的编码。新的 &lt;code&gt;AbstractChar&lt;/code&gt; 类型必须提供自己的 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;read&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; 将整数 &lt;code&gt;x&lt;/code&gt; 转换为与 &lt;code&gt;x&lt;/code&gt; 取模 &lt;code&gt;2^n&lt;/code&gt; 相等的整数类型 &lt;code&gt;T&lt;/code&gt; 的值，其中 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 中的位数。换句话说，二进制表示被截断以适合。</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; （其中 &lt;code&gt;&amp;sdot;&lt;/code&gt; 可以通过REPL中的制表符填充 &lt;code&gt;\cdot&lt;/code&gt; 键入）是 &lt;code&gt;dot(x, y)&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; 对于 &lt;code&gt;n&lt;/code&gt; 的整数值有效地计算x * 2 ^ n</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 也可以是数字数组，在这种情况下 &lt;code&gt;norm&lt;/code&gt; 默认为LinearAlgebra中的常规 &lt;code&gt;norm&lt;/code&gt; 函数，但可以通过传递 &lt;code&gt;norm::Function&lt;/code&gt; 关键字参数来进行更改。 （对于数字， &lt;code&gt;norm&lt;/code&gt; 与 &lt;code&gt;abs&lt;/code&gt; 相同。）当 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是数组时，如果 &lt;code&gt;norm(x-y)&lt;/code&gt; 不是有限的（即 &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; 或 &lt;code&gt;NaN&lt;/code&gt; ），则比较会退回到检查 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的所有元素是否为大致相等的分量。</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 启用&amp;ldquo;注释模式&amp;rdquo;：启用空格，除非使用 &lt;code&gt;\&lt;/code&gt; 进行转义，并且将 &lt;code&gt;#&lt;/code&gt; 视为开始注释。</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 是一个有限数</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 是无限的</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 不是数字</target>
        </trans-unit>
        <trans-unit id="bcdade3b450aacebe7ce055923202bb9a54acb72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 将调用排序给其子迭代器，这样，当当前迭代中的另一个迭代器完成时，有状态迭代器将不会前进。</target>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; 其中， &lt;code&gt;~&lt;/code&gt; 是系统上适当的用户目录；</target>
        </trans-unit>
        <trans-unit id="e0376dc9fd7a8a47da8cd6fcc825a0caa36450a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful idiom (see &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt;). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.</source>
          <target state="translated">&lt;em&gt;所有&lt;/em&gt;功能都是通用的，并使用多个分派。参数列表不必遵循相同的模板，这会导致强大的习惯用法（请参阅&lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;）。可选参数和关键字参数的处理方式不同。像在通用Lisp对象系统中一样，无法解决方法的歧义，因此需要为交点定义更具体的方法。</target>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;在&lt;/em&gt;加载任何代码&lt;em&gt;之前&lt;/em&gt;，请确保您正在运行Revise：说 &lt;code&gt;using Revise&lt;/code&gt; 或遵循其文档将其配置为自动运行。</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;创建&lt;/em&gt;日志事件是模块作者需要考虑的问题，模块作者需要确定在何处触发事件以及包括哪些信息。</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;不要复制这些示例！&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da7110d00e265f94760324ffd9a23c2410b52b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implicit use&lt;/em&gt; of &lt;code&gt;x&lt;/code&gt; covers any indirect use of resources logically owned by &lt;code&gt;x&lt;/code&gt; which the compiler cannot see. Some examples:</source>
          <target state="translated">&lt;em&gt;隐式使用&lt;/em&gt;的 &lt;code&gt;x&lt;/code&gt; 包括任何间接使用通过逻辑拥有的资源的 &lt;code&gt;x&lt;/code&gt; ，编译器无法看到。一些例子：</target>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;日志事件的&lt;em&gt;处理&lt;/em&gt;（即显示，过滤，聚合和记录）是应用程序作者所关心的，他需要将多个模块整合到一个协作的应用程序中。</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;分而治之的&lt;/em&gt;排序策略。</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;分而治之&lt;/em&gt;：类似于&lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; 的&lt;/a&gt;排序策略。</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;大型收藏品的&lt;em&gt;良好表现&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;iid&lt;/em&gt;，独立且相同地分布。</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;在内存&lt;em&gt;中就位&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;不在&lt;/em&gt;内存中。</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;不稳定&lt;/em&gt;：不保留比较相等的元素的顺序（例如，忽略大小写的字母中的&amp;ldquo; a&amp;rdquo;和&amp;ldquo; A&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;要排序的元素数量具有&lt;em&gt;二次性能&lt;/em&gt;：它非常适合于小型集合，但不应用于大型集合。</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;稳定&lt;/em&gt;：保留比较相等的元素的顺序（例如，忽略大小写的字母中的&amp;ldquo; a&amp;rdquo;和&amp;ldquo; A&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;软件包目录&lt;/strong&gt;是一个目录，其中包含一组软件包的源树作为子目录，并形成一个&lt;em&gt;隐式环境&lt;/em&gt;。如果 &lt;code&gt;X&lt;/code&gt; 是程序包目录的子目录，并且存在 &lt;code&gt;X/src/X.jl&lt;/code&gt; ，则程序包 &lt;code&gt;X&lt;/code&gt; 在程序包目录环境中可用，而 &lt;code&gt;X/src/X.jl&lt;/code&gt; 是加载程序的源文件。</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;项目环境&lt;/strong&gt;是一个包含项目文件和可选清单文件的目录，并构成一个&lt;em&gt;显式环境&lt;/em&gt;。项目文件确定项目的直接依赖项的名称和标识。清单文件（如果存在）会提供完整的依赖关系图，包括所有直接和间接依赖关系，每个依赖关系的确切版本以及足够的信息来查找和加载正确的版本。</target>
        </trans-unit>
        <trans-unit id="71e41c9cbdf8ac89f9996aae247a324d7f18b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environment&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;项目环境&lt;/strong&gt;是一个包含项目文件和可选清单文件的目录，并构成一个&lt;em&gt;显式环境&lt;/em&gt;。项目文件确定项目的直接依赖项的名称和标识。清单文件（如果存在）会提供完整的依赖关系图，包括所有直接和间接依赖关系，每个依赖关系的确切版本以及足够的信息来查找和加载正确的版本。</target>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;自动提升内置的算术类型和运算符。&lt;/strong&gt;在大多数语言中，内置数字类型在用作带有前缀语法的算术运算符（例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; )的操作数时，会自动提升为通用类型以产生预期的结果。 C，Java，Perl和Python（仅举几例）都正确地将总和 &lt;code&gt;1 + 1.5&lt;/code&gt; 计算为浮点值 &lt;code&gt;2.5&lt;/code&gt; ，即使 &lt;code&gt;+&lt;/code&gt; 的操作数之一是一个整数。这些系统很方便且设计得足够仔细，以至于程序员通常几乎看不见它们：几乎没有人在编写这样的表达式时有意识地想到这种提升，但是编译器和解释器必须在加法之前执行转换，因为整数和浮点数-点值不能按原样添加。因此，此类自动转换的复杂规则不可避免地是此类语言的规范和实现的一部分。</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;简要描述;简介&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;绕过默认机制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;代码包含：&lt;/strong&gt;例如 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 。包含可让您将单个程序拆分为多个源文件。表达式 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 使文件 &lt;code&gt;source.jl&lt;/code&gt; 的内容在发生 &lt;code&gt;include&lt;/code&gt; 调用的模块的全局范围内进行评估。如果多次调用 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; ， &lt;code&gt;source.jl&lt;/code&gt; 多次评估source.jl。包含路径 &lt;code&gt;source.jl&lt;/code&gt; 相对于 &lt;code&gt;include&lt;/code&gt; 调用发生的文件进行解释。这样可以很容易地重新定位源文件的子树。在REPL中，包含的路径是相对于当前工作目录进行解释的，&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;线性和笛卡尔指数之间的转换&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;光标移动&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;默认定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;其他一切&lt;/strong&gt;。任何其他参数。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="19683dd3d8903f638a6b291d6c9f28ca79e6c660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Existing local:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;already a local variable&lt;/em&gt;, then the existing local &lt;code&gt;x&lt;/code&gt; is assigned;</source>
          <target state="translated">&lt;strong&gt;现有的本地：&lt;/strong&gt;如果 &lt;code&gt;x&lt;/code&gt; 是&lt;em&gt;已经局部变量&lt;/em&gt;，则现有的本地 &lt;code&gt;x&lt;/code&gt; 被分配;</target>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;外部链接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;浮点类型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;函数参数&lt;/strong&gt;。首先放置函数参数允许使用&lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;块来传递多行匿名函数。</target>
        </trans-unit>
        <trans-unit id="7ec40a2f0a30b472e6c7208cfd9385764834e554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named &lt;code&gt;x&lt;/code&gt; is created in the scope of the assignment;</source>
          <target state="translated">&lt;strong&gt;硬范围：&lt;/strong&gt;如果 &lt;code&gt;x&lt;/code&gt; 是&lt;em&gt;不是已经是一个局部变量&lt;/em&gt;和赋值内部发生任何硬范围构造（即一让块，功能或宏体，理解或发电机内）的，一个新的地方命名为 &lt;code&gt;x&lt;/code&gt; 中的范围内产生任务;</target>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;高维实例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更高尺寸&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;I / O流&lt;/strong&gt;。首先指定 &lt;code&gt;IO&lt;/code&gt; 对象可以将函数传递给&lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; 之&lt;/a&gt;类的函数，例如 &lt;code&gt;sprint(show, x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;重要的可选方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;输入被突变&lt;/strong&gt;。例如，在&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;x&lt;/code&gt; 是要突变的对象，它出现在要插入 &lt;code&gt;x&lt;/code&gt; 的值之前。</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;输入未发生变异&lt;/strong&gt;。在 &lt;code&gt;fill!(x, v)&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;被突变，并谈到后， &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;整数类型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;键&lt;/strong&gt;。对于关联集合，这是键值对的键。对于其他索引集合，这就是索引。</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;关键字参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;关键字参数&lt;/strong&gt;。在Julia中，关键字参数必须在函数定义中排在最后。为了完整起见，此处列出了它们。</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;泡沫。冲洗。重复。&lt;/strong&gt;在 &lt;code&gt;julia&lt;/code&gt; 命令提示符下探索想法。将好的想法保存在 &lt;code&gt;tst.jl&lt;/code&gt; 中。要在 &lt;code&gt;tst.jl&lt;/code&gt; 后执行tst.jl，只需再次 &lt;code&gt;include&lt;/code&gt; 它即可。</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;没有自动升级。&lt;/strong&gt;该阵营包括Ada和ML &amp;ndash;非常&amp;ldquo;严格&amp;rdquo;的静态类型语言。在这些语言中，每次转换都必须由程序员明确指定。因此，示例表达式 &lt;code&gt;1 + 1.5&lt;/code&gt; 在Ada和ML中都是编译错误。取而代之的是，必须写 &lt;code&gt;real(1) + 1.5&lt;/code&gt; ，在执行加法之前将整数 &lt;code&gt;1&lt;/code&gt; 显式转换为浮点值。到处都是显式转换非常不方便，但是，即使Ada也具有一定程度的自动转换：整数文字会自动提升为所需的整数类型，而浮点文字也同样会提升为适当的浮点类型。</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非传统指标&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由于 &lt;code&gt;libgit2&lt;/code&gt; 身份验证过程的特定性，当身份验证失败时，将再次调用此函数，而不会指示身份验证是否成功。为了避免无限循环重复使用相同的错误凭据，我们将使用有效负载来跟踪状态。</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：本节介绍在类似Unix的操作系统上将Julia代码嵌入C中的方法。有关在Windows上执行此操作的信息，请参见此部分。</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;可选方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;包装：&lt;/strong&gt;如 &lt;code&gt;import X&lt;/code&gt; 或 &lt;code&gt;using X&lt;/code&gt; 。导入机制使您可以加载程序包（即包装在模块中的Julia代码的独立，可重用的集合），并通过导入模块内部的名称 &lt;code&gt;X&lt;/code&gt; 使生成的模块可用。如果在同一个Julia会话中多次导入相同的 &lt;code&gt;X&lt;/code&gt; 包，则仅在首次加载时加载-在随后的导入中，导入模块将获得对相同模块的引用。但是请注意， &lt;code&gt;import X&lt;/code&gt; 可以在不同的上下文中加载不同的程序包： &lt;code&gt;X&lt;/code&gt; 可以在主项目中引用一个名为 &lt;code&gt;X&lt;/code&gt; 的程序包，但有可能引用也称为 &lt;code&gt;X&lt;/code&gt; 的不同程序包在每个依赖项中。在下面的更多内容。</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;程序控制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;将正在开发的代码放在一个临时模块中。&lt;/strong&gt;创建一个文件，例如 &lt;code&gt;Tmp.jl&lt;/code&gt; ，并将其包含在其中</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;将您的测试代码放在另一个文件中。&lt;/strong&gt;创建另一个文件，例如 &lt;code&gt;tst.jl&lt;/code&gt; ，看起来像</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;也可以看看&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36121b3eefd78b60d0003f60318af0689a90639e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Soft scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and all of the scope constructs containing the assignment are soft scopes (loops, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; blocks, or &lt;code&gt;struct&lt;/code&gt; blocks), the behavior depends on whether the global variable &lt;code&gt;x&lt;/code&gt; is defined:</source>
          <target state="translated">&lt;strong&gt;软范围：&lt;/strong&gt;如果 &lt;code&gt;x&lt;/code&gt; 是&lt;em&gt;不是已经是一个局部变量&lt;/em&gt;，并包含所有分配范围构建的软范围（循环， &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 块或 &lt;code&gt;struct&lt;/code&gt; 块），则该行为取决于全局变量是否 &lt;code&gt;x&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="b3021827c46a7ed515f5246c6017d78d244ed6bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Dependent Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;系统相关类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="608f32cb9eef948fcb1ef6e535b6635c88420101" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;系统独立类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;与系统无关：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;项目目录&lt;strong&gt;的依赖关系图&lt;/strong&gt;由每个包的子目录中项目文件的存在和内容确定。规则是：</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;项目环境&lt;strong&gt;的依赖关系图&lt;/strong&gt;由清单文件的内容（如果存在）确定。如果没有清单文件，则图为空。清单文件包含项目的每个直接或间接依赖关系的节。对于每个依赖项，文件都会列出程序包的UUID和源树哈希或源代码的显式路径。考虑下面的 &lt;code&gt;App&lt;/code&gt; 清单文件示例：</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这里的关键点是Julia代码在内部表示为可从语言本身访问的数据结构。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;包目录中&lt;strong&gt;的路径映射&lt;/strong&gt;很简单：它将子目录名称映射到其相应的入口点路径。换句话说，如果我们的示例项目目录的路径是 &lt;code&gt;/home/me/animals&lt;/code&gt; ,则 &lt;code&gt;paths&lt;/code&gt; 映射可以用此字典表示：</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;从清单文件中提取项目环境&lt;strong&gt;的路径图&lt;/strong&gt;。名为 &lt;code&gt;X&lt;/code&gt; 的包 &lt;code&gt;uuid&lt;/code&gt; 的路径由以下规则确定（按顺序）：</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;通过检查软件包目录的内容来确定生成&lt;strong&gt;根映射&lt;/strong&gt;，以生成所有存在的软件包的列表。此外，UUID将分配给每个条目，如下所示：对于在文件夹 &lt;code&gt;X&lt;/code&gt; 中找到的给定包...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;环境&lt;strong&gt;的根映射&lt;/strong&gt;取决于项目文件的内容，特别是其顶层 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;uuid&lt;/code&gt; 条目以及其 &lt;code&gt;[deps]&lt;/code&gt; 节（全部可选）。如前所述，考虑假设应用程序 &lt;code&gt;App&lt;/code&gt; 的以下示例项目文件：</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;输入&lt;/strong&gt;。传递类型通常意味着输出将具有给定的类型。在&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt;，类型在要分析的字符串之前。有很多这样的示例，其中类型首先出现，但是要注意，在&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;IO&lt;/code&gt; 参数出现在类型之前，这与此处概述的顺序一致。</target>
        </trans-unit>
        <trans-unit id="b586fc911b064b4cf7b9cf3a61a4f379ea0edfb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use in broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在广播中使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1eab55c50210340cd0c0df6a7519baa6abc6fcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;价值&lt;/strong&gt;。对于关联集合，这是键值对的值。在诸如&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt;，该值为 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;价值&lt;/strong&gt;。对于关联集合，这是键/值对的值。在诸如 &lt;code&gt;fill!(x, v)&lt;/code&gt; ，该值为 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Varargs&lt;/strong&gt;。这指的是可以在函数调用结束时无限期列出的参数。例如，在 &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; ，尺寸可以指定为&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;，例如 &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt;，例如 &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这将生成什么代码？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;接下来发生什么？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;图形：&lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; UUID⟶ &lt;code&gt;name::Symbol&lt;/code&gt; Symbol⟶uuid &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;路径：&lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; Symbol⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;根目录：&lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; Symbol⟶uuid &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;我&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">@threadcall（实验性）</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">&amp;ldquo;分散的&amp;rdquo;数组存储在内存中，其元素以规则的偏移量进行布局，以便具有受支持的 &lt;code&gt;isbits&lt;/code&gt; 元素类型的实例可以传递给需要此内存布局的外部C和Fortran函数。交错数组必须定义strides &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt;方法，该方法为每个维度返回一个元组&amp;ldquo; strides&amp;rdquo;；提供的&lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt;方法访问该元组中的第 &lt;code&gt;k&lt;/code&gt; 个元素。增大的尺寸的索引 &lt;code&gt;k&lt;/code&gt; 由 &lt;code&gt;1&lt;/code&gt; 应该增加索引 &lt;code&gt;i&lt;/code&gt; 的 &lt;code&gt;getindex(A,i)&lt;/code&gt; 通过&lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt;。如果指针转换方法为&lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;如果提供了&amp;ldquo;内存&amp;rdquo;，则内存布局必须以相同的方式对应于这些跨步。 &lt;code&gt;DenseArray&lt;/code&gt; 是跨入阵列，其中所述元件被连续地布置的一个非常具体的示例，因此它提供了它的亚型的合适定义 &lt;code&gt;strides&lt;/code&gt; 。在&lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;跨距数组&lt;/a&gt;的接口指南中可以找到更具体的例子。对于许多被视为跨步数组的内置数组类型，&lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;是方便的别名，允许它们分派以选择仅使用指针和跨距调用高度优化和优化的BLAS和LAPACK函数的专用实现。</target>
        </trans-unit>
        <trans-unit id="b06ef311fe65245308768dcdeb585be5facb485c" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;view&amp;rdquo; is a data structure that acts like an array (it is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;), but the underlying data is actually part of another array.</source>
          <target state="translated">&amp;ldquo;视图&amp;rdquo;是一种数据结构，其作用类似于一个数组（它是 &lt;code&gt;AbstractArray&lt;/code&gt; 的子类型），但是基础数据实际上是另一个数组的一部分。</target>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">A(全部)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; &lt;/a&gt;将被剥皮到一个&lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; 上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">一个&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt;运营商代表标量时间的身份操作， &lt;code&gt;&amp;lambda;*I&lt;/code&gt; 。身份运算符 &lt;code&gt;I&lt;/code&gt; 定义为常量，并且是 &lt;code&gt;UniformScaling&lt;/code&gt; 的实例。这些运算符的大小是通用的，并且与二进制运算符&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 中的另一个矩阵匹配。对于 &lt;code&gt;A+I&lt;/code&gt; 和 &lt;code&gt;A-I&lt;/code&gt; 这意味着 &lt;code&gt;A&lt;/code&gt; 必须为正方形。与身份运算符 &lt;code&gt;I&lt;/code&gt; 的乘积是无操作的（检查比例因子是否为1除外），因此几乎没有开销。</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">一个&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;，它设置 &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; 的值（默认值： &lt;code&gt;60.0&lt;/code&gt; ）。此函数提供工作进程在死亡之前等待主进程建立连接的秒数。</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是在一个开放的状态开始。这意味着可以通过 &lt;code&gt;take!&lt;/code&gt; 进行自由读取和写入！并 &lt;code&gt;put!&lt;/code&gt; 电话。&lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;关闭一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;。在封闭的&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;put!&lt;/code&gt; 将失败。例如：</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是当地的一个过程。工作人员2无法直接引用工作人员3上的&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;，反之亦然。一个&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;，但是，可以把走跨越工人值。</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;可以被认为是一个&lt;em&gt;句柄&lt;/em&gt;到一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">一个长度为 &lt;code&gt;n&lt;/code&gt; 的&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;迭代器，其元素以间隔 &lt;code&gt;factor&lt;/code&gt; *（1&amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ）的速率呈指数增加。第一个元素是 &lt;code&gt;first_delay&lt;/code&gt; ，所有元素都钳位到 &lt;code&gt;max_delay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eff87e10245c4721bd18e0368a4c02ba6a49f3c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair (most common),</source>
          <target state="translated">一对 &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; （最常见），</target>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">甲 &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; 一对，它们必须被写为一个常量，</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">甲 &lt;code&gt;(name, library)&lt;/code&gt; 功能规范必须是一个常量表达式。但是，可以通过在&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 上&lt;/a&gt;进行分段来按以下方式将计算值用作函数名：</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">甲 &lt;code&gt;:&lt;/code&gt; 字符上的列标题分离器的任一端（包含行 &lt;code&gt;-&lt;/code&gt; 字符）是否指定该行是左对齐，右对齐，或（当 &lt;code&gt;:&lt;/code&gt; 两端出现）的中心对齐。不提供 &lt;code&gt;:&lt;/code&gt; 字符将默认为使列右对齐。</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">甲 &lt;code&gt;BufferStream&lt;/code&gt; 是一个内存&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;其行为类似于 &lt;code&gt;IO&lt;/code&gt; -它是一种可以异步处理的流。</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;有时会产生一个 &lt;code&gt;CartesianIndex&lt;/code&gt; ，并且总是在显式&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;迭代时产生。</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">甲 &lt;code&gt;Channel&lt;/code&gt; 可以用作在一个迭代对象 &lt;code&gt;for&lt;/code&gt; 循环，在这种情况下，循环只要运行 &lt;code&gt;Channel&lt;/code&gt; 具有数据或打开。循环变量采用所有添加到 &lt;code&gt;Channel&lt;/code&gt; 的值。 &lt;code&gt;Channel&lt;/code&gt; 关闭并清空后， &lt;code&gt;for&lt;/code&gt; 循环终止。</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">甲 &lt;code&gt;Char&lt;/code&gt; 值代表单个字符：它仅仅是一个32位的原始类型用特殊文字表示和适当的算术行为，它可以被转换成表示一个数值&lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode代码点&lt;/a&gt;。 （Julia包可以定义 &lt;code&gt;AbstractChar&lt;/code&gt; 的其他子类型，例如，以优化其他&lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;文本编码的&lt;/a&gt;操作。）这是输入和显示 &lt;code&gt;Char&lt;/code&gt; 值的方式：</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">甲 &lt;code&gt;CompoundPeriod&lt;/code&gt; 用于表示不属于较小周期的固定倍数的时间段是有用的。例如，&amp;ldquo;一年零一日&amp;rdquo;不是固定的天数，而是可以使用 &lt;code&gt;CompoundPeriod&lt;/code&gt; 表示。实际上，通过添加不同的期间类型会自动生成 &lt;code&gt;CompoundPeriod&lt;/code&gt; ，例如 &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; 会产生 &lt;code&gt;CompoundPeriod&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">数据 &lt;code&gt;DataType&lt;/code&gt; 可以是抽象的或具体的。如果是具体的，则具有指定的大小，存储布局和（可选）字段名称。因此，基本类型是具有非零大小但没有字段名称的 &lt;code&gt;DataType&lt;/code&gt; 。复合类型是具有字段名称或为空（零大小）的 &lt;code&gt;DataType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8254718d7cf35196b57a0c256656d29ca6967f68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Future&lt;/code&gt; is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see &lt;code&gt;RemoteChannel&lt;/code&gt;. See &lt;code&gt;remoteref_id&lt;/code&gt; for identifying an &lt;code&gt;AbstractRemoteRef&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;Future&lt;/code&gt; 是未知的终止状态和时间的单一计算的占位符。有关多种可能的计算，请参见 &lt;code&gt;RemoteChannel&lt;/code&gt; 。有关标识 &lt;code&gt;AbstractRemoteRef&lt;/code&gt; 的信息,请参见 &lt;code&gt;remoteref_id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;GitCommit&lt;/code&gt; 将被剥皮到一个 &lt;code&gt;GitTree&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">一个 &lt;code&gt;GitRevWalker&lt;/code&gt; &lt;em&gt;走&lt;/em&gt;通过&lt;em&gt;修改&lt;/em&gt;一个Git仓库（即提交） &lt;code&gt;repo&lt;/code&gt; 。它是存储库中提交的集合，并支持迭代以及&lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;调用（例如， &lt;code&gt;count&lt;/code&gt; 可用于确定某个作者在存储库中提交的百分比是多少）。</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">一个 &lt;code&gt;GitTag&lt;/code&gt; 将被剥离到它所引用的对象上。</target>
        </trans-unit>
        <trans-unit id="9ecaf0ba8d28df22c60ef1b5589bb9e3a4cbe6da" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Hessenberg&lt;/code&gt; object represents the Hessenberg factorization &lt;code&gt;QHQ'&lt;/code&gt; of a square matrix, or a shift &lt;code&gt;Q(H+&amp;mu;I)Q'&lt;/code&gt; thereof, which is produced by the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">甲 &lt;code&gt;Hessenberg&lt;/code&gt; 对象表示Hessenberg因式分解 &lt;code&gt;QHQ'&lt;/code&gt; 方阵，或者移位的 &lt;code&gt;Q(H+&amp;mu;I)Q'&lt;/code&gt; 体，它是由生产&lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">甲 &lt;code&gt;MIME&lt;/code&gt; 对象可以作为第二个参数被传递&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;到请求输出该格式。</target>
        </trans-unit>
        <trans-unit id="bd67479c52c92dddc64ec714d9c7069f1b10867a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">甲 &lt;code&gt;MIME&lt;/code&gt; 对象可以作为第二个参数被传递&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;到请求输出该格式。</target>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;MersenneTwister&lt;/code&gt; 或 &lt;code&gt;RandomDevice&lt;/code&gt; RNG可以生成以下类型的均匀的随机数：&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; 类型&lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; 的&lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; 类型&lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 有&lt;/a&gt;（或复数这些类型）。随机浮点数在$ [0，1）$中统一生成。作为 &lt;code&gt;BigInt&lt;/code&gt; 代表无界整数，必须指定间隔（例如 &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="93e7981a3162e9783d86dcf2247127a2e48a689e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">甲 &lt;code&gt;Module&lt;/code&gt; 是一个单独的全局变量的工作区。有关详细信息，请参见&lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt;和有关模块的&lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;手册部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">甲 &lt;code&gt;Module&lt;/code&gt; 是一个单独的全局变量的工作区。有关详细信息，请参见&lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt;和有关模块的&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;手册部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7ec3daecca2c04b2bae1c27f0094a5422da6aa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;N&lt;/code&gt;-dimensional custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexCartesian&lt;/code&gt; needs to implement indexing (and indexed assignment) with exactly &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices; all other indexing expressions &amp;mdash; including linear indexing &amp;mdash; will be recomputed to the equivalent Cartesian location. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with cartesian indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt;, this would be recomputed to the equivalent Cartesian index and call &lt;code&gt;A[1, 3]&lt;/code&gt; since &lt;code&gt;5 = 2*1 + 3&lt;/code&gt;.</source>
          <target state="translated">一个将其 &lt;code&gt;IndexStyle&lt;/code&gt; 报告为 &lt;code&gt;IndexCartesian&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 维自定义数组，需要使用恰好 &lt;code&gt;N&lt;/code&gt; 个 &lt;code&gt;Int&lt;/code&gt; 索引来实现索引（和索引分配）。所有其他索引表达式（包括线性索引）将重新计算为等效的笛卡尔位置。例如，如果 &lt;code&gt;A&lt;/code&gt; 是具有笛卡尔索引的 &lt;code&gt;2&amp;times;3&lt;/code&gt; 自定义矩阵，并且我们引用了 &lt;code&gt;A[5]&lt;/code&gt; ，则由于 &lt;code&gt;5 = 2*1 + 3&lt;/code&gt; ，它将被重新计算为等效的笛卡尔索引并调用 &lt;code&gt;A[1, 3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">甲 &lt;code&gt;NamedTuple&lt;/code&gt; 类型可以用于作为构造，接受一个元组参数。构造的 &lt;code&gt;NamedTuple&lt;/code&gt; 类型可以是指定了两个参数的具体类型，也可以是仅指定字段名称的类型：</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">一个 &lt;code&gt;Polar&lt;/code&gt; 那么对象将自动显示在环境，支持HTML显示使用HTML，但你可以叫 &lt;code&gt;show&lt;/code&gt; ，如果你想手动将HTML输出：</target>
        </trans-unit>
        <trans-unit id="3992f5106e091bf1a1db28341609bec19be4cafd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;VersionNumber&lt;/code&gt; 对象，它描述了正在使用的Julia版本。有关详细信息，请参见&lt;a href=&quot;../../manual/strings/index#man-version-number-literals&quot;&gt;版本号文字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;VersionNumber&lt;/code&gt; 对象，它描述了正在使用的Julia版本。有关详细信息，请参见&lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;版本号文字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b5d6ebeedad778839a920e823243163f3ccd68a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;do&lt;/code&gt; 块，像任何其他内部函数，从其封闭范围可以&amp;ldquo;捕获&amp;rdquo;的变量。例如，上述 &lt;code&gt;open...do&lt;/code&gt; 示例中的变量 &lt;code&gt;data&lt;/code&gt; 是从外部范围捕获的。如&lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;性能提示中&lt;/a&gt;所述，捕获的变量可能会带来性能挑战。</target>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;do&lt;/code&gt; 块，像任何其他内部函数，从其封闭范围可以&amp;ldquo;捕获&amp;rdquo;的变量。例如，上述 &lt;code&gt;open...do&lt;/code&gt; 示例中的变量 &lt;code&gt;data&lt;/code&gt; 是从外部范围捕获的。如&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示中&lt;/a&gt;所述，捕获的变量可能会带来性能挑战。</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">一个 &lt;code&gt;for&lt;/code&gt; 循环或理解迭代变量始终是一个新的变量：</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">事件的 &lt;code&gt;group&lt;/code&gt; ，默认情况下设置为文件的基本名称，不带扩展名。这可用于将消息分组为比日志级别更精细的类别（例如，所有弃用警告均具有group &lt;code&gt;:depwarn&lt;/code&gt; ），或将模块分组为模块内或模块内的逻辑分组。</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">一个 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 语句允许拦截引发的错误（例外）&lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;，这样的程序可以继续执行。例如，以下代码尝试写入文件，但是警告用户并继续执行操作，而不是在无法写入文件时终止执行：</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">甲&lt;em&gt;包&lt;/em&gt;是一个源树与可由其他朱莉娅项目中重复使用的标准布局提供的功能性。包是通过 &lt;code&gt;import X&lt;/code&gt; 或 &lt;code&gt;using X&lt;/code&gt; 语句加载的。这些语句还使名为 &lt;code&gt;X&lt;/code&gt; 的模块（由加载程序包代码产生）在导入语句所在的模块中可用。的含义 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;import X&lt;/code&gt; 是依赖于上下文的：其中 &lt;code&gt;X&lt;/code&gt; 包被加载取决于什么代码中出现的语句。因此，处理的。 &lt;code&gt;import X&lt;/code&gt; 在两个阶段发生：首先，它确定&lt;strong&gt;什么&lt;/strong&gt;包被定义为 &lt;code&gt;X&lt;/code&gt; 在这种情况下 其次，它确定&lt;strong&gt;在哪里&lt;/strong&gt;找到特定的 &lt;code&gt;X&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">声明为返回 &lt;code&gt;Cvoid&lt;/code&gt; 的 AC函数将在Julia中 &lt;code&gt;nothing&lt;/code&gt; 返回任何值。</target>
        </trans-unit>
        <trans-unit id="390614814aa5adb2a2fccf6c0c90c7149f4d96ba" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">由本地字符类型&lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt;组成的C样式字符串。 &lt;code&gt;Cstring&lt;/code&gt; 是NUL终止的。有关由本机宽字符类型组成的C样式字符串，请参见&lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt;。有关与C进行字符串互操作性的更多信息，请参见&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;手册&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">由本地字符类型&lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt;组成的C样式字符串。 &lt;code&gt;Cstring&lt;/code&gt; 是NUL终止的。有关由本机宽字符类型组成的C样式字符串，请参见&lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt;。有关与C进行字符串互操作的更多信息，请参见&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;手册&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18521ba47ad36cc4f8c112bae48ca35ecb2ee122" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">由本地宽字符类型&lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt;组成的C样式字符串。 &lt;code&gt;Cwstring&lt;/code&gt; 是NUL终止的。有关由本机字符类型组成的C样式字符串，请参见&lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt;。有关与C进行字符串互操作性的更多信息，请参见&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;手册&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">由本地宽字符类型&lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt;组成的C样式字符串。 &lt;code&gt;Cwstring&lt;/code&gt; 是NUL终止的。有关由本机字符类型组成的C样式字符串，请参见&lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt;。有关与C进行字符串互操作的更多信息，请参见&lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;手册&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c197fd05f688124d54264f0b58fc3c22d93ec77c" translate="yes" xml:space="preserve">
          <source>A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexCartesian&lt;/code&gt; will return a range of &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">笛卡尔索引风格使用多个整数索引来描述多维数组中的位置，每个维度仅具有一个索引。这意味着从&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;数组中请求每个 &lt;code&gt;IndexCartesian&lt;/code&gt; 将返回&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;范围。</target>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">Givens旋转线性运算符。字段 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;s&lt;/code&gt; 分别代表旋转角的余弦和正弦。的 &lt;code&gt;Givens&lt;/code&gt; 型支持左乘法 &lt;code&gt;G*A&lt;/code&gt; 和共轭转置权乘法 &lt;code&gt;A*G'&lt;/code&gt; 。类型不具有 &lt;code&gt;size&lt;/code&gt; ，因此可以用任意大小的矩阵乘以只要 &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; 为 &lt;code&gt;G*A&lt;/code&gt; 或 &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; 为 &lt;code&gt;A*G'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">茱莉亚功能</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">一个Julia集群具有以下特征:</target>
        </trans-unit>
        <trans-unit id="b46f55d05b4cea9eeb2d26c893736aefe4db768d" translate="yes" xml:space="preserve">
          <source>A Julia function</source>
          <target state="translated">一个Julia函数</target>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">一个Julia脚本可以包含任何数量的函数,当文件被加载时,所有的定义都将在外部可见。函数定义可以从当前工作目录之外的文件中加载。</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">LibGit2凭证回调函数，该函数通过连接协议提供不同的凭证获取功能。该 &lt;code&gt;payload_ptr&lt;/code&gt; 需要包含一个 &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; 对象，将跟踪状态和设置。</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">字符串数组的LibGit2表示形式。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">以紧凑块格式存储的QR矩阵分解，通常从&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;获得。如果$ A $是一个 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 矩阵，则</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">以打包格式存储的QR矩阵分解，通常从&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;获得。如果$ A $是一个 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 矩阵，则</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">列旋转的QR矩阵分解以压缩格式（通常从&lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;获得）。如果$ A $是一个 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 矩阵，则</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">一个基本的编辑/REPL工作流程</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">包装OS文件描述符的缓冲IO流。通常用于表示&lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;返回的文件。</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">调用&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; 会&lt;/a&gt;返回 &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; 的向量，然后可以将其传递到&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 中&lt;/a&gt;进行翻译：</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">笛卡尔索引风格使用多个整数/索引来描述数组中的位置。例如，如果 &lt;code&gt;A&lt;/code&gt; 是具有笛卡尔索引的 &lt;code&gt;(2, 3, 4)&lt;/code&gt; 自定义矩阵类型，我们可以引用 &lt;code&gt;A[2, 1, 3]&lt;/code&gt; 2、1、3 ]，Julia会自动将其转换为基础内存中的正确位置。另请参见&lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">一个通道可以可视化为一个管道,即它有一个写端和一个读端。</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">一个经典的例子是标准的C库 &lt;code&gt;qsort&lt;/code&gt; 函数，声明为：</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">使用 &lt;code&gt;--machine-file&lt;/code&gt; 选项跨越机器的集群。这将使用无密码的 &lt;code&gt;ssh&lt;/code&gt; 登录名在指定的计算机上启动Julia工作进程（从与当前主机相同的路径）。</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">通过外壳运行外部程序时常见的陷阱是，如果文件名包含外壳专用的字符，则它们可能会导致不良行为。例如，假设我们要对 &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; 文件的内容进行排序，而不是 &lt;code&gt;/etc/passwd&lt;/code&gt; 。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">变量的常见用法是为特定的不变值命名。此类变量仅分配一次。可以使用&lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt;关键字将此意图传达给编译器：</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">全面概述所有可记录的Julia语法。</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">要实现 &lt;code&gt;put!&lt;/code&gt; ，需要 &lt;code&gt;AbstractChannel&lt;/code&gt; 的具体实现（例如 &lt;code&gt;Channel&lt;/code&gt; ）。， &lt;code&gt;take!&lt;/code&gt; ， &lt;code&gt;fetch&lt;/code&gt; ， &lt;code&gt;isready&lt;/code&gt; 并&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;引用的远程对象存储在 &lt;code&gt;Channel{Any}(1)&lt;/code&gt; ，即大小为1 的 &lt;code&gt;Channel&lt;/code&gt; ，它可以容纳 &lt;code&gt;Any&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">构造器与Julia中的其他任何函数一样，其总体行为由其方法的组合行为定义。因此，您可以通过简单地定义新方法来向构造函数添加功能。例如，假设您要为 &lt;code&gt;Foo&lt;/code&gt; 对象添加一个构造函数方法，该方法仅采用一个参数，并将 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 字段都使用给定值。这很简单：</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">用于编写&lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt;类型的便利宏，通常在添加&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;方法时使用。例如，语法 &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; 可用于定义如何编写 &lt;code&gt;MyType&lt;/code&gt; 的HTML表示形式。</target>
        </trans-unit>
        <trans-unit id="70c4d119efcef0d9d58b6c1b731caa5e0cea492c" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">用于编写&lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt;类型的便利宏，通常在添加&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;方法时使用。例如，语法 &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; 可用于定义如何编写 &lt;code&gt;MyType&lt;/code&gt; 的HTML表示形式。</target>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">定义接受 &lt;code&gt;Point{T}&lt;/code&gt; 类型的所有参数（其中 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;的子类型）的方法的正确方法是：</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">在主要Julia网站的&lt;a href=&quot;https://julialang.org/learning/&quot;&gt;学习&lt;/a&gt;页面上可以找到精选的有用学习资源列表，以帮助新用户入门。</target>
        </trans-unit>
        <trans-unit id="195192cf6a65111d3220eb69daad42095c4bb54b" translate="yes" xml:space="preserve">
          <source>A custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexLinear&lt;/code&gt; only needs to implement indexing (and indexed assignment) with a single &lt;code&gt;Int&lt;/code&gt; index; all other indexing expressions &amp;mdash; including multidimensional accesses &amp;mdash; will be recomputed to the linear index. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with linear indexing, and we referenced &lt;code&gt;A[1, 3]&lt;/code&gt;, this would be recomputed to the equivalent linear index and call &lt;code&gt;A[5]&lt;/code&gt; since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;.</source>
          <target state="translated">一个将其 &lt;code&gt;IndexStyle&lt;/code&gt; 报告为 &lt;code&gt;IndexLinear&lt;/code&gt; 的自定义数组仅需要使用单个 &lt;code&gt;Int&lt;/code&gt; 索引来实现索引（和索引分配）。所有其他索引表达式（包括多维访问）将重新计算为线性索引。例如，如果 &lt;code&gt;A&lt;/code&gt; 是具有线性索引的 &lt;code&gt;2&amp;times;3&lt;/code&gt; 自定义矩阵，并且我们引用了 &lt;code&gt;A[1, 3]&lt;/code&gt; ，则它将被重新计算为等效线性索引，并由于 &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; 故将其称为 &lt;code&gt;A[5]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eda7036e705b5b4e6080ae4d063390e3d333bd8" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. For that standard types (&lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;... etc_, if no title text is specified after the admonition type, then the type title used will be the type of the block. E.g. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">可以在警告类型之后以字符串（双引号）的形式提供该框的自定义标题。对于该标准类型（ &lt;code&gt;danger&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ...等，如果在警告类型之后未指定标题文本，则使用的类型标题将是块的类型。例如，在 &lt;code&gt;note&lt;/code&gt; 警告的情况下为 &lt;code&gt;&quot;Note&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">可以在警告类型之后以字符串（双引号）的形式提供该框的自定义标题。如果在警告类型之后未指定标题文本，则使用的标题将是块的类型，即在 &lt;code&gt;note&lt;/code&gt; 警告的情况下为 &lt;code&gt;&quot;Note&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">用于从libgit2导出数据的数据缓冲区。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">一个被废弃的函数在内部执行查找,以便只打印一次相关的警告。这种额外的查找可能会导致显著的速度减慢,所以所有使用废弃函数的情况都应该按照警告的建议进行修改。</target>
        </trans-unit>
        <trans-unit id="30d96d8ddfc84bb803bea097ec17d062d6889473" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">一个目录路径，指示哪个项目应该是初始活动项目。设置此环境变量与指定 &lt;code&gt;--project&lt;/code&gt; 启动选项具有相同的效果，但是 &lt;code&gt;--project&lt;/code&gt; 具有更高的优先级。如果变量设置为 &lt;code&gt;@.&lt;/code&gt; 然后Julia尝试从当前目录及 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 目录中找到一个包含 &lt;code&gt;Project.toml&lt;/code&gt; 或JuliaProject.toml文件的项目目录。另请参阅&lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;&amp;ldquo;代码加载&lt;/a&gt;&amp;rdquo;一章。</target>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">一个目录路径，指示哪个项目应该是初始活动项目。设置此环境变量与指定 &lt;code&gt;--project&lt;/code&gt; 启动选项具有相同的效果，但是 &lt;code&gt;--project&lt;/code&gt; 具有更高的优先级。如果变量设置为 &lt;code&gt;@.&lt;/code&gt; 然后Julia尝试从当前目录及 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 目录中找到一个包含 &lt;code&gt;Project.toml&lt;/code&gt; 或JuliaProject.toml文件的项目目录。另请参阅&lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;&amp;ldquo;代码加载&lt;/a&gt; &amp;rdquo;一章。</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">一个分布式内存,并行for循环的形式。</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">可以使用标题将文档分成不同的部分。页眉使用以下语法。</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">&lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; 快速，不公平的调度版本；yield（）在调用调度程序之前立即屈服到 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">需要注意的几个一般规则。</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">还有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">一些流行的语言有单子类型,包括Haskell、Scala和Ruby。在一般的用法中,术语 &quot;单子类型 &quot;指的是一个类型,其唯一的实例是一个单一的值。这个意思适用于Julia的单子类型,但要注意的是,只有类型对象才有单子类型。</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">有几个特殊的表达式对应于对名称不明显的函数的调用。这些函数是:</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">也可以在启动时使用 &lt;code&gt;-L&lt;/code&gt; 标志将文件预加载到多个进程中，并且可以使用驱动程序脚本来驱动计算：</target>
        </trans-unit>
        <trans-unit id="f9a01e3bc84b099bc13fd4194e7a227e1495a2f3" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">制表符补全的完整列表可以在手册的&amp;ldquo; &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input&quot;&gt;Unicode输入&amp;rdquo;&lt;/a&gt;部分中找到。</target>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">制表符补全的完整列表可以在手册的&amp;ldquo; &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode输入&amp;rdquo;&lt;/a&gt;部分中找到。</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; 中&lt;/a&gt;提供了全套的解析和格式化测试以及示例。</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">一个函数&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; ,&lt;/a&gt;用于请求Julia对象 &lt;code&gt;x&lt;/code&gt; 的最丰富的多媒体显示（带有纯文本后备）。</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">使用传统的括号语法调用一个函数。</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">函数名称可以代替元组单独使用（只是 &lt;code&gt;:function&lt;/code&gt; 或 &lt;code&gt;&quot;function&quot;&lt;/code&gt; ）。在这种情况下，名称将在当前进程中解析。该格式可用于调用C库函数，Julia运行时中的函数或链接到Julia的应用程序中的函数。</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">一个函数签名;</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">一个有声明返回类型的函数将其返回值转换为该类型。</target>
        </trans-unit>
        <trans-unit id="fff933fe03507e0a69f0bb2eb791a7b5f8b176b4" translate="yes" xml:space="preserve">
          <source>A functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. Some &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;workarounds&lt;/a&gt; may be necessary for performance when modifying captured variables.</source>
          <target state="translated">该语言完全支持一种函数式编程样式，包括闭包，但并不总是Julia的惯用解决方案。修改捕获的变量时，可能需要一些&lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;变通办法&lt;/a&gt;来提高性能。</target>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">git对象标识符，基于sha-1哈希值。它是一个20字节的字符串（40个十六进制数字），用于标识存储库中的 &lt;code&gt;GitObject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">给定的 &lt;code&gt;AbstractChar&lt;/code&gt; 子类型可能仅能表示Unicode的子集，在这种情况下，从不受支持的 &lt;code&gt;UInt32&lt;/code&gt; 值进行的转换可能会引发错误。相反，内置的&lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;类型表示Unicode 的&lt;em&gt;超集&lt;/em&gt;（以无损编码无效字节流），在这种情况下，将非Unicode值转换&lt;em&gt;为&lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; 会引发错误。所述&lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt;函数可用于检查哪个码点是在给定表示的 &lt;code&gt;AbstractChar&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">一个全局变量可能在任何时候改变它的值,从而改变它的类型。这使得编译器难以优化使用全局变量的代码。变量应该是局部的,或者尽可能地作为参数传递给函数。</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Julia的一个强项是，即使I / O实际上是异步发生的，由于API是同步公开的，因此我们不必担心回调，甚至不必确保服务器可以运行。当我们调用 &lt;code&gt;connect&lt;/code&gt; 时，当前任务等待建立连接，并且只有在完成连接后才继续执行。在此暂停中，服务器任务恢复执行（因为现在有连接请求可用），接受连接，打印消息并等待下一个客户端。阅读和写作以相同的方式进行。要看到这一点，请考虑以下简单的回显服务器：</target>
        </trans-unit>
        <trans-unit id="31c1ae4c7c3a38a0afd976393219aa6a44dd785b" translate="yes" xml:space="preserve">
          <source>A hard-coded &lt;a href=&quot;../base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; of common array types that follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays&quot;&gt;strided array interface&lt;/a&gt;, with elements of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; dimensions.</source>
          <target state="translated">硬编码&lt;a href=&quot;../base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt;下面的共同数组类型的&lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays&quot;&gt;跨距阵列接口&lt;/a&gt;，与类型的元素 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 尺寸。</target>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">标题行可以包含任何内联语法,就像段落可以一样。</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">定义 &lt;code&gt;AbstractArray&lt;/code&gt; 子类型的关键部分是&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;。由于索引是数组的重要组成部分，并且经常发生在热循环中，因此使索引和索引分配尽可能高效是很重要的。数组数据结构通常以以下两种方式之一进行定义：要么仅使用一个索引（线性索引）最有效地访问其元素，要么本质上访问具有为每个维指定的索引的元素。 Julia将这两种方式标识为 &lt;code&gt;IndexLinear()&lt;/code&gt; 和 &lt;code&gt;IndexCartesian()&lt;/code&gt; 。将线性索引转换为多个索引下标通常非常昂贵，因此这提供了一种基于特征的机制，可为所有数组类型启用有效的通用代码。</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">线性索引到阵列 &lt;code&gt;A&lt;/code&gt; 可以转换为一个 &lt;code&gt;CartesianIndex&lt;/code&gt; 为笛卡尔索引与 &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; （参见&lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;），和一组 &lt;code&gt;N&lt;/code&gt; 笛卡尔索引可以转换为线性索引与 &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; （请参见&lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2c3eb1f6f74eb080998f31c2d0aa44b3b54b4558" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer index to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexLinear&lt;/code&gt; will return a simple one-dimensional range, even if it is multidimensional.</source>
          <target state="translated">线性索引样式使用一个整数索引来描述数组中的位置（即使它是多维数组），并且使用列大顺序来有效访问元素。这意味着从&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;数组中请求每个 &lt;code&gt;IndexLinear&lt;/code&gt; 将返回一个简单的一维范围，即使它是多维范围也是如此。</target>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">线性索引样式使用一个整数来描述数组中的位置（即使它是多维数组），并且使用列大顺序来访问元素。例如，如果 &lt;code&gt;A&lt;/code&gt; 是具有线性索引的 &lt;code&gt;(2, 3)&lt;/code&gt; 自定义矩阵类型，并且我们引用 &lt;code&gt;A[5]&lt;/code&gt; （使用线性样式），则这将等效于引用 &lt;code&gt;A[1, 3]&lt;/code&gt; （因为 &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; ）。另请参见&lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">输入类型的文字元组</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">再往下一点,你看。</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">如上所示，使用 &lt;code&gt;-p&lt;/code&gt; 选项指定的本地集群。</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">记录器控制着如何过滤和发送日志记录。当一个日志记录生成时,记录器是第一段用户可配置的代码,它可以检查记录并决定如何处理它。</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Julia的很多功能和可扩展性来自于非正式接口的集合。通过扩展一些特定的方法来为自定义类型工作,该类型的对象不仅可以接收到这些功能,而且还可以在其他方法中使用,这些方法是为了通用地建立在这些行为的基础上而编写的。</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">一种低级API，该API 返回由&lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; &lt;/a&gt;返回的 &lt;code&gt;id&lt;/code&gt; 的支持 &lt;code&gt;AbstractChannel&lt;/code&gt; 。该呼叫仅在支持通道存在的节点上有效。</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">给定 &lt;code&gt;IO&lt;/code&gt; 连接或 &lt;code&gt;Worker&lt;/code&gt; 的低级API ，返回与其连接的worker 的 &lt;code&gt;pid&lt;/code&gt; 。在为类型编写自定义&lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt;方法时，这很有用，该方法可以根据接收进程ID优化写出的数据。</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">机器规范可以是字符串 &lt;code&gt;machine_spec&lt;/code&gt; 或元组- &lt;code&gt;(machine_spec, count)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">一个宏,用于评估一个表达式,丢弃所产生的值,而是以浮点数的形式返回执行所需的秒数。</target>
        </trans-unit>
        <trans-unit id="25d6ce8e35c816ac4036b6028811a1a2075b37da" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.</source>
          <target state="translated">一个宏,用于评估一个表达式,丢弃产生的值,而返回在评估表达式期间分配的总字节数。</target>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">用于评估表达式的宏，丢弃结果值，而是返回在评估表达式期间分配的总字节数。注意：为了消除编译的影响，表达式是在局部函数而不是当前上下文中求值的，但是，由于JIT编译，可能还会有一些分配。这也使结果与 &lt;code&gt;@time&lt;/code&gt; 宏不一致，后者不会尝试针对编译效果进行调整。</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">执行一个表达式的宏,并返回表达式的值、经过的时间、分配的总字节数、垃圾回收时间,以及一个带有各种内存分配计数器的对象。</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">执行一个表达式的宏,在返回表达式的值之前,打印它执行的时间、分配的次数和它的执行导致被分配的字节总数。</target>
        </trans-unit>
        <trans-unit id="e612ee47dedcebb8c33ec68affacf4a81104cb7f" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a &lt;code&gt;for&lt;/code&gt; loop to run with multiple threads. Splits the iteration space among multiple tasks and runs those tasks on threads according to a scheduling policy. A barrier is placed at the end of the loop which waits for all tasks to finish execution.</source>
          <target state="translated">用于并行化 &lt;code&gt;for&lt;/code&gt; 循环以与多个线程一起运行的宏。在多个任务之间分配迭代空间，并根据调度策略在线程上运行这些任务。在循环的末尾放置一个屏障，它等待所有任务完成执行。</target>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">用于并行化for循环以与多个线程一起运行的宏。这会产生 &lt;code&gt;nthreads()&lt;/code&gt; 个线程，在其中分裂迭代空间，并进行并行迭代。在循环的末尾放置一个屏障，它等待所有线程完成执行，然后循环返回。</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">引用类型 &lt;code&gt;T&lt;/code&gt; 的数据的内存地址。但是，不能保证该内存实际上是有效的，也不是它实际上表示指定类型的数据。</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">消息 &lt;code&gt;id&lt;/code&gt; ，它是出现日志记录宏的&lt;em&gt;源代码语句&lt;/em&gt;的唯一固定标识符。只要日志记录本身保持不变，即使文件的源代码发生了更改，此标识符也被设计为相当稳定。</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">在给定的通用函数中不存在具有所需类型签名的方法。或者,不存在唯一的最特定的方法。</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">一个更具可移植性的文件将需要对字长（32位或64位）和标头中的字节序信息进行编码。在实践中，请考虑使用HDF5之类的标准格式（可以与内存映射一起使用）对二进制数据进行编码。</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">对上面的迭代调度的自然扩展是为方法选择添加一层，该层允许调度与由类型层次结构定义的集合无关的类型集合。我们可以通过编写了构建这样一套 &lt;code&gt;Union&lt;/code&gt; 问题的类型，但后来因为这集不会扩展 &lt;code&gt;Union&lt;/code&gt; -types创建后不能更改。然而，可以用通常被称为&lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&amp;ldquo;圣洁特性&amp;rdquo;&lt;/a&gt;的设计模式来编程这样的可扩展集合。</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;f&lt;/code&gt; 返回的负值将停止树行走。正值表示如果 &lt;code&gt;post&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则将跳过该条目。</target>
        </trans-unit>
        <trans-unit id="62d79b805fd70e21e9dc784de34e11e7bbeb08de" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table&quot;&gt;table&lt;/a&gt; for a complete list). Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing &lt;code&gt;local x&lt;/code&gt; declares a new local variable in that scope, regardless of whether there is already a variable named &lt;code&gt;x&lt;/code&gt; in an outer scope or not. Declaring each new local like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a new variable in a local scope to implicitly declare that variable as a new local. Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might na&amp;iuml;vely imagine.</source>
          <target state="translated">大多数代码块都引入了新的本地范围（有关完整列表，请参见上&lt;a href=&quot;#man-scope-table&quot;&gt;表&lt;/a&gt;）。一些编程语言要求在使用新变量之前明确声明它们。显式声明也适用于Julia：在任何局部范围内，编写 &lt;code&gt;local x&lt;/code&gt; 在该范围内声明一个新的局部变量，而不管外部范围中是否已经存在名为 &lt;code&gt;x&lt;/code&gt; 的变量。像这样声明每个新的本地语言有些冗长乏味，因此，与许多其他语言一样，Julia认为在本地范围内分配给新变量会隐式将该变量声明为新的本地语言。通常，这是非常直观的，但是与许多直观地表现的事物一样，这些细节比人们天真的想象的要微妙得多。</target>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">大多数代码块都引入了新的本地范围（有关完整列表，请参见上&lt;a href=&quot;#man-scope-table-1&quot;&gt;表&lt;/a&gt;）。本地作用域从父本地作用域继承所有变量，以进行读取和写入。与全局作用域不同，局部作用域不是名称空间，因此内部作用域中的变量无法通过某种合格的访问从父作用域中检索。</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; 的非数值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;的非数值。</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; 的非数值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91d3c0787a3293d9e014f25bc097c52cd39aa358" translate="yes" xml:space="preserve">
          <source>A numeric literal placed directly before an identifier or parentheses, e.g. &lt;code&gt;2x&lt;/code&gt; or &lt;code&gt;2(x+y)&lt;/code&gt;, is treated as a multiplication, except with higher precedence than other binary operations. See &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;Numeric Literal Coefficients&lt;/a&gt; for details.</source>
          <target state="translated">直接放在标识符或括号之前的数字文字 &lt;code&gt;2(x+y)&lt;/code&gt; 例如 &lt;code&gt;2x&lt;/code&gt; 或2（x + y））被视为乘法，但其优先级高于其他二进制运算。有关详细信息，请参见&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;数字文字系数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一维&lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">每个Julia会话只能加载一次软件包。如果您在当前的Julia会话中运行了 &lt;code&gt;import Example&lt;/code&gt; ，则必须重新启动Julia并重新运行Pkg REPL中的 &lt;code&gt;activate tutorial&lt;/code&gt; 。&lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt;可以使此过程变得更加愉快，但是对其进行设置超出了本指南的范围。</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">一个有项目文件但没有明确UUID的包只能被没有项目文件的包依赖,因为分配给这些包的虚拟UUID是严格的内部文件。</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">没有项目文件的软件包不能依赖没有项目文件的软件包，因为有项目文件的软件包只能加载 &lt;code&gt;graph&lt;/code&gt; 软件包，而没有项目文件的软件包则不会出现在 &lt;code&gt;graph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">一个没有项目文件的包可以依赖任何顶层的依赖,由于包目录下的每个包都可以在顶层使用,所以它可以导入环境中的所有包。</target>
        </trans-unit>
        <trans-unit id="5392bfe5103ecd0e6030986407ee36c2237b3b31" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">段落是纯文本块，可能包含上面的&amp;ldquo;&lt;a href=&quot;#Inline-elements&quot;&gt;内联元素&amp;rdquo;&lt;/a&gt;部分中定义的任何数量的内联元素，在其上方和下方都有一个或多个空行。</target>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">段落是纯文本块，可能包含上面的&amp;ldquo; &lt;a href=&quot;#Inline-elements-1&quot;&gt;内联元素&amp;rdquo;&lt;/a&gt;部分中定义的任意数量的内联元素，在其上方和下方都有一个或多个空行。</target>
        </trans-unit>
        <trans-unit id="6007e06cc6ef0228d827b11a1334d34e7c3bc855" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 类型的一个特别有用的情况是 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 可以是任何类型，&lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;是单例类型，其唯一实例是对象&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;。此模式与其他语言的Julia等效于&lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; ， &lt;code&gt;Option&lt;/code&gt; 或 &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt;类型。将函数参数或字段声明为 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 可以将其设置为 &lt;code&gt;T&lt;/code&gt; 类型的值，也可以将其设置为 &lt;code&gt;nothing&lt;/code&gt; 表示没有值。有关更多信息，请参&lt;a href=&quot;../faq/index#faq-nothing&quot;&gt;见此FAQ条目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 类型的一个特别有用的情况是 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 可以是任何类型，&lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;是单例类型，其唯一实例是对象&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;。此模式与其他语言的Julia等效于&lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; ， &lt;code&gt;Option&lt;/code&gt; 或 &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt;类型。声明函数参数或一个字段作为 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 允许使用其设置为类型的值 &lt;code&gt;T&lt;/code&gt; ，还是 &lt;code&gt;nothing&lt;/code&gt; ，表明没有价值。有关更多信息，请参&lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;见此FAQ条目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">指向数据块的指针</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">正的 &lt;code&gt;Int&lt;/code&gt; 决定最大求和子程序多少时间 &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; 封装依赖解析器的将致力于放弃之前试图满足约束：这个值是默认 &lt;code&gt;1&lt;/code&gt; ，和更大的值对应于更大的量的时间。</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">可以提供预先计算的 &lt;code&gt;mean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d945dad8bbc2c247c2aec246f6c166ddc81c4918" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided. When &lt;code&gt;dims&lt;/code&gt; is specified, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="translated">可以提供预先计算的 &lt;code&gt;mean&lt;/code&gt; 。当指定了 &lt;code&gt;dims&lt;/code&gt; 时， &lt;code&gt;mean&lt;/code&gt; 必须是形状与 &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; 相同的数组（允许附加尾随单例尺寸）。</target>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的参数上使用前缀 &lt;code&gt;&amp;amp;&lt;/code&gt; 表示应传递指向标量参数的指针，而不是标量值本身（如上所述，对于所有Fortran函数参数都是必需的）。下面的示例使用BLAS函数计算点积。</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">基元类型是一种具体的类型,其数据由普通的位组成。基元类型的经典例子是整数和浮点值。与大多数语言不同的是,Julia允许您声明自己的基元类型,而不是只提供一组固定的内置类型。事实上,标准的基元类型都是在语言本身中定义的。</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">项目环境由目录确定，该目录包含一个名为 &lt;code&gt;Project.toml&lt;/code&gt; 的项目文件，以及一个可选的名为 &lt;code&gt;Manifest.toml&lt;/code&gt; 的清单文件。这些文件也可以称为 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 和 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ，在这种情况下， &lt;code&gt;Project.toml&lt;/code&gt; 和 &lt;code&gt;Manifest.toml&lt;/code&gt; 将被忽略。这允许与其他工具共存，这些工具可能认为 &lt;code&gt;Project.toml&lt;/code&gt; 和 &lt;code&gt;Manifest.toml&lt;/code&gt; 文件很重要。但是，对于纯Julia项目，则首选 &lt;code&gt;Project.toml&lt;/code&gt; 和 &lt;code&gt;Manifest.toml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">纯函数只能依赖于不变的信息。这也意味着 &lt;code&gt;@pure&lt;/code&gt; 函数不能使用任何全局可变状态，包括泛型函数。对泛型函数的调用取决于可变状态的方法表。谨慎使用，错误的 &lt;code&gt;@pure&lt;/code&gt; 函数注释可能会导致难以识别错误。仔细检查对泛型函数的调用。</target>
        </trans-unit>
        <trans-unit id="a38ae91b9307c68d0e967bb52415d492ca7b2c6c" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.</source>
          <target state="translated">纯函数只能依赖于不变的信息。这也意味着 &lt;code&gt;@pure&lt;/code&gt; 函数不能使用任何全局可变状态，包括泛型函数。对泛型函数的调用取决于可变状态的方法表。谨慎使用，错误的 &lt;code&gt;@pure&lt;/code&gt; 功能注释可能会导致难以识别的错误。仔细检查对泛型函数的调用。该宏供内部编译器使用，并且可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="ceda790c7683875242632789b7229b6b3328dc5d" translate="yes" xml:space="preserve">
          <source>A quoted piece of code, that does not support interpolation. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-quote-node&quot;&gt;manual section about QuoteNodes&lt;/a&gt; for details.</source>
          <target state="translated">带引号的一段代码，不支持插值。有关详细信息，请参见&lt;a href=&quot;../../manual/metaprogramming/index#man-quote-node&quot;&gt;有关QuoteNodes&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">甲范围 &lt;code&gt;r&lt;/code&gt; ，其中 &lt;code&gt;r[i]&lt;/code&gt; 产生类型的值 &lt;code&gt;T&lt;/code&gt; （在第二形式中， &lt;code&gt;T&lt;/code&gt; 自动推导出），通过参数化 &lt;code&gt;ref&lt;/code&gt; erence值， &lt;code&gt;step&lt;/code&gt; ，和 &lt;code&gt;len&lt;/code&gt; GTH。默认情况下， &lt;code&gt;ref&lt;/code&gt; 是起始值 &lt;code&gt;r[1]&lt;/code&gt; ，但您也可以将其作为 &lt;code&gt;r[offset]&lt;/code&gt; 的值提供给其他一些索引 &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; 。与 &lt;code&gt;TwicePrecision&lt;/code&gt; 结合使用，可以实现没有舍入误差的范围。</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">由类型 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 参数化的范围，其中填充了从 &lt;code&gt;start&lt;/code&gt; 到 &lt;code&gt;stop&lt;/code&gt; 间隔为 &lt;code&gt;1&lt;/code&gt; 的元素。带有 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 均为 &lt;code&gt;Integer&lt;/code&gt; 的语法 &lt;code&gt;a:b&lt;/code&gt; 创建一个 &lt;code&gt;UnitRange&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">一系列带有 &lt;code&gt;len&lt;/code&gt; 个其之间线性间隔元件 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 。间距的大小由 &lt;code&gt;len&lt;/code&gt; 控制，该值必须为 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">一个相关的策略漏洞可以 &lt;code&gt;promote&lt;/code&gt; 将 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 带入一个通用类型：</target>
        </trans-unit>
        <trans-unit id="d7c0e6452fd18c0732cb625754236d5f55a408f6" translate="yes" xml:space="preserve">
          <source>A related third strategy is to use a yield-free queue. We don't currently have a lock-free queue implemented in Base, but &lt;code&gt;Base.InvasiveLinkedListSynchronized{T}&lt;/code&gt; is suitable. This can frequently be a good strategy to use for code with event loops. For example, this strategy is employed by &lt;code&gt;Gtk.jl&lt;/code&gt; to manage lifetime ref-counting. In this approach, we don't do any explicit work inside the &lt;code&gt;finalizer&lt;/code&gt;, and instead add it to a queue to run at a safer time. In fact, Julia's task scheduler already uses this, so defining the finalizer as &lt;code&gt;x -&amp;gt; @spawn do_cleanup(x)&lt;/code&gt; is one example of this approach. Note however that this doesn't control which thread &lt;code&gt;do_cleanup&lt;/code&gt; runs on, so &lt;code&gt;do_cleanup&lt;/code&gt; would still need to acquire a lock. That doesn't need to be true if you implement your own queue, as you can explicitly only drain that queue from your thread.</source>
          <target state="translated">相关的第三种策略是使用无收益队列。目前，我们没有在Base中实现无锁队列，但是 &lt;code&gt;Base.InvasiveLinkedListSynchronized{T}&lt;/code&gt; 是合适的。对于带有事件循环的代码，这通常是一个很好的策略。例如， &lt;code&gt;Gtk.jl&lt;/code&gt; 使用此策略来管理生命周期引用计数。在这种方法中，我们无需在 &lt;code&gt;finalizer&lt;/code&gt; 内部进行任何显式的工作，而是将其添加到队列中以在更安全的时间运行。实际上，Julia的任务计划程序已经使用了此方法，因此将终结器定义为 &lt;code&gt;x -&amp;gt; @spawn do_cleanup(x)&lt;/code&gt; 是此方法的一个示例。但是请注意，这并不控制 &lt;code&gt;do_cleanup&lt;/code&gt; 在哪个线程上运行，因此 &lt;code&gt;do_cleanup&lt;/code&gt; 仍然需要获得一把锁。如果您实现自己的队列，则不必是真的，因为您可以明确地仅从线程中耗尽该队列。</target>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">远程调用将&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;返回其结果。远程呼叫立即返回；进行呼叫的过程继续进行下一个操作，而远程呼叫发生在其他地方。您可以通过对返回的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;来等待远程调用完成，然后可以使用 &lt;code&gt;fetch&lt;/code&gt; 获取结果的完整值。</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">还可以使用 &lt;code&gt;::&lt;/code&gt; 运算符在函数声明中指定返回类型。这会将返回值转换为指定的类型。</target>
        </trans-unit>
        <trans-unit id="f794450cdef21a1d306e7fb59ec235acfc19011a" translate="yes" xml:space="preserve">
          <source>A return type can be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">可以使用 &lt;code&gt;::&lt;/code&gt; 运算符在函数声明中指定返回类型。这会将返回值转换为指定的类型。</target>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; 返回类型表示该函数将不返回，即C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; 或C11 &lt;code&gt;_Noreturn&lt;/code&gt; （例如 &lt;code&gt;jl_throw&lt;/code&gt; 或 &lt;code&gt;longjmp&lt;/code&gt; ）。不要将此函数用于不返回任何值（ &lt;code&gt;void&lt;/code&gt; ）但确实返回的函数，而应使用 &lt;code&gt;Cvoid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0df8658c1a2663d5b4b16580728c11544340a3ac" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return, i.e., C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; 返回类型表示该函数将不返回，即C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; 或C11 &lt;code&gt;_Noreturn&lt;/code&gt; （例如 &lt;code&gt;jl_throw&lt;/code&gt; 或 &lt;code&gt;longjmp&lt;/code&gt; ）。不要将此函数用于不返回任何值（ &lt;code&gt;void&lt;/code&gt; ）但确实返回的函数，而应使用 &lt;code&gt;Cvoid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">丰富的类型语言,用于构造和描述对象,也可以选择用来进行类型声明。</target>
        </trans-unit>
        <trans-unit id="3b35eab36ca2f92e10ca8fc1b981602576d246ef" translate="yes" xml:space="preserve">
          <source>A sampler for types, containing no other information. The default fallback for &lt;code&gt;Sampler&lt;/code&gt; when called with types.</source>
          <target state="translated">类型的采样器，不包含其他信息。使用类型调用时， &lt;code&gt;Sampler&lt;/code&gt; 的默认后备。</target>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">抽样剖析器不能提供完整的逐行覆盖,因为回溯是有时间间隔的(默认情况下,Unix系统为1毫秒,Windows系统为10毫秒,尽管实际的调度取决于操作系统的负载)。此外,如下文所述,由于样本是在所有执行点的一个稀疏子集上收集的,因此采样剖析器收集的数据会受到统计噪声的影响。</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">一个标量索引。默认情况下包括:</target>
        </trans-unit>
        <trans-unit id="2e149e1fe6cf738b9500f7f73419a47eddcaa861" translate="yes" xml:space="preserve">
          <source>A second strategy, employed by Base in a couple places, is to explicitly delay a finalizer until it may be able to acquire its lock non-recursively. The following example demonstrates how this strategy could be applied to &lt;code&gt;Distributed.finalize_ref&lt;/code&gt;:</source>
          <target state="translated">Base在几个地方采用的第二种策略是显式延迟终结器，直到它可以非递归获取其锁为止。以下示例演示了如何将该策略应用于 &lt;code&gt;Distributed.finalize_ref&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">缩短的git对象标识符，可用于标识唯一的git对象，它由 &lt;code&gt;hash&lt;/code&gt; 的初始 &lt;code&gt;len&lt;/code&gt; 十六进制数字（其余数字将被忽略）组成。</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">一个简单的TCP例子</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">一个简单的例子是一个具有定义长度的可迭代的平方数序列。</target>
        </trans-unit>
        <trans-unit id="74210b965c13b3f0a92488bc76d8ed6610e194df" translate="yes" xml:space="preserve">
          <source>A simple sampler without pre-computed data</source>
          <target state="translated">一个没有预先计算数据的简单采样器</target>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">此脚本的简单用法是从命令行开始。假设 &lt;code&gt;julia-config.jl&lt;/code&gt; 位于 &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; ，则可以直接在命令行上调用它，并且可以使用以下三个标志的任意组合：</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">这个类型的单子提供了一个环境变量的哈希表接口。</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">存在用于广播的特殊语法： &lt;code&gt;f.(args...)&lt;/code&gt; 等效于 &lt;code&gt;broadcast(f, args...)&lt;/code&gt; ，并且嵌套的 &lt;code&gt;f.(g.(args...))&lt;/code&gt; 调用被合并到单个广播循环中。</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">一堆 &quot;depot &quot;位置,包管理器以及Julia的代码加载机制在这里寻找包注册表、已安装的包、命名的环境、repo克隆、缓存的编译包镜像和配置文件。默认情况下,它包括。</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">跨距数组是 &lt;code&gt;AbstractArray&lt;/code&gt; 的子类型，其条目以固定跨距存储在内存中。如果数组的元素类型与BLAS兼容，则跨步数组可以利用BLAS和LAPACK例程获得更有效的线性代数例程。用户定义的跨步数组的一个典型示例是包装带有附加结构的标准 &lt;code&gt;Array&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">一个包含构建三重奏的字符串。</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">一个字符串，包含指向包含 &lt;code&gt;julia&lt;/code&gt; 可执行文件的目录的完整路径。</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个字符串，其中包含从命令行传递给Julia的脚本名称。请注意，脚本名称在包含的文件中保持不变。或者，请参阅&lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">一个字符串,给出一个数字的字面位数表示。</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">结构也可以通过 &lt;code&gt;&amp;lt;:&lt;/code&gt; 语法声明抽象超类型：</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">调用成功表示该请求已被远程节点接受执行。</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">当前范围内的一个符号没有被定义。</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">一个代表构建配置架构的符号。</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">一个符号，代表操作系统的名称，由构建配置的 &lt;code&gt;uname&lt;/code&gt; 名称返回。</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">也可以通过调用内置函数 &lt;code&gt;Base.operator_associativity&lt;/code&gt; 找到表示操作员关联性的符号：</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">系统调用失败，并显示错误代码（在 &lt;code&gt;errno&lt;/code&gt; 全局变量中）。</target>
        </trans-unit>
        <trans-unit id="e7383f155bc43b22861eb93ff761378a3dfd82ac" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect.</source>
          <target state="translated">最初不知道通过调用&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;显式创建的任务。这使您可以根据需要使用&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;手动管理任务。但是，当此类任务等待事件发生时，它仍然会自动发生，如您期望的那样，在事件发生时自动重新启动。</target>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">最初不知道通过调用&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;显式创建的任务。这使您可以根据需要使用&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;手动管理任务。但是，当这样的任务等待事件发生时，它仍然会自动发生事件发生时自动重新启动，这与您期望的一样。也可以使调度程序尽可能地运行任务，而不必等待任何事件。这可以通过调用&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;或使用&lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt;宏来完成（有关更多详细信息，请参见&lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;并行计算&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; 的&lt;/a&gt;线程安全版本。</target>
        </trans-unit>
        <trans-unit id="edef5e7571427a5f91f025df54f077af0dd3024e" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;../parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; 的&lt;/a&gt;线程安全版本。</target>
        </trans-unit>
        <trans-unit id="2b58805de54debccfbd0e801ac822dbec053b647" translate="yes" xml:space="preserve">
          <source>A tuple of input types, corresponding to the function signature</source>
          <target state="translated">输入类型的元组,对应于函数签名。</target>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">输入类型的元组。输入类型必须写成一个元组,而不是一个元组值的变量或表达式。</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">二维&lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">类型断言失败,或者调用固有函数时参数类型不正确。</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">一种代表标准互联网数据格式的类型。&quot;MIME &quot;代表 &quot;Multipurpose Internet Mail Extensions&quot;,因为该标准最初是用来描述电子邮件信息的多媒体附件。</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">一种类型，表示已解析的茱莉亚代码（AST）中的复合表达式。每个表达式都由一个 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; 用于标识它是哪种表达式）（例如，调用，for循环，条件语句等）以及子表达式（例如，调用的自变量）组成。子表达式存储在一个名为 &lt;code&gt;args&lt;/code&gt; 的 &lt;code&gt;Vector{Any}&lt;/code&gt; 字段中。</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">类型联合是一种特殊的抽象类型，它包含使用特殊的&lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt;关键字构造的其任何参数类型的所有实例作为对象：</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">类型联合是抽象类型，包括其任何参数类型的所有实例。空的&lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt;是Julia的底部类型。</target>
        </trans-unit>
        <trans-unit id="d4feddb63143773f90aec3aa6e9e79164c040b57" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;a href=&quot;#Base.round-Tuple%7BType,Any%7D&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="translated">用于控制浮点运算的舍入模式（通过A型&lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt;/ &lt;code&gt;setrounding&lt;/code&gt; 函数），或者作为可选参数为四舍五入到最接近的整数（通过&lt;a href=&quot;#Base.round-Tuple%7BType,Any%7D&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt;函数）。</target>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">用于控制浮点运算的舍入模式（通过A型&lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; 函数），或者作为可选参数为四舍五入到最接近的整数（通过 &lt;code&gt;round&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">没有字段的类型就是&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">一种不包含&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;其单例实例的字段的类型，用于表示缺少的值。</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">然而,这种一对返回值的典型用法是将每个值提取到一个变量中。茱莉亚支持简单的元组 &quot;解构&quot;,这就方便了。</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">在类型参数的所有值上的类型联合。 &lt;code&gt;UnionAll&lt;/code&gt; 用于描述参数类型未知的参数类型。</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">测量时间的有用工具是&lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt;宏。我们在这里用上面的全局变量重复该示例，但是这次删除了类型注释：</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">可以通过将变量名称声明为 &lt;code&gt;global x&lt;/code&gt; 来&amp;ldquo;保留&amp;rdquo;变量名称，而无需对其进行分配。这样可以避免在加载时间后初始化的全局变量的名称冲突。</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">指向最后计算值的变量,在交互式提示下自动设置。</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">在Julia中,变量是与一个值相关联(或绑定)的名称。当你想存储一个值(例如,经过一些数学计算后得到的)供以后使用时,它是很有用的。比如说,你想把一个值(经过一些数学计算后得到的值)存储起来,以便以后使用。</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">避免出现类型不稳定性的这种方法的一种变体是将 &lt;code&gt;Int&lt;/code&gt; 和&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;类型合并为单个混合整数类型，当结果不再适合机器整数的大小时，该类型会在内部更改表示形式。尽管这从表面上避免了Julia代码级别的类型不稳定性，但它通过将所有相同的困难加在实现此混合整数类型的C代码上，彻底解决了问题。这种方法&lt;em&gt;可以&lt;/em&gt;在很多情况下可以工作，甚至可以很快完成，但是有一些缺点。一个问题是整数的内存中表示形式和整数数组不再与C，Fortran和其他语言与本机机器整数使用的自然表示形式匹配。因此，要与这些语言进行互操作，无论如何我们最终都需要引入本机整数类型。整数的任何无界表示形式都不能具有固定的位数，因此不能内联存储在具有固定大小的插槽的数组中&amp;ndash;大整数值将始终需要单独的堆分配存储。当然，无论使用哪种混合整数实现多么聪明，总会有性能陷阱-性能意外下降的情况。表示形式复杂，缺乏与C和Fortran的互操作性，无法在没有额外堆存储的情况下表示整数数组，以及不可预测的性能特征，即使是最聪明的混合整数实现，也都不是高性能数值工作的不佳选择。</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; &lt;/a&gt;是一个非常特殊的宏，它允许您定义所谓的&lt;em&gt;生成函数&lt;/em&gt;。它们具有根据其参数类型生成专用代码的能力，与多次分派所能实现的相比，它们具有更大的灵活性和/或更少的代码。尽管宏在解析时与表达式一起使用并且无法访问其输入的类型，但是当已知参数的类型但尚未编译该函数时，生成的函数会在一次扩展。</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">中使用的包装类型 &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 不存在的值（区分&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;）和存在 &lt;code&gt;nothing&lt;/code&gt; 值（即 &lt;code&gt;Some(nothing)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">API参考</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII字符和ASCII转义符产生一个单字节。</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="125c32f24e67f8006c45d7fdea568e01f28fd48b" translate="yes" xml:space="preserve">
          <source>Abbreviated days of the week</source>
          <target state="translated">缩略的一周天数</target>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">上文指出,可以通过解决歧义问题,如</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">抽象数组</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">抽象类型</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">抽象容器和元素类型</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">抽象的数字类型</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">抽象超类，描述实现同步原语的类型：&lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">IP地址的抽象超类型。&lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;是其子类型。</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">所有浮点数的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">所有整数的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">所有数字类型的抽象超级类型。</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">所有实数的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">所有有符号整数的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">所有无符号整数的抽象超类型。</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">丰富的显示输出设备的抽象超类型。&lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt;是其子类型。</target>
        </trans-unit>
        <trans-unit id="5e9597d58105eaf8a30d20d99c956a69b4d700ba" translate="yes" xml:space="preserve">
          <source>Abstract type for &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix factorizations&lt;/a&gt; a.k.a. matrix decompositions. See &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;online documentation&lt;/a&gt; for a list of available matrix factorizations.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;矩阵分解&lt;/a&gt;又称为矩阵分解的抽象类型。有关可用矩阵分解的列表，请参见&lt;a href=&quot;#man-linalg-factorizations&quot;&gt;在线文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">所有函数的抽象类型。</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">抽象类型使用&lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt;关键字声明。声明抽象类型的常规语法为：</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">抽象类型不能被实例化,只能作为类型图中的节点,从而描述相关具体类型的集合:那些具体类型是它们的后代。我们从抽象类型开始,即使它们没有实例化,因为它们是类型系统的骨干:它们形成了概念层次,使得Julia的类型系统不仅仅是对象实现的集合。</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; 使用显示堆栈中最适用的显示器，通常使用 &lt;code&gt;x&lt;/code&gt; 支持的最丰富的多媒体输出，并以纯文本&lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;输出作为后备。所述 &lt;code&gt;display(d, x)&lt;/code&gt; 变体的尝试显示 &lt;code&gt;x&lt;/code&gt; 在给定的显示 &lt;code&gt;d&lt;/code&gt; 只，投掷&lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;d&lt;/code&gt; 不能显示此类型的对象。</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">滥用这一点将破坏运行时系统并导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">交流电流</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">在给定的服务器上接受一个连接并返回一个连接到客户端。可以提供一个未初始化的客户端流,在这种情况下,将使用它来代替创建一个新的流。</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">按内存顺序,沿列访问数组。</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">访问必须有跨步模式,不能是 &quot;收集&quot;(随机索引读)或 &quot;分散&quot;(随机索引写)。</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">通过指针访问数据</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">访问文件</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">访问全局变量</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">访问返回的数组</target>
        </trans-unit>
        <trans-unit id="06321d9fadb0d72695135f33706dc1e00ad6f5c5" translate="yes" xml:space="preserve">
          <source>Accessing memory of an object directly via a &lt;code&gt;Ptr&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;Ptr&lt;/code&gt; 直接访问对象的内存</target>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用字段访问语法（例如 &lt;code&gt;x.a&lt;/code&gt; ）或使用&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;（例如 &lt;code&gt;x[:a]&lt;/code&gt; 来访问与命名元组中的名称关联的值。可以使用&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;获得名称的元组，并且可以使用&lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;获得值的元组。</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">配件功能</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">积累和清算</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">精确的自然对数 &lt;code&gt;1+x&lt;/code&gt; 。对于小于-1的&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;参数，抛出&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">准确计算$e^x-1$。</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">在 &lt;code&gt;lock&lt;/code&gt; 可用时获取锁。如果该锁已被其他任务/线程锁定，请等待该锁变为可用。</target>
        </trans-unit>
        <trans-unit id="1b62ab8ac8364cef9cfdb46dc16347ea263ed957" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt;, execute &lt;code&gt;f&lt;/code&gt; with the &lt;code&gt;lock&lt;/code&gt; held, and release the &lt;code&gt;lock&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; returns. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">获取 &lt;code&gt;lock&lt;/code&gt; ，执行 &lt;code&gt;f&lt;/code&gt; 与 &lt;code&gt;lock&lt;/code&gt; 持有，并释放 &lt;code&gt;lock&lt;/code&gt; 时 &lt;code&gt;f&lt;/code&gt; 回报。如果该锁已被其他任务/线程锁定，请等待该锁变为可用。</target>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">获取锁（如果有），如果成功，则返回 &lt;code&gt;true&lt;/code&gt; 。如果该锁已被其他任务/线程锁定，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">锐角</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;添加到调度程序的队列。这将导致任务在系统空闲时持续运行，除非该任务执行诸如&lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;的阻止操作。</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">为指定的 &lt;code&gt;rmt&lt;/code&gt; 添加&lt;em&gt;访&lt;/em&gt;存refspec。该refspec将包含有关从哪个分支提取的信息。</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">为指定的 &lt;code&gt;rmt&lt;/code&gt; 添加&lt;em&gt;push&lt;/em&gt; refspec 。此refspec将包含有关要推送到哪个分支的信息。</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">在流 &lt;code&gt;s&lt;/code&gt; 的当前位置添加一个标记。返回标记的位置。</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">添加的所有文件与指定的路径 &lt;code&gt;files&lt;/code&gt; 的索引 &lt;code&gt;idx&lt;/code&gt; （或指数 &lt;code&gt;repo&lt;/code&gt; ）。如果文件已经存在，则索引条目将被更新。如果该文件尚不存在，它将被重新添加到索引中。 &lt;code&gt;files&lt;/code&gt; 可能包含将被扩展的glob模式，并且将添加任何匹配的文件（除非设置了 &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; ，请参见下文）。如果文件被忽略（在 &lt;code&gt;.gitignore&lt;/code&gt; 或在配置中），&lt;em&gt;则将不会&lt;/em&gt;添加该文件，&lt;em&gt;除非&lt;/em&gt;已在索引中对其进行了跟踪，在这种情况下&lt;em&gt;将&lt;/em&gt;对其进行更新。关键字参数 &lt;code&gt;flags&lt;/code&gt; 是一组位标记，用于控制有关被忽略文件的行为：</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">通过SSH在远程计算机上添加进程。要求 &lt;code&gt;julia&lt;/code&gt; 必须安装在每个节点上的相同位置，或者可以通过共享文件系统使用。</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">的元素添加 &lt;code&gt;collection2&lt;/code&gt; 在2002年底 &lt;code&gt;collection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">加法运算符。 &lt;code&gt;x+y+z+...&lt;/code&gt; 使用所有参数调用该函数，即 &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">其他示例和测试位于&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">此外，&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;不仅限于数组（请参见功能文档），它还处理元组，并将非数组，元组或&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;除外）以外的任何参数视为&amp;ldquo;标量&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="945097f233edb04921a995b222a7aba704c8bec8" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections. By default, only some argument types are considered scalars, including (but not limited to) &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;code&gt;missing&lt;/code&gt; and &lt;code&gt;nothing&lt;/code&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">此外，&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;不限于数组（请参见功能文档）；请参见功能文档。它还处理标量，元组和其他集合。默认情况下，仅将某些参数类型视为标量，包括（但不限于） &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ， &lt;code&gt;Type&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 以及一些常见的单例，如 &lt;code&gt;missing&lt;/code&gt; 和 &lt;code&gt;nothing&lt;/code&gt; 。所有其他参数在元素方式上进行迭代或索引。</target>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">此外，分别提供&lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt;分别用于更精确地计算 &lt;code&gt;sin(pi*x)&lt;/code&gt; 和 &lt;code&gt;cos(pi*x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6351bb5c94d5c92615addcb5b2795472a480f027" translate="yes" xml:space="preserve">
          <source>Additionally, Julia is not memory safe in the presence of a data race. Be very careful about reading a global variable (or closure variable) if another thread might write to it! Instead, always use the lock pattern above when changing any data (such as assigning to a global) visible to multiple threads.</source>
          <target state="translated">此外,Julia在数据竞赛的情况下是不安全的。如果另一个线程可能会对全局变量(或闭包变量)进行写入,那么在读取全局变量时要非常小心! 相反,在改变任何对多个线程可见的数据(如分配给全局)时,总是使用上面的锁模式。</target>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">此外,代码块可以使用三条回标线和一个可选的 &quot;语言 &quot;来指定如何突出显示一个代码块。</target>
        </trans-unit>
        <trans-unit id="1f4cc224a45b05b5c73175d158a7eca11aff2c5e" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">此外，在这些原始数字类型的基础上，全面支持&lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers&quot;&gt;复杂和有理数&lt;/a&gt;。得益于灵活的，用户可扩展的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;类型升级系统&lt;/a&gt;，所有数字类型都可以自然地互操作而无需显式转换。</target>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">此外，在这些原始数字类型的基础上，全面支持&lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;复杂和有理数&lt;/a&gt;。得益于灵活的，用户可扩展的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;类型升级系统&lt;/a&gt;，所有数字类型都可以自然地互操作而无需显式转换。</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此外，正常和指数分布的一些实施 &lt;code&gt;AbstractFloat&lt;/code&gt; 和 &lt;code&gt;Complex&lt;/code&gt; 类型，请参阅&lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt;了解详情。</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">此外,括号内的表达式可以作为变量的系数,意味着表达式与变量的相乘。</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">此外,一些异常类型会接受一个或多个用于错误报告的参数。</target>
        </trans-unit>
        <trans-unit id="7c53242e98f029fd9fd99fe8ac859128c91d92ea" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[begin]&lt;/code&gt; and &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the first and last valid indices, respectively:</source>
          <target state="translated">另外，为了支持语法 &lt;code&gt;S[begin]&lt;/code&gt; 和 &lt;code&gt;S[end]&lt;/code&gt; ，我们必须定义&lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt;分别指定第一个和最后一个有效索引：</target>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">另外，为了支持语法 &lt;code&gt;S[end]&lt;/code&gt; ，我们必须定义&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt;来指定最后一个有效索引。建议还定义&lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; &lt;/a&gt;以指定第一个有效索引：</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ,每个字符串应为可记录的表达式。此语法等效于</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到通过扩展 &lt;code&gt;@m expression&lt;/code&gt; 生成的表达式中。这允许表达饰 &lt;code&gt;@inline&lt;/code&gt; ， &lt;code&gt;@noinline&lt;/code&gt; ， &lt;code&gt;@generated&lt;/code&gt; ，或以相同的方式为未装饰则表达式来进行记录的任何其它宏。</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到 &lt;code&gt;@m(::Any)&lt;/code&gt; 宏定义。</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到 &lt;code&gt;Binding&lt;/code&gt; s &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">再添文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 的 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; 。首选语法是在 &lt;code&gt;Module&lt;/code&gt; 上方添加docstring ，但是两者都是等效的。</target>
        </trans-unit>
        <trans-unit id="82e1da815004f8c82f5b3b4ddf196b362c9b6b8a" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到通过扩展 &lt;code&gt;@m expression&lt;/code&gt; 生成的表达式中。这允许表达饰 &lt;code&gt;@inline&lt;/code&gt; ， &lt;code&gt;@noinline&lt;/code&gt; ， &lt;code&gt;@generated&lt;/code&gt; ，或以相同的方式为未装饰则表达式来进行记录的任何其它宏。</target>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到函数 &lt;code&gt;f&lt;/code&gt; 中。第一个版本是首选语法，但是两者是等效的。</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到名为 &lt;code&gt;@m&lt;/code&gt; 的宏中。</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到方法 &lt;code&gt;f(::Any)&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b443c2f582d2d534bd4dd25c05fdf4fba408aed1" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. However, it is preferred that &lt;code&gt;sym&lt;/code&gt; is documented where it is defined.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到与 &lt;code&gt;sym&lt;/code&gt; 关联的值。但是，最好在定义 &lt;code&gt;sym&lt;/code&gt; 的地方记录该符号。</target>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到与 &lt;code&gt;sym&lt;/code&gt; 相关的值。用户应首选在其定义处记录 &lt;code&gt;sym&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到两个 &lt;code&gt;Method&lt;/code&gt; s中，即 &lt;code&gt;f(::Any)&lt;/code&gt; 和 &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到 &lt;code&gt;T&lt;/code&gt; ，将 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 到 &lt;code&gt;T.x&lt;/code&gt; 字段，将 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 到 &lt;code&gt;T.y&lt;/code&gt; 。也适用于 &lt;code&gt;mutable struct&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">将文档字符串 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 添加到 &lt;code&gt;T1&lt;/code&gt; ， &lt;code&gt;T2&lt;/code&gt; 和 &lt;code&gt;T3&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">调整器功能</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">通过最多 &lt;code&gt;step&lt;/code&gt; 迭代 &lt;code&gt;limit&lt;/code&gt; 迭代来调整 &lt;code&gt;dt&lt;/code&gt; ，直到 &lt;code&gt;func&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;func&lt;/code&gt; 必须接受一个 &lt;code&gt;TimeType&lt;/code&gt; 参数并返回&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;same&lt;/code&gt; 允许 &lt;code&gt;dt&lt;/code&gt; 在满足 &lt;code&gt;func&lt;/code&gt; 时被考虑。</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为其星期的星期一。</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为其星期几。</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为该月的第一个 &lt;code&gt;dow&lt;/code&gt; 。或者， &lt;code&gt;of=Year&lt;/code&gt; 将调整为该年的第一个 &lt;code&gt;dow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为该月的第一天。</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为其季度的第一天。</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为一年的第一天。</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为该月的最后一个 &lt;code&gt;dow&lt;/code&gt; 。另外， &lt;code&gt;of=Year&lt;/code&gt; 将调整为该年的最后一个 &lt;code&gt;dow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为该月的最后一天。</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为该季度的最后一天。</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为一年中的最后一天。</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为与 &lt;code&gt;dow&lt;/code&gt; 对应的星期的第二天，其中 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; 依此类推。设置 &lt;code&gt;same=true&lt;/code&gt; 允许将当前 &lt;code&gt;dt&lt;/code&gt; 视为下一个 &lt;code&gt;dow&lt;/code&gt; ，从而不进行任何调整。</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">将 &lt;code&gt;dt&lt;/code&gt; 调整为与 &lt;code&gt;dow&lt;/code&gt; 相对应的一周的前一天，其中 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; 依此类推。设置 &lt;code&gt;same=true&lt;/code&gt; 可以将当前 &lt;code&gt;dt&lt;/code&gt; 视为先前的 &lt;code&gt;dow&lt;/code&gt; ，从而不进行任何调整。</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">忠告,像大多数其他toplevel元素一样,可以包含其他toplevel元素。</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">推进迭代器以获得下一个元素。如果没有元素仍然存在， &lt;code&gt;nothing&lt;/code&gt; 应该返回。否则，应返回下一个元素的2元组和新的迭代状态。</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">使流 &lt;code&gt;io&lt;/code&gt; 前进，以使下一个读取的字符成为 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 的第一个剩余字符。如果指定了关键字参数 &lt;code&gt;linecomment&lt;/code&gt; ，则将从该字符开始直到下一行开始的所有字符都将被忽略。</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">高级使用方法</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">架空索道</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">像 &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; 这样的通话之后；y = power_by_squaring（x，4），您将获得预期的结果： &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; 。但是，现在假设 &lt;code&gt;*=&lt;/code&gt; ，当与矩阵一起使用时，将左侧突变。会有两个问题：</target>
        </trans-unit>
        <trans-unit id="ad5164f2f115375c06ec8f88153f96f0d31b808d" translate="yes" xml:space="preserve">
          <source>After a task starts running on a certain thread (e.g. via &lt;code&gt;@spawn&lt;/code&gt;), it will always be restarted on the same thread after blocking. In the future this limitation will be removed, and tasks will migrate between threads.</source>
          <target state="translated">在某个任务开始在某个线程上运行后（例如，通过 &lt;code&gt;@spawn&lt;/code&gt; ），在阻塞后它将始终在同一线程上重新启动。将来，将消除此限制，并且任务将在线程之间迁移。</target>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">闹钟</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">阿莱夫符号/第一变身红衣主教</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">&lt;code&gt;UndefInitializer()&lt;/code&gt; 的别名，它构造单例类型&lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; &lt;/a&gt;的实例，用于数组初始化，以指示array-constructor-caller需要未初始化的数组。</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">外星怪兽</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">所有 &lt;code&gt;export&lt;/code&gt; 名称（ &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ）， &lt;code&gt;MyModule.x&lt;/code&gt; ， &lt;code&gt;MyModule.y&lt;/code&gt; 和 &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">人人平等</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">所有I / O任务，计时器，REPL命令等都通过事件循环复用到单个OS线程上。libuv的修补版本（&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;）提供了此功能。屈服点提供了将多个任务协作调度到同一OS线程上的功能。在等待事件发生时，I / O任务和计时器会隐式产生。显式调用&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt;可以安排其他任务。</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">所有Julia流都至少公开了一个&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;方法，并以该流作为它们的第一个参数，例如：</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">所有对象</target>
        </trans-unit>
        <trans-unit id="dd1ab7575b34c95371319e3c78f1e648aa0611b0" translate="yes" xml:space="preserve">
          <source>All Unicode code points (&lt;code&gt;\U&lt;/code&gt; with 1-8 trailing hex digits; max value = 0010ffff)</source>
          <target state="translated">所有Unicode代码点（带有1-8个尾随十六进制数字的 &lt;code&gt;\U&lt;/code&gt; ；最大值= 0010ffff）</target>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">REPL中的所有代码都是在全局范围内评估的，因此在顶层定义和分配的变量将是&lt;strong&gt;全局&lt;/strong&gt;变量。在模块内部的顶级范围定义的变量也是全局的。</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 之后的所有逗号分隔的表达式都被解释为范围。添加括号可以让我们向&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;添加第三个参数：</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">所有的连接都要经过双方的认证,以确保只有由主站启动的工人才可以互相连接。</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">所有声明的类型（ &lt;code&gt;DataType&lt;/code&gt; 变体）都可以参数化，每种情况下使用相同的语法。我们将按以下顺序讨论它们：首先是参数复合类型，然后是参数抽象类型，最后是参数基本类型。</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">默认情况下，某些抽象类型的所有实例都被认为与Julia Base中提供的通用 &lt;code&gt;convert&lt;/code&gt; 定义&amp;ldquo;足够相似&amp;rdquo; 。例如，此定义指出通过调用1参数构造函数 &lt;code&gt;convert&lt;/code&gt; 任何 &lt;code&gt;Number&lt;/code&gt; 类型转换为任何Number类型都是有效的：</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">所有界面定制均通过仅关键字 &lt;code&gt;TerminalMenus.config()&lt;/code&gt; 函数完成。</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">对角线的所有非真实部分将被忽略。</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所有记录宏 &lt;code&gt;@debug&lt;/code&gt; ， &lt;code&gt;@info&lt;/code&gt; ， &lt;code&gt;@warn&lt;/code&gt; 和 &lt;code&gt;@error&lt;/code&gt; 了在详细的文档中更常用的宏观描述的共同特点&lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec4e52b5ca9f88c6fa22f8c3f3902856d9403989" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Logging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所有记录宏 &lt;code&gt;@debug&lt;/code&gt; ， &lt;code&gt;@info&lt;/code&gt; ， &lt;code&gt;@warn&lt;/code&gt; 和 &lt;code&gt;@error&lt;/code&gt; 了在详细的文档中更常用的宏观描述的共同特点&lt;a href=&quot;#Logging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">所有对稀疏矩阵的操作都是精心实现的,以利用CSC数据结构提高性能,并避免昂贵的操作。</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">所有其他参数组合默认情况下都返回 &lt;code&gt;Array&lt;/code&gt; ，但是自定义容器类型可以定义自己的实现和类似促销的规则，以在它们作为参数出现时自定义结果。</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">所有的进程都可以直接相互沟通。</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">集群中的所有进程共享同一个cookie,默认情况下,这个cookie是主进程上随机生成的字符串。</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">所有字符串类型都是抽象类型 &lt;code&gt;AbstractString&lt;/code&gt; 的子类型，外部包定义了其他 &lt;code&gt;AbstractString&lt;/code&gt; 子类型（例如，用于其他编码）。如果定义一个需要字符串参数的函数，则应将该类型声明为 &lt;code&gt;AbstractString&lt;/code&gt; 以便接受任何字符串类型。</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">&lt;code&gt;AbstractDateToken&lt;/code&gt; 的所有子类型都必须定义此方法，以便能够根据包含该令牌的 &lt;code&gt;DateFormat&lt;/code&gt; 打印Date / DateTime对象。</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">所有与排序和顺序相关的功能都依赖于&amp;ldquo;小于&amp;rdquo;关系，该关系定义要操纵的值的总顺序。该 &lt;code&gt;isless&lt;/code&gt; 功能缺省调用，但可以通过在指定的关系 &lt;code&gt;lt&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">所有标准的三角函数和双曲函数也被定义。</target>
        </trans-unit>
        <trans-unit id="47776a059f25c3e9e75665d89b25759946e151d9" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">集群中的所有工作程序都与主服务器共享相同的&lt;a href=&quot;#man-cluster-cookie&quot;&gt;cookie&lt;/a&gt;。当未指定cookie时，即使用 &lt;code&gt;--worker&lt;/code&gt; 选项，工作程序将尝试从其标准输入中读取它。 &lt;code&gt;LocalManager&lt;/code&gt; 和 &lt;code&gt;SSHManager&lt;/code&gt; 都通过其标准输入将cookie传递给新启动的工作程序。</target>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">集群中的所有工作程序都与主服务器共享相同的&lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt;。当未指定cookie时，即使用 &lt;code&gt;--worker&lt;/code&gt; 选项，工作程序将尝试从其标准输入中读取它。 &lt;code&gt;LocalManager&lt;/code&gt; 和 &lt;code&gt;SSHManager&lt;/code&gt; 都通过其标准输入将cookie传递给新启动的工作程序。</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">输出容器的分配</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">允许的变量名称</target>
        </trans-unit>
        <trans-unit id="91b9aa574b0fcbb72864d68cfe9f2b306633c73a" translate="yes" xml:space="preserve">
          <source>Allowed within</source>
          <target state="translated">允许的范围</target>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">几乎等于或等于</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">几乎等于</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">几乎等同于Circumflex Accent</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">好了,现在我们对生成函数的工作原理有了更好的理解,让我们用它们来构建一些更高级(有效)的功能...</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">还要注意的差 &lt;code&gt;max.(a,b)&lt;/code&gt; ，其中&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;小号&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;过的elementwise &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，和&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt;，其发现内最大值 &lt;code&gt;a&lt;/code&gt; 。 &lt;code&gt;min.(a,b)&lt;/code&gt; 和 &lt;code&gt;minimum(a)&lt;/code&gt; 具有相同的关系。</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">还请注意 &lt;code&gt;\xff&lt;/code&gt; 和 &lt;code&gt;\uff&lt;/code&gt; 之间的显着区别：前一个转义序列编码&lt;em&gt;字节255&lt;/em&gt;，而后一个转义序列表示&lt;em&gt;代码点255&lt;/em&gt;，在UTF-8中将其编码为两个字节：</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">还推荐布鲁斯&amp;middot;道森（Bruce Dawson）&lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;关于浮点数的博客文章系列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3be1a8ba3f90adcceb5c1de0a45416e04c2e2aa6" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">而且，&lt;em&gt;每个&lt;/em&gt;二进制运算符都支持一个&lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;点版本&lt;/a&gt;，该点版本可以在这种&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;融合的广播操作中&lt;/a&gt;应用于数组（以及数组和标量的组合），例如 &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">而且，&lt;em&gt;每个&lt;/em&gt;二进制运算符都支持一个&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;点版本&lt;/a&gt;，该点版本可以在这种&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;融合的广播操作中&lt;/a&gt;应用于数组（以及数组和标量的组合），例如 &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">另外,参数被溅入的函数不需要是一个varargs函数(尽管它经常是)。</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">open的备用语法，其中使用基于字符串的模式说明符而不是五个布尔值。 &lt;code&gt;mode&lt;/code&gt; 的值与 &lt;code&gt;fopen(3)&lt;/code&gt; 或Perl &lt;code&gt;open&lt;/code&gt; 的值相对应，并且等效于设置以下布尔组：</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">另外， &lt;code&gt;using Module&lt;/code&gt; 会将所有导出的 &lt;code&gt;Module&lt;/code&gt; 函数导入到当前名称空间中。</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">另外,也可以传递一连串的对参数。</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">另外，可以通过调用 &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; 获得更精细的控制和其他转换，其中指定了任意数量的以下布尔关键字选项（除 &lt;code&gt;compose&lt;/code&gt; 外，所有默认均为 &lt;code&gt;false&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="afdfa160e58c5d1c29ca9c36c54e36dba734b5d6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">另外，可以通过调用 &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; 获得更精细的控制和其他转换，其中指定了任意数量的以下布尔关键字选项（除 &lt;code&gt;compose&lt;/code&gt; 外，所有默认值都为 &lt;code&gt;false&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">另外,对于除了一种方法之外的所有方法,你可以坚持元组中至少有一个元素。</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">另外,如果你已经分配了数组,你可以围绕它的数据生成一个薄的包装。</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">或者，在 &lt;code&gt;test/embedding/&lt;/code&gt; 文件夹中的Julia源代码树中查看 &lt;code&gt;embedding.c&lt;/code&gt; 程序。 &lt;code&gt;ui/repl.c&lt;/code&gt; 文件是另一个简单的示例，说明如何在与 &lt;code&gt;libjulia&lt;/code&gt; 链接时设置 &lt;code&gt;jl_options&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0651e957590c9ae374820826fa54266e498875fb" translate="yes" xml:space="preserve">
          <source>Alternatively, one of the four &quot;normal forms&quot; of the Unicode standard can be specified: &lt;code&gt;normalform&lt;/code&gt; can be &lt;code&gt;:NFC&lt;/code&gt;, &lt;code&gt;:NFD&lt;/code&gt;, &lt;code&gt;:NFKC&lt;/code&gt;, or &lt;code&gt;:NFKD&lt;/code&gt;. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</source>
          <target state="translated">或者，可以指定Unicode标准的四种&amp;ldquo;常规形式&amp;rdquo;之一： &lt;code&gt;normalform&lt;/code&gt; 可以是 &lt;code&gt;:NFC&lt;/code&gt; ， &lt;code&gt;:NFD&lt;/code&gt; ， &lt;code&gt;:NFKC&lt;/code&gt; 或 &lt;code&gt;:NFKD&lt;/code&gt; 。规范形式C（规范组成）和D（规范分解）将同一抽象字符串的不同视觉上相同的表示形式转换为单个规范形式，其中形式C更为紧凑。正常形式KC和KD额外规范化了&amp;ldquo;兼容性等效项&amp;rdquo;：它们将抽象相似但视觉上不同的字符转换为单个规范选择（例如，将连字扩展为单个字符），而形式KC更紧凑。</target>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">虽然MATLAB用户可能会发现Julia的语法很熟悉,但Julia并不是MATLAB的克隆。在语法和功能上都有很大的不同。以下是一些值得注意的差异,这些差异可能会让习惯于MATLAB的Julia用户感到困惑。</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">虽然一般来说,从内部构造函数返回一个完全初始化的对象是个好主意,但也有可能返回不完全初始化的对象。</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">虽然这看起来是一个简单的概念,但对值的类型进行多重调度可能是Julia语言最强大、最核心的一个功能。核心操作通常有几十个方法。</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">尽管原则上可以直接定义 &lt;code&gt;promote&lt;/code&gt; 函数的方法，但这将需要为参数类型的所有可能排列提供许多冗余定义。相反，行为 &lt;code&gt;promote&lt;/code&gt; 在称为辅助功能来定义的&lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt;，其中的一个可以为提供方法。所述 &lt;code&gt;promote_rule&lt;/code&gt; 函数采用一对对象的类型，并返回另一种类型的对象，使得所述参数类型的实例将被提升到返回的类型。因此，通过定义规则：</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">尽管有时有人说动态语言是&amp;ldquo;无类型的&amp;rdquo;，但它们绝对不是：每个对象（无论是原始对象还是用户定义的对象）都具有类型。但是，在大多数动态语言中都缺乏类型声明，这意味着人们无法指示编译器有关值的类型，并且通常根本不能明确地谈论类型。另一方面，在静态语言中，虽然可以（通常必须）为编译器注释类型，但类型仅在编译时存在，而不能在运行时进行操作或表示。在Julia中，类型本身就是运行时对象，也可以用于将信息传达给编译器。</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">尽管这看起来很无辜，但问题在于 &lt;code&gt;0&lt;/code&gt; 是整数（ &lt;code&gt;Int&lt;/code&gt; 类型），而 &lt;code&gt;x&lt;/code&gt; 可能是任何类型。因此，根据 &lt;code&gt;x&lt;/code&gt; 的值，此函数可能返回两种类型之一的值。此行为是允许的，并且在某些情况下可能是理想的。但是可以很容易地将其固定如下：</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">总是给出相反的答案，即&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">始终在文档的顶部显示函数的签名,并缩进4个空格,以便打印成Julia代码。</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">合并或联合产品</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">美式足球</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">首先将8字节的标识头写入流中。为了避免编写标头，请构造一个 &lt;code&gt;Serializer&lt;/code&gt; 并将其用作第一个参数进行 &lt;code&gt;serialize&lt;/code&gt; 。另请参见&lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">一个&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;，允许读取并执行追加写入。不支持查找和截断。有关可用的构造函数，请参见&lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;。如果给出了 &lt;code&gt;data&lt;/code&gt; ，则创建一个 &lt;code&gt;PipeBuffer&lt;/code&gt; 来对数据向量进行操作，可以选择指定一个大小，超出该大小则可能无法增长基础 &lt;code&gt;Array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">一个&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;如果所有工人不能请求前终止上升 &lt;code&gt;waitfor&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">给出矩阵 &lt;code&gt;M&lt;/code&gt; 的第 &lt;code&gt;k&lt;/code&gt; 个对角线索引的 &lt;code&gt;AbstractRange&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">一个 &lt;code&gt;ArgumentError&lt;/code&gt; 如果抛出 &lt;code&gt;itr&lt;/code&gt; 包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值。使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数可以省略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非缺失值的分位数。</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">一个 &lt;code&gt;ArgumentError&lt;/code&gt; 如果抛出 &lt;code&gt;v&lt;/code&gt; 包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="273b5060458d33a00226d8a4b324524243edaee5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">一个 &lt;code&gt;ArgumentError&lt;/code&gt; 如果抛出 &lt;code&gt;v&lt;/code&gt; 包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值。使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;功能可省略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非遗漏值的分位数。</target>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">元素类型为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 维&lt;em&gt;跨步&lt;/em&gt;数组。这些数组遵循&lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided数组接口&lt;/a&gt;。如果 &lt;code&gt;A&lt;/code&gt; 是一个 &lt;code&gt;StridedArray&lt;/code&gt; ，则其元素将以偏移量存储在内存中，偏移量在维度之间可能有所不同，但在维度内是恒定的。例如， &lt;code&gt;A&lt;/code&gt; 可能在维度1上具有步幅2，在维度2上具有3步幅。沿维度 &lt;code&gt;d&lt;/code&gt; 递增 &lt;code&gt;A&lt;/code&gt; 会在内存中通过[ &lt;code&gt;strides(A, d)&lt;/code&gt; ]个插槽跳转。交错数组特别重要且有用，因为有时它们可​​以作为指向BLAS等外语库的指针直接传递。</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;NTuple&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; &amp;scaron;用于表示的尺寸&lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">一个&lt;em&gt;环境&lt;/em&gt;决定了 &lt;code&gt;import X&lt;/code&gt; ，并 &lt;code&gt;using X&lt;/code&gt; 被加载意味着各种代码背景和哪些文件，这些语句引起。朱莉娅了解两种环境：</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">HTML渲染器将显示为： &lt;code&gt;Polar{Float64}&lt;/code&gt; 复数：3.0</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">动作签名（例如，提交者，标记者等）。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">一个先进的例子</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">为方便起见，提供了 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 的别名；通过调用 &lt;code&gt;stacktrace&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">一种替代方法是创建数组的&amp;ldquo;视图&amp;rdquo;，这是一个数组对象（ &lt;code&gt;SubArray&lt;/code&gt; ），该对象实际上就地引用原始数组的数据，而不进行复制。（如果您写入视图，它也会修改原始数组的数据。）这可以通过调用&lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt;对单个切片进行，或者通过将&lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt;放在该表达式的前面，对于整个表达式或代码块更简单。例如：</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">使用混合整数或提升为BigInts的另一种方法是使用饱和整数算术，将其添加到最大整数将使它保持不变，并且同样要从最小整数中减去。这正是Matlab&amp;trade;的作用：</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">在数组文字（或理解）上调用宏的另一种方法是在不使用括号的情况下将两者并置。在这种情况下，数组将是馈送给宏的唯一表达式。以下语法是等效的（并且不同于 &lt;code&gt;@name [a b] * v&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">类似的 &quot;类型稳定性 &quot;问题存在于一个函数中重复使用的变量。</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">带注释的git commit带有有关如何查找它以及为什么原因的信息，以便rebase或merge操作具有有关提交上下文的更多信息。例如，冲突文件包含有关合并中的源/目标分支的信息。带注释的提交可以引用远程分支的尖端，例如，当&lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt;传递时，或使用 &lt;code&gt;GitReference&lt;/code&gt; 描述的分支头。</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; 语法编写接受多个参数的匿名函数。零参数匿名函数写为 &lt;code&gt;()-&amp;gt;3&lt;/code&gt; 。没有参数的函数的概念可能看起来很奇怪，但是对于&amp;ldquo;延迟&amp;rdquo;计算很有用。在这种用法中，代码块包装在零参数函数中，该函数随后通过将其调用为 &lt;code&gt;f&lt;/code&gt; 来调用。</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">允许 &lt;code&gt;missing&lt;/code&gt; 值但不包含任何此类值的数组可以使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;转换回不允许缺失值的数组。如果数组包含 &lt;code&gt;missing&lt;/code&gt; 值，则在转换期间会引发 &lt;code&gt;MethodError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1aa345a94617c2935e2b045aa7c4690942cd7adb" translate="yes" xml:space="preserve">
          <source>An array is &quot;strided&quot; if it is stored in memory with well-defined spacings (strides) between its elements. A strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or LAPACK by simply passing its &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt; and the stride for each dimension. The &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A, d)&lt;/code&gt;&lt;/a&gt; is the distance between elements along dimension &lt;code&gt;d&lt;/code&gt;. For example, the builtin &lt;code&gt;Array&lt;/code&gt; returned by &lt;code&gt;rand(5,7,2)&lt;/code&gt; has its elements arranged contiguously in column major order. This means that the stride of the first dimension &amp;mdash; the spacing between elements in the same column &amp;mdash; is &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">如果数组以其元素之间明确定义的间距（步幅）存储在内存中，则将被&amp;ldquo;条纹化&amp;rdquo;。可以通过简单地传递每个维度的&lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt;和步幅，将具有受支持元素类型的跨步数组传递给外部（非Julia）库，例如BLAS或LAPACK 。的&lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A, d)&lt;/code&gt; &lt;/a&gt;是沿着维度元件之间的距离 &lt;code&gt;d&lt;/code&gt; 。例如， &lt;code&gt;rand(5,7,2)&lt;/code&gt; 返回的内置 &lt;code&gt;Array&lt;/code&gt; 的元素按列主要顺序连续排列。这意味着第一维的跨度（同一列中元素之间的间距）为 &lt;code&gt;1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组是存储在多维网格中的对象的集合。在最一般的情况下，数组可以包含&lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt;类型的对象。对于大多数计算而言，数组应包含更特定类型的对象，例如&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ca0d5271db66618f81cc70b668cef389e0b4f2d" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">加载代码时， &lt;code&gt;using&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 语句将其视为项目环境或程序包目录的路径数组。如果已设置，则根据&lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt;环境变量进行填充；否则默认为 &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; 。以 &lt;code&gt;@&lt;/code&gt; 开头的条目具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">加载代码时， &lt;code&gt;using&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 语句视为项目环境或程序包目录的路径数组。如果已设置，则根据&lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt;环境变量进行填充；否则默认为 &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; 。以 &lt;code&gt;@&lt;/code&gt; 开头的条目具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">一个标量指数的数组。这包括:</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">传递给Julia的命令行参数数组,为字符串。</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">可以使用语法 &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; 构造具有特定元素类型的数组。这将构造一个元素类型为 &lt;code&gt;T&lt;/code&gt; 的1-d数组，初始化为包含元素 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 等。例如， &lt;code&gt;Any[x, y, z]&lt;/code&gt; 构造一个可以包含任何值的异构数组。</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">assert可能在不同的优化级别上被禁用。因此,断言只能作为调试工具,而不能用于认证验证(如验证密码),也不能在断言中使用函数正确工作所需的副作用。</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">在函数、类型或宏定义中引入一个变量的赋值不需要在其内部使用之前。</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">一个简单的方法是将身体提取到另一个(常规)功能。</target>
        </trans-unit>
        <trans-unit id="1b60a8e096bfa335613b61303e86087f18cd47ed" translate="yes" xml:space="preserve">
          <source>An entirely independent approach to profile visualization is &lt;a href=&quot;https://github.com/vchuravy/PProf.jl&quot;&gt;PProf.jl&lt;/a&gt;, which uses the external &lt;code&gt;pprof&lt;/code&gt; tool.</source>
          <target state="translated">完全独立的配置文件可视化方法是&lt;a href=&quot;https://github.com/vchuravy/PProf.jl&quot;&gt;PProf.jl&lt;/a&gt;，它使用外部 &lt;code&gt;pprof&lt;/code&gt; 工具。</target>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">环境的图是一个多级映射，它为每个 &lt;code&gt;context&lt;/code&gt; UUID 分配一个从名称到UUID的映射，类似于根映射，但特定于该 &lt;code&gt;context&lt;/code&gt; 。当Julia 在以UUID为 &lt;code&gt;context&lt;/code&gt; 的程序包的代码中看到 &lt;code&gt;import X&lt;/code&gt; 时，它将 &lt;code&gt;X&lt;/code&gt; 的身份视为 &lt;code&gt;graph[context][:X]&lt;/code&gt; 。特别是，这意味着 &lt;code&gt;import X&lt;/code&gt; 可以根据 &lt;code&gt;context&lt;/code&gt; 引用不同的包。</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">环境的根映射将包名称分配给该环境可用于主项目的所有顶级依赖项（即可以在 &lt;code&gt;Main&lt;/code&gt; 中加载的那些依赖项）的UUID 。当Julia 在主项目中遇到 &lt;code&gt;import X&lt;/code&gt; 时，它将查找 &lt;code&gt;X&lt;/code&gt; 的身份为 &lt;code&gt;roots[:X]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">运行模块的 &lt;code&gt;__init__&lt;/code&gt; 函数时发生错误。引发的实际错误在 &lt;code&gt;.error&lt;/code&gt; 字段中可用。</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">尝试访问无效索引 &lt;code&gt;i&lt;/code&gt; 的 &lt;code&gt;str&lt;/code&gt; 时发生错误。</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;文件时发生错误。错误的详细信息应在 &lt;code&gt;.error&lt;/code&gt; 字段中可用。</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">正确使用 &lt;code&gt;Val&lt;/code&gt; 的示例如下：</target>
        </trans-unit>
        <trans-unit id="25c5e7a2c4027183bf26e4e9c2615052f9de37e7" translate="yes" xml:space="preserve">
          <source>An example of overflow behavior and how to potentially resolve it is as follows:</source>
          <target state="translated">一个溢出行为的例子以及如何潜在地解决它的问题如下。</target>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">如果要求清除全局常量,则会引发异常。</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">一个明确的 &lt;code&gt;global&lt;/code&gt; 需要分配给一个全局变量：</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">以这种方式包装的表达式,宏扩展器不会管它,只需逐字粘贴到输出中即可。因此,它将在宏调用环境中被解析。</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">一个不可更改的对象可能包含可更改的对象,如数组,作为字段。这些包含的对象将保持可变,只有不可变对象本身的字段不能改变,以指向不同的对象。</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">&lt;code&gt;AbstractWorkerPool&lt;/code&gt; 的实现。&lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;（以及其他远程执行功能的远程调用）受益于在工作程序节点（尤其是闭包（可能捕获大量数据））上缓存序列化/反序列化的函数。</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">分布式内存并行计算的实现是由模块 &lt;code&gt;Distributed&lt;/code&gt; 提供的，该模块是Julia附带的标准库的一部分。</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Julia的类型系统的一个重要且强大的功能是参数化的：类型可以带参数，因此类型声明实际上引入了一整套新类型-每个可能的参数值组合都一个。有许多语言支持某种版本的&lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;通用编程&lt;/a&gt;，其中可以指定数据结构和操作它们的算法，而无需指定所涉及的确切类型。例如，仅举几例，ML，Haskell，Ada，Eiffel，C ++，Java，C＃，F＃和Scala中存在某种形式的通用编程。这些语言中的某些语言支持真正的参数多态性（例如ML，Haskell，Scala），而其他语言则支持特殊的，基于模板的通用编程样式（例如C ++，Java）。在具有多种语言的泛型编程和参数类型如此之多的情况下，我们甚至不会尝试将Julia的参数类型与其他语言进行比较，而是着重于自己解释Julia的系统。不过，我们会注意到，由于Julia是一种动态类型的语言，不需要在编译时做出所有类型的决定，静态参数类型系统中遇到的许多传统困难可以相对轻松地解决。</target>
        </trans-unit>
        <trans-unit id="cbe22d7af0ef7feda8cfd84ded555dd181a687db" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-abstract-container&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">需要注意的重要一点是，如果程序员依赖于其参数为抽象类型的函数，则不会降低性能，因为对于调用它的参数具体类型的每个元组，该函数都会重新编译。（但是，在函数参数是抽象类型的容器的情况下，可能会出现性能问题；请参阅&lt;a href=&quot;../performance-tips/index#man-performance-abstract-container&quot;&gt;性能提示&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">需要注意的重要一点是，如果程序员依赖于其参数为抽象类型的函数，则不会降低性能，因为对于调用它的参数具体类型的每个元组，该函数都会重新编译。（但是，在函数参数是抽象类型的容器的情况下，可能会出现性能问题；请参阅&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a9c84445e53230deb0eebf338b52d84f7d83ccf2" translate="yes" xml:space="preserve">
          <source>An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.</source>
          <target state="translated">这种设计的一个重要属性是,任何在文件中执行的代码,如果没有警告,在新的REPL中也会有同样的行为。而反过来说,如果你把一个 REPL 会话保存到文件中,如果它的行为与在 REPL 中的行为不同,那么你会得到一个警告。</target>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">要记住的重要一点是，一旦获取，&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;将在本地缓存其值。进一步的 &lt;code&gt;fetch&lt;/code&gt; 调用不需要网络跳。获取所有引用的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; 后&lt;/a&gt;，将删除远程存储的值。</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">抽象类型的一个重要用途是为具体类型提供默认实现。举个简单的例子,考虑一下。</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">索引到 &lt;code&gt;AbstractDict&lt;/code&gt; （ &lt;code&gt;Dict&lt;/code&gt; ）或 &lt;code&gt;Set&lt;/code&gt; 类似对象的索引操作试图访问或删除不存在的元素。</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">数组 &lt;code&gt;a&lt;/code&gt; 的索引操作尝试访问索引 &lt;code&gt;i&lt;/code&gt; 处的越界元素。</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; 的实例可以紧凑而有效地表示为64位值的直接对。</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Point{Real}&lt;/code&gt; 的实例必须能够容纳&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; 的&lt;/a&gt;任意一对实例。由于作为 &lt;code&gt;Real&lt;/code&gt; 实例的对象可以具有任意大小和结构，因此在实践中， &lt;code&gt;Point{Real}&lt;/code&gt; 的实例必须表示为指向单独分配的 &lt;code&gt;Real&lt;/code&gt; 对象的一对指针。</target>
        </trans-unit>
        <trans-unit id="12aa0088bc6a62b5d720f6445639bc7feea0dfd4" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">在更复杂的宏中出现的一个问题是&lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;卫生问题&lt;/a&gt;。简而言之，宏必须确保它们在返回的表达式中引入的变量不会意外地与它们扩展到的周围代码中的现有变量发生冲突。相反，通常&lt;em&gt;期望将&lt;/em&gt;作为参数传递到宏中的表达式&lt;em&gt;&lt;/em&gt;在周围代码的上下文中进行评估，与现有变量进行交互并对其进行修改。另一个担忧来自以下事实：可以在与定义宏的模块不同的模块中调用宏。在这种情况下，我们需要确保将所有全局变量解析为正确的模块。与使用文本宏扩展（例如C）的语言相比，Julia已经具有一个主要优势，因为它只需要考虑返回的表达式即可。所有其他变量（如 &lt;code&gt;msg&lt;/code&gt; 在 &lt;code&gt;@assert&lt;/code&gt; 上文）遵循&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;正常范围界定块行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">在更复杂的宏中出现的一个问题是&lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;卫生问题&lt;/a&gt;。简而言之，宏必须确保它们在返回的表达式中引入的变量不会意外地与它们扩展到的周围代码中的现有变量冲突。相反，通常&lt;em&gt;期望将&lt;/em&gt;作为参数传递给宏的表达式&lt;em&gt;&lt;/em&gt;在周围代码的上下文中进行评估，与现有变量进行交互并对其进行修改。另一个担忧来自以下事实：可以在与定义宏不同的模块中调用宏。在这种情况下，我们需要确保将所有全局变量解析为正确的模块。与使用文本宏扩展（例如C）的语言相比，Julia已经具有主要优势，因为它只需要考虑返回的表达式。所有其他变量（如 &lt;code&gt;msg&lt;/code&gt; 在 &lt;code&gt;@assert&lt;/code&gt; 上文）遵循&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;正常范围界定块行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">一个访问数组 &lt;code&gt;A&lt;/code&gt; 的每个元素并返回 &lt;code&gt;i =&amp;gt; x&lt;/code&gt; 的迭代器，其中 &lt;code&gt;i&lt;/code&gt; 是元素的索引， &lt;code&gt;x = A[i]&lt;/code&gt; 。与 &lt;code&gt;pairs(A)&lt;/code&gt; 相同，除了可以选择索引的样式。也类似于 &lt;code&gt;enumerate(A)&lt;/code&gt; ，除了 &lt;code&gt;i&lt;/code&gt; 将是 &lt;code&gt;A&lt;/code&gt; 的有效索引，而 &lt;code&gt;enumerate&lt;/code&gt; 始终从1开始计数，而不管 &lt;code&gt;A&lt;/code&gt; 的索引如何。</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">迭代器，计数永远，开始 &lt;code&gt;start&lt;/code&gt; ，并通过增加 &lt;code&gt;step&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">迭代器，通过循环 &lt;code&gt;iter&lt;/code&gt; 永远。如果 &lt;code&gt;iter&lt;/code&gt; 为空，那么 &lt;code&gt;cycle(iter)&lt;/code&gt; 也是。</target>
        </trans-unit>
        <trans-unit id="99ec5bfacc5e607a59f3f0e21acc0539e9b04968" translate="yes" xml:space="preserve">
          <source>An iterator that drops element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, returns every element.</source>
          <target state="translated">只要谓词 &lt;code&gt;pred&lt;/code&gt; 为true，迭代器就会从 &lt;code&gt;iter&lt;/code&gt; 中删除元素，然后返回每个元素。</target>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，它生成 &lt;code&gt;iter&lt;/code&gt; 的除前 &lt;code&gt;n&lt;/code&gt; 个元素外的所有元素。</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">一个迭代器，最多生成 &lt;code&gt;iter&lt;/code&gt; 的前 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="d764aa048a3e74537873dd366c614add03dee409" translate="yes" xml:space="preserve">
          <source>An iterator that generates element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, drops every element.</source>
          <target state="translated">只要谓词 &lt;code&gt;pred&lt;/code&gt; 为true，迭代器就会从 &lt;code&gt;iter&lt;/code&gt; 生成元素，然后删除每个元素。</target>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">一个永远生成值 &lt;code&gt;x&lt;/code&gt; 的迭代器。如果指定了 &lt;code&gt;n&lt;/code&gt; ，则生成 &lt;code&gt;x&lt;/code&gt; 次（等效于 &lt;code&gt;take(repeated(x), n)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">产生 &lt;code&gt;(i, x)&lt;/code&gt; 的迭代器，其中 &lt;code&gt;i&lt;/code&gt; 是从1开始的计数器， &lt;code&gt;x&lt;/code&gt; 是给定迭代器的第 &lt;code&gt;i&lt;/code&gt; 个值。当您不仅需要迭代的值 &lt;code&gt;x&lt;/code&gt; ，而且还需要到目前为止的迭代次数时，这很有用。请注意， &lt;code&gt;i&lt;/code&gt; 可能无法为 &lt;code&gt;iter&lt;/code&gt; 编制索引；如果 &lt;code&gt;iter&lt;/code&gt; 的索引不是以1开始，则 &lt;code&gt;x != iter[i]&lt;/code&gt; 也很有可能。如果要确保 &lt;code&gt;i&lt;/code&gt; 是索引 &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; 请参见Pairs（IndexLinear（），iter）方法。</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">产生与 &lt;code&gt;iter&lt;/code&gt; 相同的元素，但从给定 &lt;code&gt;state&lt;/code&gt; 开始的迭代器。</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">类型&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt;的对象，表示任何大小的单位矩阵。</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">一个表示标量索引数组的对象，可以通过&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; 将该&lt;/a&gt;对象转换为标量索引。默认情况下，这包括：</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">安全引用类型 &lt;code&gt;T&lt;/code&gt; 的数据的对象。保证该类型指向正确的类型的有效的，Julia分配的内存。只要引用了 &lt;code&gt;Ref&lt;/code&gt; 本身，就可以保护基础数据免受垃圾回收器的释放。</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">一个具有不可变类型的对象可以被编译器自由复制,因为它的不可变性使得它无法在程序上区分原始对象和副本。</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">一个操作分配了太多的内存,使系统或垃圾收集器无法正确处理。</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">试图向只读存储器写入的操作。</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">矩阵-矩阵运算的优化方法可供使用。</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">矩阵-标量运算的优化方法可供使用。</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">矩阵-向量运算的优化方法可供选择</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">有一种优化的方法可以找到所有的特征值和/或向量。</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">有找到第 &lt;code&gt;il&lt;/code&gt; 个至第 &lt;code&gt;ih&lt;/code&gt; 个特征值的优化方法</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">提供了一种在区间[ &lt;code&gt;vl&lt;/code&gt; ， &lt;code&gt;vh&lt;/code&gt; ]中找到特征值的优化方法</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">一个优化的方法，以找到对应于所述特征值的特征矢量 &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; 是可用</target>
        </trans-unit>
        <trans-unit id="f744563fd636d437613d62cd83f1a88cf9af7cbd" translate="yes" xml:space="preserve">
          <source>An optimized sampler with pre-computed data</source>
          <target state="translated">带有预计算数据的优化采样器。</target>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">有序列表可以从1以外的数字开始,如上例中的第二个列表,它从5开始编号。与无序列表一样,有序列表可以包含嵌套的toplevel元素。</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">一个无符号的64位整数（ &lt;code&gt;uint64_t&lt;/code&gt; ），用于设置Julia可用的最大线程数。如果 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 超过可用的物理CPU内核数，则将线程数设置为内核数。如果 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 不是正数或未设置，或者如果无法通过系统调用确定CPU内核数，则将线程数设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
