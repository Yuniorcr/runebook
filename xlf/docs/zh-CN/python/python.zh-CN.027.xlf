<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="102dc7d3bf538e66387889d7daeeb05e53a870a4" translate="yes" xml:space="preserve">
          <source>Utilities to compile all Python source files in a directory tree.</source>
          <target state="translated">用于编译目录树中所有Python源文件的实用程序。</target>
        </trans-unit>
        <trans-unit id="894c08b4d341d3181d652622edf583cdb792b50d" translate="yes" xml:space="preserve">
          <source>Utilities to help work with fonts.</source>
          <target state="translated">帮助使用字体的实用工具。</target>
        </trans-unit>
        <trans-unit id="9b5439bb171dd02403cd4a0162c5e608f757fe9b" translate="yes" xml:space="preserve">
          <source>Utilities to run asyncio programs, create Tasks, and await on multiple things with timeouts.</source>
          <target state="translated">用来运行asyncio程序,创建Tasks,以及在多个事情上等待超时的实用工具。</target>
        </trans-unit>
        <trans-unit id="4fafea3320bd24aef44e569f108bcf7bb663fa8f" translate="yes" xml:space="preserve">
          <source>Utilities to spawn subprocesses and run shell commands.</source>
          <target state="translated">用于生成子进程和运行shell命令的实用程序。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="6e7be9dc79ed50d8c704d7f221a2758927ee65a3" translate="yes" xml:space="preserve">
          <source>Uuencode file &lt;em&gt;in_file&lt;/em&gt; into file &lt;em&gt;out_file&lt;/em&gt;. The uuencoded file will have the header specifying &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; as the defaults for the results of decoding the file. The default defaults are taken from &lt;em&gt;in_file&lt;/em&gt;, or &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;0o666&lt;/code&gt; respectively. If &lt;em&gt;backtick&lt;/em&gt; is true, zeros are represented by &lt;code&gt;'`'&lt;/code&gt; instead of spaces.</source>
          <target state="translated">将文件&lt;em&gt;in_file&lt;/em&gt;编码为文件&lt;em&gt;out_file&lt;/em&gt;。uuencoded文件将具有标头，该标头将&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;模式&lt;/em&gt;指定为解码文件结果的默认值。默认默认值分别来自&lt;em&gt;in_file&lt;/em&gt;或 &lt;code&gt;'-'&lt;/code&gt; 和 &lt;code&gt;0o666&lt;/code&gt; 。如果&lt;em&gt;backtick&lt;/em&gt;为true，则零用 &lt;code&gt;'`'&lt;/code&gt; 代替空格。</target>
        </trans-unit>
        <trans-unit id="51920a4103a076cddaea8c5320e3e3d41f0fe359" translate="yes" xml:space="preserve">
          <source>VRFY</source>
          <target state="translated">VRFY</target>
        </trans-unit>
        <trans-unit id="6ef9fae42b29329a1ed8c77701fe1700d757002f" translate="yes" xml:space="preserve">
          <source>Valid String Arg</source>
          <target state="translated">有效字符串Arg</target>
        </trans-unit>
        <trans-unit id="ae9f1d564485db39fcd34520a7886185a9f3d9bb" translate="yes" xml:space="preserve">
          <source>Valid enum Arg</source>
          <target state="translated">有效 enum Arg</target>
        </trans-unit>
        <trans-unit id="d11dea5084c554faaf9051f680e8d26ff170b6ad" translate="yes" xml:space="preserve">
          <source>Valid values are &lt;code&gt;7bit&lt;/code&gt;, &lt;code&gt;8bit&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, and &lt;code&gt;quoted-printable&lt;/code&gt;. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">有效值为 &lt;code&gt;7bit&lt;/code&gt; ， &lt;code&gt;8bit&lt;/code&gt; ， &lt;code&gt;base64&lt;/code&gt; 和 &lt;code&gt;quoted-printable&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ed34a07f3d8b83630e9e822f76c6734a7177025" translate="yes" xml:space="preserve">
          <source>Validating Parsers must use this method to report each chunk of ignorable whitespace (see the W3C XML 1.0 recommendation, section 2.10): non-validating parsers may also use this method if they are capable of parsing and using content models.</source>
          <target state="translated">验证性解析器必须使用此方法来报告每块可忽略的空白(参见W3C XML 1.0建议,2.10节):非验证性解析器如果能够解析和使用内容模型,也可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="0701d51e2238471096af133360d47b98e784ca3c" translate="yes" xml:space="preserve">
          <source>Value Types</source>
          <target state="translated">价值类型</target>
        </trans-unit>
        <trans-unit id="2ee2c05664be5bc3b7425a3cd5c2eaeb9af87ebe" translate="yes" xml:space="preserve">
          <source>Value if not present</source>
          <target state="translated">价值,如果不存在</target>
        </trans-unit>
        <trans-unit id="7dd7eb81edd524ab9b2cc8166a90a72809941195" translate="yes" xml:space="preserve">
          <source>Value lengths are limited by available memory. Long values (more than 2048 bytes) should be stored as files with the filenames stored in the configuration registry. This helps the registry perform efficiently.</source>
          <target state="translated">值的长度受可用内存的限制。长值(超过2048字节)应以文件形式存储,文件名存储在配置注册表中。这有助于注册表有效地执行。</target>
        </trans-unit>
        <trans-unit id="ff4442e3ee6e85b03ce0d04c09a9f9afc7926b83" translate="yes" xml:space="preserve">
          <source>Value may be supplied as either a keyword or positional argument (this is the standard binding behaviour for functions implemented in Python.)</source>
          <target state="translated">值可以作为关键字或位置参数提供 (这是 Python 中实现的函数的标准绑定行为)。</target>
        </trans-unit>
        <trans-unit id="e606eb6146ca90bd2780303c47db18287309d201" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a keyword argument. Keyword only parameters are those which appear after a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;*args&lt;/code&gt; entry in a Python function definition.</source>
          <target state="translated">值必须作为关键字参数提供。仅关键字参数是在Python函数定义中的 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;*args&lt;/code&gt; 条目之后出现的参数。</target>
        </trans-unit>
        <trans-unit id="f281af900c7055431a7ba9336e9f5b33972ace2e" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a positional argument. Positional only parameters are those which appear before a &lt;code&gt;/&lt;/code&gt; entry (if present) in a Python function definition.</source>
          <target state="translated">必须将值作为位置参数提供。仅位置参数是在Python函数定义中 &lt;code&gt;/&lt;/code&gt; 条目（如果存在）之前出现的参数。</target>
        </trans-unit>
        <trans-unit id="86d356e451eb275892ab84a0a8cabfd82d894744" translate="yes" xml:space="preserve">
          <source>Value of function key &lt;em&gt;n&lt;/em&gt;</source>
          <target state="translated">功能键&lt;em&gt;n的&lt;/em&gt;值&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58abe8dc89cf79184a2726248be2244df3ce518b" translate="yes" xml:space="preserve">
          <source>Value too large for defined data type</source>
          <target state="translated">对于定义的数据类型来说,数值太大</target>
        </trans-unit>
        <trans-unit id="0f22edd532486ea6c69bc19fb1bb15eb52cfdba0" translate="yes" xml:space="preserve">
          <source>Value used to identify the event. The interpretation depends on the filter but it&amp;rsquo;s usually the file descriptor. In the constructor ident can either be an int or an object with a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method. kevent stores the integer internally.</source>
          <target state="translated">用于标识事件的值。解释取决于过滤器，但通常是文件描述符。在构造函数中，ident可以是int或具有&lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt;方法的对象。kevent在内部存储整数。</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4ffc08181d2110828c38d18c73ceb4f5562de955" translate="yes" xml:space="preserve">
          <source>Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;#plistlib.Data&quot;&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;bytesarray&lt;/code&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">值可以是字符串，整数，浮点数，布尔值，元组，列表，字典（但仅具有字符串键），&lt;a href=&quot;#plistlib.Data&quot;&gt; &lt;code&gt;Data&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;bytesarray&lt;/code&gt; 或&lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b6acf79ae6557a4f6cef52f8868d47e669eb915d" translate="yes" xml:space="preserve">
          <source>Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">值可以是字符串，整数，浮点数，布尔值，元组，列表，字典（但仅具有字符串键），&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d4af2aaf629c09c7b586c6140040cd042f1b5dae" translate="yes" xml:space="preserve">
          <source>Values from other sections can be fetched as well:</source>
          <target state="translated">也可以从其他部分取值。</target>
        </trans-unit>
        <trans-unit id="e7c8e3c3012e41d09c6656db5fddb8ed8d0ecd84" translate="yes" xml:space="preserve">
          <source>Values in the registry have name, type, and data components. This method retrieves the data for a key&amp;rsquo;s first value that has a &lt;code&gt;NULL&lt;/code&gt; name. But the underlying API call doesn&amp;rsquo;t return the type, so always use &lt;a href=&quot;#winreg.QueryValueEx&quot;&gt;&lt;code&gt;QueryValueEx()&lt;/code&gt;&lt;/a&gt; if possible.</source>
          <target state="translated">注册表中的值具有名称，类型和数据组件。此方法检索名称为 &lt;code&gt;NULL&lt;/code&gt; 的键的第一个值的数据。但是底层的API调用不会返回该类型，因此请尽可能使用&lt;a href=&quot;#winreg.QueryValueEx&quot;&gt; &lt;code&gt;QueryValueEx()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c44a2d0d8fe41ed1dbff4d435d6b3be6cd0c3f" translate="yes" xml:space="preserve">
          <source>Values of &lt;em&gt;n&lt;/em&gt; less than &lt;code&gt;0&lt;/code&gt; are treated as &lt;code&gt;0&lt;/code&gt; (which yields an empty sequence of the same type as &lt;em&gt;s&lt;/em&gt;). Note that items in the sequence &lt;em&gt;s&lt;/em&gt; are not copied; they are referenced multiple times. This often haunts new Python programmers; consider:</source>
          <target state="translated">小于 &lt;code&gt;0&lt;/code&gt; 的&lt;em&gt;n&lt;/em&gt;值将被视为 &lt;code&gt;0&lt;/code&gt; （产生与&lt;em&gt;s&lt;/em&gt;类型相同的空序列）。请注意，序列&lt;em&gt;s&lt;/em&gt;中的项目不会被复制；它们被多次引用。这常常困扰着新的Python程序员。考虑：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99882406ebedbb37513cb23cc3017de1859ae178" translate="yes" xml:space="preserve">
          <source>Values that cannot be determined are returned as given by the parameter presets. If bits is given as &lt;code&gt;''&lt;/code&gt;, the &lt;code&gt;sizeof(pointer)&lt;/code&gt; (or &lt;code&gt;sizeof(long)&lt;/code&gt; on Python version &amp;lt; 1.5.2) is used as indicator for the supported pointer size.</source>
          <target state="translated">如参数预设所给定，将返回无法确定的值。如果将位指定为 &lt;code&gt;''&lt;/code&gt; ，则将 &lt;code&gt;sizeof(pointer)&lt;/code&gt; （或在Python版本&amp;lt;1.5.2上为 &lt;code&gt;sizeof(long)&lt;/code&gt; ）用作支持的指针大小的指示符。</target>
        </trans-unit>
        <trans-unit id="b7fc44b31c7c9574a8212b50dbd39bc45209ed3f" translate="yes" xml:space="preserve">
          <source>Values to pass as the &lt;em&gt;mode&lt;/em&gt; parameter of &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; to test the existence, readability, writability and executability of &lt;em&gt;path&lt;/em&gt;, respectively.</source>
          <target state="translated">作为&lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;mode&lt;/em&gt;参数传递的值分别测试&lt;em&gt;path&lt;/em&gt;的存在，可读性，可写性和可执行性。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9675228400dbafe37ef560b13bae74e47caa9aac" translate="yes" xml:space="preserve">
          <source>Variable references can be used to load the value of a variable, to assign a new value to it, or to delete it. Variable references are given a context to distinguish these cases.</source>
          <target state="translated">变量引用可以用来加载一个变量的值,给它分配一个新的值,或者删除它。变量引用有一个上下文,以区分这些情况。</target>
        </trans-unit>
        <trans-unit id="505c78fab28aa9b0b70f7dcbd71feb993b8ff277" translate="yes" xml:space="preserve">
          <source>Variable that specifies the user agent of the opener object. To get &lt;a href=&quot;urllib#module-urllib&quot;&gt;&lt;code&gt;urllib&lt;/code&gt;&lt;/a&gt; to tell servers that it is a particular user agent, set this in a subclass as a class variable or in the constructor before calling the base constructor.</source>
          <target state="translated">指定打开器对象的用户代理的变量。要使&lt;a href=&quot;urllib#module-urllib&quot;&gt; &lt;code&gt;urllib&lt;/code&gt; &lt;/a&gt;告诉服务器它是特定的用户代理，请在调用基本构造函数之前，在子类中将其设置为类变量或在构造函数中进行设置。</target>
        </trans-unit>
        <trans-unit id="acc4399a5b517cf7222cd58ad2c32cfd48aac016" translate="yes" xml:space="preserve">
          <source>Variable-sized data types</source>
          <target state="translated">可变大小的数据类型</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="25482e67402e6c3f5fe20df41e9dcae2a9ba2841" translate="yes" xml:space="preserve">
          <source>Various structures for implementing schedulers have been extensively studied, and heaps are good for this, as they are reasonably speedy, the speed is almost constant, and the worst case is not much different than the average case. However, there are other representations which are more efficient overall, yet the worst cases might be terrible.</source>
          <target state="translated">各种实现调度器的结构已经被广泛研究,堆是很好的选择,因为堆的速度相当快,速度几乎是恒定的,最坏的情况与平均情况相差不大。然而,还有其他的表示方式,总体上效率更高,然而最坏的情况可能是可怕的。</target>
        </trans-unit>
        <trans-unit id="c01dc65ed82215cf4434e1aca2d7412f6c775240" translate="yes" xml:space="preserve">
          <source>Vector example:</source>
          <target state="translated">矢量的例子。</target>
        </trans-unit>
        <trans-unit id="965ef7e332ac200f4b5e70778db19b375745f0da" translate="yes" xml:space="preserve">
          <source>Verbose output</source>
          <target state="translated">啰嗦的输出</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">啰嗦的输出。</target>
        </trans-unit>
        <trans-unit id="c3b257b1e9f0266480a6612a0d51d64c417b942e" translate="yes" xml:space="preserve">
          <source>Verify that &lt;em&gt;cert&lt;/em&gt; (in decoded format as returned by &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;) matches the given &lt;em&gt;hostname&lt;/em&gt;. The rules applied are those for checking the identity of HTTPS servers as outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125&lt;/strong&gt;&lt;/a&gt;. In addition to HTTPS, this function should be suitable for checking the identity of servers in various SSL-based protocols such as FTPS, IMAPS, POPS and others.</source>
          <target state="translated">验证&lt;em&gt;证书&lt;/em&gt;（由&lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt;返回的解码格式）与给定的&lt;em&gt;主机名&lt;/em&gt;匹配。所应用的规则是用于检查&lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125中&lt;/strong&gt;&lt;/a&gt;概述的HTTPS服务器身份的规则。除HTTPS之外，此功能还应适用于检查各种基于SSL的协议（例如FTPS，IMAPS，POPS等）中服务器的身份。</target>
        </trans-unit>
        <trans-unit id="53ba4e70726a4a91e073b0dd557344bd475a0a8b" translate="yes" xml:space="preserve">
          <source>Verifying certificates</source>
          <target state="translated">核查证书</target>
        </trans-unit>
        <trans-unit id="63f133e763468a73947f4629707ecc9c9d90bb76" translate="yes" xml:space="preserve">
          <source>Version interface for Jython.</source>
          <target state="translated">Jython的版本接口。</target>
        </trans-unit>
        <trans-unit id="19e3aaed4d8f8b4a00e21a218ae1c005508d0951" translate="yes" xml:space="preserve">
          <source>Vertical highlight</source>
          <target state="translated">纵向高亮</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">垂直标签</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="c72e003330b099c436ab550f7c7a659390de0b50" translate="yes" xml:space="preserve">
          <source>View Last Restart</source>
          <target state="translated">查看最后一次重启</target>
        </trans-unit>
        <trans-unit id="f633d1002c0f5f6ce6be33d7377af0ab89993bbb" translate="yes" xml:space="preserve">
          <source>View Objects</source>
          <target state="translated">查看对象</target>
        </trans-unit>
        <trans-unit id="8674ea8214e1ae57f3e50b4fb7b3ef79a1d1476a" translate="yes" xml:space="preserve">
          <source>Vincent Bernat.</source>
          <target state="translated">Vincent Bernat.</target>
        </trans-unit>
        <trans-unit id="82cb0e10bd78d0153cd1698ceb6ca31fb1f0f1e3" translate="yes" xml:space="preserve">
          <source>Virtual Events</source>
          <target state="translated">虚拟活动</target>
        </trans-unit>
        <trans-unit id="17939436623483b052de1e4d3f9d6c11ccdc98ad" translate="yes" xml:space="preserve">
          <source>Virtual events</source>
          <target state="translated">虚拟活动</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="5a2efe7f1abb84c38f1725a2ecc3c4e87349a479" translate="yes" xml:space="preserve">
          <source>Visit a node. The default implementation calls the method called &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; where &lt;em&gt;classname&lt;/em&gt; is the name of the node class, or &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt;&lt;code&gt;generic_visit()&lt;/code&gt;&lt;/a&gt; if that method doesn&amp;rsquo;t exist.</source>
          <target state="translated">访问节点。默认实现调用名为 &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; 的方法，其中&lt;em&gt;classname&lt;/em&gt;是节点类的名称；如果该方法不存在，则调用&lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt; &lt;code&gt;generic_visit()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3c755d8a06e5cd333fac0016835f914045f69e" translate="yes" xml:space="preserve">
          <source>Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host &lt;code&gt;www.python.org&lt;/code&gt;):</source>
          <target state="translated">外观检查表明证书确实标识了所需的服务（即HTTPS主机 &lt;code&gt;www.python.org&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5eee88bfaa26b0b2250c40217a4675afbea5cd23" translate="yes" xml:space="preserve">
          <source>Volume number of file header.</source>
          <target state="translated">文件头的卷号。</target>
        </trans-unit>
        <trans-unit id="c328c0ed13eb319fbdea95de7337047e0b069c45" translate="yes" xml:space="preserve">
          <source>Voluntarily relinquish the CPU.</source>
          <target state="translated">自愿放弃CPU。</target>
        </trans-unit>
        <trans-unit id="30e1c76ac6526fc5debd6d9e1463cc9f2e2c997b" translate="yes" xml:space="preserve">
          <source>VxWorks only supports setting &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt;&lt;code&gt;RLIMIT_NOFILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">VxWorks仅支持设置&lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt; &lt;code&gt;RLIMIT_NOFILE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3645a420f6c8c0399ea11997839dc3fbde6f0ad" translate="yes" xml:space="preserve">
          <source>Wait for child process to terminate. Set and return &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">等待子进程终止。设置并返回&lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="ee4b0606dd5fd109342b9b5b4880dd14615482ba" translate="yes" xml:space="preserve">
          <source>Wait for completion of a child process, and return a tuple containing its pid and exit status indication: a 16-bit number, whose low byte is the signal number that killed the process, and whose high byte is the exit status (if the signal number is zero); the high bit of the low byte is set if a core file was produced.</source>
          <target state="translated">等待一个子进程的完成,并返回一个包含其pid和退出状态指示的元组:一个16位的数字,其低字节是杀死该进程的信号号,高字节是退出状态(如果信号号为零);如果产生了核心文件,则设置低字节的高位。</target>
        </trans-unit>
        <trans-unit id="6cf3a1c5971c4c21eec5eb16a888eb935b06df3a" translate="yes" xml:space="preserve">
          <source>Wait for events. timeout in seconds (float)</source>
          <target state="translated">等待事件发生,超时秒数(浮动)。</target>
        </trans-unit>
        <trans-unit id="cabdac1beb596d1e8239e59912c30fa91617e2d4" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; instances (possibly created by different &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; instances) given by &lt;em&gt;fs&lt;/em&gt; to complete. Returns a named 2-tuple of sets. The first set, named &lt;code&gt;done&lt;/code&gt;, contains the futures that completed (finished or cancelled futures) before the wait completed. The second set, named &lt;code&gt;not_done&lt;/code&gt;, contains the futures that did not complete (pending or running futures).</source>
          <target state="translated">等待&lt;em&gt;fs&lt;/em&gt;给定的&lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;实例（可能由不同的&lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt;实例创建）完成。返回一组命名的2元组。第一组名为 &lt;code&gt;done&lt;/code&gt; ，包含在等待完成之前已完成的期货（已完成或已取消的期货）。第二组名为 &lt;code&gt;not_done&lt;/code&gt; ，包含未完成的期货（待定或正在运行的期货）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29151336d8a123354d0b207654c1c2fac16dbab5" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;em&gt;aw&lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt; to complete with a timeout.</source>
          <target state="translated">等待&lt;em&gt;AW &lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt;与超时完成。</target>
        </trans-unit>
        <trans-unit id="d5bfcef6a02be7849ca322a1b7fa63807a4361ed" translate="yes" xml:space="preserve">
          <source>Wait for the child process to terminate.</source>
          <target state="translated">等到孩子进程终止。</target>
        </trans-unit>
        <trans-unit id="fc57d83fd49bf3b1beb38bc11fe23ab63ce80444" translate="yes" xml:space="preserve">
          <source>Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt;&lt;code&gt;P_PID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt;&lt;code&gt;P_PGID&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.P_ALL&quot;&gt;&lt;code&gt;P_ALL&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt;&lt;code&gt;WEXITED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt;&lt;code&gt;WSTOPPED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt;&lt;code&gt;WCONTINUED&lt;/code&gt;&lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt;&lt;code&gt;WNOWAIT&lt;/code&gt;&lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; is specified and there are no children in a waitable state.</source>
          <target state="translated">等待一个或多个子进程完成。&lt;em&gt;idtype&lt;/em&gt;可以是&lt;a href=&quot;#os.P_PID&quot;&gt; &lt;code&gt;P_PID&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.P_PGID&quot;&gt; &lt;code&gt;P_PGID&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.P_ALL&quot;&gt; &lt;code&gt;P_ALL&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;id&lt;/em&gt;指定要等待的pid。&lt;em&gt;options&lt;/em&gt;是通过&lt;a href=&quot;#os.WEXITED&quot;&gt; &lt;code&gt;WEXITED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.WSTOPPED&quot;&gt; &lt;code&gt;WSTOPPED&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.WCONTINUED&quot;&gt; &lt;code&gt;WCONTINUED&lt;/code&gt; &lt;/a&gt;或一个或多个的ORing构造的，并且还可以与&lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.WNOWAIT&quot;&gt; &lt;code&gt;WNOWAIT&lt;/code&gt; &lt;/a&gt;进行OR运算。返回值是一个对象，代表 &lt;code&gt;siginfo_t&lt;/code&gt; 结构中包含的数据，即： &lt;code&gt;si_pid&lt;/code&gt; ， &lt;code&gt;si_uid&lt;/code&gt; ， &lt;code&gt;si_signo&lt;/code&gt; ， &lt;code&gt;si_status&lt;/code&gt; ， &lt;code&gt;si_code&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; ，如果&lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt;是指定的，有没有孩子在可等待的状态。</target>
        </trans-unit>
        <trans-unit id="8fb0e69dd9fcfb951c44934a49370ba0848fdd14" translate="yes" xml:space="preserve">
          <source>Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt;&lt;code&gt;P_PID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt;&lt;code&gt;P_PGID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_ALL&quot;&gt;&lt;code&gt;P_ALL&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#os.P_PIDFD&quot;&gt;&lt;code&gt;P_PIDFD&lt;/code&gt;&lt;/a&gt; on Linux. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt;&lt;code&gt;WEXITED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt;&lt;code&gt;WSTOPPED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt;&lt;code&gt;WCONTINUED&lt;/code&gt;&lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt;&lt;code&gt;WNOWAIT&lt;/code&gt;&lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; is specified and there are no children in a waitable state.</source>
          <target state="translated">等待一个或多个子进程完成。在Linux上，&lt;em&gt;idtype&lt;/em&gt;可以是&lt;a href=&quot;#os.P_PID&quot;&gt; &lt;code&gt;P_PID&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.P_PGID&quot;&gt; &lt;code&gt;P_PGID&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.P_ALL&quot;&gt; &lt;code&gt;P_ALL&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.P_PIDFD&quot;&gt; &lt;code&gt;P_PIDFD&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;id&lt;/em&gt;指定要等待的pid。&lt;em&gt;options&lt;/em&gt;是由&lt;a href=&quot;#os.WEXITED&quot;&gt; &lt;code&gt;WEXITED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.WSTOPPED&quot;&gt; &lt;code&gt;WSTOPPED&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.WCONTINUED&quot;&gt; &lt;code&gt;WCONTINUED&lt;/code&gt; 中&lt;/a&gt;的一个或多个的ORing构造而成的，此外，还可以与&lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#os.WNOWAIT&quot;&gt; &lt;code&gt;WNOWAIT&lt;/code&gt; &lt;/a&gt;进行OR运算。返回值是一个对象，代表 &lt;code&gt;siginfo_t&lt;/code&gt; 结构中包含的数据，即： &lt;code&gt;si_pid&lt;/code&gt; ， &lt;code&gt;si_uid&lt;/code&gt; ， &lt;code&gt;si_signo&lt;/code&gt; ， &lt;code&gt;si_status&lt;/code&gt; ， &lt;code&gt;si_code&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; (如果指定了&lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt;，并且没有子级处于等待状态）。</target>
        </trans-unit>
        <trans-unit id="5ec9481f9a89a7f37a291ebe888b480fa7b27740" translate="yes" xml:space="preserve">
          <source>Wait for the worker processes to exit. One must call &lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; before using &lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等待工作进程退出。在使用&lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;之前，必须先调用&lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="24c2968b108d264170fd51a0470c595df02b5436" translate="yes" xml:space="preserve">
          <source>Wait till an object in &lt;em&gt;object_list&lt;/em&gt; is ready. Returns the list of those objects in &lt;em&gt;object_list&lt;/em&gt; which are ready. If &lt;em&gt;timeout&lt;/em&gt; is a float then the call blocks for at most that many seconds. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then it will block for an unlimited period. A negative timeout is equivalent to a zero timeout.</source>
          <target state="translated">等待直到&lt;em&gt;object_list中&lt;/em&gt;的对象准备就绪。在返回这些对象的列表&lt;em&gt;object_list中&lt;/em&gt;哪些准备。如果&lt;em&gt;超时&lt;/em&gt;是浮动的，则呼叫最多会阻塞很多秒。如果&lt;em&gt;超时&lt;/em&gt;为&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 则它将无限期阻塞。负超时等于零超时。</target>
        </trans-unit>
        <trans-unit id="70307f0b7918be1c3ba2811e4af742880bd148cb" translate="yes" xml:space="preserve">
          <source>Wait until a condition evaluates to true. &lt;em&gt;predicate&lt;/em&gt; should be a callable which result will be interpreted as a boolean value. A &lt;em&gt;timeout&lt;/em&gt; may be provided giving the maximum time to wait.</source>
          <target state="translated">等到条件评估为真。&lt;em&gt;谓词&lt;/em&gt;应该是可调用的，其结果将被解释为布尔值。一个&lt;em&gt;超时&lt;/em&gt;可以提供给最长等待时间。</target>
        </trans-unit>
        <trans-unit id="f2cef329a9efde14e8d238168106e3ca5692ee07" translate="yes" xml:space="preserve">
          <source>Wait until a file descriptor received some data using the &lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; method and then close the event loop:</source>
          <target state="translated">等待文件描述符使用&lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt;方法接收到一些数据，然后关闭事件循环：</target>
        </trans-unit>
        <trans-unit id="74ad20c64b497f2ca5ab845b7554279263b0f679" translate="yes" xml:space="preserve">
          <source>Wait until a predicate becomes &lt;em&gt;true&lt;/em&gt;.</source>
          <target state="translated">等到谓词变为&lt;em&gt;真&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a6ca18daf863b117483b5967387209392304958f" translate="yes" xml:space="preserve">
          <source>Wait until a socket receives data using the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; method with a protocol:</source>
          <target state="translated">等待套接字使用具有协议的&lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt;方法接收数据：</target>
        </trans-unit>
        <trans-unit id="07a9261621d8e68aedbd16e18722b9a67f39cec1" translate="yes" xml:space="preserve">
          <source>Wait until all output written to file descriptor &lt;em&gt;fd&lt;/em&gt; has been transmitted.</source>
          <target state="translated">等待直到写入文件描述符&lt;em&gt;fd的&lt;/em&gt;所有输出都已传输。</target>
        </trans-unit>
        <trans-unit id="dfe11ac9dce22748ac5bc6e88601147ef1f88fb6" translate="yes" xml:space="preserve">
          <source>Wait until it is appropriate to resume writing to the stream. Example:</source>
          <target state="translated">等到合适的时候再恢复对流的写入。例如:</target>
        </trans-unit>
        <trans-unit id="b67b0cd8f0df8f71b4a7721db60c000c4a9aaff5" translate="yes" xml:space="preserve">
          <source>Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">等待直到收到通知或超时。如果在调用此方法时调用线程未获取锁，则会引发&lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0970419de06465ae0edf094213021ffbd86ca8c" translate="yes" xml:space="preserve">
          <source>Wait until notified.</source>
          <target state="translated">等到通知。</target>
        </trans-unit>
        <trans-unit id="c2fc9d1ed3712ef7d3bde153348d7c6c6cfd49a2" translate="yes" xml:space="preserve">
          <source>Wait until process &lt;em&gt;pid&lt;/em&gt; completes and check that the process exit code is &lt;em&gt;exitcode&lt;/em&gt;.</source>
          <target state="translated">等待进程&lt;em&gt;pid&lt;/em&gt;完成，然后检查进程退出代码是否为&lt;em&gt;exitcode&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ec9622e8f50c22884aacc0c6a6c6d1d859b01b43" translate="yes" xml:space="preserve">
          <source>Wait until some registered file objects become ready, or the timeout expires.</source>
          <target state="translated">等到一些注册的文件对象准备好了,或者超时了。</target>
        </trans-unit>
        <trans-unit id="c5ec2047d1b5f0f5a23a91d4267a89adebce9d94" translate="yes" xml:space="preserve">
          <source>Wait until the &lt;a href=&quot;#asyncio.Server.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method completes.</source>
          <target state="translated">等待&lt;a href=&quot;#asyncio.Server.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;方法完成。</target>
        </trans-unit>
        <trans-unit id="fdc40d911794127c221170ea25e3065e9d790a27" translate="yes" xml:space="preserve">
          <source>Wait until the event is set.</source>
          <target state="translated">等到事件设置好后。</target>
        </trans-unit>
        <trans-unit id="29508508455305b1db6d27aa2e48c694fd3d730b" translate="yes" xml:space="preserve">
          <source>Wait until the result is available or until &lt;em&gt;timeout&lt;/em&gt; seconds pass.</source>
          <target state="translated">等待结果可用或&lt;em&gt;超时&lt;/em&gt;秒数过去。</target>
        </trans-unit>
        <trans-unit id="056d3e2f705449186f7ac1299798e318e2219fbd" translate="yes" xml:space="preserve">
          <source>Wait until the sound device has played every byte in its buffer. (This happens implicitly when the device is closed.) The OSS documentation recommends closing and re-opening the device rather than using &lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等待声音设备播放其缓冲区中的每个字节。（这在关闭设备时隐式发生。）OSS文档建议关闭并重新打开设备，而不是使用&lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec111d4c42deb0f141e5bb12ebeed4601999588c" translate="yes" xml:space="preserve">
          <source>Wait until the stream is closed.</source>
          <target state="translated">等到合流的时候。</target>
        </trans-unit>
        <trans-unit id="eba24cad077b45f2680eff0bdf9fd0536486f778" translate="yes" xml:space="preserve">
          <source>Wait until the thread terminates. This blocks the calling thread until the thread whose &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called terminates &amp;ndash; either normally or through an unhandled exception &amp;ndash; or until the optional timeout occurs.</source>
          <target state="translated">等待线程终止。这将阻塞调用线程，直到被调用&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;方法的线程终止（正常或通过未处理的异常终止），或直到发生可选的超时为止。</target>
        </trans-unit>
        <trans-unit id="08e6575bce34aa7e829066c628e1bbe5ee1d226d" translate="yes" xml:space="preserve">
          <source>Waiting Primitives</source>
          <target state="translated">等待的基元</target>
        </trans-unit>
        <trans-unit id="f3bea4a4b6439483e8e78f429d91872ebd9c3c18" translate="yes" xml:space="preserve">
          <source>Wake only one epoll object when the associated fd has an event. The default (if this flag is not set) is to wake all epoll objects polling on a fd.</source>
          <target state="translated">当相关的fd发生事件时,只唤醒一个epoll对象。默认情况下(如果没有设置这个标志)是唤醒所有在fd上轮询的epoll对象。</target>
        </trans-unit>
        <trans-unit id="6a8cfa9cdcc5cfd14c9ca062c6bc6c63f61f28de" translate="yes" xml:space="preserve">
          <source>Wake up all tasks waiting on this condition.</source>
          <target state="translated">唤醒所有等待此条件的任务。</target>
        </trans-unit>
        <trans-unit id="93ae74426e9dc6545cb55c36b1af9d2f7460d6e8" translate="yes" xml:space="preserve">
          <source>Wake up all threads waiting on this condition. This method acts like &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt;, but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">唤醒所有在这种情况下等待的线程。此方法的行为类似于&lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt;，但是唤醒所有等待的线程而不是一个。如果在调用此方法时调用线程未获取锁，则会引发&lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd4a765d51a4008bcc07316f2233df4d04edeb34" translate="yes" xml:space="preserve">
          <source>Wake up at most &lt;em&gt;n&lt;/em&gt; tasks (1 by default) waiting on this condition. The method is no-op if no tasks are waiting.</source>
          <target state="translated">在这种情况下最多唤醒&lt;em&gt;n个&lt;/em&gt;任务（默认为1个）。如果没有任务在等待，则该方法为无操作。</target>
        </trans-unit>
        <trans-unit id="bf340b925958411b04f22ec98ee18783d9a1e220" translate="yes" xml:space="preserve">
          <source>Walk a stack following &lt;code&gt;f.f_back&lt;/code&gt; from the given frame, yielding the frame and line number for each frame. If &lt;em&gt;f&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the current stack is used. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从给定帧中沿着 &lt;code&gt;f.f_back&lt;/code&gt; 跟随堆栈，产生每个帧的帧和行号。如果&lt;em&gt;f&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则使用当前堆栈。该帮助程序与&lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; 一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a27a446a60fb72e15035278b0c8eb08c42135e9" translate="yes" xml:space="preserve">
          <source>Walk a traceback following &lt;code&gt;tb_next&lt;/code&gt; yielding the frame and line number for each frame. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;tb_next&lt;/code&gt; 之后进行回溯，以产生每个帧的帧号和行号。该帮助程序与&lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; 一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="f0b8c638923d24a321f5c6972c05277cf144fb7b" translate="yes" xml:space="preserve">
          <source>Warning Categories</source>
          <target state="translated">警告类别</target>
        </trans-unit>
        <trans-unit id="4b2c3cc9b73eb686d163d3880f8c1912f8b96956" translate="yes" xml:space="preserve">
          <source>Warning categories that are primarily of interest to Python developers (rather than end users of applications written in Python) are ignored by default.</source>
          <target state="translated">主要是Python开发者(而不是用Python编写的应用程序的最终用户)感兴趣的警告类别会被默认忽略。</target>
        </trans-unit>
        <trans-unit id="847345091f804153cb593f84ad497f73b760d180" translate="yes" xml:space="preserve">
          <source>Warning messages are normally written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;, but their disposition can be changed flexibly, from ignoring all warnings to turning them into exceptions. The disposition of warnings can vary based on the &lt;a href=&quot;#warning-categories&quot;&gt;warning category&lt;/a&gt;, the text of the warning message, and the source location where it is issued. Repetitions of a particular warning for the same source location are typically suppressed.</source>
          <target state="translated">警告消息通常写入&lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;，但是可以灵活地更改它们的处理方式，从忽略所有警告到将其转变为异常。警告的处理方式可能会根据&lt;a href=&quot;#warning-categories&quot;&gt;警告类别&lt;/a&gt;，警告消息的文本以及发出警告的源位置而有所不同。通常会禁止针对同一源位置重复特定警告。</target>
        </trans-unit>
        <trans-unit id="6fa8d6a7b1b2b2ba758f00991e78c8631d91fa69" translate="yes" xml:space="preserve">
          <source>Warning messages are typically issued in situations where it is useful to alert the user of some condition in a program, where that condition (normally) doesn&amp;rsquo;t warrant raising an exception and terminating the program. For example, one might want to issue a warning when a program uses an obsolete module.</source>
          <target state="translated">警告消息通常是在警告用户程序中某些情况的情况下发出的，该情况（通常）不保证引发异常并终止程序。例如，当程序使用过时的模块时，可能要发出警告。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="09505683c6b5bf3932806860c33becb79c315a18" translate="yes" xml:space="preserve">
          <source>Watch a file descriptor for read events</source>
          <target state="translated">关注文件描述符的读取事件</target>
        </trans-unit>
        <trans-unit id="56bdf1df2d6de2dce3cb70cc7a1d445ff547ab4f" translate="yes" xml:space="preserve">
          <source>Watch for events on a network device [not available on Mac OS X]</source>
          <target state="translated">监视网络设备上的事件[在Mac OS X上不可用]。</target>
        </trans-unit>
        <trans-unit id="a77a9f44b3dc9612388cdc66f0973471511ca754" translate="yes" xml:space="preserve">
          <source>Watch for events on a process id</source>
          <target state="translated">监视流程id上的事件</target>
        </trans-unit>
        <trans-unit id="7b8d444f092659996944c98103896607bf61afda" translate="yes" xml:space="preserve">
          <source>WatchedFileHandler</source>
          <target state="translated">WatchedFileHandler</target>
        </trans-unit>
        <trans-unit id="6c952491e9149238af6d5009db8cdd488e66dcb2" translate="yes" xml:space="preserve">
          <source>Watching file descriptors</source>
          <target state="translated">观察文件描述符</target>
        </trans-unit>
        <trans-unit id="853f81f21983a508519fe18408fdef4381a53c85" translate="yes" xml:space="preserve">
          <source>Wave_read Objects</source>
          <target state="translated">Wave_read 对象</target>
        </trans-unit>
        <trans-unit id="40b33acc387d819933f3a4e356b1224932bc5fe4" translate="yes" xml:space="preserve">
          <source>Wave_read objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;返回的Wave_read对象具有以下方法：</target>
        </trans-unit>
        <trans-unit id="d6e5965f88e6bbc53b5aa0194a15009dfa785bfa" translate="yes" xml:space="preserve">
          <source>Wave_write Objects</source>
          <target state="translated">Wave_write 对象</target>
        </trans-unit>
        <trans-unit id="b2438cc47ac4cf690f00fb0bcb5a03c6f4fd235a" translate="yes" xml:space="preserve">
          <source>Wave_write objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;返回的Wave_write对象具有以下方法：</target>
        </trans-unit>
        <trans-unit id="cb1d2fa5af87cd6de5bce19db6524cc1d529a3d0" translate="yes" xml:space="preserve">
          <source>Ways to reference it</source>
          <target state="translated">参考方法</target>
        </trans-unit>
        <trans-unit id="d85190bf88b389c7893fdc3f90cf47dcd9cbeca0" translate="yes" xml:space="preserve">
          <source>We can import this data by reading from a file:</source>
          <target state="translated">我们可以通过从文件中读取这些数据来导入。</target>
        </trans-unit>
        <trans-unit id="2b789995e580ea25048a2285a5926e24768d9cf2" translate="yes" xml:space="preserve">
          <source>We can remove elements using &lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt;&lt;code&gt;Element.remove()&lt;/code&gt;&lt;/a&gt;. Let&amp;rsquo;s say we want to remove all countries with a rank higher than 50:</source>
          <target state="translated">我们可以使用&lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt; &lt;code&gt;Element.remove()&lt;/code&gt; &lt;/a&gt;删除元素。假设我们要删除排名高于50的所有国家/地区：</target>
        </trans-unit>
        <trans-unit id="215e314610fefea13b5da68c465496bf961d967a" translate="yes" xml:space="preserve">
          <source>We can see that Python has loaded &lt;code&gt;8173 KiB&lt;/code&gt; of module data (bytecode and constants), and that this is &lt;code&gt;4428 KiB&lt;/code&gt; more than had been loaded before the tests, when the previous snapshot was taken. Similarly, the &lt;a href=&quot;linecache#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module has cached &lt;code&gt;940 KiB&lt;/code&gt; of Python source code to format tracebacks, all of it since the previous snapshot.</source>
          <target state="translated">我们可以看到Python已加载了 &lt;code&gt;8173 KiB&lt;/code&gt; 的模块数据（字节码和常量），这比获取前一个快照时在测试之前加载的数据多了 &lt;code&gt;4428 KiB&lt;/code&gt; 。类似地，&lt;a href=&quot;linecache#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; &lt;/a&gt;模块已经缓存了 &lt;code&gt;940 KiB&lt;/code&gt; 的Python源代码以格式化回溯，所有这些都来自上一个快照。</target>
        </trans-unit>
        <trans-unit id="a3cfb793dfee5070acdfd0a536b9c921adeb6f59" translate="yes" xml:space="preserve">
          <source>We can see that Python loaded &lt;code&gt;4855 KiB&lt;/code&gt; data (bytecode and constants) from modules and that the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module allocated &lt;code&gt;244 KiB&lt;/code&gt; to build &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">我们可以看到Python 从模块中加载了 &lt;code&gt;4855 KiB&lt;/code&gt; 数据（字节码和常量），并且&lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt;模块分配了 &lt;code&gt;244 KiB&lt;/code&gt; 来构建&lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="7b16f5f4ffc8f56cb2bb30fa071edafeee046554" translate="yes" xml:space="preserve">
          <source>We can see that the most memory was allocated in the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; module to load data (bytecode and constants) from modules: &lt;code&gt;870.1 KiB&lt;/code&gt;. The traceback is where the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; loaded data most recently: on the &lt;code&gt;import pdb&lt;/code&gt; line of the &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. The traceback may change if a new module is loaded.</source>
          <target state="translated">我们可以看到，在&lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt;模块中分配了最多的内存以从模块中加载数据（字节码和常量）： &lt;code&gt;870.1 KiB&lt;/code&gt; 。追溯是&lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt;最近加载数据的位置：在&lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt;模块的 &lt;code&gt;import pdb&lt;/code&gt; 行上。如果加载了新模块，则回溯可能会更改。</target>
        </trans-unit>
        <trans-unit id="41498dcbefc1d323bf74e1d9ce5b53a4cc360514" translate="yes" xml:space="preserve">
          <source>We have defined the &lt;code&gt;struct _frozen&lt;/code&gt; data type, so we can get the pointer to the table:</source>
          <target state="translated">我们已经定义了 &lt;code&gt;struct _frozen&lt;/code&gt; 数据类型，因此我们可以获得表的指针：</target>
        </trans-unit>
        <trans-unit id="5cfcb5b8900d48c6735c6871c6773651f8b0c087" translate="yes" xml:space="preserve">
          <source>We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method as follows:</source>
          <target state="translated">我们可以尝试使用&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt;方法实现该类，如下所示：</target>
        </trans-unit>
        <trans-unit id="dd9a3eb14b1a885e62804e74860fd9a945f731e9" translate="yes" xml:space="preserve">
          <source>We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method as follows:</source>
          <target state="translated">我们可以尝试使用&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt;方法实现该类，如下所示：</target>
        </trans-unit>
        <trans-unit id="31f330039a177b6f4ba692d81baa88bba27b8da4" translate="yes" xml:space="preserve">
          <source>We recommend that all application designers seriously consider doing this; we have seen many protocols where a hash that is computed in one part of the protocol can be used in an entirely different part because two hash computations were done on similar or related data, and the attacker can force the application to make the hash inputs the same. Personalizing each hash function used in the protocol summarily stops this type of attack.</source>
          <target state="translated">我们建议所有的应用设计者认真考虑这样做,我们看到很多协议中,在协议的一个部分计算出的哈希值可以在一个完全不同的部分使用,因为在相似或相关的数据上进行了两次哈希计算,攻击者可以强迫应用使哈希输入相同。对协议中使用的每个哈希函数进行个性化处理,可以总结性地阻止这种类型的攻击。</target>
        </trans-unit>
        <trans-unit id="366243de9e8dd818c63915fa0eb00c27eb54fd4e" translate="yes" xml:space="preserve">
          <source>We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</source>
          <target state="translated">我们说如果可以在&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt;表达式中使用对象，则它是一个&lt;strong&gt;等待&lt;/strong&gt;对象。许多异步API被设计为接受等待。</target>
        </trans-unit>
        <trans-unit id="d1fe7a751621e826dae3cf98b7078b3b5dca2ddc" translate="yes" xml:space="preserve">
          <source>We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</source>
          <target state="translated">我们说一个对象是&lt;strong&gt;awaitable&lt;/strong&gt;对象，如果它可以在使用&lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt;表达。许多异步API旨在接受等待。</target>
        </trans-unit>
        <trans-unit id="57b5ab6e43e7e9a6b2ac86fe4eb61e522b2004b3" translate="yes" xml:space="preserve">
          <source>We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt;&lt;code&gt;Integral&lt;/code&gt;&lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; should be defined as:</source>
          <target state="translated">我们要实现算术运算，以便混合模式运算要么调用其作者知道两个参数类型的实现，要么将两者都转换为最接近的内置类型并在其中执行操作。对于&lt;a href=&quot;#numbers.Integral&quot;&gt; &lt;code&gt;Integral&lt;/code&gt; 的&lt;/a&gt;子类型，这意味着&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt;应该定义为：</target>
        </trans-unit>
        <trans-unit id="bc761093cffe85e655f26465122794f56dd31a1d" translate="yes" xml:space="preserve">
          <source>We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt;&lt;code&gt;Integral&lt;/code&gt;&lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; should be defined as:</source>
          <target state="translated">我们要实现算术运算，以便混合模式运算要么调用其作者知道两个参数类型的实现，要么将两者都转换为最接近的内置类型并在该位置执行操作。对于&lt;a href=&quot;#numbers.Integral&quot;&gt; &lt;code&gt;Integral&lt;/code&gt; 的&lt;/a&gt;子类型，这意味着&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt;应该定义为：</target>
        </trans-unit>
        <trans-unit id="f7d8571598e317c5f7d8abde12db88f57270cea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following XML document as the sample data for this section:</source>
          <target state="translated">我们将使用以下XML文档作为本节的示例数据：</target>
        </trans-unit>
        <trans-unit id="498251e1ee5e102841353e28c1ae8f3a3c95d0ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re given a training dataset with measurements for eight people. The measurements are assumed to be normally distributed, so we summarize the data with &lt;a href=&quot;#statistics.NormalDist&quot;&gt;&lt;code&gt;NormalDist&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">我们获得了一个训练数据集，其中包含八个人的测量值。假定测量值是正态分布的，所以我们使用&lt;a href=&quot;#statistics.NormalDist&quot;&gt; &lt;code&gt;NormalDist&lt;/code&gt; &lt;/a&gt;汇总数据：</target>
        </trans-unit>
        <trans-unit id="53fa691162f39e16d25e99147762bfdb99f7853f" translate="yes" xml:space="preserve">
          <source>Weak Reference Objects</source>
          <target state="translated">弱参考对象</target>
        </trans-unit>
        <trans-unit id="5ee5214a04390535aa3407199b4313f1342ce933" translate="yes" xml:space="preserve">
          <source>Weak reference objects have no methods and no attributes besides &lt;a href=&quot;#weakref.ref.__callback__&quot;&gt;&lt;code&gt;ref.__callback__&lt;/code&gt;&lt;/a&gt;. A weak reference object allows the referent to be obtained, if it still exists, by calling it:</source>
          <target state="translated">弱引用对象除了&lt;a href=&quot;#weakref.ref.__callback__&quot;&gt; &lt;code&gt;ref.__callback__&lt;/code&gt; &lt;/a&gt;之外，没有方法，也没有属性。弱引用对象可以通过调用它（如果仍然存在）来获取它：</target>
        </trans-unit>
        <trans-unit id="269b06c67f58c7694dc71ae7f0afae036d4818c7" translate="yes" xml:space="preserve">
          <source>Weak references are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;em&gt;对象&lt;/em&gt;是可&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;哈希的，&lt;/a&gt;则弱引用是可哈希的。即使删除了&lt;em&gt;对象&lt;/em&gt;，它们也将保持其哈希值。如果仅在删除&lt;em&gt;对象&lt;/em&gt;后才第一次调用&lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt;，则该调用将引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04913217684b6d8f5cd00da928dd46e054c1b557" translate="yes" xml:space="preserve">
          <source>Weak references are &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;em&gt;对象&lt;/em&gt;是可&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;哈希的，&lt;/a&gt;则弱引用是可哈希的。即使删除了&lt;em&gt;对象&lt;/em&gt;，它们也将保持其哈希值。如果仅在删除&lt;em&gt;对象&lt;/em&gt;后才第一次调用&lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt;，则该调用将引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf5772b94a870ac2c2a272ce1b65b3d3ec5cdd0a" translate="yes" xml:space="preserve">
          <source>Weak references support tests for equality, but not ordering. If the referents are still alive, two references have the same equality relationship as their referents (regardless of the &lt;em&gt;callback&lt;/em&gt;). If either referent has been deleted, the references are equal only if the reference objects are the same object.</source>
          <target state="translated">弱引用支持相等性测试，但不支持顺序测试。如果引用仍然存在，则两个引用与其引用具有相同的相等关系（与&lt;em&gt;callback&lt;/em&gt;无关）。如果已删除任何一个引用对象，则仅当引用对象是同一对象时，引用才相等。</target>
        </trans-unit>
        <trans-unit id="160d43660c7e93a34cbf9e6d0683b3f1d070e0fc" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt;, Section 10.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt;第10.1节</target>
        </trans-unit>
        <trans-unit id="4a73d3d2fe230642eaf557fd34c51c84ef4ff1ba" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.1节</target>
        </trans-unit>
        <trans-unit id="295bedc312a6b750f29bbdcb9c55b71841762311" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.1节</target>
        </trans-unit>
        <trans-unit id="74f89d6c2e38467f5b13ae0091d9a8a51c1b16e1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.2节</target>
        </trans-unit>
        <trans-unit id="a2bff95c1e44c73456e7cae10cda54d6fa398f6f" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.3节</target>
        </trans-unit>
        <trans-unit id="abe7a48219d118193d54ce7547d400d9545dd2cc" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.2节</target>
        </trans-unit>
        <trans-unit id="fd468def379a57145ba45b0607d05b11370a29a3" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.4节</target>
        </trans-unit>
        <trans-unit id="8819e6862e6a19eeb00ace3fec0603e588d8328b" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.3节</target>
        </trans-unit>
        <trans-unit id="bca3fc2cd5c152a0bdbb345654a6d0db591b3ea4" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.4节</target>
        </trans-unit>
        <trans-unit id="98acc379abdeda29844b5028a71fa64b09754bd1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.5节</target>
        </trans-unit>
        <trans-unit id="45ce951509f93a486a7c99b75337871dfff2d631" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-59&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-59&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;第11.5节</target>
        </trans-unit>
        <trans-unit id="98047a8d0918ebb9d2a9d3244b26fc929a5bcb7c" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</source>
          <target state="translated">WebDAV绑定扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;第7.1节（实验性）</target>
        </trans-unit>
        <trans-unit id="c50e846faf966023af5fd09f48f61a853f3480e1" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</source>
          <target state="translated">WebDAV绑定扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;第7.1节（实验性）</target>
        </trans-unit>
        <trans-unit id="2525087157bd91fd05837fb713cd7d80f247559d" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</source>
          <target state="translated">WebDAV绑定扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;第7.2节（实验性）</target>
        </trans-unit>
        <trans-unit id="5b74f2b39309ad2c4f5a3646e6db00e00616b578" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-60&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</source>
          <target state="translated">WebDAV绑定扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-60&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;第7.2节（实验性）</target>
        </trans-unit>
        <trans-unit id="efaa49e0aaddcee60c9e56544c7c0972d0e98dcb" translate="yes" xml:space="preserve">
          <source>WebP files</source>
          <target state="translated">WebP文件</target>
        </trans-unit>
        <trans-unit id="fe3f61ddecbabd9df7b81c596b0e344f7a9a1ef0" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">一年的周数(星期一为一周的第一天)为小数[00,53]。新的一年中第一个星期一之前的所有日子都被认为是第0周。</target>
        </trans-unit>
        <trans-unit id="957344126e376dfec66a5865493968e5033a759d" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">一年的周数(星期一为一周的第一天),用小数表示。新的一年中第一个星期一之前的所有日子都被认为是第0周。</target>
        </trans-unit>
        <trans-unit id="3aadb81eb1a1699671247b51c01b0cc44432b8bb" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">一年的周数(周日为一周的第一天)为十进制数[00,53]。在新的一年中,第一个星期日之前的所有日子都被认为是在第0周。</target>
        </trans-unit>
        <trans-unit id="f93371df01a8682d904d17bbc9258abc77e066be" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">一年的周数(周日为一周的第一天),作为一个零垫小数。在新的一年中,第一个星期日之前的所有日子都被认为是在第0周。</target>
        </trans-unit>
        <trans-unit id="027417f7bd7fb85e6bdc77ed8d873c5e62146b37" translate="yes" xml:space="preserve">
          <source>Weekday (0=Monday)</source>
          <target state="translated">工作日(0=周一)</target>
        </trans-unit>
        <trans-unit id="da94621ef8999a8ac972599f062234bc846d53f9" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number [0(Sunday),6].</source>
          <target state="translated">工作日为十进制数[0(星期日),6]。</target>
        </trans-unit>
        <trans-unit id="149ccb2de453647267122d8a96dda7b0ae559978" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.</source>
          <target state="translated">周日为十进制数,其中0为周日,6为周六。</target>
        </trans-unit>
        <trans-unit id="bb0fc2dc3a75233397a7a28f15f9662ee67c106e" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s abbreviated name.</source>
          <target state="translated">工作日为语言环境的缩写名称。</target>
        </trans-unit>
        <trans-unit id="bb1e28b07531c9368250cf22e73ebdac9375108f" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s full name.</source>
          <target state="translated">工作日为语言环境的全名。</target>
        </trans-unit>
        <trans-unit id="f6103eca7ab314d7e7cfd58095933632e58c72c4" translate="yes" xml:space="preserve">
          <source>Weibull distribution. &lt;em&gt;alpha&lt;/em&gt; is the scale parameter and &lt;em&gt;beta&lt;/em&gt; is the shape parameter.</source>
          <target state="translated">威布尔分布。&lt;em&gt;alpha&lt;/em&gt;是比例参数，&lt;em&gt;beta&lt;/em&gt;是形状参数。</target>
        </trans-unit>
        <trans-unit id="c74e5c5d315ff3f823c6f47d8fb4fc7d0c8fe3e0" translate="yes" xml:space="preserve">
          <source>Western Europe</source>
          <target state="translated">西欧</target>
        </trans-unit>
        <trans-unit id="ed6c63b0557e98944ebbf0299cfb303283e1e58e" translate="yes" xml:space="preserve">
          <source>What About Exceptions?</source>
          <target state="translated">那例外情况呢?</target>
        </trans-unit>
        <trans-unit id="6ee52e14b570b091324e858324b60dbe6df01e5a" translate="yes" xml:space="preserve">
          <source>What Is Deterministic Profiling?</source>
          <target state="translated">什么是确定性剖析?</target>
        </trans-unit>
        <trans-unit id="e5ac2d9156eb23a3dbdb1999476310a8ac6727e3" translate="yes" xml:space="preserve">
          <source>What can be pickled and unpickled?</source>
          <target state="translated">哪些东西可以腌制和不腌制?</target>
        </trans-unit>
        <trans-unit id="fcf1ade96b2641b7f1c03643a78aaf7e4461cb47" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;[[]]&lt;/code&gt; is a one-element list containing an empty list, so all three elements of &lt;code&gt;[[]] * 3&lt;/code&gt; are references to this single empty list. Modifying any of the elements of &lt;code&gt;lists&lt;/code&gt; modifies this single list. You can create a list of different lists this way:</source>
          <target state="translated">发生的事情是 &lt;code&gt;[[]]&lt;/code&gt; 是一个包含一个空列表的单元素列表，因此 &lt;code&gt;[[]] * 3&lt;/code&gt; 所有三个元素都是对该单个空列表的引用。修改 &lt;code&gt;lists&lt;/code&gt; 任何元素都会修改该单个列表。您可以通过以下方式创建不同列表的列表：</target>
        </trans-unit>
        <trans-unit id="9ea4146566e7e0cd8f5a8d4c34d120c18c585cf1" translate="yes" xml:space="preserve">
          <source>What the &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; functions do is connect an XML parser with a &amp;ldquo;DOM builder&amp;rdquo; that can accept parse events from any SAX parser and convert them into a DOM tree. The name of the functions are perhaps misleading, but are easy to grasp when learning the interfaces. The parsing of the document will be completed before these functions return; it&amp;rsquo;s simply that these functions do not provide a parser implementation themselves.</source>
          <target state="translated">什么&lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt;函数的功能是具有&amp;ldquo;DOM生成器&amp;rdquo;，可以从任何SAX解析器解析接受事件并将它们转换成DOM树连接XML解析器。函数的名称可能会引起误解，但在学习接口时很容易掌握。这些函数返回之前，将完成文档的解析。只是这些函数本身不提供解析器实现。</target>
        </trans-unit>
        <trans-unit id="e3c2e61a8fe0f76312d3b9af5434565ee7de2ec5" translate="yes" xml:space="preserve">
          <source>What the new Enum class will record as its name.</source>
          <target state="translated">新的Enum类将记录什么作为它的名字。</target>
        </trans-unit>
        <trans-unit id="0711f3c581dc5072b2cf9e260f7e705f68754df8" translate="yes" xml:space="preserve">
          <source>What this means in practice is that to support finding distribution package metadata in locations other than the file system, subclass &lt;code&gt;Distribution&lt;/code&gt; and implement the abstract methods. Then from a custom finder, return instances of this derived &lt;code&gt;Distribution&lt;/code&gt; in the &lt;code&gt;find_distributions()&lt;/code&gt; method.</source>
          <target state="translated">实际上，这意味着要支持在文件系统之外的其他位置查找分发程序包元数据，请子类化 &lt;code&gt;Distribution&lt;/code&gt; 并实现抽象方法。然后从自定义查找器中，在 &lt;code&gt;find_distributions()&lt;/code&gt; 方法中返回此派生的 &lt;code&gt;Distribution&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="5390d096f592c9ee00a6e75cd2a40d199772255f" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the Execution Context?</source>
          <target state="translated">什么是执行上下文？</target>
        </trans-unit>
        <trans-unit id="86d433886770959c5f8b1c7316fb956a27baddc4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#abc.abstractmethod&quot;&gt;&lt;code&gt;abstractmethod()&lt;/code&gt;&lt;/a&gt; is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples:</source>
          <target state="translated">当将&lt;a href=&quot;#abc.abstractmethod&quot;&gt; &lt;code&gt;abstractmethod()&lt;/code&gt; &lt;/a&gt;与其他方法描述符结合使用时，应将其用作最里面的装饰器，如以下用法示例所示：</target>
        </trans-unit>
        <trans-unit id="7f660ad4252bf5d8a48ac42ba8b9a8060d0a917e" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; generates help messages, it needs some way to refer to each expected argument. By default, ArgumentParser objects use the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value as the &amp;ldquo;name&amp;rdquo; of each object. By default, for positional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is used directly, and for optional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is uppercased. So, a single positional argument with &lt;code&gt;dest='bar'&lt;/code&gt; will be referred to as &lt;code&gt;bar&lt;/code&gt;. A single optional argument &lt;code&gt;--foo&lt;/code&gt; that should be followed by a single command-line argument will be referred to as &lt;code&gt;FOO&lt;/code&gt;. An example:</source>
          <target state="translated">当&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt;生成帮助消息时，它需要某种方式来引用每个期望的参数。默认情况下，ArgumentParser对象使用&lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt;值作为每个对象的&amp;ldquo;名称&amp;rdquo;。默认情况下，对于位置参数操作，直接使用&lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt;值，对于可选参数操作，&lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt;值使用大写。因此，具有 &lt;code&gt;dest='bar'&lt;/code&gt; 的单个位置参数将称为 &lt;code&gt;bar&lt;/code&gt; 。单个可选参数 &lt;code&gt;--foo&lt;/code&gt; 后面应带有单个命令行参数，将被称为 &lt;code&gt;FOO&lt;/code&gt; 。一个例子：</target>
        </trans-unit>
        <trans-unit id="bbb7e98f193941e94a08737449c4a58a55c161fa" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with &lt;code&gt;action='store_const'&lt;/code&gt; or &lt;code&gt;action='append_const'&lt;/code&gt;. These actions add the &lt;code&gt;const&lt;/code&gt; value to one of the attributes of the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;#action&quot;&gt;action&lt;/a&gt; description for examples.</source>
          <target state="translated">当使用 &lt;code&gt;action='store_const'&lt;/code&gt; 或 &lt;code&gt;action='append_const'&lt;/code&gt; 调用&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; 时&lt;/a&gt;。这些操作将 &lt;code&gt;const&lt;/code&gt; 值添加到&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt;返回的对象的属性之一。有关示例，请参见&lt;a href=&quot;#action&quot;&gt;操作&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="908430b67ffab7192c58d413878590107f99ac8a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with option strings (like &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--foo&lt;/code&gt;) and &lt;code&gt;nargs='?'&lt;/code&gt;. This creates an optional argument that can be followed by zero or one command-line arguments. When parsing the command line, if the option string is encountered with no command-line argument following it, the value of &lt;code&gt;const&lt;/code&gt; will be assumed instead. See the &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; description for examples.</source>
          <target state="translated">当使用选项字符串（如 &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--foo&lt;/code&gt; ）和 &lt;code&gt;nargs='?'&lt;/code&gt; 调用&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; 时&lt;/a&gt;。。这将创建一个可选参数，后跟零个或一个命令行参数。解析命令行时，如果遇到选项字符串后没有命令行参数，则将使用 &lt;code&gt;const&lt;/code&gt; 的值。有关示例，请参见&lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="02441c1f960fb0baf4239fae2d2c88d890e1b2fc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; is called, optional arguments will be identified by the &lt;code&gt;-&lt;/code&gt; prefix, and the remaining arguments will be assumed to be positional:</source>
          <target state="translated">当&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt;被调用时，可选的参数将被识别 &lt;code&gt;-&lt;/code&gt; 前缀，而其余的参数将被认为是位置：</target>
        </trans-unit>
        <trans-unit id="629de685613646d00ea10bd953237cc1c7924121" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; is available then backwards-compatible functionality is provided.</source>
          <target state="translated">当&lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt;可用时，将提供向后兼容功能。</target>
        </trans-unit>
        <trans-unit id="c0d39c6fdaaf5a388a75f42af12f2c38b99a2423" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; is executed:</source>
          <target state="translated">当执行&lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; 时&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="fd23a56d325ff0bf7a6e61d85cd4f34a2147f5d5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; is initialized the main process is assigned a random string using &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt;初始化主处理使用分配给随机字符串&lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11aa0c7fff9e9b567a187a2e5b13f5a8d5be7181" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; is supported, assignments to items in &lt;code&gt;os.environ&lt;/code&gt; are automatically translated into corresponding calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to assign to items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">当支持&lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; 时&lt;/a&gt;，对 &lt;code&gt;os.environ&lt;/code&gt; 中项目的分配将自动转换为对&lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; 的&lt;/a&gt;相应调用；但是，对&lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; 的&lt;/a&gt;调用不会更新 &lt;code&gt;os.environ&lt;/code&gt; ，因此实际上最好分配给 &lt;code&gt;os.environ&lt;/code&gt; 的项。</target>
        </trans-unit>
        <trans-unit id="c01e42f0e3d04cc243dd7a57f8e10baf4c6db3b1" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt;&lt;code&gt;st_file_attributes&lt;/code&gt;&lt;/a&gt; has the &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; set, this field contains the tag identifying the type of reparse point. See the &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">当&lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt; &lt;code&gt;st_file_attributes&lt;/code&gt; &lt;/a&gt;设置了 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 时，此字段包含标识重解析点类型的标记。请参阅&lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="cf790e480175785930a548355dd8f5086f5c9b7a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; is supported, deletion of items in &lt;code&gt;os.environ&lt;/code&gt; is automatically translated into a corresponding call to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to delete items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">当支持&lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; 时&lt;/a&gt;，删除 &lt;code&gt;os.environ&lt;/code&gt; 中的项目会自动转换为对&lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt;的相应调用；但是，对&lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; 的&lt;/a&gt;调用不会更新 &lt;code&gt;os.environ&lt;/code&gt; ，因此实际上最好删除 &lt;code&gt;os.environ&lt;/code&gt; 的项。</target>
        </trans-unit>
        <trans-unit id="e962e2ecd1be54236efb9b9cd0dcb1c0a6890061" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; detects a source request (see &lt;a href=&quot;#shlex.shlex.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.</source>
          <target state="translated">当&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt;检测到一个源请求时（请参见下面的&lt;a href=&quot;#shlex.shlex.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;），该方法将获得以下标记作为参数，并期望返回一个由文件名和类似文件的打开对象组成的元组。</target>
        </trans-unit>
        <trans-unit id="003413e572cb08fc012d56140cf949b7ac4b28b8" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt;&lt;code&gt;keylog_filename&lt;/code&gt;&lt;/a&gt; is supported and the environment variable &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; is set, &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; enables key logging.</source>
          <target state="translated">当&lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt; &lt;code&gt;keylog_filename&lt;/code&gt; &lt;/a&gt;被支撑和环境变量 &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; 被设置，&lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt;使关键日志记录。</target>
        </trans-unit>
        <trans-unit id="ae592f12245b7b672b2b312ad6a41430e2206fbb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is creating a mock for you, it is common that the first thing you need to do is to configure the mock. Some of that configuration can be done in the call to patch. Any arbitrary keywords you pass into the call will be used to set attributes on the created mock:</source>
          <target state="translated">当&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt;为您创建模拟程序时，通常要做的第一件事就是配置模拟程序。其中一些配置可以在补丁调用中完成。您传递给调用的任何任意关键字将用于在创建的模拟中设置属性：</target>
        </trans-unit>
        <trans-unit id="984f54d038232b41fa8fb278710d0228edce2b46" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, whitespace immediately following the &lt;em&gt;delimiter&lt;/em&gt; is ignored. The default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果为&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;，则&lt;em&gt;分隔符后的&lt;/em&gt;空白将被忽略。默认值为&lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fbc90776622a0bcb40ca2bd0c844997d03d08a5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;COLUMNS&lt;/code&gt; or &lt;code&gt;LINES&lt;/code&gt; is not defined, which is the common case, the terminal connected to &lt;a href=&quot;sys#sys.__stdout__&quot;&gt;&lt;code&gt;sys.__stdout__&lt;/code&gt;&lt;/a&gt; is queried by invoking &lt;a href=&quot;os#os.get_terminal_size&quot;&gt;&lt;code&gt;os.get_terminal_size()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当没有定义 &lt;code&gt;COLUMNS&lt;/code&gt; 或 &lt;code&gt;LINES&lt;/code&gt; 时（这是常见的情况），通过调用&lt;a href=&quot;os#os.get_terminal_size&quot;&gt; &lt;code&gt;os.get_terminal_size()&lt;/code&gt; &lt;/a&gt;来查询连接到&lt;a href=&quot;sys#sys.__stdout__&quot;&gt; &lt;code&gt;sys.__stdout__&lt;/code&gt; &lt;/a&gt;的终端。</target>
        </trans-unit>
        <trans-unit id="be1c8634db85a77e79d600408825132f805fd2d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;None&lt;/code&gt; is passed, it&amp;rsquo;s up to the class designer to decide the best response. For example, returning &lt;code&gt;None&lt;/code&gt; is appropriate if the class wishes to say that time objects don&amp;rsquo;t participate in the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; protocols. It may be more useful for &lt;code&gt;utcoffset(None)&lt;/code&gt; to return the standard UTC offset, as there is no other convention for discovering the standard offset.</source>
          <target state="translated">如果传递 &lt;code&gt;None&lt;/code&gt; ，则由类设计者决定最佳响应。例如，如果该类希望说时间对象不参与&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;协议，则返回 &lt;code&gt;None&lt;/code&gt; 是适当的。 &lt;code&gt;utcoffset(None)&lt;/code&gt; 返回标准UTC偏移量可能更有用，因为没有其他约定可以发现标准偏移量。</target>
        </trans-unit>
        <trans-unit id="d247f34d37a9741e0b40611aec77465bb0b0659a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PATH_INFO&lt;/code&gt; is just a &amp;ldquo;/&amp;rdquo;, this routine returns an empty string and appends a trailing slash to &lt;code&gt;SCRIPT_NAME&lt;/code&gt;, even though empty path segments are normally ignored, and &lt;code&gt;SCRIPT_NAME&lt;/code&gt; doesn&amp;rsquo;t normally end in a slash. This is intentional behavior, to ensure that an application can tell the difference between URIs ending in &lt;code&gt;/x&lt;/code&gt; from ones ending in &lt;code&gt;/x/&lt;/code&gt; when using this routine to do object traversal.</source>
          <target state="translated">当 &lt;code&gt;PATH_INFO&lt;/code&gt; 只是一个&amp;ldquo; /&amp;rdquo;时，此例程将返回一个空字符串并将尾部斜杠附加到 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; ，即使通常忽略空路径段，并且 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 通常也不以斜杠结尾。这是故意行为，以确保应用程序在使用此例程进行对象遍历时可以区分以 &lt;code&gt;/x&lt;/code&gt; 结尾的URI 与以 &lt;code&gt;/x/&lt;/code&gt; 结尾的URI之间的区别。</target>
        </trans-unit>
        <trans-unit id="3259a3e106d026a974e471af3e09c6877af341cc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;True&lt;/code&gt;, raise exception &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on bad CSV input. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;True&lt;/code&gt; 时，&lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; CSV输入引发异常Error。默认值为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e22a01415028c5429e1a93f81e2fccf26594dcd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ZoneInfo(key)&lt;/code&gt; is called, the constructor first searches the directories specified in &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; for a file matching &lt;code&gt;key&lt;/code&gt;, and on failure looks for a match in the tzdata package. This behavior can be configured in three ways:</source>
          <target state="translated">当 &lt;code&gt;ZoneInfo(key)&lt;/code&gt; 被调用时，构造函数首先搜索的目录中指定&lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; &lt;/a&gt;的文件匹配 &lt;code&gt;key&lt;/code&gt; ，并在故障查找在包装的tzdata匹配。可以通过三种方式配置此行为：</target>
        </trans-unit>
        <trans-unit id="7249093ec9e4d3cc83bc42119bb94a864c87dc19" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;punctuation_chars&lt;/code&gt; is specified, the &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt;&lt;code&gt;wordchars&lt;/code&gt;&lt;/a&gt; attribute is augmented with the characters &lt;code&gt;~-./*?=&lt;/code&gt;. That is because these characters can appear in file names (including wildcards) and command-line arguments (e.g. &lt;code&gt;--color=auto&lt;/code&gt;). Hence:</source>
          <target state="translated">当 &lt;code&gt;punctuation_chars&lt;/code&gt; 指定，则&lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt; &lt;code&gt;wordchars&lt;/code&gt; &lt;/a&gt;属性被扩充以字符 &lt;code&gt;~-./*?=&lt;/code&gt; 。这是因为这些字符可以出现在文件名（包括通配符）和命令行参数（例如 &lt;code&gt;--color=auto&lt;/code&gt; ）中。因此：</target>
        </trans-unit>
        <trans-unit id="18714bad76b2938b84e76ca6a48899884c985828" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;cmd&lt;/em&gt; is &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX&lt;/code&gt;, it can also be bitwise ORed with &lt;code&gt;LOCK_NB&lt;/code&gt; to avoid blocking on lock acquisition. If &lt;code&gt;LOCK_NB&lt;/code&gt; is used and the lock cannot be acquired, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised and the exception will have an &lt;em&gt;errno&lt;/em&gt; attribute set to &lt;code&gt;EACCES&lt;/code&gt; or &lt;code&gt;EAGAIN&lt;/code&gt; (depending on the operating system; for portability, check for both values). On at least some systems, &lt;code&gt;LOCK_EX&lt;/code&gt; can only be used if the file descriptor refers to a file opened for writing.</source>
          <target state="translated">当&lt;em&gt;cmd&lt;/em&gt;为 &lt;code&gt;LOCK_SH&lt;/code&gt; 或 &lt;code&gt;LOCK_EX&lt;/code&gt; 时，也可以将其与 &lt;code&gt;LOCK_NB&lt;/code&gt; 进行按位或运算，以避免在获取锁时发生阻塞。如果使用 &lt;code&gt;LOCK_NB&lt;/code&gt; 且无法获取该锁，则将引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;并将异常的&lt;em&gt;errno&lt;/em&gt;属性设置为 &lt;code&gt;EACCES&lt;/code&gt; 或 &lt;code&gt;EAGAIN&lt;/code&gt; （取决于操作系统；对于可移植性，请检查两个值）。在至少某些系统上，仅当文件描述符引用了为写入而打开的文件时，才可以使用 &lt;code&gt;LOCK_EX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b83c29eb631fb560f29f322bca1a715e76bddb07" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;converters&lt;/em&gt; is given, it should be a dictionary where each key represents the name of a type converter and each value is a callable implementing the conversion from string to the desired datatype. Every converter gets its own corresponding &lt;code&gt;get*()&lt;/code&gt; method on the parser object and section proxies.</source>
          <target state="translated">当&lt;em&gt;转换器&lt;/em&gt;给出，它应该是一个字典，其中每个键表示一个类型的转换器的名称和每一个值是一个可调用的执行从字符串中的转化为期望的数据类型。每个转换器在解析器对象和节代理上都有自己的对应 &lt;code&gt;get*()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="af9e0a3c67c495e5f8455996a807bfc6861a7af3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;decode&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default) the body is returned as a string without decoding the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. However, for a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of 8bit, an attempt is made to decode the original bytes using the &lt;code&gt;charset&lt;/code&gt; specified by the &lt;em&gt;Content-Type&lt;/em&gt; header, using the &lt;code&gt;replace&lt;/code&gt; error handler. If no &lt;code&gt;charset&lt;/code&gt; is specified, or if the &lt;code&gt;charset&lt;/code&gt; given is not recognized by the email package, the body is decoded using the default ASCII charset.</source>
          <target state="translated">当&lt;em&gt;解码&lt;/em&gt;为 &lt;code&gt;False&lt;/code&gt; （默认值）时，正文将以字符串形式返回，而不对&lt;em&gt;Content-Transfer-Encoding进行解码&lt;/em&gt;。但是，对于8位的&lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;，尝试使用 &lt;code&gt;replace&lt;/code&gt; 错误处理程序，使用&lt;em&gt;Content-Type&lt;/em&gt;标头指定的 &lt;code&gt;charset&lt;/code&gt; 对原始字节进行解码。如果未指定任何 &lt;code&gt;charset&lt;/code&gt; ，或者电子邮件包无法识别给定的 &lt;code&gt;charset&lt;/code&gt; ，则使用默认的ASCII字符集对正文进行解码。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8896ffa0276b29fe5abcec59ab4dbb6132b4621" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;default_section&lt;/em&gt; is given, it specifies the name for the special section holding default values for other sections and interpolation purposes (normally named &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt;). This value can be retrieved and changed on runtime using the &lt;code&gt;default_section&lt;/code&gt; instance attribute.</source>
          <target state="translated">当&lt;em&gt;default_section&lt;/em&gt;给出，它指定为其他部分和内插的目的（通常称为特殊部分保持默认值名称 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; ）。可以使用 &lt;code&gt;default_section&lt;/code&gt; 实例属性在运行时检索和更改此值。</target>
        </trans-unit>
        <trans-unit id="6ec4070356db325dd5a3a1a7a7c4a6d9c8470430" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;delimiters&lt;/em&gt; is given, it is used as the set of substrings that divide keys from values. When &lt;em&gt;comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in otherwise empty lines. Comments can be indented. When &lt;em&gt;inline_comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in non-empty lines.</source>
          <target state="translated">当&lt;em&gt;分隔符&lt;/em&gt;给出，它被用作一组，从值分割密钥的子串。当&lt;em&gt;comment_prefixes&lt;/em&gt;给出，它将被用作集前缀，否则空行注释子的。注释可以缩进。当&lt;em&gt;inline_comment_prefixes&lt;/em&gt;给出，它将被用作集子的，在非空行前缀的意见。</target>
        </trans-unit>
        <trans-unit id="017422042ed5196395fe163f83a712b974664f00" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;fileobj&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the &lt;em&gt;filename&lt;/em&gt; argument is only used to be included in the &lt;strong&gt;gzip&lt;/strong&gt; file header, which may include the original filename of the uncompressed file. It defaults to the filename of &lt;em&gt;fileobj&lt;/em&gt;, if discernible; otherwise, it defaults to the empty string, and in this case the original filename is not included in the header.</source>
          <target state="translated">当&lt;em&gt;fileobj&lt;/em&gt;不是 &lt;code&gt;None&lt;/code&gt; 时，&lt;em&gt;filename&lt;/em&gt;参数仅用于包含在&lt;strong&gt;gzip&lt;/strong&gt;文件头中，该头可能包含未压缩文件的原始文件名。如果可以识别，则默认为&lt;em&gt;fileobj&lt;/em&gt;的文件名；否则，它默认为空字符串，在这种情况下，原始文件名不包含在标题中。</target>
        </trans-unit>
        <trans-unit id="e007940c1a1ac1b90ed239aaae563d08c3c83e5c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; attempts to copy all metadata from the &lt;em&gt;src&lt;/em&gt; symbolic link to the newly-created &lt;em&gt;dst&lt;/em&gt; symbolic link. However, this functionality is not available on all platforms. On platforms where some or all of this functionality is unavailable, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; will preserve all the metadata it can; &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; never raises an exception because it cannot preserve file metadata.</source>
          <target state="translated">当&lt;em&gt;follow_symlinks&lt;/em&gt;为false，并且&lt;em&gt;src&lt;/em&gt;是符号链接时，&lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt;尝试将所有元数据从&lt;em&gt;src&lt;/em&gt;符号链接复制到新创建的&lt;em&gt;dst&lt;/em&gt;符号链接。但是，此功能并非在所有平台上都可用。在某些或所有不具备此功能的平台上，&lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt;将保留所有可能的元数据。&lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt;永远不会引发异常，因为它无法保留文件元数据。</target>
        </trans-unit>
        <trans-unit id="ef749f2221652284c69ca1d8aca13dd2c69b4877" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a descriptor (such as a normal Python function, &lt;a href=&quot;functions#classmethod&quot;&gt;&lt;code&gt;classmethod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;abstractmethod()&lt;/code&gt; or another instance of &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt;), calls to &lt;code&gt;__get__&lt;/code&gt; are delegated to the underlying descriptor, and an appropriate &lt;a href=&quot;#partial-objects&quot;&gt;partial object&lt;/a&gt; returned as the result.</source>
          <target state="translated">当&lt;em&gt;func&lt;/em&gt;是描述符（例如普通的Python函数，&lt;a href=&quot;functions#classmethod&quot;&gt; &lt;code&gt;classmethod()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;abstractmethod()&lt;/code&gt; 或&lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; 的&lt;/a&gt;另一个实例）时，对 &lt;code&gt;__get__&lt;/code&gt; 的调用将委托给基础描述符，并返回适当的&lt;a href=&quot;#partial-objects&quot;&gt;部分对象&lt;/a&gt;作为结果。</target>
        </trans-unit>
        <trans-unit id="2a7099d0edd318bbd39005c2813b14b352de9cce" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a non-descriptor callable, an appropriate bound method is created dynamically. This behaves like a normal Python function when used as a method: the &lt;em&gt;self&lt;/em&gt; argument will be inserted as the first positional argument, even before the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;keywords&lt;/em&gt; supplied to the &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">当&lt;em&gt;func&lt;/em&gt;是可调用的非描述符时，将动态创建适当的绑定方法。当用作方法时，其行为类似于普通的Python函数：&lt;em&gt;self&lt;/em&gt;参数将作为第一个位置参数插入，甚至在提供给&lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; &lt;/a&gt;构造函数的&lt;em&gt;args&lt;/em&gt;和&lt;em&gt;关键字&lt;/em&gt;之前。</target>
        </trans-unit>
        <trans-unit id="45e75310ec28936ea5e8f063d0b326f7a35ceaaa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;limits&lt;/em&gt; is not given the function returns the &lt;em&gt;resource&lt;/em&gt; limit of the process &lt;em&gt;pid&lt;/em&gt;. When &lt;em&gt;limits&lt;/em&gt; is given the &lt;em&gt;resource&lt;/em&gt; limit of the process is set and the former resource limit is returned.</source>
          <target state="translated">当&lt;em&gt;限制&lt;/em&gt;没有给出函数返回的&lt;em&gt;资源&lt;/em&gt;的过程中限制&lt;em&gt;的pid&lt;/em&gt;。当&lt;em&gt;限制&lt;/em&gt;给出&lt;em&gt;的资源&lt;/em&gt;的过程中限制设置并返回前资源限制。</target>
        </trans-unit>
        <trans-unit id="e06b2c5a32e26f67b12baa218e1362803c4f76e3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;operation&lt;/em&gt; is not specified or &lt;code&gt;'open'&lt;/code&gt;, this acts like double-clicking the file in Windows Explorer, or giving the file name as an argument to the &lt;strong&gt;start&lt;/strong&gt; command from the interactive command shell: the file is opened with whatever application (if any) its extension is associated.</source>
          <target state="translated">如果未指定&lt;em&gt;操作&lt;/em&gt;或 &lt;code&gt;'open'&lt;/code&gt; ，则类似于在Windows资源管理器中双击文件，或从交互式命令外壳将文件名作为&lt;strong&gt;启动&lt;/strong&gt;命令的参数：通过任何应用程序（如果有）打开文件）与其扩展名相关联。</target>
        </trans-unit>
        <trans-unit id="821a2ea402d2f70a801f8008ac1f17c8a85bc5fa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;pathsegments&lt;/em&gt; is empty, the current directory is assumed:</source>
          <target state="translated">当&lt;em&gt;pathsegments&lt;/em&gt;为空时，将使用当前目录：</target>
        </trans-unit>
        <trans-unit id="75967987830adb468980e21d08d3b79aba8262fe" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;section&lt;/em&gt; is not given, return a list of &lt;em&gt;section_name&lt;/em&gt;, &lt;em&gt;section_proxy&lt;/em&gt; pairs, including DEFAULTSECT.</source>
          <target state="translated">如果未提供&lt;em&gt;section&lt;/em&gt;，则返回&lt;em&gt;section_name&lt;/em&gt;和&lt;em&gt;section_proxy&lt;/em&gt;对的列表，包括DEFAULTSECT。</target>
        </trans-unit>
        <trans-unit id="ceee677568b16b47671c5f9b32ba5aa7d309179a" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;skipkeys&lt;/em&gt; is false (the default) the function raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when a key of a dictionary is not a string, otherwise such keys are skipped.</source>
          <target state="translated">如果&lt;em&gt;skipkeys&lt;/em&gt;为false（默认值），则当字典的键不是字符串时，该函数将引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;，否则将跳过此类键。</target>
        </trans-unit>
        <trans-unit id="472dd01686c20762dc7bf928e1bdbe2e019a8702" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;sort_keys&lt;/em&gt; is true (the default) the keys for dictionaries will be written to the plist in sorted order, otherwise they will be written in the iteration order of the dictionary.</source>
          <target state="translated">当&lt;em&gt;sort_keys&lt;/em&gt;为true（默认值）时，字典的键将以排序顺序写入plist，否则它们将以字典的迭代顺序写入。</target>
        </trans-unit>
        <trans-unit id="c2f903cfa4c4022ca7d7343290d72e1caad4bcee" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;st&lt;/em&gt; represents an &lt;code&gt;'eval'&lt;/code&gt; form, this function returns &lt;code&gt;True&lt;/code&gt;, otherwise it returns &lt;code&gt;False&lt;/code&gt;. This is useful, since code objects normally cannot be queried for this information using existing built-in functions. Note that the code objects created by &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt; cannot be queried like this either, and are identical to those created by the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">当&lt;em&gt;st&lt;/em&gt;表示 &lt;code&gt;'eval'&lt;/code&gt; 形式时，此函数返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。这很有用，因为通常无法使用现有的内置函数来查询代码对象以获取此信息。注意，&lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt;创建的代码对象也不能像这样查询，并且与内置&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt;函数创建的代码对象相同。</target>
        </trans-unit>
        <trans-unit id="c4701dad121dbacff21ec8bfc48ee5a248faeaec" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the mapping will be added to the official MIME types, otherwise to the non-standard ones.</source>
          <target state="translated">当&lt;em&gt;strict&lt;/em&gt;为 &lt;code&gt;True&lt;/code&gt; （默认值）时，该映射将添加到官方MIME类型，否则将添加到非标准MIME类型。</target>
        </trans-unit>
        <trans-unit id="1c8f2e3f887ca166194ca9ecc8d2f3c166b6328e" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the parser won&amp;rsquo;t allow for any section or option duplicates while reading from a single source (file, string or dictionary), raising &lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt;&lt;code&gt;DuplicateSectionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt;&lt;code&gt;DuplicateOptionError&lt;/code&gt;&lt;/a&gt;. When &lt;em&gt;empty_lines_in_values&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (default: &lt;code&gt;True&lt;/code&gt;), each empty line marks the end of an option. Otherwise, internal empty lines of a multiline option are kept as part of the value. When &lt;em&gt;allow_no_value&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (default: &lt;code&gt;False&lt;/code&gt;), options without values are accepted; the value held for these is &lt;code&gt;None&lt;/code&gt; and they are serialized without the trailing delimiter.</source>
          <target state="translated">当&lt;em&gt;strict&lt;/em&gt;为 &lt;code&gt;True&lt;/code&gt; （默认值）时，解析器在从单个源（文件，字符串或字典）读取时不允许重复任何节或选项，从而引发&lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt; &lt;code&gt;DuplicateSectionError&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt; &lt;code&gt;DuplicateOptionError&lt;/code&gt; &lt;/a&gt;。当&lt;em&gt;empty_lines_in_values&lt;/em&gt;为 &lt;code&gt;False&lt;/code&gt; （默认值： &lt;code&gt;True&lt;/code&gt; ）时，每个空行都标记一个选项的结尾。否则，多行选项的内部空行将保留为值的一部分。当&lt;em&gt;allow_no_value&lt;/em&gt;为 &lt;code&gt;True&lt;/code&gt; （默认值： &lt;code&gt;False&lt;/code&gt; ）时，接受不带值的选项；否则为0。持有的这些价值是 &lt;code&gt;None&lt;/code&gt; 并且它们被序列化而没有尾随定界符。</target>
        </trans-unit>
        <trans-unit id="13434fcf0e93bac1cc2c94533fc5d1edd99c06f4" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;symlinks&lt;/em&gt; is false, if the file pointed by the symlink doesn&amp;rsquo;t exist, an exception will be added in the list of errors raised in an &lt;a href=&quot;#shutil.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; exception at the end of the copy process. You can set the optional &lt;em&gt;ignore_dangling_symlinks&lt;/em&gt; flag to true if you want to silence this exception. Notice that this option has no effect on platforms that don&amp;rsquo;t support &lt;a href=&quot;os#os.symlink&quot;&gt;&lt;code&gt;os.symlink()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当&lt;em&gt;symlinks&lt;/em&gt;为false时，如果symlink指向的文件不存在，则在复制过程结束时，将在&lt;a href=&quot;#shutil.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;异常中引发的错误列表中添加一个异常。如果要使此异常静音，可以将可选的&lt;em&gt;ignore_dangling_symlinks&lt;/em&gt;标志设置为true。请注意，此选项在不支持&lt;a href=&quot;os#os.symlink&quot;&gt; &lt;code&gt;os.symlink()&lt;/code&gt; 的&lt;/a&gt;平台上无效。</target>
        </trans-unit>
        <trans-unit id="dc2a3c9dea5d3009f072403af68bc41dbee55be1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</source>
          <target state="translated">当&lt;em&gt;自上而下&lt;/em&gt;是 &lt;code&gt;True&lt;/code&gt; ，调用者可以修改&lt;em&gt;dirnames中&lt;/em&gt;就地（可能使用列表&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt;或切片分配）和&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;将只迭代到他们的名字留在子目录&lt;em&gt;dirnames中&lt;/em&gt; ;这可用于修剪搜索，施加特定的访问顺序，甚至可在调用者再次恢复&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;之前向&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;告知调用者创建或重命名的目录。修改&lt;em&gt;dirnames中&lt;/em&gt;，当&lt;em&gt;自上而下&lt;/em&gt;的 &lt;code&gt;False&lt;/code&gt; 对行走的行为没有影响，因为在自下而上的模式在目录&lt;em&gt;dirnames中&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;在生成&lt;em&gt;dirpath&lt;/em&gt;本身之前生成。</target>
        </trans-unit>
        <trans-unit id="7132c69782a8b6829ef6b03b540baba57ab12b2e" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</source>
          <target state="translated">当&lt;em&gt;自上而下&lt;/em&gt;是 &lt;code&gt;True&lt;/code&gt; ，调用者可以修改&lt;em&gt;dirnames中&lt;/em&gt;就地（可能使用列表&lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt;或切片分配）和&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;将只迭代到他们的名字留在子目录&lt;em&gt;dirnames中&lt;/em&gt;; 这可用于修剪搜索，施加特定的访问顺序，甚至可在调用者再次恢复&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;之前向&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;告知调用者创建或重命名的目录。修改&lt;em&gt;dirnames中&lt;/em&gt;，当&lt;em&gt;自上而下&lt;/em&gt;的 &lt;code&gt;False&lt;/code&gt; 对行走的行为没有影响，因为在自下而上的模式在目录&lt;em&gt;dirnames中&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;在生成&lt;em&gt;dirpath&lt;/em&gt;本身之前生成。</target>
        </trans-unit>
        <trans-unit id="40cb053f7928b5af0b380bb285ed3b898bb57205" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;pydoc&lt;/strong&gt; generates documentation, it uses the current environment and path to locate modules. Thus, invoking &lt;strong&gt;pydoc spam&lt;/strong&gt; documents precisely the version of the module you would get if you started the Python interpreter and typed &lt;code&gt;import spam&lt;/code&gt;.</source>
          <target state="translated">当&lt;strong&gt;是pydoc&lt;/strong&gt;生成文档，它使用当前的环境和定位模块的路径。因此，调用&lt;strong&gt;pydoc spam会&lt;/strong&gt;精确地记录您启动Python解释器并输入 &lt;code&gt;import spam&lt;/code&gt; 时将获得的模块版本。</target>
        </trans-unit>
        <trans-unit id="966d03fa55cf89b971f2711329e87cfb6a8d70ef" translate="yes" xml:space="preserve">
          <source>When DST ends (the &amp;ldquo;end&amp;rdquo; line), there&amp;rsquo;s a potentially worse problem: there&amp;rsquo;s an hour that can&amp;rsquo;t be spelled unambiguously in local wall time: the last hour of daylight time. In Eastern, that&amp;rsquo;s times of the form 5:MM UTC on the day daylight time ends. The local wall clock leaps from 1:59 (daylight time) back to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous. &lt;code&gt;astimezone()&lt;/code&gt; mimics the local clock&amp;rsquo;s behavior by mapping two adjacent UTC hours into the same local hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when converted to Eastern, but earlier times have the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute set to 0 and the later times have it set to 1. For example, at the Fall back transition of 2016, we get:</source>
          <target state="translated">当DST结束（&amp;ldquo;结束&amp;rdquo;行）时，可能会出现一个更严重的问题：在当地的墙上时间，不能明确地拼写一个小时：夏令时的最后一个小时。在东部，白天的时间是5：MM UTC。当地壁钟再次从1:59（夏令时）跳回到1:00（标准时间）。 1：MM形式的当地时间是模棱两可的。 &lt;code&gt;astimezone()&lt;/code&gt; 通过将两个相邻的UTC小时映射到同一本地时间来模拟本地时钟的行为。在&amp;ldquo;东部&amp;rdquo;示例中，格式为5：MM和6：MM的UTC时间在转换为&amp;ldquo;东部&amp;rdquo;时都映射为1：MM，但是较早的时间将&lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;属性设置为0，较晚的时间将其设置为1。例如，在2016年的后备过渡中，我们得到：</target>
        </trans-unit>
        <trans-unit id="f9e5d2b07f1f34036b37e1fe11345da1aa1e1630" translate="yes" xml:space="preserve">
          <source>When DST starts (the &amp;ldquo;start&amp;rdquo; line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesn&amp;rsquo;t really make sense on that day, so &lt;code&gt;astimezone(Eastern)&lt;/code&gt; won&amp;rsquo;t deliver a result with &lt;code&gt;hour == 2&lt;/code&gt; on the day DST begins. For example, at the Spring forward transition of 2016, we get:</source>
          <target state="translated">DST开始时（&amp;ldquo;开始&amp;rdquo;行），本地壁钟从1:59跳到3:00。格式为2：MM的时间在该天实际上没有意义，因此 &lt;code&gt;astimezone(Eastern)&lt;/code&gt; 在DST开始的那一天不会传递 &lt;code&gt;hour == 2&lt;/code&gt; 的结果。例如，在2016年春季向前过渡中，我们得到：</target>
        </trans-unit>
        <trans-unit id="607bcef959d2c892c1b6a1b372716350bf979b2f" translate="yes" xml:space="preserve">
          <source>When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand, using the configuration dialog, under Options, instead Options. Once it happens, the solution may be to delete one or more of the configuration files.</source>
          <target state="translated">首次启动IDLE时，它将尝试读取 &lt;code&gt;~/.idlerc/&lt;/code&gt; （〜是用户的主目录）中的用户配置文件。如果有问题，应显示一条错误消息。抛开随机磁盘故障，可以通过从不使用配置对话框（在&amp;ldquo;选项&amp;rdquo;下而是&amp;ldquo;选项&amp;rdquo;下）手动编辑文件来避免这种情况。一旦发生，解决方案可能是删除一个或多个配置文件。</target>
        </trans-unit>
        <trans-unit id="33e01015396bc2a1d42f9b6722c229ffeab0414f" translate="yes" xml:space="preserve">
          <source>When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand. Instead, use the configuration dialog, under Options. Once there is an error in a user configuration file, the best solution may be to delete it and start over with the settings dialog.</source>
          <target state="translated">首次启动IDLE时，它将尝试读取 &lt;code&gt;~/.idlerc/&lt;/code&gt; （〜是用户的主目录）中的用户配置文件。如果有问题，应显示一条错误消息。抛开随机磁盘故障，可以通过从不手动编辑文件来防止这种情况发生。而是使用&amp;ldquo;选项&amp;rdquo;下的配置对话框。一旦用户配置文件中出现错误，最好的解决方案是删除该错误并从设置对话框重新开始。</target>
        </trans-unit>
        <trans-unit id="8e8cfacfb0ec66c495be055f582089d68c4b5869" translate="yes" xml:space="preserve">
          <source>When Python code uses the &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module to change the locale, this also affects the embedding application. If the embedding application doesn&amp;rsquo;t want this to happen, it should remove the &lt;code&gt;_locale&lt;/code&gt; extension module (which does all the work) from the table of built-in modules in the &lt;code&gt;config.c&lt;/code&gt; file, and make sure that the &lt;code&gt;_locale&lt;/code&gt; module is not accessible as a shared library.</source>
          <target state="translated">当Python代码使用&lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt;模块更改语言环境时，这也会影响嵌入应用程序。如果嵌入式应用程序不希望发生这种情况，则应从 &lt;code&gt;config.c&lt;/code&gt; 文件中的内置模块表中删除 &lt;code&gt;_locale&lt;/code&gt; 扩展模块（完成所有工作），并确保 &lt;code&gt;_locale&lt;/code&gt; 模块不是可作为共享库访问。</target>
        </trans-unit>
        <trans-unit id="b5f41d4f67b29d3c1098269b891e9bec309ad5e3" translate="yes" xml:space="preserve">
          <source>When Shell has the focus, it controls the keyboard and screen. This is normally transparent, but functions that directly access the keyboard and screen will not work. These include system-specific functions that determine whether a key has been pressed and if so, which.</source>
          <target state="translated">当Shell拥有焦点时,它会控制键盘和屏幕。这通常是透明的,但直接访问键盘和屏幕的功能将无法工作。这些功能包括系统特有的功能,这些功能确定是否有键被按下,如果有,则确定哪个键。</target>
        </trans-unit>
        <trans-unit id="7a359f4fa5e01180f16295319eaf53142e2c0994" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object is passed in response to a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;dt.tzinfo&lt;/code&gt; is the same object as &lt;em&gt;self&lt;/em&gt;. &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods can rely on this, unless user code calls &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods directly. The intent is that the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods interpret &lt;em&gt;dt&lt;/em&gt; as being in local time, and not need worry about objects in other timezones.</source>
          <target state="translated">当传递&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;对象以响应&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;方法时， &lt;code&gt;dt.tzinfo&lt;/code&gt; 是与&lt;em&gt;self&lt;/em&gt;相同的对象。除非用户代码直接调用&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;方法，否则&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;方法可以依赖于此。目的是&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;方法将&lt;em&gt;dt&lt;/em&gt;解释为本地时间，而无需担心其他时区的对象。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc52f05baa4394318109ef8dd16b0838e7819096" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="a87ed137d28adb4e7367125bf334be63876e2c24" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="4e6e7fb6abd8fd4a202f9606c8570fc783915cb4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">当&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例是基于一个创建&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;例如，&lt;em&gt;状态&lt;/em&gt;和&lt;em&gt;X-状态&lt;/em&gt;标头省略，下面的转换发生：</target>
        </trans-unit>
        <trans-unit id="ca33d6c3c9d25ed20394d7c3deaa901e7846bdec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s original headers are modified, the visible headers are not automatically modified to correspond. This method updates the visible headers as follows: each visible header with a corresponding original header is set to the value of the original header, each visible header without a corresponding original header is removed, and any of &lt;em&gt;Date&lt;/em&gt;, &lt;em&gt;From&lt;/em&gt;, &lt;em&gt;Reply-To&lt;/em&gt;, &lt;em&gt;To&lt;/em&gt;, &lt;em&gt;CC&lt;/em&gt;, and &lt;em&gt;Subject&lt;/em&gt; that are present in the original headers but not the visible headers are added to the visible headers.</source>
          <target state="translated">当&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例的原始标题被修改，可见标题不会自动修改对应。此方法如下更新可见标头：将具有相应原始标头的每个可见标头设置为原始标头的值，删除没有相应原始标头的每个可见标头，以及&lt;em&gt;Date&lt;/em&gt;，&lt;em&gt;From&lt;/em&gt;，&lt;em&gt;Reply-To&lt;/em&gt;，&lt;em&gt;To中的任何一个&lt;/em&gt;，原始标题中存在的&lt;em&gt;CC&lt;/em&gt;，&lt;em&gt;Subject&lt;/em&gt;和但不是可见标题的&lt;em&gt;Subject&lt;/em&gt;被添加到可见标题中。</target>
        </trans-unit>
        <trans-unit id="75531aef3bfb04565ed01de282e0e8a5dd90cd56" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="a351f9e4fca060cf05b544590758e13c938d87a1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="1152ba9f8c4290368623aeaac928cca549892729" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">当&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例是基于一个创建&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;例如，&lt;em&gt;状态&lt;/em&gt;和&lt;em&gt;X-状态&lt;/em&gt;标头省略，下面的转换发生：</target>
        </trans-unit>
        <trans-unit id="ebde1da7e650fdde9e9869ca15dbe9af33e8273e" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;实例时，将复制&amp;ldquo; From&amp;rdquo;行，并且所有标志都直接对应：</target>
        </trans-unit>
        <trans-unit id="b0a451fe8c2a75c0a9d07b757e5b645a5db0c95a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object is created, it will inherit the authentication key of its parent process, although this may be changed by setting &lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt;&lt;code&gt;authkey&lt;/code&gt;&lt;/a&gt; to another byte string.</source>
          <target state="translated">当一个&lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;被创建的对象，它会继承父进程的认证密钥，尽管这可以通过设置来改变&lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt; &lt;code&gt;authkey&lt;/code&gt; &lt;/a&gt;到另一字节串。</target>
        </trans-unit>
        <trans-unit id="bd552e17015aa5c66496ae4f45468cddbe08da34" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is created, it acquires a policy. If the message is created by a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt;, a policy passed to the parser will be the policy used by the message it creates. If the message is created by the program, then the policy can be specified when it is created. When a message is passed to a &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;, the generator uses the policy from the message by default, but you can also pass a specific policy to the generator that will override the one stored on the message object.</source>
          <target state="translated">当&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt;对象被创建，它获取的策略。如果消息是由&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt;创建的，则传递给解析器的策略将是其创建的消息所使用的策略。如果消息是由程序创建的，则可以在创建策略时指定该策略。当消息传递给&lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt;，生成器默认使用消息中的策略，但是您也可以将特定策略传递给生成器，该策略将覆盖存储在消息对象上的策略。</target>
        </trans-unit>
        <trans-unit id="796474d1752f90ea152f5dd6af4e1499894479a4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</source>
          <target state="translated">当&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;生成器&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;协程&lt;/a&gt;函数返回时，将引发新的&lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt;实例，并且该函数返回的值用作异常构造函数的 &lt;code&gt;value&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="d12afd02904407ac827bc33a9ab049515e5bb6a2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</source>
          <target state="translated">当&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;生成器&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;协程&lt;/a&gt;函数返回时，将引发新的&lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt;实例，并且该函数返回的值将用作异常构造函数的 &lt;code&gt;value&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="f43590acc1cf538fae98de86cea41d189b3c470b" translate="yes" xml:space="preserve">
          <source>When a Future object is &lt;em&gt;awaited&lt;/em&gt; it means that the coroutine will wait until the Future is resolved in some other place.</source>
          <target state="translated">当&lt;em&gt;等待&lt;/em&gt; Future对象时，它意味着协程将等待，直到在其他地方解析Future。</target>
        </trans-unit>
        <trans-unit id="a501ed1c9da143e744360045a70756ab3a3c2bbc" translate="yes" xml:space="preserve">
          <source>When a HTTP/1.1 compliant server receives an &lt;code&gt;Expect: 100-continue&lt;/code&gt; request header it responds back with a &lt;code&gt;100 Continue&lt;/code&gt; followed by &lt;code&gt;200
OK&lt;/code&gt; headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can chose to send &lt;code&gt;417
Expectation Failed&lt;/code&gt; as a response header and &lt;code&gt;return False&lt;/code&gt;.</source>
          <target state="translated">当符合HTTP / 1.1的服务器收到 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 请求标头时，它将返回 &lt;code&gt;100 Continue&lt;/code&gt; 和 &lt;code&gt;200 OK&lt;/code&gt; 标头。如果服务器不希望客户端继续，则可以重写此方法以引发错误。例如，服务器可以选择发送 &lt;code&gt;417 Expectation Failed&lt;/code&gt; 作为响应头，并 &lt;code&gt;return False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f1159e7b0d3c34483e2df19f60fd60e258658c" translate="yes" xml:space="preserve">
          <source>When a binary (or in-place) method returns &lt;code&gt;NotImplemented&lt;/code&gt; the interpreter will try the reflected operation on the other type (or some other fallback, depending on the operator). If all attempts return &lt;code&gt;NotImplemented&lt;/code&gt;, the interpreter will raise an appropriate exception. Incorrectly returning &lt;code&gt;NotImplemented&lt;/code&gt; will result in a misleading error message or the &lt;code&gt;NotImplemented&lt;/code&gt; value being returned to Python code.</source>
          <target state="translated">当二进制（或就地）方法返回 &lt;code&gt;NotImplemented&lt;/code&gt; 时，解释器将尝试对其他类型（或其他后备情况，具体取决于运算符）的反射操作。如果所有尝试都返回 &lt;code&gt;NotImplemented&lt;/code&gt; ，则解释器将引发适当的异常。错误地返回 &lt;code&gt;NotImplemented&lt;/code&gt; 将导致产生误导性的错误消息，或者将 &lt;code&gt;NotImplemented&lt;/code&gt; 值返回给Python代码。</target>
        </trans-unit>
        <trans-unit id="63fc5ba727ad83fc978cb83426ef44950fb22f0c" translate="yes" xml:space="preserve">
          <source>When a client connects, you&amp;rsquo;ll call &lt;code&gt;accept()&lt;/code&gt; on the socket to get the new socket from the other end, and use the context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method to create a server-side SSL socket for the connection:</source>
          <target state="translated">当客户端连接时，您将在套接字上调用 &lt;code&gt;accept()&lt;/code&gt; 以从另一端获取新的套接字，并使用上下文的&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt;方法为该连接创建服务器端SSL套接字：</target>
        </trans-unit>
        <trans-unit id="14355459d065a2126b707c1cdaf9a9ce0eb37d01" translate="yes" xml:space="preserve">
          <source>When a coroutine function is called, but not awaited (e.g. &lt;code&gt;coro()&lt;/code&gt; instead of &lt;code&gt;await coro()&lt;/code&gt;) or the coroutine is not scheduled with &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt;, asyncio will emit a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当协程函数被调用但未等待时（例如， &lt;code&gt;coro()&lt;/code&gt; 而不是 &lt;code&gt;await coro()&lt;/code&gt; ）或未使用&lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt;调度协程时，asyncio将发出&lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="80027fbdb3d8bf1a0774de4650e2b1aab343032a" translate="yes" xml:space="preserve">
          <source>When a coroutine is wrapped into a &lt;em&gt;Task&lt;/em&gt; with functions like &lt;a href=&quot;#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; the coroutine is automatically scheduled to run soon:</source>
          <target state="translated">当协程被包装到具有&lt;a href=&quot;#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt;之类的功能的&lt;em&gt;Task中时&lt;/em&gt;，协程将自动计划很快运行：</target>
        </trans-unit>
        <trans-unit id="29bdbe2316b1cfa1ea855e4c3c8a620f07d98c69" translate="yes" xml:space="preserve">
          <source>When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The &lt;em&gt;timeout&lt;/em&gt; parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).</source>
          <target state="translated">当通过多个连接访问数据库，并且其中一个进程修改了数据库时，SQLite数据库将被锁定，直到提交该事务为止。该&lt;em&gt;超时&lt;/em&gt;参数指定连接应该多长时间等待锁消失，直到引发异常。超时参数的默认值为5.0（五秒）。</target>
        </trans-unit>
        <trans-unit id="58541f13ed67949530f68a704b5ad0ef345cd0ab" translate="yes" xml:space="preserve">
          <source>When a foreign function is called, each actual argument is passed to the &lt;code&gt;from_param()&lt;/code&gt; class method of the items in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple, this method allows adapting the actual argument to an object that the foreign function accepts. For example, a &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; item in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple will convert a string passed as argument into a bytes object using ctypes conversion rules.</source>
          <target state="translated">调用外部函数时，每个实际参数都传递给&lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt;元组中各项的 &lt;code&gt;from_param()&lt;/code&gt; 类方法，此方法允许将实际参数调整为外部函数接受的对象。例如，&lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt;元组中的&lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt;项将使用ctypes转换规则将作为参数传递的字符串转换为bytes对象。</target>
        </trans-unit>
        <trans-unit id="4b49ea0d90c828ff025e45c681bc2ce260779892" translate="yes" xml:space="preserve">
          <source>When a form is submitted in the &amp;ldquo;old&amp;rdquo; format (as the query string or as a single data part of type &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt;), the items will actually be instances of the class &lt;code&gt;MiniFieldStorage&lt;/code&gt;. In this case, the &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;filename&lt;/code&gt; attributes are always &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">当表单以&amp;ldquo;旧&amp;rdquo;格式（作为查询字符串或作为&lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt;类型的单个数据部分）提交时，这些项实际上将是 &lt;code&gt;MiniFieldStorage&lt;/code&gt; 类的实例。在这种情况下， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 属性始终为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff8b51f9aced6e65bff3f4369665f2c727321580" translate="yes" xml:space="preserve">
          <source>When a header parameter is encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format, &lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt;&lt;code&gt;Message.get_param&lt;/code&gt;&lt;/a&gt; may return a 3-tuple containing the character set, language, and value. &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt; turns this into a unicode string. Optional &lt;em&gt;errors&lt;/em&gt; is passed to the &lt;em&gt;errors&lt;/em&gt; argument of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; method; it defaults to &lt;code&gt;'replace'&lt;/code&gt;. Optional &lt;em&gt;fallback_charset&lt;/em&gt; specifies the character set to use if the one in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; header is not known by Python; it defaults to &lt;code&gt;'us-ascii'&lt;/code&gt;.</source>
          <target state="translated">当标头参数以&lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;格式编码时，&lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt; &lt;code&gt;Message.get_param&lt;/code&gt; &lt;/a&gt;可能返回一个包含字符集，语言和值的3元组。&lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt;将其转换为unicode字符串。可选&lt;em&gt;错误&lt;/em&gt;会传递给&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt;方法的&lt;em&gt;errors&lt;/em&gt;参数；它默认为 &lt;code&gt;'replace'&lt;/code&gt; 。可选的&lt;em&gt;fallback_charset&lt;/em&gt;指定在&lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;标头中的字符集不为Python所使用的字符集；它默认为 &lt;code&gt;'us-ascii'&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d710381a25baff3243b6945ecd27556783f6e36" translate="yes" xml:space="preserve">
          <source>When a letter is first encountered, it is missing from the mapping, so the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function calls &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; to supply a default count of zero. The increment operation then builds up the count for each letter.</source>
          <target state="translated">首次遇到字母时，映射中会缺少它，因此&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt;函数调用&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt;来提供默认计数零。然后，递增操作将为每个字母建立计数。</target>
        </trans-unit>
        <trans-unit id="32fdfac5d569cc8091912ece10591faa073940b3" translate="yes" xml:space="preserve">
          <source>When a logger is created, the level is set to &lt;code&gt;NOTSET&lt;/code&gt; (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level &lt;code&gt;WARNING&lt;/code&gt;.</source>
          <target state="translated">创建记录器时，该级别设置为 &lt;code&gt;NOTSET&lt;/code&gt; （当记录器是根记录器时，将处理所有消息，而当记录器是非根记录器时，将委派给父级）。请注意，根记录器的创建级别为 &lt;code&gt;WARNING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c121beda2f5083b1511f5b13c9899bd1d6ba9b6" translate="yes" xml:space="preserve">
          <source>When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</source>
          <target state="translated">重新加载模块时，将保留其字典（包含模块的全局变量）。名称的重新定义将覆盖旧的定义，因此通常这不是问题。如果模块的新版本未定义旧版本定义的名称，则保留旧定义。如果此功能维护模块的全局表或对象高速缓存，则可以利用该功能，从而可以利用模块的&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt;语句测试表是否存在，并在需要时跳过其初始化操作：</target>
        </trans-unit>
        <trans-unit id="f4b14b90e029d5b6f2e02ad6ead9c927a62548a2" translate="yes" xml:space="preserve">
          <source>When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</source>
          <target state="translated">重新加载模块时，将保留其字典（包含模块的全局变量）。名称的重新定义将覆盖旧的定义，因此通常这不是问题。如果模块的新版本未定义旧版本所定义的名称，则保留旧定义。如果此功能可以维护模块的全局表或对象缓存，则可以利用该功能，从而可以利用模块&amp;ndash;通过&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt;语句可以测试表的存在，并在需要时跳过其初始化：</target>
        </trans-unit>
        <trans-unit id="102ecaca0081733892ac9c0922de0ed7ff3dd82f" translate="yes" xml:space="preserve">
          <source>When a process exits, it attempts to terminate all of its daemonic child processes.</source>
          <target state="translated">当一个进程退出时,它试图终止所有的守护子进程。</target>
        </trans-unit>
        <trans-unit id="f779be4e8bb9308b016d27968c5002b765b616cf" translate="yes" xml:space="preserve">
          <source>When a program outputs text, the result is determined by the corresponding output device. When IDLE executes user code, &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; are connected to the display area of IDLE&amp;rsquo;s Shell. Some of its features are inherited from the underlying Tk Text widget. Others are programmed additions. Where it matters, Shell is designed for development rather than production runs.</source>
          <target state="translated">当程序输出文本时，结果由相应的输出设备确定。当IDLE执行用户代码时， &lt;code&gt;sys.stdout&lt;/code&gt; 和 &lt;code&gt;sys.stderr&lt;/code&gt; 连接到IDLE Shell的显示区域。它的某些功能是从基础Tk Text小部件继承的。其他是已编程的添加项。在重要的地方，壳牌专为开发而不是生产运行而设计。</target>
        </trans-unit>
        <trans-unit id="b145886bd139940193c9516b5aa5ce15ebcfa79a" translate="yes" xml:space="preserve">
          <source>When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</source>
          <target state="translated">当使用两个元素的元组序列作为&lt;em&gt;查询&lt;/em&gt;参数时，每个元组的第一个元素是键，第二个是值。value元素本身可以是一个序列，在这种情况下，如果可选参数&lt;em&gt;药q&lt;/em&gt;评估为 &lt;code&gt;True&lt;/code&gt; ，则为该键的值序列的每个元素生成由 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 分隔的单个 &lt;code&gt;key=value&lt;/code&gt; 对。编码字符串中参数的顺序将与序列中参数元组的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="5fe3fda7a7625ed5821ce75af517849bfdd0407e" translate="yes" xml:space="preserve">
          <source>When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; is evaluates to &lt;code&gt;True&lt;/code&gt;, individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</source>
          <target state="translated">当使用两个元素的元组序列作为&lt;em&gt;查询&lt;/em&gt;参数时，每个元组的第一个元素是键，第二个是值。值元素本身可以是一个序列，在这种情况下，如果可选参数&lt;em&gt;药q&lt;/em&gt;被评估为 &lt;code&gt;True&lt;/code&gt; ，则为键的值序列的每个元素生成由 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 分隔的单个 &lt;code&gt;key=value&lt;/code&gt; 对。编码字符串中参数的顺序将与序列中参数元组的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="7b4f273f661846773d9602c6e5e1ab50f3c31c65" translate="yes" xml:space="preserve">
          <source>When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">拍摄快照时，跟踪的跟踪仅限于&lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt;帧。请参见&lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="16c2b7b95a617a78019f007b1a6276ff133633a3" translate="yes" xml:space="preserve">
          <source>When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function. The original number of frames of the traceback is stored in the &lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt;&lt;code&gt;Traceback.total_nframe&lt;/code&gt;&lt;/a&gt; attribute. That allows to know if a traceback has been truncated by the traceback limit.</source>
          <target state="translated">拍摄快照时，跟踪的跟踪仅限于&lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt;帧。请参见&lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt;函数。追溯的原始帧数存储在&lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt; &lt;code&gt;Traceback.total_nframe&lt;/code&gt; &lt;/a&gt;属性中。这样就可以知道回溯限制是否已截断了回溯。</target>
        </trans-unit>
        <trans-unit id="f0093f870eef1dbea47bfba379efd8c3efa29578" translate="yes" xml:space="preserve">
          <source>When a test needs to look more deeply into the warnings, rather than just checking whether or not they occurred, code like this can be used:</source>
          <target state="translated">当测试需要更深入地研究警告时,而不仅仅是检查它们是否发生,可以使用这样的代码。</target>
        </trans-unit>
        <trans-unit id="3c867916e7973025c622ee7e9b701da070179716" translate="yes" xml:space="preserve">
          <source>When a tool or a library does not support annotations or encounters an unknown annotation it should just ignore it and treat annotated type as the underlying type.</source>
          <target state="translated">当一个工具或一个库不支持注释或遇到一个未知的注释时,它应该直接忽略它,并将注释类型视为底层类型。</target>
        </trans-unit>
        <trans-unit id="ace6e48a34ddec70b997e7ed4ef30cd1200e48dd" translate="yes" xml:space="preserve">
          <source>When a tuple is returned, it must be between two and six items long. Optional items can either be omitted, or &lt;code&gt;None&lt;/code&gt; can be provided as their value. The semantics of each item are in order:</source>
          <target state="translated">返回元组时，它的长度必须在2到6之间。可选项目可以被省略，或者 &lt;code&gt;None&lt;/code&gt; 能作为自己的价值来提供。每个项目的语义顺序如下：</target>
        </trans-unit>
        <trans-unit id="6e91619aaae63d9b1d57efcb79896aa3fdd3e043" translate="yes" xml:space="preserve">
          <source>When a tuple with an incorrect length is passed to a function expecting a &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt;, or having elements of the wrong type, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">当将长度不正确的元组传递给需要&lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; &lt;/a&gt;或具有错误类型的元素的函数时，将&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="122b5a9e98f973011f8c23604c35ee0744f01180" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active (i.e., the virtual environment&amp;rsquo;s Python interpreter is running), the attributes &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; point to the base directory of the virtual environment, whereas &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; point to the non-virtual environment Python installation which was used to create the virtual environment. If a virtual environment is not active, then &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; (they all point to a non-virtual environment Python installation).</source>
          <target state="translated">当虚拟环境处于活动状态时（即，虚拟环境的Python解释器正在运行），属性&lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt;指向虚拟环境的基本目录，而&lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt;指向非虚拟目录。虚拟环境用于创建虚拟环境的Python安装。如果虚拟环境是不活动的，则&lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt;相同&lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt;相同&lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt;（它们都指向到非虚拟环境Python安装）。</target>
        </trans-unit>
        <trans-unit id="49099fe8787d9b66d249172b5b8c16fae8d8776e" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active, any options that change the installation path will be ignored from all &lt;a href=&quot;distutils#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; configuration files to prevent projects being inadvertently installed outside of the virtual environment.</source>
          <target state="translated">当虚拟环境处于活动状态时，所有&lt;a href=&quot;distutils#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt;配置文件中都会更改任何更改安装路径的选项，以防止无意中将项目安装在虚拟环境之外。</target>
        </trans-unit>
        <trans-unit id="e73006af8303cac324a6bee6ebfb9a71386816b0" translate="yes" xml:space="preserve">
          <source>When activated, code entered in the Shell or run from an Editor will run under the debugger. In the Editor, breakpoints can be set with the context menu. This feature is still incomplete and somewhat experimental.</source>
          <target state="translated">激活后,在Shell中输入的代码或从编辑器中运行的代码将在调试器下运行。在编辑器中,可以通过上下文菜单设置断点。这个功能还不完整,还在试验阶段。</target>
        </trans-unit>
        <trans-unit id="cbdd2a51e4781c318a7a1a81e4c3eb4ba6ae291d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="ddc891f4c25b8225fd0001cdae26af6639e7537e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="e46ed5b47728cdf79b8e4b0ea7954bf28bac75b9" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">当&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例是基于一个创建&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;例如，&lt;em&gt;状态&lt;/em&gt;和&lt;em&gt;X-状态&lt;/em&gt;标头省略，下面的转换发生：</target>
        </trans-unit>
        <trans-unit id="e173b2ac8c61d6fbcc0ffb178a6f5c0aa5074e9e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="4a95e85d749bc7be23343bcb5277621335a1948d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例时，将根据&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例的交付日期生成&amp;ldquo;发件人&amp;rdquo;行，并进行以下转换：</target>
        </trans-unit>
        <trans-unit id="e255b577d6bbc86290e4f9d517b3ffbe62bbaae4" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="10d8c3d31070cdae2a2783c0d5f2693fbf078f89" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;实例时，将复制&amp;ldquo;发件人&amp;rdquo;行，并且所有标志都直接对应：</target>
        </trans-unit>
        <trans-unit id="286e3f12905a38714edf02bf122a3f8052a6268d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="4c4296d06ab3b5a40fe3f89cb3f43ef0aef304f8" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例时，将基于&lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; &lt;/a&gt;实例的交付日期生成&amp;ldquo;发件人&amp;rdquo;行，并进行以下转换：</target>
        </trans-unit>
        <trans-unit id="4d0342e5504d800d945bf2084fb63194683176ac" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">当基于&lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt;实例创建&lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; &lt;/a&gt;实例时，将发生以下转换：</target>
        </trans-unit>
        <trans-unit id="d9ae3b18f623ec44c4c53a80c85290adab2b1644" translate="yes" xml:space="preserve">
          <source>When an array object is printed or converted to a string, it is represented as &lt;code&gt;array(typecode, initializer)&lt;/code&gt;. The &lt;em&gt;initializer&lt;/em&gt; is omitted if the array is empty, otherwise it is a string if the &lt;em&gt;typecode&lt;/em&gt; is &lt;code&gt;'u'&lt;/code&gt;, otherwise it is a list of numbers. The string is guaranteed to be able to be converted back to an array with the same type and value using &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;, so long as the &lt;a href=&quot;#array.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; class has been imported using &lt;code&gt;from array import array&lt;/code&gt;. Examples:</source>
          <target state="translated">当将数组对象打印或转换为字符串时，它表示为 &lt;code&gt;array(typecode, initializer)&lt;/code&gt; 。在&lt;em&gt;初始化&lt;/em&gt;如果数组为空，则忽略，否则它是一个字符串，如果该&lt;em&gt;类型代码&lt;/em&gt;为 &lt;code&gt;'u'&lt;/code&gt; ，否则是号码清单。只要使用 &lt;code&gt;from array import array&lt;/code&gt; 导入了&lt;a href=&quot;#array.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;类，就可以确保使用&lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt;将字符串转换回具有相同类型和值的数组。例子：</target>
        </trans-unit>
        <trans-unit id="e57a24f717690d606e0285653c2532690dac8586" translate="yes" xml:space="preserve">
          <source>When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt;&lt;code&gt;sys.audit()&lt;/code&gt;&lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; are called first, followed by hooks added in the current interpreter.</source>
          <target state="translated">通过&lt;a href=&quot;#sys.audit&quot;&gt; &lt;code&gt;sys.audit()&lt;/code&gt; &lt;/a&gt;函数引发审核事件时，将按照添加事件名称和参数元组的顺序调用每个挂钩。首先调用由&lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt;添加的本机钩子，然后调用当前解释器中添加的钩子。</target>
        </trans-unit>
        <trans-unit id="da37c46dce4431adb3ffa8a7a4157478f4800eb9" translate="yes" xml:space="preserve">
          <source>When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt;&lt;code&gt;sys.audit()&lt;/code&gt;&lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; are called first, followed by hooks added in the current interpreter. Hooks can then log the event, raise an exception to abort the operation, or terminate the process entirely.</source>
          <target state="translated">通过&lt;a href=&quot;#sys.audit&quot;&gt; &lt;code&gt;sys.audit()&lt;/code&gt; &lt;/a&gt;函数引发审核事件时，将按照添加事件名称和参数元组的顺序调用每个挂钩。首先调用由&lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt;添加的本机钩子，然后调用当前解释器中添加的钩子。然后，挂钩可以记录该事件，引发异常以中止该操作或完全终止该过程。</target>
        </trans-unit>
        <trans-unit id="a060e94770f6ada605adcbe7b40294d9f24ee084" translate="yes" xml:space="preserve">
          <source>When an exception is raised and uncaught, the interpreter calls &lt;code&gt;sys.excepthook&lt;/code&gt; with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; in a Python program this happens just before the program exits. The handling of such top-level exceptions can be customized by assigning another three-argument function to &lt;code&gt;sys.excepthook&lt;/code&gt;.</source>
          <target state="translated">引发并捕获异常时，解释器将使用三个参数，异常类，异常实例和回溯对象调用 &lt;code&gt;sys.excepthook&lt;/code&gt; 。在交互式会话中，这恰好在控制权返回到提示之前发生。在Python程序中，这恰好在程序退出之前发生。可以通过将另一个三参数函数分配给 &lt;code&gt;sys.excepthook&lt;/code&gt; 来定制此类顶级异常的处理。</target>
        </trans-unit>
        <trans-unit id="bdd8e7c6427b144ae5ce58a35c7ec85907800fd4" translate="yes" xml:space="preserve">
          <source>When an expression, such as a function call, appears as a statement by itself with its return value not used or stored, it is wrapped in this container. &lt;code&gt;value&lt;/code&gt; holds one of the other nodes in this section, a &lt;a href=&quot;#ast.Constant&quot;&gt;&lt;code&gt;Constant&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Lambda&quot;&gt;&lt;code&gt;Lambda&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Yield&quot;&gt;&lt;code&gt;Yield&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.YieldFrom&quot;&gt;&lt;code&gt;YieldFrom&lt;/code&gt;&lt;/a&gt; node.</source>
          <target state="translated">当表达式（例如函数调用）本身作为语句出现而未使用或存储其返回值时，它将包装在此容器中。 &lt;code&gt;value&lt;/code&gt; 包含本节中的其他节点之一，即&lt;a href=&quot;#ast.Constant&quot;&gt; &lt;code&gt;Constant&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ast.Lambda&quot;&gt; &lt;code&gt;Lambda&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ast.Yield&quot;&gt; &lt;code&gt;Yield&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ast.YieldFrom&quot;&gt; &lt;code&gt;YieldFrom&lt;/code&gt; &lt;/a&gt;节点。</target>
        </trans-unit>
        <trans-unit id="b9ffd4c1a0ac9fe5d9bc16351d2b81ce70edccab" translate="yes" xml:space="preserve">
          <source>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt;&lt;code&gt;signal.ITIMER_REAL&lt;/code&gt;&lt;/a&gt; will deliver &lt;a href=&quot;#signal.SIGALRM&quot;&gt;&lt;code&gt;SIGALRM&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt;&lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt;&lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt;, and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt;&lt;code&gt;signal.ITIMER_PROF&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt;.</source>
          <target state="translated">当间隔计时器触发时，信号将发送到该进程。发送的信号取决于所使用的计时器。&lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt; &lt;code&gt;signal.ITIMER_REAL&lt;/code&gt; &lt;/a&gt;将提供&lt;a href=&quot;#signal.SIGALRM&quot;&gt; &lt;code&gt;SIGALRM&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt; &lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt; &lt;/a&gt;发送 &lt;code&gt;SIGVTALRM&lt;/code&gt; ，并&lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt; &lt;code&gt;signal.ITIMER_PROF&lt;/code&gt; &lt;/a&gt;将提供 &lt;code&gt;SIGPROF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98cb90ca3fe9c876d8490b4b2d59b0b2fc0154fc" translate="yes" xml:space="preserve">
          <source>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt;&lt;code&gt;signal.ITIMER_REAL&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGALRM&lt;/code&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt;&lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt;&lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt;, and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt;&lt;code&gt;signal.ITIMER_PROF&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt;.</source>
          <target state="translated">当间隔计时器触发时，信号将发送到该进程。发送的信号取决于所使用的计时器。&lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt; &lt;code&gt;signal.ITIMER_REAL&lt;/code&gt; &lt;/a&gt;将发送 &lt;code&gt;SIGALRM&lt;/code&gt; ，&lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt; &lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt; &lt;/a&gt;发送 &lt;code&gt;SIGVTALRM&lt;/code&gt; ，&lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt; &lt;code&gt;signal.ITIMER_PROF&lt;/code&gt; &lt;/a&gt;将发送 &lt;code&gt;SIGPROF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d729011a0caf801b2d3090cac48b85a3ba68cf73" translate="yes" xml:space="preserve">
          <source>When an object is put on a queue, the object is pickled and a background thread later flushes the pickled data to an underlying pipe. This has some consequences which are a little surprising, but should not cause any practical difficulties &amp;ndash; if they really bother you then you can instead use a queue created with a &lt;a href=&quot;#multiprocessing-managers&quot;&gt;manager&lt;/a&gt;.</source>
          <target state="translated">将对象放入队列时，将对对象进行酸洗，然后后台线程将酸洗的数据刷新到基础管道。这带来了一些令人惊讶的后果，但不会造成任何实际困难-如果它们确实困扰您，那么您可以使用由&lt;a href=&quot;#multiprocessing-managers&quot;&gt;manager&lt;/a&gt;创建的队列。</target>
        </trans-unit>
        <trans-unit id="46c6a7ab062a3f1ac7a1fa12015f2ab3e6c6e8ef" translate="yes" xml:space="preserve">
          <source>When an ordinary Python script raises an unhandled exception (for whatever reason: of a typo in a module name, a file that can&amp;rsquo;t be opened, etc.), the Python interpreter prints a nice traceback and exits. While the Python interpreter will still do this when your CGI script raises an exception, most likely the traceback will end up in one of the HTTP server&amp;rsquo;s log files, or be discarded altogether.</source>
          <target state="translated">当普通的Python脚本引发未处理的异常（出于某种原因：模块名称中的错字，无法打开的文件等）时，Python解释器会打印出一个不错的回溯并退出。尽管当CGI脚本引发异常时Python解释器仍会执行此操作，但回溯很可能最终会出现在HTTP服务器的日志文件之一中，或者被完全丢弃。</target>
        </trans-unit>
        <trans-unit id="f0b18b0dca198469e2e5821b568a8af8553f7137" translate="yes" xml:space="preserve">
          <source>When another &lt;em&gt;operation&lt;/em&gt; is given, it must be a &amp;ldquo;command verb&amp;rdquo; that specifies what should be done with the file. Common verbs documented by Microsoft are &lt;code&gt;'print'&lt;/code&gt; and &lt;code&gt;'edit'&lt;/code&gt; (to be used on files) as well as &lt;code&gt;'explore'&lt;/code&gt; and &lt;code&gt;'find'&lt;/code&gt; (to be used on directories).</source>
          <target state="translated">当给出另一个&lt;em&gt;操作时&lt;/em&gt;，它必须是一个&amp;ldquo;命令动词&amp;rdquo;，该命令动词指定应该对文件执行的操作。Microsoft记录的常见动词是 &lt;code&gt;'print'&lt;/code&gt; 和 &lt;code&gt;'edit'&lt;/code&gt; （将在文件上使用）以及 &lt;code&gt;'explore'&lt;/code&gt; 和 &lt;code&gt;'find'&lt;/code&gt; （将在目录上使用）。</target>
        </trans-unit>
        <trans-unit id="c4d9c23255dc7b8ca6f19ef5a940eb877d9642dd" translate="yes" xml:space="preserve">
          <source>When another data type is mixed in, the &lt;code&gt;value&lt;/code&gt; attribute is &lt;em&gt;not the same&lt;/em&gt; as the enum member itself, although it is equivalent and will compare equal.</source>
          <target state="translated">当另一数据类型被混入，该 &lt;code&gt;value&lt;/code&gt; 属性是&lt;em&gt;不一样&lt;/em&gt;的枚举构件本身，虽然它是等效，将比较相等。</target>
        </trans-unit>
        <trans-unit id="782a74b6093e9a274767f8a985a07199d8c71046" translate="yes" xml:space="preserve">
          <source>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</source>
          <target state="translated">尝试使用任何整数转换代码打包非整数时，如果非整数具有&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt;方法，则在打包前将调用该方法将参数转换为整数。</target>
        </trans-unit>
        <trans-unit id="b4bcdffe284cc4209a6efda0e7fcb83ad577a516" translate="yes" xml:space="preserve">
          <source>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</source>
          <target state="translated">尝试使用任何整数转换代码打包非整数时，如果非整数具有&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt;方法，则在打包之前将调用该方法以将参数转换为整数。</target>
        </trans-unit>
        <trans-unit id="38f8d78459f2077063513420c80633ee6ca35e36" translate="yes" xml:space="preserve">
          <source>When called as a program from the command line, the following form is used:</source>
          <target state="translated">当从命令行作为程序调用时,使用以下形式。</target>
        </trans-unit>
        <trans-unit id="7774c1b19e4f3bda02017096fe4f300d221be9d7" translate="yes" xml:space="preserve">
          <source>When called with the entire population, this gives the population variance &amp;sigma;&amp;sup2;. When called on a sample instead, this is the biased sample variance s&amp;sup2;, also known as variance with N degrees of freedom.</source>
          <target state="translated">当与整个总体调用时，得出总体方差&amp;sigma;&amp;sup2;。相反，当调用样本时，这是偏差样本方差s&amp;sup2;，也称为N自由度方差。</target>
        </trans-unit>
        <trans-unit id="e1510a977d9eec8bae218f453f2180521adfa1a6" translate="yes" xml:space="preserve">
          <source>When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler while the test is being executed:</source>
          <target state="translated">当没有参数的情况下调用这个函数时,如果control-c处理程序已经被安装,那么这个函数就会删除它。这个函数也可以作为测试装饰器,在测试执行过程中临时删除处理程序。</target>
        </trans-unit>
        <trans-unit id="68b31def5bdc28465822c89803310f8ec7825150" translate="yes" xml:space="preserve">
          <source>When called, the generic function dispatches on the type of the first argument:</source>
          <target state="translated">当调用时,通用函数根据第一个参数的类型进行调度。</target>
        </trans-unit>
        <trans-unit id="49f7a0d990e54e7e4ff423f9bcf931e35657cbac" translate="yes" xml:space="preserve">
          <source>When calling the &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; constructor directly, &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; is the default. Since it does not authenticate the other peer, it can be insecure, especially in client mode where most of time you would like to ensure the authenticity of the server you&amp;rsquo;re talking to. Therefore, when in client mode, it is highly recommended to use &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. However, it is in itself not sufficient; you also have to check that the server certificate, which can be obtained by calling &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;, matches the desired service. For many protocols and applications, the service can be identified by the hostname; in this case, the &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; function can be used. This common check is automatically performed when &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;SSLContext.check_hostname&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">直接调用&lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt;构造函数时，默认&lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt;。由于它不对另一个对等方进行身份验证，因此它可能是不安全的，尤其是在客户端模式下，在大多数情况下，您希望确保与之对话的服务器的真实性。因此，在客户端模式下，强烈建议使用&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;。但是，这本身是不够的。您还必须检查可以通过调用&lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt;获得的服务器证书是否与所需的服务匹配。对于许多协议和应用程序，可以通过主机名来标识服务。在这种情况下，可以使用&lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt;函数。在以下情况下会自动执行此常规检查&lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;SSLContext.check_hostname&lt;/code&gt; &lt;/a&gt;已启用。</target>
        </trans-unit>
        <trans-unit id="4dc40bbe639d96f637bd93855f1791e60c735e90" translate="yes" xml:space="preserve">
          <source>When calling with the two argument form you omit the replacement object, and a mock is created for you and passed in as an extra argument to the decorated function:</source>
          <target state="translated">当使用两个参数形式调用时,你会省略替换对象,并为你创建一个mock,并作为装饰函数的一个额外参数传递进来。</target>
        </trans-unit>
        <trans-unit id="18e0548d845776f7d9fb1bb48334763d7bb375ac" translate="yes" xml:space="preserve">
          <source>When compared to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, this object lacks the following features:</source>
          <target state="translated">与&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;相比，此对象缺少以下功能：</target>
        </trans-unit>
        <trans-unit id="856a45270239471af6c5f0a357260107cdc44d90" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt;&lt;code&gt;hexdigest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">在验证例程&lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt; &lt;code&gt;hexdigest()&lt;/code&gt; &lt;/a&gt;的输出与外部提供的摘要进行比较时，建议使用&lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt;函数而不是 &lt;code&gt;==&lt;/code&gt; 运算符来减少定时攻击的脆弱性。</target>
        </trans-unit>
        <trans-unit id="92028d8951df45be6cbda2380b77dd7080678d69" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">在验证例程期间将&lt;a href=&quot;#hmac.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt;的输出与外部提供的摘要进行比较时，建议使用&lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt;函数而不是 &lt;code&gt;==&lt;/code&gt; 运算符，以减少定时攻击的脆弱性。</target>
        </trans-unit>
        <trans-unit id="cc34f0feb28081050c116e0b782b908cc2cd4bfa" translate="yes" xml:space="preserve">
          <source>When comparing unions, the argument order is ignored, e.g.:</source>
          <target state="translated">在比较联合体时,忽略了参数顺序,例如:。</target>
        </trans-unit>
        <trans-unit id="ed05a329db63e10d1f8fb992f1545e7cd8c147c7" translate="yes" xml:space="preserve">
          <source>When compiling a string with multi-line code in &lt;code&gt;'single'&lt;/code&gt; or &lt;code&gt;'eval'&lt;/code&gt; mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">在 &lt;code&gt;'single'&lt;/code&gt; 或 &lt;code&gt;'eval'&lt;/code&gt; 模式下用多行代码编译字符串时，输入必须以至少一个换行符终止。这是为了便于检测&lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt;模块中不完整和完整的语句。</target>
        </trans-unit>
        <trans-unit id="696dab8a84aeff4c3a2e883a2314face9ba4d539" translate="yes" xml:space="preserve">
          <source>When computing the next rollover time for the first time (when the handler is created), the last modification time of an existing log file, or else the current time, is used to compute when the next rotation will occur.</source>
          <target state="translated">当第一次计算下一次翻转时间时(创建处理程序时),使用现有日志文件的最后一次修改时间或当前时间来计算下一次翻转的时间。</target>
        </trans-unit>
        <trans-unit id="d884d8babe5a567edcfd0ea18f46faab02d32494" translate="yes" xml:space="preserve">
          <source>When connected, &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt;&lt;code&gt;NNTP_SSL&lt;/code&gt;&lt;/a&gt; objects support the following methods and attributes.</source>
          <target state="translated">连接后，&lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt; &lt;code&gt;NNTP_SSL&lt;/code&gt; &lt;/a&gt;对象支持以下方法和属性。</target>
        </trans-unit>
        <trans-unit id="060ff3bcb23f907c12e71640fb12cf92d2d0e3e5" translate="yes" xml:space="preserve">
          <source>When converting from a string, the string must not contain whitespace around the central &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; operator. For example, &lt;code&gt;complex('1+2j')&lt;/code&gt; is fine, but &lt;code&gt;complex('1 + 2j')&lt;/code&gt; raises &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从字符串转换时，字符串中的 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 运算符周围不能包含空格。例如， &lt;code&gt;complex('1+2j')&lt;/code&gt; 很好，但是 &lt;code&gt;complex('1 + 2j')&lt;/code&gt; 引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="729cf6941132415f4f8f822faa0d6fea63ed2df7" translate="yes" xml:space="preserve">
          <source>When converting from another time zone, the fold will be set to the correct value:</source>
          <target state="translated">当从其他时区转换时,折页将被设置为正确的值。</target>
        </trans-unit>
        <trans-unit id="c6c5e5ce837c0e22ffcd56a47571a9b383672bcb" translate="yes" xml:space="preserve">
          <source>When copying an existing archive, file objects supplied only need &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;readline&lt;/code&gt;, or &lt;code&gt;write&lt;/code&gt; methods. When creating an archive from a directory, if the target is a file object it will be passed to the &lt;code&gt;zipfile.ZipFile&lt;/code&gt; class, and must supply the methods needed by that class.</source>
          <target state="translated">复制现有档案时，提供的文件对象仅需要 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;readline&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 方法。从目录创建档案时，如果目标是文件对象，它将被传递到 &lt;code&gt;zipfile.ZipFile&lt;/code&gt; 类，并且必须提供该类所需的方法。</target>
        </trans-unit>
        <trans-unit id="62f08dfe8f53d7f93ca2ca215d1e0ef6f39c519e" translate="yes" xml:space="preserve">
          <source>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: &lt;code&gt;(start + step * i
for i in count())&lt;/code&gt;.</source>
          <target state="translated">当使用浮点数进行计数时，有时可以通过使用诸如以下代码（例如， &lt;code&gt;(start + step * i for i in count())&lt;/code&gt; 中用start + step * i代替i）来获得更好的精度。</target>
        </trans-unit>
        <trans-unit id="5a51eebc4aef573b36497fe8c2650ded21d78cac" translate="yes" xml:space="preserve">
          <source>When creating &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects from scratch, you often need to encode the payloads for transport through compliant mail servers. This is especially true for &lt;em&gt;image/*&lt;/em&gt; and &lt;em&gt;text/*&lt;/em&gt; type messages containing binary data.</source>
          <target state="translated">从头开始创建&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;对象时，通常需要对有效负载进行编码，以便通过兼容的邮件服务器进行传输。对于包含二进制数据的&lt;em&gt;image / *&lt;/em&gt;和&lt;em&gt;text / *&lt;/em&gt;类型的消息尤其如此。</target>
        </trans-unit>
        <trans-unit id="6c409f842f8763b8712502f5713a4839b3224fe8" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Call&lt;/code&gt; node, &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;keywords&lt;/code&gt; are required, but they can be empty lists. &lt;code&gt;starargs&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are optional.</source>
          <target state="translated">创建&amp;ldquo; &lt;code&gt;Call&lt;/code&gt; 节点时，必须使用 &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;keywords&lt;/code&gt; ，但它们可以为空列表。 &lt;code&gt;starargs&lt;/code&gt; 和 &lt;code&gt;kwargs&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="a423c248f1413b6e1e0f4f3faa51f5f733b512cd" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;DateHeader&lt;/code&gt;, &lt;em&gt;value&lt;/em&gt; may be &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance. This means, for example, that the following code is valid and does what one would expect:</source>
          <target state="translated">创建 &lt;code&gt;DateHeader&lt;/code&gt; 时，&lt;em&gt;值&lt;/em&gt;可能是&lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;实例。例如，这意味着以下代码有效，并且可以完成预期的工作：</target>
        </trans-unit>
        <trans-unit id="a4db0b5c5393d0800539c706fee74aab4223e2df" translate="yes" xml:space="preserve">
          <source>When creating a breakpoint, its associated filename should be in canonical form. If a &lt;em&gt;funcname&lt;/em&gt; is defined, a breakpoint hit will be counted when the first line of that function is executed. A conditional breakpoint always counts a hit.</source>
          <target state="translated">创建断点时，其关联的文件名应采用规范形式。如果&lt;em&gt;funcname的&lt;/em&gt;定义，则执行该功能的第一行当断点命中将被计数。有条件的断点始终算命中。</target>
        </trans-unit>
        <trans-unit id="672bf0c86c2581afe64984ce3a00746c2792ef5c" translate="yes" xml:space="preserve">
          <source>When creating new WSGI application objects, frameworks, servers, or middleware, it can be useful to validate the new code&amp;rsquo;s conformance using &lt;a href=&quot;#module-wsgiref.validate&quot;&gt;&lt;code&gt;wsgiref.validate&lt;/code&gt;&lt;/a&gt;. This module provides a function that creates WSGI application objects that validate communications between a WSGI server or gateway and a WSGI application object, to check both sides for protocol conformance.</source>
          <target state="translated">创建新的WSGI应用程序对象，框架，服务器或中间件时，使用&lt;a href=&quot;#module-wsgiref.validate&quot;&gt; &lt;code&gt;wsgiref.validate&lt;/code&gt; &lt;/a&gt;验证新代码的一致性可能很有用。该模块提供了创建WSGI应用程序对象的功能，该功能验证WSGI服务器或网关与WSGI应用程序对象之间的通信，以检查双方的协议一致性。</target>
        </trans-unit>
        <trans-unit id="3e5bb3321cca6ff1fb46c71f838479a459fa1e5d" translate="yes" xml:space="preserve">
          <source>When decompressing a stream, the window size must not be smaller than the size originally used to compress the stream; using a too-small value may result in an &lt;a href=&quot;#zlib.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; exception. The default &lt;em&gt;wbits&lt;/em&gt; value corresponds to the largest window size and requires a zlib header and trailer to be included.</source>
          <target state="translated">在对流进行解压缩时，窗口大小不得小于最初用于压缩流的大小。使用太小的值可能会导致&lt;a href=&quot;#zlib.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt;异常。默认的&lt;em&gt;wbits&lt;/em&gt;值对应于最大的窗口大小，并且需要包含zlib标头和尾标。</target>
        </trans-unit>
        <trans-unit id="4d74f26e8d112aef4595ce1a87bdb3b198f7b5e3" translate="yes" xml:space="preserve">
          <source>When decompressing, the value of the last modification time field in the most recently read header may be read from this attribute, as an integer. The initial value before reading any headers is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">解压缩时，可以从该属性中读取整数形式的最近读取的报头中的最后修改时间字段的值。读取任何标头之前的初始值为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3403f72d755a11055123ac4361d68696ca02cdee" translate="yes" xml:space="preserve">
          <source>When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the &lt;code&gt;values&lt;/code&gt; list, with a &lt;code&gt;None&lt;/code&gt; at the corresponding position in &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">使用字典文字进行字典解包时，要扩展的表达式将进入 &lt;code&gt;values&lt;/code&gt; 列表，并且在 &lt;code&gt;keys&lt;/code&gt; 的相应位置为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02833f75f25f075b18c22a28c5aa2ba25a8444fc" translate="yes" xml:space="preserve">
          <source>When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function which returns an empty &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;list.append()&lt;/code&gt; operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the &lt;code&gt;list.append()&lt;/code&gt; operation adds another value to the list. This technique is simpler and faster than an equivalent technique using &lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt;&lt;code&gt;dict.setdefault()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">首次遇到每个键时，它尚未在映射中；因此，将使用&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt;函数自动创建一个条目，该函数返回一个空&lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt;。然后， &lt;code&gt;list.append()&lt;/code&gt; 操作会将值附加到新列表。当再次遇到键时，查找将正常进行（返回该键的列表），并且 &lt;code&gt;list.append()&lt;/code&gt; 操作将另一个值添加到列表中。与使用&lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt; &lt;code&gt;dict.setdefault()&lt;/code&gt; &lt;/a&gt;的等效技术相比，该技术更简单，更快捷：</target>
        </trans-unit>
        <trans-unit id="e7a986ad80ec6a19bad35676d48184874aeb1f45" translate="yes" xml:space="preserve">
          <source>When editing code in an editor (as oppose to Shell), increase the available module-level names by running your code and not restarting the Shell thereafter. This is especially useful after adding imports at the top of a file. This also increases possible attribute completions.</source>
          <target state="translated">当在编辑器中编辑代码时(与Shell相反),通过运行你的代码并在此后不重新启动Shell来增加可用的模块级名称。这在文件顶部添加导入后特别有用。这也增加了可能的属性完成度。</target>
        </trans-unit>
        <trans-unit id="9887fe8e3c1a8945458c737be092d9fc035304db" translate="yes" xml:space="preserve">
          <source>When enabled on client-side sockets, the client signals the server that it supports post-handshake authentication.</source>
          <target state="translated">当在客户端套接字上启用时,客户端会向服务器发出信号,表示它支持握手后认证。</target>
        </trans-unit>
        <trans-unit id="4b197cf7dc7faf88b3cb2e54d710a0d303daee67" translate="yes" xml:space="preserve">
          <source>When enabled on server-side sockets, &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, too. The actual client cert exchange is delayed until &lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt;&lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt;&lt;/a&gt; is called and some I/O is performed.</source>
          <target state="translated">在服务器端套接字上启用时，&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; 也&lt;/a&gt;必须设置为&lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;。实际的客户端证书交换被延迟，直到调用&lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt; &lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt; &lt;/a&gt;并执行一些I / O 为止。</target>
        </trans-unit>
        <trans-unit id="a621755ca7f41470229f75442067ad0d1c20faff" translate="yes" xml:space="preserve">
          <source>When encountering a &lt;code&gt;multipart/related&lt;/code&gt;, check the &lt;code&gt;start&lt;/code&gt; parameter and if a part with a matching &lt;em&gt;Content-ID&lt;/em&gt; is found, consider only it when looking for candidate matches. Otherwise consider only the first (default root) part of the &lt;code&gt;multipart/related&lt;/code&gt;.</source>
          <target state="translated">遇到 &lt;code&gt;multipart/related&lt;/code&gt; 时，请检查 &lt;code&gt;start&lt;/code&gt; 参数，如果找到具有匹配&lt;em&gt;Content-ID&lt;/em&gt;的零件，则在寻找候选匹配项时仅考虑它。否则，仅考虑 &lt;code&gt;multipart/related&lt;/code&gt; 的第一部分（默认根）。</target>
        </trans-unit>
        <trans-unit id="d720d1be1de6b788b045c550171b49ace0d34e71" translate="yes" xml:space="preserve">
          <source>When executed without arguments &lt;a href=&quot;#unittest-test-discovery&quot;&gt;Test Discovery&lt;/a&gt; is started:</source>
          <target state="translated">在不带参数的情况下执行时，将启动&amp;ldquo; &lt;a href=&quot;#unittest-test-discovery&quot;&gt;测试发现&amp;rdquo;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d9f5758875cf66a5a33444f0562ccc5e99c8db03" translate="yes" xml:space="preserve">
          <source>When first created the logger has level &lt;code&gt;logging.NOTSET&lt;/code&gt; and no default handler. Messages sent to this logger will not by default propagate to the root logger.</source>
          <target state="translated">首次创建时，记录器具有级别 &lt;code&gt;logging.NOTSET&lt;/code&gt; 且没有默认处理程序。默认情况下，发送到该记录器的消息不会传播到根记录器。</target>
        </trans-unit>
        <trans-unit id="69309127fb83429d8269e5e345250adcff5991bf" translate="yes" xml:space="preserve">
          <source>When formatting a number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; and subclasses) with the &lt;code&gt;n&lt;/code&gt; type (ex: &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt;), the function temporarily sets the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale to the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale to decode &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; fields of &lt;code&gt;localeconv()&lt;/code&gt; if they are non-ASCII or longer than 1 byte, and the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale is different than the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale. This temporary change affects other threads.</source>
          <target state="translated">当使用 &lt;code&gt;n&lt;/code&gt; 类型（例如： &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt; ）格式化数字（&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt;，Decimal和子类）时，该函数会临时将 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境设置为 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境以进行解码 &lt;code&gt;localeconv()&lt;/code&gt; 的 &lt;code&gt;decimal_point&lt;/code&gt; 和 &lt;code&gt;thousands_sep&lt;/code&gt; 字段，如果它们是非ASCII或超过1个字节，并且 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境与 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境不同。此临时更改会影响其他线程。</target>
        </trans-unit>
        <trans-unit id="0c6c0444904253e2eedbaa36573956718aa2948c" translate="yes" xml:space="preserve">
          <source>When generating annotated listings, mark lines which were not executed with &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">生成带注释的列表时，标记未使用 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 执行的行。</target>
        </trans-unit>
        <trans-unit id="be8e8b32da74a37571c34b0e9517346b53020b30" translate="yes" xml:space="preserve">
          <source>When identifying things (such as host names) in the internet, it is often necessary to compare such identifications for &amp;ldquo;equality&amp;rdquo;. Exactly how this comparison is executed may depend on the application domain, e.g. whether it should be case-insensitive or not. It may be also necessary to restrict the possible identifications, to allow only identifications consisting of &amp;ldquo;printable&amp;rdquo; characters.</source>
          <target state="translated">在标识Internet中的事物（例如主机名）时，通常需要将此类标识进行&amp;ldquo;平等&amp;rdquo;比较。确切地说，如何执行此比较可能取决于应用程序域，例如，是否应该不区分大小写。也可能有必要限制可能的标识，以仅允许包含&amp;ldquo;可打印&amp;rdquo;字符的标识。</target>
        </trans-unit>
        <trans-unit id="9e7e37fe6162273e5e4281cf61c42ffd2d46e957" translate="yes" xml:space="preserve">
          <source>When implementing coroutine schedulers and for other advanced uses of generators, it is useful to determine whether a generator is currently executing, is waiting to start or resume or execution, or has already terminated. &lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt;&lt;code&gt;getgeneratorstate()&lt;/code&gt;&lt;/a&gt; allows the current state of a generator to be determined easily.</source>
          <target state="translated">在实现协程调度程序时以及对于生成器的其他高级用法时，确定生成器是当前正在执行，正在等待启动，恢复还是执行，还是已经终止是很有用的。&lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt; &lt;code&gt;getgeneratorstate()&lt;/code&gt; &lt;/a&gt;允许轻松确定发电机的当前状态。</target>
        </trans-unit>
        <trans-unit id="5376e91d28fee3241c94e60ac21eaf1934266aa4" translate="yes" xml:space="preserve">
          <source>When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the data needed to be written to the raw stream but it couldn&amp;rsquo;t accept all the data without blocking.</source>
          <target state="translated">在非阻塞模式下，如果需要将数据写入原始流，但如果不阻塞就无法接受所有数据，则会引发&lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="949c191a2b89d062d5cb3c84d7a255f7ab9b1114" translate="yes" xml:space="preserve">
          <source>When inheriting from &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; class defines an attribute &lt;em&gt;daemon_threads&lt;/em&gt;, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, meaning that Python will not exit until all threads created by &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; have exited.</source>
          <target state="translated">当从&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt;继承线程连接行为时，应明确声明希望线程在突然关闭时的行为。该&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt;类定义的属性&lt;em&gt;daemon_threads&lt;/em&gt;，这表明服务器是否应该等待线程终止。如果希望线程自主运行，则应显式设置该标志。默认值为&lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;，这意味着在退出&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt;创建的所有线程之前，Python不会退出。</target>
        </trans-unit>
        <trans-unit id="0c4ce52ce81abe52a94c5ca1b4e84054f0c345e6" translate="yes" xml:space="preserve">
          <source>When inheriting from generic classes, some type variables could be fixed:</source>
          <target state="translated">从通用类继承时,可以固定一些类型变量。</target>
        </trans-unit>
        <trans-unit id="d13155b8b331b5e8b4a6adbaa811a4f85484dce4" translate="yes" xml:space="preserve">
          <source>When initializing &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; (either at import time or whenever &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt;&lt;code&gt;reset_tzpath()&lt;/code&gt;&lt;/a&gt; is called with no arguments), the &lt;code&gt;zoneinfo&lt;/code&gt; module will use the environment variable &lt;code&gt;PYTHONTZPATH&lt;/code&gt;, if it exists, to set the search path.</source>
          <target state="translated">初始化&lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; 时&lt;/a&gt;（在导入时或每当不带参数调用&lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt; &lt;code&gt;reset_tzpath()&lt;/code&gt; 时&lt;/a&gt;）， &lt;code&gt;zoneinfo&lt;/code&gt; 模块将使用环境变量 &lt;code&gt;PYTHONTZPATH&lt;/code&gt; （如果存在）来设置搜索路径。</target>
        </trans-unit>
        <trans-unit id="2d57a9f5d007446cdead859ca66e2d6075df536d" translate="yes" xml:space="preserve">
          <source>When instantiated, &lt;em&gt;msg&lt;/em&gt; should be a human-readable description of the error. The optional &lt;em&gt;exception&lt;/em&gt; parameter, if given, should be &lt;code&gt;None&lt;/code&gt; or an exception that was caught by the parsing code and is being passed along as information.</source>
          <target state="translated">实例化后，&lt;em&gt;msg&lt;/em&gt;应该是该错误的易于理解的描述。可选的&lt;em&gt;exception&lt;/em&gt;参数（如果提供）应该为 &lt;code&gt;None&lt;/code&gt; 或由解析代码捕获并作为信息传递的异常。</target>
        </trans-unit>
        <trans-unit id="0a44c954d6ff4db8ecacb3e811d6941f43087b96" translate="yes" xml:space="preserve">
          <source>When interactive, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams are line-buffered. Otherwise, they are block-buffered like regular text files. You can override this value with the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/a&gt; command-line option.</source>
          <target state="translated">交互式时， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 流是行缓冲的。否则，它们像常规文本文件一样被块缓冲。您可以使用&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt; &lt;code&gt;-u&lt;/code&gt; &lt;/a&gt;命令行选项覆盖此值。</target>
        </trans-unit>
        <trans-unit id="c9d780f23a2b4601e2764bf38f20738f15f23667" translate="yes" xml:space="preserve">
          <source>When interactive, the &lt;code&gt;stdout&lt;/code&gt; stream is line-buffered. Otherwise, it is block-buffered like regular text files. The &lt;code&gt;stderr&lt;/code&gt; stream is line-buffered in both cases. You can make both streams unbuffered by passing the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-u&quot;&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/a&gt; command-line option or setting the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONUNBUFFERED&quot; id=&quot;index-36&quot;&gt;&lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt;&lt;/a&gt; environment variable.</source>
          <target state="translated">交互式时， &lt;code&gt;stdout&lt;/code&gt; 流是行缓冲的。否则，它将像常规文本文件一样被块缓冲。在两种情况下， &lt;code&gt;stderr&lt;/code&gt; 流都是行缓冲的。通过传递&lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-u&quot;&gt; &lt;code&gt;-u&lt;/code&gt; &lt;/a&gt;命令行选项或设置&lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONUNBUFFERED&quot; id=&quot;index-36&quot;&gt; &lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt; &lt;/a&gt;环境变量，可以使两个流都变得无缓冲。</target>
        </trans-unit>
        <trans-unit id="995afee8f4fa71b9b054d20a6203385ccf1bd50f" translate="yes" xml:space="preserve">
          <source>When invoked as a script, pdb will automatically enter post-mortem debugging if the program being debugged exits abnormally. After post-mortem debugging (or after normal exit of the program), pdb will restart the program. Automatic restarting preserves pdb&amp;rsquo;s state (such as breakpoints) and in most cases is more useful than quitting the debugger upon program&amp;rsquo;s exit.</source>
          <target state="translated">当作为脚本调用时，如果要调试的程序异常退出，pdb将自动进入事后调试。在事后调试之后（或在程序正常退出之后），pdb将重新启动该程序。自动重启会保留pdb的状态（例如断点），并且在大多数情况下比在程序退出时退出调试器更为有用。</target>
        </trans-unit>
        <trans-unit id="2539ba7b8e0eee8855621eedd477ec61c17b8f6b" translate="yes" xml:space="preserve">
          <source>When invoked from the command line, &lt;code&gt;python -m pickletools&lt;/code&gt; will disassemble the contents of one or more pickle files. Note that if you want to see the Python object stored in the pickle rather than the details of pickle format, you may want to use &lt;code&gt;-m pickle&lt;/code&gt; instead. However, when the pickle file that you want to examine comes from an untrusted source, &lt;code&gt;-m pickletools&lt;/code&gt; is a safer option because it does not execute pickle bytecode.</source>
          <target state="translated">从命令行调用时， &lt;code&gt;python -m pickletools&lt;/code&gt; 将反汇编一个或多个pickle文件的内容。请注意，如果要查看存储在pickle中的Python对象而不是pickle格式的详细信息，则可能要使用 &lt;code&gt;-m pickle&lt;/code&gt; 。但是，当您要检查的泡菜文件来自不受信任的来源时， &lt;code&gt;-m pickletools&lt;/code&gt; 是更安全的选择，因为它不执行泡菜字节码。</target>
        </trans-unit>
        <trans-unit id="4b61fed1c9136364f71b07a1ac9ee9de891cc79e" translate="yes" xml:space="preserve">
          <source>When invoked on an unlocked lock, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">在解锁的锁上调用时，将引发&lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a4c03388380d599f150c844d9f2270ba506b4b5" translate="yes" xml:space="preserve">
          <source>When invoked with &lt;em&gt;blocking&lt;/em&gt; set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;阻塞&lt;/em&gt;设置为false的情况下调用时，请勿阻塞。如果没有参数的调用将阻塞，则立即返回 &lt;code&gt;False&lt;/code&gt; ；否则，返回False。否则，执行与不带参数调用时相同的操作，并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3215b0285b31a2e686d7f6ba8334728310827391" translate="yes" xml:space="preserve">
          <source>When invoked with a &lt;em&gt;timeout&lt;/em&gt; other than &lt;code&gt;None&lt;/code&gt;, it will block for at most &lt;em&gt;timeout&lt;/em&gt; seconds. If acquire does not complete successfully in that interval, return &lt;code&gt;False&lt;/code&gt;. Return &lt;code&gt;True&lt;/code&gt; otherwise.</source>
          <target state="translated">当与调用&lt;em&gt;超时&lt;/em&gt;比其他 &lt;code&gt;None&lt;/code&gt; ，这将至多阻塞&lt;em&gt;超时&lt;/em&gt;秒。如果获取未在该时间间隔内成功完成，则返回 &lt;code&gt;False&lt;/code&gt; 。否则返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1e3e192edfe421df0ce1b99d20b60757870a5ac" translate="yes" xml:space="preserve">
          <source>When invoked with a positive, floating-point value for &lt;em&gt;timeout&lt;/em&gt;, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; as long as the lock can not be acquired. Invocations with a negative value for &lt;em&gt;timeout&lt;/em&gt; are equivalent to a &lt;em&gt;timeout&lt;/em&gt; of zero. Invocations with a &lt;em&gt;timeout&lt;/em&gt; value of &lt;code&gt;None&lt;/code&gt; (the default) set the timeout period to infinite. Note that the treatment of negative or &lt;code&gt;None&lt;/code&gt; values for &lt;em&gt;timeout&lt;/em&gt; differs from the implemented behavior in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;timeout&lt;/em&gt; argument has no practical implications if the &lt;em&gt;block&lt;/em&gt; argument is set to &lt;code&gt;False&lt;/code&gt; and is thus ignored. Returns &lt;code&gt;True&lt;/code&gt; if the lock has been acquired or &lt;code&gt;False&lt;/code&gt; if the timeout period has elapsed.</source>
          <target state="translated">当使用&lt;em&gt;超时&lt;/em&gt;的正浮点值调用&lt;em&gt;时&lt;/em&gt;，只要无法获取锁定，阻塞最多由&lt;em&gt;超时&lt;/em&gt;指定的秒数。&lt;em&gt;超时&lt;/em&gt;值为负的调用等效于零&lt;em&gt;超时&lt;/em&gt;。&lt;em&gt;超时&lt;/em&gt;值为&amp;ldquo; &lt;code&gt;None&lt;/code&gt; （默认值）的调用会将超时期限设置为无限。请注意，对&lt;em&gt;超时&lt;/em&gt;值为负或 &lt;code&gt;None&lt;/code&gt; 值的处理与&lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; 中&lt;/a&gt;实现的行为不同。该&lt;em&gt;超时&lt;/em&gt;参数没有实际意义，如果&lt;em&gt;块&lt;/em&gt;参数设置为&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;False&lt;/code&gt; ，因此被忽略。如果已获取锁定，则返回 &lt;code&gt;True&lt;/code&gt; ;如果超时时间已过，则返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7920fec1db552b1e56262de88d29376efd098e4" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If the lock has already been acquired (and thus is owned) by another process or thread, the current process or thread does not take ownership and the recursion level within the lock is not changed, resulting in a return value of &lt;code&gt;False&lt;/code&gt;. If the lock is in an unlocked state, the current process or thread takes ownership and the recursion level is incremented, resulting in a return value of &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;block&lt;/em&gt;参数设置为 &lt;code&gt;False&lt;/code&gt; 的情况下调用时，请勿阻止。如果该锁已被另一个进程或线程获取（并因此拥有），则当前进程或线程将不拥有所有权，并且锁内的递归级别不会更改，从而导致返回值 &lt;code&gt;False&lt;/code&gt; 。如果锁处于未锁定状态，则当前进程或线程将拥有所有权，并且递归级别将增加，从而导致返回值为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26d84ac2fed2d1d6bf35aca2492e7a51b1254f22" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt;, block until the lock is in an unlocked state (not owned by any process or thread) unless the lock is already owned by the current process or thread. The current process or thread then takes ownership of the lock (if it does not already have ownership) and the recursion level inside the lock increments by one, resulting in a return value of &lt;code&gt;True&lt;/code&gt;. Note that there are several differences in this first argument&amp;rsquo;s behavior compared to the implementation of &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt;&lt;code&gt;threading.RLock.acquire()&lt;/code&gt;&lt;/a&gt;, starting with the name of the argument itself.</source>
          <target state="translated">在将&lt;em&gt;block&lt;/em&gt;参数设置为 &lt;code&gt;True&lt;/code&gt; 的情况下调用时，除非锁定已由当前进程或线程拥有，否则将一直锁定直到锁处于未锁定状态（不属于任何进程或线程）。然后，当前进程或线程将获得该锁的所有权（如果尚未拥有该锁），并且该锁内的递归级别将递增1，从而导致返回值为 &lt;code&gt;True&lt;/code&gt; 。请注意，与参数&lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt; &lt;code&gt;threading.RLock.acquire()&lt;/code&gt; &lt;/a&gt;的实现相比，此第一个参数的行为有几个不同之处，从参数本身的名称开始。</target>
        </trans-unit>
        <trans-unit id="3adb7479baf4957251699e2c3f19fc3aa413e8ed" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If a call with &lt;em&gt;blocking&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt; would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, set the lock to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;阻塞&lt;/em&gt;参数设置为 &lt;code&gt;False&lt;/code&gt; 的情况下调用时，请勿阻塞。如果将&lt;em&gt;阻塞&lt;/em&gt;设置为 &lt;code&gt;True&lt;/code&gt; 的呼叫将阻塞，则立即返回 &lt;code&gt;False&lt;/code&gt; ；否则，返回0 。否则，将锁设置为locked，然后返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00fee988fe737d2ff47fe5cb9ac426ebebb9888c" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), block until the lock is unlocked, then set it to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;阻塞&lt;/em&gt;参数设置为 &lt;code&gt;True&lt;/code&gt; （默认值）的情况下调用时，&lt;em&gt;阻塞&lt;/em&gt;直到锁被解锁，然后将其设置为lock并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530808d79c5fd710b7d8c76ae1e70cbe8c467712" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;阻塞&lt;/em&gt;参数设置为false的情况下调用时，请勿阻塞。如果没有参数的调用将阻塞，则立即返回 &lt;code&gt;False&lt;/code&gt; ；否则，返回False。否则，执行与不带参数调用时相同的操作，并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c7b2e8b0136f5c21ccc0f8e3de7ab48e6ebe94d" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to true, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">在将&lt;em&gt;阻塞&lt;/em&gt;参数设置为true的情况下调用时，与在不使用参数的情况下调用时执行相同的操作，然后返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b710997372980f7c6061e22520300cdf15b9436e" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. A &lt;em&gt;timeout&lt;/em&gt; argument of &lt;code&gt;-1&lt;/code&gt; specifies an unbounded wait. It is forbidden to specify a &lt;em&gt;timeout&lt;/em&gt; when &lt;em&gt;blocking&lt;/em&gt; is false.</source>
          <target state="translated">在将浮点&lt;em&gt;超时&lt;/em&gt;参数设置为正值的情况下调用&lt;em&gt;时&lt;/em&gt;，只要无法获取锁定，最多阻塞&lt;em&gt;超时&lt;/em&gt;指定的秒数。一个&lt;em&gt;超时&lt;/em&gt;的参数 &lt;code&gt;-1&lt;/code&gt; 指定了一个无限的等待。禁止指定&lt;em&gt;超时&lt;/em&gt;时&lt;em&gt;阻塞&lt;/em&gt;是假的。</target>
        </trans-unit>
        <trans-unit id="2140b5f65b8ba6f4b2bd371613d7e60332a2c64a" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. Return &lt;code&gt;True&lt;/code&gt; if the lock has been acquired, false if the timeout has elapsed.</source>
          <target state="translated">在将浮点&lt;em&gt;超时&lt;/em&gt;参数设置为正值的情况下调用&lt;em&gt;时&lt;/em&gt;，只要无法获取锁定，最多阻塞&lt;em&gt;超时&lt;/em&gt;指定的秒数。如果已获取锁定，则返回 &lt;code&gt;True&lt;/code&gt; ;如果超时，则返回false。</target>
        </trans-unit>
        <trans-unit id="dec567edc06d3b9893b2e7ade359dacbc93eb18e" translate="yes" xml:space="preserve">
          <source>When invoked without arguments:</source>
          <target state="translated">当调用无参数时。</target>
        </trans-unit>
        <trans-unit id="2c15ab576c9f7d8bf5867e09294955007cfb98cc" translate="yes" xml:space="preserve">
          <source>When invoked without arguments: if this thread already owns the lock, increment the recursion level by one, and return immediately. Otherwise, if another thread owns the lock, block until the lock is unlocked. Once the lock is unlocked (not owned by any thread), then grab ownership, set the recursion level to one, and return. If more than one thread is blocked waiting until the lock is unlocked, only one at a time will be able to grab ownership of the lock. There is no return value in this case.</source>
          <target state="translated">在没有参数的情况下调用时:如果这个线程已经拥有锁,则将递归级别递增1,并立即返回。否则,如果另一个线程拥有该锁,则阻塞,直到该锁被解锁。一旦锁被解锁(不被任何线程拥有),则抢夺所有权,将递归级别设为1,然后返回。如果有多个线程被阻塞,等待锁被解锁,那么每次只有一个线程能够抢夺锁的所有权。在这种情况下,没有返回值。</target>
        </trans-unit>
        <trans-unit id="b96b14764f1e6579b1b14032256583960d45abf4" translate="yes" xml:space="preserve">
          <source>When invoking external programs, make sure they can be found. Usually, this means using absolute path names &amp;mdash; &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; is usually not set to a very useful value in a CGI script.</source>
          <target state="translated">调用外部程序时，请确保可以找到它们。通常，这意味着使用绝对路径名- 在CGI脚本中 &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 通常不会设置为非常有用的值。</target>
        </trans-unit>
        <trans-unit id="5d49406082e5d3ef12b51588b4ee561e90642dbb" translate="yes" xml:space="preserve">
          <source>When more than one coroutine is blocked in &lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the lock to be unlocked, only one coroutine eventually proceeds.</source>
          <target state="translated">当不超过一个协程被阻止在&lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; 中&lt;/a&gt;等待锁被解锁时，最终只有一个协程进行。</target>
        </trans-unit>
        <trans-unit id="d757253ec842e92c57d2efdf31bbd2d4624ea4d1" translate="yes" xml:space="preserve">
          <source>When more than one key is provided, then additional keys are used as secondary criteria when there is equality in all keys selected before them. For example, &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; will sort all the entries according to their function name, and resolve all ties (identical function names) by sorting by file name.</source>
          <target state="translated">如果提供了多个键，则当在它们前面选择的所有键都相等时，其他键将用作次要条件。例如， &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; 将根据它们的函数名称对所有条目进行排序，并通过按文件名进行排序来解析所有联系（相同的函数名称）。</target>
        </trans-unit>
        <trans-unit id="ea00e1f9fb3773e02544a5c95c6a57b4665e0f48" translate="yes" xml:space="preserve">
          <source>When more than one pickle file are specified, print given preamble before each disassembly.</source>
          <target state="translated">当指定多个pickle文件时,在每次拆解前打印给定的序言。</target>
        </trans-unit>
        <trans-unit id="9a26198a4f09f3862bf0af3dbd7f4aeaa0993b74" translate="yes" xml:space="preserve">
          <source>When more than one thread is blocked in &lt;a href=&quot;#threading.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the state to turn to unlocked, only one thread proceeds when a &lt;a href=&quot;#threading.Lock.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.</source>
          <target state="translated">如果在&lt;a href=&quot;#threading.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;阻塞了多个线程等待状态变为解锁状态，则当&lt;a href=&quot;#threading.Lock.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;调用将状态重置为解锁状态时，只有一个线程继续运行；否则，只有一个线程继续运行。等待线程之一继续前进的过程尚未定义，并且可能因实现而异。</target>
        </trans-unit>
        <trans-unit id="cf9260c7b087d873e21d35d7eab19843d9322220" translate="yes" xml:space="preserve">
          <source>When multiple objects are disassembled, preserve memo between disassemblies.</source>
          <target state="translated">当多个对象被拆解时,在拆解之间保留备忘录。</target>
        </trans-unit>
        <trans-unit id="d053b7be9831593a88afbed3a5bc6fa5f8506a45" translate="yes" xml:space="preserve">
          <source>When multiple processes with differing UIDs assign sockets to an identical UDP socket address with &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, incoming packets can become randomly distributed among the sockets.</source>
          <target state="translated">当多个具有不同UID的进程使用 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 将套接字分配给相同的UDP套接字地址时，传入的数据包可能会随机分布在套接字之间。</target>
        </trans-unit>
        <trans-unit id="3978842d4de4c74136c46923ed77df9264119bc1" translate="yes" xml:space="preserve">
          <source>When no &lt;em&gt;path&lt;/em&gt; is specified, the results of &lt;a href=&quot;os#os.environ&quot;&gt;&lt;code&gt;os.environ()&lt;/code&gt;&lt;/a&gt; are used, returning either the &amp;ldquo;PATH&amp;rdquo; value or a fallback of &lt;a href=&quot;os#os.defpath&quot;&gt;&lt;code&gt;os.defpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未指定&lt;em&gt;路径&lt;/em&gt;，则使用&lt;a href=&quot;os#os.environ&quot;&gt; &lt;code&gt;os.environ()&lt;/code&gt; &lt;/a&gt;的结果，返回&amp;ldquo; PATH&amp;rdquo;值或&lt;a href=&quot;os#os.defpath&quot;&gt; &lt;code&gt;os.defpath&lt;/code&gt; &lt;/a&gt;的后备。</target>
        </trans-unit>
        <trans-unit id="60fa2ee1d31958e02f93bc8b356815374fa1d19b" translate="yes" xml:space="preserve">
          <source>When no explicit alignment is given, preceding the &lt;em&gt;width&lt;/em&gt; field by a zero (&lt;code&gt;'0'&lt;/code&gt;) character enables sign-aware zero-padding for numeric types. This is equivalent to a &lt;em&gt;fill&lt;/em&gt; character of &lt;code&gt;'0'&lt;/code&gt; with an &lt;em&gt;alignment&lt;/em&gt; type of &lt;code&gt;'='&lt;/code&gt;.</source>
          <target state="translated">如果未给出明确的对齐方式，则在&lt;em&gt;宽度&lt;/em&gt;字段前面加上零（ &lt;code&gt;'0'&lt;/code&gt; ）字符可启用数字类型的符号感知零填充。这等同于一个&lt;em&gt;填充&lt;/em&gt;的字符 &lt;code&gt;'0'&lt;/code&gt; 用一个&lt;em&gt;对准&lt;/em&gt;的类型 &lt;code&gt;'='&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6065b034a11abad3d959f6d6989348ca636780d3" translate="yes" xml:space="preserve">
          <source>When no match is found, return whatever is available instead, possibly empty bytes. Raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; if the connection is closed and no cooked data is available.</source>
          <target state="translated">如果找不到匹配项，则返回任何可用的内容，可能为空字节。抬起&lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt;如果连接被关闭，没有煮熟的数据是可用的。</target>
        </trans-unit>
        <trans-unit id="4d974deeca1f469c2b5a6fa343cdf431c097d9b5" translate="yes" xml:space="preserve">
          <source>When one pastes code into Shell, it is not compiled and possibly executed until one hits</source>
          <target state="translated">当一个人把代码粘贴到Shell中时,它不会被编译,也不可能被执行,直到打到</target>
        </trans-unit>
        <trans-unit id="df4178055aedbbbaa771fd15ebbc33ceeea78f97" translate="yes" xml:space="preserve">
          <source>When one uses &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;Connection.recv&lt;/code&gt;&lt;/a&gt;, the data received is automatically unpickled. Unfortunately unpickling data from an untrusted source is a security risk. Therefore &lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt;&lt;code&gt;Client()&lt;/code&gt;&lt;/a&gt; use the &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module to provide digest authentication.</source>
          <target state="translated">当使用&lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;Connection.recv&lt;/code&gt; 时&lt;/a&gt;，接收到的数据将自动解开。不幸的是，从不受信任的来源中抽取数据会带来安全风险。因此，&lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt; &lt;code&gt;Client()&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt;模块提供摘要身份验证。</target>
        </trans-unit>
        <trans-unit id="defeae2dfe201352a7bdcfddb389352110acc25b" translate="yes" xml:space="preserve">
          <source>When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means &lt;code&gt;r&quot;\\&quot;&lt;/code&gt;. Without raw string notation, one must use &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;, making the following lines of code functionally identical:</source>
          <target state="translated">当要匹配文字反斜杠时，必须在正则表达式中将其转义。使用原始字符串表示法，这意味着 &lt;code&gt;r&quot;\\&quot;&lt;/code&gt; 。如果没有原始字符串符号，则必须使用 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; ，从而使以下代码行在功能上相同：</target>
        </trans-unit>
        <trans-unit id="8cb74b28bda4099bc79fd005722acae57fc6872e" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the &lt;em&gt;format&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;. In this case, the &lt;em&gt;check&lt;/em&gt; and &lt;em&gt;preset&lt;/em&gt; arguments should not be used.</source>
          <target state="translated">打开文件进行读取时，&lt;em&gt;format&lt;/em&gt;和&lt;em&gt;filter&lt;/em&gt;参数的含义与&lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt;相同。在这种情况下，不应使用&lt;em&gt;check&lt;/em&gt;和&lt;em&gt;预设&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="2aa3b23d9c311bebcce2d82c3b6469767bdd03e8" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the input file may be the concatenation of multiple separate compressed streams. These are transparently decoded as a single logical stream.</source>
          <target state="translated">当打开一个文件进行读取时,输入文件可能是多个独立压缩流的合并。这些压缩流会被透明地解码为一个单一的逻辑流。</target>
        </trans-unit>
        <trans-unit id="b40148ffbc845740f7452ddadab19f55d4a0a189" translate="yes" xml:space="preserve">
          <source>When opening a file for writing, the &lt;em&gt;format&lt;/em&gt;, &lt;em&gt;check&lt;/em&gt;, &lt;em&gt;preset&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt;&lt;code&gt;LZMACompressor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开文件进行写入时，&lt;em&gt;format&lt;/em&gt;，&lt;em&gt;check&lt;/em&gt;，&lt;em&gt;预置&lt;/em&gt;和&lt;em&gt;filter&lt;/em&gt;参数的含义与&lt;a href=&quot;#lzma.LZMACompressor&quot;&gt; &lt;code&gt;LZMACompressor&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="0673e8efa9150c8c2de8c19210f1833061eca945" translate="yes" xml:space="preserve">
          <source>When operating in POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following parsing rules.</source>
          <target state="translated">当以POSIX模式运行时，&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt;将尝试遵守以下解析规则。</target>
        </trans-unit>
        <trans-unit id="07b63f3da75da4705f49d38fa15d535bbd4d2a24" translate="yes" xml:space="preserve">
          <source>When operating in non-POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following rules.</source>
          <target state="translated">在非POSIX模式下运行时，&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt;将尝试遵守以下规则。</target>
        </trans-unit>
        <trans-unit id="45df7e43b0ea1fa603be77df6607a8c7e5ebe833" translate="yes" xml:space="preserve">
          <source>When packing a value &lt;code&gt;x&lt;/code&gt; using one of the integer formats (&lt;code&gt;'b'&lt;/code&gt;, &lt;code&gt;'B'&lt;/code&gt;, &lt;code&gt;'h'&lt;/code&gt;, &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'i'&lt;/code&gt;, &lt;code&gt;'I'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'L'&lt;/code&gt;, &lt;code&gt;'q'&lt;/code&gt;, &lt;code&gt;'Q'&lt;/code&gt;), if &lt;code&gt;x&lt;/code&gt; is outside the valid range for that format then &lt;a href=&quot;#struct.error&quot;&gt;&lt;code&gt;struct.error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">进行包装时的值 &lt;code&gt;x&lt;/code&gt; 用的整数格式之一（ &lt;code&gt;'b'&lt;/code&gt; ， &lt;code&gt;'B'&lt;/code&gt; ， &lt;code&gt;'h'&lt;/code&gt; ， &lt;code&gt;'H'&lt;/code&gt; ， &lt;code&gt;'i'&lt;/code&gt; ， &lt;code&gt;'I'&lt;/code&gt; ， &lt;code&gt;'l'&lt;/code&gt; ， &lt;code&gt;'L'&lt;/code&gt; ， &lt;code&gt;'q'&lt;/code&gt; ， &lt;code&gt;'Q'&lt;/code&gt; ），如果 &lt;code&gt;x&lt;/code&gt; 在该格式的有效范围之外，则会引发&lt;a href=&quot;#struct.error&quot;&gt; &lt;code&gt;struct.error&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ff53ce933cb55e5d195fd8da14f24a9ea8a7dec" translate="yes" xml:space="preserve">
          <source>When passing a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance as the &lt;em&gt;zinfo_or_arcname&lt;/em&gt; parameter, the compression method used will be that specified in the &lt;em&gt;compress_type&lt;/em&gt; member of the given &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance. By default, the &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; constructor sets this member to &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt;&lt;code&gt;ZIP_STORED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;实例作为&lt;em&gt;zinfo_or_arcname&lt;/em&gt;参数传递时，使用的压缩方法将是在给定&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;实例的&lt;em&gt;compress_type&lt;/em&gt;成员中指定的压缩方法。默认情况下，&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;构造函数将此成员设置为&lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt; &lt;code&gt;ZIP_STORED&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbfc7a1fdbd85a7a8af9ae652a598a7fb18209e5" translate="yes" xml:space="preserve">
          <source>When passing strings, characters special to XML such as &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; will be automatically escaped. However, it&amp;rsquo;s the caller&amp;rsquo;s responsibility to ensure that the string is free of characters that aren&amp;rsquo;t allowed in XML, such as the control characters with ASCII values between 0 and 31 (except, of course, tab, newline and carriage return); failing to do this will result in an XML-RPC request that isn&amp;rsquo;t well-formed XML. If you have to pass arbitrary bytes via XML-RPC, use &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; classes or the &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; wrapper class described below.</source>
          <target state="translated">传递字符串时，XML专用字符，例如 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 将自动转义。但是，调用者有责任确保字符串中没有XML不允许的字符，例如ASCII值在0到31之间的控制字符（当然，制表符，换行符和回车符除外）；否则，将导致XML-RPC请求不是格式正确的XML。如果必须通过XML-RPC传递任意字节，请使用&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;类或下面描述的&lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt;包装器类。</target>
        </trans-unit>
        <trans-unit id="63bc2447bdc66517ffbc569605d6b0a283df40ef" translate="yes" xml:space="preserve">
          <source>When performing basic authentication, a &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; instance calls its &lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt;&lt;code&gt;prompt_user_passwd()&lt;/code&gt;&lt;/a&gt; method. The default implementation asks the users for the required information on the controlling terminal. A subclass may override this method to support more appropriate behavior if needed.</source>
          <target state="translated">执行基本身份验证时，&lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt;实例将调用其&lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt; &lt;code&gt;prompt_user_passwd()&lt;/code&gt; &lt;/a&gt;方法。默认实现是在控制终端上向用户询问所需的信息。如果需要，子类可以重写此方法以支持更适当的行为。</target>
        </trans-unit>
        <trans-unit id="cdd3028f0460b2a38b88a225adf972c3a4a4fe5b" translate="yes" xml:space="preserve">
          <source>When printing output to the console, &lt;strong&gt;pydoc&lt;/strong&gt; attempts to paginate the output for easier reading. If the &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; environment variable is set, &lt;strong&gt;pydoc&lt;/strong&gt; will use its value as a pagination program.</source>
          <target state="translated">在将输出打印到控制台时，&lt;strong&gt;pydoc&lt;/strong&gt;尝试对输出进行分页以便于阅读。如果设置了 &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; 环境变量，则&lt;strong&gt;pydoc&lt;/strong&gt;会将其值用作分页程序。</target>
        </trans-unit>
        <trans-unit id="0ed1e3583fcf60dc14b51dea1fcf2276215158d1" translate="yes" xml:space="preserve">
          <source>When programming in a compiled language, shared libraries are accessed when compiling/linking a program, and when the program is run.</source>
          <target state="translated">当使用编译语言编程时,在编译/链接程序时,以及程序运行时都会访问共享库。</target>
        </trans-unit>
        <trans-unit id="03f1758f540eba7a39f832dfe0bdad388ef357ae" translate="yes" xml:space="preserve">
          <source>When provided, &lt;em&gt;extra_args&lt;/em&gt; is a sequence of &lt;code&gt;(name, value)&lt;/code&gt; tuples that will be passed as keywords arguments to the callable.</source>
          <target state="translated">提供后，&lt;em&gt;extra_args&lt;/em&gt;是 &lt;code&gt;(name, value)&lt;/code&gt; 元组的序列，这些元组将作为关键字参数传递给可调用对象。</target>
        </trans-unit>
        <trans-unit id="7d590e3c7f8f976b86d3937ef37f23bbcf9e23b0" translate="yes" xml:space="preserve">
          <source>When raising (or re-raising) an exception in an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause &lt;code&gt;__context__&lt;/code&gt; is automatically set to the last exception caught; if the new exception is not handled the traceback that is eventually displayed will include the originating exception(s) and the final exception.</source>
          <target state="translated">当引发（或重新引发）&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句中的异常时， &lt;code&gt;__context__&lt;/code&gt; 会自动设置为捕获到的最后一个异常。如果未处理新的异常，则最终显示的回溯将包括原始异常和最终异常。</target>
        </trans-unit>
        <trans-unit id="a67ffe067c715a48c6e91eae37f79dcbfbe58ddb" translate="yes" xml:space="preserve">
          <source>When raising (or re-raising) an exception in an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause &lt;code&gt;__context__&lt;/code&gt; is automatically set to the last exception caught; if the new exception is not handled the traceback that is eventually displayed will include the originating exception(s) and the final exception.</source>
          <target state="translated">当引发（或重新引发）&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句中的异常时， &lt;code&gt;__context__&lt;/code&gt; 会自动设置为捕获到的最后一个异常。如果未处理新的异常，则最终显示的回溯将包括原始异常和最终异常。</target>
        </trans-unit>
        <trans-unit id="84626ccb1f1b7c51c54d20b65a4d9d24bac172db" translate="yes" xml:space="preserve">
          <source>When raising a new exception (rather than using a bare &lt;code&gt;raise&lt;/code&gt; to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当提升一个新的异常（而不是使用裸 &lt;code&gt;raise&lt;/code&gt; 重新提高目前正在处理的异常），隐含的例外情况下可以通过使用补充有明确的原因&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt; &lt;code&gt;raise&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="93bd48fad8b203b60c5efe8bb8ffe28fea84868a" translate="yes" xml:space="preserve">
          <source>When raising a new exception (rather than using a bare &lt;code&gt;raise&lt;/code&gt; to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#raise&quot;&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当引发新异常时（而不是使用裸露的 &lt;code&gt;raise&lt;/code&gt; 来重新引发当前正在处理的异常），可以通过使用&lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#raise&quot;&gt; &lt;code&gt;raise&lt;/code&gt; &lt;/a&gt;来为隐式异常上下文添加显式原因：</target>
        </trans-unit>
        <trans-unit id="ebdaa4be34e107dcd8db3e5870c90743caace639" translate="yes" xml:space="preserve">
          <source>When reading data from this object, a larger amount of data may be requested from the underlying raw stream, and kept in an internal buffer. The buffered data can then be returned directly on subsequent reads.</source>
          <target state="translated">当从该对象读取数据时,可以从底层原始流中请求较大的数据量,并保存在内部缓冲区中。缓冲区的数据就可以在后续的读取中直接返回。</target>
        </trans-unit>
        <trans-unit id="cc416240914fa2f9d0a3585ee1b058f79fc51d82" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">从流中读取输入时，如果&lt;em&gt;newline&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则启用&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;通用换行&lt;/a&gt;模式。输入中的行可以以 &lt;code&gt;'\n'&lt;/code&gt; ， &lt;code&gt;'\r'&lt;/code&gt; 或 &lt;code&gt;'\r\n'&lt;/code&gt; 结尾，在返回给调用者之前，这些行会转换为 &lt;code&gt;'\n'&lt;/code&gt; 。如果它是 &lt;code&gt;''&lt;/code&gt; ，则启用通用换行模式，但是行结尾不翻译就返回给呼叫者。如果它具有任何其他合法值，则输入行仅由给定的字符串终止，并且该行的末尾不翻译就返回给调用方。</target>
        </trans-unit>
        <trans-unit id="cdc9df5bfe580172c92099968262f07274c0e815" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If &lt;em&gt;newline&lt;/em&gt; has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">从流中读取输入时，如果&lt;em&gt;newline&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则启用&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;通用换行&lt;/a&gt;模式。输入中的行可以以 &lt;code&gt;'\n'&lt;/code&gt; ， &lt;code&gt;'\r'&lt;/code&gt; 或 &lt;code&gt;'\r\n'&lt;/code&gt; 结尾，在返回给调用者之前，这些行会转换为 &lt;code&gt;'\n'&lt;/code&gt; 。如果&lt;em&gt;newline&lt;/em&gt;为 &lt;code&gt;''&lt;/code&gt; ，则启用通用换行模式，但是行结尾不翻译就返回给呼叫者。如果&lt;em&gt;换行符&lt;/em&gt;具有任何其他合法值，则输入行仅由给定的字符串终止，并且行结束符不翻译就返回给调用方。</target>
        </trans-unit>
        <trans-unit id="521e95b377d73dc55cb2baf5c5af8fdf1ed894f3" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, universal newlines mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">从流中读取输入时，如果&lt;em&gt;newline&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则启用通用换行模式。输入中的行可以以 &lt;code&gt;'\n'&lt;/code&gt; ， &lt;code&gt;'\r'&lt;/code&gt; 或 &lt;code&gt;'\r\n'&lt;/code&gt; 结尾，在返回给调用者之前，这些行会转换为 &lt;code&gt;'\n'&lt;/code&gt; 。如果它是 &lt;code&gt;''&lt;/code&gt; ，则启用通用换行模式，但是行结尾不翻译就返回给呼叫者。如果它具有任何其他合法值，则输入行仅由给定的字符串终止，并且该行的末尾不翻译就返回给调用方。</target>
        </trans-unit>
        <trans-unit id="ef6664d6092937daced8b81f9ccf4a2841a1ee61" translate="yes" xml:space="preserve">
          <source>When reading or writing external files, make sure they can be read or written by the userid under which your CGI script will be running: this is typically the userid under which the web server is running, or some explicitly specified userid for a web server&amp;rsquo;s &lt;code&gt;suexec&lt;/code&gt; feature.</source>
          <target state="translated">在读取或写入外部文件时，请确保可由运行CGI脚本的用户ID读取或写入它们：通常是运行Web服务器的用户ID，或者是为Web服务器的 &lt;code&gt;suexec&lt;/code&gt; 明确指定的用户ID。特征。</target>
        </trans-unit>
        <trans-unit id="d8df0ae7a831d2bc654fc7f26ceaddd0fec6a53d" translate="yes" xml:space="preserve">
          <source>When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: applications wishing to present such host names to the user should decode them to Unicode.</source>
          <target state="translated">当从网线接收主机名时(如在反向名称查询中),不会自动转换为Unicode:希望向用户展示这些主机名的应用程序应将其解码为Unicode。</target>
        </trans-unit>
        <trans-unit id="c249fada241449b7a8d98255500a026f1ff7ff6e" translate="yes" xml:space="preserve">
          <source>When rotating, rotate the current log.</source>
          <target state="translated">旋转时,旋转当前日志。</target>
        </trans-unit>
        <trans-unit id="009f8f1003bd38ceb66bdf4766db141ef685c52a" translate="yes" xml:space="preserve">
          <source>When run with the appropriate arguments, it prints either the sum or the max of the command-line integers:</source>
          <target state="translated">当与适当的参数一起运行时,它将打印命令行整数的和或最大值。</target>
        </trans-unit>
        <trans-unit id="d2c61737a1449cc5834b15d481c322aac953d7bb" translate="yes" xml:space="preserve">
          <source>When running a tkinter program from an IDLE editor, one can comment out the mainloop call. One then gets a shell prompt immediately and can interact with the live application. One just has to remember to re-enable the mainloop call when running in standard Python.</source>
          <target state="translated">当从IDLE编辑器中运行tkinter程序时,可以注释掉mainloop调用。然后立即得到一个 shell 提示,可以与实时应用程序交互。只需在标准 Python 中运行时记得重新启用 mainloop 调用。</target>
        </trans-unit>
        <trans-unit id="ef04bb8c76c31bcff2e40b83fb3b51dbc495fd47" translate="yes" xml:space="preserve">
          <source>When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation&amp;rsquo;s range and precision limitations. This is especially relevant when serializing Python &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; values of extremely large magnitude, or when serializing instances of &amp;ldquo;exotic&amp;rdquo; numerical types such as &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">序列化为JSON时，请注意可能会占用JSON的应用程序中的任何此类限制。特别是，通常将JSON数字反序列化为IEEE 754双精度数字，并因此受到该表示形式的范围和精度限制。在序列化非常大的Python &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;值时，或者在序列化&amp;ldquo;奇特&amp;rdquo;数字类型（例如&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; )的&lt;/a&gt;实例时，这一点尤其重要。</target>
        </trans-unit>
        <trans-unit id="3856e8bd6a5962d17cc2916a2ad00664a1e6d558" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, the parser will not allow for any section or option duplicates while reading from a single source (using &lt;code&gt;read_file()&lt;/code&gt;, &lt;code&gt;read_string()&lt;/code&gt; or &lt;code&gt;read_dict()&lt;/code&gt;). It is recommended to use strict parsers in new applications.</source>
          <target state="translated">当设置为 &lt;code&gt;True&lt;/code&gt; 时，解析器在从单个源读取时（使用 &lt;code&gt;read_file()&lt;/code&gt; ， &lt;code&gt;read_string()&lt;/code&gt; 或 &lt;code&gt;read_dict()&lt;/code&gt; ）将不允许任何节或选项重复。建议在新应用程序中使用严格的解析器。</target>
        </trans-unit>
        <trans-unit id="af553f6e77f3799cc572c24f6b17d618156fcd66" translate="yes" xml:space="preserve">
          <source>When set to a value other than &lt;code&gt;None&lt;/code&gt;, this variable defines the default value for the &lt;em&gt;dir&lt;/em&gt; argument to the functions defined in this module.</source>
          <target state="translated">当设置为 &lt;code&gt;None&lt;/code&gt; 以外的其他值时，此变量将为该模块中定义的函数的&lt;em&gt;dir&lt;/em&gt;参数定义默认值。</target>
        </trans-unit>
        <trans-unit id="a651c4386e23ffbd8bc757cc1022ed6e854c9c0d" translate="yes" xml:space="preserve">
          <source>When set, all unreachable objects found will be appended to &lt;em&gt;garbage&lt;/em&gt; rather than being freed. This can be useful for debugging a leaking program.</source>
          <target state="translated">设置后，找到的所有不可达对象将被添加到&lt;em&gt;垃圾中，&lt;/em&gt;而不是被释放。这对于调试泄漏的程序很有用。</target>
        </trans-unit>
        <trans-unit id="966461a5030c03e1d1f1351234001ea1acd1bcfd" translate="yes" xml:space="preserve">
          <source>When setting cookies, require a full &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; domain-match.</source>
          <target state="translated">设置Cookie时，要求完整的&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt;域匹配。</target>
        </trans-unit>
        <trans-unit id="962945e9937ea98d222513b922d5881fd1bf1687" translate="yes" xml:space="preserve">
          <source>When setting cookies, the &amp;lsquo;host prefix&amp;rsquo; must not contain a dot (eg. &lt;code&gt;www.foo.bar.com&lt;/code&gt; can&amp;rsquo;t set a cookie for &lt;code&gt;.bar.com&lt;/code&gt;, because &lt;code&gt;www.foo&lt;/code&gt; contains a dot).</source>
          <target state="translated">设置cookie时，&amp;ldquo;主机前缀&amp;rdquo;不得包含点（例如 &lt;code&gt;www.foo.bar.com&lt;/code&gt; 不能为 &lt;code&gt;.bar.com&lt;/code&gt; 设置cookie ，因为 &lt;code&gt;www.foo&lt;/code&gt; 包含点）。</target>
        </trans-unit>
        <trans-unit id="1497d638ca2af8c9832a39909543a42d33c7e1e0" translate="yes" xml:space="preserve">
          <source>When several absolute paths are given, the last is taken as an anchor (mimicking &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s behaviour):</source>
          <target state="translated">当给出几个绝对路径时，最后一个被当作锚点（模仿&lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt;的行为）：</target>
        </trans-unit>
        <trans-unit id="0ef246b92ec78bbb2904be545cecaaa31079bddf" translate="yes" xml:space="preserve">
          <source>When specified, all sequences of whitespace (blanks and newlines) are treated as equal. Any sequence of whitespace within the expected output will match any sequence of whitespace within the actual output. By default, whitespace must match exactly. &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt;&lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt;&lt;/a&gt; is especially useful when a line of expected output is very long, and you want to wrap it across multiple lines in your source.</source>
          <target state="translated">指定时，所有空格序列（空白和换行符）均被视为相等。预期输出中的任何空格序列都将匹配实际输出中的任何空格序列。默认情况下，空格必须完全匹配。当一行预期的输出很长并且您希望将其包装在源代码的多行中时，&lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt; &lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt; &lt;/a&gt;特别有用。</target>
        </trans-unit>
        <trans-unit id="1b218a31cb42b5880f2b77432b336a4dc41d9aa7" translate="yes" xml:space="preserve">
          <source>When specified, an ellipsis marker (&lt;code&gt;...&lt;/code&gt;) in the expected output can match any substring in the actual output. This includes substrings that span line boundaries, and empty substrings, so it&amp;rsquo;s best to keep usage of this simple. Complicated uses can lead to the same kinds of &amp;ldquo;oops, it matched too much!&amp;rdquo; surprises that &lt;code&gt;.*&lt;/code&gt; is prone to in regular expressions.</source>
          <target state="translated">指定后，预期输出中的省略号（ &lt;code&gt;...&lt;/code&gt; ）可以与实际输出中的任何子字符串匹配。这包括跨越线边界的子字符串和空的子字符串，因此最好保持简单的用法。复杂的使用可能导致相同的&amp;ldquo;糟糕，匹配太多！&amp;rdquo; 令人惊讶的是 &lt;code&gt;.*&lt;/code&gt; 容易在正则表达式中出现。</target>
        </trans-unit>
        <trans-unit id="dcb31cc2903efca845f37ae06ecb0d7faead34bc" translate="yes" xml:space="preserve">
          <source>When specified, an example that expects an exception passes if an exception of the expected type is raised, even if the exception detail does not match. For example, an example expecting &lt;code&gt;ValueError: 42&lt;/code&gt; will pass if the actual exception raised is &lt;code&gt;ValueError: 3*14&lt;/code&gt;, but will fail, e.g., if &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">指定后，即使引发了预期类型的​​异常，即使异常详细信息不匹配，也会通过一个预期异常的示例。例如，如果实际引发的异常为 &lt;code&gt;ValueError: 3*14&lt;/code&gt; ，则期望 &lt;code&gt;ValueError: 42&lt;/code&gt; 的示例将通过，但是例如，如果&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;，则该示例将失败。</target>
        </trans-unit>
        <trans-unit id="506d23fee0102647e3e510ecb1828895d54af340" translate="yes" xml:space="preserve">
          <source>When specified, differences are computed by &lt;code&gt;difflib.Differ&lt;/code&gt;, using the same algorithm as the popular &lt;code&gt;ndiff.py&lt;/code&gt; utility. This is the only method that marks differences within lines as well as across lines. For example, if a line of expected output contains digit &lt;code&gt;1&lt;/code&gt; where actual output contains letter &lt;code&gt;l&lt;/code&gt;, a line is inserted with a caret marking the mismatching column positions.</source>
          <target state="translated">指定后，差异将由 &lt;code&gt;difflib.Differ&lt;/code&gt; 使用与流行的 &lt;code&gt;ndiff.py&lt;/code&gt; 实用程序相同的算法进行计算。这是标记行内以及行间差异的唯一方法。例如，如果预期输出的行包含数字 &lt;code&gt;1&lt;/code&gt; ，而实际输出包含字母 &lt;code&gt;l&lt;/code&gt; ，则会插入带有脱字符号的行，以标记不匹配的列位置。</target>
        </trans-unit>
        <trans-unit id="725ed21a520fb4bdfd0c582f999632c3b3e1a3c6" translate="yes" xml:space="preserve">
          <source>When specified, display the first failing example in each doctest, but suppress output for all remaining examples. This will prevent doctest from reporting correct examples that break because of earlier failures; but it might also hide incorrect examples that fail independently of the first failure. When &lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt;&lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt;&lt;/a&gt; is specified, the remaining examples are still run, and still count towards the total number of failures reported; only the output is suppressed.</source>
          <target state="translated">指定后，在每个doctest中显示第一个失败的示例，但不显示所有其余示例的输出。这样可以防止doctest报告由于早期故障而中断的正确示例；但是它也可能隐藏不正确的示例，这些示例独立于第一次失败而失败。当指定&lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt; &lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt; 时&lt;/a&gt;，其余示例仍在运行，并且仍计入报告的故障总数；仅输出被抑制。</target>
        </trans-unit>
        <trans-unit id="aeb4572ffe4ed819ce94cd6722f54cd0aadb9fe4" translate="yes" xml:space="preserve">
          <source>When specified, do not run the example at all. This can be useful in contexts where doctest examples serve as both documentation and test cases, and an example should be included for documentation purposes, but should not be checked. E.g., the example&amp;rsquo;s output might be random; or the example might depend on resources which would be unavailable to the test driver.</source>
          <target state="translated">指定后，完全不要运行该示例。这在doctest示例既可作为文档又可作为测试用例的情况下很有用，并且应出于文档目的而包含一个示例，但不应对其进行检查。例如，示例的输出可能是随机的；否则示例可能取决于测试驱动程序无法使用的资源。</target>
        </trans-unit>
        <trans-unit id="1313668fddf2714b9e79f58afa68fecf0d72d780" translate="yes" xml:space="preserve">
          <source>When specified, exit after the first failing example and don&amp;rsquo;t attempt to run the remaining examples. Thus, the number of failures reported will be at most 1. This flag may be useful during debugging, since examples after the first failure won&amp;rsquo;t even produce debugging output.</source>
          <target state="translated">指定后，请在第一个失败的示例之后退出，不要尝试运行其余示例。因此，报告的失败数量最多为1。此标志在调试期间可能很有用，因为第一次失败后的示例甚至都不会产生调试输出。</target>
        </trans-unit>
        <trans-unit id="a165ac4e0fc877daf25b2fcfe0a4d6e37cd8566f" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs are displayed using a unified diff.</source>
          <target state="translated">当指定时,涉及多行预期和实际输出的故障将使用统一的差异显示。</target>
        </trans-unit>
        <trans-unit id="210d27f93a6ffbf0d54ba3a0a4a851f82c25d9b1" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs will be displayed using a context diff.</source>
          <target state="translated">当指定时,涉及多行预期和实际输出的故障将使用上下文差异显示。</target>
        </trans-unit>
        <trans-unit id="2e021460883f1eef6780ecadd57bc2f7a8e86c36" translate="yes" xml:space="preserve">
          <source>When specified, the pattern character &lt;code&gt;'^'&lt;/code&gt; matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character &lt;code&gt;'$'&lt;/code&gt; matches at the end of the string and at the end of each line (immediately preceding each newline). By default, &lt;code&gt;'^'&lt;/code&gt; matches only at the beginning of the string, and &lt;code&gt;'$'&lt;/code&gt; only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag &lt;code&gt;(?m)&lt;/code&gt;.</source>
          <target state="translated">指定时，模式字符 &lt;code&gt;'^'&lt;/code&gt; 在字符串的开头和每行的开头（紧随每个换行符之后）匹配；模式字符 &lt;code&gt;'$'&lt;/code&gt; 在字符串的末尾和每行的末尾（紧接在每个换行符之前）匹配。默认情况下， &lt;code&gt;'^'&lt;/code&gt; 仅匹配于字符串的开头， &lt;code&gt;'$'&lt;/code&gt; 仅匹配于字符串的末尾且紧接换行符（如果有）位于字符串的末尾。对应于内联标志 &lt;code&gt;(?m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6508ccae0114f70101a39c1ade3be77f9a0e54cc" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, mix-in types must appear before &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; itself in the sequence of bases, as in the &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; example above.</source>
          <target state="translated">子类化&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 时&lt;/a&gt;，混合类型必须按基数顺序出现在&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;本身之前，如上面的&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt;示例中所示。</target>
        </trans-unit>
        <trans-unit id="6ab9f2e0c84d1cef2e81d17d102b665c42c1b918" translate="yes" xml:space="preserve">
          <source>When symbolic link cycles occur, the returned path will be one member of the cycle, but no guarantee is made about which member that will be.</source>
          <target state="translated">当符号链接循环发生时,返回的路径将是循环中的一个成员,但不能保证是哪个成员。</target>
        </trans-unit>
        <trans-unit id="dda516a7e878443b38c4fe64189ee1bdd2488b07" translate="yes" xml:space="preserve">
          <source>When testing multiple operations that raise the same kind of warning, it is important to test them in a manner that confirms each operation is raising a new warning (e.g. set warnings to be raised as exceptions and check the operations raise exceptions, check that the length of the warning list continues to increase after each operation, or else delete the previous entries from the warnings list before each new operation).</source>
          <target state="translated">在测试多个引发同种警告的操作时,一定要确认每个操作都引发了新的警告(如将警告设置为异常,并检查操作是否引发了异常,检查每次操作后警告列表的长度是否继续增加,否则就在每次新的操作前从警告列表中删除之前的条目)。</target>
        </trans-unit>
        <trans-unit id="32c986eba58685d8d5c5b9096bea3ea17575dc2a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt;&lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt;&lt;/a&gt; doctest option is specified, everything following the leftmost colon and any module information in the exception name is ignored.</source>
          <target state="translated">当&lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt; &lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt; &lt;/a&gt;指定文档测试选项，一切都遵循最左边的冒号，并在异常名的任何模块的信息被忽略。</target>
        </trans-unit>
        <trans-unit id="aa3f49f30bcc7e091d5c01e4ab7c4d154fba44f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noqiflush()&lt;/code&gt; routine is used, normal flush of input and output queues associated with the &lt;code&gt;INTR&lt;/code&gt;, &lt;code&gt;QUIT&lt;/code&gt; and &lt;code&gt;SUSP&lt;/code&gt; characters will not be done. You may want to call &lt;code&gt;noqiflush()&lt;/code&gt; in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits.</source>
          <target state="translated">当使用 &lt;code&gt;noqiflush()&lt;/code&gt; 例程时，将不会完成与 &lt;code&gt;INTR&lt;/code&gt; ， &lt;code&gt;QUIT&lt;/code&gt; 和 &lt;code&gt;SUSP&lt;/code&gt; 字符关联的输入和输出队列的常规刷新。如果希望在处理程序退出后继续进行输出，就好像没有发生中断一样，则可能要在信号处理程序中调用 &lt;code&gt;noqiflush()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92f7176cdc28e8fabe1cc4ce9c92d06ff62a9627" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; attribute is retrieved from a ctypes instance, usually a new object is returned each time. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; implement original object return, always a new object is constructed. The same is true for all other ctypes object instances.</source>
          <target state="translated">当 &lt;code&gt;value&lt;/code&gt; 属性是从一个ctypes实例获取，通常是一个新的对象，每次返回。&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;不实现原始对象返回，&lt;em&gt;而是&lt;/em&gt;始终构造一个新对象。所有其他ctypes对象实例也是如此。</target>
        </trans-unit>
        <trans-unit id="cba25eeaf6632c7ebc55efeeb8b1a2231818ee6e" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;name&lt;/em&gt; variable is of the form &lt;code&gt;package.module&lt;/code&gt;, normally, the top-level package (the name up till the first dot) is returned, &lt;em&gt;not&lt;/em&gt; the module named by &lt;em&gt;name&lt;/em&gt;. However, when a non-empty &lt;em&gt;fromlist&lt;/em&gt; argument is given, the module named by &lt;em&gt;name&lt;/em&gt; is returned.</source>
          <target state="translated">当&lt;em&gt;name&lt;/em&gt;变量的形式为 &lt;code&gt;package.module&lt;/code&gt; 时，通常返回顶级包（名称直到第一个点），&lt;em&gt;而不是&lt;/em&gt;返回由&lt;em&gt;name&lt;/em&gt;命名的模块。但是，当给出非空的&lt;em&gt;fromlist&lt;/em&gt;参数时，将返回以&lt;em&gt;名称&lt;/em&gt;命名的模块。</target>
        </trans-unit>
        <trans-unit id="0839b23fb2fd3debdac05fc9ae13ae6b565a4724" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is not present or &lt;code&gt;None&lt;/code&gt;, the operation will block until the thread terminates.</source>
          <target state="translated">当不存在&lt;em&gt;timeout&lt;/em&gt;参数或 &lt;code&gt;None&lt;/code&gt; 时，该操作将阻塞，直到线程终止。</target>
        </trans-unit>
        <trans-unit id="a4f2a083cefefece0f9a989089d273d2343db7c8" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">当存在&lt;em&gt;timeout&lt;/em&gt;参数而不是 &lt;code&gt;None&lt;/code&gt; 时，它应该是一个浮点数，以秒为单位（或其分数）指定操作的超时时间。</target>
        </trans-unit>
        <trans-unit id="9427976e1510be53b2baa1d26a02bd7a239f5c51" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; always returns &lt;code&gt;None&lt;/code&gt;, you must call &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; to decide whether a timeout happened &amp;ndash; if the thread is still alive, the &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; call timed out.</source>
          <target state="translated">当存在&lt;em&gt;timeout&lt;/em&gt;参数而不是 &lt;code&gt;None&lt;/code&gt; 时，它应该是一个浮点数，以秒为单位（或其分数）指定操作的超时时间。由于&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;始终返回 &lt;code&gt;None&lt;/code&gt; ，因此必须在&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#threading.Thread.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt;之后调用is_alive（）来确定是否发生超时&amp;ndash;如果线程仍然存在，则&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;调用将超时。</target>
        </trans-unit>
        <trans-unit id="4efa641d2d18d3d35e2f53ff91c7db9472e3c6c4" translate="yes" xml:space="preserve">
          <source>When the database has been opened in fast mode, this method forces any unwritten data to be written to the disk.</source>
          <target state="translated">当数据库已经以快速模式打开时,此方法强制将任何未写入的数据写入磁盘。</target>
        </trans-unit>
        <trans-unit id="b82443f1c4eff35532245efa9cbc5d46a5e79a79" translate="yes" xml:space="preserve">
          <source>When the dataclass is being created by the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator, it looks through all of the class&amp;rsquo;s base classes in reverse MRO (that is, starting at &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;) and, for each dataclass that it finds, adds the fields from that base class to an ordered mapping of fields. After all of the base class fields are added, it adds its own fields to the ordered mapping. All of the generated methods will use this combined, calculated ordered mapping of fields. Because the fields are in insertion order, derived classes override base classes. An example:</source>
          <target state="translated">当由&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt;装饰器创建数据类时，它将以反向MRO（即，从&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;）开始遍历该类的所有基类，并针对找到的每个数据类，将该基类中的字段添加到字段的有序映射。添加所有基类字段后，它将自己的字段添加到有序映射中。所有生成的方法都将使用此组合的，计算得出的字段有序映射。由于字段按插入顺序排列，因此派生类将覆盖基类。一个例子：</target>
        </trans-unit>
        <trans-unit id="d9b66dd18ce1e12e4286175c7d8752f320de1be6" translate="yes" xml:space="preserve">
          <source>When the debug mode is enabled:</source>
          <target state="translated">启用调试模式时。</target>
        </trans-unit>
        <trans-unit id="3d323c0b3abd37e8843f26f7250d48151ff4e9e4" translate="yes" xml:space="preserve">
          <source>When the deque is not empty, rotating one step to the right is equivalent to &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt;, and rotating one step to the left is equivalent to &lt;code&gt;d.append(d.popleft())&lt;/code&gt;.</source>
          <target state="translated">当双端队列不为空时，向右旋转一个步骤等效于 &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt; ，向左旋转一个步骤等效于 &lt;code&gt;d.append(d.popleft())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="965bb2961456fd9ec18c155c435cd124d7f1e1f7" translate="yes" xml:space="preserve">
          <source>When the following functions return &amp;ldquo;frame records,&amp;rdquo; each record is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt;. The tuple contains the frame object, the filename, the line number of the current line, the function name, a list of lines of context from the source code, and the index of the current line within that list.</source>
          <target state="translated">当以下函数返回&amp;ldquo;框架记录&amp;rdquo;时，每个记录就是一个&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;命名的元组&lt;/a&gt; &lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt; 。元组包含框架对象，文件名，当前行的行号，函数名称，源代码中的上下文行的列表以及该列表中当前行的索引。</target>
        </trans-unit>
        <trans-unit id="3c368910c5373a95bb55df52216e148f6cdcaba8" translate="yes" xml:space="preserve">
          <source>When the following functions return &amp;ldquo;frame records,&amp;rdquo; each record is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt;. The tuple contains the frame object, the filename, the line number of the current line, the function name, a list of lines of context from the source code, and the index of the current line within that list.</source>
          <target state="translated">当以下函数返回&amp;ldquo;框架记录&amp;rdquo;时，每个记录就是一个&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;命名的元组&lt;/a&gt; &lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt; 。元组包含框架对象，文件名，当前行的行号，函数名称，源代码中的上下文行的列表以及该列表中当前行的索引。</target>
        </trans-unit>
        <trans-unit id="a192ce7dd917b79cdadcecc69d15e0e840e3fac2" translate="yes" xml:space="preserve">
          <source>When the function raises a &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; exception, it is silently ignored.</source>
          <target state="translated">当该函数引发&lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt;异常时，它将被静默忽略。</target>
        </trans-unit>
        <trans-unit id="0c8af2d5b431a64609659111ed46cf47a5a6d0cb" translate="yes" xml:space="preserve">
          <source>When the function returns, the thread silently exits.</source>
          <target state="translated">当函数返回时,线程默默退出。</target>
        </trans-unit>
        <trans-unit id="2939cf22671cec72fb407f91f1dd1da33466f4b0" translate="yes" xml:space="preserve">
          <source>When the function terminates with an unhandled exception, &lt;a href=&quot;sys#sys.unraisablehook&quot;&gt;&lt;code&gt;sys.unraisablehook()&lt;/code&gt;&lt;/a&gt; is called to handle the exception. The &lt;em&gt;object&lt;/em&gt; attribute of the hook argument is &lt;em&gt;function&lt;/em&gt;. By default, a stack trace is printed and then the thread exits (but other threads continue to run).</source>
          <target state="translated">当函数以未处理的异常终止时，将调用&lt;a href=&quot;sys#sys.unraisablehook&quot;&gt; &lt;code&gt;sys.unraisablehook()&lt;/code&gt; &lt;/a&gt;处理该异常。hook参数的&lt;em&gt;object&lt;/em&gt;属性是&lt;em&gt;function&lt;/em&gt;。默认情况下，将打印堆栈跟踪，然后线程退出（但是其他线程继续运行）。</target>
        </trans-unit>
        <trans-unit id="11e1f7a5314c521814efab7673f88a014796119b" translate="yes" xml:space="preserve">
          <source>When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.</source>
          <target state="translated">当iterable为空时,返回起始值。这个函数专门用于数值,可能会拒绝非数值类型。</target>
        </trans-unit>
        <trans-unit id="0619f802303d6a776090a8553bcded1600861c45" translate="yes" xml:space="preserve">
          <source>When the lock is &lt;em&gt;locked&lt;/em&gt;, reset it to &lt;em&gt;unlocked&lt;/em&gt; and return.</source>
          <target state="translated">锁&lt;em&gt;锁定后&lt;/em&gt;，将其重置为&lt;em&gt;解锁状态&lt;/em&gt;并返回。</target>
        </trans-unit>
        <trans-unit id="12b90fc7c45f662a12bf1ee8cea1898d278f7026" translate="yes" xml:space="preserve">
          <source>When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.</source>
          <target state="translated">当锁被锁定时,将其重置为解锁,然后返回。如果有其他线程在等待解锁时被阻塞,则允许其中一个线程继续进行。</target>
        </trans-unit>
        <trans-unit id="6c398f7629217467760d733727be89698cfaee23" translate="yes" xml:space="preserve">
          <source>When the logging module is imported, it registers this function as an exit handler (see &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;), so normally there&amp;rsquo;s no need to do that manually.</source>
          <target state="translated">导入日志记录模块时，它将此函数注册为退出处理程序（请参阅&lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt;），因此通常不需要手动执行此操作。</target>
        </trans-unit>
        <trans-unit id="cdd980ea6acc8763679979a08e2398cb455101b4" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it does not do any of its usual cleanup (except that &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses are honored), and the standard I/O files are not flushed.</source>
          <target state="translated">当主线程退出时，它不执行任何常规清理操作（除了使用&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句），并且不刷新标准I / O文件。</target>
        </trans-unit>
        <trans-unit id="447b65a54ecd195ca52b1bbe7503032f5367dc81" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it does not do any of its usual cleanup (except that &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses are honored), and the standard I/O files are not flushed.</source>
          <target state="translated">当主线程退出时，它不执行任何常规清理操作（除了使用&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句），并且不刷新标准I / O文件。</target>
        </trans-unit>
        <trans-unit id="5af7554aea463351096c790b6eebb65f8d0e1e78" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses or executing object destructors.</source>
          <target state="translated">当主线程退出时，系统定义其他线程是否存活。在大多数系统上，它们是在不执行&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句或执行对象析构函数的情况下被杀死的。</target>
        </trans-unit>
        <trans-unit id="abc6ab97345fb3adba854a2e5fae01d5e49e1ac2" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses or executing object destructors.</source>
          <target state="translated">当主线程退出时，系统定义其他线程是否存活。在大多数系统上，它们是在不执行&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt;子句或执行对象析构函数的情况下被杀死的。</target>
        </trans-unit>
        <trans-unit id="df8416c53a3fab417f18d34ff6b2c7c89921bb9b" translate="yes" xml:space="preserve">
          <source>When the number of data points is even, the median is interpolated by taking the average of the two middle values:</source>
          <target state="translated">当数据点数为偶数时,取中间两个值的平均值来插值。</target>
        </trans-unit>
        <trans-unit id="c3727a0d49a696958b7e7aedf6197c454a60d276" translate="yes" xml:space="preserve">
          <source>When the parser is instantiated it is ready to begin accepting data from the feed method immediately. After parsing has been finished with a call to close the reset method must be called to make the parser ready to accept new data, either from feed or using the parse method.</source>
          <target state="translated">当解析器被实例化后,它就可以立即开始接受来自feed方法的数据。在解析结束后调用关闭复位方法,必须调用复位方法使解析器准备好接受新数据,无论是从feed还是使用解析方法。</target>
        </trans-unit>
        <trans-unit id="512d3776530707ff872caf29c6b20b7211d9d8d5" translate="yes" xml:space="preserve">
          <source>When the path points to a directory, yield path objects of the directory contents:</source>
          <target state="translated">当路径指向目录时,产生目录内容的路径对象。</target>
        </trans-unit>
        <trans-unit id="df6ac2fad722ee466b6d6cb46713a1963668153e" translate="yes" xml:space="preserve">
          <source>When the program exits, each remaining live finalizer is called unless its &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; attribute has been set to false. They are called in reverse order of creation.</source>
          <target state="translated">程序退出时，将调用每个剩余的活动终结器，除非其&lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt;属性设置为false。它们的创建顺序相反。</target>
        </trans-unit>
        <trans-unit id="a67cebb1835e8e6bf7a770664e7365b4b2e21589" translate="yes" xml:space="preserve">
          <source>When the program starts and selects the &lt;em&gt;forkserver&lt;/em&gt; start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt;. No unnecessary resources are inherited.</source>
          <target state="translated">当程序启动并选择&lt;em&gt;forkserver&lt;/em&gt; start方法时，服务器进程将启动。从那时起，无论何时需要新进程，父进程都将连接到服务器并请求它派生一个新进程。fork服务器进程是单线程的，因此使用&lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt;是安全的。没有不必要的资源被继承。</target>
        </trans-unit>
        <trans-unit id="1f5136bd917b359254fcb25318d6cf9878572072" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the bytes object &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">当正确的参数是字典（或其他映射类型）时，bytes对象中的格式&lt;em&gt;必须&lt;/em&gt;在该字典中包括带括号的映射键，该键直接插入在 &lt;code&gt;'%'&lt;/code&gt; 字符之后。映射键从映射中选择要格式化的值。例如：</target>
        </trans-unit>
        <trans-unit id="d1b647f4b9964ada60f8adbae790c7e50f0a7417" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the string &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">当正确的参数是字典（或其他映射类型）时，字符串中的格式&lt;em&gt;必须&lt;/em&gt;在该字典中包含带括号的映射键，该键直接插入在 &lt;code&gt;'%'&lt;/code&gt; 字符之后。映射键从映射中选择要格式化的值。例如：</target>
        </trans-unit>
        <trans-unit id="8c542987ce2fae3c5dd363658acde3db213bccc7" translate="yes" xml:space="preserve">
          <source>When the timeout argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">当存在timeout参数而不是 &lt;code&gt;None&lt;/code&gt; 时，它应该是一个浮点数，以秒为单位（或其分数）指定操作的超时时间。</target>
        </trans-unit>
        <trans-unit id="dcaffd14aa04c2c35de2956e1ed898667e511dfc" translate="yes" xml:space="preserve">
          <source>When the underlying lock is an &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt;, it is not released using its &lt;a href=&quot;#threading.Condition.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method, since this may not actually unlock the lock when it was acquired multiple times recursively. Instead, an internal interface of the &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; class is used, which really unlocks it even when it has been recursively acquired several times. Another internal interface is then used to restore the recursion level when the lock is reacquired.</source>
          <target state="translated">当基础锁是&lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; 时&lt;/a&gt;，不会使用其&lt;a href=&quot;#threading.Condition.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;方法释放该锁，因为当递归多次获取锁时，它实际上可能不会解锁。而是使用&lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt;类的内部接口，即使递归获取了几次，它也可以真正将其解锁。重新获取锁后，另一个内部接口将用于恢复递归级别。</target>
        </trans-unit>
        <trans-unit id="a547e1586802e299eb73e97be7ee39d485999089" translate="yes" xml:space="preserve">
          <source>When the view in the widget&amp;rsquo;s window change, the widget will generate a Tcl command based on the scrollcommand.</source>
          <target state="translated">当窗口小部件窗口中的视图更改时，窗口小部件将基于滚动命令生成Tcl命令。</target>
        </trans-unit>
        <trans-unit id="befa970eff3f7ebe6809143ffe66cd7843089ead" translate="yes" xml:space="preserve">
          <source>When there are two numbers in the first column (for example &lt;code&gt;3/1&lt;/code&gt;), it means that the function recursed. The second value is the number of primitive calls and the former is the total number of calls. Note that when the function does not recurse, these two values are the same, and only the single figure is printed.</source>
          <target state="translated">如果第一列中有两个数字（例如 &lt;code&gt;3/1&lt;/code&gt; ），则表示函数已递归。第二个值是原始调用数，前一个是调用总数。请注意，当函数不递归时，这两个值相同，并且仅打印单个图形。</target>
        </trans-unit>
        <trans-unit id="ab22dc5a231f8fc7cacd590361630a5e4a9cd4ba" translate="yes" xml:space="preserve">
          <source>When there are very small differences among your tests, for instance some parameters, unittest allows you to distinguish them inside the body of a test method using the &lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt;&lt;code&gt;subTest()&lt;/code&gt;&lt;/a&gt; context manager.</source>
          <target state="translated">当测试之间的差异很小时（例如某些参数），unittest允许您使用&lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt; &lt;code&gt;subTest()&lt;/code&gt; &lt;/a&gt;上下文管理器在测试方法的主体内区分它们。</target>
        </trans-unit>
        <trans-unit id="83c77d278084a249196dc8ad39e0428b94116b8a" translate="yes" xml:space="preserve">
          <source>When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. This is done after the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file is read, so that you can set this hook there. The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module &lt;a href=&quot;site#rlcompleter-config&quot;&gt;sets this&lt;/a&gt;.</source>
          <target state="translated">当存在此属性时，以&lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;交互方式&lt;/a&gt;启动解释器时，将自动调用其值（不带参数）。这是在读取&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt;文件之后完成的，因此您可以在此处设置此挂钩。该&lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt;模块&lt;a href=&quot;site#rlcompleter-config&quot;&gt;设置此&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="176b8013f9b255204e913f81e2aad8839519f277" translate="yes" xml:space="preserve">
          <source>When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in &lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. This is done after the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-17&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file is read, so that you can set this hook there. The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module &lt;a href=&quot;site#rlcompleter-config&quot;&gt;sets this&lt;/a&gt;.</source>
          <target state="translated">当此属性存在时，以&lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;交互方式&lt;/a&gt;启动解释器时，将自动调用其值（不带参数）。这是在读取&lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-17&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt;文件之后完成的，因此您可以在此处设置此挂钩。该&lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt;模块&lt;a href=&quot;site#rlcompleter-config&quot;&gt;设置此&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca5561b0bcfc3026fbfdb899d58edadb60d7787f" translate="yes" xml:space="preserve">
          <source>When this module is imported on a Unix platform with the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module available, an instance of the &lt;code&gt;Completer&lt;/code&gt; class is automatically created and its &lt;code&gt;complete()&lt;/code&gt; method is set as the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; completer.</source>
          <target state="translated">在具有&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;模块可用的Unix平台上导入此模块时，会自动创建 &lt;code&gt;Completer&lt;/code&gt; 类的实例，并将其 &lt;code&gt;complete()&lt;/code&gt; 方法设置为&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; completer。</target>
        </trans-unit>
        <trans-unit id="51abaa779be741115f9981dd161abaf14ca5f234" translate="yes" xml:space="preserve">
          <source>When this module is run as a script, the &lt;a href=&quot;#py_compile.main&quot;&gt;&lt;code&gt;main()&lt;/code&gt;&lt;/a&gt; is used to compile all the files named on the command line. The exit status is nonzero if one of the files could not be compiled.</source>
          <target state="translated">当此模块作为脚本运行时，&lt;a href=&quot;#py_compile.main&quot;&gt; &lt;code&gt;main()&lt;/code&gt; &lt;/a&gt;用于编译在命令行上命名的所有文件。如果其中一个文件无法编译，则退出状态为非零。</target>
        </trans-unit>
        <trans-unit id="ad505c5cec1abb554c0e70fe34e8dfe5e8ee251d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a URL.</source>
          <target state="translated">指定此名称空间后，&lt;em&gt;名称&lt;/em&gt;字符串是URL。</target>
        </trans-unit>
        <trans-unit id="c4271730cf91863d7eba060c9ce05e17fb1e5d3d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a fully-qualified domain name.</source>
          <target state="translated">指定此名称空间后，&lt;em&gt;名称&lt;/em&gt;字符串是完全限定的域名。</target>
        </trans-unit>
        <trans-unit id="df57f6bd5424a2b48ed53224b034c92f20111436" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an ISO OID.</source>
          <target state="translated">指定此名称空间后，&lt;em&gt;名称&lt;/em&gt;字符串为ISO OID。</target>
        </trans-unit>
        <trans-unit id="b118949a5b99f77f5500b4d3f0d5939a3e84377f" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an X.500 DN in DER or a text output format.</source>
          <target state="translated">指定此命名空间后，&lt;em&gt;名称&lt;/em&gt;字符串是DER或文本输出格式的X.500 DN。</target>
        </trans-unit>
        <trans-unit id="1ac5dffa9ac6727f876535e5fe1228a53748f38d" translate="yes" xml:space="preserve">
          <source>When this variable is set to an integer value, it determines the maximum number of levels of traceback information printed when an unhandled exception occurs. The default is &lt;code&gt;1000&lt;/code&gt;. When set to &lt;code&gt;0&lt;/code&gt; or less, all traceback information is suppressed and only the exception type and value are printed.</source>
          <target state="translated">当此变量设置为整数值时，它将确定在发生未处理的异常时打印的回溯信息的最大级别数。默认值为 &lt;code&gt;1000&lt;/code&gt; 。当设置为 &lt;code&gt;0&lt;/code&gt; 或小于0时，将禁止所有回溯信息，并且仅打印异常类型和值。</target>
        </trans-unit>
        <trans-unit id="45ed44e1c2deee3726f1fb9e1612d293ad1c8ed8" translate="yes" xml:space="preserve">
          <source>When threads are enabled, this function can only be called from &lt;a href=&quot;#signals-and-threads&quot;&gt;the main thread of the main interpreter&lt;/a&gt;; attempting to call it from other threads will cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">启用线程后，只能从&lt;a href=&quot;#signals-and-threads&quot;&gt;主解释器的主线程&lt;/a&gt;调用此函数；尝试从其他线程调用它会导致引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="278cf1fb88404480dadf9b626eaab7ebb46fb611" translate="yes" xml:space="preserve">
          <source>When threads are enabled, this function can only be called from the main thread; attempting to call it from other threads will cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">启用线程后，只能从主线程调用此函数；尝试从其他线程调用它会导致引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="fa49c23d5b633ba09194c60a98a0663082ee806f" translate="yes" xml:space="preserve">
          <source>When to use __new__() vs. __init__()</source>
          <target state="translated">什么时候使用__new__()vs.__init__()</target>
        </trans-unit>
        <trans-unit id="ae8e822e628357a56fee4e1e237f47916afdb25d" translate="yes" xml:space="preserve">
          <source>When trying to answer questions of the form &amp;ldquo;how do I do blah&amp;rdquo;, it is often best to find out how to do &amp;ldquo;blah&amp;rdquo; in straight Tk, and then convert this back into the corresponding &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; call. Python programmers can often guess at the correct Python command by looking at the Tk documentation. This means that in order to use Tkinter, you will have to know a little bit about Tk. This document can&amp;rsquo;t fulfill that role, so the best we can do is point you to the best documentation that exists. Here are some hints:</source>
          <target state="translated">尝试回答&amp;ldquo;我该怎么做&amp;rdquo;形式的问题时，通常最好找出直行Tk中的&amp;ldquo;等等&amp;rdquo;，然后将其转换回相应的&lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt;调用。Python程序员通常可以通过查看Tk文档来猜测正确的Python命令。这意味着要使用Tkinter，您将必须对Tk有所了解。该文档不能发挥该作用，因此我们能做的最好的就是将您指向存在的最佳文档。这里有一些提示：</target>
        </trans-unit>
        <trans-unit id="76b7fde33d91393f4e37520e38b01684ea8be333" translate="yes" xml:space="preserve">
          <source>When trying to resolve a path that may contain links, use &lt;a href=&quot;os.path#os.path.realpath&quot;&gt;&lt;code&gt;realpath()&lt;/code&gt;&lt;/a&gt; to properly handle recursion and platform differences.</source>
          <target state="translated">尝试解析可能包含链接的路径时，请使用&lt;a href=&quot;os.path#os.path.realpath&quot;&gt; &lt;code&gt;realpath()&lt;/code&gt; &lt;/a&gt;正确处理递归和平台差异。</target>
        </trans-unit>
        <trans-unit id="2f3811d14f89d59ba51a06a1a040db1eba48fe96" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; (default to &lt;code&gt;'test'&lt;/code&gt;) for choosing which methods to wrap:</source>
          <target state="translated">当作为一类的装饰用&lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt;荣誉 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; （默认到 &lt;code&gt;'test'&lt;/code&gt; ），用于选择哪个方法来包装：</target>
        </trans-unit>
        <trans-unit id="705e7c80833fc33cb99db4df5a3694a333edc598" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">当作为一类的装饰用&lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt;荣誉 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 用于选择包哪些方法。</target>
        </trans-unit>
        <trans-unit id="5b03309707733138089592715f0e9b9ff4448b18" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">当作为一类的装饰用&lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt;荣誉 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 用于选择包哪些方法。</target>
        </trans-unit>
        <trans-unit id="fba105ce35abd2dc08e1a686f3ddd015c632904f" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">当用作上下文管理器时，&lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt;接受附加的关键字参数&lt;em&gt;msg&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="83414cd2e98b72f702142fb8a769008e29f7a984" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">当用作上下文管理器时，&lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt;接受附加的关键字参数&lt;em&gt;msg&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a119452aa32cdce61667b0d150a3806d0c9b047c" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the year are specified.</source>
          <target state="translated">与&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt;函数一起使用时，仅当指定星期几和年份时， &lt;code&gt;%U&lt;/code&gt; 和 &lt;code&gt;%W&lt;/code&gt; 仅用于计算。</target>
        </trans-unit>
        <trans-unit id="7c496b450e8c39131b7391ec30143aac02a4ea29" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">当与&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt;函数一起使用时，仅当 &lt;code&gt;%I&lt;/code&gt; 指令用于解析小时时， &lt;code&gt;%p&lt;/code&gt; 指令才会影响输出小时字段。</target>
        </trans-unit>
        <trans-unit id="53f6e3b18d54172809724ec98b1116def825fde0" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the calendar year (&lt;code&gt;%Y&lt;/code&gt;) are specified.</source>
          <target state="translated">当与 &lt;code&gt;strptime()&lt;/code&gt; 方法一起使用时，仅当指定星期几和日历年（ &lt;code&gt;%Y&lt;/code&gt; ）时， &lt;code&gt;%U&lt;/code&gt; 和 &lt;code&gt;%W&lt;/code&gt; 仅用于计算。</target>
        </trans-unit>
        <trans-unit id="4b2ee1207071c0489d96d299dd458032cc3f29e2" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%f&lt;/code&gt; directive accepts from one to six digits and zero pads on the right. &lt;code&gt;%f&lt;/code&gt; is an extension to the set of format characters in the C standard (but implemented separately in datetime objects, and therefore always available).</source>
          <target state="translated">与 &lt;code&gt;strptime()&lt;/code&gt; 方法一起使用时， &lt;code&gt;%f&lt;/code&gt; 伪指令接受1到6位数字和右边的零填充。 &lt;code&gt;%f&lt;/code&gt; 是对C标准格式字符集的扩展（但在日期时间对象中单独实现，因此始终可用）。</target>
        </trans-unit>
        <trans-unit id="dc1c5087fa82a6d1840533fce5b820256e369ddd" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">与 &lt;code&gt;strptime()&lt;/code&gt; 方法一起使用时，仅当 &lt;code&gt;%I&lt;/code&gt; 指令用于解析小时时， &lt;code&gt;%p&lt;/code&gt; 指令才会影响输出小时字段。</target>
        </trans-unit>
        <trans-unit id="8b8a227fcef52e704757038bfb5a5f8a8ba80e0a" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the leading zero is optional for formats &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%m&lt;/code&gt;, &lt;code&gt;%H&lt;/code&gt;, &lt;code&gt;%I&lt;/code&gt;, &lt;code&gt;%M&lt;/code&gt;, &lt;code&gt;%S&lt;/code&gt;, &lt;code&gt;%J&lt;/code&gt;, &lt;code&gt;%U&lt;/code&gt;, &lt;code&gt;%W&lt;/code&gt;, and &lt;code&gt;%V&lt;/code&gt;. Format &lt;code&gt;%y&lt;/code&gt; does require a leading zero.</source>
          <target state="translated">与 &lt;code&gt;strptime()&lt;/code&gt; 方法一起使用时，对于格式 &lt;code&gt;%d&lt;/code&gt; ， &lt;code&gt;%m&lt;/code&gt; ， &lt;code&gt;%H&lt;/code&gt; ， &lt;code&gt;%I&lt;/code&gt; ， &lt;code&gt;%M&lt;/code&gt; ， &lt;code&gt;%S&lt;/code&gt; ， &lt;code&gt;%J&lt;/code&gt; ， &lt;code&gt;%U&lt;/code&gt; ， &lt;code&gt;%W&lt;/code&gt; 和 &lt;code&gt;%V&lt;/code&gt; ，前导零是可选的。格式 &lt;code&gt;%y&lt;/code&gt; 确实需要前导零。</target>
        </trans-unit>
        <trans-unit id="8993c4db89e355448ee2758089ff089b6167f894" translate="yes" xml:space="preserve">
          <source>When user code raises SystemExit either directly or by calling sys.exit, IDLE returns to a Shell prompt instead of exiting.</source>
          <target state="translated">当用户代码直接或通过调用sys.exit引发SystemExit时,IDLE会返回Shell提示而不是退出。</target>
        </trans-unit>
        <trans-unit id="e8d99d6e745dcc773c5780813fa3d777f5ab117b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#cmdoption-trace-r&quot;&gt;&lt;code&gt;--report&lt;/code&gt;&lt;/a&gt;, write a brief summary to stdout for each file processed.</source>
          <target state="translated">使用&lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#cmdoption-trace-r&quot;&gt; &lt;code&gt;--report&lt;/code&gt; 时&lt;/a&gt;，为每个处理的文件向stdout编写一个简短的摘要。</target>
        </trans-unit>
        <trans-unit id="d69285961c4bd67c93bcd61d97d840352615a6b6" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt;, this method chops &lt;em&gt;iterables&lt;/em&gt; into a number of chunks which it submits to the pool as separate tasks. The (approximate) size of these chunks can be specified by setting &lt;em&gt;chunksize&lt;/em&gt; to a positive integer. For very long iterables, using a large value for &lt;em&gt;chunksize&lt;/em&gt; can significantly improve performance compared to the default size of 1. With &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;chunksize&lt;/em&gt; has no effect.</source>
          <target state="translated">使用&lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 时&lt;/a&gt;，此方法&lt;em&gt;将可迭代项&lt;/em&gt;分为许多块，将其作为单独的任务提交给池。这些块的（大约）大小可以通过将&lt;em&gt;chunksize&lt;/em&gt;设置为正整数来指定。对于很长的iterables，采用大值&lt;em&gt;CHUNKSIZE&lt;/em&gt;可以显著提高性能相比，1默认大小有了&lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的&lt;/a&gt;，&lt;em&gt;CHUNKSIZE&lt;/em&gt;没有效果。</target>
        </trans-unit>
        <trans-unit id="67dbf8b14ab5b34c346cf0ec2ca601d364ad77a4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;shell=True&lt;/code&gt;, the &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and shell metacharacters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">当使用 &lt;code&gt;shell=True&lt;/code&gt; 时，&lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt;函数可用于适当地转义将用于构造Shell命令的字符串中的空格和Shell元字符。</target>
        </trans-unit>
        <trans-unit id="be8018ded6871ec6f5c2db4b1df5eb57ea72056b" translate="yes" xml:space="preserve">
          <source>When using IDLE, tooltips show the signatures and first lines of the docstrings of typed in function-/method calls.</source>
          <target state="translated">当使用IDLE时,工具提示会显示函数/方法调用的签名和docstrings的第一行。</target>
        </trans-unit>
        <trans-unit id="6a5ee388e1f0b24ab337fb675482fe01a76a1b13" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;SharedMemoryManager&lt;/code&gt; in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the shared memory blocks created using that manager are all released when the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s code block finishes execution.</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句中使用 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 时，在&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句的代码块完成执行时，将释放使用该管理器创建的共享内存块。</target>
        </trans-unit>
        <trans-unit id="f1f4fd3135a6c1c4c361b9300a12a8082ea070bb" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;SharedMemoryManager&lt;/code&gt; in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the shared memory blocks created using that manager are all released when the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s code block finishes execution.</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句中使用 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 时，在&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句的代码块完成执行时，将释放使用该管理器创建的共享内存块。</target>
        </trans-unit>
        <trans-unit id="cff5871a771c52192ce76b27da8593fb1ba702e3" translate="yes" xml:space="preserve">
          <source>When using any of the policy objects derived from &lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt;, all headers are produced by &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt; and have &lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt;&lt;code&gt;BaseHeader&lt;/code&gt;&lt;/a&gt; as their last base class. Each header class has an additional base class that is determined by the type of the header. For example, many headers have the class &lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt;&lt;code&gt;UnstructuredHeader&lt;/code&gt;&lt;/a&gt; as their other base class. The specialized second class for a header is determined by the name of the header, using a lookup table stored in the &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;. All of this is managed transparently for the typical application program, but interfaces are provided for modifying the default behavior for use by more complex applications.</source>
          <target state="translated">使用从&lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; &lt;/a&gt;派生的任何策略对象时，所有标头均由&lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; &lt;/a&gt;生成，并将&lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt; &lt;code&gt;BaseHeader&lt;/code&gt; &lt;/a&gt;作为其最后一个基类。每个标头类都有一个附加的基类，该基类由标头的类型确定。例如，许多标头将&lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt; &lt;code&gt;UnstructuredHeader&lt;/code&gt; &lt;/a&gt;类作为其其他基类。头的专用第二类&lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; &lt;/a&gt;的名称确定，使用存储在HeaderRegistry中的查找表。对于典型的应用程序，所有这些都是透明管理的，但是提供了用于修改默认行为以供更复杂的应用程序使用的接口。</target>
        </trans-unit>
        <trans-unit id="b05e16fdd139b928e5d9f97d7e26405bb10ad23a" translate="yes" xml:space="preserve">
          <source>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects. This method is maintained for backward compatibility and should be avoided in new code. The buffer interface is documented in &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;.</source>
          <target state="translated">使用C或C ++编写的代码中的数组对象（有效利用此信息的唯一方法）时，使用数组对象支持的缓冲区接口更有意义。维护此方法是为了实现向后兼容，因此在新代码中应避免使用此方法。缓冲区接口记录在&lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;缓冲区协议中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01c71a3439a3427537cb3ed1f93938eddd01e21c" translate="yes" xml:space="preserve">
          <source>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects. This method is maintained for backward compatibility and should be avoided in new code. The buffer interface is documented in &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;.</source>
          <target state="translated">使用C或C ++编写的代码中的数组对象（有效利用此信息的唯一方法）时，使用数组对象支持的缓冲区接口更有意义。维护此方法是为了实现向后兼容，因此在新代码中应避免使用此方法。缓冲区接口记录在&lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;缓冲区协议中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6b80cace7f20688ab820fe8baf0df818b93de50" translate="yes" xml:space="preserve">
          <source>When using multiple processes, one generally uses message passing for communication between processes and avoids having to use any synchronization primitives like locks.</source>
          <target state="translated">当使用多个进程时,一般使用消息传递在进程之间进行通信,避免使用任何同步基元(如锁)。</target>
        </trans-unit>
        <trans-unit id="bfd6a46b825093b75110261b57205d3c8b35775e" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods many types from &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; need to be picklable so that child processes can use them. However, one should generally avoid sending shared objects to other processes using pipes or queues. Instead you should arrange the program so that a process which needs access to a shared resource created elsewhere can inherit it from an ancestor process.</source>
          <target state="translated">使用&lt;em&gt;spawn&lt;/em&gt;或&lt;em&gt;forkserver&lt;/em&gt;启动方法时，&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt;许多类型都需要可腌制，以便子进程可以使用它们。但是，通常应该避免使用管道或队列将共享对象发送到其他进程。相反，您应该安排程序，以便需要访问在其他位置创建的共享资源的进程可以从祖先进程继承该程序。</target>
        </trans-unit>
        <trans-unit id="c0f3d8f9182ed3d95d5c0426514f0709e918d398" translate="yes" xml:space="preserve">
          <source>When using this pattern, remember that all classes that inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; are run as tests. The &lt;code&gt;Mixin&lt;/code&gt; class in the example above does not have any data and so can&amp;rsquo;t be run by itself, thus it does not inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用此模式时，请记住所有从&lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt;继承的类都作为测试运行。上面的示例中的 &lt;code&gt;Mixin&lt;/code&gt; 类没有任何数据，因此无法单独运行，因此它不继承自&lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bc63598e62f8448d98f0887d22314a85ab47257" translate="yes" xml:space="preserve">
          <source>When using weekday-based rotation, specify &amp;lsquo;W0&amp;rsquo; for Monday, &amp;lsquo;W1&amp;rsquo; for Tuesday, and so on up to &amp;lsquo;W6&amp;rsquo; for Sunday. In this case, the value passed for &lt;em&gt;interval&lt;/em&gt; isn&amp;rsquo;t used.</source>
          <target state="translated">使用基于工作日的轮播时，将&amp;ldquo; W0&amp;rdquo;指定为星期一，将&amp;ldquo; W1&amp;rdquo;指定为星期二，依此类推，直到&amp;ldquo; W6&amp;rdquo;指定为星期日。在这种情况下，不使用为&lt;em&gt;interval&lt;/em&gt;传递的值。</target>
        </trans-unit>
        <trans-unit id="d6aea84bd51b5a34854466c47a84c480e9d183e1" translate="yes" xml:space="preserve">
          <source>When working in a command shell, users can make a virtual environment active by running an &lt;code&gt;activate&lt;/code&gt; script in the virtual environment&amp;rsquo;s executables directory (the precise filename and command to use the file is shell-dependent), which prepends the virtual environment&amp;rsquo;s directory for executables to the &lt;code&gt;PATH&lt;/code&gt; environment variable for the running shell. There should be no need in other circumstances to activate a virtual environment; scripts installed into virtual environments have a &amp;ldquo;shebang&amp;rdquo; line which points to the virtual environment&amp;rsquo;s Python interpreter. This means that the script will run with that interpreter regardless of the value of &lt;code&gt;PATH&lt;/code&gt;. On Windows, &amp;ldquo;shebang&amp;rdquo; line processing is supported if you have the Python Launcher for Windows installed (this was added to Python in 3.3 - see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt; for more details). Thus, double-clicking an installed script in a Windows Explorer window should run the script with the correct interpreter without there needing to be any reference to its virtual environment in &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">在命令外壳中工作时，用户可以通过在虚拟环境的可执行文件目录中运行 &lt;code&gt;activate&lt;/code&gt; 脚本（使用该文件的确切文件名和命令取决于外壳）来激活虚拟环境，这会将虚拟环境的目录添加到可执行文件之前正在运行的shell 的 &lt;code&gt;PATH&lt;/code&gt; 环境变量。在其他情况下，无需激活虚拟环境。安装到虚拟环境中的脚本的&amp;ldquo; shebang&amp;rdquo;行指向虚拟环境的Python解释器。这意味着脚本将与该解释器一起运行，而不管 &lt;code&gt;PATH&lt;/code&gt; 的值如何。在Windows上，如果您安装了适用于Windows的Python启动器，则支持&amp;ldquo; shebang&amp;rdquo;行处理（此功能已在3.3中添加到Python中- 有关更多详细信息，请参见&lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt;）。因此，在Windows资源管理器窗口中双击已安装的脚本应使用正确的解释器运行该脚本，而无需在 &lt;code&gt;PATH&lt;/code&gt; 中对其虚拟环境进行任何引用。</target>
        </trans-unit>
        <trans-unit id="a8a8029dbde9896495f35f3b5cc6049139cf4061" translate="yes" xml:space="preserve">
          <source>When writing a docstring, choose docstring examples with care. There&amp;rsquo;s an art to this that needs to be learned&amp;mdash;it may not be natural at first. Examples should add genuine value to the documentation. A good example can often be worth many words. If done with care, the examples will be invaluable for your users, and will pay back the time it takes to collect them many times over as the years go by and things change. I&amp;rsquo;m still amazed at how often one of my &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; examples stops working after a &amp;ldquo;harmless&amp;rdquo; change.</source>
          <target state="translated">编写文档字符串时，请小心选择文档字符串示例。这是一门需要学习的艺术，一开始可能并不自然。示例应为文档增添真正的价值。一个好榜样通常值得多说。如果精心制作，这些示例对于您的用户将是无价的，并且将随着时间的流逝和情况的变化而返还多次收集它们所花费的时间。我仍然对我的一个&lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt;示例在&amp;ldquo;无害&amp;rdquo;更改后停止工作的频率感到惊讶。</target>
        </trans-unit>
        <trans-unit id="8592ae082c5c9b46046c7a2f018c32ed0f608909" translate="yes" xml:space="preserve">
          <source>When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass &lt;code&gt;force_zip64=True&lt;/code&gt; to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object with &lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt;&lt;code&gt;file_size&lt;/code&gt;&lt;/a&gt; set, and use that as the &lt;em&gt;name&lt;/em&gt; parameter.</source>
          <target state="translated">写入文件时，如果文件大小事先未知，但可能超过2 GiB，请传递 &lt;code&gt;force_zip64=True&lt;/code&gt; 以确保头格式能够支持大文件。如果预先知道文件大小，则构造一个设置了&lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt; &lt;code&gt;file_size&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;对象，并将其用作&lt;em&gt;name&lt;/em&gt;参数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eabb64e4773edb5fffc016299f8bed93923cd8c" translate="yes" xml:space="preserve">
          <source>When writing output to the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the system default line separator, &lt;a href=&quot;os#os.linesep&quot;&gt;&lt;code&gt;os.linesep&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt;, no translation takes place. If &lt;em&gt;newline&lt;/em&gt; is any of the other legal values, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the given string.</source>
          <target state="translated">将输出写入流时，如果&lt;em&gt;换行符&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则写入的所有 &lt;code&gt;'\n'&lt;/code&gt; 字符都将转换为系统默认的行分隔符&lt;a href=&quot;os#os.linesep&quot;&gt; &lt;code&gt;os.linesep&lt;/code&gt; &lt;/a&gt;。如果&lt;em&gt;换行符&lt;/em&gt;是 &lt;code&gt;''&lt;/code&gt; 或 &lt;code&gt;'\n'&lt;/code&gt; ，则不会进行翻译。如果&lt;em&gt;换行符&lt;/em&gt;是其他任何合法值，则将写入的所有 &lt;code&gt;'\n'&lt;/code&gt; 字符转换为给定的字符串。</target>
        </trans-unit>
        <trans-unit id="067f2ecb8b6372c1f3e42f05250baae071a8c1df" translate="yes" xml:space="preserve">
          <source>When writing to the path fails because the path is read-only (&lt;a href=&quot;errno#errno.EACCES&quot;&gt;&lt;code&gt;errno.EACCES&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt;), do not propagate the exception.</source>
          <target state="translated">当由于路径是只读（&lt;a href=&quot;errno#errno.EACCES&quot;&gt; &lt;code&gt;errno.EACCES&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt;）而导致写入路径失败时，请勿传播该异常。</target>
        </trans-unit>
        <trans-unit id="248ff5afb565bdd43eb7abc7973b09733b696289" translate="yes" xml:space="preserve">
          <source>When writing to this object, data is normally placed into an internal buffer. The buffer will be written out to the underlying &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; object under various conditions, including:</source>
          <target state="translated">写入该对象时，通常将数据放入内部缓冲区。在各种情况下，缓冲区将被写出到基础&lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt;对象，包括：</target>
        </trans-unit>
        <trans-unit id="0aec152755409343dddc07ce07a2031e69c7060e" translate="yes" xml:space="preserve">
          <source>When you are finished with a DOM tree, you may optionally call the &lt;code&gt;unlink()&lt;/code&gt; method to encourage early cleanup of the now-unneeded objects. &lt;code&gt;unlink()&lt;/code&gt; is an &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;-specific extension to the DOM API that renders the node and its descendants are essentially useless. Otherwise, Python&amp;rsquo;s garbage collector will eventually take care of the objects in the tree.</source>
          <target state="translated">完成DOM树后，可以选择调用 &lt;code&gt;unlink()&lt;/code&gt; 方法，以鼓励及早清除现在不需要的对象。 &lt;code&gt;unlink()&lt;/code&gt; 是DOM API 的&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt;特定扩展，它使节点及其后代基本上没有用。否则，Python的垃圾收集器将最终处理树中的对象。</target>
        </trans-unit>
        <trans-unit id="d8b4b9124db1d9506c6395b32b710d76c6d1388e" translate="yes" xml:space="preserve">
          <source>When you attach a mock as an attribute of another mock (or as the return value) it becomes a &amp;ldquo;child&amp;rdquo; of that mock. Calls to the child are recorded in the &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; attributes of the parent. This is useful for configuring child mocks and then attaching them to the parent, or for attaching mocks to a parent that records all calls to the children and allows you to make assertions about the order of calls between mocks:</source>
          <target state="translated">当您将一个模拟作为另一个模拟的属性（或作为返回值）附加时，它将成为该模拟的&amp;ldquo;子代&amp;rdquo;。对子项的调用记录在父项的&lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt;属性中。这对于配置子模拟然后将它们附加到父代，或将模拟附加到父代很有用，它记录了对子代的所有调用，并允许您声明模拟之间的调用顺序：</target>
        </trans-unit>
        <trans-unit id="be1b470500af8dd6da06d2ce49d4cefe28a83a6b" translate="yes" xml:space="preserve">
          <source>When you compile a node tree with &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, the compiler expects &lt;code&gt;lineno&lt;/code&gt; and &lt;code&gt;col_offset&lt;/code&gt; attributes for every node that supports them. This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node. It works recursively starting at &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">当使用&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt;编译节点树时，编译器期望每个支持它们的节点的 &lt;code&gt;lineno&lt;/code&gt; 和 &lt;code&gt;col_offset&lt;/code&gt; 属性。填写生成的节点非常繁琐，因此该帮助程序通过将其设置为父节点的值，以递归方式将这些属性添加到尚未设置的位置。它从&lt;em&gt;node&lt;/em&gt;开始递归工作。</target>
        </trans-unit>
        <trans-unit id="8168a6e30b1a0dd14b3d6bed0aa248b7873034b1" translate="yes" xml:space="preserve">
          <source>When you have a consistent answer, there are three ways you can use it:</source>
          <target state="translated">当你有一个一致的答案时,有三种方法可以使用它。</target>
        </trans-unit>
        <trans-unit id="980c6f4da1cfe70fd805b5d970a5223e7e867fdd" translate="yes" xml:space="preserve">
          <source>When you have finished providing data to the compressor, call the &lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; method to finish the compression process.</source>
          <target state="translated">完成向压缩器提供数据后，请调用&lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt;方法完成压缩过程。</target>
        </trans-unit>
        <trans-unit id="ebaa64dbb3e64356296053a73cf19b2addb5348d" translate="yes" xml:space="preserve">
          <source>When you have placed your tests in a module, the module can itself be the test runner. When a test fails, you can arrange for your test runner to re-run only the failing doctest while you debug the problem. Here is a minimal example of such a test runner:</source>
          <target state="translated">当你把你的测试放在一个模块中时,这个模块本身就可以是测试运行器。当一个测试失败时,你可以安排你的测试运行程序在调试问题时只重新运行失败的doctest。这里是这样一个测试运行程序的最小例子。</target>
        </trans-unit>
        <trans-unit id="f6bcd3b04b0d7cac7cf2e9d8396970c1121f17d6" translate="yes" xml:space="preserve">
          <source>When you nest patch decorators the mocks are passed in to the decorated function in the same order they applied (the normal &lt;em&gt;Python&lt;/em&gt; order that decorators are applied). This means from the bottom up, so in the example above the mock for &lt;code&gt;module.ClassName1&lt;/code&gt; is passed in first.</source>
          <target state="translated">当您嵌套补丁装饰器时，模拟将以它们应用的顺序（装饰器的正常&lt;em&gt;Python&lt;/em&gt;顺序）传递给装饰的函数。这意味着自下而上，因此在上面的示例中，模块 &lt;code&gt;module.ClassName1&lt;/code&gt; 的模拟首先传入。</target>
        </trans-unit>
        <trans-unit id="4d0ae07c9462ed9e0e688008d531cdc33cae796d" translate="yes" xml:space="preserve">
          <source>When you use the context to connect to a server, &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; validate the server certificate: it ensures that the server certificate was signed with one of the CA certificates, checks the signature for correctness, and verifies other properties like validity and identity of the hostname:</source>
          <target state="translated">当您使用上下文连接到服务器时，&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; 会&lt;/a&gt;验证服务器证书：它确保使用CA证书之一对服务器证书进行签名，检查签名的正确性，并验证其他属性，例如证书的有效性和身份。主机名：</target>
        </trans-unit>
        <trans-unit id="693ee6b490569d4d5711a3b5add559ce77978de6" translate="yes" xml:space="preserve">
          <source>When you write a new script, consider adding these lines:</source>
          <target state="translated">当你写一个新的脚本时,可以考虑添加这些行。</target>
        </trans-unit>
        <trans-unit id="205afaa9a1fee6195f966485ecd67e9562f2bb6a" translate="yes" xml:space="preserve">
          <source>Whenever &lt;em&gt;x&lt;/em&gt; or &lt;em&gt;y&lt;/em&gt; arguments to a function or a method are optional, they default to the current cursor location. Whenever &lt;em&gt;attr&lt;/em&gt; is optional, it defaults to &lt;code&gt;A_NORMAL&lt;/code&gt;.</source>
          <target state="translated">每当函数或方法的&lt;em&gt;x&lt;/em&gt;或&lt;em&gt;y&lt;/em&gt;参数是可选的时，它们默认为当前光标位置。只要&lt;em&gt;attr&lt;/em&gt;是可选的，它默认为 &lt;code&gt;A_NORMAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8765d4b8962f94d6b6eef545316618c01d52eff3" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character string&lt;/em&gt; it can be specified as a Unicode string or a byte string.</source>
          <target state="translated">无论何时文档提到&lt;em&gt;字符串&lt;/em&gt;，都可以将其指定为Unicode字符串或字节字符串。</target>
        </trans-unit>
        <trans-unit id="999400ad526ca682840c4c4ec0cf126c5252625e" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character&lt;/em&gt; it can be specified as an integer, a one-character Unicode string or a one-byte byte string.</source>
          <target state="translated">只要文档中提到一个&lt;em&gt;字符，&lt;/em&gt;就可以将其指定为整数，一字符Unicode字符串或一字节字节的字符串。</target>
        </trans-unit>
        <trans-unit id="e6bfb2c4bd7e77dce0abe22138a5a1dba3fd4d8e" translate="yes" xml:space="preserve">
          <source>Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is &lt;code&gt;1.0&lt;/code&gt; if the sequences are identical, and &lt;code&gt;0.0&lt;/code&gt; if they have nothing in common.</source>
          <target state="translated">其中T是两个序列中元素的总数，M是匹配数，这是2.0 * M /T。请注意，如果序列相同，则为 &lt;code&gt;1.0&lt;/code&gt; ;如果没有相同之处，则为 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0698d3446ab96f16d8d0f4a7d46e511ffaa1b1a" translate="yes" xml:space="preserve">
          <source>Where the components are:</source>
          <target state="translated">组成部分在哪里。</target>
        </trans-unit>
        <trans-unit id="9043b61aa57de9fe6a9cd0fbf895ea057d46ea33" translate="yes" xml:space="preserve">
          <source>Where the following options are understood:</source>
          <target state="translated">其中,以下选项理解为:</target>
        </trans-unit>
        <trans-unit id="f5a5f04e05ccffc4c2734a94e36079f88e06a02b" translate="yes" xml:space="preserve">
          <source>Where there is no registered implementation for a specific type, its method resolution order is used to find a more generic implementation. The original function decorated with &lt;code&gt;@singledispatch&lt;/code&gt; is registered for the base &lt;code&gt;object&lt;/code&gt; type, which means it is used if no better implementation is found.</source>
          <target state="translated">如果没有针对特定类型的注册实现，则使用其方法解析顺序来查找更通用的实现。用 &lt;code&gt;@singledispatch&lt;/code&gt; 装饰的原始函数已为基础 &lt;code&gt;object&lt;/code&gt; 类型注册，这意味着如果找不到更好的实现，则使用该函数。</target>
        </trans-unit>
        <trans-unit id="53573fb4e5abc3ff45094b0052fde922a5a87848" translate="yes" xml:space="preserve">
          <source>Where to patch</source>
          <target state="translated">哪里可以打补丁</target>
        </trans-unit>
        <trans-unit id="c18e7a9c733c88bde9faa67d79db05fefdfd3ec9" translate="yes" xml:space="preserve">
          <source>Wherever the former background character appears, it is changed to the new background character.</source>
          <target state="translated">凡是原背景字符出现的地方,都会改成新的背景字符。</target>
        </trans-unit>
        <trans-unit id="0a042ada48fa9e3c00cffdff61a30274621080e2" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; falls back to verify the cert&amp;rsquo;s subject common name in the absence of a subject alternative name extension (default: true).</source>
          <target state="translated">在没有使用者替代名称扩展名的情况下，&lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt;是否回退以验证证书的使用者通用名称（默认值：true）。</target>
        </trans-unit>
        <trans-unit id="8cd43d90a2c53503d089732d23dcac513590b751" translate="yes" xml:space="preserve">
          <source>Whether &lt;em&gt;K&lt;/em&gt; is a member of the set of keys of a &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">是否&lt;em&gt;ķ&lt;/em&gt;是集合A的键的成员&lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d302d51b9f99d9aa32a01277d93fb96ac09ca34" translate="yes" xml:space="preserve">
          <source>Whether a frame is considered to originate in a certain module is determined by the &lt;code&gt;__name__&lt;/code&gt; in the frame globals.</source>
          <target state="translated">帧是否被认为起源于某个模块由帧全局变量中的 &lt;code&gt;__name__&lt;/code&gt; 确定。</target>
        </trans-unit>
        <trans-unit id="a943fe736644b8b8c93795478580ff25f5fcf6e7" translate="yes" xml:space="preserve">
          <source>Whether line buffering is enabled.</source>
          <target state="translated">是否启用行缓冲。</target>
        </trans-unit>
        <trans-unit id="0c5318374911071b186050497110ee2859024b25" translate="yes" xml:space="preserve">
          <source>Whether or not overlap regions for self-intersecting polygons or multiple shapes are filled depends on the operating system graphics, type of overlap, and number of overlaps. For example, the Turtle star above may be either all yellow or have some white regions.</source>
          <target state="translated">自交多边形或多个图形的重叠区域是否被填充,取决于操作系统图形、重叠的类型和重叠的数量。例如,上面的龟星可能全部是黄色或有一些白色区域。</target>
        </trans-unit>
        <trans-unit id="04435c32a748b091872ac0d2173dbfad57d8cf08" translate="yes" xml:space="preserve">
          <source>Whether or not two values are considered close is determined according to given absolute and relative tolerances.</source>
          <target state="translated">根据给定的绝对公差和相对公差来确定两个值是否接近。</target>
        </trans-unit>
        <trans-unit id="704f9ab62db9376e10128b17cb17cbd1569fe1d7" translate="yes" xml:space="preserve">
          <source>Whether output is buffered is usually determined by &lt;em&gt;file&lt;/em&gt;, but if the &lt;em&gt;flush&lt;/em&gt; keyword argument is true, the stream is forcibly flushed.</source>
          <target state="translated">输出是否被缓冲通常由&lt;em&gt;file&lt;/em&gt;确定，但是如果&lt;em&gt;flush&lt;/em&gt;关键字参数为true，则将强制刷新流。</target>
        </trans-unit>
        <trans-unit id="e9704f5d09c8a18f1f4b364c56355a76782182d8" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Application-Layer Protocol Negotiation&lt;/em&gt; TLS extension as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301中&lt;/strong&gt;&lt;/a&gt;所述，OpenSSL库是否具有对&lt;em&gt;应用程序层协议协商&lt;/em&gt; TLS扩展的内置支持。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f75f6bb7fcb11e2f45c69c0a7ca4c4682d4f5923" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Next Protocol Negotiation&lt;/em&gt; as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;Application Layer Protocol Negotiation&lt;/a&gt;. When true, you can use the &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt;&lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt;&lt;/a&gt; method to advertise which protocols you want to support.</source>
          <target state="translated">如&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;应用层协议协商中&lt;/a&gt;所述，OpenSSL库是否具有对&lt;em&gt;下一协议协商的&lt;/em&gt;内置支持。如果为true，则可以使用&lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt; &lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt; &lt;/a&gt;方法来播发要支持的协议。</target>
        </trans-unit>
        <trans-unit id="7a2de0f65d5d2e9aa283fe9814ef530df9f4d7f4" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Server Name Indication&lt;/em&gt; extension (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">OpenSSL库是否具有对&lt;em&gt;服务器名称指示&lt;/em&gt;扩展名的内置支持（如&lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066中&lt;/strong&gt;&lt;/a&gt;所定义）。</target>
        </trans-unit>
        <trans-unit id="f10549c2669f338103d9d69275acd6ff0bb42f85" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the Elliptic Curve-based Diffie-Hellman key exchange. This should be true unless the feature was explicitly disabled by the distributor.</source>
          <target state="translated">OpenSSL 库是否内置了对基于椭圆曲线的 Diffie-Hellman 密钥交换的支持。这应该是真的,除非分发者明确地禁用了该功能。</target>
        </trans-unit>
        <trans-unit id="189c811d0c4a89efbb0bd31d293ff4f4943d0dbe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对SSL 2.0协议的支持。</target>
        </trans-unit>
        <trans-unit id="cc2afc4d9cd37973dffe79768c99919a50576238" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对SSL 3.0协议的支持。</target>
        </trans-unit>
        <trans-unit id="89e2466bdf6938ea2d60c44e09f1c3edaea29f39" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对TLS 1.0协议的支持。</target>
        </trans-unit>
        <trans-unit id="adb5564adfd4cdc59e03f6665550cc56692d4f99" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对TLS 1.1协议的支持。</target>
        </trans-unit>
        <trans-unit id="cca6b49130e274478019943c2fbeb20a7cbc1d17" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对TLS 1.2协议的支持。</target>
        </trans-unit>
        <trans-unit id="e350ddccc623cf6675373d55c31c906ec7237c92" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.</source>
          <target state="translated">OpenSSL库是否内置了对TLS 1.3协议的支持。</target>
        </trans-unit>
        <trans-unit id="fb7e4191f43e54b167216c9758819c2068bd3dfe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support not checking subject common name and &lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt;&lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt;&lt;/a&gt; is writeable.</source>
          <target state="translated">OpenSSL库是否具有内置支持而不检查主题公用名和&lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt; &lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt; &lt;/a&gt;是可写的。</target>
        </trans-unit>
        <trans-unit id="88f23b4bf4e20fc7a9bdac4783297fabf3f1c246" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol is separated from the value by a space (for positive resp. negative values).</source>
          <target state="translated">货币符号与数值之间是否用空格隔开(对于正值或负值)。</target>
        </trans-unit>
        <trans-unit id="7bb65cdf22c5687fc74b96fb5b3b8c68399e1532" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol precedes the value (for positive resp. negative values).</source>
          <target state="translated">货币符号是否在数值之前(对于正值或负值)。</target>
        </trans-unit>
        <trans-unit id="b6318ba22ae30ad3468f9876a3fd1a5745b34ced" translate="yes" xml:space="preserve">
          <source>Whether the data is buffered, chunked or reassembled depends on the transport. In general, you shouldn&amp;rsquo;t rely on specific semantics and instead make your parsing generic and flexible. However, data is always received in the correct order.</source>
          <target state="translated">数据是缓冲，分块还是重组取决于传输方式。通常，您不应该依赖于特定的语义，而应该使解析具有通用性和灵活性。但是，始终以正确的顺序接收数据。</target>
        </trans-unit>
        <trans-unit id="728787761dd4dda0e68398ac7fa7afe469103a47" translate="yes" xml:space="preserve">
          <source>Whether the path points to an existing file or directory:</source>
          <target state="translated">路径是否指向现有的文件或目录。</target>
        </trans-unit>
        <trans-unit id="7c0b74000f7c6661d85ff5da8e8055be52233230" translate="yes" xml:space="preserve">
          <source>Whether the server will allow the reuse of an address. This defaults to &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, and can be set in subclasses to change the policy.</source>
          <target state="translated">服务器是否允许重用地址。默认为&lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;，并且可以在子类中设置以更改策略。</target>
        </trans-unit>
        <trans-unit id="4273367589a735b6de5ee51a98d1f45ef36ee8a3" translate="yes" xml:space="preserve">
          <source>Whether to match the peer cert&amp;rsquo;s hostname with &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt;. The context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, and you must pass &lt;em&gt;server_hostname&lt;/em&gt; to &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; in order to match the hostname. Enabling hostname checking automatically sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. It cannot be set back to &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; as long as hostname checking is enabled. The &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; protocol enables hostname checking by default. With other protocols, hostname checking must be enabled explicitly.</source>
          <target state="translated">是否对等证书的主机名相匹配&lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt;。上下文的&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt;必须设置为&lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;，并且必须将&lt;em&gt;server_hostname&lt;/em&gt;传递给&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt;才能与主机名匹配。启用主机名检查会自动将&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt;从&lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; 设置&lt;/a&gt;为&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;。只要启用了主机名检查，就不能将其设置回&lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; &lt;/a&gt;协议默认启用主机名检查。使用其他协议，必须显式启用主机名检查。</target>
        </trans-unit>
        <trans-unit id="0b724e20c7a82379a9a08525bdba888f74aefd96" translate="yes" xml:space="preserve">
          <source>Whether to try to verify other peers&amp;rsquo; certificates and how to behave if verification fails. This attribute must be one of &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">是否尝试验证其他对等方的证书以及验证失败时的行为。此属性必须是&lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; 之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25631d4668b3c0f9f32771f513f7cdbaf448ad8a" translate="yes" xml:space="preserve">
          <source>Whether writes are passed immediately to the underlying binary buffer.</source>
          <target state="translated">写入的内容是否立即传递到底层二进制缓冲区。</target>
        </trans-unit>
        <trans-unit id="71cfd83d887f9f86d88898814a6869aad231de3a" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;package&lt;/a&gt; a module belongs to. If the module is top-level (i.e. not a part of any specific package) then the attribute should be set to &lt;code&gt;''&lt;/code&gt;, else it should be set to the name of the package (which can be &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; if the module is a package itself). Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">模块属于哪个&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;包&lt;/a&gt;。如果模块是顶级模块（即不是任何特定软件包的一部分），则应将属性设置为 &lt;code&gt;''&lt;/code&gt; ，否则应将其设置为软件包的名称（如果模块本身是软件包，则可以为&lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt;）。默认为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bf7777d6a8548936df37db843584a88bd1bbbf8" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-package&quot;&gt;package&lt;/a&gt; a module belongs to. If the module is top-level (i.e. not a part of any specific package) then the attribute should be set to &lt;code&gt;''&lt;/code&gt;, else it should be set to the name of the package (which can be &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; if the module is a package itself). Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">模块属于哪个&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-package&quot;&gt;包&lt;/a&gt;。如果模块是顶级模块（即不是任何特定软件包的一部分），则应将属性设置为 &lt;code&gt;''&lt;/code&gt; ，否则应将其设置为软件包的名称（如果模块本身是软件包，则可以为&lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt;）。默认为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4040c278cd792b1142c2b0b1b82b0f58225cee15" translate="yes" xml:space="preserve">
          <source>Which Docstrings Are Examined?</source>
          <target state="translated">哪些文件串会被检查?</target>
        </trans-unit>
        <trans-unit id="422d9e85c4992821c007871473f5fa36c3b56c95" translate="yes" xml:space="preserve">
          <source>Which produces</source>
          <target state="translated">这就产生了</target>
        </trans-unit>
        <trans-unit id="a995c55c592cf94976c7d041d87c783ecf9451c8" translate="yes" xml:space="preserve">
          <source>Which solves the fundamental issue of processes colliding with each other resulting in a bad file descriptor error, but introduces a potential danger to applications which replace &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin()&lt;/code&gt;&lt;/a&gt; with a &amp;ldquo;file-like object&amp;rdquo; with output buffering. This danger is that if multiple processes call &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; on this file-like object, it could result in the same data being flushed to the object multiple times, resulting in corruption.</source>
          <target state="translated">它解决了进程相互冲突导致文件描述符错误的根本问题，但对使用&lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin()&lt;/code&gt; &lt;/a&gt;替换为带有输出缓冲的&amp;ldquo;类文件对象&amp;rdquo;的应用程序造成了潜在的危险。危险在于，如果多个进程对该文件状对象调用&lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;，则可能导致同一数据多次刷新到该对象，从而导致损坏。</target>
        </trans-unit>
        <trans-unit id="ddaaf09868cf6400cdcb648881000117dda08bc9" translate="yes" xml:space="preserve">
          <source>Whichever method you choose, you should provide a &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; that also hides the (unimportant) value:</source>
          <target state="translated">无论选择哪种方法，都应提供一个&lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt;，它也隐藏（不重要的）值：</target>
        </trans-unit>
        <trans-unit id="c646905a39f0ba1aaa09265f14adc54f064ca461" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; above. This restriction does not apply to mix-ins which only add methods and don&amp;rsquo;t specify another data type such as &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">尽管&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;可以具有任何类型的成员，但是一旦混合使用其他类型，则所有成员都必须具有该类型的值，例如上述&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;。此限制不适用于仅添加方法且未指定其他数据类型（例如&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; )的&lt;/a&gt;混入。</target>
        </trans-unit>
        <trans-unit id="6d9477fc38246177b0f8120236145f55c4f04194" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; above. This restriction does not apply to mix-ins which only add methods and don&amp;rsquo;t specify another type.</source>
          <target state="translated">尽管&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;可以具有任何类型的成员，但是一旦混合使用其他类型，则所有成员都必须具有该类型的值，例如，上面的&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;。此限制不适用于仅添加方法且未指定其他类型的混入。</target>
        </trans-unit>
        <trans-unit id="e556a67224525bf738669c6821725b3262368ed7" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one&amp;rsquo;s own.</source>
          <target state="translated">虽然&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt;，预计能满足大多数的使用情况，也不可能涵盖所有。这里是一些不同类型的枚举的配方，这些枚举可以直接使用，也可以作为创建自己的示例。</target>
        </trans-unit>
        <trans-unit id="fe708d810599cc0f179e22587c1998a55fa295c9" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; is part of the &lt;a href=&quot;#module-enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; module, it would be very simple to implement independently:</source>
          <target state="translated">尽管&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;#module-enum&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt;模块的一部分，但独立实现非常简单：</target>
        </trans-unit>
        <trans-unit id="1a6d1449ab3b35e2bc83dba53adce17079ecd21a" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#graphlib.TopologicalSorter.is_active&quot;&gt;&lt;code&gt;is_active()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, iterate over the nodes returned by &lt;a href=&quot;#graphlib.TopologicalSorter.get_ready&quot;&gt;&lt;code&gt;get_ready()&lt;/code&gt;&lt;/a&gt; and process them. Call &lt;a href=&quot;#graphlib.TopologicalSorter.done&quot;&gt;&lt;code&gt;done()&lt;/code&gt;&lt;/a&gt; on each node as it finishes processing.</source>
          <target state="translated">当&lt;a href=&quot;#graphlib.TopologicalSorter.is_active&quot;&gt; &lt;code&gt;is_active()&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;True&lt;/code&gt; 时，迭代&lt;a href=&quot;#graphlib.TopologicalSorter.get_ready&quot;&gt; &lt;code&gt;get_ready()&lt;/code&gt; &lt;/a&gt;返回的节点并对其进行处理。完成处理后，在每个节点上调用&lt;a href=&quot;#graphlib.TopologicalSorter.done&quot;&gt; &lt;code&gt;done()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02cb7cf515d5ba420c468f846b2ed31c98f290b6" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt; describes the exact syntax and semantics of the Python language, this library reference manual describes the standard library that is distributed with Python. It also describes some of the optional components that are commonly included in Python distributions.</source>
          <target state="translated">虽然&lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;《 Python语言参考》&lt;/a&gt;描述了Python语言的确切语法和语义，但该库参考手册描述了随Python分发的标准库。它还描述了Python发行版中通常包含的一些可选组件。</target>
        </trans-unit>
        <trans-unit id="297f2a972c76e5f7a1e934cb7cea1a69f71a15df" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://docs.python.org/3.9/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt; describes the exact syntax and semantics of the Python language, this library reference manual describes the standard library that is distributed with Python. It also describes some of the optional components that are commonly included in Python distributions.</source>
          <target state="translated">虽然&lt;a href=&quot;https://docs.python.org/3.9/reference/index.html#reference-index&quot;&gt;《 Python语言参考》&lt;/a&gt;描述了Python语言的确切语法和语义，但该库参考手册描述了随Python分发的标准库。它还描述了Python发行版中通常包含的一些可选组件。</target>
        </trans-unit>
        <trans-unit id="e0785829e0c8a5f6cee5eb7d590c1588c0e86596" translate="yes" xml:space="preserve">
          <source>While ConfigParser objects also use an &lt;code&gt;OPTCRE&lt;/code&gt; attribute for recognizing option lines, it&amp;rsquo;s not recommended to override it because that would interfere with constructor options &lt;em&gt;allow_no_value&lt;/em&gt; and &lt;em&gt;delimiters&lt;/em&gt;.</source>
          <target state="translated">尽管ConfigParser对象还使用 &lt;code&gt;OPTCRE&lt;/code&gt; 属性来识别选项行，但不建议覆盖它，因为这会干扰构造函数选项&lt;em&gt;allow_no_value&lt;/em&gt;和&lt;em&gt;delimiters&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0aea4fc9adcf74252cf54344d84df634df38ce92" translate="yes" xml:space="preserve">
          <source>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; (attempts to violate this restriction will trigger &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption).</source>
          <target state="translated">尽管字节文字和表示形式是基于ASCII文本的，但字节对象实际上的行为就像不可变的整数序列，序列中的每个值都受到限制，以使 &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; （试图违反此限制将触发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;）。故意这样做是为了强调，尽管许多二进制格式都包含基于ASCII的元素，并且可以通过某些面向文本的算法进行有用的操作，但对于任意二进制数据通常不是这种情况（盲目地将文本处理算法应用于不是二进制格式的二进制数据格式）。 ASCII兼容通常会导致数据损坏。</target>
        </trans-unit>
        <trans-unit id="afca682adab62f0880b590c7e59b89279df102ab" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">虽然调用&lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt;不会更改&lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt;的文件位置，但它可能会更改基础文件对象的位置（例如，如果&lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt;是通过传递文件&lt;em&gt;名来&lt;/em&gt;构造文件&lt;em&gt;名&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="38177ebefc8686714a66d6d82cf4ee10e3058268" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; was constructed with the &lt;em&gt;fileobj&lt;/em&gt; parameter).</source>
          <target state="translated">虽然调用&lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt;不会更改&lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt;的文件位置，但它可能会更改基础文件对象的位置（例如，如果&lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt;是使用&lt;em&gt;fileobj&lt;/em&gt;参数构造的）。</target>
        </trans-unit>
        <trans-unit id="e6545af489ed1f20fcc9c3b27afc7248e80f9df3" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">虽然调用&lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt;不会更改&lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt;的文件位置，但是它可能会更改基础文件对象的位置（例如，如果&lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt;是通过传递文件对象的&lt;em&gt;filename&lt;/em&gt;构造的）。</target>
        </trans-unit>
        <trans-unit id="c0bb1fc2909ab24f32996f8a6e44f36be2000ff2" translate="yes" xml:space="preserve">
          <source>While curses is most widely used in the Unix environment, versions are available for Windows, DOS, and possibly other systems as well. This extension module is designed to match the API of ncurses, an open-source curses library hosted on Linux and the BSD variants of Unix.</source>
          <target state="translated">虽然curses在Unix环境下使用最为广泛,但Windows、DOS以及其他系统也有相应的版本。这个扩展模块是为了匹配ncurses的API而设计的,ncurses是一个开源的curses库,托管在Linux和Unix的BSD变体上。</target>
        </trans-unit>
        <trans-unit id="786cdfb379403ea4cce195f3dca6c17b6ee0052a" translate="yes" xml:space="preserve">
          <source>While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation.</source>
          <target state="translated">虽然支持日期和时间运算,但实现的重点是高效的属性提取,以便进行输出格式化和操作。</target>
        </trans-unit>
        <trans-unit id="67281bc9ed61750f29460e86ce99cc6681899c14" translate="yes" xml:space="preserve">
          <source>While many objects natively support use in with statements, sometimes a resource needs to be managed that isn&amp;rsquo;t a context manager in its own right, and doesn&amp;rsquo;t implement a &lt;code&gt;close()&lt;/code&gt; method for use with &lt;code&gt;contextlib.closing&lt;/code&gt;</source>
          <target state="translated">尽管许多对象本机支持在with语句中使用，但有时需要管理的资源本身不是上下文管理器，并且不实现与 &lt;code&gt;contextlib.closing&lt;/code&gt; 一起使用的 &lt;code&gt;close()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="93bfa21ab3a98f4858cf4bc1efde7812c899e149" translate="yes" xml:space="preserve">
          <source>While many useful operations may take place between parsing and bytecode generation, the simplest operation is to do nothing. For this purpose, using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module to produce an intermediate data structure is equivalent to the code</source>
          <target state="translated">尽管在解析和字节码生成之间可能会发生许多有用的操作，但最简单的操作是什么也不做。为此，使用&lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt;模块生成中间数据结构等效于代码</target>
        </trans-unit>
        <trans-unit id="b514cb7bc8722d4e70eacb8c91412ef7465d4c76" translate="yes" xml:space="preserve">
          <source>While other exceptions may still occur, this method is called &amp;ldquo;safe&amp;rdquo; because it always tries to return a usable string instead of raising an exception. In another sense, &lt;a href=&quot;#string.Template.safe_substitute&quot;&gt;&lt;code&gt;safe_substitute()&lt;/code&gt;&lt;/a&gt; may be anything other than safe, since it will silently ignore malformed templates containing dangling delimiters, unmatched braces, or placeholders that are not valid Python identifiers.</source>
          <target state="translated">尽管仍然可能发生其他异常，但是此方法被称为&amp;ldquo;安全&amp;rdquo;，因为它总是尝试返回可用的字符串而不是引发异常。换句话说，&lt;a href=&quot;#string.Template.safe_substitute&quot;&gt; &lt;code&gt;safe_substitute()&lt;/code&gt; &lt;/a&gt;可能不是安全的，因为它会静默忽略格式错误的模板，这些模板包含悬挂的定界符，不匹配的花括号或无效的Python标识符的占位符。</target>
        </trans-unit>
        <trans-unit id="a915d6b0d37f05b5affd54282cd5bb33c1eff648" translate="yes" xml:space="preserve">
          <source>While parsing the command line, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc. When it encounters such an error, it exits and prints the error along with a usage message:</source>
          <target state="translated">解析命令行时，&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt;检查各种错误，包括歧义选项，无效类型，无效选项，错误的位置参数数量等。遇到此类错误时，它将退出并打印错误以及使用信息：</target>
        </trans-unit>
        <trans-unit id="af0a5de79e2df6a8d199d3d065c11df24c028f5b" translate="yes" xml:space="preserve">
          <source>While symlinks are supported on Windows, they are not recommended. Of particular note is that double-clicking &lt;code&gt;python.exe&lt;/code&gt; in File Explorer will resolve the symlink eagerly and ignore the virtual environment.</source>
          <target state="translated">虽然Windows上支持符号链接，但不建议使用它们。特别需要注意的是，在文件资源管理器中双击 &lt;code&gt;python.exe&lt;/code&gt; 将迅速解析符号链接，并忽略虚拟环境。</target>
        </trans-unit>
        <trans-unit id="f0e04edc4d322f07593d9595090717727de98239" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;not in&lt;/code&gt; operations are used only for simple containment testing in the general case, some specialised sequences (such as &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) also use them for subsequence testing:</source>
          <target state="translated">而 &lt;code&gt;in&lt;/code&gt; 与 &lt;code&gt;not in&lt;/code&gt; 操作仅用于在通常情况下简单容纳测试，一些专门序列（如&lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;）也将它们用于序列检测：</target>
        </trans-unit>
        <trans-unit id="5d31855d6be2ba764837d00ac8c9c8aa85b873bb" translate="yes" xml:space="preserve">
          <source>While the above API is the most common and convenient usage, you can get all of that information from the &lt;code&gt;Distribution&lt;/code&gt; class. A &lt;code&gt;Distribution&lt;/code&gt; is an abstract object that represents the metadata for a Python package. You can get the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">虽然上述API是最常见，最方便的用法，但您可以从 &lt;code&gt;Distribution&lt;/code&gt; 类获取所有这些信息。甲 &lt;code&gt;Distribution&lt;/code&gt; 是一个抽象的对象，它表示为一个Python包的元数据。您可以获取 &lt;code&gt;Distribution&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="d6319151ce24cde9d9afeaf68fdcdbec22e36ba3" translate="yes" xml:space="preserve">
          <source>While the builtin &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; and the associated &lt;a href=&quot;io#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module are the recommended approach for working with encoded text files, this module provides additional utility functions and classes that allow the use of a wider range of codecs when working with binary files:</source>
          <target state="translated">虽然建议使用内置的&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;和关联的&lt;a href=&quot;io#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt;模块来处理编码的文本文件，但是此模块提供了附加的实用程序功能和类，这些功能和类在处理二进制文件时允许使用更多的编解码器：</target>
        </trans-unit>
        <trans-unit id="42821c116527a74cd5c9f35556c03beeb2cf5d8f" translate="yes" xml:space="preserve">
          <source>While the method has a default implementation, it is suggested that it be overridden if possible for performance.</source>
          <target state="translated">虽然该方法有一个默认的实现,但为了性能,建议尽可能地覆盖它。</target>
        </trans-unit>
        <trans-unit id="14032b7a66889d07d3394faf5c484ef0cdf94cea" translate="yes" xml:space="preserve">
          <source>While these are technically &lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;built-in exceptions&lt;/a&gt;, they are documented here, because conceptually they belong to the warnings mechanism.</source>
          <target state="translated">尽管这些是技术上&lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;内置的异常&lt;/a&gt;，但在此处进行了记录，因为从概念上讲，它们属于警告机制。</target>
        </trans-unit>
        <trans-unit id="dcfc856d002acccc1fa089a7e19be1782a8e1118" translate="yes" xml:space="preserve">
          <source>While they are not listed below, the &lt;code&gt;camelCase&lt;/code&gt; names used for some methods and functions in this module in the Python 2.x series are still supported by this module.</source>
          <target state="translated">尽管未在下面列出，但该模块仍支持用于Python 2.x系列中此模块中某些方法和功能的 &lt;code&gt;camelCase&lt;/code&gt; 名称。</target>
        </trans-unit>
        <trans-unit id="0f4b7324352db1ad0e38dfcfad84d64814555c92" translate="yes" xml:space="preserve">
          <source>While this decorator makes it easy to create well behaved totally ordered types, it &lt;em&gt;does&lt;/em&gt; come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost.</source>
          <target state="translated">虽然这个装饰可以很容易地创建很乖全序类型，它&lt;em&gt;确实&lt;/em&gt;来得比较慢的执行和更复杂的堆栈跟踪派生比较方法的成本。如果性能基准测试表明这是给定应用程序的瓶颈，则实施所有六种丰富的比较方法可能会轻松提高速度。</target>
        </trans-unit>
        <trans-unit id="8863d901011fb351d3633ca34f340a2828c5fea0" translate="yes" xml:space="preserve">
          <source>While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;s would be used with particular &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">尽管这可能很烦人，但是此功能旨在用于特殊情况下，例如在多个上下文中执行相同代码的多线程服务器，并且有趣的条件取决于此上下文（例如，远程客户端IP地址和已验证用户名，在上面的示例中）。在这种情况下，很可能将特殊的&lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;与特定的&lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="840def8eae0283a6cbfe40db44014f3c77b1c43b" translate="yes" xml:space="preserve">
          <source>While using a hierarchy of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;-derived classes can be convenient in sharing fixtures and helper functions, defining test methods on base classes that are not intended to be instantiated directly does not play well with this method. Doing so, however, can be useful when the fixtures are different and defined in subclasses.</source>
          <target state="translated">尽管使用&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;派生的类的层次结构可以方便地共享固定装置和辅助函数，但是在不打算直接实例化的基类上定义测试方法在此方法中不能很好地发挥作用。但是，当固定装置不同且在子类中定义时，这样做可能会很有用。</target>
        </trans-unit>
        <trans-unit id="988a0cff7503163f428287a56046c0bb09b3b7fd" translate="yes" xml:space="preserve">
          <source>While within the context manager all warnings will simply be ignored. This allows you to use known-deprecated code without having to see the warning while not suppressing the warning for other code that might not be aware of its use of deprecated code. Note: this can only be guaranteed in a single-threaded application. If two or more threads use the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager at the same time, the behavior is undefined.</source>
          <target state="translated">在上下文管理器中，所有警告都将被忽略。这使您可以使用已知已弃用的代码，而不必查看警告，而不必为可能不知道其已弃用代码的其他代码取消警告。注意：只能在单线程应用程序中保证这一点。如果两个或多个线程同时使用&lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; &lt;/a&gt;上下文管理器，则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="62d692a71777fd55efffbdb0ca5893dd735770aa" translate="yes" xml:space="preserve">
          <source>Whitebox testing (examining the code being tested when the tests are being written) is preferred. Blackbox testing (testing only the published user interface) is not complete enough to make sure all boundary and edge cases are tested.</source>
          <target state="translated">白盒测试(在编写测试时检查被测试的代码)是首选。黑盒测试(只测试发布的用户界面)不够完整,无法确保所有边界和边缘情况都得到测试。</target>
        </trans-unit>
        <trans-unit id="931f4c5c75b75b488b411586b1c52d7e9f8da29c" translate="yes" xml:space="preserve">
          <source>Whiteout.</source>
          <target state="translated">Whiteout.</target>
        </trans-unit>
        <trans-unit id="b78a557954071d939474b0820ce2d887c5949beb" translate="yes" xml:space="preserve">
          <source>Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.</source>
          <target state="translated">格式之间的空白字符会被忽略;但计数和它的格式必须不包含空白字符。</target>
        </trans-unit>
        <trans-unit id="6b7e00ea7c678d4c6c68704506146cc03ff76587" translate="yes" xml:space="preserve">
          <source>Whitespace is not allowed between the &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and the directive option name. The directive option name can be any of the option flag names explained above.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 与指令选项名称之间不允许有空格。指令选项名称可以是上面说明的任何选项标志名称。</target>
        </trans-unit>
        <trans-unit id="d8fe1444c5cef2f1bf2942426dad26edc71785bf" translate="yes" xml:space="preserve">
          <source>Why is it printing &lt;code&gt;False&lt;/code&gt;? ctypes instances are objects containing a memory block plus some &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the &lt;code&gt;contents&lt;/code&gt; of the object is stored. Accessing the contents again constructs a new Python object each time!</source>
          <target state="translated">为什么打印 &lt;code&gt;False&lt;/code&gt; ？ctypes实例是包含一个内存块以及一些访问内存内容的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;描述符&lt;/a&gt;的对象。在内存块中存储Python对象并不存储对象本身，而是存储对象的 &lt;code&gt;contents&lt;/code&gt; 。再次访问内容每次都会构造一个新的Python对象！</target>
        </trans-unit>
        <trans-unit id="abe93e8d7ae385c7fa16cc4105c3de888fe59d53" translate="yes" xml:space="preserve">
          <source>Why is it printing &lt;code&gt;False&lt;/code&gt;? ctypes instances are objects containing a memory block plus some &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the &lt;code&gt;contents&lt;/code&gt; of the object is stored. Accessing the contents again constructs a new Python object each time!</source>
          <target state="translated">为什么打印 &lt;code&gt;False&lt;/code&gt; ？ctypes实例是包含一个内存块以及一些访问内存内容的&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;描述符&lt;/a&gt;的对象。将Python对象存储在内存块中并不存储对象本身，而是存储对象的 &lt;code&gt;contents&lt;/code&gt; 。再次访问内容每次都会构造一个新的Python对象！</target>
        </trans-unit>
        <trans-unit id="fb8f747f33b6f74dbe7fd5ac838801c9d72b22ac" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; 的&lt;/a&gt;宽字符变体，返回Unicode值。</target>
        </trans-unit>
        <trans-unit id="c5be99ca3a70e3977f2f65814d98de5c5b56d2d2" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getche&quot;&gt;&lt;code&gt;getche()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getche&quot;&gt; &lt;code&gt;getche()&lt;/code&gt; 的&lt;/a&gt;宽字符变体，返回Unicode值。</target>
        </trans-unit>
        <trans-unit id="255f38720857b44ab5ff2e2d98e37a3c89e37d00" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.putch&quot;&gt;&lt;code&gt;putch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.putch&quot;&gt; &lt;code&gt;putch()&lt;/code&gt; 的&lt;/a&gt;宽字符变体，接受Unicode值。</target>
        </trans-unit>
        <trans-unit id="6f0779174f97c45da57524e6b209ae90dff53c3d" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.ungetch&quot;&gt;&lt;code&gt;ungetch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.ungetch&quot;&gt; &lt;code&gt;ungetch()&lt;/code&gt; 的&lt;/a&gt;宽字符变体，接受Unicode值。</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="bfee860a8a5dc6ac74dd99d215ad1d51cce5c8c7" translate="yes" xml:space="preserve">
          <source>Widget States</source>
          <target state="translated">小工具状态</target>
        </trans-unit>
        <trans-unit id="79beed1fb49764e8862ef327797df09e07c316a6" translate="yes" xml:space="preserve">
          <source>Widget has keyboard focus</source>
          <target state="translated">小工具具有键盘焦点</target>
        </trans-unit>
        <trans-unit id="2233730413ec55a5b571e7d775be44e6e3e013b3" translate="yes" xml:space="preserve">
          <source>Widget is being pressed</source>
          <target state="translated">小工具被按下</target>
        </trans-unit>
        <trans-unit id="da46e3b7f16d7ede37378d1c431a4c43fb3ef6fc" translate="yes" xml:space="preserve">
          <source>Widget is disabled under program control</source>
          <target state="translated">小工具在程序控制下被禁用</target>
        </trans-unit>
        <trans-unit id="211f67af4e336b2c25b87952f14880aca797600a" translate="yes" xml:space="preserve">
          <source>Widget should not allow user modification</source>
          <target state="translated">小工具不应允许用户修改</target>
        </trans-unit>
        <trans-unit id="802f4ec2a7a115583d6e55e6d32a4beead4d14b2" translate="yes" xml:space="preserve">
          <source>Width of the terminal window in characters.</source>
          <target state="translated">终端窗口的宽度,以字符为单位。</target>
        </trans-unit>
        <trans-unit id="080323da0bfe1ab0191a174c2237858164d7cdaf" translate="yes" xml:space="preserve">
          <source>Wikipedia article with information on which algorithms have known issues and what that means regarding their use.</source>
          <target state="translated">维基百科上有一篇文章,介绍了哪些算法存在已知的问题,以及这些问题对其使用的意义。</target>
        </trans-unit>
        <trans-unit id="c1b3cf193c6d821b49984f993d3ea75cf5a5a2be" translate="yes" xml:space="preserve">
          <source>Wikipedia entry for &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;Multisets&lt;/a&gt;.</source>
          <target state="translated">有关多&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;集的&lt;/a&gt; Wikipedia条目。</target>
        </trans-unit>
        <trans-unit id="113f18f5469ce5347437610dd55d140a53fa09c6" translate="yes" xml:space="preserve">
          <source>Wikipedia has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;nice example of a Naive Bayesian Classifier&lt;/a&gt;. The challenge is to predict a person&amp;rsquo;s gender from measurements of normally distributed features including height, weight, and foot size.</source>
          <target state="translated">维基百科有一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;朴素的贝叶斯分类器&lt;/a&gt;的很好的例子。面临的挑战是根据对身高，体重和足部大小等正态分布特征的测量来预测一个人的性别。</target>
        </trans-unit>
        <trans-unit id="f6fe06680d0563e4e9deb6c1d86aa445e8e5c908" translate="yes" xml:space="preserve">
          <source>Will add, among other things, a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; that looks like:</source>
          <target state="translated">除其他外，将添加一个类似于以下内容的&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d058ba61c1be1593a1050216418b28999b88eb0a" translate="yes" xml:space="preserve">
          <source>Will add, among other things, a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; that looks like:</source>
          <target state="translated">除其他外，将添加一个类似于以下内容的&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d239e74c0170d39d6786ccf1a848d04c2c537ed2" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the indicated number of characters have been received</source>
          <target state="translated">收到指定数量的字符&lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt;调用found_terminator（）</target>
        </trans-unit>
        <trans-unit id="4426413765c214020905681f96c46df4a803dd94" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the string is found in the input stream</source>
          <target state="translated">在输入流中找到字符串时将调用&lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47374c257b33abb533116a9cb9651554e18faed7" translate="yes" xml:space="preserve">
          <source>Will generally raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; if executed on a 32-bit operating system.</source>
          <target state="translated">如果在32位操作系统上执行，通常会引发&lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b90c5925294b920cc6ddfbe599b541b3edf485fe" translate="yes" xml:space="preserve">
          <source>Will try to match with &lt;code&gt;yes-pattern&lt;/code&gt; if the group with given &lt;em&gt;id&lt;/em&gt; or &lt;em&gt;name&lt;/em&gt; exists, and with &lt;code&gt;no-pattern&lt;/code&gt; if it doesn&amp;rsquo;t. &lt;code&gt;no-pattern&lt;/code&gt; is optional and can be omitted. For example, &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; is a poor email matching pattern, which will match with &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; as well as &lt;code&gt;'user@host.com'&lt;/code&gt;, but not with &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; nor &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">如果存在具有给定&lt;em&gt;ID&lt;/em&gt;或&lt;em&gt;名称&lt;/em&gt;的组，则尝试与 &lt;code&gt;yes-pattern&lt;/code&gt; 匹配；如果 &lt;code&gt;no-pattern&lt;/code&gt; 存在，则尝试与no-pattern匹配。 &lt;code&gt;no-pattern&lt;/code&gt; 是可选的，可以省略。例如， &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; 是较差的电子邮件匹配模式，它将与 &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; 和 &lt;code&gt;'user@host.com'&lt;/code&gt; ，但不包含 &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; 或 &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81dab24e3d9f50cff7ee608ff0514afa0cfa05b9" translate="yes" xml:space="preserve">
          <source>Window Objects</source>
          <target state="translated">窗口对象</target>
        </trans-unit>
        <trans-unit id="ce658069fb4ffc6d3ca8e791633d8df32975802b" translate="yes" xml:space="preserve">
          <source>Window control</source>
          <target state="translated">窗口控制</target>
        </trans-unit>
        <trans-unit id="660e57fa2bc58f9dadba0b1f9648498cca7a58e4" translate="yes" xml:space="preserve">
          <source>Window menu (Shell and Editor)</source>
          <target state="translated">窗口菜单(外壳和编辑器</target>
        </trans-unit>
        <trans-unit id="b7e449a2f3ba9b16acfab22bc1c12f4e17b45718" translate="yes" xml:space="preserve">
          <source>Window objects, as returned by &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#curses.newwin&quot;&gt;&lt;code&gt;newwin()&lt;/code&gt;&lt;/a&gt; above, have the following methods and attributes:</source>
          <target state="translated">上面的&lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#curses.newwin&quot;&gt; &lt;code&gt;newwin()&lt;/code&gt; &lt;/a&gt;返回的Window对象具有以下方法和属性：</target>
        </trans-unit>
        <trans-unit id="64271b944dda3c434c1d350e41c4b9a56d00bf95" translate="yes" xml:space="preserve">
          <source>Window resize signal.</source>
          <target state="translated">窗口大小调整信号。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="e23575cabbcb9b7c4f9b7f51a07387fed98002f0" translate="yes" xml:space="preserve">
          <source>Windows Constants</source>
          <target state="translated">窗口常量</target>
        </trans-unit>
        <trans-unit id="733b53500cac45b1ccabfeea23e2dd3682ceafd7" translate="yes" xml:space="preserve">
          <source>Windows Platform</source>
          <target state="translated">Windows平台</target>
        </trans-unit>
        <trans-unit id="707d9815b3e7e66dfa8de1e9a953cf814bb32ace" translate="yes" xml:space="preserve">
          <source>Windows Popen Helpers</source>
          <target state="translated">Windows Popen帮助程序</target>
        </trans-unit>
        <trans-unit id="059cace6c4e4f2ba24a96dd77457fa820cea57be" translate="yes" xml:space="preserve">
          <source>Windows and Mac have a notion of an &amp;ldquo;active&amp;rdquo; or foreground window. The &lt;em&gt;background&lt;/em&gt; state is set for widgets in a background window, and cleared for those in the foreground window</source>
          <target state="translated">Windows和Mac具有&amp;ldquo;活动&amp;rdquo;或前景窗口的概念。在&lt;em&gt;后台&lt;/em&gt;窗口中为窗口小部件设置&lt;em&gt;背景&lt;/em&gt;状态，并在前景窗口中为那些窗口小部件清除&lt;em&gt;背景&lt;/em&gt;状态</target>
        </trans-unit>
        <trans-unit id="58f8b33dac190c990211b26ccc6956c320800b74" translate="yes" xml:space="preserve">
          <source>Windows appends the usual &lt;code&gt;.dll&lt;/code&gt; file suffix automatically.</source>
          <target state="translated">Windows 自动添加通常的 &lt;code&gt;.dll&lt;/code&gt; 文件后缀。</target>
        </trans-unit>
        <trans-unit id="c3fc7bf4a41cf349e493878f4d10064c2cb45383" translate="yes" xml:space="preserve">
          <source>Windows file attributes: &lt;code&gt;dwFileAttributes&lt;/code&gt; member of the &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; structure returned by &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt;. See the &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows文件属性： &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt; 返回的 &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; 结构的 &lt;code&gt;dwFileAttributes&lt;/code&gt; 成员。请参阅&lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="f3fbab09a7f617cae95132c649f8e0c1742cca65" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.OleDLL&quot;&gt;&lt;code&gt;OleDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">仅Windows：创建&lt;a href=&quot;#ctypes.OleDLL&quot;&gt; &lt;code&gt;OleDLL&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="612e01f22f9c1d88221548d271f8b961715eb8ed" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.WinDLL&quot;&gt;&lt;code&gt;WinDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">仅Windows：创建&lt;a href=&quot;#ctypes.WinDLL&quot;&gt; &lt;code&gt;WinDLL&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e2c52f5bde98e844c1500dc7688f5098974c8782" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the ANSI codepage (CP_ACP).</source>
          <target state="translated">仅限Windows。根据ANSI代码页(CP_ACP)对操作数进行编码。</target>
        </trans-unit>
        <trans-unit id="266fb264e8732c43ca999faee5d793005f28e1c9" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the OEM codepage (CP_OEMCP).</source>
          <target state="translated">仅限Windows。根据OEM代码页(CP_OEMCP)对操作数进行编码。</target>
        </trans-unit>
        <trans-unit id="edb6ed45a1b723b7af51540eab62bf7ae64e1059" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return &lt;code&gt;int&lt;/code&gt; by default.</source>
          <target state="translated">仅限Windows：此类的实例表示已加载的共享库，这些库中的函数使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定，并且假定默认情况下返回 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8baa6ebf95b244d430b0bac19d2d4be067fc743" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return the windows specific &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; code. &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is automatically raised.</source>
          <target state="translated">仅限Windows：此类的实例表示已加载的共享库，这些库中的函数使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定，并假定它们返回Windows特定的&lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt;代码。&lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt;值包含指定函数调用是成功还是失败的信息，以及其他错误代码。如果返回值表示失败，则会自动引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4996849541b713bd583a818c47de0918c05b035c" translate="yes" xml:space="preserve">
          <source>Windows only: Represents a &lt;code&gt;HRESULT&lt;/code&gt; value, which contains success or error information for a function or method call.</source>
          <target state="translated">仅限Windows：表示 &lt;code&gt;HRESULT&lt;/code&gt; 值，其中包含函数或方法调用的成功或错误信息。</target>
        </trans-unit>
        <trans-unit id="bdabf613004cb36f7b1c0e46576c928355e113b5" translate="yes" xml:space="preserve">
          <source>Windows only: Returns a textual description of the error code &lt;em&gt;code&lt;/em&gt;. If no error code is specified, the last error code is used by calling the Windows api function GetLastError.</source>
          <target state="translated">仅限Windows：返回错误代码&lt;em&gt;code&lt;/em&gt;的文本描述。如果未指定错误代码，则通过调用Windows api函数GetLastError使用最后一个错误代码。</target>
        </trans-unit>
        <trans-unit id="fbcbf3ad5bd151aa5b3e3fde3eb8d692caac57ec" translate="yes" xml:space="preserve">
          <source>Windows only: Returns the last error code set by Windows in the calling thread. This function calls the Windows &lt;code&gt;GetLastError()&lt;/code&gt; function directly, it does not return the ctypes-private copy of the error code.</source>
          <target state="translated">仅Windows：返回Windows在调用线程中设置的最后一个错误代码。此函数直接调用Windows &lt;code&gt;GetLastError()&lt;/code&gt; 函数，它不返回错误代码的ctypes-private副本。</target>
        </trans-unit>
        <trans-unit id="2511b1a5b947b91013c7afa28eb6b0b78fe0e385" translate="yes" xml:space="preserve">
          <source>Windows only: The returned function prototype creates functions that use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, except on Windows CE where &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt;&lt;code&gt;WINFUNCTYPE()&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt;&lt;code&gt;CFUNCTYPE()&lt;/code&gt;&lt;/a&gt;. The function will release the GIL during the call. &lt;em&gt;use_errno&lt;/em&gt; and &lt;em&gt;use_last_error&lt;/em&gt; have the same meaning as above.</source>
          <target state="translated">仅限Windows：返回的函数原型创建使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定的函数，但Windows CE上的&lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt; &lt;code&gt;WINFUNCTYPE()&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt; &lt;code&gt;CFUNCTYPE()&lt;/code&gt; &lt;/a&gt;相同。该函数将在调用过程中释放GIL。&lt;em&gt;use_errno&lt;/em&gt;和&lt;em&gt;use_last_error&lt;/em&gt;具有与上述相同的含义。</target>
        </trans-unit>
        <trans-unit id="08605ae2b964896441a344b5311963123c2e7022" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports.</source>
          <target state="translated">仅限Windows。这个函数是一个钩子,允许用ctypes实现进程内COM服务器。它从_ctypes扩展dll导出的DllCanUnloadNow函数中调用。</target>
        </trans-unit>
        <trans-unit id="29751233ae7d28491bf89fa51c323518e5fedbd3" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllGetClassObject function that the &lt;code&gt;_ctypes&lt;/code&gt; extension dll exports.</source>
          <target state="translated">仅限Windows：此函数是一个挂钩，允许使用ctypes实现进程内COM服务器。 &lt;code&gt;_ctypes&lt;/code&gt; 扩展dll导出的DllGetClassObject函数调用它。</target>
        </trans-unit>
        <trans-unit id="4880e94875e68f82bb6fce3490b9c97c9c5d775d" translate="yes" xml:space="preserve">
          <source>Windows only: return the filename of the VC runtime library used by Python, and by the extension modules. If the name of the library cannot be determined, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">仅限Windows：返回Python和扩展模块使用的VC运行时库的文件名。如果无法确定库的名称，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3e388ef290e4bd8ff8d89808b87dad3695d974a" translate="yes" xml:space="preserve">
          <source>Windows only: returns the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread.</source>
          <target state="translated">仅限Windows：返回调用线程中系统 &lt;code&gt;LastError&lt;/code&gt; 变量的ctypes-private副本的当前值。</target>
        </trans-unit>
        <trans-unit id="bb8310fccfe554408a2574b1c48ddf84fd935b53" translate="yes" xml:space="preserve">
          <source>Windows only: set the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread to &lt;em&gt;value&lt;/em&gt; and return the previous value.</source>
          <target state="translated">仅限Windows：将调用线程中系统 &lt;code&gt;LastError&lt;/code&gt; 变量的ctypes-private副本的当前值设置为&lt;em&gt;value，&lt;/em&gt;并返回先前的值。</target>
        </trans-unit>
        <trans-unit id="8358fc5d14e0fbf09bf3e54d163a390795bbe4f7" translate="yes" xml:space="preserve">
          <source>Windows only: this function is probably the worst-named thing in ctypes. It creates an instance of OSError. If &lt;em&gt;code&lt;/em&gt; is not specified, &lt;code&gt;GetLastError&lt;/code&gt; is called to determine the error code. If &lt;em&gt;descr&lt;/em&gt; is not specified, &lt;a href=&quot;#ctypes.FormatError&quot;&gt;&lt;code&gt;FormatError()&lt;/code&gt;&lt;/a&gt; is called to get a textual description of the error.</source>
          <target state="translated">仅限Windows：此函数可能是ctypes中命名最差的东西。它创建OSError的实例。如果未指定&lt;em&gt;代码&lt;/em&gt;，则调用 &lt;code&gt;GetLastError&lt;/code&gt; 以确定错误代码。如果未指定&lt;em&gt;descr&lt;/em&gt;，则调用&lt;a href=&quot;#ctypes.FormatError&quot;&gt; &lt;code&gt;FormatError()&lt;/code&gt; &lt;/a&gt;以获取错误的文本描述。</target>
        </trans-unit>
        <trans-unit id="db996879e3dc4634bda2abfa9ed3e517199ceb69" translate="yes" xml:space="preserve">
          <source>Windows will return one of:</source>
          <target state="translated">Windows将返回其中一个。</target>
        </trans-unit>
        <trans-unit id="9cd7eea9943b6fe344a02e8fbc71ef279241c91a" translate="yes" xml:space="preserve">
          <source>Windows/Cygwin</source>
          <target state="translated">Windows/Cygwin</target>
        </trans-unit>
        <trans-unit id="a807de5503cda53ca6fea19efe8608ddcb20996b" translate="yes" xml:space="preserve">
          <source>Windows: The &lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt;&lt;/a&gt; signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for &lt;em&gt;sig&lt;/em&gt; will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to &lt;em&gt;sig&lt;/em&gt;. The Windows version of &lt;a href=&quot;#os.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt; additionally takes process handles to be killed.</source>
          <target state="translated">Windows：&lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt; &lt;/a&gt;信号是特殊信号，只能发送到共享公共控制台窗口的控制台进程，例如某些子进程。&lt;em&gt;sig的&lt;/em&gt;任何其他值将导致该进程被TerminateProcess API无条件终止，并且退出代码将设置为&lt;em&gt;sig&lt;/em&gt;。Windows版本的&lt;a href=&quot;#os.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt;另外需要杀死进程句柄。</target>
        </trans-unit>
        <trans-unit id="adf309288e97790d19b86dd6d3f7067de5f4100b" translate="yes" xml:space="preserve">
          <source>WindowsError</source>
          <target state="translated">WindowsError</target>
        </trans-unit>
        <trans-unit id="a20440ab3aefcfb4bb482ffec0fe5d04e27395bf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; event loop, the &lt;em&gt;pipe&lt;/em&gt; is set to non-blocking mode.</source>
          <target state="translated">通过&lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt;事件循环，&lt;em&gt;管道&lt;/em&gt;被设置为非阻塞模式。</target>
        </trans-unit>
        <trans-unit id="c2504489b4771be876382108e6f7ae9120afc09b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;, each caller is preceded by three numbers: the number of times this specific call was made, and the total and cumulative times spent in the current function while it was invoked by this specific caller.</source>
          <target state="translated">使用&lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 时&lt;/a&gt;，每个调用方前面都有三个数字：进行此特定调用的次数，以及在此特定调用方调用当前函数时在当前函数中花费的总时间和累积时间。</target>
        </trans-unit>
        <trans-unit id="d44b294510f145891db9e384bc38c4e88df7f7c7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt;, a number is shown in parentheses after each caller to show how many times this specific call was made. For convenience, a second non-parenthesized number repeats the cumulative time spent in the function at the right.</source>
          <target state="translated">使用&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; 时&lt;/a&gt;，在每个呼叫者之后的括号中显示一个数字，以显示进行此特定呼叫的次数。为方便起见，第二个非括号内的数字重复了右侧功能所花费的累积时间。</target>
        </trans-unit>
        <trans-unit id="cab1487529e22885346d5098b46bd492a9089ff9" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt;&lt;code&gt;PureWindowsPath&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;True&lt;/code&gt; if the path is considered reserved under Windows, &lt;code&gt;False&lt;/code&gt; otherwise. With &lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt;&lt;code&gt;PurePosixPath&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;False&lt;/code&gt; is always returned.</source>
          <target state="translated">使用&lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt; &lt;code&gt;PureWindowsPath&lt;/code&gt; &lt;/a&gt;，如果该路径在Windows下被视为保留，则返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。使用&lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt; &lt;code&gt;PurePosixPath&lt;/code&gt; 时&lt;/a&gt;，始终返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e771f57ddca6161f395e0eeba63e82d899e7d5f" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; it matters that you patch objects in the namespace where they are looked up. This is normally straightforward, but for a quick guide read &lt;a href=&quot;#where-to-patch&quot;&gt;where to patch&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt;可以在查找对象的名称空间中修补对象。这通常很简单，但是要获得快速指南，请阅读&lt;a href=&quot;#where-to-patch&quot;&gt;在何处打补丁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="687dc08f377a2b328a8f70bc97535a43cc502f58" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;interpolation&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;, the parser would simply return &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; as the value of &lt;code&gt;my_pictures&lt;/code&gt; and &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; as the value of &lt;code&gt;my_dir&lt;/code&gt;.</source>
          <target state="translated">随着 &lt;code&gt;interpolation&lt;/code&gt; 设置为 &lt;code&gt;None&lt;/code&gt; ，解析器仅返回 &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; 作为价值 &lt;code&gt;my_pictures&lt;/code&gt; 和 &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; 作为价值 &lt;code&gt;my_dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15bc87ebe549a152d95621af5e9d7461b775788e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;mode='w'&lt;/code&gt;, a writable file handle is returned, which supports the &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;mode='w'&lt;/code&gt; ，将返回一个可写文件句柄，该句柄支持&lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;方法。打开可写文件句柄时，尝试在ZIP文件中读取或写入其他文件将引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd7953113e258fb4a03370e957ae379b0c21dcb8" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt; you can specify which file mode will be passed to &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. It must be one of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rU'&lt;/code&gt;, &lt;code&gt;'U'&lt;/code&gt; and &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">使用&lt;em&gt;mode，&lt;/em&gt;您可以指定将哪种文件模式传递给&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;。它必须是 &lt;code&gt;'r'&lt;/code&gt; ， &lt;code&gt;'rU'&lt;/code&gt; ， &lt;code&gt;'U'&lt;/code&gt; 和 &lt;code&gt;'rb'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="2da8c5473cf49716c34f3c81822b2920eb1d2993" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; the file-like object (&lt;code&gt;ZipExtFile&lt;/code&gt;) is read-only and provides the following methods: &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.seek&quot;&gt;&lt;code&gt;seek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.tell&quot;&gt;&lt;code&gt;tell()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt;. These objects can operate independently of the ZipFile.</source>
          <target state="translated">在&lt;em&gt;模式&lt;/em&gt; &lt;code&gt;'r'&lt;/code&gt; ，类似文件的对象（ &lt;code&gt;ZipExtFile&lt;/code&gt; ）是只读的，并提供以下方法：&lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.seek&quot;&gt; &lt;code&gt;seek()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.tell&quot;&gt; &lt;code&gt;tell()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt;next __（）。这些对象可以独立于ZipFile运行。</target>
        </trans-unit>
        <trans-unit id="379f83dca17684083b0f735691e8be9c7a53a82e" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; the file-like object (&lt;code&gt;ZipExtFile&lt;/code&gt;) is read-only and provides the following methods: &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.seek&quot;&gt;&lt;code&gt;seek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.tell&quot;&gt;&lt;code&gt;tell()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt;. These objects can operate independently of the ZipFile.</source>
          <target state="translated">在 &lt;code&gt;'r'&lt;/code&gt; &lt;em&gt;模式下，&lt;/em&gt;类似文件的对象（ &lt;code&gt;ZipExtFile&lt;/code&gt; ）是只读的，并提供以下方法：&lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.seek&quot;&gt; &lt;code&gt;seek()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.IOBase.tell&quot;&gt; &lt;code&gt;tell()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt;next __（）。这些对象可以独立于ZipFile运行。</target>
        </trans-unit>
        <trans-unit id="760bad3e7ab6068220380f26094e6c0104a0a57d" translate="yes" xml:space="preserve">
          <source>With IDLE&amp;rsquo;s Shell, one enters, edits, and recalls complete statements. Most consoles and terminals only work with a single physical line at a time.</source>
          <target state="translated">使用IDLE的Shell，您可以输入，编辑和调用完整的语句。大多数控制台和终端一次只能使用一条物理线路。</target>
        </trans-unit>
        <trans-unit id="c8624f48bb5849e7e5433618835e15f38bb647da" translate="yes" xml:space="preserve">
          <source>With SQLite versions before 3.6.5, &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt; is set to 0 if you make a &lt;code&gt;DELETE FROM table&lt;/code&gt; without any condition.</source>
          <target state="translated">在3.6.5之前的SQLite版本中，如果无条件创建 &lt;code&gt;DELETE FROM table&lt;/code&gt; ，则&lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt;设置为0 。</target>
        </trans-unit>
        <trans-unit id="25ab21266758b5ede32eaf88e6036970613bdaaa" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;filename:lineno&lt;/em&gt; argument, clear all the breakpoints at this line. With a space separated list of breakpoint numbers, clear those breakpoints. Without argument, clear all breaks (but first ask confirmation).</source>
          <target state="translated">使用&lt;em&gt;filename：lineno&lt;/em&gt;参数，清除此行上的所有断点。用空格分隔的断点列表，清除这些断点。不加争论，清除所有中断（但首先要求确认）。</target>
        </trans-unit>
        <trans-unit id="2f04d9aa94fac16f17c271f8cc6b74f5e423a9cf" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;lineno&lt;/em&gt; argument, set a break there in the current file. With a &lt;em&gt;function&lt;/em&gt; argument, set a break at the first executable statement within that function. The line number may be prefixed with a filename and a colon, to specify a breakpoint in another file (probably one that hasn&amp;rsquo;t been loaded yet). The file is searched on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;. Note that each breakpoint is assigned a number to which all the other breakpoint commands refer.</source>
          <target state="translated">使用&lt;em&gt;lineno&lt;/em&gt;参数在当前文件中设置一个中断。使用&lt;em&gt;函数&lt;/em&gt;参数，在该函数中的第一个可执行语句处设置一个中断。行号可以以文件名和冒号作为前缀，以在另一个文件（可能是尚未加载的文件）中指定一个断点。在&lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt;上搜索该文件。请注意，每个断点都分配有一个编号，所有其他断点命令都引用该编号。</target>
        </trans-unit>
        <trans-unit id="2644e40930b324401a9a51c3ee62d4106eb004ee" translate="yes" xml:space="preserve">
          <source>With a line number, continue execution until a line with a number greater or equal to that is reached. In both cases, also stop when the current frame returns.</source>
          <target state="translated">有了行号,继续执行,直到达到一个大于或等于该行号的行。在这两种情况下,也要在当前帧返回时停止。</target>
        </trans-unit>
        <trans-unit id="38ea4c11846bc3197c60dd6b0099e4ae33231ccb" translate="yes" xml:space="preserve">
          <source>With all of these &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicies&lt;/code&gt;&lt;/a&gt;, the effective API of the email package is changed from the Python 3.2 API in the following ways:</source>
          <target state="translated">通过所有这些&lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicies&lt;/code&gt; &lt;/a&gt;，电子邮件包的有效API通过以下方式从Python 3.2 API进行了更改：</target>
        </trans-unit>
        <trans-unit id="b96c4be50c56eb883550373721c030d4e8832643" translate="yes" xml:space="preserve">
          <source>With all these new widgets, you can introduce new interaction techniques into applications, creating more useful and more intuitive user interfaces. You can design your application by choosing the most appropriate widgets to match the special needs of your application and users.</source>
          <target state="translated">有了这些新的小部件,您可以将新的交互技术引入到应用程序中,创建更有用、更直观的用户界面。您可以通过选择最合适的小部件来设计您的应用程序,以满足您的应用程序和用户的特殊需求。</target>
        </trans-unit>
        <trans-unit id="dfb01d15923e2347d124cf6810b6f7bbee6f12aa" translate="yes" xml:space="preserve">
          <source>With an explicit &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; argument, the result is a byte string in the specified encoding. With no &lt;em&gt;encoding&lt;/em&gt; argument, the result is a Unicode string, and the XML declaration in the resulting string does not specify an encoding. Encoding this string in an encoding other than UTF-8 is likely incorrect, since UTF-8 is the default encoding of XML.</source>
          <target state="translated">使用显式&lt;em&gt;encoding &lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;参数，结果是指定编码中的字节字符串。没有&lt;em&gt;编码&lt;/em&gt;参数，结果为Unicode字符串，并且结果字符串中的XML声明未指定编码。由于UTF-8是XML的默认编码，因此使用UTF-8以外的其他编码对该字符串进行编码可能不正确。</target>
        </trans-unit>
        <trans-unit id="4880d188a38217b2e5a2d31451fe8eadcea721e6" translate="yes" xml:space="preserve">
          <source>With arguments, return a list of values that result from looking up each argument in the configuration variable dictionary.</source>
          <target state="translated">带参数,返回在配置变量字典中查找每个参数的结果值的列表。</target>
        </trans-unit>
        <trans-unit id="764867c8bff630b1f0ada90f3f9eb8f138801c7b" translate="yes" xml:space="preserve">
          <source>With filtering on, &lt;code&gt;dir(some_mock)&lt;/code&gt; shows only useful attributes and will include any dynamically created attributes that wouldn&amp;rsquo;t normally be shown. If the mock was created with a &lt;em&gt;spec&lt;/em&gt; (or &lt;em&gt;autospec&lt;/em&gt; of course) then all the attributes from the original are shown, even if they haven&amp;rsquo;t been accessed yet:</source>
          <target state="translated">启用过滤后， &lt;code&gt;dir(some_mock)&lt;/code&gt; 仅显示有用的属性，并且将包含通常不会显示的任何动态创建的属性。如果模拟是使用&lt;em&gt;规范&lt;/em&gt;（或&lt;em&gt;自动&lt;/em&gt;&lt;em&gt;规范&lt;/em&gt;）创建的，那么即使尚未访问原始属性，也会显示所有属性：</target>
        </trans-unit>
        <trans-unit id="aab53d4374bfcc2a7d9f8f2e07cc334e9b8d4ebe" translate="yes" xml:space="preserve">
          <source>With no &lt;em&gt;bpnumber&lt;/em&gt; argument, &lt;code&gt;commands&lt;/code&gt; refers to the last breakpoint set.</source>
          <target state="translated">如果没有&lt;em&gt;bpnumber&lt;/em&gt;参数，则 &lt;code&gt;commands&lt;/code&gt; 引用最后一个断点集。</target>
        </trans-unit>
        <trans-unit id="a0d7fd252a8ac0acd7b9c9b4e24a97bf47857d8f" translate="yes" xml:space="preserve">
          <source>With no arguments, return a dictionary of all configuration variables relevant for the current platform.</source>
          <target state="translated">没有参数,返回与当前平台相关的所有配置变量的字典。</target>
        </trans-unit>
        <trans-unit id="efd89a071ec612fcc528b4ebb7e35378e6acc199" translate="yes" xml:space="preserve">
          <source>With no arguments, run a full collection. The optional argument &lt;em&gt;generation&lt;/em&gt; may be an integer specifying which generation to collect (from 0 to 2). A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if the generation number is invalid. The number of unreachable objects found is returned.</source>
          <target state="translated">没有参数，运行完整的集合。可选参数&lt;em&gt;生成&lt;/em&gt;可以是整数，它指定要收集的生成代（从0到2）。一个&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 异常&lt;/a&gt;若辈号码无效上升。返回找到的不可达对象的数量。</target>
        </trans-unit>
        <trans-unit id="ed5301520b7fd396ab2dfe6409c5f533e884e4c5" translate="yes" xml:space="preserve">
          <source>With one argument, return the natural logarithm of &lt;em&gt;x&lt;/em&gt; (to base &lt;em&gt;e&lt;/em&gt;).</source>
          <target state="translated">使用一个参数，返回&lt;em&gt;x&lt;/em&gt;的自然对数（以&lt;em&gt;e&lt;/em&gt;为底）。</target>
        </trans-unit>
        <trans-unit id="b5717389f2b0fe33f8fc1d55c281454fe06d5e2b" translate="yes" xml:space="preserve">
          <source>With one argument, return the type of an &lt;em&gt;object&lt;/em&gt;. The return value is a type object and generally the same object as returned by &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt;&lt;code&gt;object.__class__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用一个参数返回&lt;em&gt;对象&lt;/em&gt;的类型。返回值是类型对象，通常与&lt;a href=&quot;stdtypes#instance.__class__&quot;&gt; &lt;code&gt;object.__class__&lt;/code&gt; &lt;/a&gt;返回的对象相同。</target>
        </trans-unit>
        <trans-unit id="3010b34325387d6e0374de77099e8677662b587d" translate="yes" xml:space="preserve">
          <source>With one argument, returns a dictionary of column/value pairs for the specified &lt;em&gt;item&lt;/em&gt;. With two arguments, returns the current value of the specified &lt;em&gt;column&lt;/em&gt;. With three arguments, sets the value of given &lt;em&gt;column&lt;/em&gt; in given &lt;em&gt;item&lt;/em&gt; to the specified &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">使用一个参数，返回指定&lt;em&gt;item&lt;/em&gt;的列/值对的字典。具有两个参数，返回指定&lt;em&gt;column&lt;/em&gt;的当前值。使用三个参数，将给定&lt;em&gt;项目&lt;/em&gt;中给定&lt;em&gt;列&lt;/em&gt;的值设置为指定&lt;em&gt;值&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f254b557ac83471d6ca20286be89daa2ca79428b" translate="yes" xml:space="preserve">
          <source>With optional argument &lt;em&gt;i&lt;/em&gt;, &lt;a href=&quot;#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; will return the &lt;em&gt;i&lt;/em&gt;-th element of the payload, counting from zero, if &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. An &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is less than 0 or greater than or equal to the number of items in the payload. If the payload is a string (i.e. &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;) and &lt;em&gt;i&lt;/em&gt; is given, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果&lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;True&lt;/code&gt; ，则使用可选参数&lt;em&gt;i&lt;/em&gt;，&lt;a href=&quot;#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt;将返回有效载荷的第&lt;em&gt;i&lt;/em&gt;个元素，从零开始计数。一个&lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt;如果将提高&lt;em&gt;我&lt;/em&gt;是小于0或大于或等于在所述有效载荷的项目数。如果有效载荷是字符串（即&lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;False&lt;/code&gt; ）并且给出&lt;em&gt;i&lt;/em&gt;，则引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95cfd380016562aed86b66b762be2eb99843bf08" translate="yes" xml:space="preserve">
          <source>With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</source>
          <target state="translated">在pickle协议第4版中,可以轻松地将枚举嵌套在其他类中。</target>
        </trans-unit>
        <trans-unit id="5f1839f1bd0fed63c796608b36a191d7890a7fee" translate="yes" xml:space="preserve">
          <source>With rare exceptions, the result of executing Python code with IDLE is intended to be the same as executing the same code by the default method, directly with Python in a text-mode system console or terminal window. However, the different interface and operation occasionally affect visible results. For instance, &lt;code&gt;sys.modules&lt;/code&gt; starts with more entries, and &lt;code&gt;threading.activeCount()&lt;/code&gt; returns 2 instead of 1.</source>
          <target state="translated">除极少数例外，使用IDLE执行Python代码的结果与通过默认方法直接在文本模式系统控制台或终端窗口中直接使用Python执行相同的代码的意图相同。但是，不同的界面和操作有时会影响可见结果。例如， &lt;code&gt;sys.modules&lt;/code&gt; 以更多条目开头， &lt;code&gt;threading.activeCount()&lt;/code&gt; 返回2而不是1。</target>
        </trans-unit>
        <trans-unit id="c0015f869c31b401bfecbb86dbfba0c4047c9bd7" translate="yes" xml:space="preserve">
          <source>With server socket, this mode provides mandatory TLS client cert authentication. A client certificate request is sent to the client and the client must provide a valid and trusted certificate.</source>
          <target state="translated">通过服务器套接字,该模式提供强制性的TLS客户端证书认证。客户端证书请求被发送到客户端,客户端必须提供有效的可信证书。</target>
        </trans-unit>
        <trans-unit id="d44fbe6e65b12b51b031a5cae9513730c1dc7435" translate="yes" xml:space="preserve">
          <source>With sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, an &lt;strong&gt;aware&lt;/strong&gt; object can locate itself relative to other aware objects. An aware object represents a specific moment in time that is not open to interpretation. &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">有了足够的适用算法和政治时间调整知识（例如时区和夏时制信息），一个有&lt;strong&gt;意识的&lt;/strong&gt;对象就可以相对于其他有意识的对象定位自己。一个有意识的对象表示一个特定的时刻，这个时刻是无法解释的。&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1个&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="deac18952e93d68efd06227e703e6bf5a3115b23" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;'store_const'&lt;/code&gt; and &lt;code&gt;'append_const'&lt;/code&gt; actions, the &lt;code&gt;const&lt;/code&gt; keyword argument must be given. For other actions, it defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;'store_const'&lt;/code&gt; 和 &lt;code&gt;'append_const'&lt;/code&gt; 操作时，必须给出 &lt;code&gt;const&lt;/code&gt; 关键字参数。对于其他操作，它默认为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="194119009270c68f60a1104e8b4240dd2ceaff94" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, the method call does not block. If the lock is currently in a locked state, return &lt;code&gt;False&lt;/code&gt;; otherwise set the lock to a locked state and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">将&lt;em&gt;block&lt;/em&gt;参数设置为 &lt;code&gt;False&lt;/code&gt; 时，方法调用不会阻塞。如果锁当前处于锁定状态，则返回 &lt;code&gt;False&lt;/code&gt; 。否则，将锁定设置为锁定状态并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e871eb88b98ae8c67b374e93e1e89a7c0c7dcd5" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), the method call will block until the lock is in an unlocked state, then set it to locked and return &lt;code&gt;True&lt;/code&gt;. Note that the name of this first argument differs from that in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;em&gt;block&lt;/em&gt;参数设置为 &lt;code&gt;True&lt;/code&gt; （默认值）后，方法调用将阻塞，直到锁处于解锁状态为止，然后将其设置为locked并返回 &lt;code&gt;True&lt;/code&gt; 。请注意，第一个参数的名称与&lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; &lt;/a&gt;中的名称不同。</target>
        </trans-unit>
        <trans-unit id="2269bdd62541838f898684dcd5142d85924bfe48" translate="yes" xml:space="preserve">
          <source>With the subsequent code object one can execute it in a module by running &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt;.</source>
          <target state="translated">使用随后的代码对象，可以通过运行 &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt; 在模块中执行它。</target>
        </trans-unit>
        <trans-unit id="ebbacdcf56db793c4cc45ee8691bf7b6605ec5c1" translate="yes" xml:space="preserve">
          <source>With this pattern, multiple factories could be chained, and as long as they don&amp;rsquo;t overwrite each other&amp;rsquo;s attributes or unintentionally overwrite the standard attributes listed above, there should be no surprises.</source>
          <target state="translated">通过这种模式，可以链接多个工厂，并且只要它们不覆盖彼此的属性或无意覆盖上面列出的标准属性，就不会感到惊讶。</target>
        </trans-unit>
        <trans-unit id="40a6ba4daa5a2342ad82ea7038d0c1a705a07197" translate="yes" xml:space="preserve">
          <source>With three arguments, compute &lt;code&gt;(x**y) % modulo&lt;/code&gt;. For the three argument form, the following restrictions on the arguments hold:</source>
          <target state="translated">使用三个参数，计算 &lt;code&gt;(x**y) % modulo&lt;/code&gt; 。对于三个参数形式，对参数的以下限制适用：</target>
        </trans-unit>
        <trans-unit id="8fab22f970395c672be8c4c452402f6883149c6e" translate="yes" xml:space="preserve">
          <source>With three arguments, return a new type object. This is essentially a dynamic form of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; statement. The &lt;em&gt;name&lt;/em&gt; string is the class name and becomes the &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; attribute; the &lt;em&gt;bases&lt;/em&gt; tuple itemizes the base classes and becomes the &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt;&lt;code&gt;__bases__&lt;/code&gt;&lt;/a&gt; attribute; and the &lt;em&gt;dict&lt;/em&gt; dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. For example, the following two statements create identical &lt;a href=&quot;#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">具有三个参数，返回一个新的类型对象。这本质上是&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt;语句的动态形式。该&lt;em&gt;名&lt;/em&gt;字符串类名，成为&lt;a href=&quot;stdtypes#definition.__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt;属性;所述&lt;em&gt;碱&lt;/em&gt;元组逐条列出的基类和成为&lt;a href=&quot;stdtypes#class.__bases__&quot;&gt; &lt;code&gt;__bases__&lt;/code&gt; 来得到&lt;/a&gt;的属性;和&lt;em&gt;字典&lt;/em&gt;的字典是包含用于类定义体的命名空间和被复制到标准词典成为&lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt;属性。例如，以下两个语句创建相同的&lt;a href=&quot;#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="fa3a7fb3b8e9ab7d2857a7405a359bd983f4cf63" translate="yes" xml:space="preserve">
          <source>With three arguments, return a new type object. This is essentially a dynamic form of the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; statement. The &lt;em&gt;name&lt;/em&gt; string is the class name and becomes the &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; attribute; the &lt;em&gt;bases&lt;/em&gt; tuple itemizes the base classes and becomes the &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt;&lt;code&gt;__bases__&lt;/code&gt;&lt;/a&gt; attribute; and the &lt;em&gt;dict&lt;/em&gt; dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. For example, the following two statements create identical &lt;a href=&quot;#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">具有三个参数，返回一个新的类型对象。这本质上是&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt;语句的动态形式。该&lt;em&gt;名&lt;/em&gt;字符串类名，成为&lt;a href=&quot;stdtypes#definition.__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt;属性; 所述&lt;em&gt;碱&lt;/em&gt;元组逐条列出的基类和成为&lt;a href=&quot;stdtypes#class.__bases__&quot;&gt; &lt;code&gt;__bases__&lt;/code&gt; 来得到&lt;/a&gt;的属性; 和&lt;em&gt;字典&lt;/em&gt;的字典是包含用于类定义体的命名空间和被复制到标准词典成为&lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt;属性。例如，以下两个语句创建相同的&lt;a href=&quot;#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="f8885c6119b55f6917eee9f2b9372898c8263a3e" translate="yes" xml:space="preserve">
          <source>With two arguments, compute &lt;code&gt;x**y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is negative then &lt;code&gt;y&lt;/code&gt; must be integral. The result will be inexact unless &lt;code&gt;y&lt;/code&gt; is integral and the result is finite and can be expressed exactly in &amp;lsquo;precision&amp;rsquo; digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version.</source>
          <target state="translated">有两个参数，计算 &lt;code&gt;x**y&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 为负，则 &lt;code&gt;y&lt;/code&gt; 必须为整数。除非 &lt;code&gt;y&lt;/code&gt; 为整数并且结果是有限的并且可以用&amp;ldquo;精度&amp;rdquo;数字精确表示，否则结果将是不精确的。使用上下文的舍入模式。结果始终在Python版本中正确取整。</target>
        </trans-unit>
        <trans-unit id="b43cb0e0aa8bf5b547ad83f94e989da6ff98d438" translate="yes" xml:space="preserve">
          <source>With two arguments, return the logarithm of &lt;em&gt;x&lt;/em&gt; to the given &lt;em&gt;base&lt;/em&gt;, calculated as &lt;code&gt;log(x)/log(base)&lt;/code&gt;.</source>
          <target state="translated">使用两个参数，将&lt;em&gt;x&lt;/em&gt;的对数返回给定的&lt;em&gt;底数&lt;/em&gt;，计算为 &lt;code&gt;log(x)/log(base)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00a50c0d900159dbcd62b43debe7309bd2b37fad" translate="yes" xml:space="preserve">
          <source>With version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; generates a narrower range of seeds.</source>
          <target state="translated">对于版本1（为从旧版本的Python复制随机序列而提供），用于&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;的算法生成的种子范围更窄。</target>
        </trans-unit>
        <trans-unit id="b20bd639ded266fcc391752e271e39a98c7700d3" translate="yes" xml:space="preserve">
          <source>With version 2 (the default), a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; object gets converted to an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and all of its bits are used.</source>
          <target state="translated">在版本2（默认设置）中，将&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;对象转换为&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;并使用其所有位。</target>
        </trans-unit>
        <trans-unit id="6ec63c85650e7ada817c79ea880456525b435a75" translate="yes" xml:space="preserve">
          <source>With versions of OpenSSL older than 0.9.8m, it is only possible to set options, not to clear them. Attempting to clear an option (by resetting the corresponding bits) will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于低于0.9.8m的OpenSSL版本，只能设置选项，而不能清除它们。尝试清除选项（通过重置相应的位）将引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6887de87bb8914463818ce0668d423fe277ff788" translate="yes" xml:space="preserve">
          <source>Within an editor window containing Python code, code context can be toggled in order to show or hide a pane at the top of the window. When shown, this pane freezes the opening lines for block code, such as those beginning with &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or &lt;code&gt;if&lt;/code&gt; keywords, that would have otherwise scrolled out of view. The size of the pane will be expanded and contracted as needed to show the all current levels of context, up to the maximum number of lines defined in the Configure IDLE dialog (which defaults to 15). If there are no current context lines and the feature is toggled on, a single blank line will display. Clicking on a line in the context pane will move that line to the top of the editor.</source>
          <target state="translated">在包含Python代码的编辑器窗口中，可以切换代码上下文，以显示或隐藏窗口顶部的窗格。当显示时，此窗格将冻结块代码的开头行，例如以 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; 或 &lt;code&gt;if&lt;/code&gt; 关键字开头的行，否则这些行将滚动到视图之外。窗格的大小将根据需要进行扩展和收缩，以显示所有当前级别的上下文，直到&amp;ldquo;配置IDLE&amp;rdquo;对话框中定义的最大行数（默认为15）。如果没有当前上下文行并且功能已打开，则将显示单个空白行。单击上下文窗格中的一行将把该行移到编辑器的顶部。</target>
        </trans-unit>
        <trans-unit id="2f8b057e4c0feacb665a8a7757beb8aa22e2fdde" translate="yes" xml:space="preserve">
          <source>Without an argument, &lt;a href=&quot;#vars&quot;&gt;&lt;code&gt;vars()&lt;/code&gt;&lt;/a&gt; acts like &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt;. Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.</source>
          <target state="translated">没有参数，&lt;a href=&quot;#vars&quot;&gt; &lt;code&gt;vars()&lt;/code&gt; &lt;/a&gt;就像&lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; 一样&lt;/a&gt;。请注意，由于忽略了本地字典的更新，因此本地字典仅对读取有用。</target>
        </trans-unit>
        <trans-unit id="89afaf5902230f11dab6931656e83d660578a26d" translate="yes" xml:space="preserve">
          <source>Without an argument, an array of size 0 is created.</source>
          <target state="translated">在没有参数的情况下,会创建一个大小为0的数组。</target>
        </trans-unit>
        <trans-unit id="9879a08d72136016023f63f62288fdbd06d5e766" translate="yes" xml:space="preserve">
          <source>Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock &amp;mdash; that&amp;rsquo;s their reason for existence).</source>
          <target state="translated">如果没有任何可选参数，则此方法无条件获取该锁，必要时可以等待它被另一个线程释放（一次只有一个线程可以获取一个锁-这就是它们存在的原因）。</target>
        </trans-unit>
        <trans-unit id="eb98828bb03ebff04d92f1d4995a6a336ce35b0c" translate="yes" xml:space="preserve">
          <source>Without argument, continue execution until the line with a number greater than the current one is reached.</source>
          <target state="translated">在没有参数的情况下,继续执行,直到达到比当前数字大的行。</target>
        </trans-unit>
        <trans-unit id="c89138ed071a0b6e27259e35980ae9555134901d" translate="yes" xml:space="preserve">
          <source>Without argument, list all breaks, including for each breakpoint, the number of times that breakpoint has been hit, the current ignore count, and the associated condition if any.</source>
          <target state="translated">在没有参数的情况下,列出所有的断点,包括每个断点被击中的次数,当前的忽略次数,以及相关的条件(如果有)。</target>
        </trans-unit>
        <trans-unit id="5eeedd2237cda7b0eb8c9cc1a204ca22979c1c18" translate="yes" xml:space="preserve">
          <source>Without argument, print the list of available commands. With a &lt;em&gt;command&lt;/em&gt; as argument, print help about that command. &lt;code&gt;help pdb&lt;/code&gt; displays the full documentation (the docstring of the &lt;a href=&quot;#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module). Since the &lt;em&gt;command&lt;/em&gt; argument must be an identifier, &lt;code&gt;help exec&lt;/code&gt; must be entered to get help on the &lt;code&gt;!&lt;/code&gt; command.</source>
          <target state="translated">不带参数的情况下，显示可用命令的列表。以&lt;em&gt;命令&lt;/em&gt;作为参数，输出有关该命令的帮助。 &lt;code&gt;help pdb&lt;/code&gt; 显示完整的文档（&lt;a href=&quot;#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt;模块的文档字符串）。由于&lt;em&gt;命令&lt;/em&gt;参数必须是标识符，因此必须输入 &lt;code&gt;help exec&lt;/code&gt; 以获取有关 &lt;code&gt;!&lt;/code&gt; 的帮助。命令。</target>
        </trans-unit>
        <trans-unit id="77f66cab56a49a5274a00828711f0d39b63586e1" translate="yes" xml:space="preserve">
          <source>Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.</source>
          <target state="translated">没有参数,返回当前本地作用域中的名称列表。有参数时,尝试返回该对象的有效属性列表。</target>
        </trans-unit>
        <trans-unit id="769b9bb5176bd30fc5c9a906deb72757797c5114" translate="yes" xml:space="preserve">
          <source>Without expression, list all display expressions for the current frame.</source>
          <target state="translated">无表情,列出当前帧的所有显示表情。</target>
        </trans-unit>
        <trans-unit id="f094cebe8a845676c5da8b2f31cd1951b0afca42" translate="yes" xml:space="preserve">
          <source>Without external information it&amp;rsquo;s impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that&amp;rsquo;s not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn&amp;rsquo;t allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt;) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: &lt;code&gt;0xef&lt;/code&gt;, &lt;code&gt;0xbb&lt;/code&gt;, &lt;code&gt;0xbf&lt;/code&gt;) is written. As it&amp;rsquo;s rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</source>
          <target state="translated">没有外部信息，就不可能可靠地确定使用哪种编码对字符串进行编码。每种charmap编码都可以解码任何随机字节序列。但是，对于UTF-8，这是不可能的，因为UTF-8字节序列的结构不允许任意字节序列。为了提高检测UTF-8编码的可靠性，Microsoft 为其Notepad程序发明了UTF-8的变体（Python 2.5称为 &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt; ）：在将任何Unicode字符写入之前在文件中，写入了UTF-8编码的BOM（看起来像字节序列： &lt;code&gt;0xef&lt;/code&gt; ， &lt;code&gt;0xbb&lt;/code&gt; ， &lt;code&gt;0xbf&lt;/code&gt; ）。因为任何charmap编码的文件都以这些字节值开头（例如，映射到</target>
        </trans-unit>
        <trans-unit id="7849a7a1c3473cfd49dc9807cf4c861c767d29df" translate="yes" xml:space="preserve">
          <source>Without the directive it would fail, both because the actual output doesn&amp;rsquo;t have two blanks before the single-digit list elements, and because the actual output is on a single line. This test also passes, and also requires a directive to do so:</source>
          <target state="translated">如果没有该指令，它将会失败，这是因为实际输出在单位列表元素之前没有两个空格，并且因为实际输出在一行上。此测试也可以通过，并且还需要一条指令来这样做：</target>
        </trans-unit>
        <trans-unit id="b56f8f7059663881528e5f04cc607dbf57d02130" translate="yes" xml:space="preserve">
          <source>Without the use of this decorator factory, the name of the example function would have been &lt;code&gt;'wrapper'&lt;/code&gt;, and the docstring of the original &lt;code&gt;example()&lt;/code&gt; would have been lost.</source>
          <target state="translated">如果不使用此装饰器工厂，则示例函数的名称将为 &lt;code&gt;'wrapper'&lt;/code&gt; ，并且原始 &lt;code&gt;example()&lt;/code&gt; 的文档字符串将丢失。</target>
        </trans-unit>
        <trans-unit id="f7fe2fe1baf1ec16cf5ceba69d9460d06d020a49" translate="yes" xml:space="preserve">
          <source>Without using a subtest, execution would stop after the first failure, and the error would be less easy to diagnose because the value of &lt;code&gt;i&lt;/code&gt; wouldn&amp;rsquo;t be displayed:</source>
          <target state="translated">如果不使用子测试，则在第一个失败后执行将停止，并且错误将不那么容易诊断，因为不会显示 &lt;code&gt;i&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="5ea2ab24d7c35c5430a569d407bd85c65f4e85bc" translate="yes" xml:space="preserve">
          <source>Without using the lock output from the different processes is liable to get all mixed up.</source>
          <target state="translated">如果不使用锁,不同进程的输出很有可能全部混在一起。</target>
        </trans-unit>
        <trans-unit id="b27c0f0558f8802b19cb669e94d2076c0c6c0fda" translate="yes" xml:space="preserve">
          <source>Worker processes within a &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; typically live for the complete duration of the Pool&amp;rsquo;s work queue. A frequent pattern found in other systems (such as Apache, mod_wsgi, etc) to free resources held by workers is to allow a worker within a pool to complete only a set amount of work before being exiting, being cleaned up and a new process spawned to replace the old one. The &lt;em&gt;maxtasksperchild&lt;/em&gt; argument to the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; exposes this ability to the end user.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt;工作进程通常在池的工作队列的整个期间内都处于活动状态。在其他系统（例如Apache，mod_wsgi等）中发现的释放工人资源的常见模式是允许池中的工人在退出，清理和产生新进程之前仅完成一定数量的工作。取代旧的。&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;maxtasksperchild&lt;/em&gt;参数向最终用户公开了此功能。</target>
        </trans-unit>
        <trans-unit id="89015cfdb27fab11c50f80e1f354316ca91c613f" translate="yes" xml:space="preserve">
          <source>Working with pipes</source>
          <target state="translated">使用管道</target>
        </trans-unit>
        <trans-unit id="8bae363ed38dab1b6d087a54fbbd4f84ed78b18a" translate="yes" xml:space="preserve">
          <source>Working with socket objects directly</source>
          <target state="translated">直接使用插座对象</target>
        </trans-unit>
        <trans-unit id="9d6d7f52d1d150a89cde4bda127b7602fe0e15d9" translate="yes" xml:space="preserve">
          <source>Working with threads</source>
          <target state="translated">使用线程</target>
        </trans-unit>
        <trans-unit id="67bb3765ae259f479c80ae46b7c05de23c1886aa" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a list.</source>
          <target state="translated">用作&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; &lt;/a&gt;，但创建一个列表。</target>
        </trans-unit>
        <trans-unit id="fb8fe5d39fb592372defca4a7c0cdd14adfc931a" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a set.</source>
          <target state="translated">用作&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; &lt;/a&gt;，但创建一个集合。</target>
        </trans-unit>
        <trans-unit id="2e4b35ffa278b6b960046684c3fd2fa34208fe21" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt;&lt;code&gt;DELETE_NAME&lt;/code&gt;&lt;/a&gt;, but deletes a global name.</source>
          <target state="translated">用作&lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt; &lt;code&gt;DELETE_NAME&lt;/code&gt; &lt;/a&gt;，但删除全局名称。</target>
        </trans-unit>
        <trans-unit id="9391eb2e809296019b9e1392d2df6abc88491766" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-STORE_NAME&quot;&gt;&lt;code&gt;STORE_NAME&lt;/code&gt;&lt;/a&gt;, but stores the name as a global.</source>
          <target state="translated">用作&lt;a href=&quot;#opcode-STORE_NAME&quot;&gt; &lt;code&gt;STORE_NAME&lt;/code&gt; &lt;/a&gt;，但将名称存储为全局名称。</target>
        </trans-unit>
        <trans-unit id="f9b523701c081148b44a5e161316a03f46215499" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt; except that the input to the &lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt;&lt;code&gt;feed()&lt;/code&gt;&lt;/a&gt; method must be a string. This is of limited utility, since the only way for such a message to be valid is for it to contain only ASCII text or, if &lt;code&gt;utf8&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, no binary attachments.</source>
          <target state="translated">与&lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; 相似,&lt;/a&gt;但&lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt; &lt;code&gt;feed()&lt;/code&gt; &lt;/a&gt;方法的输入必须为字符串。这是有限的实用程序，因为使这种消息有效的唯一方法是仅包含ASCII文本，或者，如果 &lt;code&gt;utf8&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则不包含二进制附件。</target>
        </trans-unit>
        <trans-unit id="185db21e361257c180478865bbb0efa3b0737049" translate="yes" xml:space="preserve">
          <source>Works the same way as &lt;a href=&quot;#inspect.Signature.bind&quot;&gt;&lt;code&gt;Signature.bind()&lt;/code&gt;&lt;/a&gt;, but allows the omission of some required arguments (mimics &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt; behavior.) Returns &lt;a href=&quot;#inspect.BoundArguments&quot;&gt;&lt;code&gt;BoundArguments&lt;/code&gt;&lt;/a&gt;, or raises a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the passed arguments do not match the signature.</source>
          <target state="translated">与&lt;a href=&quot;#inspect.Signature.bind&quot;&gt; &lt;code&gt;Signature.bind()&lt;/code&gt; 的&lt;/a&gt;工作方式相同，但允许省略某些必需的参数（模仿&lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;行为。）返回&lt;a href=&quot;#inspect.BoundArguments&quot;&gt; &lt;code&gt;BoundArguments&lt;/code&gt; &lt;/a&gt;，如果传递的参数与签名不匹配，则引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1783e364fda74448269ebe2d7f239fb3ef7f871" translate="yes" xml:space="preserve">
          <source>Wrap &lt;em&gt;application&lt;/em&gt; and return a new WSGI application object. The returned application will forward all requests to the original &lt;em&gt;application&lt;/em&gt;, and will check that both the &lt;em&gt;application&lt;/em&gt; and the server invoking it are conforming to the WSGI specification and to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">包装&lt;em&gt;应用程序&lt;/em&gt;并返回一个新的WSGI应用程序对象。返回的应用程序会将所有请求转发到原始&lt;em&gt;应用程序&lt;/em&gt;，并将检查该&lt;em&gt;应用程序&lt;/em&gt;和调用它的服务器是否都符合WSGI规范和&lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50ddf4360a796894dae0f6d5a9d4445df2e11d56" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt;&lt;code&gt;concurrent.futures.Future&lt;/code&gt;&lt;/a&gt; object in a &lt;a href=&quot;#asyncio.Future&quot;&gt;&lt;code&gt;asyncio.Future&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">裹一&lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt; &lt;code&gt;concurrent.futures.Future&lt;/code&gt; &lt;/a&gt;的对象&lt;a href=&quot;#asyncio.Future&quot;&gt; &lt;code&gt;asyncio.Future&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="2b27f3224dafe97e6c0b3e8a8fa06d53cea4dc76" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">将&lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;包装为 &lt;code&gt;(transport, protocol)&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="c612d6e5f7981ee986eea5813673351e3cb45b2c" translate="yes" xml:space="preserve">
          <source>Wrap a read end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">将管道的读取端包装为 &lt;code&gt;(transport, protocol)&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="ff3306add2272df4e9ce3ccf3f316e30e699743f" translate="yes" xml:space="preserve">
          <source>Wrap a write end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">将管道的写端包装为 &lt;code&gt;(transport, protocol)&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="b76b940bb5be2bb8e2a70d99685e901b66b64693" translate="yes" xml:space="preserve">
          <source>Wrap an already accepted connection into a transport/protocol pair.</source>
          <target state="translated">将一个已经接受的连接包装成传输/协议对。</target>
        </trans-unit>
        <trans-unit id="6a18c9e5ad1f9bbb6b629543bc34a3ee5302486a" translate="yes" xml:space="preserve">
          <source>Wrap an existing Python socket &lt;em&gt;sock&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt;&lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;). The returned SSL socket is tied to the context, its settings and certificates. &lt;em&gt;sock&lt;/em&gt; must be a &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; socket; other socket types are unsupported.</source>
          <target state="translated">包装现有的Python套接字&lt;em&gt;袜子，&lt;/em&gt;并返回&lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt; &lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt; &lt;/a&gt;的实例（默认&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;）。返回的SSL套接字与上下文，其设置和证书相关联。&lt;em&gt;袜子&lt;/em&gt;必须是&lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt;套接字；其他套接字类型不受支持。</target>
        </trans-unit>
        <trans-unit id="0016efeeb31ae253fc49cf82049e6b29fd8ba856" translate="yes" xml:space="preserve">
          <source>Wrap the &lt;em&gt;coro&lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;coroutine&lt;/a&gt; into a &lt;a href=&quot;#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and schedule its execution. Return the Task object.</source>
          <target state="translated">将&lt;em&gt;coro &lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;协程&lt;/a&gt;包装到&lt;a href=&quot;#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 中&lt;/a&gt;并安排其执行时间。返回任务对象。</target>
        </trans-unit>
        <trans-unit id="f98244aacb2a997c25507ffd260f55a5828e5faa" translate="yes" xml:space="preserve">
          <source>Wrap the BIO objects &lt;em&gt;incoming&lt;/em&gt; and &lt;em&gt;outgoing&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt;&lt;code&gt;SSLContext.sslobject_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;). The SSL routines will read input data from the incoming BIO and write data to the outgoing BIO.</source>
          <target state="translated">包装&lt;em&gt;传入&lt;/em&gt;和&lt;em&gt;传出&lt;/em&gt;的BIO对象，并返回&lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt; &lt;code&gt;SSLContext.sslobject_class&lt;/code&gt; &lt;/a&gt;的实例（默认&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;）。SSL例程将从传入的BIO读取输入数据，并将数据写入传出的BIO。</target>
        </trans-unit>
        <trans-unit id="25c90f8fd4499cd6197f01d510ea3f1b389a2d87" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This is used when reading or writing NSKeyedArchiver encoded data, which contains UID (see PList manual).</source>
          <target state="translated">包装一个&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;。在读取或写入包含UID的NSKeyedArchiver编码数据时使用此方法（请参见PList手册）。</target>
        </trans-unit>
        <trans-unit id="68ffa41434f5ef07bf1b79c543ee91e505e4515d" translate="yes" xml:space="preserve">
          <source>Wraps the &lt;code&gt;posix_spawn()&lt;/code&gt; C library API for use from Python.</source>
          <target state="translated">包装 &lt;code&gt;posix_spawn()&lt;/code&gt; C库API以从Python使用。</target>
        </trans-unit>
        <trans-unit id="b8e4112a55e8230798780d123b0e6ee7624c2bdb" translate="yes" xml:space="preserve">
          <source>Wraps the &lt;code&gt;posix_spawnp()&lt;/code&gt; C library API for use from Python.</source>
          <target state="translated">包装 &lt;code&gt;posix_spawnp()&lt;/code&gt; C库API以从Python使用。</target>
        </trans-unit>
        <trans-unit id="d43d22b5ed05f4ee8e1729b35aef77956fd174aa" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt; (a string) so every line is at most &lt;a href=&quot;#textwrap.TextWrapper.width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; characters long. All wrapping options are taken from instance attributes of the &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty.</source>
          <target state="translated">将单个段落包装为&lt;em&gt;文本&lt;/em&gt;（字符串），因此每行最多为&lt;a href=&quot;#textwrap.TextWrapper.width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt;字符长。所有包装选项均取自&lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt;实例的实例属性。返回输出行列表，不带最终换行符。如果包装的输出没有内容，则返回的列表为空。</target>
        </trans-unit>
        <trans-unit id="bc06193157378861d75bff7a2f1b594fb5b1d3ad" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt; (a string) so every line is at most &lt;em&gt;width&lt;/em&gt; characters long. Returns a list of output lines, without final newlines.</source>
          <target state="translated">将单个段落包装为&lt;em&gt;文本&lt;/em&gt;（字符串），因此每行最多为&lt;em&gt;宽度&lt;/em&gt;字符长。返回输出行列表，不带最终换行符。</target>
        </trans-unit>
        <trans-unit id="7bbb266e216d3a300ed723990a06600b7e04df65" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt;, and returns a single string containing the wrapped paragraph.</source>
          <target state="translated">将单个段落包装为&lt;em&gt;text&lt;/em&gt;，并返回包含已包装段落的单个字符串。</target>
        </trans-unit>
        <trans-unit id="ca151de3d39257aaa7ef51f09776d9426a4e86bf" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt;, and returns a single string containing the wrapped paragraph. &lt;a href=&quot;#textwrap.fill&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; is shorthand for</source>
          <target state="translated">将单个段落包装为&lt;em&gt;text&lt;/em&gt;，并返回包含已包装段落的单个字符串。&lt;a href=&quot;#textwrap.fill&quot;&gt; &lt;code&gt;fill()&lt;/code&gt; &lt;/a&gt;是的简写</target>
        </trans-unit>
        <trans-unit id="cbb520367f46e90cee8b8f5b1e6c21207124495b" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;buf&lt;/em&gt; to the SSL socket and return the number of bytes written. The &lt;em&gt;buf&lt;/em&gt; argument must be an object supporting the buffer interface.</source>
          <target state="translated">将&lt;em&gt;buf&lt;/em&gt;写入SSL套接字，并返回写入的字节数。所述&lt;em&gt;的buf&lt;/em&gt;参数必须是支撑所述缓冲器接口的对象。</target>
        </trans-unit>
        <trans-unit id="aef4a515b7b057bb68f87f064fae35143ec9e666" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;rootObject&lt;/em&gt; to an XML plist file. &lt;em&gt;pathOrFile&lt;/em&gt; may be either a file name or a (writable and binary) file object</source>
          <target state="translated">将&lt;em&gt;rootObject&lt;/em&gt;写入XML plist文件。&lt;em&gt;pathOrFile&lt;/em&gt;可以是文件名，也可以是（可写和二进制）文件对象</target>
        </trans-unit>
        <trans-unit id="48a124faaf6d6424254bc6c3fa325a5691ed3e90" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;s&lt;/em&gt; to the &lt;em&gt;write&lt;/em&gt; method of the &lt;em&gt;outfp&lt;/em&gt; passed to the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s constructor. This provides just enough file-like API for &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; instances to be used in the &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">将&lt;em&gt;s &lt;/em&gt;&lt;em&gt;写入&lt;/em&gt;传递给&lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;的构造函数的&lt;em&gt;outfp&lt;/em&gt;的&lt;em&gt;write&lt;/em&gt;方法。这为&lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;实例提供了足够的类似于文件的API，可在&lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt;函数中使用。</target>
        </trans-unit>
        <trans-unit id="6d2124f354eb98d13eab8a7539f15f0cde6ced95" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;value&lt;/em&gt; to a plist file. &lt;em&gt;Fp&lt;/em&gt; should be a writable, binary file object.</source>
          <target state="translated">将&lt;em&gt;值&lt;/em&gt;写入plist文件。&lt;em&gt;Fp&lt;/em&gt;应该是可写的二进制文件对象。</target>
        </trans-unit>
        <trans-unit id="3fc569fdf3522d7fe1d58d73b6d385b8c188e591" translate="yes" xml:space="preserve">
          <source>Write TLS keys to a keylog file, whenever key material is generated or received. The keylog file is designed for debugging purposes only. The file format is specified by NSS and used by many traffic analyzers such as Wireshark. The log file is opened in append-only mode. Writes are synchronized between threads, but not between processes.</source>
          <target state="translated">每当生成或接收到密钥材料时,将TLS密钥写入密钥记录文件。钥匙记录文件只用于调试目的,文件格式由NSS指定,并被许多流量分析器如Wireshark使用。文件格式由NSS指定,并被许多流量分析软件(如Wireshark)使用。日志文件是以仅附加模式打开的。线程之间的写入是同步的,但进程之间不同步。</target>
        </trans-unit>
        <trans-unit id="37c8d727588366243c8993e3e979b39ba193db5c" translate="yes" xml:space="preserve">
          <source>Write Transports</source>
          <target state="translated">编写运输工具</target>
        </trans-unit>
        <trans-unit id="7f87fb907ae200e452ff1d664c58831d2d4084b7" translate="yes" xml:space="preserve">
          <source>Write XML to the writer object. The writer receives texts but not bytes as input, it should have a &lt;code&gt;write()&lt;/code&gt; method which matches that of the file object interface. The &lt;em&gt;indent&lt;/em&gt; parameter is the indentation of the current node. The &lt;em&gt;addindent&lt;/em&gt; parameter is the incremental indentation to use for subnodes of the current one. The &lt;em&gt;newl&lt;/em&gt; parameter specifies the string to use to terminate newlines.</source>
          <target state="translated">将XML写入writer对象。 &lt;code&gt;write()&lt;/code&gt; 接收文本但不接收字节作为输入，它应具有与文件对象接口相匹配的write（）方法。的&lt;em&gt;缩进&lt;/em&gt;的参数是当前节点的缩进。该&lt;em&gt;addindent&lt;/em&gt;参数是增量压痕要用于当前的子节点。该&lt;em&gt;的NewL&lt;/em&gt;参数指定用于终止换行符的字符串。</target>
        </trans-unit>
        <trans-unit id="34af1234d1be52e185f56532800f5c20e29687e6" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device and return the number of bytes written. If the audio device is in blocking mode (the default), the entire data is always written (again, this is different from usual Unix device semantics). If the device is in non-blocking mode, some data may not be written&amp;mdash;see &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将类似&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;字节的对象&lt;/a&gt;&lt;em&gt;数据&lt;/em&gt;写入音频设备，并返回写入的字节数。如果音频设备处于阻止模式（默认），则始终写入整个数据（再次，这与通常的Unix设备语义不同）。如果设备处于非阻塞模式，则可能无法写入某些数据-请参见&lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7530782eb2bf804763cda334f2dc760226b94c6f" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device: waits until the audio device is able to accept data, writes as much data as it will accept, and repeats until &lt;em&gt;data&lt;/em&gt; has been completely written. If the device is in blocking mode (the default), this has the same effect as &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt; is only useful in non-blocking mode. Has no return value, since the amount of data written is always equal to the amount of data supplied.</source>
          <target state="translated">将类似&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;字节的对象&lt;/a&gt;&lt;em&gt;数据&lt;/em&gt;写入音频设备：等待直到音频设备能够接受数据，写入将要接受的尽可能多的数据，然后重复直到&lt;em&gt;数据&lt;/em&gt;完全写入为止。如果设备处于阻止模式（默认），则其作用与&lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;相同；&lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt;仅在非阻塞模式下有用。没有返回值，因为写入的数据量始终等于提供的数据量。</target>
        </trans-unit>
        <trans-unit id="93cb6941cbab90f65c71948e43ce9d15dbc779e0" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device and return the number of bytes written. If the audio device is in blocking mode (the default), the entire data is always written (again, this is different from usual Unix device semantics). If the device is in non-blocking mode, some data may not be written&amp;mdash;see &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将类似&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;字节的对象&lt;/a&gt;&lt;em&gt;数据&lt;/em&gt;写入音频设备，并返回写入的字节数。如果音频设备处于阻止模式（默认），则始终写入全部数据（同样，这与通常的Unix设备语义不同）。如果设备处于非阻塞模式，则可能无法写入某些数据-请参见&lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c2555eb091dc69472d9fd280785d6512fad99a5" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device: waits until the audio device is able to accept data, writes as much data as it will accept, and repeats until &lt;em&gt;data&lt;/em&gt; has been completely written. If the device is in blocking mode (the default), this has the same effect as &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt; is only useful in non-blocking mode. Has no return value, since the amount of data written is always equal to the amount of data supplied.</source>
          <target state="translated">将类似&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;字节的对象&lt;/a&gt;&lt;em&gt;数据&lt;/em&gt;写入音频设备：等待直到音频设备能够接受数据，写入将要接受的尽可能多的数据，然后重复直到&lt;em&gt;数据&lt;/em&gt;完全写入为止。如果设备处于阻止模式（默认），则其作用与&lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;相同；&lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt;仅在非阻塞模式下有用。没有返回值，因为写入的数据量始终等于提供的数据量。</target>
        </trans-unit>
        <trans-unit id="ab07be95f65e1f944e226c637379683c5bcbbeff" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;__main__.py&lt;/code&gt; file to the archive that executes &lt;em&gt;mainfn&lt;/em&gt;. The &lt;em&gt;mainfn&lt;/em&gt; argument should have the form &amp;ldquo;pkg.mod:fn&amp;rdquo;, where &amp;ldquo;pkg.mod&amp;rdquo; is a package/module in the archive, and &amp;ldquo;fn&amp;rdquo; is a callable in the given module. The &lt;code&gt;__main__.py&lt;/code&gt; file will execute that callable.</source>
          <target state="translated">将 &lt;code&gt;__main__.py&lt;/code&gt; 文件写入执行&lt;em&gt;mainfn&lt;/em&gt;的档案中。所述&lt;em&gt;mainfn&lt;/em&gt;参数应具有的形式是&amp;ldquo;pkg.mod：FN&amp;rdquo;，其中&amp;ldquo;pkg.mod&amp;rdquo;是在归档中的包/模块，和&amp;ldquo;FN&amp;rdquo;是给定模块中的调用。该 &lt;code&gt;__main__.py&lt;/code&gt; 文件将执行调用。</target>
        </trans-unit>
        <trans-unit id="7ee50cf63ba8885dc61601f8b5cd0b79d178853d" translate="yes" xml:space="preserve">
          <source>Write a byte string to the socket, doubling any IAC characters. This can block if the connection is blocked. May raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if the connection is closed.</source>
          <target state="translated">将字节字符串写入套接字，将所有IAC字符加倍。如果连接被阻止，则可能会阻止。如果关闭连接，可能会引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11050f94833bd03482233f6f4a212266c002bd4d" translate="yes" xml:space="preserve">
          <source>Write a file into the archive. The contents is &lt;em&gt;data&lt;/em&gt;, which may be either a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; instance; if it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, it is encoded as UTF-8 first. &lt;em&gt;zinfo_or_arcname&lt;/em&gt; is either the file name it will be given in the archive, or a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance. If it&amp;rsquo;s an instance, at least the filename, date, and time must be given. If it&amp;rsquo;s a name, the date and time is set to the current date and time. The archive must be opened with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">将文件写入存档。内容是&lt;em&gt;data&lt;/em&gt;，可以是&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;实例；如果是&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;，则首先将其编码为UTF-8。&lt;em&gt;zinfo_or_arcname&lt;/em&gt;是将在归档文件中给出的文件名，或者是&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;实例。如果是实例，则至少必须提供文件名，日期和时间。如果是名称，则将日期和时间设置为当前日期和时间。必须以 &lt;code&gt;'w'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'a'&lt;/code&gt; 模式打开档案。</target>
        </trans-unit>
        <trans-unit id="f3eb00f495508e3700c4ba0640bfacc98b0501ae" translate="yes" xml:space="preserve">
          <source>Write a list (or any iterable) of data bytes to the transport. This is functionally equivalent to calling &lt;a href=&quot;#asyncio.WriteTransport.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; on each element yielded by the iterable, but may be implemented more efficiently.</source>
          <target state="translated">将数据字节列表（或任何可迭代的字节）写入传输。从功能上讲，这等效于对可迭代对象产生的每个元素调用&lt;a href=&quot;#asyncio.WriteTransport.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;，但可以更高效地实现。</target>
        </trans-unit>
        <trans-unit id="c7437d7098997ca3f0b36ac87a6783125bd334ba" translate="yes" xml:space="preserve">
          <source>Write a list of lines to the stream. Line separators are not added, so it is usual for each of the lines provided to have a line separator at the end.</source>
          <target state="translated">向流中写入一个行的列表。不添加行的分隔符,所以通常在提供的每一行的末尾都有一个行的分隔符。</target>
        </trans-unit>
        <trans-unit id="37e2299e025bd71effd4f4c8ea111a73efc09766" translate="yes" xml:space="preserve">
          <source>Write a prompt and read a line. The returned line does not include the trailing newline. When the user enters the EOF key sequence, &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; is raised. The base implementation reads from &lt;code&gt;sys.stdin&lt;/code&gt;; a subclass may replace this with a different implementation.</source>
          <target state="translated">编写提示并阅读一行。返回的行不包含结尾的换行符。当用户输入EOF键序列时，将&lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt;。基本实现从 &lt;code&gt;sys.stdin&lt;/code&gt; 中读取；子类可以用其他实现代替它。</target>
        </trans-unit>
        <trans-unit id="19f447e1ee94708098c72a4348432a023a0a8cf9" translate="yes" xml:space="preserve">
          <source>Write a representation of the configuration to the specified &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which must be opened in text mode (accepting strings). This representation can be parsed by a future &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; call. If &lt;em&gt;space_around_delimiters&lt;/em&gt; is true, delimiters between keys and values are surrounded by spaces.</source>
          <target state="translated">将配置的表示形式写入指定的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;，该对象必须以文本模式（接受字符串）打开。可以通过将来的&lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;调用来解析此表示形式。如果&lt;em&gt;space_around_delimiters&lt;/em&gt;为true，则键和值之间的定界符将被空格包围。</target>
        </trans-unit>
        <trans-unit id="0eef9c11e095a7379d1c8f9b621d22452c461848" translate="yes" xml:space="preserve">
          <source>Write a representation of the configuration to the specified &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which must be opened in text mode (accepting strings). This representation can be parsed by a future &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; call. If &lt;em&gt;space_around_delimiters&lt;/em&gt; is true, delimiters between keys and values are surrounded by spaces.</source>
          <target state="translated">将配置的表示形式写入指定的&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;，该对象必须以文本模式（接受字符串）打开。可以通过将来的&lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;调用来解析此表示形式。如果&lt;em&gt;space_around_delimiters&lt;/em&gt;为true，则键和值之间的定界符将被空格包围。</target>
        </trans-unit>
        <trans-unit id="44f425021d217395cd90bd3e1c685d406345abef" translate="yes" xml:space="preserve">
          <source>Write a row with the field names (as specified in the constructor) to the writer&amp;rsquo;s file object, formatted according to the current dialect. Return the return value of the &lt;a href=&quot;#csv.csvwriter.writerow&quot;&gt;&lt;code&gt;csvwriter.writerow()&lt;/code&gt;&lt;/a&gt; call used internally.</source>
          <target state="translated">将具有字段名称（在构造函数中指定）的行写入编写者的文件对象，并根据当前方言格式化。返回内部使用的&lt;a href=&quot;#csv.csvwriter.writerow&quot;&gt; &lt;code&gt;csvwriter.writerow()&lt;/code&gt; &lt;/a&gt;调用的返回值。</target>
        </trans-unit>
        <trans-unit id="3de22fd70b48f7f02d64b21199c74c551c5a4056" translate="yes" xml:space="preserve">
          <source>Write a string to the standard error stream (&lt;code&gt;sys.stderr&lt;/code&gt;). Derived classes should override this to provide the appropriate output handling as needed.</source>
          <target state="translated">将字符串写入标准错误流（ &lt;code&gt;sys.stderr&lt;/code&gt; ）。派生类应重写此方法，以根据需要提供适当的输出处理。</target>
        </trans-unit>
        <trans-unit id="d612d16d0cf266e7ebef3c7987599b4fd184d79d" translate="yes" xml:space="preserve">
          <source>Write a warning to a file. The default implementation calls &lt;code&gt;formatwarning(message, category, filename, lineno, line)&lt;/code&gt; and writes the resulting string to &lt;em&gt;file&lt;/em&gt;, which defaults to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;. You may replace this function with any callable by assigning to &lt;code&gt;warnings.showwarning&lt;/code&gt;. &lt;em&gt;line&lt;/em&gt; is a line of source code to be included in the warning message; if &lt;em&gt;line&lt;/em&gt; is not supplied, &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt; will try to read the line specified by &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;lineno&lt;/em&gt;.</source>
          <target state="translated">向文件写警告。默认实现调用 &lt;code&gt;formatwarning(message, category, filename, lineno, line)&lt;/code&gt; ，并将结果字符串写入&lt;em&gt;file&lt;/em&gt;，默认为&lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;。您可以通过分配给 &lt;code&gt;warnings.showwarning&lt;/code&gt; 将该函数替换为任何可调用的函数。&lt;em&gt;line&lt;/em&gt;是警告消息中包含的源代码行；如果未提供&lt;em&gt;line&lt;/em&gt;，则&lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt;将尝试读取&lt;em&gt;filename&lt;/em&gt;和&lt;em&gt;lineno&lt;/em&gt;指定的行。</target>
        </trans-unit>
        <trans-unit id="bb845fd32652cc2e4f58bebbf5d18bb847fd06c2" translate="yes" xml:space="preserve">
          <source>Write all data associated with the window into the provided file object. This information can be later retrieved using the &lt;a href=&quot;#curses.getwin&quot;&gt;&lt;code&gt;getwin()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">将与窗口关联的所有数据写入提供的文件对象。以后可以使用&lt;a href=&quot;#curses.getwin&quot;&gt; &lt;code&gt;getwin()&lt;/code&gt; &lt;/a&gt;函数检索此信息。</target>
        </trans-unit>
        <trans-unit id="81abe8375bf8942cde0da27f3d6c849d0068cc77" translate="yes" xml:space="preserve">
          <source>Write all elements in &lt;em&gt;rows&lt;/em&gt; (an iterable of &lt;em&gt;row&lt;/em&gt; objects as described above) to the writer&amp;rsquo;s file object, formatted according to the current dialect.</source>
          <target state="translated">将&lt;em&gt;行中的&lt;/em&gt;所有元素（如上所述，&lt;em&gt;行&lt;/em&gt;对象可迭代）写入编写者的文件对象，并根据当前方言格式化。</target>
        </trans-unit>
        <trans-unit id="fc9ceb61920372f0588b9d7561124c54016a1122" translate="yes" xml:space="preserve">
          <source>Write all items (as machine values) to the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">将所有项目（作为机器值）写入&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d0c36c3ce32990a4354e9f9b514a715f25ec2591" translate="yes" xml:space="preserve">
          <source>Write all items (as machine values) to the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">将所有项目（作为机器值）写入&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f81f2599a0df03842e1b569bdbf1ec30324a18f4" translate="yes" xml:space="preserve">
          <source>Write an EOF marker to the memory BIO. After this method has been called, it is illegal to call &lt;a href=&quot;#ssl.MemoryBIO.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;. The attribute &lt;a href=&quot;#ssl.MemoryBIO.eof&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; will become true after all data currently in the buffer has been read.</source>
          <target state="translated">将EOF标记写入内存BIO。调用此方法后，调用&lt;a href=&quot;#ssl.MemoryBIO.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;是非法的。读取缓冲区中当前的所有数据后，属性&lt;a href=&quot;#ssl.MemoryBIO.eof&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;将变为true。</target>
        </trans-unit>
        <trans-unit id="fd0862fa068194298c775ee76e1f456320747a5a" translate="yes" xml:space="preserve">
          <source>Write any pending changes to the filesystem. For some &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; subclasses, changes are always written immediately and &lt;a href=&quot;#mailbox.Mailbox.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; does nothing, but you should still make a habit of calling this method.</source>
          <target state="translated">将所有挂起的更改写入文件系统。对于某些&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt;子类，更改总是立即写入，并且&lt;a href=&quot;#mailbox.Mailbox.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt;不会执行任何操作，但是您仍然应该习惯于调用此方法。</target>
        </trans-unit>
        <trans-unit id="5a1297c30d5d72fb62f06bfd02306776bc567c17" translate="yes" xml:space="preserve">
          <source>Write audio frames and make sure &lt;em&gt;nframes&lt;/em&gt; is correct. It will raise an error if the output stream is not seekable and the total number of frames that have been written after &lt;em&gt;data&lt;/em&gt; has been written does not match the previously set value for &lt;em&gt;nframes&lt;/em&gt;.</source>
          <target state="translated">编写音频帧，并确保&lt;em&gt;nframe&lt;/em&gt;正确。如果输出流不可搜索，并且在写入&lt;em&gt;数据&lt;/em&gt;后已写入的帧总数与&lt;em&gt;nframe&lt;/em&gt;的先前设置值不匹配，&lt;em&gt;则会产生错误&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6374207475d74b69e79e3c97cb15756f85e6eecd" translate="yes" xml:space="preserve">
          <source>Write audio frames, without correcting &lt;em&gt;nframes&lt;/em&gt;.</source>
          <target state="translated">编写音频帧，而不校正&lt;em&gt;nframe&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="10d10592df13916c769fed5ce2f6051eab11d892" translate="yes" xml:space="preserve">
          <source>Write back all entries in the cache if the shelf was opened with &lt;em&gt;writeback&lt;/em&gt; set to &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;. Also empty the cache and synchronize the persistent dictionary on disk, if feasible. This is called automatically when the shelf is closed with &lt;a href=&quot;#shelve.Shelf.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在&lt;em&gt;写回&lt;/em&gt;设置为&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 的情况&lt;/a&gt;下打开了架子，则&lt;em&gt;写回&lt;/em&gt;缓存中的所有条目。如果可行，还清空缓存并同步磁盘上的持久字典。当使用&lt;a href=&quot;#shelve.Shelf.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;关闭书架时，将自动调用此方法。</target>
        </trans-unit>
        <trans-unit id="bfb4b78e519e7550928b490acec5cdf38eb80432" translate="yes" xml:space="preserve">
          <source>Write buffers to the transport.</source>
          <target state="translated">向运输工具写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="ef28f2b25c05e4ce563406a1aa0120af14871caf" translate="yes" xml:space="preserve">
          <source>Write coverage results. Set &lt;em&gt;show_missing&lt;/em&gt; to show lines that had no hits. Set &lt;em&gt;summary&lt;/em&gt; to include in the output the coverage summary per module. &lt;em&gt;coverdir&lt;/em&gt; specifies the directory into which the coverage result files will be output. If &lt;code&gt;None&lt;/code&gt;, the results for each source file are placed in its directory.</source>
          <target state="translated">写覆盖结果。设置&lt;em&gt;show_missing&lt;/em&gt;以显示没有命中的行。设置&lt;em&gt;摘要&lt;/em&gt;以在输出中包括每个模块的覆盖范围摘要。&lt;em&gt;Coverdir&lt;/em&gt;指定将覆盖结果文件输出到的目录。如果为 &lt;code&gt;None&lt;/code&gt; ，则将每个源文件的结果放置在其目录中。</target>
        </trans-unit>
        <trans-unit id="de823fe8fae6707bcca7ae9d265deafd25388197" translate="yes" xml:space="preserve">
          <source>Write data to the output file. This method can only be called after the audio file parameters have been set.</source>
          <target state="translated">向输出文件写入数据。本方法只能在设置了音频文件参数后调用。</target>
        </trans-unit>
        <trans-unit id="7e0192353108eeff55932692ba801f256905196f" translate="yes" xml:space="preserve">
          <source>Write data to the transport.</source>
          <target state="translated">将数据写入传输系统。</target>
        </trans-unit>
        <trans-unit id="b37ba65d2a4a6d647d50783ee4565efe21874280" translate="yes" xml:space="preserve">
          <source>Write only mode.</source>
          <target state="translated">只写模式。</target>
        </trans-unit>
        <trans-unit id="de43cb842768a7bf97800356094a1d534b6900c6" translate="yes" xml:space="preserve">
          <source>Write some &lt;em&gt;data&lt;/em&gt; bytes to the transport.</source>
          <target state="translated">向传输中写入一些&lt;em&gt;数据&lt;/em&gt;字节。</target>
        </trans-unit>
        <trans-unit id="871c8f9286c953dd029dbbaeca8bcb6b99962da0" translate="yes" xml:space="preserve">
          <source>Write text - the string representation of &lt;em&gt;arg&lt;/em&gt; - at the current turtle position according to &lt;em&gt;align&lt;/em&gt; (&amp;ldquo;left&amp;rdquo;, &amp;ldquo;center&amp;rdquo; or right&amp;rdquo;) and with the given font. If &lt;em&gt;move&lt;/em&gt; is true, the pen is moved to the bottom-right corner of the text. By default, &lt;em&gt;move&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">根据&lt;em&gt;对齐&lt;/em&gt;（&amp;ldquo;左&amp;rdquo;，&amp;ldquo;中心&amp;rdquo;或&amp;ldquo;右&amp;rdquo;）并使用给定的字体在当前乌龟位置写文本&lt;em&gt;-arg&lt;/em&gt;的字符串表示形式。如果&lt;em&gt;move&lt;/em&gt;为true，则笔将移动到文本的右下角。默认情况下，&lt;em&gt;move&lt;/em&gt;为 &lt;code&gt;False&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3378a681ace2c9c5d6e0cd6c28d0e5dc9a0608f5" translate="yes" xml:space="preserve">
          <source>Write text files containing test cases as interactive examples, and test the files using &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt;&lt;code&gt;DocFileSuite()&lt;/code&gt;&lt;/a&gt;. This is recommended, although is easiest to do for new projects, designed from the start to use doctest.</source>
          <target state="translated">编写包含测试用例的文本文件作为交互式示例，并使用&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#doctest.DocFileSuite&quot;&gt; &lt;code&gt;DocFileSuite()&lt;/code&gt; &lt;/a&gt;测试文件。尽管从一开始就使用doctest设计新项目，这是最容易做到的，但建议这样做。</target>
        </trans-unit>
        <trans-unit id="c49bb785234b8ca3d65e01ef187d421d2ad64c53" translate="yes" xml:space="preserve">
          <source>Write the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written. When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the buffer needs to be written out but the raw stream blocks.</source>
          <target state="translated">写&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;字节状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，并返回写入的字节数。在非阻塞模式下，如果需要写出缓冲区但原始流&lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt;则会引发BlockingIOError。</target>
        </trans-unit>
        <trans-unit id="e7c7d79640aa2b1f9a0829b07201eaf51d80f7b0" translate="yes" xml:space="preserve">
          <source>Write the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written. When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the buffer needs to be written out but the raw stream blocks.</source>
          <target state="translated">写&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;字节状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，并返回写入的字节数。在非阻塞模式下，如果需要写出缓冲区但原始流&lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt;则会引发BlockingIOError。</target>
        </trans-unit>
        <trans-unit id="80c87e056df756962ad8a4e0b3ed6dfcb114b2df" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;buffers&lt;/em&gt; contents to file descriptor &lt;em&gt;fd&lt;/em&gt; at a offset &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">将&lt;em&gt;缓冲区&lt;/em&gt;内容以偏移&lt;em&gt;量&lt;/em&gt;偏移&lt;em&gt;量&lt;/em&gt;写入文件描述符&lt;em&gt;fd&lt;/em&gt;，而文件偏移量保持不变。&lt;em&gt;缓冲区&lt;/em&gt;必须是一系列&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。缓冲区以数组顺序处理。在继续第二个缓冲区之前，先写入第一个缓冲区的全部内容，依此类推。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7cac7e50579b40392dcb2dcea2d2c807901f780c" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;buffers&lt;/em&gt; contents to file descriptor &lt;em&gt;fd&lt;/em&gt; at a offset &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">将&lt;em&gt;缓冲区&lt;/em&gt;内容以偏移&lt;em&gt;量&lt;/em&gt;偏移&lt;em&gt;量&lt;/em&gt;写入文件描述符&lt;em&gt;fd&lt;/em&gt;，而文件偏移量保持不变。&lt;em&gt;缓冲区&lt;/em&gt;必须是一系列&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。缓冲区以数组顺序处理。在进入第二个缓冲区之前，先写入第一个缓冲区的全部内容，依此类推。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b68098901631691c20ac4c25cf82febd1b870a65" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;row&lt;/em&gt; parameter to the writer&amp;rsquo;s file object, formatted according to the current dialect. Return the return value of the call to the &lt;em&gt;write&lt;/em&gt; method of the underlying file object.</source>
          <target state="translated">将&lt;em&gt;行&lt;/em&gt;参数写入编写者的文件对象，并根据当前方言格式化。将调用的返回值返回到基础文件对象的&lt;em&gt;write&lt;/em&gt;方法。</target>
        </trans-unit>
        <trans-unit id="73ec3e1f52340e46c299e8d695880b094a6fd996" translate="yes" xml:space="preserve">
          <source>Write the XML-RPC base 64 encoding of this binary item to the &lt;em&gt;out&lt;/em&gt; stream object.</source>
          <target state="translated">写这个二进制信息的XML-RPC基64编码的&lt;em&gt;出&lt;/em&gt;流对象。</target>
        </trans-unit>
        <trans-unit id="09605d772916211b4f273ac78b4abb90e0284a69" translate="yes" xml:space="preserve">
          <source>Write the XML-RPC encoding of this &lt;a href=&quot;#xmlrpc.client.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; item to the &lt;em&gt;out&lt;/em&gt; stream object.</source>
          <target state="translated">写这篇文章的XML-RPC编码&lt;a href=&quot;#xmlrpc.client.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;项目的&lt;em&gt;出&lt;/em&gt;流对象。</target>
        </trans-unit>
        <trans-unit id="bef2916cd925d9f570653604eed88e3d7738b49e" translate="yes" xml:space="preserve">
          <source>Write the byte-code files to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">将字节代码文件写入其原有位置和名称，这可能会覆盖由另一个版本的Python创建的字节代码文件。默认设置是将文件写入其&lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147的&lt;/strong&gt;&lt;/a&gt;位置和名称，这允许来自多个Python版本的字节代码文件共存。</target>
        </trans-unit>
        <trans-unit id="0cdd677e07f573fdbc799f5165e8f7ed05952f7f" translate="yes" xml:space="preserve">
          <source>Write the bytes from &lt;em&gt;buf&lt;/em&gt; to the memory BIO. The &lt;em&gt;buf&lt;/em&gt; argument must be an object supporting the buffer protocol.</source>
          <target state="translated">将&lt;em&gt;buf中&lt;/em&gt;的字节写入内存BIO。所述&lt;em&gt;的buf&lt;/em&gt;参数必须是支持缓冲协议的对象。</target>
        </trans-unit>
        <trans-unit id="f3354e519dec860fd5b4513b4f703e6282b70945" translate="yes" xml:space="preserve">
          <source>Write the bytes in &lt;em&gt;bytes&lt;/em&gt; into memory at the current position of the file pointer and return the number of bytes written (never less than &lt;code&gt;len(bytes)&lt;/code&gt;, since if the write fails, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised). The file position is updated to point after the bytes that were written. If the mmap was created with &lt;code&gt;ACCESS_READ&lt;/code&gt;, then writing to it will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">将字节（以&lt;em&gt;字节&lt;/em&gt;为单位）写入文件指针当前位置的内存中，并返回已写入的字节数（不要小于 &lt;code&gt;len(bytes)&lt;/code&gt; ，因为如果写入失败，将引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;）。文件位置将更新为指向写入的字节之后的位置。如果mmap是使用 &lt;code&gt;ACCESS_READ&lt;/code&gt; 创建的，则对其进行写入将引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="791c39fe68f1524d71fee0a4ea28b01783eda89a" translate="yes" xml:space="preserve">
          <source>Write the bytestring in &lt;em&gt;str&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt; at position of &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged.</source>
          <target state="translated">将&lt;em&gt;str中&lt;/em&gt;的字节串写入&lt;em&gt;offset&lt;/em&gt;位置的文件描述符&lt;em&gt;fd&lt;/em&gt;，使文件offset保持不变。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5328e34fbdfb16a49801df3179dac7827d6c2c5e" translate="yes" xml:space="preserve">
          <source>Write the bytestring in &lt;em&gt;str&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;str中&lt;/em&gt;的字节串写入文件描述符&lt;em&gt;fd中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="27b94773d284ac100a9d67d6a8514f6713ad81c9" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;buffers&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">将&lt;em&gt;缓冲区&lt;/em&gt;的内容写入文件描述符&lt;em&gt;fd&lt;/em&gt;。&lt;em&gt;缓冲区&lt;/em&gt;必须是一系列&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。缓冲区以数组顺序处理。在继续第二个缓冲区之前，先写入第一个缓冲区的全部内容，依此类推。</target>
        </trans-unit>
        <trans-unit id="3b30bae590878dfc74fd0b3a60ccfd65b4215fed" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;buffers&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">将&lt;em&gt;缓冲区&lt;/em&gt;的内容写入文件描述符&lt;em&gt;fd&lt;/em&gt;。&lt;em&gt;缓冲区&lt;/em&gt;必须是一系列&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。缓冲区以数组顺序处理。在进入第二个缓冲区之前，先写入第一个缓冲区的全部内容，依此类推。</target>
        </trans-unit>
        <trans-unit id="c2efd35168142cd179ef29ca72c5ec8a98f503be" translate="yes" xml:space="preserve">
          <source>Write the file named &lt;em&gt;filename&lt;/em&gt; to the archive, giving it the archive name &lt;em&gt;arcname&lt;/em&gt; (by default, this will be the same as &lt;em&gt;filename&lt;/em&gt;, but without a drive letter and with leading path separators removed). If given, &lt;em&gt;compress_type&lt;/em&gt; overrides the value given for the &lt;em&gt;compression&lt;/em&gt; parameter to the constructor for the new entry. Similarly, &lt;em&gt;compresslevel&lt;/em&gt; will override the constructor if given. The archive must be open with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">将名为&lt;em&gt;filename&lt;/em&gt;的文件写入存档，并为其指定存档名称&lt;em&gt;arcname&lt;/em&gt;（默认情况下，该名称与&lt;em&gt;filename&lt;/em&gt;相同，但不带驱动器号，并且删除前导路径分隔符）。如果给定，&lt;em&gt;compress_type&lt;/em&gt;会将给&lt;em&gt;压缩&lt;/em&gt;参数的值覆盖给新条目的构造函数。同样，如果指定，&lt;em&gt;compresslevel&lt;/em&gt;将覆盖构造函数。归档文件必须以 &lt;code&gt;'w'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'a'&lt;/code&gt; 模式打开。</target>
        </trans-unit>
        <trans-unit id="f0122c32b529e0fe1cabeadad2b8ff8edccbce43" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written (always equal to the length of &lt;em&gt;b&lt;/em&gt; in bytes, since if the write fails an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised). Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.</source>
          <target state="translated">写所述给定&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;字节的状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，并返回写入的字节的数量（总是等于的长度&lt;em&gt;b&lt;/em&gt;以字节为单位，因为如果写入失败的&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;将提高）。取决于实际的实现方式，这些字节可以很容易地写入底层流，或者出于性能和延迟原因，可以保留在缓冲区中。</target>
        </trans-unit>
        <trans-unit id="28a6af62d0fddfdcac2699f837e4923a4e0da362" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, to the underlying raw stream, and return the number of bytes written. This can be less than the length of &lt;em&gt;b&lt;/em&gt; in bytes, depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. &lt;code&gt;None&lt;/code&gt; is returned if the raw stream is set not to block and no single byte could be readily written to it. The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">写所述给定&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;字节的状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，对基础原料流，并返回写入的字节的数目。根据底层原始流的具体情况，尤其是处于非阻塞模式时，此长度可以小于&lt;em&gt;b&lt;/em&gt;的字节长度。 &lt;code&gt;None&lt;/code&gt; 如果原始数据流被设置为不堵塞，无单字节可以容易地写入其返回。调用者可以在此方法返回之后释放&lt;em&gt;b&lt;/em&gt;或对其进行突变，因此，实现应仅在方法调用期间访问&lt;em&gt;b&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="27455b21fa23722a89a9798d0a3301fc564413fb" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written (always equal to the length of &lt;em&gt;b&lt;/em&gt; in bytes, since if the write fails an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised). Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.</source>
          <target state="translated">写所述给定&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;字节的状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，并返回写入的字节的数量（总是等于的长度&lt;em&gt;b&lt;/em&gt;以字节为单位，因为如果写入失败的&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;将提高）。取决于实际的实现方式，这些字节可以很容易地写入底层流，或者出于性能和延迟原因，可以保留在缓冲区中。</target>
        </trans-unit>
        <trans-unit id="78bb881db0e1f430d7902b668b98e8528e172885" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, to the underlying raw stream, and return the number of bytes written. This can be less than the length of &lt;em&gt;b&lt;/em&gt; in bytes, depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. &lt;code&gt;None&lt;/code&gt; is returned if the raw stream is set not to block and no single byte could be readily written to it. The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">写所述给定&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;字节的状物体&lt;/a&gt;，&lt;em&gt;b&lt;/em&gt;，对基础原料流，并返回写入的字节的数目。根据底层原始流的具体情况，尤其是处于非阻塞模式时，此长度可以小于&lt;em&gt;b&lt;/em&gt;的字节长度。 &lt;code&gt;None&lt;/code&gt; 如果原始数据流被设置为不堵塞，无单字节可以容易地写入其返回。调用者可以在此方法返回后释放&lt;em&gt;b&lt;/em&gt;或对其进行突变，因此，实现应仅在方法调用期间访问&lt;em&gt;b&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="02aca4b0c4cf6c2a7fe54cc559e99496d0c3f596" translate="yes" xml:space="preserve">
          <source>Write the integer &lt;em&gt;byte&lt;/em&gt; into memory at the current position of the file pointer; the file position is advanced by &lt;code&gt;1&lt;/code&gt;. If the mmap was created with &lt;code&gt;ACCESS_READ&lt;/code&gt;, then writing to it will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">将整数&lt;em&gt;字节&lt;/em&gt;写入文件指针当前位置的内存中；文件位置增加 &lt;code&gt;1&lt;/code&gt; 。如果mmap是使用 &lt;code&gt;ACCESS_READ&lt;/code&gt; 创建的，则对其进行写入将引发&lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="edb72d7ee339e68a0aebdb5f886ea9310729e068" translate="yes" xml:space="preserve">
          <source>Write the modified properties to the summary information stream, using &lt;code&gt;MsiSummaryInfoPersist()&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;MsiSummaryInfoPersist()&lt;/code&gt; 将修改后的属性写入摘要信息流。</target>
        </trans-unit>
        <trans-unit id="55bf2fe45536bc78a1a8caf7889193c631c34161" translate="yes" xml:space="preserve">
          <source>Write the output of the &lt;em&gt;infile&lt;/em&gt; to the given &lt;em&gt;outfile&lt;/em&gt;. Otherwise, write it to &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;em&gt;infile&lt;/em&gt;的输出写入给定的&lt;em&gt;outfile中&lt;/em&gt;。否则，将其写入&lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d838008f04fccbdbd310f0f2eda2be824679476" translate="yes" xml:space="preserve">
          <source>Write the output to a file named &lt;em&gt;output&lt;/em&gt;. If this option is not specified, the output filename will be the same as the input &lt;em&gt;source&lt;/em&gt;, with the extension &lt;code&gt;.pyz&lt;/code&gt; added. If an explicit filename is given, it is used as is (so a &lt;code&gt;.pyz&lt;/code&gt; extension should be included if required).</source>
          <target state="translated">将输出写入名为&lt;em&gt;output&lt;/em&gt;的文件中。如果未指定此选项，则输出文件名将与输入&lt;em&gt;源&lt;/em&gt;相同，并带有扩展名 &lt;code&gt;.pyz&lt;/code&gt; 。如果给出了明确的文件名， &lt;code&gt;.pyz&lt;/code&gt; 使用（因此，如果需要，应包括.pyz扩展名）。</target>
        </trans-unit>
        <trans-unit id="b82530a5087bab2d42ad0ddb90cf1ef9792a699a" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of &lt;em&gt;obj&lt;/em&gt; to the open file object given in the constructor.</source>
          <target state="translated">将&lt;em&gt;obj&lt;/em&gt;的腌制表示形式写入构造函数中提供的打开文件对象。</target>
        </trans-unit>
        <trans-unit id="2e3cb793d567a188a0b227ebd8f0b39627a11406" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of the object &lt;em&gt;obj&lt;/em&gt; to the open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;file&lt;/em&gt;. This is equivalent to &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt;.</source>
          <target state="translated">将对象&lt;em&gt;obj&lt;/em&gt;的腌制表示形式写入打开的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;&lt;em&gt;文件&lt;/em&gt;。这等效于 &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="014ee2af4e701fcab5e779636a1bab6243c960b6" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of the object &lt;em&gt;obj&lt;/em&gt; to the open &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;file&lt;/em&gt;. This is equivalent to &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt;.</source>
          <target state="translated">将对象&lt;em&gt;obj&lt;/em&gt;的腌制表示形式写入打开的&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;&lt;em&gt;文件&lt;/em&gt;。这等效于 &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d26b0a11db95123185fa367e58a8b7362b3ed079" translate="yes" xml:space="preserve">
          <source>Write the results of the current profile to &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">将当前配置&lt;em&gt;文件&lt;/em&gt;的结果写入&lt;em&gt;filename&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5fb7530657763f9875f7b1f976e2ce7f011577e9" translate="yes" xml:space="preserve">
          <source>Write the snapshot into a file.</source>
          <target state="translated">将快照写成文件。</target>
        </trans-unit>
        <trans-unit id="85d258d2fb226ec2c0c709a20107d7d1cd49dda7" translate="yes" xml:space="preserve">
          <source>Write the string &lt;em&gt;s&lt;/em&gt; to the stream and return the number of characters written.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;写入流并返回写入的字符数。</target>
        </trans-unit>
        <trans-unit id="a1f9fa39199b8be1519faca0bdbf541e2e1411a7" translate="yes" xml:space="preserve">
          <source>Write the value on the open file. The value must be a supported type. The file must be a writeable &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;binary file&lt;/a&gt;.</source>
          <target state="translated">将值写在打开的文件上。该值必须是受支持的类型。该文件必须是可写的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;二进制文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c7340eaff729a0a7bab0ac8f74a10c0b4a0bbbe" translate="yes" xml:space="preserve">
          <source>Write the value on the open file. The value must be a supported type. The file must be a writeable &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-binary-file&quot;&gt;binary file&lt;/a&gt;.</source>
          <target state="translated">将值写在打开的文件上。该值必须是受支持的类型。该文件必须是可写的&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-binary-file&quot;&gt;二进制文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f0ad1cd3dd03f0a6c9c662064a29f7888fb5ccf" translate="yes" xml:space="preserve">
          <source>Write-only Transports</source>
          <target state="translated">只写运输</target>
        </trans-unit>
        <trans-unit id="335cbd7aaa63f61606a8ce6bfa9ddbc970e54241" translate="yes" xml:space="preserve">
          <source>Writer Objects</source>
          <target state="translated">编写对象</target>
        </trans-unit>
        <trans-unit id="4d0bf7b553d43cfdd760c33cc20420dd919b351d" translate="yes" xml:space="preserve">
          <source>Writer objects have the following public attribute:</source>
          <target state="translated">Writer对象有以下公共属性。</target>
        </trans-unit>
        <trans-unit id="35eda2b27bf2882a31d059cb23f01e9439d450de" translate="yes" xml:space="preserve">
          <source>Writes a sentinel to the queue to tell the listener to quit. This implementation uses &lt;code&gt;put_nowait()&lt;/code&gt;. You may want to override this method if you want to use timeouts or work with custom queue implementations.</source>
          <target state="translated">将标记写入队列以告知侦听器退出。此实现使用 &lt;code&gt;put_nowait()&lt;/code&gt; 。如果要使用超时或使用自定义队列实现，则可能要覆盖此方法。</target>
        </trans-unit>
        <trans-unit id="17739c26273b3c54186e1d431020da69cfc1db41" translate="yes" xml:space="preserve">
          <source>Writes all the attributes of a key to the registry.</source>
          <target state="translated">将键的所有属性写入注册表。</target>
        </trans-unit>
        <trans-unit id="e658a7fb3a51b39345e62d94dba9025da173bea3" translate="yes" xml:space="preserve">
          <source>Writes an element tree or element structure to sys.stdout. This function should be used for debugging only.</source>
          <target state="translated">将元素树或元素结构写入sys.stdout。这个函数只能用于调试。</target>
        </trans-unit>
        <trans-unit id="c80c0741f41bf444cf6674603a6956344dc09d2c" translate="yes" xml:space="preserve">
          <source>Writes the concatenated list of strings to the stream (possibly by reusing the &lt;a href=&quot;#codecs.StreamWriter.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method). The standard bytes-to-bytes codecs do not support this method.</source>
          <target state="translated">将字符串的串联列表写入流中（可能通过重用&lt;a href=&quot;#codecs.StreamWriter.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;方法）。标准的逐字节编解码器不支持此方法。</target>
        </trans-unit>
        <trans-unit id="5380803f5da36b35d28343f1d050c78f6fcd7c0d" translate="yes" xml:space="preserve">
          <source>Writes the element tree to a file, as XML. &lt;em&gt;file&lt;/em&gt; is a file name, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for writing. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; controls if an XML declaration should be added to the file. Use &lt;code&gt;False&lt;/code&gt; for never, &lt;code&gt;True&lt;/code&gt; for always, &lt;code&gt;None&lt;/code&gt; for only if not US-ASCII or UTF-8 or Unicode (default is &lt;code&gt;None&lt;/code&gt;). &lt;em&gt;default_namespace&lt;/em&gt; sets the default XML namespace (for &amp;ldquo;xmlns&amp;rdquo;). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). The keyword-only &lt;em&gt;short_empty_elements&lt;/em&gt; parameter controls the formatting of elements that contain no content. If &lt;code&gt;True&lt;/code&gt; (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags.</source>
          <target state="translated">将元素树作为XML写入文件。&lt;em&gt;file&lt;/em&gt;是文件名或为写入而打开的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;。&lt;em&gt;编码&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt;是输出编码（默认为US-ASCII）。&lt;em&gt;xml_declaration&lt;/em&gt;控制是否应将XML声明添加到文件中。使用 &lt;code&gt;False&lt;/code&gt; 的永远， &lt;code&gt;True&lt;/code&gt; 为始终， &lt;code&gt;None&lt;/code&gt; 仅供如果不是US-ASCII或UTF-8或Unicode（默认为 &lt;code&gt;None&lt;/code&gt; ）。&lt;em&gt;default_namespace&lt;/em&gt;设置默认的XML名称空间（用于&amp;ldquo; xmlns&amp;rdquo;）。&lt;em&gt;方法&lt;/em&gt;为 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ， &lt;code&gt;&quot;html&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;text&quot;&lt;/code&gt; （默认为 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ）。仅关键字&lt;em&gt;short_empty_elements&lt;/em&gt;参数控制不包含任何内容的元素的格式。如果为 &lt;code&gt;True&lt;/code&gt; （默认值），则将它们作为单个自闭标签发出，否则将作为一对开始/结束标签发出。</target>
        </trans-unit>
        <trans-unit id="fc5eb318d92101439c44d64e484a16b9153e0a31" translate="yes" xml:space="preserve">
          <source>Writes the element tree to a file, as XML. &lt;em&gt;file&lt;/em&gt; is a file name, or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for writing. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; controls if an XML declaration should be added to the file. Use &lt;code&gt;False&lt;/code&gt; for never, &lt;code&gt;True&lt;/code&gt; for always, &lt;code&gt;None&lt;/code&gt; for only if not US-ASCII or UTF-8 or Unicode (default is &lt;code&gt;None&lt;/code&gt;). &lt;em&gt;default_namespace&lt;/em&gt; sets the default XML namespace (for &amp;ldquo;xmlns&amp;rdquo;). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). The keyword-only &lt;em&gt;short_empty_elements&lt;/em&gt; parameter controls the formatting of elements that contain no content. If &lt;code&gt;True&lt;/code&gt; (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags.</source>
          <target state="translated">将元素树作为XML写入文件。&lt;em&gt;file&lt;/em&gt;是文件名或为写入而打开的&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;。&lt;em&gt;编码&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt;是输出编码（默认为US-ASCII）。&lt;em&gt;xml_declaration&lt;/em&gt;控制是否应将XML声明添加到文件中。使用 &lt;code&gt;False&lt;/code&gt; 的永远， &lt;code&gt;True&lt;/code&gt; 为始终， &lt;code&gt;None&lt;/code&gt; 仅供如果不是US-ASCII或UTF-8或Unicode（默认为 &lt;code&gt;None&lt;/code&gt; ）。&lt;em&gt;default_namespace&lt;/em&gt;设置默认的XML名称空间（用于&amp;ldquo; xmlns&amp;rdquo;）。&lt;em&gt;方法&lt;/em&gt;是 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ， &lt;code&gt;&quot;html&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;text&quot;&lt;/code&gt; （默认为 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ）。仅关键字&lt;em&gt;short_empty_elements&lt;/em&gt;参数控制不包含任何内容的元素的格式。如果为 &lt;code&gt;True&lt;/code&gt; （默认值），则将它们作为单个自闭标签发出，否则将作为一对开始/结束标签发出。</target>
        </trans-unit>
        <trans-unit id="25a8fba70140127a17356ef143684300827e20e9" translate="yes" xml:space="preserve">
          <source>Writes the object&amp;rsquo;s contents encoded to the stream.</source>
          <target state="translated">将编码后的对象的内容写入流中。</target>
        </trans-unit>
        <trans-unit id="cae18decb80c060b17ef47ce0c96553cc5c6d777" translate="yes" xml:space="preserve">
          <source>Writing PyUnit regression tests.</source>
          <target state="translated">编写PyUnit回归测试。</target>
        </trans-unit>
        <trans-unit id="25cc1ad64131bcda2eb3e49d5f401de5ae0fa111" translate="yes" xml:space="preserve">
          <source>Writing Unit Tests for the &lt;code&gt;test&lt;/code&gt; package</source>
          <target state="translated">为 &lt;code&gt;test&lt;/code&gt; 包编写单元测试</target>
        </trans-unit>
        <trans-unit id="66d735f0726a922d346407641bd5cf2708118ab7" translate="yes" xml:space="preserve">
          <source>Writing Unit Tests for the test package</source>
          <target state="translated">为测试包编写单元测试</target>
        </trans-unit>
        <trans-unit id="6623bd8fdf17715345d6e193b4a938d36d3a8912" translate="yes" xml:space="preserve">
          <source>Writing a Tokenizer</source>
          <target state="translated">编写一个记号器</target>
        </trans-unit>
        <trans-unit id="a7970cd648ac7bccb04089bb24dad00d62fe7de4" translate="yes" xml:space="preserve">
          <source>Writing an adapter lets you send custom Python types to SQLite. But to make it really useful we need to make the Python to SQLite to Python roundtrip work.</source>
          <target state="translated">编写一个适配器可以让你把自定义的Python类型发送到SQLite。但是为了让它真正有用,我们需要让Python到SQLite到Python的往返工作。</target>
        </trans-unit>
        <trans-unit id="8dcb129b81a9b97ee4f1424a1e0fb697ea634d2f" translate="yes" xml:space="preserve">
          <source>Writing and reading a bzip2-compressed file in binary mode:</source>
          <target state="translated">以二进制模式写入和读取bzip2压缩文件。</target>
        </trans-unit>
        <trans-unit id="90d1fb7894a11f529f52cf8ecb5d9976ceef53b1" translate="yes" xml:space="preserve">
          <source>Writing compressed data to an already-open file:</source>
          <target state="translated">将压缩数据写入一个已经打开的文件。</target>
        </trans-unit>
        <trans-unit id="423fd842912e5704c1495f92cbf775b3b301aaec" translate="yes" xml:space="preserve">
          <source>Writing outside the window, subwindow, or pad raises &lt;a href=&quot;#curses.error&quot;&gt;&lt;code&gt;curses.error&lt;/code&gt;&lt;/a&gt;. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the string is printed.</source>
          <target state="translated">在窗口，子窗口或&lt;a href=&quot;#curses.error&quot;&gt; &lt;code&gt;curses.error&lt;/code&gt; &lt;/a&gt;书写会引发curses.error。尝试在窗口，子窗口或填充区的右下角进行写入将导致在打印字符串后引发异常。</target>
        </trans-unit>
        <trans-unit id="66b0caed981253d594af909c645888be42302ac7" translate="yes" xml:space="preserve">
          <source>Writing outside the window, subwindow, or pad raises a &lt;a href=&quot;#curses.error&quot;&gt;&lt;code&gt;curses.error&lt;/code&gt;&lt;/a&gt;. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the character is printed.</source>
          <target state="translated">在窗口，子窗口或&lt;a href=&quot;#curses.error&quot;&gt; &lt;code&gt;curses.error&lt;/code&gt; &lt;/a&gt;纸外书写会引发curses.error。尝试在窗口，子窗口或填充区的右下角进行写入将导致在打印字符后引发异常。</target>
        </trans-unit>
        <trans-unit id="463175f0030d6c5bc93c5ba14c4b34f90a466ed2" translate="yes" xml:space="preserve">
          <source>Written by James C. Ahlstrom, who also provided an implementation. Python 2.3 follows the specification in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0273&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 273&lt;/strong&gt;&lt;/a&gt;, but uses an implementation written by Just van Rossum that uses the import hooks described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">由James C. Ahlstrom撰写，他也提供了一个实现。Python 2.3遵循&lt;a href=&quot;https://www.python.org/dev/peps/pep-0273&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 273中&lt;/strong&gt;&lt;/a&gt;的规范，但是使用Just van Rossum编写的实现，该实现使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302中&lt;/strong&gt;&lt;/a&gt;描述的导入挂钩。</target>
        </trans-unit>
        <trans-unit id="270c60956bc9c23c8fe9a0b4bac1ed97cf2f4291" translate="yes" xml:space="preserve">
          <source>X Bitmap Files</source>
          <target state="translated">X位图文件</target>
        </trans-unit>
        <trans-unit id="df2e2736374ccada1de5c3b7c05f3612bbc80534" translate="yes" xml:space="preserve">
          <source>XInclude support</source>
          <target state="translated">X包括支持</target>
        </trans-unit>
        <trans-unit id="1ad96390f6242f3cec13bdeae582a19d9407d608" translate="yes" xml:space="preserve">
          <source>XML Processing Modules</source>
          <target state="translated">XML处理模块</target>
        </trans-unit>
        <trans-unit id="4c7f7159a8411bf46c36150c878849d3426e4995" translate="yes" xml:space="preserve">
          <source>XML data for the &lt;a href=&quot;#plistlib.FMT_XML&quot;&gt;&lt;code&gt;FMT_XML&lt;/code&gt;&lt;/a&gt; format is parsed using the Expat parser from &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; &amp;ndash; see its documentation for possible exceptions on ill-formed XML. Unknown elements will simply be ignored by the plist parser.</source>
          <target state="translated">使用来自&lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt;的Expat解析器解析&lt;a href=&quot;#plistlib.FMT_XML&quot;&gt; &lt;code&gt;FMT_XML&lt;/code&gt; &lt;/a&gt;格式的XML数据&amp;ndash;有关格式错误的XML的可能异常，请参阅其文档。plist解析器将忽略未知的元素。</target>
        </trans-unit>
        <trans-unit id="eb4e1a90d8df93786f8530be82d70f96c907403f" translate="yes" xml:space="preserve">
          <source>XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. &lt;code&gt;ET&lt;/code&gt; has two classes for this purpose - &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; represents the whole XML document as a tree, and &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; level. Interactions with a single XML element and its sub-elements are done on the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">XML是一种固有的分层数据格式，最自然的表示方法是使用树。 &lt;code&gt;ET&lt;/code&gt; 为此有两个类&lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; &lt;/a&gt;将整个XML文档表示为一棵树，而&lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt;表示此树中的单个节点。与整个文档的交互（读写文件）通常在&lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; &lt;/a&gt;级别上进行。与单个XML元素及其子元素的交互在&lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt;级别完成。</target>
        </trans-unit>
        <trans-unit id="9924906708da9844dcf966582660a824d07419a9" translate="yes" xml:space="preserve">
          <source>XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available:</source>
          <target state="translated">XML解析错误,由本模块中的各种解析方法在解析失败时引发。这个异常实例的字符串表示将包含一个用户友好的错误信息。此外,它还会有以下属性可用。</target>
        </trans-unit>
        <trans-unit id="096332ac995cd54246f20718b546ac8586de4200" translate="yes" xml:space="preserve">
          <source>XML tree and elements</source>
          <target state="translated">XML树和元素</target>
        </trans-unit>
        <trans-unit id="d10f7ada917a0516264a166e94fe43f43a7f141e" translate="yes" xml:space="preserve">
          <source>XML vulnerabilities</source>
          <target state="translated">XML漏洞</target>
        </trans-unit>
        <trans-unit id="c5d50f18d7b7a0ea894fe5f24aec3e7baf72508e" translate="yes" xml:space="preserve">
          <source>XML-RPC HOWTO</source>
          <target state="translated">XML-RPC HOWTO</target>
        </trans-unit>
        <trans-unit id="5ecaf07183071066578274e8760e0bea165e82a4" translate="yes" xml:space="preserve">
          <source>XML-RPC Introspection</source>
          <target state="translated">XML-RPC自省</target>
        </trans-unit>
        <trans-unit id="e68fd76cd84fb2c95d9fbb40006ec3cb311e1bc2" translate="yes" xml:space="preserve">
          <source>XML-RPC Specification</source>
          <target state="translated">XML-RPC规范</target>
        </trans-unit>
        <trans-unit id="2e48b9fbebc39ff8c9f81e1b9bc7ae35dc6312d6" translate="yes" xml:space="preserve">
          <source>XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP as a transport. With it, a client can call methods with parameters on a remote server (the server is named by a URI) and get back structured data.</source>
          <target state="translated">XML-RPC是一种远程过程调用方法,它使用通过HTTP传递的XML作为传输。有了它,客户端可以调用远程服务器上的带参数的方法(服务器由URI命名),并得到结构化的数据。</target>
        </trans-unit>
        <trans-unit id="7a3256ce956df095fe4314c0a860638e54fbdef5" translate="yes" xml:space="preserve">
          <source>XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP(S) as a transport. With it, a client can call methods with parameters on a remote server (the server is named by a URI) and get back structured data. This module supports writing XML-RPC client code; it handles all the details of translating between conformable Python objects and XML on the wire.</source>
          <target state="translated">XML-RPC是一种远程过程调用方法,它使用通过HTTP(S)传递的XML作为传输。有了它,客户端可以调用远程服务器上的参数方法 (服务器由 URI 命名),并得到结构化的数据。这个模块支持编写 XML-RPC 客户端代码;它处理了所有在符合Python对象和XML之间进行翻译的细节。</target>
        </trans-unit>
        <trans-unit id="466d1915a26cde29cec1e37e7777bd7f436a3403" translate="yes" xml:space="preserve">
          <source>XML-RPC type</source>
          <target state="translated">XML-RPC类型</target>
        </trans-unit>
        <trans-unit id="b48dd5178a470f86e203690c7805dc9b0b2341c0" translate="yes" xml:space="preserve">
          <source>XMLParser Objects</source>
          <target state="translated">XMLParser对象</target>
        </trans-unit>
        <trans-unit id="9e9410180aab9a821557dcc7d0d4c2058d73dd7c" translate="yes" xml:space="preserve">
          <source>XMLPullParser Objects</source>
          <target state="translated">XMLPullParser对象</target>
        </trans-unit>
        <trans-unit id="c0a5ba60aa26c1d7531b3906ecd8c55209f2d410" translate="yes" xml:space="preserve">
          <source>XMLReader Objects</source>
          <target state="translated">XML阅读器对象</target>
        </trans-unit>
        <trans-unit id="bfa3cfc9c89b42310a22b649c3f853faf5dd886d" translate="yes" xml:space="preserve">
          <source>XOFF, for flow control</source>
          <target state="translated">XOFF,用于流量控制</target>
        </trans-unit>
        <trans-unit id="dd84031d44b67a1ddb8cdee96e88fe594f8656ed" translate="yes" xml:space="preserve">
          <source>XON, for flow control</source>
          <target state="translated">XON,用于流量控制</target>
        </trans-unit>
        <trans-unit id="39c789da8e50b0e071e1c885013d7a4b29164374" translate="yes" xml:space="preserve">
          <source>XPath support</source>
          <target state="translated">支持XPath</target>
        </trans-unit>
        <trans-unit id="6060d77ff0f25227959b320cc3c85a394bdc6230" translate="yes" xml:space="preserve">
          <source>Xlib (C)</source>
          <target state="translated">Xlib (C)</target>
        </trans-unit>
        <trans-unit id="53c91c9cd5c47000ef428a9ab7e99e267172260b" translate="yes" xml:space="preserve">
          <source>Year (&amp;gt;= 1980)</source>
          <target state="translated">年（&amp;gt; = 1980）</target>
        </trans-unit>
        <trans-unit id="b5b7f5d30699e5d4e15b4875dbd3728c364030a0" translate="yes" xml:space="preserve">
          <source>Year with century as a decimal number.</source>
          <target state="translated">以世纪为小数的年份。</target>
        </trans-unit>
        <trans-unit id="c64879d90ccc2fc0d06f018314bfc95458d99f67" translate="yes" xml:space="preserve">
          <source>Year without century as a decimal number [00,99].</source>
          <target state="translated">不含世纪的小数点[00,99]年。</target>
        </trans-unit>
        <trans-unit id="872bdd7e5e7113390d4c8fa46dd39ec67115b808" translate="yes" xml:space="preserve">
          <source>Year without century as a zero-padded decimal number.</source>
          <target state="translated">不含世纪的年,作为一个零填充的十进制数。</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="4b7d9108b065dee3edad5735649aad18773cab07" translate="yes" xml:space="preserve">
          <source>Yet another view is the transport and protocol interfaces together define an abstract interface for using network I/O and interprocess I/O.</source>
          <target state="translated">然而另一种观点是传输接口和协议接口共同定义了一个使用网络I/O和进程间I/O的抽象接口。</target>
        </trans-unit>
        <trans-unit id="a7feecab2e1b4006a64972db4b4b19657a1f23d1" translate="yes" xml:space="preserve">
          <source>Yield &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; objects for the given module name.</source>
          <target state="translated">给定模块名称的产量&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;查找器&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="831464f24cac0120f2caade5d640afb021f5150a" translate="yes" xml:space="preserve">
          <source>Yield &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; objects for the given module name.</source>
          <target state="translated">给定模块名称的产量&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;查找器&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="023c595fbee175f8fca03795fa86cafa1a4d11e0" translate="yes" xml:space="preserve">
          <source>Yield a tuple of &lt;code&gt;(fieldname, value)&lt;/code&gt; for each field in &lt;code&gt;node._fields&lt;/code&gt; that is present on &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">为存在于&lt;em&gt;node&lt;/em&gt;上的 &lt;code&gt;node._fields&lt;/code&gt; 中的每个字段产生一个 &lt;code&gt;(fieldname, value)&lt;/code&gt; 元组。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6779be84159814116de4d6defda58236dc2d77b" translate="yes" xml:space="preserve">
          <source>Yield all direct child nodes of &lt;em&gt;node&lt;/em&gt;, that is, all fields that are nodes and all items of fields that are lists of nodes.</source>
          <target state="translated">产生&lt;em&gt;node的&lt;/em&gt;所有直接子节点，即，所有属于节点的字段和所有属于节点列表的字段的项。</target>
        </trans-unit>
        <trans-unit id="836fb31f30edf4301b980b0c16e58e5aca0eb9ba" translate="yes" xml:space="preserve">
          <source>Yields &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt;&lt;code&gt;ModuleInfo&lt;/code&gt;&lt;/a&gt; for all modules recursively on &lt;em&gt;path&lt;/em&gt;, or, if &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, all accessible modules.</source>
          <target state="translated">产量&lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt; &lt;code&gt;ModuleInfo&lt;/code&gt; &lt;/a&gt;所有模块上的递归&lt;em&gt;路径&lt;/em&gt;，或者，如果&lt;em&gt;路径&lt;/em&gt;是 &lt;code&gt;None&lt;/code&gt; ，所有可访问的模块。</target>
        </trans-unit>
        <trans-unit id="e9faaa5a777c93309c3cc258992e9b2bf854a04d" translate="yes" xml:space="preserve">
          <source>Yields &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt;&lt;code&gt;ModuleInfo&lt;/code&gt;&lt;/a&gt; for all submodules on &lt;em&gt;path&lt;/em&gt;, or, if &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, all top-level modules on &lt;code&gt;sys.path&lt;/code&gt;.</source>
          <target state="translated">产量&lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt; &lt;code&gt;ModuleInfo&lt;/code&gt; &lt;/a&gt;用于所有子模块上&lt;em&gt;的路径&lt;/em&gt;，或者，如果&lt;em&gt;路径&lt;/em&gt;是 &lt;code&gt;None&lt;/code&gt; ，在所有顶层模块 &lt;code&gt;sys.path&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a7e2b5d8b96f15b1607e0fd8f2aba767f499b4cc" translate="yes" xml:space="preserve">
          <source>You &amp;ldquo;block&amp;rdquo; attributes by deleting them. Once deleted, accessing an attribute will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以通过删除属性来&amp;ldquo;阻止&amp;rdquo;属性。删除后，访问属性将引发&lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e75e02c51bec7a3ae6df9959824abb351dfd2a65" translate="yes" xml:space="preserve">
          <source>You can add a call to &lt;a href=&quot;pdb#pdb.set_trace&quot;&gt;&lt;code&gt;pdb.set_trace()&lt;/code&gt;&lt;/a&gt; in a doctest example, and you&amp;rsquo;ll drop into the Python debugger when that line is executed. Then you can inspect current values of variables, and so on. For example, suppose &lt;code&gt;a.py&lt;/code&gt; contains just this module docstring:</source>
          <target state="translated">您可以在doctest示例中添加对&lt;a href=&quot;pdb#pdb.set_trace&quot;&gt; &lt;code&gt;pdb.set_trace()&lt;/code&gt; &lt;/a&gt;的调用，并在执行该行时进入Python调试器。然后，您可以检查变量的当前值，依此类推。例如，假设 &lt;code&gt;a.py&lt;/code&gt; 仅包含以下模块文档字符串：</target>
        </trans-unit>
        <trans-unit id="8cb5ee2b3c4d39d5885e625e1382b9b2cbcbbadc" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;Document&lt;/code&gt; by calling a method on a &amp;ldquo;DOM Implementation&amp;rdquo; object. You can get this object either by calling the &lt;code&gt;getDOMImplementation()&lt;/code&gt; function in the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; package or the &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; module. Once you have a &lt;code&gt;Document&lt;/code&gt;, you can add child nodes to it to populate the DOM:</source>
          <target state="translated">您还可以通过在&amp;ldquo; DOM实施&amp;rdquo;对象上调用方法来创建 &lt;code&gt;Document&lt;/code&gt; 。您可以通过调用&lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt;包中的 &lt;code&gt;getDOMImplementation()&lt;/code&gt; 函数或&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt;模块来获取此对象。拥有 &lt;code&gt;Document&lt;/code&gt; 后，可以向其添加子节点以填充DOM：</target>
        </trans-unit>
        <trans-unit id="6cd29f26483ed42fd8dc1116c4e8174423d8b0c6" translate="yes" xml:space="preserve">
          <source>You can also customize &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; argument conversion to allow instances of your own classes be used as function arguments. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; looks for an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute and uses this as the function argument. Of course, it must be one of integer, string, or bytes:</source>
          <target state="translated">您还可以自定义&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;参数转换，以允许将自己的类的实例用作函数参数。&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;查找 &lt;code&gt;_as_parameter_&lt;/code&gt; 属性，并将其用作函数参数。当然，它必须是整数，字符串或字节之一：</target>
        </trans-unit>
        <trans-unit id="04e30ddb9ce13f853c2bfa8e3007580a9b8c57cc" translate="yes" xml:space="preserve">
          <source>You can also extract a tar archive into a different directory by passing the directory&amp;rsquo;s name:</source>
          <target state="translated">您还可以通过传递目录名称来将tar归档文件提取到另一个目录中：</target>
        </trans-unit>
        <trans-unit id="5bd455d2467cd1dcd0d2e97d17dee374eccd5cfd" translate="yes" xml:space="preserve">
          <source>You can also get a &lt;a href=&quot;#version&quot;&gt;distribution&amp;rsquo;s version number&lt;/a&gt;, list its &lt;a href=&quot;#files&quot;&gt;constituent files&lt;/a&gt;, and get a list of the distribution&amp;rsquo;s &lt;a href=&quot;#requirements&quot;&gt;Distribution requirements&lt;/a&gt;.</source>
          <target state="translated">您还可以获得&lt;a href=&quot;#version&quot;&gt;发行版的版本号&lt;/a&gt;，列出其&lt;a href=&quot;#files&quot;&gt;组成文件&lt;/a&gt;，并获得发行版的&lt;a href=&quot;#requirements&quot;&gt;发行要求&lt;/a&gt;列表。</target>
        </trans-unit>
        <trans-unit id="b68300502198932658513c3b6ded30832208e1d6" translate="yes" xml:space="preserve">
          <source>You can also get the full set of files contained within a distribution. The &lt;code&gt;files()&lt;/code&gt; function takes a distribution package name and returns all of the files installed by this distribution. Each file object returned is a &lt;code&gt;PackagePath&lt;/code&gt;, a &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;pathlib.Path&lt;/a&gt; derived object with additional &lt;code&gt;dist&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;hash&lt;/code&gt; properties as indicated by the metadata. For example:</source>
          <target state="translated">您还可以获取分发中包含的完整文件集。该 &lt;code&gt;files()&lt;/code&gt; 函数将分发包名称，并返回全部由这种分布安装的文件。返回的每个文件对象都是 &lt;code&gt;PackagePath&lt;/code&gt; ，&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;pathlib.Path&lt;/a&gt;派生的对象，具有附加的 &lt;code&gt;dist&lt;/code&gt; ， &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;hash&lt;/code&gt; 属性，如元数据所示。例如：</target>
        </trans-unit>
        <trans-unit id="c6a42f0aeadf60a525c55a9533ae3027f565e03f" translate="yes" xml:space="preserve">
          <source>You can also get the full set of files contained within a distribution. The &lt;code&gt;files()&lt;/code&gt; function takes a distribution package name and returns all of the files installed by this distribution. Each file object returned is a &lt;code&gt;PackagePath&lt;/code&gt;, a &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; derived object with additional &lt;code&gt;dist&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;hash&lt;/code&gt; properties as indicated by the metadata. For example:</source>
          <target state="translated">您还可以获取分发中包含的完整文件集。该 &lt;code&gt;files()&lt;/code&gt; 函数将分发包名称，并返回全部由这种分布安装的文件。返回的每个文件对象都是 &lt;code&gt;PackagePath&lt;/code&gt; ，&lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt;派生的对象，具有附加的 &lt;code&gt;dist&lt;/code&gt; ， &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;hash&lt;/code&gt; 属性，如元数据所示。例如：</target>
        </trans-unit>
        <trans-unit id="13be6cdea4e3d4decb6434c0ceed8a0ae35d3756" translate="yes" xml:space="preserve">
          <source>You can also get the set of entry points keyed by group, such as &lt;code&gt;console_scripts&lt;/code&gt;, &lt;code&gt;distutils.commands&lt;/code&gt; and others. Each group contains a sequence of &lt;a href=&quot;#entry-points&quot;&gt;EntryPoint&lt;/a&gt; objects.</source>
          <target state="translated">您还可以获取按组键控的一组入口点，例如 &lt;code&gt;console_scripts&lt;/code&gt; ， &lt;code&gt;distutils.commands&lt;/code&gt; 等。每个组包含一系列&lt;a href=&quot;#entry-points&quot;&gt;EntryPoint&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="c554438646a4fbb6bf065d2eb85cf775c355cab2" translate="yes" xml:space="preserve">
          <source>You can also override this method in an abstract base class:</source>
          <target state="translated">你也可以在抽象基类中重写这个方法。</target>
        </trans-unit>
        <trans-unit id="190f0f3ab62c7ad1e17bcd39e5e06e81ea5e0af0" translate="yes" xml:space="preserve">
          <source>You can also set it to any other callable that accepts a single bytestring parameter and returns the resulting object.</source>
          <target state="translated">你也可以将它设置为任何其他可调用的对象,接受一个单一的bytestring参数并返回结果的对象。</target>
        </trans-unit>
        <trans-unit id="cdf53e0a2dfd4a1e030ae29ed48f2c5b451befc1" translate="yes" xml:space="preserve">
          <source>You can also supply the special name &lt;code&gt;:memory:&lt;/code&gt; to create a database in RAM.</source>
          <target state="translated">您还可以提供特殊名称 &lt;code&gt;:memory:&lt;/code&gt; 在RAM中创建数据库。</target>
        </trans-unit>
        <trans-unit id="10258a035721306e7f2e7a26bdaef81ffbba54de" translate="yes" xml:space="preserve">
          <source>You can also use &lt;strong&gt;pydoc&lt;/strong&gt; to start an HTTP server on the local machine that will serve documentation to visiting Web browsers. &lt;strong&gt;pydoc -p 1234&lt;/strong&gt; will start a HTTP server on port 1234, allowing you to browse the documentation at &lt;code&gt;http://localhost:1234/&lt;/code&gt; in your preferred Web browser. Specifying &lt;code&gt;0&lt;/code&gt; as the port number will select an arbitrary unused port.</source>
          <target state="translated">您还可以使用&lt;strong&gt;pydoc&lt;/strong&gt;在本地计算机上启动HTTP服务器，该服务器将为访问Web浏览器提供文档。&lt;strong&gt;pydoc -p 1234&lt;/strong&gt;将在端口1234上启动HTTP服务器，从而允许您使用首选的Web浏览器浏览位于 &lt;code&gt;http://localhost:1234/&lt;/code&gt; 的文档。指定 &lt;code&gt;0&lt;/code&gt; 作为端口号将选择任意一个未使用的端口。</target>
        </trans-unit>
        <trans-unit id="eda72f19cb6e48b513d9b28377c92f2ebdb8b1bd" translate="yes" xml:space="preserve">
          <source>You can also use a callable Python object (a function or a class for example) as the &lt;code&gt;restype&lt;/code&gt; attribute, if the foreign function returns an integer. The callable will be called with the &lt;em&gt;integer&lt;/em&gt; the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception:</source>
          <target state="translated">如果外部函数返回整数，则还可以将可调用的Python对象（例如，函数或类）用作 &lt;code&gt;restype&lt;/code&gt; 属性。可调用对象将使用C函数返回的&lt;em&gt;整数&lt;/em&gt;进行调用，并且此调用的结果将用作函数调用的结果。这对于检查错误返回值并自动引发异常很有用：</target>
        </trans-unit>
        <trans-unit id="454870431f74d4866521fb0079e0632baf5ce8fd" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;#decimal.localcontext&quot;&gt;&lt;code&gt;localcontext()&lt;/code&gt;&lt;/a&gt; function to temporarily change the active context.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句和&lt;a href=&quot;#decimal.localcontext&quot;&gt; &lt;code&gt;localcontext()&lt;/code&gt; &lt;/a&gt;函数临时更改活动上下文。</target>
        </trans-unit>
        <trans-unit id="b60697ea5592e1d15b0989fd09285ea42c7ffe7a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;#decimal.localcontext&quot;&gt;&lt;code&gt;localcontext()&lt;/code&gt;&lt;/a&gt; function to temporarily change the active context.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句和&lt;a href=&quot;#decimal.localcontext&quot;&gt; &lt;code&gt;localcontext()&lt;/code&gt; &lt;/a&gt;函数临时更改活动上下文。</target>
        </trans-unit>
        <trans-unit id="80f46ed4471fe65e1faf5ebf1891ef4d016092a2" translate="yes" xml:space="preserve">
          <source>You can avoid calling this method explicitly by using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The following code will automatically unlink &lt;em&gt;dom&lt;/em&gt; when the &lt;code&gt;with&lt;/code&gt; block is exited:</source>
          <target state="translated">您可以避免使用&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句来显式调用此方法。退出 &lt;code&gt;with&lt;/code&gt; 块时，以下代码将自动取消&lt;em&gt;dom&lt;/em&gt;的链接：</target>
        </trans-unit>
        <trans-unit id="dde83b96548c4f32be3edb9f1d11f917c25e4700" translate="yes" xml:space="preserve">
          <source>You can avoid calling this method explicitly by using the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The following code will automatically unlink &lt;em&gt;dom&lt;/em&gt; when the &lt;code&gt;with&lt;/code&gt; block is exited:</source>
          <target state="translated">您可以避免通过使用&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句来显式调用此方法。退出 &lt;code&gt;with&lt;/code&gt; 块时，以下代码将自动取消&lt;em&gt;dom&lt;/em&gt;的链接：</target>
        </trans-unit>
        <trans-unit id="9ff8e543590eb6efdd79bbec14ee431d600224b1" translate="yes" xml:space="preserve">
          <source>You can avoid having to call this method explicitly if you use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will shutdown the &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; (waiting as if &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt;&lt;code&gt;Executor.shutdown()&lt;/code&gt;&lt;/a&gt; were called with &lt;em&gt;wait&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句，则可以避免显式调用此方法，这将关闭&lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt;（等待，就像在将&lt;em&gt;wait&lt;/em&gt;设置为 &lt;code&gt;True&lt;/code&gt; 的情况下调用&lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt; &lt;code&gt;Executor.shutdown()&lt;/code&gt; &lt;/a&gt;一样）：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ce715771653f7d4737a60a7668bc850ae2719d7" translate="yes" xml:space="preserve">
          <source>You can avoid having to call this method explicitly if you use the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will shutdown the &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; (waiting as if &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt;&lt;code&gt;Executor.shutdown()&lt;/code&gt;&lt;/a&gt; were called with &lt;em&gt;wait&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句，则可以避免显式调用此方法，这将关闭&lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt;（等待，就像在将&lt;em&gt;wait&lt;/em&gt;设置为 &lt;code&gt;True&lt;/code&gt; 的情况下调用&lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt; &lt;code&gt;Executor.shutdown()&lt;/code&gt; &lt;/a&gt;一样）：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eddf45cff20d1b2f04fdafeec9e97e0ab7dd24ce" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;#hashlib.hash.update&quot;&gt;&lt;code&gt;hash.update()&lt;/code&gt;&lt;/a&gt; as many times as you need to iteratively update the hash:</source>
          <target state="translated">您可以根据需要多次调用&lt;a href=&quot;#hashlib.hash.update&quot;&gt; &lt;code&gt;hash.update()&lt;/code&gt; &lt;/a&gt;来迭代更新哈希：</target>
        </trans-unit>
        <trans-unit id="34c3da7abf9b07dabb72b6daa7e9e7c974938c68" translate="yes" xml:space="preserve">
          <source>You can call these functions like any other Python callable. This example uses the &lt;code&gt;time()&lt;/code&gt; function, which returns system time in seconds since the Unix epoch, and the &lt;code&gt;GetModuleHandleA()&lt;/code&gt; function, which returns a win32 module handle.</source>
          <target state="translated">您可以像调用其他任何Python一样调用这些函数。本示例使用 &lt;code&gt;time()&lt;/code&gt; 函数和 &lt;code&gt;GetModuleHandleA()&lt;/code&gt; 函数，该函数返回自Unix纪元以来的系统时间（以秒为单位），该函数返回Win32模块句柄。</target>
        </trans-unit>
        <trans-unit id="9c9c3c4d6ee67054cff47adecf258437ce7a8a43" translate="yes" xml:space="preserve">
          <source>You can call this method from a different thread to abort any queries that might be executing on the connection. The query will then abort and the caller will get an exception.</source>
          <target state="translated">你可以从不同的线程调用这个方法来中止任何可能在连接上执行的查询。然后查询会中止,调用者会得到一个异常。</target>
        </trans-unit>
        <trans-unit id="f34bf214bdf66878eb786811d2f218be800ab6aa" translate="yes" xml:space="preserve">
          <source>You can change this attribute to a callable that accepts the cursor and the original row as a tuple and will return the real result row. This way, you can implement more advanced ways of returning results, such as returning an object that can also access columns by name.</source>
          <target state="translated">你可以把这个属性改成一个可调用的属性,这个属性接受游标和原始行作为元组,并将返回真正的结果行。这样一来,你就可以实现更高级的返回结果的方式,比如返回一个也可以通过名称访问列的对象。</target>
        </trans-unit>
        <trans-unit id="3dfc510d44c70187526acac335d43e20ac9ac3b7" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;dir_fd&lt;/em&gt; is supported for a particular function on your platform using &lt;a href=&quot;#os.supports_dir_fd&quot;&gt;&lt;code&gt;os.supports_dir_fd&lt;/code&gt;&lt;/a&gt;. If it&amp;rsquo;s unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以检查是否&lt;em&gt;dir_fd&lt;/em&gt;支持使用平台上的特定功能&lt;a href=&quot;#os.supports_dir_fd&quot;&gt; &lt;code&gt;os.supports_dir_fd&lt;/code&gt; &lt;/a&gt;。如果不可用，使用它将引发&lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f63f9df6440b712c040a96a597c89c59d5cd17c0" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;follow_symlinks&lt;/em&gt; is supported for a particular function on your platform using &lt;a href=&quot;#os.supports_follow_symlinks&quot;&gt;&lt;code&gt;os.supports_follow_symlinks&lt;/code&gt;&lt;/a&gt;. If it&amp;rsquo;s unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以检查是否&lt;em&gt;follow_symlinks&lt;/em&gt;支持使用平台上的特定功能&lt;a href=&quot;#os.supports_follow_symlinks&quot;&gt; &lt;code&gt;os.supports_follow_symlinks&lt;/code&gt; &lt;/a&gt;。如果不可用，使用它将引发&lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d14bdf3cfbfc55eeb19102c8785836424dd0384" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;path&lt;/em&gt; can be specified as a file descriptor for a particular function on your platform using &lt;a href=&quot;#os.supports_fd&quot;&gt;&lt;code&gt;os.supports_fd&lt;/code&gt;&lt;/a&gt;. If this functionality is unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#os.supports_fd&quot;&gt; &lt;code&gt;os.supports_fd&lt;/code&gt; &lt;/a&gt;检查是否可以将&lt;em&gt;路径&lt;/em&gt;指定为平台上特定功能的文件描述符。如果此功能不可用，则使用它会引发&lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e32b868cec8c152364c46842077c4cc9e7fa693" translate="yes" xml:space="preserve">
          <source>You can control how files are opened by providing an opening hook via the &lt;em&gt;openhook&lt;/em&gt; parameter to &lt;a href=&quot;#fileinput.input&quot;&gt;&lt;code&gt;fileinput.input()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#fileinput.FileInput&quot;&gt;&lt;code&gt;FileInput()&lt;/code&gt;&lt;/a&gt;. The hook must be a function that takes two arguments, &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt;, and returns an accordingly opened file-like object. Two useful hooks are already provided by this module.</source>
          <target state="translated">您可以通过使用&lt;em&gt;openhook&lt;/em&gt;参数为&lt;a href=&quot;#fileinput.input&quot;&gt; &lt;code&gt;fileinput.input()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#fileinput.FileInput&quot;&gt; &lt;code&gt;FileInput()&lt;/code&gt; &lt;/a&gt;提供打开挂钩来控制文件的打开方式。挂钩必须是一个接受两个参数&lt;em&gt;filename&lt;/em&gt;和&lt;em&gt;mode&lt;/em&gt;的函数，并返回相应打开的类似文件的对象。该模块已经提供了两个有用的钩子。</target>
        </trans-unit>
        <trans-unit id="759d4b35c7817f3e8c98a2e2dd3e428931ede384" translate="yes" xml:space="preserve">
          <source>You can control which kind of &lt;code&gt;BEGIN&lt;/code&gt; statements &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; implicitly executes via the &lt;em&gt;isolation_level&lt;/em&gt; parameter to the &lt;a href=&quot;#sqlite3.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; call, or via the &lt;code&gt;isolation_level&lt;/code&gt; property of connections. If you specify no &lt;em&gt;isolation_level&lt;/em&gt;, a plain &lt;code&gt;BEGIN&lt;/code&gt; is used, which is equivalent to specifying &lt;code&gt;DEFERRED&lt;/code&gt;. Other possible values are &lt;code&gt;IMMEDIATE&lt;/code&gt; and &lt;code&gt;EXCLUSIVE&lt;/code&gt;.</source>
          <target state="translated">您可以通过&lt;a href=&quot;#sqlite3.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;调用的&lt;em&gt;isolation_level&lt;/em&gt;参数或连接的 &lt;code&gt;isolation_level&lt;/code&gt; 属性来控制&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt;隐式执行哪种 &lt;code&gt;BEGIN&lt;/code&gt; 语句。如果未指定&lt;em&gt;isolation_level&lt;/em&gt;，则使用普通的 &lt;code&gt;BEGIN&lt;/code&gt; ，等效于指定 &lt;code&gt;DEFERRED&lt;/code&gt; 。其他可能的值是 &lt;code&gt;IMMEDIATE&lt;/code&gt; 和 &lt;code&gt;EXCLUSIVE&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34baf03473d0f12ec482dd3869630ac31ac0cdee" translate="yes" xml:space="preserve">
          <source>You can create a new object structure by creating &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instances, adding attachments and all the appropriate headers manually. For MIME messages though, the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package provides some convenient subclasses to make things easier.</source>
          <target state="translated">您可以通过创建&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;实例，手动添加附件和所有适当的标题来创建新的对象结构。但是对于MIME邮件，&lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt;包提供了一些方便的子类来使事情变得更容易。</target>
        </trans-unit>
        <trans-unit id="f5697da2c07ba075dd78f5d4867d1c352a9a54b9" translate="yes" xml:space="preserve">
          <source>You can deactivate a virtual environment by typing &amp;ldquo;deactivate&amp;rdquo; in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically a script or shell function will be used).</source>
          <target state="translated">您可以通过在Shell中键入&amp;ldquo; deactivate&amp;rdquo;来停用虚拟环境。确切的机制是特定于平台的，并且是内部的实现细节（通常将使用脚本或shell函数）。</target>
        </trans-unit>
        <trans-unit id="ac0ac8096a20f57f84bc75d77322b86d3e701044" translate="yes" xml:space="preserve">
          <source>You can delete items in this mapping to unset environment variables. &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when an item is deleted from &lt;code&gt;os.environ&lt;/code&gt;, and when one of the &lt;code&gt;pop()&lt;/code&gt; or &lt;code&gt;clear()&lt;/code&gt; methods is called.</source>
          <target state="translated">您可以删除此映射中的项目以取消设置环境变量。当从 &lt;code&gt;os.environ&lt;/code&gt; 中删除一项时，以及当 &lt;code&gt;pop()&lt;/code&gt; 或 &lt;code&gt;clear()&lt;/code&gt; 方法之一被调用时，&lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt;将被自动调用。</target>
        </trans-unit>
        <trans-unit id="3165c20f5760e56d7cc769937fc9c54ec9eb5b3c" translate="yes" xml:space="preserve">
          <source>You can disable the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s implicit transaction management by setting &lt;code&gt;isolation_level&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;. This will leave the underlying &lt;code&gt;sqlite3&lt;/code&gt; library operating in &lt;code&gt;autocommit&lt;/code&gt; mode. You can then completely control the transaction state by explicitly issuing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, &lt;code&gt;SAVEPOINT&lt;/code&gt;, and &lt;code&gt;RELEASE&lt;/code&gt; statements in your code.</source>
          <target state="translated">您可以禁用&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 的&lt;/a&gt;设置模块的隐式事务管理 &lt;code&gt;isolation_level&lt;/code&gt; 到 &lt;code&gt;None&lt;/code&gt; 。这将使基础 &lt;code&gt;sqlite3&lt;/code&gt; 库在 &lt;code&gt;autocommit&lt;/code&gt; 模式下运行。然后，您可以通过在代码中显式发出 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;ROLLBACK&lt;/code&gt; ， &lt;code&gt;SAVEPOINT&lt;/code&gt; 和 &lt;code&gt;RELEASE&lt;/code&gt; 语句来完全控制事务状态。</target>
        </trans-unit>
        <trans-unit id="700422f5e3ee3a72c11fcc9addee940ea1cbf9da" translate="yes" xml:space="preserve">
          <source>You can either call &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; with three arguments or two arguments. The three argument form takes the object to be patched, the attribute name and the object to replace the attribute with.</source>
          <target state="translated">您可以使用三个参数或两个参数调用&lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt;。这三个参数形式采用要修补的对象，属性名称和用于替换属性的对象。</target>
        </trans-unit>
        <trans-unit id="931d434403a5284cf6c44cafa1f3fb736e71253d" translate="yes" xml:space="preserve">
          <source>You can escape other strings of data by passing a dictionary as the optional &lt;em&gt;entities&lt;/em&gt; parameter. The keys and values must all be strings; each key will be replaced with its corresponding value. The characters &lt;code&gt;'&amp;amp;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;'&lt;/code&gt; and &lt;code&gt;'&amp;gt;'&lt;/code&gt; are always escaped, even if &lt;em&gt;entities&lt;/em&gt; is provided.</source>
          <target state="translated">您可以通过传递字典作为可选的&lt;em&gt;entities&lt;/em&gt;参数来转义其他数据字符串。键和值都必须是字符串；每个键将替换为其对应的值。即使提供了&lt;em&gt;实体&lt;/em&gt;，字符 &lt;code&gt;'&amp;amp;'&lt;/code&gt; ， &lt;code&gt;'&amp;lt;'&lt;/code&gt; 和 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 也总是被转义。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="573f2efb0ec1c2a5d9e8ef8857e1296252240138" translate="yes" xml:space="preserve">
          <source>You can extend the list of file types &lt;a href=&quot;#module-imghdr&quot;&gt;&lt;code&gt;imghdr&lt;/code&gt;&lt;/a&gt; can recognize by appending to this variable:</source>
          <target state="translated">您可以通过附加到此变量来扩展&lt;a href=&quot;#module-imghdr&quot;&gt; &lt;code&gt;imghdr&lt;/code&gt; &lt;/a&gt;可以识别的文件类型列表：</target>
        </trans-unit>
        <trans-unit id="195ad7b8f2b09586418660df23685063cb22b239" translate="yes" xml:space="preserve">
          <source>You can force use of your own dict as the execution context by passing &lt;code&gt;globs=your_dict&lt;/code&gt; to &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">您可以通过将 &lt;code&gt;globs=your_dict&lt;/code&gt; 传递给&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt;来强制使用自己的dict作为执行上下文。</target>
        </trans-unit>
        <trans-unit id="dcb97e241e1e5c9620f24676030d9e232a3c7a23" translate="yes" xml:space="preserve">
          <source>You can force verbose mode by passing &lt;code&gt;verbose=True&lt;/code&gt; to &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, or prohibit it by passing &lt;code&gt;verbose=False&lt;/code&gt;. In either of those cases, &lt;code&gt;sys.argv&lt;/code&gt; is not examined by &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; (so passing &lt;code&gt;-v&lt;/code&gt; or not has no effect).</source>
          <target state="translated">您可以通过将 &lt;code&gt;verbose=True&lt;/code&gt; 传递给&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt;来强制采用详细模式，也可以通过传递 &lt;code&gt;verbose=False&lt;/code&gt; 来禁止它。在这两种情况下，&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt;均不会检查 &lt;code&gt;sys.argv&lt;/code&gt; （因此，传递 &lt;code&gt;-v&lt;/code&gt; 无效）。</target>
        </trans-unit>
        <trans-unit id="35c7606f98e9dd961b696a7ddeffebdba225ead4" translate="yes" xml:space="preserve">
          <source>You can get the &lt;a href=&quot;#metadata&quot;&gt;metadata for a distribution&lt;/a&gt;:</source>
          <target state="translated">您可以获取&lt;a href=&quot;#metadata&quot;&gt;分发&lt;/a&gt;的元数据：</target>
        </trans-unit>
        <trans-unit id="6a35d8910326f07b0f1906f10b52c07b4fa3a76e" translate="yes" xml:space="preserve">
          <source>You can get the version string for &lt;code&gt;wheel&lt;/code&gt; by running the following:</source>
          <target state="translated">您可以通过运行以下命令获取 &lt;code&gt;wheel&lt;/code&gt; 的版本字符串：</target>
        </trans-unit>
        <trans-unit id="a032c7f821aa0424d57257b08c9ddac86e6e7e57" translate="yes" xml:space="preserve">
          <source>You can handle these with code like the following. Note that for arbitrary getset descriptors invoking these may trigger code execution:</source>
          <target state="translated">你可以用下面这样的代码来处理这些问题。请注意,对于任意的getset描述符,调用这些可能会触发代码执行。</target>
        </trans-unit>
        <trans-unit id="3cb8c4e2de3a151cd226fb06b93bdaeac63f0b4d" translate="yes" xml:space="preserve">
          <source>You can instantiate a &lt;a href=&quot;#curses.textpad.Textbox&quot;&gt;&lt;code&gt;Textbox&lt;/code&gt;&lt;/a&gt; object as follows:</source>
          <target state="translated">您可以实例化&lt;a href=&quot;#curses.textpad.Textbox&quot;&gt; &lt;code&gt;Textbox&lt;/code&gt; &lt;/a&gt;对象，如下所示：</target>
        </trans-unit>
        <trans-unit id="9a5d59662d5371a0fdfca7a9eef49f35ae3ce64a" translate="yes" xml:space="preserve">
          <source>You can modify some of the &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s attributes before you add it using &lt;a href=&quot;#tarfile.TarFile.addfile&quot;&gt;&lt;code&gt;addfile()&lt;/code&gt;&lt;/a&gt;. If the file object is not an ordinary file object positioned at the beginning of the file, attributes such as &lt;a href=&quot;#tarfile.TarInfo.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt; may need modifying. This is the case for objects such as &lt;a href=&quot;gzip#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#tarfile.TarInfo.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; may also be modified, in which case &lt;em&gt;arcname&lt;/em&gt; could be a dummy string.</source>
          <target state="translated">您可以在使用&lt;a href=&quot;#tarfile.TarFile.addfile&quot;&gt; &lt;code&gt;addfile()&lt;/code&gt; &lt;/a&gt;添加&lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt;的某些属性之前对其进行修改。如果文件对象不是位于文件开头的普通文件对象，则可能需要修改诸如&lt;a href=&quot;#tarfile.TarInfo.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;属性。对于诸如&lt;a href=&quot;gzip#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; 的&lt;/a&gt;对象就是这种情况。该&lt;a href=&quot;#tarfile.TarInfo.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt;也可以修改，在这种情况下&lt;em&gt;arcname&lt;/em&gt;可能是一个虚拟的字符串。</target>
        </trans-unit>
        <trans-unit id="e839e79b2480577448952d6abaeadf88b91bec05" translate="yes" xml:space="preserve">
          <source>You can only instantiate the class flavour that corresponds to your system (allowing system calls on non-compatible path flavours could lead to bugs or failures in your application):</source>
          <target state="translated">你只能实例化与你的系统相对应的类风味(允许系统调用不兼容的路径风味可能会导致你的应用程序出现错误或失败)。</target>
        </trans-unit>
        <trans-unit id="0578dfb60398ddde818b7586a4e3117026258d03" translate="yes" xml:space="preserve">
          <source>You can override this to implement custom flushing behavior. This version just zaps the buffer to empty.</source>
          <target state="translated">你可以重写这个来实现自定义的刷新行为。这个版本只是将缓冲区清空。</target>
        </trans-unit>
        <trans-unit id="2bc87e2256f9989176b847850b749c9cc0cc6702" translate="yes" xml:space="preserve">
          <source>You can pass in a list with any combination of module names, and fully qualified class or method names.</source>
          <target state="translated">你可以传入一个列表,其中包含任意组合的模块名称,以及完全限定的类或方法名称。</target>
        </trans-unit>
        <trans-unit id="a41bb05a43844e14e9db9886115ec4b066bd61b1" translate="yes" xml:space="preserve">
          <source>You can pass integers 0 or 1 or the strings &lt;code&gt;&quot;yes&quot;&lt;/code&gt; or &lt;code&gt;&quot;no&quot;&lt;/code&gt;.</source>
          <target state="translated">您可以传递整数0或1或字符串 &lt;code&gt;&quot;yes&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad0da7097c864ecb1de37d622a186a7c648c4e2a" translate="yes" xml:space="preserve">
          <source>You can patch any builtins within a module. The following example patches builtin &lt;a href=&quot;functions#ord&quot;&gt;&lt;code&gt;ord()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以修补模块中的任何内置插件。以下示例补丁内置于&lt;a href=&quot;functions#ord&quot;&gt; &lt;code&gt;ord()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9ec973428da2c09e12914b4e9b653d668597b96e" translate="yes" xml:space="preserve">
          <source>You can place the definitions of test cases and test suites in the same modules as the code they are to test (such as &lt;code&gt;widget.py&lt;/code&gt;), but there are several advantages to placing the test code in a separate module, such as &lt;code&gt;test_widget.py&lt;/code&gt;:</source>
          <target state="translated">可以放置的测试用例和测试套件的定义在相同的模块，因为它们是测试（如代码 &lt;code&gt;widget.py&lt;/code&gt; ），但也有几个优点将测试码在一个单独的模块，如 &lt;code&gt;test_widget.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="64d273c86ad6ae2b4218d4f8a1cf522c0e7dff12" translate="yes" xml:space="preserve">
          <source>You can re-use the same &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; object many times, and you can change any of its options through direct assignment to instance attributes between uses.</source>
          <target state="translated">您可以多次重复使用同一&lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt;对象，并且可以通过在使用之间直接分配给实例属性来更改其任何选项。</target>
        </trans-unit>
        <trans-unit id="185356fb3c67fcf9bd0085c884b80c32a2e93e4d" translate="yes" xml:space="preserve">
          <source>You can register new formats or provide your own archiver for any existing formats, by using &lt;a href=&quot;#shutil.register_archive_format&quot;&gt;&lt;code&gt;register_archive_format()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#shutil.register_archive_format&quot;&gt; &lt;code&gt;register_archive_format()&lt;/code&gt; &lt;/a&gt;注册新格式或为任何现有格式提供自己的存档器。</target>
        </trans-unit>
        <trans-unit id="a9c59d52c0ef34971a017a80bfad6dc0e9a43e0e" translate="yes" xml:space="preserve">
          <source>You can register new formats or provide your own unpacker for any existing formats, by using &lt;a href=&quot;#shutil.register_unpack_format&quot;&gt;&lt;code&gt;register_unpack_format()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#shutil.register_unpack_format&quot;&gt; &lt;code&gt;register_unpack_format()&lt;/code&gt; &lt;/a&gt;注册新格式或为任何现有格式提供自己的拆包器。</target>
        </trans-unit>
        <trans-unit id="c6eab1e30d733d2bc722869dacae533e1cfa585d" translate="yes" xml:space="preserve">
          <source>You can run tests with more detail (higher verbosity) by passing in the -v flag:</source>
          <target state="translated">你可以通过传递-v标志来运行更详细的测试(更高的verbosity)。</target>
        </trans-unit>
        <trans-unit id="f1b607c7c24b44337173d6d898a09d86d78747aa" translate="yes" xml:space="preserve">
          <source>You can run tests with more detailed information by passing in the verbosity argument:</source>
          <target state="translated">你可以通过传递verbosity参数来运行具有更详细信息的测试。</target>
        </trans-unit>
        <trans-unit id="98e511b3bdd1ce757c87785c523b616f2db1ad16" translate="yes" xml:space="preserve">
          <source>You can see that &lt;code&gt;request.Request&lt;/code&gt; has a spec. &lt;code&gt;request.Request&lt;/code&gt; takes two arguments in the constructor (one of which is &lt;em&gt;self&lt;/em&gt;). Here&amp;rsquo;s what happens if we try to call it incorrectly:</source>
          <target state="translated">您可以看到该 &lt;code&gt;request.Request&lt;/code&gt; 。请求具有规范。 &lt;code&gt;request.Request&lt;/code&gt; 在构造函数中有两个参数（其中一个是&lt;em&gt;self&lt;/em&gt;）。如果我们尝试错误地调用它，将会发生以下情况：</target>
        </trans-unit>
        <trans-unit id="7dc1b0288d71a05f65580cdcbf7bcc461729fa07" translate="yes" xml:space="preserve">
          <source>You can specify &lt;em&gt;stack_info&lt;/em&gt; independently of &lt;em&gt;exc_info&lt;/em&gt;, e.g. to just show how you got to a certain point in your code, even when no exceptions were raised. The stack frames are printed following a header line which says:</source>
          <target state="translated">您可以独立于&lt;em&gt;exc_info&lt;/em&gt;来指定&lt;em&gt;stack_info&lt;/em&gt;，例如，即使在未引发任何异常的情况下，也可以仅显示如何到达代码中的特定点。堆栈框架在标题行之后打印：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="680d7a6fb2ebb3408e9b53cb231daa64e3270083" translate="yes" xml:space="preserve">
          <source>You can stack up multiple patch decorators using this pattern:</source>
          <target state="translated">你可以用这个图案叠加多个贴片装饰器。</target>
        </trans-unit>
        <trans-unit id="6c62dfcabd935ea8e9bffc17a00618ffafad4ff5" translate="yes" xml:space="preserve">
          <source>You can still read the original number of total frames that composed the traceback by looking at the &lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt;&lt;code&gt;Traceback.total_nframe&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">通过查看&lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt; &lt;code&gt;Traceback.total_nframe&lt;/code&gt; &lt;/a&gt;属性，您仍然可以读取构成回溯的原始帧总数。</target>
        </trans-unit>
        <trans-unit id="c643863a496cceedd3383ac19ac4ae419cf4d464" translate="yes" xml:space="preserve">
          <source>You can still retrieve the downloaded data in this case, it is stored in the &lt;code&gt;content&lt;/code&gt; attribute of the exception instance.</source>
          <target state="translated">在这种情况下，您仍然可以检索下载的数据，该数据存储在异常实例的 &lt;code&gt;content&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="1de115a11b34194063eb6b97040f48ef6d842aca" translate="yes" xml:space="preserve">
          <source>You can unescape other strings of data by passing a dictionary as the optional &lt;em&gt;entities&lt;/em&gt; parameter. The keys and values must all be strings; each key will be replaced with its corresponding value. &lt;code&gt;'&amp;amp;amp'&lt;/code&gt;, &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt;, and &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; are always unescaped, even if &lt;em&gt;entities&lt;/em&gt; is provided.</source>
          <target state="translated">您可以通过将字典作为可选的&lt;em&gt;entities&lt;/em&gt;参数来取消转义其他数据字符串。键和值都必须是字符串；每个键将替换为其对应的值。 &lt;code&gt;'&amp;amp;amp'&lt;/code&gt; ， &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt; 和 &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; 即使提供了&lt;em&gt;实体&lt;/em&gt;，也始终不会转义。</target>
        </trans-unit>
        <trans-unit id="301b27cb1683d2e7c0b8ba419ff685e93d50ce4d" translate="yes" xml:space="preserve">
          <source>You can unregister a finalizer using its &lt;a href=&quot;#weakref.finalize.detach&quot;&gt;&lt;code&gt;detach()&lt;/code&gt;&lt;/a&gt; method. This kills the finalizer and returns the arguments passed to the constructor when it was created.</source>
          <target state="translated">您可以使用终结器的&lt;a href=&quot;#weakref.finalize.detach&quot;&gt; &lt;code&gt;detach()&lt;/code&gt; &lt;/a&gt;方法注销它。这将杀死终结器并返回创建时传递给构造函数的参数。</target>
        </trans-unit>
        <trans-unit id="166be8a8478c4349774e11ae954bcf15ea13c98f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#module-sysconfig&quot;&gt;&lt;code&gt;sysconfig&lt;/code&gt;&lt;/a&gt; as a script with Python&amp;rsquo;s &lt;em&gt;-m&lt;/em&gt; option:</source>
          <target state="translated">您可以使用&lt;a href=&quot;#module-sysconfig&quot;&gt; &lt;code&gt;sysconfig&lt;/code&gt; &lt;/a&gt;作为带有Python的&lt;em&gt;-m&lt;/em&gt;选项的脚本：</target>
        </trans-unit>
        <trans-unit id="4a2a75932fb642063f33320e42bd47704f40bcf9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#str.maketrans&quot;&gt;&lt;code&gt;str.maketrans()&lt;/code&gt;&lt;/a&gt; to create a translation map from character-to-character mappings in different formats.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#str.maketrans&quot;&gt; &lt;code&gt;str.maketrans()&lt;/code&gt; &lt;/a&gt;从不同格式的字符到字符映射创建翻译映射。</target>
        </trans-unit>
        <trans-unit id="0ef37ecf8c36fd08b114602b0f13c55a48235640" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;Optional[X]&lt;/code&gt; as a shorthand for &lt;code&gt;Union[X, None]&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;Optional[X]&lt;/code&gt; 作为 &lt;code&gt;Union[X, None]&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="93860cdb857fa2ccab62a0fe438384b6ec2ab456" translate="yes" xml:space="preserve">
          <source>You can use breakpoint commands to start your program up again. Simply use the &lt;a href=&quot;#pdbcommand-continue&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; command, or &lt;a href=&quot;#pdbcommand-step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt;, or any other command that resumes execution.</source>
          <target state="translated">您可以使用断点命令重新启动程序。只需使用&lt;a href=&quot;#pdbcommand-continue&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;命令或&lt;a href=&quot;#pdbcommand-step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;，或任何其他恢复执行的命令。</target>
        </trans-unit>
        <trans-unit id="18a9f7442f0c27445596b606f02263419595de19" translate="yes" xml:space="preserve">
          <source>You can use multiple inheritance with &lt;a href=&quot;#typing.Generic&quot;&gt;&lt;code&gt;Generic&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以对&lt;a href=&quot;#typing.Generic&quot;&gt; &lt;code&gt;Generic&lt;/code&gt; &lt;/a&gt;使用多重继承：</target>
        </trans-unit>
        <trans-unit id="08a65a4fd87ab3260a2995232edfe49d33c5209f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#bytes.maketrans&quot;&gt;&lt;code&gt;bytes.maketrans()&lt;/code&gt;&lt;/a&gt; method to create a translation table.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#bytes.maketrans&quot;&gt; &lt;code&gt;bytes.maketrans()&lt;/code&gt; &lt;/a&gt;方法创建转换表。</target>
        </trans-unit>
        <trans-unit id="a3a1452d46bec95e5b939ca953e994a40a430f62" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;maxBytes&lt;/em&gt; and &lt;em&gt;backupCount&lt;/em&gt; values to allow the file to &lt;em&gt;rollover&lt;/em&gt; at a predetermined size. When the size is about to be exceeded, the file is closed and a new file is silently opened for output. Rollover occurs whenever the current log file is nearly &lt;em&gt;maxBytes&lt;/em&gt; in length; but if either of &lt;em&gt;maxBytes&lt;/em&gt; or &lt;em&gt;backupCount&lt;/em&gt; is zero, rollover never occurs, so you generally want to set &lt;em&gt;backupCount&lt;/em&gt; to at least 1, and have a non-zero &lt;em&gt;maxBytes&lt;/em&gt;. When &lt;em&gt;backupCount&lt;/em&gt; is non-zero, the system will save old log files by appending the extensions &amp;lsquo;.1&amp;rsquo;, &amp;lsquo;.2&amp;rsquo; etc., to the filename. For example, with a &lt;em&gt;backupCount&lt;/em&gt; of 5 and a base file name of &lt;code&gt;app.log&lt;/code&gt;, you would get &lt;code&gt;app.log&lt;/code&gt;, &lt;code&gt;app.log.1&lt;/code&gt;, &lt;code&gt;app.log.2&lt;/code&gt;, up to &lt;code&gt;app.log.5&lt;/code&gt;. The file being written to is always &lt;code&gt;app.log&lt;/code&gt;. When this file is filled, it is closed and renamed to &lt;code&gt;app.log.1&lt;/code&gt;, and if files &lt;code&gt;app.log.1&lt;/code&gt;, &lt;code&gt;app.log.2&lt;/code&gt;, etc. exist, then they are renamed to &lt;code&gt;app.log.2&lt;/code&gt;, &lt;code&gt;app.log.3&lt;/code&gt; etc. respectively.</source>
          <target state="translated">您可以使用&lt;em&gt;maxBytes&lt;/em&gt;和&lt;em&gt;backupCount&lt;/em&gt;值来允许文件以预定大小&lt;em&gt;滚动&lt;/em&gt;。当将要超过该大小时，将关闭文件，并以静默方式打开一个新文件以进行输出。只要当前日志文件的长度接近&lt;em&gt;maxBytes&lt;/em&gt;，就会发生翻转。但是如果&lt;em&gt;maxBytes&lt;/em&gt;或&lt;em&gt;backupCount中的&lt;/em&gt;任何一个为零，都不会发生过渡，因此您通常希望将&lt;em&gt;backupCount&lt;/em&gt;设置为至少1，并且&lt;em&gt;maxBytes&lt;/em&gt;为非零。当&lt;em&gt;backupCount&lt;/em&gt;不为零时，系统将通过在文件名后附加扩展名'.1'，'。2'等来保存旧的日志文件。例如，使用&lt;em&gt;backupCount&lt;/em&gt;的5个文件和一个基本文件名 &lt;code&gt;app.log&lt;/code&gt; ，您将获得 &lt;code&gt;app.log&lt;/code&gt; ， &lt;code&gt;app.log.1&lt;/code&gt; ， &lt;code&gt;app.log.2&lt;/code&gt; ，直到 &lt;code&gt;app.log.5&lt;/code&gt; 。写入的文件始终是 &lt;code&gt;app.log&lt;/code&gt; 。当这个文件被填满时，它被关闭并重新命名为 &lt;code&gt;app.log.1&lt;/code&gt; ，如果文件 &lt;code&gt;app.log.1&lt;/code&gt; ， &lt;code&gt;app.log.2&lt;/code&gt; 等存在，那么它们被重命名为 &lt;code&gt;app.log.2&lt;/code&gt; ， &lt;code&gt;app.log.3&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="1d81a63f3a0b165e52e93538340d0368d87d32f2" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;when&lt;/em&gt; to specify the type of &lt;em&gt;interval&lt;/em&gt;. The list of possible values is below. Note that they are not case sensitive.</source>
          <target state="translated">您可以使用&lt;em&gt;when&lt;/em&gt;指定&lt;em&gt;间隔&lt;/em&gt;的类型。可能值的列表如下。请注意，它们不区分大小写。</target>
        </trans-unit>
        <trans-unit id="d0cca2e6adbd32c2d102c851414d65aceb06c207" translate="yes" xml:space="preserve">
          <source>You can use their &amp;ldquo;tupleness&amp;rdquo; to pull out the individual arguments for more complex introspection and assertions. The positional arguments are a tuple (an empty tuple if there are no positional arguments) and the keyword arguments are a dictionary:</source>
          <target state="translated">您可以使用它们的&amp;ldquo;元组&amp;rdquo;来提取各个参数，以进行更复杂的自省和断言。位置参数是一个元组（如果没有位置参数，则为空元组），关键字参数是一个字典：</target>
        </trans-unit>
        <trans-unit id="4ad3bae98cc6e6098bbeb87c404b93a8af1ae980" translate="yes" xml:space="preserve">
          <source>You can use these objects to do transparent transcodings, e.g., from Latin-1 to UTF-8 and back.</source>
          <target state="translated">你可以使用这些对象来进行透明的转码,例如,从Latin-1转为UTF-8再转回来。</target>
        </trans-unit>
        <trans-unit id="f7a3127c0bc2be176f0faafcf4a37b1cfc1abb3f" translate="yes" xml:space="preserve">
          <source>You can use this value if you want to wait on several events at once using &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt;&lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt;&lt;/a&gt;. Otherwise calling &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is simpler.</source>
          <target state="translated">如果要使用&lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt; &lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt; &lt;/a&gt;一次等待多个事件，则可以使用此值。否则，调用&lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;更简单。</target>
        </trans-unit>
        <trans-unit id="e2350bed90650fb87541671e1d3f3ffd1c20689e" translate="yes" xml:space="preserve">
          <source>You can, however, build much more complicated structures. A structure can itself contain other structures by using a structure as a field type.</source>
          <target state="translated">然而,您可以建立更复杂的结构。通过使用结构体作为字段类型,一个结构体本身可以包含其他结构体。</target>
        </trans-unit>
        <trans-unit id="64232b1d30a4b1e7f9e804d9e5b5aeafaf0b3c72" translate="yes" xml:space="preserve">
          <source>You cannot go past an anchor, or empty path:</source>
          <target state="translated">不能过锚,也不能空路。</target>
        </trans-unit>
        <trans-unit id="e66b26b6f2c6b7b9831acdd5ef8c996027377922" translate="yes" xml:space="preserve">
          <source>You cannot subclass or instantiate a union.</source>
          <target state="translated">你不能子类或实例化一个联盟。</target>
        </trans-unit>
        <trans-unit id="966bda9fba3346ce89e289b42714a0f9e137407c" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;Union[X][Y]&lt;/code&gt;.</source>
          <target state="translated">您不能写 &lt;code&gt;Union[X][Y]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="752587134d14b2eaf8447f7b6f2d68877dfdd6b9" translate="yes" xml:space="preserve">
          <source>You do not need to create instances of this class directly; they are automatically created as needed by &lt;a href=&quot;#wsgiref.simple_server.WSGIServer&quot;&gt;&lt;code&gt;WSGIServer&lt;/code&gt;&lt;/a&gt; objects. You can, however, subclass this class and supply it as a &lt;em&gt;handler_class&lt;/em&gt; to the &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt; function. Some possibly relevant methods for overriding in subclasses:</source>
          <target state="translated">您无需直接创建此类的实例；它们由&lt;a href=&quot;#wsgiref.simple_server.WSGIServer&quot;&gt; &lt;code&gt;WSGIServer&lt;/code&gt; &lt;/a&gt;对象根据需要自动创建。但是，您可以将该类作为子类，并将其作为&lt;em&gt;handler_class提供&lt;/em&gt;给&lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt;函数。在子类中重写的一些可能相关的方法：</target>
        </trans-unit>
        <trans-unit id="431cbf03af6322a0c5713e5104bf689d6714c32c" translate="yes" xml:space="preserve">
          <source>You do not need to set the epilogue to the empty string in order for the &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to print a newline at the end of the file.</source>
          <target state="translated">您无需将结尾部分设置为空字符串，即可让&lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;在文件末尾打印换行符。</target>
        </trans-unit>
        <trans-unit id="a17530dc8c32d2acb8875bd9c97bc5b2d12e7a45" translate="yes" xml:space="preserve">
          <source>You do not normally need to call this constructor, as the &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt; function can handle all the details for you.</source>
          <target state="translated">通常不需要调用此构造函数，因为&lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt;函数可以为您处理所有详细信息。</target>
        </trans-unit>
        <trans-unit id="ea99f60bcd9ea0794f5438dbea50265ec904cc2b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t actually need to subclass &lt;code&gt;Filter&lt;/code&gt;: you can pass any instance which has a &lt;code&gt;filter&lt;/code&gt; method with the same semantics.</source>
          <target state="translated">实际上，您不需要子类 &lt;code&gt;Filter&lt;/code&gt; ：您可以传递任何具有相同语义的 &lt;code&gt;filter&lt;/code&gt; 方法的实例。</target>
        </trans-unit>
        <trans-unit id="bc60677ef0241f3f9196c36f2e70aeee248e2fbd" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to subclass the parser to use this method, you can also set it on an instance, to a function that takes a string argument and returns a string. Setting it to &lt;code&gt;str&lt;/code&gt;, for example, would make option names case sensitive:</source>
          <target state="translated">您无需继承解析器的子类即可使用此方法，还可以在实例上将其设置为具有字符串参数并返回字符串的函数。例如，将其设置为 &lt;code&gt;str&lt;/code&gt; 会使选项名称区分大小写：</target>
        </trans-unit>
        <trans-unit id="07066c5c390391f5b0549847d58ead8ad1fc7cf5" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to wrap with &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt; if you&amp;rsquo;re setting the import callable on a configurator &lt;em&gt;instance&lt;/em&gt;.</source>
          <target state="translated">如果您要在configurator &lt;em&gt;实例&lt;/em&gt;上设置import调用，则无需使用&lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt;进行包装。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50060718f1fe46b8db95adb5dafc6399b74bdccf" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t specifically &lt;em&gt;need&lt;/em&gt; to activate an environment; activation just prepends the virtual environment&amp;rsquo;s binary directory to your path, so that &amp;ldquo;python&amp;rdquo; invokes the virtual environment&amp;rsquo;s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a virtual environment should be runnable without activating it, and run with the virtual environment&amp;rsquo;s Python automatically.</source>
          <target state="translated">你并不特别&lt;em&gt;需要&lt;/em&gt;激活的环境;激活只是将虚拟环境的二进制目录添加到您的路径中，以便&amp;ldquo; python&amp;rdquo;调用虚拟环境的Python解释器，您可以运行已安装的脚本，而不必使用其完整路径。但是，安装在虚拟环境中的所有脚本都应在不激活的情况下可运行，并自动与虚拟环境的Python一起运行。</target>
        </trans-unit>
        <trans-unit id="6d235d73a43398a64c313b4126a55b055ef79602" translate="yes" xml:space="preserve">
          <source>You load libraries by accessing them as attributes of these objects. &lt;em&gt;cdll&lt;/em&gt; loads libraries which export functions using the standard &lt;code&gt;cdecl&lt;/code&gt; calling convention, while &lt;em&gt;windll&lt;/em&gt; libraries call functions using the &lt;code&gt;stdcall&lt;/code&gt; calling convention. &lt;em&gt;oledll&lt;/em&gt; also uses the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and assumes the functions return a Windows &lt;code&gt;HRESULT&lt;/code&gt; error code. The error code is used to automatically raise an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception when the function call fails.</source>
          <target state="translated">通过将库作为这些对象的属性进行访问来加载它们。&lt;em&gt;cdll&lt;/em&gt;加载使用标准 &lt;code&gt;cdecl&lt;/code&gt; 调用约定导出函数的库，而&lt;em&gt;windll&lt;/em&gt;库使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定调用函数。&lt;em&gt;oledll&lt;/em&gt;也使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定，并假定函数返回Windows &lt;code&gt;HRESULT&lt;/code&gt; 错误代码。错误代码用于在函数调用失败时自动引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="aac6314187cc5d9a54cb395d4bf42121079c9e85" translate="yes" xml:space="preserve">
          <source>You may also specify an arbitrary action by passing an Action subclass or other object that implements the same interface. The &lt;code&gt;BooleanOptionalAction&lt;/code&gt; is available in &lt;code&gt;argparse&lt;/code&gt; and adds support for boolean actions such as &lt;code&gt;--foo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt;:</source>
          <target state="translated">您也可以通过传递Action子类或实现相同接口的其他对象来指定任意动作。该 &lt;code&gt;BooleanOptionalAction&lt;/code&gt; 是可用 &lt;code&gt;argparse&lt;/code&gt; 并增加了对布尔操作，如支持 &lt;code&gt;--foo&lt;/code&gt; 和 &lt;code&gt;--no-foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7a9f24d09ce2fac5b6b5e198261279380d5bbbd5" translate="yes" xml:space="preserve">
          <source>You may also specify an arbitrary action by passing an Action subclass or other object that implements the same interface. The recommended way to do this is to extend &lt;a href=&quot;#argparse.Action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;, overriding the &lt;code&gt;__call__&lt;/code&gt; method and optionally the &lt;code&gt;__init__&lt;/code&gt; method.</source>
          <target state="translated">您也可以通过传递Action子类或实现相同接口的其他对象来指定任意动作。推荐的方法是扩展&lt;a href=&quot;#argparse.Action&quot;&gt; &lt;code&gt;Action&lt;/code&gt; &lt;/a&gt;，覆盖 &lt;code&gt;__call__&lt;/code&gt; 方法和可选的 &lt;code&gt;__init__&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="355be00ad0a55445558f75bdbc18f08ec59ccd73" translate="yes" xml:space="preserve">
          <source>You may override this method in a subclass. The standard &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method invokes the callable object passed to the object&amp;rsquo;s constructor as the target argument, if any, with sequential and keyword arguments taken from the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; arguments, respectively.</source>
          <target state="translated">您可以在子类中重写此方法。标准的&lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;方法调用传递给对象构造函数的可调用对象作为目标参数（如果有），并分别从&lt;em&gt;args&lt;/em&gt;和&lt;em&gt;kwargs&lt;/em&gt;参数中获取顺序参数和关键字参数。</target>
        </trans-unit>
        <trans-unit id="63d0895d58df495742a522d15640d62134175d03" translate="yes" xml:space="preserve">
          <source>You may override this method in a subclass. The standard &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method invokes the callable object passed to the object&amp;rsquo;s constructor as the &lt;em&gt;target&lt;/em&gt; argument, if any, with positional and keyword arguments taken from the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; arguments, respectively.</source>
          <target state="translated">您可以在子类中重写此方法。标准的&lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;方法调用传递到对象构造函数的可调用对象作为&lt;em&gt;目标&lt;/em&gt;参数（如果有），并分别从&lt;em&gt;args&lt;/em&gt;和&lt;em&gt;kwargs&lt;/em&gt;参数获取位置和关键字参数。</target>
        </trans-unit>
        <trans-unit id="559ac3792a61fab934579c9348c599af2f6ebff8" translate="yes" xml:space="preserve">
          <source>You may still perform all &lt;code&gt;int&lt;/code&gt; operations on a variable of type &lt;code&gt;UserId&lt;/code&gt;, but the result will always be of type &lt;code&gt;int&lt;/code&gt;. This lets you pass in a &lt;code&gt;UserId&lt;/code&gt; wherever an &lt;code&gt;int&lt;/code&gt; might be expected, but will prevent you from accidentally creating a &lt;code&gt;UserId&lt;/code&gt; in an invalid way:</source>
          <target state="translated">您仍然可以对 &lt;code&gt;UserId&lt;/code&gt; 类型的变量执行所有 &lt;code&gt;int&lt;/code&gt; 操作，但结果始终为 &lt;code&gt;int&lt;/code&gt; 类型。这使您可以在可能需要 &lt;code&gt;int&lt;/code&gt; 的任何地方传递 &lt;code&gt;UserId&lt;/code&gt; ，但可以防止您以无效的方式意外创建 &lt;code&gt;UserId&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d58ea92f23614149b70f3349883f40aae428e954" translate="yes" xml:space="preserve">
          <source>You may then fetch the certificate:</source>
          <target state="translated">然后你就可以取证了。</target>
        </trans-unit>
        <trans-unit id="60f46d58993c757c98a68957af7a5a798eec2a9d" translate="yes" xml:space="preserve">
          <source>You may want a mock object to return &lt;code&gt;False&lt;/code&gt; to a &lt;a href=&quot;functions#hasattr&quot;&gt;&lt;code&gt;hasattr()&lt;/code&gt;&lt;/a&gt; call, or raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; when an attribute is fetched. You can do this by providing an object as a &lt;code&gt;spec&lt;/code&gt; for a mock, but that isn&amp;rsquo;t always convenient.</source>
          <target state="translated">您可能希望模拟对象将 &lt;code&gt;False&lt;/code&gt; 返回给&lt;a href=&quot;functions#hasattr&quot;&gt; &lt;code&gt;hasattr()&lt;/code&gt; &lt;/a&gt;调用，或者在获取&lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt;时引发AttributeError。您可以通过提供一个对象作为模拟 &lt;code&gt;spec&lt;/code&gt; 来做到这一点，但这并不总是很方便。</target>
        </trans-unit>
        <trans-unit id="332990ee9355f487c806f435103a83563f35c4ce" translate="yes" xml:space="preserve">
          <source>You might also try:</source>
          <target state="translated">你也可以试试。</target>
        </trans-unit>
        <trans-unit id="d5406fdd2ad0d5807786d625bddb416283fad614" translate="yes" xml:space="preserve">
          <source>You might want to override this method if you want to convert the record to a dict or JSON string, or send a modified copy of the record while leaving the original intact.</source>
          <target state="translated">如果你想将记录转换为dict或JSON字符串,或者发送一个修改后的记录副本,同时保持原始记录的完整性,你可能需要覆盖这个方法。</target>
        </trans-unit>
        <trans-unit id="52e922832e7caa53085050a22089bcfc200171f5" translate="yes" xml:space="preserve">
          <source>You mock magic methods by setting the method you are interested in to a function or a mock instance. If you are using a function then it &lt;em&gt;must&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as the first argument &lt;a href=&quot;#id10&quot; id=&quot;id8&quot;&gt;3&lt;/a&gt;.</source>
          <target state="translated">您可以通过将感兴趣的方法设置为函数或模拟实例来模拟魔术方法。如果使用的是函数，则&lt;em&gt;必须&lt;/em&gt;将 &lt;code&gt;self&lt;/code&gt; 作为第一个参数&lt;a href=&quot;#id10&quot; id=&quot;id8&quot;&gt;3&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09b20a74562a4b523aea5e75b3238fba4872f230" translate="yes" xml:space="preserve">
          <source>You must fully initialize the parsers before passing them via &lt;code&gt;parents=&lt;/code&gt;. If you change the parent parsers after the child parser, those changes will not be reflected in the child.</source>
          <target state="translated">您必须完全初始化解析器，然后才能通过 &lt;code&gt;parents=&lt;/code&gt; 传递解析器。如果您在子解析器之后更改父解析器，则这些更改将不会反映在子解析器中。</target>
        </trans-unit>
        <trans-unit id="094bc364ccd654aa3f90655ab2f56388f1bc3a61" translate="yes" xml:space="preserve">
          <source>You must have enough privileges to access the shadow password database (this usually means you have to be root).</source>
          <target state="translated">你必须有足够的权限来访问影子密码数据库(这通常意味着你必须是root)。</target>
        </trans-unit>
        <trans-unit id="6b23fc7062bc1845bf77eb0ae69f21c191174259" translate="yes" xml:space="preserve">
          <source>You need to derive a concrete subclass, and (at least) supply implementations of the standard &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods needed by the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; methods you use. The &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module provides &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;, a simple concrete subclass of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; which can represent timezones with fixed offset from UTC such as UTC itself or North American EST and EDT.</source>
          <target state="translated">您需要派生一个具体的子类，并且（至少）提供所使用的&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;方法所需的标准&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;方法的实现。的&lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;模块提供&lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt;，一个简单的具体子类&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;其可以表示与从UTC固定偏移，如UTC本身或北美EST和EDT时区。</target>
        </trans-unit>
        <trans-unit id="7740fbb5cd79d6ed8c08a1c933712cfcb8fda34d" translate="yes" xml:space="preserve">
          <source>You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a &lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt;&lt;code&gt;create_string_buffer()&lt;/code&gt;&lt;/a&gt; function which creates these in various ways. The current memory block contents can be accessed (or changed) with the &lt;code&gt;raw&lt;/code&gt; property; if you want to access it as NUL terminated string, use the &lt;code&gt;value&lt;/code&gt; property:</source>
          <target state="translated">但是，您应注意不要将它们传递给期望指向可变内存的指针的函数。如果您需要可变的内存块，则ctypes具有一个&lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt; &lt;code&gt;create_string_buffer()&lt;/code&gt; &lt;/a&gt;函数，该函数可以通过各种方式创建它们。可以使用 &lt;code&gt;raw&lt;/code&gt; 属性访问（或更改）当前存储块的内容。如果要以NUL终止的字符串访问它，请使用 &lt;code&gt;value&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="0b1f3cec241149216d9168d1204ff3d17a2754cc" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;https://creativecommons.org/publicdomain/zero/1.0/&lt;/a&gt;.</source>
          <target state="translated">您应该已经与该软件一起收到了CC0公共域专用证书的副本。如果不是，请参阅&lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;https://creativecommons.org/publicdomain/zero/1.0/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aed8e41ce1b3c70de9323f77dbec3def95dca2b2" translate="yes" xml:space="preserve">
          <source>You should implement this method if the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method of your class requires keyword-only arguments. Otherwise, it is recommended for compatibility to implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您类的&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt;方法需要仅使用关键字的参数，则应实现此方法。否则，建议实现&lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt;以获得兼容性。</target>
        </trans-unit>
        <trans-unit id="4426329de7889e8e5e4d602d5363ef6bb0119a4c" translate="yes" xml:space="preserve">
          <source>You should implement this method if the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method of your class requires keyword-only arguments. Otherwise, it is recommended for compatibility to implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您类的&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt;方法需要仅使用关键字的参数，则应实现此方法。否则，为了实现兼容性，建议实现&lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="608bdf7953eb348170dc085e02eb0651f71c21f7" translate="yes" xml:space="preserve">
          <source>You should report this to the author or maintainer of your Python interpreter. Be sure to report the version of the Python interpreter (&lt;code&gt;sys.version&lt;/code&gt;; it is also printed at the start of an interactive Python session), the exact error message (the exception&amp;rsquo;s associated value) and if possible the source of the program that triggered the error.</source>
          <target state="translated">您应该将此报告给Python解释器的作者或维护者。请确保报告Python解释器的版本（ &lt;code&gt;sys.version&lt;/code&gt; ；它也将在交互式Python会话的开始时显示），确切的错误消息（与异常相关的值）以及可能的情况下触发该程序的源。错误。</target>
        </trans-unit>
        <trans-unit id="b6c782fc647ff3aa498d746efee7b7356d8e5253" translate="yes" xml:space="preserve">
          <source>You shouldn&amp;rsquo;t need to format this yourself.</source>
          <target state="translated">您无需自己格式化。</target>
        </trans-unit>
        <trans-unit id="b88788ab2aad4e62798ccc5bda983ef8733f0b94" translate="yes" xml:space="preserve">
          <source>You want to make sure that your code only manipulates paths without actually accessing the OS. In this case, instantiating one of the pure classes may be useful since those simply don&amp;rsquo;t have any OS-accessing operations.</source>
          <target state="translated">您要确保您的代码仅操纵路径而没有实际访问操作系统。在这种情况下，实例化纯类之一可能会很有用，因为它们根本没有任何OS访问操作。</target>
        </trans-unit>
        <trans-unit id="916096316bc5b5aae5496f6bd41e8229ed9c923a" translate="yes" xml:space="preserve">
          <source>Your App Here (Python)</source>
          <target state="translated">你的应用程序在这里 (Python)</target>
        </trans-unit>
        <trans-unit id="ef1c084cf7519afce21379d5a8c3eb6c5c1b462b" translate="yes" xml:space="preserve">
          <source>Your tests can pass silently and incorrectly because of the typo.</source>
          <target state="translated">你的测试可能因为错别字而无声无息地通过。</target>
        </trans-unit>
        <trans-unit id="2e2020bd4ed774a09d2ace95d49cf92fbcbd6e4c" translate="yes" xml:space="preserve">
          <source>ZIP flag bits.</source>
          <target state="translated">ZIP标志位。</target>
        </trans-unit>
        <trans-unit id="3bf3f71c4d3d91d72b09100088bc05f6648939f4" translate="yes" xml:space="preserve">
          <source>ZeroDivisionError</source>
          <target state="translated">ZeroDivisionError</target>
        </trans-unit>
        <trans-unit id="b44e96f9df87d40173b4e4687155b468a0e9dfd0" translate="yes" xml:space="preserve">
          <source>ZipFile Objects</source>
          <target state="translated">Zip文件对象</target>
        </trans-unit>
        <trans-unit id="d3c28efb247369df3c23761952bb20eddb7ead55" translate="yes" xml:space="preserve">
          <source>ZipFile is also a context manager and therefore supports the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. In the example, &lt;em&gt;myzip&lt;/em&gt; is closed after the &lt;code&gt;with&lt;/code&gt; statement&amp;rsquo;s suite is finished&amp;mdash;even if an exception occurs:</source>
          <target state="translated">ZipFile还是上下文管理器，因此支持&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句。在该示例中， &lt;code&gt;with&lt;/code&gt; 语句的套件完成后，&lt;em&gt;myzip&lt;/em&gt;关闭-即使发生异常：</target>
        </trans-unit>
        <trans-unit id="502e78ecee4a8d17fd59824d3b090f299b014bbf" translate="yes" xml:space="preserve">
          <source>ZipFile is also a context manager and therefore supports the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. In the example, &lt;em&gt;myzip&lt;/em&gt; is closed after the &lt;code&gt;with&lt;/code&gt; statement&amp;rsquo;s suite is finished&amp;mdash;even if an exception occurs:</source>
          <target state="translated">ZipFile还是上下文管理器，因此支持&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句。在此示例中， &lt;code&gt;with&lt;/code&gt; 语句的套件完成后，&lt;em&gt;myzip&lt;/em&gt;将关闭，即使发生异常也是如此：</target>
        </trans-unit>
        <trans-unit id="32dece39948d14cba87cb98ecec9b9ed1ae759c7" translate="yes" xml:space="preserve">
          <source>ZipInfo Objects</source>
          <target state="translated">ZipInfo对象</target>
        </trans-unit>
        <trans-unit id="1c1f3fc8258eaf3393e718a8a2747228a7fb364a" translate="yes" xml:space="preserve">
          <source>Zoom/Restore Height</source>
          <target state="translated">缩放/恢复高度</target>
        </trans-unit>
        <trans-unit id="817238a139f150e9f4f1383dbd74c0b91ee8bae0" translate="yes" xml:space="preserve">
          <source>__annotations__</source>
          <target state="translated">__annotations__</target>
        </trans-unit>
        <trans-unit id="f409f35afb6adb9d0745380c602ca135f47ef811" translate="yes" xml:space="preserve">
          <source>__code__</source>
          <target state="translated">__code__</target>
        </trans-unit>
        <trans-unit id="62bbeb1e267c62609bdf2f95e593915d20733a27" translate="yes" xml:space="preserve">
          <source>__debug__</source>
          <target state="translated">__debug__</target>
        </trans-unit>
        <trans-unit id="a0ea0ae317994102ce4319f4d6a770bf60eb5981" translate="yes" xml:space="preserve">
          <source>__defaults__</source>
          <target state="translated">__defaults__</target>
        </trans-unit>
        <trans-unit id="2922e12594306ed2f517ef5a341de5247c8c8b83" translate="yes" xml:space="preserve">
          <source>__doc__</source>
          <target state="translated">__doc__</target>
        </trans-unit>
        <trans-unit id="c75fde63c1afd749e27a30c936498ccc7b596d55" translate="yes" xml:space="preserve">
          <source>__file__</source>
          <target state="translated">__file__</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="05a73385f8915931c595c28004a15b3861ea5391" translate="yes" xml:space="preserve">
          <source>__future__</source>
          <target state="translated">__future__</target>
        </trans-unit>
        <trans-unit id="8243a95f4a52e809ca3146b71b1c4eb64e88daec" translate="yes" xml:space="preserve">
          <source>__future__ &amp;mdash; Future statement definitions</source>
          <target state="translated">__future__ &amp;mdash;将来的语句定义</target>
        </trans-unit>
        <trans-unit id="42a6b9c717b079d3902c3d927cc73c750f401249" translate="yes" xml:space="preserve">
          <source>__globals__</source>
          <target state="translated">__globals__</target>
        </trans-unit>
        <trans-unit id="7fa022a1dbbda2854490c44ddb9bbf67c875072a" translate="yes" xml:space="preserve">
          <source>__import__()</source>
          <target state="translated">__import__()</target>
        </trans-unit>
        <trans-unit id="8f67cc8062d70ff192a2db59e5936d1454a10513" translate="yes" xml:space="preserve">
          <source>__kwdefaults__</source>
          <target state="translated">__kwdefaults__</target>
        </trans-unit>
        <trans-unit id="3a64a9fca18e24c6cc560c53c3603d38f21d45e1" translate="yes" xml:space="preserve">
          <source>__main__</source>
          <target state="translated">__main__</target>
        </trans-unit>
        <trans-unit id="67b7e3744be66edbab900391343b344e45582311" translate="yes" xml:space="preserve">
          <source>__main__ &amp;mdash; Top-level script environment</source>
          <target state="translated">__main__ &amp;mdash;顶级脚本环境</target>
        </trans-unit>
        <trans-unit id="dafa226dd7478c948168cc8fe05f819f78f92608" translate="yes" xml:space="preserve">
          <source>__module__</source>
          <target state="translated">__module__</target>
        </trans-unit>
        <trans-unit id="c1dab70a8cae8ab6675cd1dd0933150036c91264" translate="yes" xml:space="preserve">
          <source>__name__</source>
          <target state="translated">__name__</target>
        </trans-unit>
        <trans-unit id="507d7fdd431c9a0168a6ce7ab07d6fddb7444e35" translate="yes" xml:space="preserve">
          <source>__qualname__</source>
          <target state="translated">__qualname__</target>
        </trans-unit>
        <trans-unit id="85e18720c20496ae00ef9cf6b8aa9ea49b266a6b" translate="yes" xml:space="preserve">
          <source>__self__</source>
          <target state="translated">__self__</target>
        </trans-unit>
        <trans-unit id="64f034dabbb4855ca6a80405bbada75a41e4f8cc" translate="yes" xml:space="preserve">
          <source>_dummy_thread</source>
          <target state="translated">_dummy_thread</target>
        </trans-unit>
        <trans-unit id="05d8fbde3570a77c3787f305a76091073da240c1" translate="yes" xml:space="preserve">
          <source>_dummy_thread &amp;mdash; Drop-in replacement for the _thread module</source>
          <target state="translated">_dummy_thread &amp;mdash; _thread模块的直接替换</target>
        </trans-unit>
        <trans-unit id="415e8b762f52dba735a8941f5c118bbcbe9c97d0" translate="yes" xml:space="preserve">
          <source>_thread</source>
          <target state="translated">_thread</target>
        </trans-unit>
        <trans-unit id="da5b2839c3debda59dc6d44d96457dca817c02c5" translate="yes" xml:space="preserve">
          <source>_thread &amp;mdash; Low-level threading API</source>
          <target state="translated">_thread &amp;mdash;低级线程API</target>
        </trans-unit>
        <trans-unit id="1197d3e3671fe302e212fc6e01a5599df1e24739" translate="yes" xml:space="preserve">
          <source>_thread.LockType</source>
          <target state="translated">_thread.LockType</target>
        </trans-unit>
        <trans-unit id="10b6524890c56d7b3c9d02dd5f9974643c3f4270" translate="yes" xml:space="preserve">
          <source>_thread.TIMEOUT_MAX</source>
          <target state="translated">_thread.TIMEOUT_MAX</target>
        </trans-unit>
        <trans-unit id="e53d1af9d5893b2846a539cfb58a8f7a8d22c89e" translate="yes" xml:space="preserve">
          <source>_thread.allocate_lock()</source>
          <target state="translated">_thread.allocate_lock()</target>
        </trans-unit>
        <trans-unit id="197f373125020edee90662419f7aad02a7b9c17d" translate="yes" xml:space="preserve">
          <source>_thread.error</source>
          <target state="translated">_thread.error</target>
        </trans-unit>
        <trans-unit id="f77734f9a672561ada2f9d806095e7dfabbef029" translate="yes" xml:space="preserve">
          <source>_thread.exit()</source>
          <target state="translated">_thread.exit()</target>
        </trans-unit>
        <trans-unit id="5c63f8bac316bfc2484ee6625f020abc63787523" translate="yes" xml:space="preserve">
          <source>_thread.get_ident()</source>
          <target state="translated">_thread.get_ident()</target>
        </trans-unit>
        <trans-unit id="6ac74f7dc2c2fc2ce38eefb755e928f8633dea0f" translate="yes" xml:space="preserve">
          <source>_thread.get_native_id()</source>
          <target state="translated">_thread.get_native_id()</target>
        </trans-unit>
        <trans-unit id="d0da4946a68555999c188366affeae7b761778a5" translate="yes" xml:space="preserve">
          <source>_thread.interrupt_main()</source>
          <target state="translated">_thread.interrupt_main()</target>
        </trans-unit>
        <trans-unit id="9d73ffbe13b07689c72d68cf3437ff8586dc3977" translate="yes" xml:space="preserve">
          <source>_thread.lock.acquire()</source>
          <target state="translated">_thread.lock.acquire()</target>
        </trans-unit>
        <trans-unit id="a66a2bd7cd05e13cbc2c202fe9970f286f342d5b" translate="yes" xml:space="preserve">
          <source>_thread.lock.locked()</source>
          <target state="translated">_thread.lock.locked()</target>
        </trans-unit>
        <trans-unit id="d9d44b39308b962300683283a9f5c9e4432e993d" translate="yes" xml:space="preserve">
          <source>_thread.lock.release()</source>
          <target state="translated">_thread.lock.release()</target>
        </trans-unit>
        <trans-unit id="92e76f45930236545f796bf83967a90dae1c5dae" translate="yes" xml:space="preserve">
          <source>_thread.stack_size()</source>
          <target state="translated">_thread.stack_size()</target>
        </trans-unit>
        <trans-unit id="fafa7fa9e2fa93f20e14a4830e70ee7f5c7a4195" translate="yes" xml:space="preserve">
          <source>_thread.start_new_thread()</source>
          <target state="translated">_thread.start_new_thread()</target>
        </trans-unit>
        <trans-unit id="e57494049e3e9cb998a365df5ebf284df3d8cd6d" translate="yes" xml:space="preserve">
          <source>_tkinter (C)</source>
          <target state="translated">_tkinter（C）</target>
        </trans-unit>
        <trans-unit id="cf88a375687c70756a66d746b4ebd426c66dbb60" translate="yes" xml:space="preserve">
          <source>_winapi.CreateFile</source>
          <target state="translated">_winapi.CreateFile</target>
        </trans-unit>
        <trans-unit id="a1a90d648c83f9aabd0d2a0dacb93d3412e6d995" translate="yes" xml:space="preserve">
          <source>_winapi.CreateJunction</source>
          <target state="translated">_winapi.CreateJunction</target>
        </trans-unit>
        <trans-unit id="5ca29ded1fb74a7907ca7408a90e333780366dc4" translate="yes" xml:space="preserve">
          <source>_winapi.CreateNamedPipe</source>
          <target state="translated">_winapi.CreateNamedPipe</target>
        </trans-unit>
        <trans-unit id="dc51e4276a5e454e6c63094807a9c12f2ad1f2f6" translate="yes" xml:space="preserve">
          <source>_winapi.CreatePipe</source>
          <target state="translated">_winapi.CreatePipe</target>
        </trans-unit>
        <trans-unit id="dcce143154225c5a0ab697cb248ee9c2fba45c2d" translate="yes" xml:space="preserve">
          <source>_winapi.CreateProcess</source>
          <target state="translated">_winapi.CreateProcess</target>
        </trans-unit>
        <trans-unit id="5e9194d15423b1a890eeb18441f1c13c49032b82" translate="yes" xml:space="preserve">
          <source>_winapi.OpenProcess</source>
          <target state="translated">_winapi.OpenProcess</target>
        </trans-unit>
        <trans-unit id="193eeb1b9fc659d49913a0171364814314d95fb7" translate="yes" xml:space="preserve">
          <source>_winapi.TerminateProcess</source>
          <target state="translated">_winapi.TerminateProcess</target>
        </trans-unit>
        <trans-unit id="884a8a81095a6c975cc5f46c5535aca47a40cc29" translate="yes" xml:space="preserve">
          <source>a (graphical) breadth first tree (using generators)</source>
          <target state="translated">广度第一树(使用生成器)</target>
        </trans-unit>
        <trans-unit id="2a3c787e15c30f9b3971b501cda113129f37b40e" translate="yes" xml:space="preserve">
          <source>a 4:1 compressed format defined by the Interactive Multimedia Association</source>
          <target state="translated">互动多媒体协会定义的4:1压缩格式。</target>
        </trans-unit>
        <trans-unit id="2a607ef8d6e4ef1cfa7c1eb06d4c3bf4e4ce6fb6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object that would await on &lt;em&gt;obj&lt;/em&gt;, if &lt;em&gt;obj&lt;/em&gt; is an awaitable (&lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; is used for the test.)</source>
          <target state="translated">如果&lt;em&gt;obj&lt;/em&gt;是awaitable ，则将在&lt;em&gt;obj上&lt;/em&gt;等待的&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象&lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt;测试使用inspect.isawaitable（）。）&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5940cf955ef1b31a29e37f1f63d6add86f7a107" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object wrapping &lt;em&gt;obj&lt;/em&gt;, if &lt;em&gt;obj&lt;/em&gt; is a coroutine (&lt;a href=&quot;asyncio-task#asyncio.iscoroutine&quot;&gt;&lt;code&gt;iscoroutine()&lt;/code&gt;&lt;/a&gt; is used for the test); in this case the coroutine will be scheduled by &lt;code&gt;ensure_future()&lt;/code&gt;.</source>
          <target state="translated">一个包装&lt;em&gt;obj&lt;/em&gt;的&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象，如果&lt;em&gt;obj&lt;/em&gt;是一个协程（&lt;a href=&quot;asyncio-task#asyncio.iscoroutine&quot;&gt; &lt;code&gt;iscoroutine()&lt;/code&gt; &lt;/a&gt;用于测试）；在这种情况下，协程将通过 &lt;code&gt;ensure_future()&lt;/code&gt; 进行调度。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60f2374ba0e896c62e9d0dd5eb89cdd040867b25" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine function&lt;/em&gt;: an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; function;</source>
          <target state="translated">一个&lt;em&gt;协程功能&lt;/em&gt;：一个&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt;功能;</target>
        </trans-unit>
        <trans-unit id="cc72dc913dfd037f65ff0c8fc40195445cf586b1" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine function&lt;/em&gt;: an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; function;</source>
          <target state="translated">一个&lt;em&gt;协程功能&lt;/em&gt;：一个&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt;功能;</target>
        </trans-unit>
        <trans-unit id="f127c8970e8aa4599e65040eeb62944bf8597ce0" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine object&lt;/em&gt;: an object returned by calling a &lt;em&gt;coroutine function&lt;/em&gt;.</source>
          <target state="translated">一个&lt;em&gt;协程对象&lt;/em&gt;：通过调用返回的对象&lt;em&gt;协程功能&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3911806e29cd9080090236543824b5efe243359e" translate="yes" xml:space="preserve">
          <source>a Future-like object with a &lt;code&gt;_asyncio_future_blocking&lt;/code&gt; attribute.</source>
          <target state="translated">具有 &lt;code&gt;_asyncio_future_blocking&lt;/code&gt; 属性的类似Future的对象。</target>
        </trans-unit>
        <trans-unit id="5891a4d5a151f585a0c68c891e76d580817faf7b" translate="yes" xml:space="preserve">
          <source>a Microsoft Windows code page, which is typically derived from an 8859 codeset, but replaces control characters with additional graphic characters</source>
          <target state="translated">微软视窗代码页,它通常由8859代码集衍生而来,但用额外的图形字符代替了控制字符。</target>
        </trans-unit>
        <trans-unit id="933e55c18eda96ea117a68f16b3c87e563cf2584" translate="yes" xml:space="preserve">
          <source>a character string or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object representing the path to the file which will be opened. In this case closefd must be &lt;code&gt;True&lt;/code&gt; (the default) otherwise an error will be raised.</source>
          <target state="translated">一个字符串或&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;对象，代表将要打开的文件的路径。在这种情况下，closefd必须为 &lt;code&gt;True&lt;/code&gt; （默认值），否则将引发错误。</target>
        </trans-unit>
        <trans-unit id="176fa9b59e72ef5e9b661ef430b1c1b283c9b900" translate="yes" xml:space="preserve">
          <source>a complex number with real part &lt;em&gt;re&lt;/em&gt;, imaginary part &lt;em&gt;im&lt;/em&gt;. &lt;em&gt;im&lt;/em&gt; defaults to zero.</source>
          <target state="translated">一个复数，实数部分为&lt;em&gt;re&lt;/em&gt;，虚数部分为&lt;em&gt;im&lt;/em&gt;。&lt;em&gt;im&lt;/em&gt;默认为零。</target>
        </trans-unit>
        <trans-unit id="04cb47559c45099cd55090b108360692573d92cd" translate="yes" xml:space="preserve">
          <source>a connected and readable &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt; object; or</source>
          <target state="translated">连接且可读的&lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt;对象；要么</target>
        </trans-unit>
        <trans-unit id="c913dab07a3e871b091d09309c9a97d8b988174f" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard error stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个类似于文件的对象，表示使用&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt;连接到子流程的标准错误流的管道</target>
        </trans-unit>
        <trans-unit id="1b8f3cba0ae0c31b00f743c2c6d5a5b70d8654de" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard input stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">类似于文件的对象，表示使用&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt;连接到子流程的标准输入流的管道</target>
        </trans-unit>
        <trans-unit id="58ab911c5e7c464d2be123c8d268865bad923208" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard output stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">类似于文件的对象，表示使用&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt;连接到子流程的标准输出流的管道</target>
        </trans-unit>
        <trans-unit id="386f15c8139cf75838d497f40399a9103a530d1f" translate="yes" xml:space="preserve">
          <source>a labelled instruction, indicated with &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,</source>
          <target state="translated">标记的指令，以指示 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="7f0697684cc35bd1f5f3599ded2ae60e4e90d78e" translate="yes" xml:space="preserve">
          <source>a list of all received parameters to the &lt;code&gt;MAIL&lt;/code&gt; command (the elements are uppercase strings; example: &lt;code&gt;['BODY=8BITMIME', 'SMTPUTF8']&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MAIL&lt;/code&gt; 命令的所有已接收参数的列表（这些元素是大写字符串；例如： &lt;code&gt;['BODY=8BITMIME', 'SMTPUTF8']&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ebfac224217452ba9a90f212a902ee1a47ab2ecc" translate="yes" xml:space="preserve">
          <source>a logarithmic encoding</source>
          <target state="translated">对数编码</target>
        </trans-unit>
        <trans-unit id="fc1acc3823ec59584f589d733c73ebf69a828ee4" translate="yes" xml:space="preserve">
          <source>a logarithmic encoding (used by Sun &lt;code&gt;.au&lt;/code&gt; files and &lt;code&gt;/dev/audio&lt;/code&gt;)</source>
          <target state="translated">对数编码（由Sun &lt;code&gt;.au&lt;/code&gt; 文件和 &lt;code&gt;/dev/audio&lt;/code&gt; 使用）</target>
        </trans-unit>
        <trans-unit id="3cbc86209c99fc06fedc28d20e4c6998dc771f44" translate="yes" xml:space="preserve">
          <source>a pattern from the wikipedia article on turtle graphics</source>
          <target state="translated">维基百科上关于海龟图形的文章中的一种模式。</target>
        </trans-unit>
        <trans-unit id="48bc4d762f4726ec868d6099b805944b28af3288" translate="yes" xml:space="preserve">
          <source>a polygon-tuple, i.e. a tuple of pairs of coordinates</source>
          <target state="translated">多边形元组</target>
        </trans-unit>
        <trans-unit id="d95f33def911a2c6829c8462e2721a2559400b0d" translate="yes" xml:space="preserve">
          <source>a readable &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object;</source>
          <target state="translated">可读的&lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;对象；</target>
        </trans-unit>
        <trans-unit id="f0901badac04f3b74bfcc02503440581292c0bb3" translate="yes" xml:space="preserve">
          <source>a text string that is pattern matched against the label of the menu entry, as scanned from the top of the menu to the bottom. Note that this index type is considered after all the others, which means that matches for menu items labelled &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; may be interpreted as the above literals, instead.</source>
          <target state="translated">从菜单顶部到底部扫描的，与菜单项的标签模式匹配的文本字符串。请注意，此索引类型在所有其他索引类型之后才被考虑，这意味着标记为 &lt;code&gt;last&lt;/code&gt; ， &lt;code&gt;active&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; 的菜单项的匹配项可以解释为上述文字。</target>
        </trans-unit>
        <trans-unit id="05df3d7b372bd2ddee06b6095e01e0e750c166b5" translate="yes" xml:space="preserve">
          <source>a write occurred</source>
          <target state="translated">动笔</target>
        </trans-unit>
        <trans-unit id="4afe0f0bc0033bb9859082e1c5eae63420774b7a" translate="yes" xml:space="preserve">
          <source>abbreviation of timezone name</source>
          <target state="translated">时区名称的缩写</target>
        </trans-unit>
        <trans-unit id="a9993e364706816aba3e25717850c26c9cd0d89d" translate="yes" xml:space="preserve">
          <source>abc</source>
          <target state="translated">abc</target>
        </trans-unit>
        <trans-unit id="c08753fb4d9d1abe3ccddc9ff169db6e7c7528c6" translate="yes" xml:space="preserve">
          <source>abc &amp;mdash; Abstract Base Classes</source>
          <target state="translated">abc &amp;mdash;抽象基类</target>
        </trans-unit>
        <trans-unit id="bf9ea26d3d8e8312edf5a0bebaf7517d3a4dd7e1" translate="yes" xml:space="preserve">
          <source>abc.ABC</source>
          <target state="translated">abc.ABC</target>
        </trans-unit>
        <trans-unit id="ba245dfb03cc341cb848315c70bc52fbf739961d" translate="yes" xml:space="preserve">
          <source>abc.ABCMeta</source>
          <target state="translated">abc.ABCMeta</target>
        </trans-unit>
        <trans-unit id="c29b9fa83144882e32d4099551dd42373c86d00c" translate="yes" xml:space="preserve">
          <source>abc.ABCMeta.__subclasshook__()</source>
          <target state="translated">abc.ABCMeta.__subclasshook__()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
