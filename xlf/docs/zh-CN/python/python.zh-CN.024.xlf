<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="e9372d8280e154ef7bd8cce1cb9067cf0ac6b897" translate="yes" xml:space="preserve">
          <source>The output of each example is checked using the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s output checker, and the results are formatted by the &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; methods.</source>
          <target state="translated">使用&lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt;的输出检查器检查每个示例的输出，并通过 &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; 方法对结果进行格式化。</target>
        </trans-unit>
        <trans-unit id="585c88899418582ad73321158b0178e16e458068" translate="yes" xml:space="preserve">
          <source>The output of the example should look exactly like for the TCP server example.</source>
          <target state="translated">这个例子的输出应该和TCP服务器的例子一模一样。</target>
        </trans-unit>
        <trans-unit id="00ef8f2fda1209e9f49161aa09f6645d996d526e" translate="yes" xml:space="preserve">
          <source>The output of the example should look something like this:</source>
          <target state="translated">这个例子的输出应该是这样的。</target>
        </trans-unit>
        <trans-unit id="2ddac9a02ca6d6738022c8b8534a979f5593d7ce" translate="yes" xml:space="preserve">
          <source>The output string will &lt;em&gt;not&lt;/em&gt; include time zone information, regardless of whether the input is aware or naive.</source>
          <target state="translated">无论输入是感知还是天真，输出字符串都&lt;em&gt;不会&lt;/em&gt;包含时区信息。</target>
        </trans-unit>
        <trans-unit id="6fc487de6f88b00ecc2f348b90e17727ccc9ccff" translate="yes" xml:space="preserve">
          <source>The output will then be:</source>
          <target state="translated">届时输出的将是。</target>
        </trans-unit>
        <trans-unit id="30e8eaae13d1dea954788334f3c9bd5becb2d6c6" translate="yes" xml:space="preserve">
          <source>The overall structure of the email package can be divided into three major components, plus a fourth component that controls the behavior of the other components.</source>
          <target state="translated">邮件包的整体结构可以分为三个主要组件,加上第四个组件,控制其他组件的行为。</target>
        </trans-unit>
        <trans-unit id="1ce355a2a46493371466043965a6b586867e0a7c" translate="yes" xml:space="preserve">
          <source>The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples:</source>
          <target state="translated">可以使用关键字-选项/值对调用pack()方法,这些关键字-选项/值对控制小组件在其容器中的出现位置,以及在主应用程序窗口调整大小时的表现。下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="43d505e6a2e7c36776ba82d594697f730f5d036e" translate="yes" xml:space="preserve">
          <source>The package contents can be roughly split into four parts: low-level CAB routines, low-level MSI routines, higher-level MSI routines, and standard table structures.</source>
          <target state="translated">软件包内容大致可以分为四个部分:低级CAB例程、低级MSI例程、高级MSI例程和标准表结构。</target>
        </trans-unit>
        <trans-unit id="b5e085f5fbf738e12557a40f2cfd7aded4c065ac" translate="yes" xml:space="preserve">
          <source>The packer is one of Tk&amp;rsquo;s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of the positioning of widgets within their container - their mutual &lt;em&gt;master&lt;/em&gt;. In contrast to the more cumbersome &lt;em&gt;placer&lt;/em&gt; (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - &lt;em&gt;above&lt;/em&gt;, &lt;em&gt;to the left of&lt;/em&gt;, &lt;em&gt;filling&lt;/em&gt;, etc - and works everything out to determine the exact placement coordinates for you.</source>
          <target state="translated">封隔器是Tk的几何管理机制之一。几何管理器用于指定窗口小部件在其容器中的相对位置-它们的共同&lt;em&gt;母版&lt;/em&gt;。与较为繁琐的&lt;em&gt;放置器&lt;/em&gt;（不常用的&lt;em&gt;放置器&lt;/em&gt;，我们不在此介绍）相比，打包机采用了定性关系规范- &lt;em&gt;上方（位于&lt;/em&gt;，&lt;em&gt;左侧&lt;/em&gt;，&lt;em&gt;填充&lt;/em&gt;等）-进行所有操作以确定确切的放置坐标为了你。</target>
        </trans-unit>
        <trans-unit id="d00bfaddba4b6a311bea1718f0f6923a76662ed2" translate="yes" xml:space="preserve">
          <source>The packer is one of Tk&amp;rsquo;s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual &lt;em&gt;master&lt;/em&gt;. In contrast to the more cumbersome &lt;em&gt;placer&lt;/em&gt; (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - &lt;em&gt;above&lt;/em&gt;, &lt;em&gt;to the left of&lt;/em&gt;, &lt;em&gt;filling&lt;/em&gt;, etc - and works everything out to determine the exact placement coordinates for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253cb8189b2936e9dc31ecb164b214955e29b52e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;do_handshake_on_connect&lt;/code&gt; specifies whether to do the SSL handshake automatically after doing a &lt;code&gt;socket.connect()&lt;/code&gt;, or whether the application program will call it explicitly, by invoking the &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; method. Calling &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; explicitly gives the program control over the blocking behavior of the socket I/O involved in the handshake.</source>
          <target state="translated">参数 &lt;code&gt;do_handshake_on_connect&lt;/code&gt; 指定是在执行 &lt;code&gt;socket.connect()&lt;/code&gt; 之后自动执行SSL握手，还是通过调用&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt;方法来使应用程序显式调用它。调用&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; 可以&lt;/a&gt;使程序对握手中涉及的套接字I / O的阻塞行为进行控制。</target>
        </trans-unit>
        <trans-unit id="7e2325d973c251eaad6d5fa92d991f2af2611734" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;server_side&lt;/code&gt; is a boolean which identifies whether server-side or client-side behavior is desired from this socket.</source>
          <target state="translated">参数 &lt;code&gt;server_side&lt;/code&gt; 是一个布尔值，它标识此套接字是否需要服务器端或客户端行为。</target>
        </trans-unit>
        <trans-unit id="823e6e4ffdf11c7805d8ae352770d5ed2e9f8a18" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;suppress_ragged_eofs&lt;/code&gt; specifies how the &lt;code&gt;SSLSocket.recv()&lt;/code&gt; method should signal unexpected EOF from the other end of the connection. If specified as &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; (the default), it returns a normal EOF (an empty bytes object) in response to unexpected EOF errors raised from the underlying socket; if &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, it will raise the exceptions back to the caller.</source>
          <target state="translated">参数 &lt;code&gt;suppress_ragged_eofs&lt;/code&gt; 指定 &lt;code&gt;SSLSocket.recv()&lt;/code&gt; 方法应如何从连接的另一端发出意外的EOF信号。如果指定为&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;（默认值），它会响应于从底层套接字引发的意外EOF错误而返回正常的EOF（空字节对象）。如果为&lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;，它将引发异常返回给调用者。</target>
        </trans-unit>
        <trans-unit id="425f1ffaff5f611531ca4dc03dbc5808560f4199" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;arg&lt;/em&gt; can be one of an integer, an object supporting the read-only buffer interface (like &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) or an object supporting the read-write buffer interface (like &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">参数&lt;em&gt;arg&lt;/em&gt;可以是整数之一，可以是支持只读缓冲区接口的对象（如&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;），也可以是支持读写缓冲区接口的对象（如&lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="07f0e19bb360bd19a1a80e689ce45296940e8971" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;reuse_address&lt;/em&gt; is no longer supported, as using &lt;code&gt;SO_REUSEADDR&lt;/code&gt; poses a significant security concern for UDP. Explicitly passing &lt;code&gt;reuse_address=True&lt;/code&gt; will raise an exception.</source>
          <target state="translated">参数&lt;em&gt;重用&lt;/em&gt;地址不再受支持，因为使用 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 会严重影响UDP的安全性。显式传递 &lt;code&gt;reuse_address=True&lt;/code&gt; 将引发异常。</target>
        </trans-unit>
        <trans-unit id="e3d9bf8f3c1e1166d31d759e64e3dbeea2b50d58" translate="yes" xml:space="preserve">
          <source>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</source>
          <target state="translated">参数解释可以识别局部和全局变量名、常量值、分支目标和比较运算符。</target>
        </trans-unit>
        <trans-unit id="4364023a096cfc76a5aaccc26d05253c492b0d07" translate="yes" xml:space="preserve">
          <source>The parameters are as for &lt;code&gt;FileHandler&lt;/code&gt;. The attributes are:</source>
          <target state="translated">参数与 &lt;code&gt;FileHandler&lt;/code&gt; 相同。这些属性是：</target>
        </trans-unit>
        <trans-unit id="328fb050a12d6f49d22d231e4d9497b6bf6996e1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt;的参数为：</target>
        </trans-unit>
        <trans-unit id="4121375e3f99104ec54ea4f3d41c8050dcbed2d1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt;的参数为：</target>
        </trans-unit>
        <trans-unit id="8b0533de393e7b886a40041244b0c1cf85c2921d" translate="yes" xml:space="preserve">
          <source>The parameters to the constructor are the same as those for &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造函数的参数与&lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt;的参数相同。</target>
        </trans-unit>
        <trans-unit id="3db46ab8cdee19add4d74116b81d433cfd3167ac" translate="yes" xml:space="preserve">
          <source>The parent of the current node, or &lt;code&gt;None&lt;/code&gt; for the document node. The value is always a &lt;code&gt;Node&lt;/code&gt; object or &lt;code&gt;None&lt;/code&gt;. For &lt;code&gt;Element&lt;/code&gt; nodes, this will be the parent element, except for the root element, in which case it will be the &lt;code&gt;Document&lt;/code&gt; object. For &lt;code&gt;Attr&lt;/code&gt; nodes, this is always &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">当前节点的父级，或文档节点的&amp;ldquo; &lt;code&gt;None&lt;/code&gt; &amp;rdquo;。该值始终是 &lt;code&gt;Node&lt;/code&gt; 对象或 &lt;code&gt;None&lt;/code&gt; 。对于 &lt;code&gt;Element&lt;/code&gt; 节点，这将是父元素（根元素除外），在这种情况下，它将是 &lt;code&gt;Document&lt;/code&gt; 对象。对于 &lt;code&gt;Attr&lt;/code&gt; 节点，始终为 &lt;code&gt;None&lt;/code&gt; 。这是一个只读属性。</target>
        </trans-unit>
        <trans-unit id="3a3afdd265cba6fd880178e4866ef40903b31ca4" translate="yes" xml:space="preserve">
          <source>The parent package for the module/package. If the module is top-level then it has a value of the empty string. The &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt; decorator can handle the details for &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">模块/程序包的父程序包。如果模块是顶级模块，则其值为空字符串。该&lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt;装饰可以处理的细节&lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1adae70f45cb1346a91a2a0f4115caab6117d269" translate="yes" xml:space="preserve">
          <source>The parent process starts a fresh python interpreter process. The child process will only inherit those resources necessary to run the process objects &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method. In particular, unnecessary file descriptors and handles from the parent process will not be inherited. Starting a process using this method is rather slow compared to using &lt;em&gt;fork&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt;.</source>
          <target state="translated">父进程开始一个全新的python解释器进程。子进程将仅继承运行进程对象&lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;方法所需的那些资源。特别是，父进程中不必要的文件描述符和句柄将不会被继承。与使用&lt;em&gt;fork&lt;/em&gt;或&lt;em&gt;forkserver&lt;/em&gt;相比，使用此方法启动进程的速度相当慢。</target>
        </trans-unit>
        <trans-unit id="369b3db27e2ba62379ec6c6f36a1ad6fef163ee0" translate="yes" xml:space="preserve">
          <source>The parent process uses &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt; to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.</source>
          <target state="translated">父进程使用&lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt;派生Python解释器。子进程开始时实际上与父进程相同。父进程的所有资源均由子进程继承。请注意，安全地分叉多线程进程是有问题的。</target>
        </trans-unit>
        <trans-unit id="595e02418163451e1abf531e59bf4de57ad3c4ec" translate="yes" xml:space="preserve">
          <source>The parse_args() method</source>
          <target state="translated">parse_args()方法</target>
        </trans-unit>
        <trans-unit id="1370400415985cb2cf13a044f34b42c6fd02cbfa" translate="yes" xml:space="preserve">
          <source>The parser determined that the document was not &amp;ldquo;standalone&amp;rdquo; though it declared itself to be in the XML declaration, and the &lt;code&gt;NotStandaloneHandler&lt;/code&gt; was set and returned &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">解析器确定该文档虽然声明自己位于XML声明中，但它不是&amp;ldquo;独立的&amp;rdquo;，并且 &lt;code&gt;NotStandaloneHandler&lt;/code&gt; 已设置并返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45abc8da4046f26f9e15931202a6cfb3bb8736a5" translate="yes" xml:space="preserve">
          <source>The parser for the binary format raises &lt;code&gt;InvalidFileException&lt;/code&gt; when the file cannot be parsed.</source>
          <target state="translated">当无法解析文件时，二进制格式的解析器将引发 &lt;code&gt;InvalidFileException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="315804a5fe161d8d161d75f269b0b17d66a550b3" translate="yes" xml:space="preserve">
          <source>The parser module defines a single exception, but may also pass other built-in exceptions from other portions of the Python runtime environment. See each function for information about the exceptions it can raise.</source>
          <target state="translated">解析器模块定义了一个单一的异常,但也可以传递其他来自 Python 运行时环境其他部分的内置异常。请参阅每个函数以了解它可以引发的异常的信息。</target>
        </trans-unit>
        <trans-unit id="4451c261ab34fa6d68e139583b9b8883047b5ca2" translate="yes" xml:space="preserve">
          <source>The parser module is deprecated and will be removed in future versions of Python. For the majority of use cases you can leverage the Abstract Syntax Tree (AST) generation and compilation stage, using the &lt;a href=&quot;ast#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47584cab28c64372ee0a66e9d6a85d1c121c012c" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; following the colon if there is one, else the entire &lt;code&gt;tagName&lt;/code&gt;. The value is a string.</source>
          <target state="translated">如果有一个 &lt;code&gt;tagName&lt;/code&gt; ,则冒号后面的部分，否则为整个 &lt;code&gt;tagName&lt;/code&gt; 。该值是一个字符串。</target>
        </trans-unit>
        <trans-unit id="775fe3289edf96d060db49b7c4beddb50812e922" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; preceding the colon if there is one, else the empty string. The value is a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tagName&lt;/code&gt; 冒号前面的部分（如果有的话），否则为空字符串。该值为字符串或 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="301b1af6ca20a6249a998cf35ee08045545a44b5" translate="yes" xml:space="preserve">
          <source>The part of the name following the colon if there is one, else the entire name. This is a read-only attribute.</source>
          <target state="translated">冒号后的名称部分(如果有冒号),否则为整个名称。这是一个只读属性。</target>
        </trans-unit>
        <trans-unit id="4b6ccf0c7b353e7f2cec6eae5206ddd756cf2a42" translate="yes" xml:space="preserve">
          <source>The part of the name preceding the colon if there is one, else the empty string.</source>
          <target state="translated">冒号前的名称部分,如果有,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="037c9a3ec1e20519c87dbc77e141395c51a490ab" translate="yes" xml:space="preserve">
          <source>The particular order that is returned may depend on the specific order in which the items were inserted in the graph. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c63b165c6cabcf3fb6d0c615994fd200d6b0b6" translate="yes" xml:space="preserve">
          <source>The particular values &lt;code&gt;sys.hash_info.inf&lt;/code&gt;, &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; and &lt;code&gt;sys.hash_info.nan&lt;/code&gt; are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.)</source>
          <target state="translated">特定值 &lt;code&gt;sys.hash_info.inf&lt;/code&gt; ， &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; 和 &lt;code&gt;sys.hash_info.nan&lt;/code&gt; 分别用作正无穷大，负无穷大或nans的哈希值。（所有可哈希的nan都具有相同的哈希值。）</target>
        </trans-unit>
        <trans-unit id="946eb4b10e46d85a90cbba3ce04154b4eb521ecd" translate="yes" xml:space="preserve">
          <source>The passed in callback is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">从函数中返回传入的回调,允许本方法作为函数装饰器使用。</target>
        </trans-unit>
        <trans-unit id="5d752ee7919317c8ef5e1cf67a53020b721a4c8d" translate="yes" xml:space="preserve">
          <source>The passed in object is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">从函数中返回传入的对象,允许本方法作为函数装饰器使用。</target>
        </trans-unit>
        <trans-unit id="80f6bc83b260a46ac7e550138dc8f3532aa793b1" translate="yes" xml:space="preserve">
          <source>The patch decorators are used for patching objects only within the scope of the function they decorate. They automatically handle the unpatching for you, even if exceptions are raised. All of these functions can also be used in with statements or as class decorators.</source>
          <target state="translated">补丁装饰器只用于在其装饰的函数范围内对对象进行补丁。它们会自动为你处理解除补丁,即使会引发异常。所有这些函数也可以用在语句中,或者作为类装饰器使用。</target>
        </trans-unit>
        <trans-unit id="e7081c6361ff2f82dac43fc3e7d1619bac7f3e3f" translate="yes" xml:space="preserve">
          <source>The patchers</source>
          <target state="translated">补丁器</target>
        </trans-unit>
        <trans-unit id="befdf46d9ff3d7a1dab0edf47f0724094bd9b1cc" translate="yes" xml:space="preserve">
          <source>The path the finder will search in.</source>
          <target state="translated">查找器要搜索的路径。</target>
        </trans-unit>
        <trans-unit id="74622e717d8bc0ccf71b94541baf057d565c1905" translate="yes" xml:space="preserve">
          <source>The path to the bytecode file.</source>
          <target state="translated">字节码文件的路径。</target>
        </trans-unit>
        <trans-unit id="35ba4af1a78250ec64c0e2392522fa5eb8e9cfe4" translate="yes" xml:space="preserve">
          <source>The path to the source file.</source>
          <target state="translated">源文件的路径。</target>
        </trans-unit>
        <trans-unit id="33a48412e2e67c67c7e92a4715e6b43be0fd6d15" translate="yes" xml:space="preserve">
          <source>The path to where a compiled version of the module is/should be stored (not set when the attribute would be inappropriate).</source>
          <target state="translated">模块的编译版本的存储路径(当属性不合适时不要设置)。</target>
        </trans-unit>
        <trans-unit id="7a8d3812438de73c08083ea24db7366309aa89e4" translate="yes" xml:space="preserve">
          <source>The path to where the module data is stored (not set for built-in modules).</source>
          <target state="translated">模块数据的存储路径(内置模块不设置)。</target>
        </trans-unit>
        <trans-unit id="6d3422ae55b1cae3c297fd0d2a7bb36e7dde778d" translate="yes" xml:space="preserve">
          <source>The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. &lt;em&gt;top_level_dir&lt;/em&gt; is stored so &lt;code&gt;load_tests&lt;/code&gt; does not need to pass this argument in to &lt;code&gt;loader.discover()&lt;/code&gt;.</source>
          <target state="translated">故意不将模式存储为loader属性，以便程序包可以自己继续发现。&lt;em&gt;top_level_dir&lt;/em&gt;已存储，因此 &lt;code&gt;load_tests&lt;/code&gt; 不需要将此参数传递给 &lt;code&gt;loader.discover()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d752d1425dfb41387a9c85ad6aa7411b1b12149" translate="yes" xml:space="preserve">
          <source>The pattern may be a string or a &lt;a href=&quot;#re-objects&quot;&gt;pattern object&lt;/a&gt;.</source>
          <target state="translated">模式可以是字符串或&lt;a href=&quot;#re-objects&quot;&gt;模式对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4198abc6596ed451fcb1e4b11283fe46e47a9bdd" translate="yes" xml:space="preserve">
          <source>The pattern string from which the pattern object was compiled.</source>
          <target state="translated">编译模式对象的模式字符串。</target>
        </trans-unit>
        <trans-unit id="ffa1bd1e5a895a32634127debbd4d54e90aadf39" translate="yes" xml:space="preserve">
          <source>The permutation tuples are emitted in lexicographic ordering according to the order of the input &lt;em&gt;iterable&lt;/em&gt;. So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the combination tuples will be produced in sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f91ca744d391bb72b78aa2afd81f096934a681" translate="yes" xml:space="preserve">
          <source>The philosophy and structure of the two classes is otherwise the same.</source>
          <target state="translated">两门课的理念和结构在其他方面是一样的。</target>
        </trans-unit>
        <trans-unit id="896181308dbe91750b43d1e225e480bee0e585e6" translate="yes" xml:space="preserve">
          <source>The platform does not provide information on whether the UUID was generated safely or not.</source>
          <target state="translated">平台不提供UUID是否安全生成的信息。</target>
        </trans-unit>
        <trans-unit id="0ebc22381e3d1840239ccd9e5f1d63077ee7dfbb" translate="yes" xml:space="preserve">
          <source>The position of the sign (for positive resp. negative values), see below.</source>
          <target state="translated">符号的位置(对于正值或负值),见下文。</target>
        </trans-unit>
        <trans-unit id="59952542e7942305c827d02265033fc6e9dbe5db" translate="yes" xml:space="preserve">
          <source>The positional argument pattern matches that of &lt;a href=&quot;stdtypes#range&quot;&gt;&lt;code&gt;range()&lt;/code&gt;&lt;/a&gt;. Keyword arguments should not be used because the function may use them in unexpected ways.</source>
          <target state="translated">位置参数模式与&lt;a href=&quot;stdtypes#range&quot;&gt; &lt;code&gt;range()&lt;/code&gt; &lt;/a&gt;匹配。不应使用关键字参数，因为函数可能会以意外方式使用它们。</target>
        </trans-unit>
        <trans-unit id="112fe2d97f81ed80cec8656f5adddd507c3ca3eb" translate="yes" xml:space="preserve">
          <source>The positional-only arguments &lt;em&gt;path&lt;/em&gt;, &lt;em&gt;args&lt;/em&gt;, and &lt;em&gt;env&lt;/em&gt; are similar to &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仅位置参数&lt;em&gt;path&lt;/em&gt;，&lt;em&gt;args&lt;/em&gt;和&lt;em&gt;env&lt;/em&gt;与&lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt;相似。</target>
        </trans-unit>
        <trans-unit id="fe3e48c18afdb606d8cb78f91a0899ad96906f15" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;'p_sign_posn'&lt;/code&gt; and &lt;code&gt;'n_sign_posn'&lt;/code&gt; are given below.</source>
          <target state="translated">下面给出了 &lt;code&gt;'p_sign_posn'&lt;/code&gt; 和 &lt;code&gt;'n_sign_posn'&lt;/code&gt; 的可能值。</target>
        </trans-unit>
        <trans-unit id="f6833954936c8ae7c88396b0dc8d3e749d41eb23" translate="yes" xml:space="preserve">
          <source>The precise rules are as follows: suppose that the result formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt; would have exponent &lt;code&gt;exp&lt;/code&gt;. Then, if &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is -4 for floats and -6 for &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimals&lt;/code&gt;&lt;/a&gt;, the number is formatted with presentation type &lt;code&gt;'f'&lt;/code&gt; and precision &lt;code&gt;p-1-exp&lt;/code&gt;. Otherwise, the number is formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt;. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the &lt;code&gt;'#'&lt;/code&gt; option is used.</source>
          <target state="translated">精确规则如下：假设以表示类型 &lt;code&gt;'e'&lt;/code&gt; 和精度 &lt;code&gt;p-1&lt;/code&gt; 格式化的结果将具有指数 &lt;code&gt;exp&lt;/code&gt; 。然后，如果 &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt; ，其中对于浮点数， &lt;code&gt;m&lt;/code&gt; 为-4；对于&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimals&lt;/code&gt; &lt;/a&gt;数，m为-6 ，则数字的格式为表示类型 &lt;code&gt;'f'&lt;/code&gt; 和精度 &lt;code&gt;p-1-exp&lt;/code&gt; 。否则，该数字将以显示类型 &lt;code&gt;'e'&lt;/code&gt; 和精度 &lt;code&gt;p-1&lt;/code&gt; 进行格式化。在这两种情况下，从有效数中除去不重要的尾随零，并且如果在其后没有剩余数字，则也除去小数点，除非使用了 &lt;code&gt;'#'&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="41fdd41826344d0be40e07a7c74ff491f514c5f0" translate="yes" xml:space="preserve">
          <source>The precision determines the number of digits after the decimal point and defaults to 6.</source>
          <target state="translated">精度决定小数点后的位数,默认为6。</target>
        </trans-unit>
        <trans-unit id="9b79033d293b6c31c75ffa5814aa5c087d000b3d" translate="yes" xml:space="preserve">
          <source>The precision determines the number of significant digits before and after the decimal point and defaults to 6.</source>
          <target state="translated">精度决定小数点前后的有效数字,默认为6。</target>
        </trans-unit>
        <trans-unit id="3cd6b8e24856e292a10d35639bc3c6b06da2cd2f" translate="yes" xml:space="preserve">
          <source>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock &amp;ldquo;ticks&amp;rdquo; only 50 or 100 times a second.</source>
          <target state="translated">各种实时函数的精度可能比表示其值或自变量的单位所建议的精度低。例如，在大多数Unix系统上，时钟每秒仅&amp;ldquo;滴答&amp;rdquo;一声50或100次。</target>
        </trans-unit>
        <trans-unit id="31605b7764d8a03a7877d08fc669e90605f06565" translate="yes" xml:space="preserve">
          <source>The predicate must be a callable which result will be interpreted as a boolean value. The final value is the return value.</source>
          <target state="translated">谓词必须是一个可调用的,其结果将被解释为一个布尔值。最后的值是返回值。</target>
        </trans-unit>
        <trans-unit id="399c6b1dfd67b2c650301b9195aaff4a7832e1a5" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Condition is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">使用条件的首选方式是&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt;语句异步：</target>
        </trans-unit>
        <trans-unit id="7d88a730e18917a56485cbcfcd85f3d8377fab9c" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Condition is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee67a620d44fb1681005258c0c62d822ecd2282" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Lock is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">使用Lock的首选方法是&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt;语句异步：</target>
        </trans-unit>
        <trans-unit id="72c98823a0ffab256e4ec15370f0e5edc89e30b8" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Lock is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf6315de2d03fd0877883f3226ad7bcb258a563" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Semaphore is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">使用信号量的首选方法是&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt;语句异步：</target>
        </trans-unit>
        <trans-unit id="73cfcf54cb5d398dd23695dfb914f4aa72e6e417" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Semaphore is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4a24206790bdb6dfb50de90139956972f17d56" translate="yes" xml:space="preserve">
          <source>The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network.</source>
          <target state="translated">前缀定义了地址中的前导位数,通过比较这些前导位来确定一个地址是否是网络的一部分。</target>
        </trans-unit>
        <trans-unit id="e953212a6913d9281232d06868614a71454e1b60" translate="yes" xml:space="preserve">
          <source>The prefix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">要搜索的前缀可以是任何&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a361ce2a67573642097e5871616b5630b23a5c9" translate="yes" xml:space="preserve">
          <source>The prefix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e690cd09d2161493928c7ed836c69440297a338" translate="yes" xml:space="preserve">
          <source>The previous section explains how to read CGI form data using the &lt;code&gt;FieldStorage&lt;/code&gt; class. This section describes a higher level interface which was added to this class to allow one to do it in a more readable and intuitive way. The interface doesn&amp;rsquo;t make the techniques described in previous sections obsolete &amp;mdash; they are still useful to process file uploads efficiently, for example.</source>
          <target state="translated">上一节解释了如何使用 &lt;code&gt;FieldStorage&lt;/code&gt; 类读取CGI表单数据。本节描述了一个更高级别的界面，该界面已添加到此类中，以使人们可以以一种更易读和直观的方式进行操作。该界面不会使前几节中描述的技术过时-例如，它们对于有效地处理文件上传仍然很有用。</target>
        </trans-unit>
        <trans-unit id="7523173e59a7046859cb60342d5e26f6d306040f" translate="yes" xml:space="preserve">
          <source>The primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">主要的API方法。它采用格式字符串以及任意一组位置和关键字参数。它只是一个调用&lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt;的包装器。</target>
        </trans-unit>
        <trans-unit id="4d20207a32c469b27878eb965894ae9e5054d063" translate="yes" xml:space="preserve">
          <source>The primary entry point is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="translated">主要入口是&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;生成器&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9632d79faa271090d54fe68aba8e08af8dd702cf" translate="yes" xml:space="preserve">
          <source>The primary entry point is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dba641bcba4143cddc64727faefe6f987cf349" translate="yes" xml:space="preserve">
          <source>The primary information is passed in &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, which are combined using &lt;code&gt;msg % args&lt;/code&gt; to create the &lt;code&gt;message&lt;/code&gt; field of the record.</source>
          <target state="translated">主要信息以 &lt;code&gt;msg&lt;/code&gt; 和 &lt;code&gt;args&lt;/code&gt; 传递，它们使用 &lt;code&gt;msg % args&lt;/code&gt; 组合在一起以创建记录的 &lt;code&gt;message&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="7bfbe0efc6318910175e0591c9d489213ef2eebb" translate="yes" xml:space="preserve">
          <source>The primary use case for &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; is the one given in the class documentation: supporting a variable number of context managers and other cleanup operations in a single &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The variability may come from the number of context managers needed being driven by user input (such as opening a user specified collection of files), or from some of the context managers being optional:</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt;的主要用例是类文档中给出的用例：在一个&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句中支持可变数量的上下文管理器和其他清除操作。可变性可能来自于由用户输入（例如，打开用户指定的文件集合）驱动的所需上下文管理器的数量，或者来自某些可选的上下文管理器：</target>
        </trans-unit>
        <trans-unit id="dbb93a98c46da8ad3ba58b1529253e2426f9275b" translate="yes" xml:space="preserve">
          <source>The primary use case for &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; is the one given in the class documentation: supporting a variable number of context managers and other cleanup operations in a single &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The variability may come from the number of context managers needed being driven by user input (such as opening a user specified collection of files), or from some of the context managers being optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e9483a317900afadce553033a91cd1d47b9bcf" translate="yes" xml:space="preserve">
          <source>The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.</source>
          <target state="translated">主要的内置类型是数字、序列、映射、类、实例和异常。</target>
        </trans-unit>
        <trans-unit id="53a56e829c4ee5d3a496f807f49d36341548a22a" translate="yes" xml:space="preserve">
          <source>The printing of warning messages is done by calling &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt;, which may be overridden; the default implementation of this function formats the message by calling &lt;a href=&quot;#warnings.formatwarning&quot;&gt;&lt;code&gt;formatwarning()&lt;/code&gt;&lt;/a&gt;, which is also available for use by custom implementations.</source>
          <target state="translated">警告消息的打印是通过调用&lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt;来完成的，它可以被覆盖；该函数的默认实现通过调用&lt;a href=&quot;#warnings.formatwarning&quot;&gt; &lt;code&gt;formatwarning()&lt;/code&gt; 来&lt;/a&gt;格式化消息，该信息也可用于自定义实现。</target>
        </trans-unit>
        <trans-unit id="825b7993e09a5012896880aa81ed2189c1fc5fc3" translate="yes" xml:space="preserve">
          <source>The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation &lt;code&gt;~&lt;/code&gt; has the same priority as the other unary numeric operations (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">二进制按位运算的优先级均低于数字运算，且高于比较运算。一元运算 &lt;code&gt;~&lt;/code&gt; 的优先级与其他一元数值运算（ &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; ）相同。</target>
        </trans-unit>
        <trans-unit id="5bf0a8ae599a694d8728a80398296f63055fcd91" translate="yes" xml:space="preserve">
          <source>The probability distribution function is:</source>
          <target state="translated">概率分布函数为:</target>
        </trans-unit>
        <trans-unit id="6f4b0a33ec009f539e41f7c7861882fe3861eb27" translate="yes" xml:space="preserve">
          <source>The problem is more important with &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; than with the lower-overhead &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;. For this reason, &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; provides a means of calibrating itself for a given platform so that this error can be probabilistically (on the average) removed. After the profiler is calibrated, it will be more accurate (in a least square sense), but it will sometimes produce negative numbers (when call counts are exceptionally low, and the gods of probability work against you :-). ) Do &lt;em&gt;not&lt;/em&gt; be alarmed by negative numbers in the profile. They should &lt;em&gt;only&lt;/em&gt; appear if you have calibrated your profiler, and the results are actually better than without calibration.</source>
          <target state="translated">使用&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt;比使用开销较低的&lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt;更重要。因此，&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt;提供了一种针对给定平台进行自我校准的方法，从而可以（平均）概率地消除此错误。在对探查器进行校准之后，它会更加精确（至少在平方意义上），但有时会产生负数（当呼叫计数异常低时，概率之神对您不利：-）。 ）不要&lt;em&gt;不&lt;/em&gt;通过配置文件中的负数惊慌。&lt;em&gt;仅&lt;/em&gt;当您已经校准了探查器时，它们&lt;em&gt;才会&lt;/em&gt;出现，并且结果实际上比没有校准时要好。</target>
        </trans-unit>
        <trans-unit id="a7bf59022d95e063a71d9d155d556fa687e8151c" translate="yes" xml:space="preserve">
          <source>The problem with the code is that you should never expect that a client will provide valid input to your scripts. For example, if a curious user appends another &lt;code&gt;user=foo&lt;/code&gt; pair to the query string, then the script would crash, because in this situation the &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; method call returns a list instead of a string. Calling the &lt;a href=&quot;stdtypes#str.upper&quot;&gt;&lt;code&gt;upper()&lt;/code&gt;&lt;/a&gt; method on a list is not valid (since lists do not have a method of this name) and results in an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">代码的问题在于，您永远不要期望客户端会向脚本提供有效的输入。例如，如果一个好奇的用户将另一个 &lt;code&gt;user=foo&lt;/code&gt; 对附加到查询字符串，则脚本将崩溃，因为在这种情况下， &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; 方法调用将返回列表而不是字符串。在列表&lt;a href=&quot;stdtypes#str.upper&quot;&gt; &lt;code&gt;upper()&lt;/code&gt; &lt;/a&gt;调用upper（）方法无效（因为列表没有此名称的方法），并导致&lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="96fdb4e91d747f7b382ca34963ea4e97a833f290" translate="yes" xml:space="preserve">
          <source>The procedural interface provides functions which are derived from the methods of the classes &lt;a href=&quot;#turtle.Screen&quot;&gt;&lt;code&gt;Screen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#turtle.Turtle&quot;&gt;&lt;code&gt;Turtle&lt;/code&gt;&lt;/a&gt;. They have the same names as the corresponding methods. A screen object is automatically created whenever a function derived from a Screen method is called. An (unnamed) turtle object is automatically created whenever any of the functions derived from a Turtle method is called.</source>
          <target state="translated">过程接口提供了从&lt;a href=&quot;#turtle.Screen&quot;&gt; &lt;code&gt;Screen&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#turtle.Turtle&quot;&gt; &lt;code&gt;Turtle&lt;/code&gt; &lt;/a&gt;类的方法派生的功能。它们具有与相应方法相同的名称。每当调用从Screen方法派生的函数时，都会自动创建一个屏幕对象。每当调用从Turtle方法派生的任何函数时，都会自动创建一个（未命名的）turtle对象。</target>
        </trans-unit>
        <trans-unit id="2e489b4dd7453fa49df07a28774b20b3ff3ca536" translate="yes" xml:space="preserve">
          <source>The process ID of the child process.</source>
          <target state="translated">子进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="150de663b2d1dfe4e98950a0d814ed1d1e220721" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s authentication key (a byte string).</source>
          <target state="translated">进程的身份验证密钥（字节字符串）。</target>
        </trans-unit>
        <trans-unit id="17a501bfd01684f2b434b6e89089168e44514201" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s daemon flag, a Boolean value. This must be set before &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">进程的守护程序标志，一个布尔值。必须在调用&lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;之前进行设置。</target>
        </trans-unit>
        <trans-unit id="06c818f8e2a507968c04b9b39e1decda880a5cf5" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s name. The name is a string used for identification purposes only. It has no semantics. Multiple processes may be given the same name.</source>
          <target state="translated">进程的名称。名称是仅用于标识目的的字符串。它没有语义。多个进程可以使用相同的名称。</target>
        </trans-unit>
        <trans-unit id="a9c95a490df7fa30b946fe0f7a64b2a77f6f669a" translate="yes" xml:space="preserve">
          <source>The produced code string will not necessarily be equal to the original code that generated the &lt;a href=&quot;#ast.AST&quot;&gt;&lt;code&gt;ast.AST&lt;/code&gt;&lt;/a&gt; object (without any compiler optimizations, such as constant tuples/frozensets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ae1e6a3ccabf77f11a716a76fae3c85a9de04b" translate="yes" xml:space="preserve">
          <source>The profiler modules are designed to provide an execution profile for a given program, not for benchmarking purposes (for that, there is &lt;a href=&quot;timeit#module-timeit&quot;&gt;&lt;code&gt;timeit&lt;/code&gt;&lt;/a&gt; for reasonably accurate results). This particularly applies to benchmarking Python code against C code: the profilers introduce overhead for Python code, but not for C-level functions, and so the C code would seem faster than any Python one.</source>
          <target state="translated">分析器模块被设计为对于给定的程序提供了一个执行配置文件，不进行基准测试目的（即，存在&lt;a href=&quot;timeit#module-timeit&quot;&gt; &lt;code&gt;timeit&lt;/code&gt; &lt;/a&gt;为合理准确的结果）。这尤其适用于使用C代码对Python代码进行基准测试：分析器会为Python代码带来开销，但不会为C级函数带来开销，因此C代码似乎比任何Python代码都要快。</target>
        </trans-unit>
        <trans-unit id="1ad274b67435cbea4d0f0022c9cb8f04c789c28d" translate="yes" xml:space="preserve">
          <source>The profiler of the &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; module subtracts a constant from each event handling time to compensate for the overhead of calling the time function, and socking away the results. By default, the constant is 0. The following procedure can be used to obtain a better constant for a given platform (see &lt;a href=&quot;#profile-limitations&quot;&gt;Limitations&lt;/a&gt;).</source>
          <target state="translated">概要&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt;模块的概要文件分析器从每个事件处理时间中减去一个常量，以补偿调用时间函数和替换结果的开销。默认情况下，常数为0。可以使用以下过程为给定平台获得更好的常数（请参阅&amp;ldquo; &lt;a href=&quot;#profile-limitations&quot;&gt;限制&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c57ccc0f47b6d649d42fac7c15dd4c76568d4399" translate="yes" xml:space="preserve">
          <source>The prompt issued to solicit input.</source>
          <target state="translated">为征求意见而发出的提示。</target>
        </trans-unit>
        <trans-unit id="83875c7800a2b76dd59acb9bb82a7881a37ecba4" translate="yes" xml:space="preserve">
          <source>The property list (&lt;code&gt;.plist&lt;/code&gt;) file format is a simple serialization supporting basic object types, like dictionaries, lists, numbers and strings. Usually the top level object is a dictionary.</source>
          <target state="translated">属性列表（ &lt;code&gt;.plist&lt;/code&gt; ）文件格式是一种简单的序列化，支持基本对象类型，如字典，列表，数字和字符串。通常，顶级对象是字典。</target>
        </trans-unit>
        <trans-unit id="a692e4b23f49571c480a6608de6502020e3e6363" translate="yes" xml:space="preserve">
          <source>The proposal and rationale for this feature, including links to earlier implementations and information about similar features in other languages.</source>
          <target state="translated">该功能的建议和理由,包括与早期实施的链接和其他语言中类似功能的信息。</target>
        </trans-unit>
        <trans-unit id="d3279c37a3d4b93f2763c17e116a163fb04d69c0" translate="yes" xml:space="preserve">
          <source>The proposal which described this feature for inclusion in the Python standard library.</source>
          <target state="translated">该提案描述了这一特性,以便纳入Python标准库。</target>
        </trans-unit>
        <trans-unit id="6aad5f6edb9228644868ffcfbe2652bf80458149" translate="yes" xml:space="preserve">
          <source>The protocol instance is coupled with the transport by calling its &lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt;&lt;code&gt;connection_made()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">协议实例通过调用其&lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt; &lt;code&gt;connection_made()&lt;/code&gt; &lt;/a&gt;方法与传输耦合。</target>
        </trans-unit>
        <trans-unit id="5bcebb7947c21cec173aaf44168e072aa830c96e" translate="yes" xml:space="preserve">
          <source>The protocol version chosen when constructing the context. This attribute is read-only.</source>
          <target state="translated">构建上下文时选择的协议版本。这个属性是只读的。</target>
        </trans-unit>
        <trans-unit id="4b8e37987302667a8c6a5a30086ea70af54f58fc" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed.</source>
          <target state="translated">自动检测pickle的协议版本,所以不需要协议参数。</target>
        </trans-unit>
        <trans-unit id="304bb59bee6afe03568f30f120fa0b442a6c61e2" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled representation of the object are ignored.</source>
          <target state="translated">自动检测pickle的协议版本,所以不需要协议参数。超过对象的pickled表示的字节将被忽略。</target>
        </trans-unit>
        <trans-unit id="27bd7c4faffc395f3247caddbe9693091c3dd829" translate="yes" xml:space="preserve">
          <source>The protocol, options, cipher and other settings may change to more restrictive values anytime without prior deprecation. The values represent a fair balance between compatibility and security.</source>
          <target state="translated">协议、选项、密码和其他设置可能会在任何时候改变为更多的限制性值,而不需要事先废弃。这些值代表了兼容性和安全性之间的公平平衡。</target>
        </trans-unit>
        <trans-unit id="9bb42a552b302f1dbded8b49b736ac990615d6f9" translate="yes" xml:space="preserve">
          <source>The proxy types in &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; do nothing to support comparisons by value. So, for instance, we have:</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt;的代理类型不支持按值进行比较。因此，例如，我们有：</target>
        </trans-unit>
        <trans-unit id="ef765547ec364b540a8f16063c0fa31ef2bb74cb" translate="yes" xml:space="preserve">
          <source>The pseudo-random generators of this module should not be used for security purposes. For security or cryptographic uses, see the &lt;a href=&quot;secrets#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">出于安全目的，不应使用此模块的伪随机数生成器。出于安全或加密的用途，请参阅&lt;a href=&quot;secrets#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a7da2517da5604deefcd3b219dc6bc72a5207e5e" translate="yes" xml:space="preserve">
          <source>The public identifier for the external subset of the document type definition. This will be a string or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">文档类型定义的外部子集的公共标识符。这将是一个字符串或 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cc24cc4f00882f93419ab13bd6a8c64685b3f66" translate="yes" xml:space="preserve">
          <source>The public methods of the Screen and Turtle classes are documented extensively via docstrings. So these can be used as online-help via the Python help facilities:</source>
          <target state="translated">Screen 和 Turtle 类的公共方法通过 docstrings 被广泛地记录下来。所以这些方法可以通过 Python 帮助工具作为在线帮助使用。</target>
        </trans-unit>
        <trans-unit id="2bed0ab16eca2867630c9e7cc4d96b74b1c2265f" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;a href=&quot;#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; package is two-fold. One is to provide the implementation of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement (and thus, by extension, the &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function) in Python source code. This provides an implementation of &lt;code&gt;import&lt;/code&gt; which is portable to any Python interpreter. This also provides an implementation which is easier to comprehend than one implemented in a programming language other than Python.</source>
          <target state="translated">&lt;a href=&quot;#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt;软件包的用途有两个。一种是在Python源代码中提供&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;语句的实现（因此，通过扩展来实现&lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt;函数）。这提供了 &lt;code&gt;import&lt;/code&gt; 的实现，该实现可移植到任何Python解释器中。这也提供了比用Python以外的其他编程语言实现的实现更容易理解的实现。</target>
        </trans-unit>
        <trans-unit id="c5af7de07ad25b8b16b26a5eec475ceb8c25175a" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;a href=&quot;#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; package is two-fold. One is to provide the implementation of the &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement (and thus, by extension, the &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function) in Python source code. This provides an implementation of &lt;code&gt;import&lt;/code&gt; which is portable to any Python interpreter. This also provides an implementation which is easier to comprehend than one implemented in a programming language other than Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16dd66cb16f34ace27bac31206afc6d4d2fe723" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;find_library()&lt;/code&gt; function is to locate a library in a way similar to what the compiler or runtime loader does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly.</source>
          <target state="translated">&lt;code&gt;find_library()&lt;/code&gt; 函数的目的是按照类似于编译器或运行时加载程序的方式来定位库（在具有多个版本的共享库的平台上，应加载最新的库），而ctypes库加载器的行为类似于当程序运行时，直接调用运行时加载程序。</target>
        </trans-unit>
        <trans-unit id="fa702db0cff6f2f3895045c3752a9fbb38f37c5c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;em&gt;context&lt;/em&gt; argument is determining what to do if &lt;em&gt;value&lt;/em&gt; is a malformed string. If the context traps &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;, an exception is raised; otherwise, the constructor returns a new Decimal with the value of &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;上下文&lt;/em&gt;参数的目的是确定如果&lt;em&gt;value&lt;/em&gt;是格式错误的字符串该怎么办。如果上下文捕获&lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt;，则会引发异常；否则，将引发异常。否则，构造函数将返回一个新的Decimal，其值为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d7470421cad5575eb47710dc31f2ce6a15d669a" translate="yes" xml:space="preserve">
          <source>The pysqlite web page &amp;ndash; sqlite3 is developed externally under the name &amp;ldquo;pysqlite&amp;rdquo;.</source>
          <target state="translated">pysqlite网页&amp;ndash; sqlite3是在外部以&amp;ldquo; pysqlite&amp;rdquo;的名称开发的。</target>
        </trans-unit>
        <trans-unit id="df0d2d334ee13950a07c31e697402c72d3e65e9f" translate="yes" xml:space="preserve">
          <source>The quoting is compatible with UNIX shells and with &lt;a href=&quot;#shlex.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">该引用与UNIX shell和&lt;a href=&quot;#shlex.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt;兼容：</target>
        </trans-unit>
        <trans-unit id="8ce58c924d511abccc91112f9868301eab2a2623" translate="yes" xml:space="preserve">
          <source>The range really is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;61&lt;/code&gt;; value &lt;code&gt;60&lt;/code&gt; is valid in timestamps representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt; and value &lt;code&gt;61&lt;/code&gt; is supported for historical reasons.</source>
          <target state="translated">范围实际上是 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;61&lt;/code&gt; ；值 &lt;code&gt;60&lt;/code&gt; 在表示&lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap秒的&lt;/a&gt;时间戳中有效，并且出于历史原因支持值 &lt;code&gt;61&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fd421df5dc2685a581e00c1459b24396ed076e6" translate="yes" xml:space="preserve">
          <source>The raw stream API is described in detail in the docs of &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt;的文档中详细描述了原始流API 。</target>
        </trans-unit>
        <trans-unit id="92473e24fa37abfabba3bd84c199a20643551ee1" translate="yes" xml:space="preserve">
          <source>The raw version number of the OpenSSL library, as a single integer:</source>
          <target state="translated">OpenSSL库的原始版本号,为一个整数。</target>
        </trans-unit>
        <trans-unit id="f5f4e5aa79fcae7b1a4aee5bb988c8d392ca329d" translate="yes" xml:space="preserve">
          <source>The reason for defaulting to &lt;code&gt;1&lt;/code&gt; as the starting number and not &lt;code&gt;0&lt;/code&gt; is that &lt;code&gt;0&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; in a boolean sense, but enum members all evaluate to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">将默认值设置为 &lt;code&gt;1&lt;/code&gt; 而不是 &lt;code&gt;0&lt;/code&gt; 的原因是，从布尔意义上讲， &lt;code&gt;0&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，但是枚举成员的所有值都为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b8da247393cb3f901f4c9827fb1c55335da705f" translate="yes" xml:space="preserve">
          <source>The reason for this error. It can be a message string or another exception instance.</source>
          <target state="translated">这个错误的原因。它可以是一个消息字符串或其他异常实例。</target>
        </trans-unit>
        <trans-unit id="7cdf1c2c1cd73bb92ad5a97181b39bc3deca2b0b" translate="yes" xml:space="preserve">
          <source>The reason the attributes exist is to save you having to subclass - you can use the same callables for instances of &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;&lt;/a&gt;. If either the namer or rotator callable raises an exception, this will be handled in the same way as any other exception during an &lt;code&gt;emit()&lt;/code&gt; call, i.e. via the &lt;code&gt;handleError()&lt;/code&gt; method of the handler.</source>
          <target state="translated">属性存在的原因是省去了子类化的&lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt; &lt;code&gt;TimedRotatingFileHandler&lt;/code&gt; &lt;/a&gt; -您可以对&lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt; &lt;code&gt;RotatingFileHandler&lt;/code&gt; &lt;/a&gt;和TimedRotatingFileHandler的实例使用相同的可调用对象。如果任一命名器或旋转器可调用引发一个例外，这将是在相同的方式与任何其他异常的期间处理 &lt;code&gt;emit()&lt;/code&gt; 调用，即通过 &lt;code&gt;handleError()&lt;/code&gt; 的处理程序的方法。</target>
        </trans-unit>
        <trans-unit id="3b9780bd4e28d18b6c6eb957a0c871c293f95ffa" translate="yes" xml:space="preserve">
          <source>The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻&amp;sup1;⁰⁷⁴ in the range &lt;em&gt;0.0 &amp;le; x &amp;lt; 1.0&lt;/em&gt;. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻&amp;sup1;⁰⁷⁴ is the smallest positive unnormalized float and is equal to &lt;code&gt;math.ulp(0.0)&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d87c844ed2c3d32ca4dbf0d2608b75aaafce69" translate="yes" xml:space="preserve">
          <source>The recommended &lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt; installer runs all &lt;code&gt;setup.py&lt;/code&gt; scripts with &lt;code&gt;setuptools&lt;/code&gt;, even if the script itself only imports &lt;code&gt;distutils&lt;/code&gt;. Refer to the &lt;a href=&quot;https://packaging.python.org&quot;&gt;Python Packaging User Guide&lt;/a&gt; for more information.</source>
          <target state="translated">推荐的&lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt;安装程序使用 &lt;code&gt;setuptools&lt;/code&gt; 运行所有 &lt;code&gt;setup.py&lt;/code&gt; 脚本，即使脚本本身仅导入 &lt;code&gt;distutils&lt;/code&gt; 。有关更多信息，请参考《&lt;a href=&quot;https://packaging.python.org&quot;&gt;Python打包用户指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3708eceef9e8fc9b657fbd262aa2dd3c8c9e05c" translate="yes" xml:space="preserve">
          <source>The recommended approach to invoking subprocesses is to use the &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; function for all use cases it can handle. For more advanced use cases, the underlying &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; interface can be used directly.</source>
          <target state="translated">推荐的调用子流程的方法是将&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;函数用于它可以处理的所有用例。对于更高级的用例，可以直接使用基础&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="fd6e5d6a0931f68dfa7a32f3cada332bb112bb51" translate="yes" xml:space="preserve">
          <source>The recommended way to create a custom action is to extend &lt;a href=&quot;#argparse.Action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;, overriding the &lt;code&gt;__call__&lt;/code&gt; method and optionally the &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;format_usage&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb4dc482b74e7926d22ef923199ab80c945bb99" translate="yes" xml:space="preserve">
          <source>The recommended way to create array types is by multiplying a data type with a positive integer:</source>
          <target state="translated">创建数组类型的推荐方法是将数据类型与正整数相乘。</target>
        </trans-unit>
        <trans-unit id="66efc06bb3809b5e55afbd1288c458d0d954c17a" translate="yes" xml:space="preserve">
          <source>The recommended way to create concrete array types is by multiplying any &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; data type with a positive integer. Alternatively, you can subclass this type and define &lt;a href=&quot;#ctypes.Array._length_&quot;&gt;&lt;code&gt;_length_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.Array._type_&quot;&gt;&lt;code&gt;_type_&lt;/code&gt;&lt;/a&gt; class variables. Array elements can be read and written using standard subscript and slice accesses; for slice reads, the resulting object is &lt;em&gt;not&lt;/em&gt; itself an &lt;a href=&quot;#ctypes.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">推荐的创建具体数组类型的方法是将任何&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;数据类型乘以一个正整数。另外，您可以&lt;a href=&quot;#ctypes.Array._length_&quot;&gt; &lt;code&gt;_length_&lt;/code&gt; &lt;/a&gt;此类型并定义_length_和&lt;a href=&quot;#ctypes.Array._type_&quot;&gt; &lt;code&gt;_type_&lt;/code&gt; &lt;/a&gt;类变量。数组元素可以使用标准下标和切片访问进行读写。对于切片读取，所得到的物体是&lt;em&gt;不&lt;/em&gt;本身的&lt;a href=&quot;#ctypes.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db258e380ae1e9f11acb7ecd11189586c81b75b9" translate="yes" xml:space="preserve">
          <source>The reconstructed script is returned as a single string. The result is guaranteed to tokenize back to match the input so that the conversion is lossless and round-trips are assured. The guarantee applies only to the token type and token string as the spacing between tokens (column positions) may change.</source>
          <target state="translated">重构后的脚本会以单个字符串的形式返回。保证结果能回溯到与输入相匹配的tokenize,因此转换是无损的,并保证往返。这个保证只适用于token类型和token字符串,因为token之间的间距(列位置)可能会改变。</target>
        </trans-unit>
        <trans-unit id="57acf8c8e12eab6d4b3a3f62dbb9d6a2820d0c9c" translate="yes" xml:space="preserve">
          <source>The reconstructor (the &lt;code&gt;_reconstruct&lt;/code&gt; class method) returns the buffer&amp;rsquo;s providing object if it has the right type. This is an easy way to simulate zero-copy behaviour on this toy example.</source>
          <target state="translated">如果缓冲区的类型正确，则重建器（ &lt;code&gt;_reconstruct&lt;/code&gt; 类方法）将返回缓冲区的提供对象。这是在此玩具示例上模拟零复制行为的简便方法。</target>
        </trans-unit>
        <trans-unit id="6832c932800d1e21134679897c1c0c648c46cac9" translate="yes" xml:space="preserve">
          <source>The record is formatted, and then sent to the syslog server. If exception information is present, it is &lt;em&gt;not&lt;/em&gt; sent to the server.</source>
          <target state="translated">记录被格式化，然后发送到syslog服务器。如果存在异常信息，&lt;em&gt;则不&lt;/em&gt;会将其发送到服务器。</target>
        </trans-unit>
        <trans-unit id="0b70780ad8c59629bb44ba0ecc4d77b4f436096b" translate="yes" xml:space="preserve">
          <source>The record&amp;rsquo;s attribute dictionary is used as the operand to a string formatting operation. Returns the resulting string. Before formatting the dictionary, a couple of preparatory steps are carried out. The &lt;em&gt;message&lt;/em&gt; attribute of the record is computed using &lt;em&gt;msg&lt;/em&gt; % &lt;em&gt;args&lt;/em&gt;. If the formatting string contains &lt;code&gt;'(asctime)'&lt;/code&gt;, &lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt;&lt;code&gt;formatTime()&lt;/code&gt;&lt;/a&gt; is called to format the event time. If there is exception information, it is formatted using &lt;a href=&quot;#logging.Formatter.formatException&quot;&gt;&lt;code&gt;formatException()&lt;/code&gt;&lt;/a&gt; and appended to the message. Note that the formatted exception information is cached in attribute &lt;em&gt;exc_text&lt;/em&gt;. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesn&amp;rsquo;t use the cached value but recalculates it afresh.</source>
          <target state="translated">记录的属性字典用作字符串格式化操作的操作数。返回结果字符串。在格式化字典之前，需要执行几个准备步骤。记录的&lt;em&gt;消息&lt;/em&gt;属性是使用&lt;em&gt;msg&lt;/em&gt;％&lt;em&gt;args&lt;/em&gt;计算的。如果格式化字符串包含 &lt;code&gt;'(asctime)'&lt;/code&gt; ，则调用&lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt; &lt;code&gt;formatTime()&lt;/code&gt; &lt;/a&gt;格式化事件时间。如果存在异常信息，则使用&lt;a href=&quot;#logging.Formatter.formatException&quot;&gt; &lt;code&gt;formatException()&lt;/code&gt; 将&lt;/a&gt;其格式化并附加到消息中。请注意，格式化的异常信息缓存在属性&lt;em&gt;exc_text中&lt;/em&gt;。这很有用，因为可以对异常信息进行酸洗并通过网络发送，但是如果您有多个自定义异常信息格式的&lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;子类，则应小心。在这种情况下，您必须在格式化程序完成格式化后清除缓存的值，以便下一个处理该事件的格式化程序不使用缓存的值，而是重新对其进行重新计算。</target>
        </trans-unit>
        <trans-unit id="7b68d4f5f80393667485b695f7d4fbe0d86fa20c" translate="yes" xml:space="preserve">
          <source>The recorder object also has a &lt;code&gt;reset()&lt;/code&gt; method, which clears the warnings list.</source>
          <target state="translated">记录器对象还具有 &lt;code&gt;reset()&lt;/code&gt; 方法，该方法清除警告列表。</target>
        </trans-unit>
        <trans-unit id="b626a485d54404ebb0e667a8827f0bc2ce4565e1" translate="yes" xml:space="preserve">
          <source>The redundant types are deprecated as of Python 3.9 but no deprecation warnings will be issued by the interpreter. It is expected that type checkers will flag the deprecated types when the checked program targets Python 3.9 or newer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f5a856010edc6634a1b395d6da029a99f96511" translate="yes" xml:space="preserve">
          <source>The regex matching flags. This is a combination of the flags given to &lt;a href=&quot;#re.compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, any &lt;code&gt;(?...)&lt;/code&gt; inline flags in the pattern, and implicit flags such as &lt;code&gt;UNICODE&lt;/code&gt; if the pattern is a Unicode string.</source>
          <target state="translated">正则表达式匹配标志。这是给&lt;a href=&quot;#re.compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; 的&lt;/a&gt;标志，模式中的任何 &lt;code&gt;(?...)&lt;/code&gt; 内联标志以及模式为Unicode字符串的隐式标志（如 &lt;code&gt;UNICODE&lt;/code&gt; ）的组合。</target>
        </trans-unit>
        <trans-unit id="4908905268dd161df8905009999a17db351541c3" translate="yes" xml:space="preserve">
          <source>The regular &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; was designed to be very good at mapping operations. Tracking insertion order was secondary.</source>
          <target state="translated">常规&lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt;被设计为非常擅长映射操作。跟踪插入顺序是次要的。</target>
        </trans-unit>
        <trans-unit id="7968a2059eb096a9ad928a6d8fa459e62e306418" translate="yes" xml:space="preserve">
          <source>The regular expression pattern.</source>
          <target state="translated">正则表达式模式。</target>
        </trans-unit>
        <trans-unit id="338a44466ba170ea38b197685c29de265d361a96" translate="yes" xml:space="preserve">
          <source>The relationships among these processing classes are summarized in the following diagram:</source>
          <target state="translated">这些处理类之间的关系总结在下图中。</target>
        </trans-unit>
        <trans-unit id="93eb7f8ce0f82ca28e08352f3f3171f042ffdf18" translate="yes" xml:space="preserve">
          <source>The relative likelihood is computed as the probability of a sample occurring in a narrow range divided by the width of the range (hence the word &amp;ldquo;density&amp;rdquo;). Since the likelihood is relative to other points, its value can be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">相对似然度被计算为样本在狭窄范围内出现的概率除以范围的宽度（因此称为&amp;ldquo;密度&amp;rdquo;）。由于可能性是相对于其他点的，因此其值可以大于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe576e550a29800997b9d6a2e646402dca141123" translate="yes" xml:space="preserve">
          <source>The remainder is computed as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object. (3)</source>
          <target state="translated">余数作为&lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt;对象计算。（3）</target>
        </trans-unit>
        <trans-unit id="0340c584ccb1afc4873c12a1e31a9be1bffa4f35" translate="yes" xml:space="preserve">
          <source>The remaining &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; methods are called by the email package code, and are not intended to be called by an application using the email package. A custom policy must implement all of these methods.</source>
          <target state="translated">其余的&lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt;方法由电子邮件程序包代码调用，并且不打算由使用电子邮件程序包的应用程序调用。定制策略必须实现所有这些方法。</target>
        </trans-unit>
        <trans-unit id="73a6d6e6fac3d7be26a7b43db8daf15d992cd3a7" translate="yes" xml:space="preserve">
          <source>The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue.</source>
          <target state="translated">其余的挑战围绕着找到一个待处理的任务,并对其优先级进行更改或完全删除。寻找任务可以通过一个指向队列中的条目的字典来完成。</target>
        </trans-unit>
        <trans-unit id="e1bc691bd9a1784a04f10810950f779a9ee15eb0" translate="yes" xml:space="preserve">
          <source>The remaining functions are part of the legacy (&lt;code&gt;Compat32&lt;/code&gt;) email API. There is no need to directly use these with the new API, since the parsing and formatting they provide is done automatically by the header parsing machinery of the new API.</source>
          <target state="translated">其余功能是旧版（ &lt;code&gt;Compat32&lt;/code&gt; ）电子邮件API的一部分。不需要直接将它们与新API一起使用，因为它们提供的解析和格式化是由新API的标头解析机制自动完成的。</target>
        </trans-unit>
        <trans-unit id="e9e96d5ad53b78651123f0aa48586b15b8bc8356" translate="yes" xml:space="preserve">
          <source>The remaining methods are specific to audio mixing:</source>
          <target state="translated">其余的方法都是针对音频混合的。</target>
        </trans-unit>
        <trans-unit id="3bfb848b5ec87a5a815658edfcfabd10bf0be1cc" translate="yes" xml:space="preserve">
          <source>The remaining methods will raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if called after the &lt;a href=&quot;#chunk.Chunk.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method has been called. Before Python 3.3, they used to raise &lt;a href=&quot;exceptions#IOError&quot;&gt;&lt;code&gt;IOError&lt;/code&gt;&lt;/a&gt;, now an alias of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#chunk.Chunk.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;方法之后调用其余方法，则会引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;。在Python 3.3之前，他们曾经提出&lt;a href=&quot;exceptions#IOError&quot;&gt; &lt;code&gt;IOError&lt;/code&gt; &lt;/a&gt;，现在是&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="ab4081a709186f53a0d01adb9c1f82670e77f305" translate="yes" xml:space="preserve">
          <source>The remaining text in this section is the original documentation of the module.</source>
          <target state="translated">本节其余文字为该模块的原始文档。</target>
        </trans-unit>
        <trans-unit id="df76983d86e7fd3680429e5d80b3f6559c176cdc" translate="yes" xml:space="preserve">
          <source>The representation of bytearray objects uses the bytes literal format (&lt;code&gt;bytearray(b'...')&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt;. You can always convert a bytearray object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">bytearray对象的表示使用字节文本格式（ &lt;code&gt;bytearray(b'...')&lt;/code&gt; ），因为它通常比 &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt; 更有用。您始终可以使用 &lt;code&gt;list(b)&lt;/code&gt; 将bytearray对象转换为整数列表。</target>
        </trans-unit>
        <trans-unit id="1d120b288aa1f00756fb3a349cf99f1b0ed62ed4" translate="yes" xml:space="preserve">
          <source>The representation of bytes objects uses the literal format (&lt;code&gt;b'...'&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt;. You can always convert a bytes object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">字节对象的表示使用文字格式（ &lt;code&gt;b'...'&lt;/code&gt; ），因为它通常比 &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt; 更有用。您始终可以使用 &lt;code&gt;list(b)&lt;/code&gt; 将bytes对象转换为整数列表。</target>
        </trans-unit>
        <trans-unit id="934e4823813e26310eba11e448f6edb5ad9e263d" translate="yes" xml:space="preserve">
          <source>The request is mapped to a local file by interpreting the request as a path relative to the current working directory.</source>
          <target state="translated">通过将请求解释为相对于当前工作目录的路径,将请求映射到本地文件。</target>
        </trans-unit>
        <trans-unit id="d1e30ca94027546a99c4c247aa7bc532aac9585a" translate="yes" xml:space="preserve">
          <source>The request will not work as expected if the data object is unable to deliver its content more than once (e.g. a file or an iterable that can produce the content only once) and the request is retried for HTTP redirects or authentication. The &lt;em&gt;data&lt;/em&gt; is sent to the HTTP server right away after the headers. There is no support for a 100-continue expectation in the library.</source>
          <target state="translated">如果数据对象无法多次传递其内容（例如，只能产生一次内容的文件或可迭代对象）并且请求重试以进行HTTP重定向或身份验证，则该请求将无法按预期方式工作。该&lt;em&gt;数据&lt;/em&gt;被发送到头部后马上HTTP服务器。库中不支持100个连续期望。</target>
        </trans-unit>
        <trans-unit id="d08fb6e54b0bef7db4806e25ba06216ddf869486" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a parser which was finished parsing input, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">所请求的操作是在解析器上进行的，解析器已完成对输入的解析，但不允许这样做。这包括尝试提供其他输入或停止解析器。</target>
        </trans-unit>
        <trans-unit id="6be492a00d95d8c38d0f08df00ba5cd76c54a3e2" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a suspended parser, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">所请求的操作是在暂停的解析器上进行的，但不允许执行。这包括尝试提供其他输入或停止解析器。</target>
        </trans-unit>
        <trans-unit id="e7da8efaff05d5a67bdc583cf83ab65e3004c869" translate="yes" xml:space="preserve">
          <source>The requested read operation did not complete fully.</source>
          <target state="translated">请求的读取操作没有完全完成。</target>
        </trans-unit>
        <trans-unit id="1f8cfa9ce8db124d500cff91c25e3e50bf494e54" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;name&lt;/em&gt; parameter is used for introspection and debug purposes.</source>
          <target state="translated">必需的&lt;em&gt;name&lt;/em&gt;参数用于自省和调试目的。</target>
        </trans-unit>
        <trans-unit id="2c25d69b77c16629632ad85bd39c5b60853e6161" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;value&lt;/em&gt; argument is the new value for the context variable.</source>
          <target state="translated">必需的&lt;em&gt;值&lt;/em&gt;参数是上下文变量的新值。</target>
        </trans-unit>
        <trans-unit id="902699a10c395c34229cad66f2a25386f0e788eb" translate="yes" xml:space="preserve">
          <source>The reset_mock method resets all the call attributes on a mock object:</source>
          <target state="translated">reset_mock方法重置了mock对象上的所有调用属性。</target>
        </trans-unit>
        <trans-unit id="ddf13e446d1b8be7a43739f2d543a173cf27e006" translate="yes" xml:space="preserve">
          <source>The resolution of such persistent IDs is not defined by the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module; it will delegate this resolution to the user-defined methods on the pickler and unpickler, &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;persistent_load()&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt;模块未定义此类持久性ID的解析；它将把该解决方案委派给Pickler和UnPickler上用户定义的方法，&lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;persistent_load()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dad2579aacf71b8f66ffcb466c20321d81397aa7" translate="yes" xml:space="preserve">
          <source>The resolution of the monotonic clock on Windows is usually around 15.6 msec. The best resolution is 0.5 msec. The resolution depends on the hardware (availability of &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET&lt;/a&gt;) and on the Windows configuration.</source>
          <target state="translated">Windows上单调时钟的分辨率通常约为15.6毫秒。最佳分辨率为0.5毫秒。分辨率取决于硬件（&lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET的&lt;/a&gt;可用性）和Windows配置。</target>
        </trans-unit>
        <trans-unit id="23afb147c8179b8f68c17fd58f357125e59e0db0" translate="yes" xml:space="preserve">
          <source>The response of the server if available, as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">服务器的响应（如果可用），作为&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="95b4a5945a9d59be88563c27320b9c7635065496" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">其余参数直接传递给&lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="052ba8628ec266d089850d398e2dffdd0e02362b" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">其余参数直接传递给&lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ca5b530f7beb3fc6b574e16895459606aeaf92d" translate="yes" xml:space="preserve">
          <source>The result can be limited to a certain &lt;em&gt;depth&lt;/em&gt; (ellipsis is used for deeper contents):</source>
          <target state="translated">结果可以限制在一定&lt;em&gt;深度&lt;/em&gt;（省略号用于更深的内容）：</target>
        </trans-unit>
        <trans-unit id="a9012bf262281e6649bca6a62eaca3e50309e056" translate="yes" xml:space="preserve">
          <source>The result has the following attributes:</source>
          <target state="translated">结果具有以下属性。</target>
        </trans-unit>
        <trans-unit id="d5ea300b3c43932c2e9cb889e33cb6a294bf5718" translate="yes" xml:space="preserve">
          <source>The result is a new handle to the specified key.</source>
          <target state="translated">结果是一个新的句柄,指向指定的键。</target>
        </trans-unit>
        <trans-unit id="9024c97c37bab6f072465e9e7695a1952461ee28" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 2 items:</source>
          <target state="translated">结果是2个项目的元组。</target>
        </trans-unit>
        <trans-unit id="1a572ad972b418d4c59e22b81a05b05d111a4914" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 3 items:</source>
          <target state="translated">结果是3个项目的元组。</target>
        </trans-unit>
        <trans-unit id="f4bcd3a97a994995588bc014bbbc763f7890e121" translate="yes" xml:space="preserve">
          <source>The result is an integer that holds the value of the handle before it is detached. If the handle is already detached or closed, this will return zero.</source>
          <target state="translated">结果是一个整数,在句柄被分离之前保持句柄的值。如果句柄已经被分离或关闭,则返回0。</target>
        </trans-unit>
        <trans-unit id="bc91a99e93e2fcc5cbfe344c6e0c71fb2ef0bf7a" translate="yes" xml:space="preserve">
          <source>The result is an iterator yielding named tuples, exactly like &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt;. It does not yield an &lt;a href=&quot;token#token.ENCODING&quot;&gt;&lt;code&gt;ENCODING&lt;/code&gt;&lt;/a&gt; token.</source>
          <target state="translated">结果是一个迭代器产生名为tuple的元组，就像&lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; 一样&lt;/a&gt;。它不会产生&lt;a href=&quot;token#token.ENCODING&quot;&gt; &lt;code&gt;ENCODING&lt;/code&gt; &lt;/a&gt;令牌。</target>
        </trans-unit>
        <trans-unit id="3227fd92d80664a7f623acd9fc4b4f80817cf727" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; along with &lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt;&lt;code&gt;stat.S_ISDIR()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">结果被缓存在 &lt;code&gt;os.DirEntry&lt;/code&gt; 对象上，并为&lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 单独缓存。调用&lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt; &lt;code&gt;stat.S_ISDIR()&lt;/code&gt; &lt;/a&gt;来获取最新信息。</target>
        </trans-unit>
        <trans-unit id="4473ea6bd1dfef0f8e5256127ece39f3a793c098" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">结果被缓存在 &lt;code&gt;os.DirEntry&lt;/code&gt; 对象上，并为&lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 提供了单独的缓存。调用&lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt;来获取最新信息。</target>
        </trans-unit>
        <trans-unit id="abbcee36b5dc7353a13842e21fc33ea3c7933bbe" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Caching, system calls made, and exceptions raised are as per &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果缓存在 &lt;code&gt;os.DirEntry&lt;/code&gt; 对象上。根据&lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt;进行缓存，进行系统调用并引发异常。</target>
        </trans-unit>
        <trans-unit id="3192c8c4ca27941d16ad2ca7a7e1edfbad87bea5" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Call &lt;a href=&quot;os.path#os.path.islink&quot;&gt;&lt;code&gt;os.path.islink()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">结果缓存在 &lt;code&gt;os.DirEntry&lt;/code&gt; 对象上。调用&lt;a href=&quot;os.path#os.path.islink&quot;&gt; &lt;code&gt;os.path.islink()&lt;/code&gt; &lt;/a&gt;以获取最新信息。</target>
        </trans-unit>
        <trans-unit id="7ec4d3f1d1936a6194d9445a29e0390f42b8ffe0" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Use &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; to fetch up-to-date information.</source>
          <target state="translated">结果缓存在 &lt;code&gt;os.DirEntry&lt;/code&gt; 对象上。使用 &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; 来获取最新信息。</target>
        </trans-unit>
        <trans-unit id="5690da7531945b23a6747716ed812a15a6963db0" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: &lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt;&lt;code&gt;Statistic.size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt;&lt;code&gt;Statistic.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果按大小从大到小排序：&lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt; &lt;code&gt;Statistic.size&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt;然后是&lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt; &lt;code&gt;Statistic.traceback&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e30839178f92f01b4544ae6c03a099b48de5230b" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt;&lt;code&gt;StatisticDiff.size_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt;&lt;code&gt;StatisticDiff.size&lt;/code&gt;&lt;/a&gt;, absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt;&lt;code&gt;StatisticDiff.count_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt;&lt;code&gt;StatisticDiff.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">绝对值：结果从最大到最小排序&lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt; &lt;code&gt;StatisticDiff.size_diff&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt; &lt;code&gt;StatisticDiff.size&lt;/code&gt; &lt;/a&gt;，绝对值&lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt; &lt;code&gt;StatisticDiff.count_diff&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt;然后&lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt; &lt;code&gt;StatisticDiff.traceback&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50b5cd74dc096919d1c4da6da20c54e0531391ea" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt;.</source>
          <target state="translated">结果看起来像是 &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad2b0ea3374869382c5626a60af95e870167d18d" translate="yes" xml:space="preserve">
          <source>The result might look something like:</source>
          <target state="translated">结果可能是这样的:</target>
        </trans-unit>
        <trans-unit id="2d4f8c61300cb280ac5d234b75011a45b9bc1479" translate="yes" xml:space="preserve">
          <source>The result objects from the &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt;&lt;code&gt;urldefrag()&lt;/code&gt;&lt;/a&gt; functions are subclasses of the &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; type. These subclasses add the attributes listed in the documentation for those functions, the encoding and decoding support described in the previous section, as well as an additional method:</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt; &lt;code&gt;urldefrag()&lt;/code&gt; &lt;/a&gt;函数的结果对象是&lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt;类型的子类。这些子类添加了文档中列出的这些功能的属性，上一节中描述的编码和解码支持以及其他方法：</target>
        </trans-unit>
        <trans-unit id="9496af6babd167973be214aba8ba07e03e05847c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;mock()&lt;/code&gt; is an async function which will have the outcome of &lt;code&gt;side_effect&lt;/code&gt; or &lt;code&gt;return_value&lt;/code&gt; after it has been awaited:</source>
          <target state="translated">&lt;code&gt;mock()&lt;/code&gt; 的结果是一个异步函数，在等待它之后将具有 &lt;code&gt;side_effect&lt;/code&gt; 或 &lt;code&gt;return_value&lt;/code&gt; 的结果：</target>
        </trans-unit>
        <trans-unit id="3bc1a9c58cb8683698d580da1969870f58ded608" translate="yes" xml:space="preserve">
          <source>The result of the manipulations is treated as a filename, and returned as the first component of the tuple, with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; called on it to yield the second component. (Note: this is the reverse of the order of arguments in instance initialization!)</source>
          <target state="translated">操纵的结果被视为文件名，并作为元组的第一个组件返回，并对其调用&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;以产生第二个组件。（注意：这与实例初始化中的参数顺序相反！）</target>
        </trans-unit>
        <trans-unit id="c4e4c6d23f69a76d21bae775427f415590d0980e" translate="yes" xml:space="preserve">
          <source>The result of this method remains unchanged if passed back through the original parsing function:</source>
          <target state="translated">如果通过原解析函数传回,该方法的结果保持不变。</target>
        </trans-unit>
        <trans-unit id="b224f9d4a8e2657de972e24ed3a8dcad279caaed" translate="yes" xml:space="preserve">
          <source>The result of this search is cached, see the description of &lt;a href=&quot;#tempfile.tempdir&quot;&gt;&lt;code&gt;tempdir&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">此搜索的结果被缓存，请参见下面对&lt;a href=&quot;#tempfile.tempdir&quot;&gt; &lt;code&gt;tempdir&lt;/code&gt; &lt;/a&gt;的描述。</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="8adfe478f190ec97428a206efe4a03294cd0ba54" translate="yes" xml:space="preserve">
          <source>The resulting archive contains:</source>
          <target state="translated">由此产生的档案包括:</target>
        </trans-unit>
        <trans-unit id="90e2c6b6dcb04800642e191cd676cfaeabfba943" translate="yes" xml:space="preserve">
          <source>The resulting class has an extra attribute &lt;code&gt;__annotations__&lt;/code&gt; giving a dict that maps the field names to the field types. (The field names are in the &lt;code&gt;_fields&lt;/code&gt; attribute and the default values are in the &lt;code&gt;_field_defaults&lt;/code&gt; attribute both of which are part of the namedtuple API.)</source>
          <target state="translated">结果类具有一个额外的属性 &lt;code&gt;__annotations__&lt;/code&gt; ，该属性给出了将字段名称映射到字段类型的字典。（字段名称位于 &lt;code&gt;_fields&lt;/code&gt; 属性中，默认值位于 &lt;code&gt;_field_defaults&lt;/code&gt; 属性中，这两者都是namedtuple API的一部分。）</target>
        </trans-unit>
        <trans-unit id="ac591da9469504c2f08a211e0607aa5095412244" translate="yes" xml:space="preserve">
          <source>The resulting file has one additional method, &lt;code&gt;rollover()&lt;/code&gt;, which causes the file to roll over to an on-disk file regardless of its size.</source>
          <target state="translated">生成的文件还有另一种方法 &lt;code&gt;rollover()&lt;/code&gt; ，无论文件大小如何，该方法都会使该文件翻转到磁盘文件上。</target>
        </trans-unit>
        <trans-unit id="7a519c498f72663eddb55617af16d07f81874708" translate="yes" xml:space="preserve">
          <source>The resulting launcher uses the &amp;ldquo;Limited ABI&amp;rdquo;, so it will run unchanged with any version of Python 3.x. All it needs is for Python (&lt;code&gt;python3.dll&lt;/code&gt;) to be on the user&amp;rsquo;s &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">生成的启动器使用&amp;ldquo;受限的ABI&amp;rdquo;，因此它在任何版本的Python 3.x上都将保持不变。它所需要的只是将Python（ &lt;code&gt;python3.dll&lt;/code&gt; ）放在用户的 &lt;code&gt;PATH&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="041df9dbd79b18f129d74bcb4f756b61fc62aae3" translate="yes" xml:space="preserve">
          <source>The resulting list is sorted alphabetically. For example:</source>
          <target state="translated">由此产生的列表按字母顺序排列。例如:</target>
        </trans-unit>
        <trans-unit id="11ae1369bb9e6629cc72ed8a767763bea61545dd" translate="yes" xml:space="preserve">
          <source>The resulting object can be used as a context manager (see &lt;a href=&quot;#tempfile-examples&quot;&gt;Examples&lt;/a&gt;). On completion of the context or destruction of the file object the temporary file will be removed from the filesystem.</source>
          <target state="translated">生成的对象可用作上下文管理器（请参见&lt;a href=&quot;#tempfile-examples&quot;&gt;示例&lt;/a&gt;）。在上下文完成或文件对象破坏后，将从文件系统中删除临时文件。</target>
        </trans-unit>
        <trans-unit id="b846db5f32c3790b53bc4bb912c408d3783cc876" translate="yes" xml:space="preserve">
          <source>The resulting profiler will then call &lt;code&gt;your_time_func&lt;/code&gt;. Depending on whether you are using &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;profile.Profile&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;cProfile.Profile&lt;/code&gt;, &lt;code&gt;your_time_func&lt;/code&gt;&amp;rsquo;s return value will be interpreted differently:</source>
          <target state="translated">然后，生成的探查器将调用 &lt;code&gt;your_time_func&lt;/code&gt; 。根据您使用的是&lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;profile.Profile&lt;/code&gt; &lt;/a&gt;还是 &lt;code&gt;cProfile.Profile&lt;/code&gt; ， &lt;code&gt;your_time_func&lt;/code&gt; 的返回值将被不同地解释：</target>
        </trans-unit>
        <trans-unit id="9db83e41267f4a8fdf365bc69918d1db78163746" translate="yes" xml:space="preserve">
          <source>The resulting string is a series of &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; characters, where both &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; are quoted using the &lt;em&gt;quote_via&lt;/em&gt; function. By default, &lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt;&lt;code&gt;quote_plus()&lt;/code&gt;&lt;/a&gt; is used to quote the values, which means spaces are quoted as a &lt;code&gt;'+'&lt;/code&gt; character and &amp;lsquo;/&amp;rsquo; characters are encoded as &lt;code&gt;%2F&lt;/code&gt;, which follows the standard for GET requests (&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). An alternate function that can be passed as &lt;em&gt;quote_via&lt;/em&gt; is &lt;a href=&quot;#urllib.parse.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;, which will encode spaces as &lt;code&gt;%20&lt;/code&gt; and not encode &amp;lsquo;/&amp;rsquo; characters. For maximum control of what is quoted, use &lt;code&gt;quote&lt;/code&gt; and specify a value for &lt;em&gt;safe&lt;/em&gt;.</source>
          <target state="translated">结果字符串是由 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 字符分隔的一系列 &lt;code&gt;key=value&lt;/code&gt; 对，其中&lt;em&gt;键&lt;/em&gt;和&lt;em&gt;值&lt;/em&gt;都使用&lt;em&gt;quote_via&lt;/em&gt;函数引用。默认情况下，&lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt; &lt;code&gt;quote_plus()&lt;/code&gt; &lt;/a&gt;用于引用值，这意味着空格用 &lt;code&gt;'+'&lt;/code&gt; 字符引用，'/'字符用 &lt;code&gt;%2F&lt;/code&gt; 编码，这遵循GET请求的标准（ &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ）。可以作为&lt;em&gt;quote_via&lt;/em&gt;传递的替代函数是&lt;a href=&quot;#urllib.parse.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt;，它将空格编码为 &lt;code&gt;%20&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;并且不编码&amp;ldquo; /&amp;rdquo;字符。为了最大程度地控制引用的内容，请使用 &lt;code&gt;quote&lt;/code&gt; 并指定&lt;em&gt;safe&lt;/em&gt;的值。</target>
        </trans-unit>
        <trans-unit id="134dbdf4e5b3e8f4c11ac5b7031c7464a782c4b0" translate="yes" xml:space="preserve">
          <source>The results printed are</source>
          <target state="translated">打印的结果是</target>
        </trans-unit>
        <trans-unit id="40b9c6b5f8f1f52e60312075db0d81f7e179965d" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt; &lt;/a&gt;的返回类型，默认为&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;。可以在类的实例上重写此属性，以返回&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;的自定义子类。</target>
        </trans-unit>
        <trans-unit id="89dd3bf6bf7ac8497c6fbc6d05c26cdd36021e83" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt;的返回类型默认为&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;。可以在类的实例上重写此属性，以返回&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;的自定义子类。</target>
        </trans-unit>
        <trans-unit id="f9ec2a98ecd14904d5d3e12031555d453b9272e4" translate="yes" xml:space="preserve">
          <source>The return value and side effect of child mocks can be set in the same way, using dotted notation. As you can&amp;rsquo;t use dotted names directly in a call you have to create a dictionary and unpack it using &lt;code&gt;**&lt;/code&gt;:</source>
          <target state="translated">子模拟的返回值和副作用可以使用点分表示法以相同方式设置。由于您不能在通话中直接使用点名，因此必须创建字典并使用 &lt;code&gt;**&lt;/code&gt; 解压缩它：</target>
        </trans-unit>
        <trans-unit id="cfba5477b25ec732aaec2f8665d9842e6b57be0f" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;'fork'&lt;/code&gt;, &lt;code&gt;'spawn'&lt;/code&gt;, &lt;code&gt;'forkserver'&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;'fork'&lt;/code&gt; is the default on Unix, while &lt;code&gt;'spawn'&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">返回值可以是 &lt;code&gt;'fork'&lt;/code&gt; ， &lt;code&gt;'spawn'&lt;/code&gt; ， &lt;code&gt;'forkserver'&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; 。在Unix上， &lt;code&gt;'fork'&lt;/code&gt; 是默认设置，而在Windows 上， &lt;code&gt;'spawn'&lt;/code&gt; 是默认设置。</target>
        </trans-unit>
        <trans-unit id="223d2d76ad021d8b529310c6405479566a8c8808" translate="yes" xml:space="preserve">
          <source>The return value can be used to decide whether to use &lt;code&gt;sys.ps1&lt;/code&gt; or &lt;code&gt;sys.ps2&lt;/code&gt; to prompt the next line.</source>
          <target state="translated">该返回值可用于决定是使用 &lt;code&gt;sys.ps1&lt;/code&gt; 还是 &lt;code&gt;sys.ps2&lt;/code&gt; 来提示下一行。</target>
        </trans-unit>
        <trans-unit id="82c5f5dea7de57114b406e5a2d10e9c9e968c10c" translate="yes" xml:space="preserve">
          <source>The return value consists of two elements: the first is a list of &lt;code&gt;(option,
value)&lt;/code&gt; pairs; the second is the list of program arguments left after the option list was stripped (this is a trailing slice of &lt;em&gt;args&lt;/em&gt;). Each option-and-value pair returned has the option as its first element, prefixed with a hyphen for short options (e.g., &lt;code&gt;'-x'&lt;/code&gt;) or two hyphens for long options (e.g., &lt;code&gt;'--long-option'&lt;/code&gt;), and the option argument as its second element, or an empty string if the option has no argument. The options occur in the list in the same order in which they were found, thus allowing multiple occurrences. Long and short options may be mixed.</source>
          <target state="translated">返回值包含两个元素：第一个是 &lt;code&gt;(option, value)&lt;/code&gt; 对的列表；第二个是剥离选项列表后剩下的程序参数列表（这是&lt;em&gt;args&lt;/em&gt;的结尾部分）。返回的每个选项和值对都将选项作为其第一个元素，对于短选项（例如 &lt;code&gt;'-x'&lt;/code&gt; ）或连字符（对于长选项（例如 &lt;code&gt;'--long-option'&lt;/code&gt; ）两个前缀）加上前缀option参数作为其第二个元素；如果option没有参数，则为空字符串。这些选项在列表中的出现顺序与找到它们的顺序相同，因此允许多次出现。多头和空头期权可能混合在一起。</target>
        </trans-unit>
        <trans-unit id="5b318dc5ec8c485015ebb1f6e03ac8abd47ac343" translate="yes" xml:space="preserve">
          <source>The return value from &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, representing a process that has finished.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;的返回值，表示已完成的进程。</target>
        </trans-unit>
        <trans-unit id="195dd48fbab413248bb85b38523fd13efbbb7f22" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not (for example if the &lt;em&gt;timeout&lt;/em&gt; expired).</source>
          <target state="translated">如果成功获取了锁，则返回值为 &lt;code&gt;True&lt;/code&gt; ,否则为 &lt;code&gt;False&lt;/code&gt; （例如，如果&lt;em&gt;超时&lt;/em&gt;已过期）。</target>
        </trans-unit>
        <trans-unit id="eda0a021ff1189c021e62f957666234bdf263951" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not.</source>
          <target state="translated">如果成功获取了锁，则返回值为 &lt;code&gt;True&lt;/code&gt; ,否则为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8808521af7a00af7e8d52a0e5473a4b0b4e5fac" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; unless a given &lt;em&gt;timeout&lt;/em&gt; expired, in which case it is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">除非给定&lt;em&gt;超时&lt;/em&gt;过期，否则返回值为 &lt;code&gt;True&lt;/code&gt; ，在这种情况下，返回值为 &lt;code&gt;False&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4ae8192eff447288a99dac0e9794231ef6500ec" translate="yes" xml:space="preserve">
          <source>The return value is a 3-tuple: &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt;</source>
          <target state="translated">返回值是一个 &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt; 组：元类，名称空间，kwds</target>
        </trans-unit>
        <trans-unit id="7b945fb04db6f2dc42f9466e62c23e6c77c03488" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(data, ancdata, msg_flags,
address)&lt;/code&gt;. The &lt;em&gt;data&lt;/em&gt; item is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the non-ancillary data received. The &lt;em&gt;ancdata&lt;/em&gt; item is a list of zero or more tuples &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; representing the ancillary data (control messages) received: &lt;em&gt;cmsg_level&lt;/em&gt; and &lt;em&gt;cmsg_type&lt;/em&gt; are integers specifying the protocol level and protocol-specific type respectively, and &lt;em&gt;cmsg_data&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the associated data. The &lt;em&gt;msg_flags&lt;/em&gt; item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. If the receiving socket is unconnected, &lt;em&gt;address&lt;/em&gt; is the address of the sending socket, if available; otherwise, its value is unspecified.</source>
          <target state="translated">返回值是一个四元组：（ &lt;code&gt;(data, ancdata, msg_flags, address)&lt;/code&gt; 。该&lt;em&gt;数据&lt;/em&gt;项是一个&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;物体保持接收到的非辅助数据。该&lt;em&gt;ancdata&lt;/em&gt;项是零个或多个元组的列表 &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; 表示接收到的辅助数据（控制消息）：&lt;em&gt;cmsg_level&lt;/em&gt;和&lt;em&gt;cmsg_type&lt;/em&gt;分别指定协议级和协议特定的类型整数，且&lt;em&gt;cmsg_data&lt;/em&gt;是一个&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;对象保存相关数据。该&lt;em&gt;msg_flags&lt;/em&gt;item是指示接收消息条件的各种标志的按位或；有关详细信息，请参见系统文档。如果接收套接字未连接，则&lt;em&gt;address&lt;/em&gt;是发送套接字的地址（如果有）；否则，其值未指定。</target>
        </trans-unit>
        <trans-unit id="ec52b14196aa8b67fb13e7dd77583943a73c711f" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(nbytes, ancdata, msg_flags,
address)&lt;/code&gt;, where &lt;em&gt;nbytes&lt;/em&gt; is the total number of bytes of non-ancillary data written into the buffers, and &lt;em&gt;ancdata&lt;/em&gt;, &lt;em&gt;msg_flags&lt;/em&gt; and &lt;em&gt;address&lt;/em&gt; are the same as for &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回值是一个4元组： &lt;code&gt;(nbytes, ancdata, msg_flags, address)&lt;/code&gt; ，其中&lt;em&gt;nbytes&lt;/em&gt;是写入缓冲区的非辅助数据的字节总数，并且&lt;em&gt;ancdata&lt;/em&gt;，&lt;em&gt;msg_flags&lt;/em&gt;和&lt;em&gt;address&lt;/em&gt;与&lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a3679d1ebda849b521be84cc43353121c8bf475" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, its items can be accessed by index or as named attributes:</source>
          <target state="translated">返回值是一个&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;命名元组&lt;/a&gt;，它的项目可以通过索引或命名属性来访问：</target>
        </trans-unit>
        <trans-unit id="a21f880bf0c221fb7bd28fe3925cdefb842fe84c" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, which means that its items can be accessed by index or as named attributes, which are:</source>
          <target state="translated">返回值是一个&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;命名的元组&lt;/a&gt;，这意味着它的项目可以通过索引或命名属性来访问，它们是：</target>
        </trans-unit>
        <trans-unit id="3dcc2832db4e1520ff1937a113e6ceacec019f27" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, its items can be accessed by index or as named attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a675db84959f2871c29882a80f8a41acc95b6f" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, which means that its items can be accessed by index or as named attributes, which are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79bebb781377c88d2426bd2e892f766e40af986" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline and some containing internal newlines. &lt;a href=&quot;#traceback.print_exception&quot;&gt;&lt;code&gt;print_exception()&lt;/code&gt;&lt;/a&gt; is a wrapper around this method which just prints the lines to a file.</source>
          <target state="translated">返回值是一个字符串生成器，每个字符串都以换行符结尾，其中一些包含内部换行符。&lt;a href=&quot;#traceback.print_exception&quot;&gt; &lt;code&gt;print_exception()&lt;/code&gt; &lt;/a&gt;是此方法的包装，该方法仅将行打印到文件中。</target>
        </trans-unit>
        <trans-unit id="a39f9ba7b42bdef3242d2a6379c62a27fc8940a4" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline.</source>
          <target state="translated">返回值是一个字符串的生成器,每个字符串都以换行结束。</target>
        </trans-unit>
        <trans-unit id="2aa307fb21c6adc415c25262d44c8b663f654493" translate="yes" xml:space="preserve">
          <source>The return value is a string suitable for passing as the &lt;em&gt;salt&lt;/em&gt; argument to &lt;a href=&quot;#module-crypt&quot;&gt;&lt;code&gt;crypt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回值是一个字符串，适合作为&lt;em&gt;salt&lt;/em&gt;参数传递给&lt;a href=&quot;#module-crypt&quot;&gt; &lt;code&gt;crypt()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb4d092528f9e91105a3ac157c24fdb4bd62ec35" translate="yes" xml:space="preserve">
          <source>The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a file descriptor becoming ready, three empty lists are returned.</source>
          <target state="translated">返回值是三个已准备好的对象列表:前三个参数的子集。当超时后没有文件描述符准备好,就会返回三个空列表。</target>
        </trans-unit>
        <trans-unit id="b21ee42cf5b7e0115206de0a971aa7059c5ad292" translate="yes" xml:space="preserve">
          <source>The return value is a tuple &lt;code&gt;(type, encoding)&lt;/code&gt; where &lt;em&gt;type&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; if the type can&amp;rsquo;t be guessed (missing or unknown suffix) or a string of the form &lt;code&gt;'type/subtype'&lt;/code&gt;, usable for a MIME &lt;em&gt;content-type&lt;/em&gt; header.</source>
          <target state="translated">返回值是一个元组 &lt;code&gt;(type, encoding)&lt;/code&gt; ，如果无法猜测类型（缺少或后缀未知）或 &lt;code&gt;'type/subtype'&lt;/code&gt; 为'type / subtype'的字符串（可用于MIME &lt;em&gt;内容类型&lt;/em&gt;标头），则&lt;em&gt;type&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f4a573600a626a8f185b96ba9102f89d318696f0" translate="yes" xml:space="preserve">
          <source>The return value is an integer in the range 0 to &lt;em&gt;parties&lt;/em&gt; &amp;ndash; 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:</source>
          <target state="translated">返回值是介于0到&lt;em&gt;各方之间&lt;/em&gt;的整数&amp;ndash; 1，每个线程不同。这可以用来选择一个线程来做一些特殊的内务处理，例如：</target>
        </trans-unit>
        <trans-unit id="68775830b95659615877cbf5628aaf0c84b66aa7" translate="yes" xml:space="preserve">
          <source>The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt;, &lt;code&gt;si_errno&lt;/code&gt;, &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_band&lt;/code&gt;.</source>
          <target state="translated">返回值是一个对象，代表 &lt;code&gt;siginfo_t&lt;/code&gt; 结构中包含的数据，即： &lt;code&gt;si_signo&lt;/code&gt; ， &lt;code&gt;si_code&lt;/code&gt; ， &lt;code&gt;si_errno&lt;/code&gt; ， &lt;code&gt;si_pid&lt;/code&gt; ， &lt;code&gt;si_uid&lt;/code&gt; ， &lt;code&gt;si_status&lt;/code&gt; 和 &lt;code&gt;si_band&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dd4f172a531526aa876355a2856ad8c9907382d" translate="yes" xml:space="preserve">
          <source>The return value is the amount of bytes copied. This could be less than the amount requested.</source>
          <target state="translated">返回值是复制的字节数。该值可能小于请求的数量。</target>
        </trans-unit>
        <trans-unit id="234b77eb5ef9ce8e2fcd0cab178d38c7fe6e2fca" translate="yes" xml:space="preserve">
          <source>The return value is the handle of the opened key. If the function fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">返回值是打开的键的句柄。如果函数失败，则会引发&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="dc2557edef7b13a49741617f01fcdba9c83af0ab" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes written, which is always equal to the length of &lt;em&gt;buf&lt;/em&gt;.</source>
          <target state="translated">返回值是写入的字节数，该字节数始终等于&lt;em&gt;buf&lt;/em&gt;的长度。</target>
        </trans-unit>
        <trans-unit id="62cbe2d5893b50a026494fd6fee07e88125f71a2" translate="yes" xml:space="preserve">
          <source>The return value is the result of the evaluated expression. Syntax errors are reported as exceptions. Example:</source>
          <target state="translated">返回值是被评估的表达式的结果。语法错误会作为异常报告。例子:</target>
        </trans-unit>
        <trans-unit id="9b569673d77a40a394325206915c8d678591e80f" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;MagicMock.__iter__()&lt;/code&gt; can be any iterable object and isn&amp;rsquo;t required to be an iterator:</source>
          <target state="translated">&lt;code&gt;MagicMock.__iter__()&lt;/code&gt; 的返回值可以是任何可迭代的对象，并且不需要是迭代器：</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">返回值。</target>
        </trans-unit>
        <trans-unit id="c335b6a081673631849b8c4210800ac50f8d01b4" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; has an additional property named &lt;code&gt;exact_type&lt;/code&gt; that contains the exact operator type for &lt;a href=&quot;token#token.OP&quot;&gt;&lt;code&gt;OP&lt;/code&gt;&lt;/a&gt; tokens. For all other token types &lt;code&gt;exact_type&lt;/code&gt; equals the named tuple &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">返回的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;命名元组&lt;/a&gt;还有一个名为 &lt;code&gt;exact_type&lt;/code&gt; 的附加属性，其中包含&lt;a href=&quot;token#token.OP&quot;&gt; &lt;code&gt;OP&lt;/code&gt; &lt;/a&gt;令牌的确切运算符类型。对于所有其他令牌类型， &lt;code&gt;exact_type&lt;/code&gt; 等于命名的元组 &lt;code&gt;type&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="495f48621e32e7509fedd99ab5f78e8a65d4cf9e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; has an additional property named &lt;code&gt;exact_type&lt;/code&gt; that contains the exact operator type for &lt;a href=&quot;token#token.OP&quot;&gt;&lt;code&gt;OP&lt;/code&gt;&lt;/a&gt; tokens. For all other token types &lt;code&gt;exact_type&lt;/code&gt; equals the named tuple &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218f49d63286506033a67a8dba86f5940020dd19" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs each doctest in the module. If any of the doctests fail, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">返回的&lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt;将由unittest框架运行，并运行模块中的每个doctest。如果任何doctest测试失败，则综合单元测试失败，并引发 &lt;code&gt;failureException&lt;/code&gt; 异常，该异常显示包含测试的文件名和（有时是近似的）行号。</target>
        </trans-unit>
        <trans-unit id="618fad8d525738d877dbb6063471d43125b8556e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs the interactive examples in each file. If an example in any file fails, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">返回的&lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt;将由unittest框架运行，并在每个文件中运行交互式示例。如果任何文件中的示例失败，则合成的单元测试将失败，并且会引发 &lt;code&gt;failureException&lt;/code&gt; 异常，显示包含测试的文件的名称和（有时是近似的）行号。</target>
        </trans-unit>
        <trans-unit id="8b0b6693ed01480a4045d1615145e7f1cf427145" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;reader&lt;/em&gt; and &lt;em&gt;writer&lt;/em&gt; objects are instances of &lt;a href=&quot;#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">返回的&lt;em&gt;reader&lt;/em&gt;和&lt;em&gt;writer&lt;/em&gt;对象是&lt;a href=&quot;#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt;类的实例。</target>
        </trans-unit>
        <trans-unit id="1f96113d2cc534f7b7ef202bb144452bc5b31520" translate="yes" xml:space="preserve">
          <source>The returned env-builder is an object which has a method, &lt;code&gt;create&lt;/code&gt;:</source>
          <target state="translated">返回的env-builder是具有方法 &lt;code&gt;create&lt;/code&gt; 的对象：</target>
        </trans-unit>
        <trans-unit id="9970c84bf057aeac8a4c0b64f98b2bef0c7395a9" translate="yes" xml:space="preserve">
          <source>The returned finder is cached in &lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt;&lt;code&gt;sys.path_importer_cache&lt;/code&gt;&lt;/a&gt; if it was newly created by a path hook.</source>
          <target state="translated">如果返回的查找程序是由路径挂钩新创建的，则将其缓存在&lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt; &lt;code&gt;sys.path_importer_cache&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7674772aaa7c3d69c9b57697d013a9667cfcd482" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the Python calling convention. The function will &lt;em&gt;not&lt;/em&gt; release the GIL during the call.</source>
          <target state="translated">返回的函数原型创建使用Python调用约定的函数。该函数&lt;em&gt;不会&lt;/em&gt;在调用过程中释放GIL。</target>
        </trans-unit>
        <trans-unit id="73c626017b30388a1c8db06167f7d17be6ca7ee7" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If &lt;em&gt;use_errno&lt;/em&gt; is set to true, the ctypes private copy of the system &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; variable is exchanged with the real &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value before and after the call; &lt;em&gt;use_last_error&lt;/em&gt; does the same for the Windows error code.</source>
          <target state="translated">返回的函数原型创建使用标准C调用约定的函数。该函数将在调用过程中释放GIL。如果&lt;em&gt;use_errno&lt;/em&gt;设置为true，则在调用之前和之后，系统&lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt;变量的ctypes私有副本与实际&lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt;值交换；&lt;em&gt;use_last_error&lt;/em&gt;对Windows错误代码执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="eb4feb485235fe9256f397550a46a3fa39024fdd" translate="yes" xml:space="preserve">
          <source>The returned group is itself an iterator that shares the underlying iterable with &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt;. Because the source is shared, when the &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt; object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list:</source>
          <target state="translated">返回的组本身就是一个与&lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt;共享底层可迭代对象的迭代器。因为源是共享的，所以当前进&lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt;对象时，先前的组不再可见。因此，如果以后需要该数据，则应将其存储为列表：</target>
        </trans-unit>
        <trans-unit id="a343865b66bc184e10fbb10b32f697cc0caef5f8" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">返回的插入点&lt;em&gt;i&lt;/em&gt;将数组&lt;em&gt;a&lt;/em&gt;划分为两半，以使 &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; 左侧和 &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; 在右边。</target>
        </trans-unit>
        <trans-unit id="669ff275cf0c181691c08c67e29ac61182ca5faf" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">返回的插入点&lt;em&gt;i&lt;/em&gt;将数组&lt;em&gt;a&lt;/em&gt;划分为两半，以使 &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; 和 &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; 在右边。</target>
        </trans-unit>
        <trans-unit id="53fe3542ff9fe12d2d3e1cb75fec1f427d2042d1" translate="yes" xml:space="preserve">
          <source>The returned instance is a proxy object with methods that can be used to invoke corresponding RPC calls on the remote server. If the remote server supports the introspection API, the proxy can also be used to query the remote server for the methods it supports (service discovery) and fetch other server-associated metadata.</source>
          <target state="translated">返回的实例是一个带有方法的代理对象,可以用来在远程服务器上调用相应的RPC调用。如果远程服务器支持自省API,代理也可以用来查询远程服务器支持的方法(服务发现),并获取其他与服务器相关的元数据。</target>
        </trans-unit>
        <trans-unit id="c7288877f11459f6ab28ff785ec24351c4aa442e" translate="yes" xml:space="preserve">
          <source>The returned iterator raises a &lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt;&lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; is called and the result isn&amp;rsquo;t available after &lt;em&gt;timeout&lt;/em&gt; seconds from the original call to &lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt;&lt;code&gt;Executor.map()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;timeout&lt;/em&gt; can be an int or a float. If &lt;em&gt;timeout&lt;/em&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, there is no limit to the wait time.</source>
          <target state="translated">返回的迭代器抛出一个&lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt; &lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt; &lt;/a&gt;如果&lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt;被调用，结果不是后可用&lt;em&gt;超时时间&lt;/em&gt;从原来的呼叫秒至&lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt; &lt;code&gt;Executor.map()&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;超时&lt;/em&gt;可以是int或float。如果未指定&lt;em&gt;timeout&lt;/em&gt;或 &lt;code&gt;None&lt;/code&gt; ，则等待时间没有限制。</target>
        </trans-unit>
        <trans-unit id="d24b35f2954c9d4ccee793a3bacdf330b843c26a" translate="yes" xml:space="preserve">
          <source>The returned list will be sorted in the order they appeared in the original header list or were added to this instance, and may contain duplicates. Any fields deleted and re-inserted are always appended to the header list. If no fields exist with the given name, returns an empty list.</source>
          <target state="translated">返回的列表将按照它们在原始头列表中出现的顺序或添加到本实例中的顺序进行排序,并可能包含重复的内容。任何被删除和重新插入的字段都会被添加到头列表中。如果给定名称的字段不存在,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="3cf77cc7d995685ae1853fc00d68172f80697726" translate="yes" xml:space="preserve">
          <source>The returned object can only be used as a foreign function call parameter. It behaves similar to &lt;code&gt;pointer(obj)&lt;/code&gt;, but the construction is a lot faster.</source>
          <target state="translated">返回的对象只能用作外部函数调用参数。它的行为类似于 &lt;code&gt;pointer(obj)&lt;/code&gt; ，但是构造要快得多。</target>
        </trans-unit>
        <trans-unit id="944d9677c5e06b68735cee6e1214d92d8f721c2f" translate="yes" xml:space="preserve">
          <source>The returned object is a file-like object whose &lt;code&gt;_file&lt;/code&gt; attribute is either an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; object (depending on whether binary or text &lt;em&gt;mode&lt;/em&gt; was specified) or a true file object, depending on whether &lt;code&gt;rollover()&lt;/code&gt; has been called. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="translated">返回的对象是类似文件的对象，其 &lt;code&gt;_file&lt;/code&gt; 属性是&lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt;对象（取决于是否指定了二进制或文本&lt;em&gt;模式&lt;/em&gt;）或真实的文件对象（取决于是否已调用 &lt;code&gt;rollover()&lt;/code&gt; )。就像普通文件一样，可以在&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句中使用该文件状对象。</target>
        </trans-unit>
        <trans-unit id="63b21c5c69819c1c91c200a05cc8559e27dc6d81" translate="yes" xml:space="preserve">
          <source>The returned object is a file-like object whose &lt;code&gt;_file&lt;/code&gt; attribute is either an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; object (depending on whether binary or text &lt;em&gt;mode&lt;/em&gt; was specified) or a true file object, depending on whether &lt;code&gt;rollover()&lt;/code&gt; has been called. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba4ccce7e74dabed802bdff9234a1122b0c4107" translate="yes" xml:space="preserve">
          <source>The returned object is a true file object on POSIX platforms. On other platforms, it is a file-like object whose &lt;code&gt;file&lt;/code&gt; attribute is the underlying true file object.</source>
          <target state="translated">返回的对象是POSIX平台上的真实文件对象。在其他平台上，它是一个类似文件的对象，其 &lt;code&gt;file&lt;/code&gt; 属性是基础真实文件对象。</target>
        </trans-unit>
        <trans-unit id="2d61336daabebc08319a6841656673dafcebf7ab" translate="yes" xml:space="preserve">
          <source>The returned property object also has the attributes &lt;code&gt;fget&lt;/code&gt;, &lt;code&gt;fset&lt;/code&gt;, and &lt;code&gt;fdel&lt;/code&gt; corresponding to the constructor arguments.</source>
          <target state="translated">返回的属性对象还具有对应于构造函数参数的属性 &lt;code&gt;fget&lt;/code&gt; ， &lt;code&gt;fset&lt;/code&gt; 和 &lt;code&gt;fdel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1078216c97fc2cb54c2f472e356bef009039e6ee" translate="yes" xml:space="preserve">
          <source>The returned string includes the currency symbol if &lt;em&gt;symbol&lt;/em&gt; is true, which is the default. If &lt;em&gt;grouping&lt;/em&gt; is true (which is not the default), grouping is done with the value. If &lt;em&gt;international&lt;/em&gt; is true (which is not the default), the international currency symbol is used.</source>
          <target state="translated">如果&lt;em&gt;symbol&lt;/em&gt;为true，则返回的字符串包含货币符号，这是默认值。如果&lt;em&gt;分组&lt;/em&gt;为true（这不是默认设置），则使用该值进行分组。如果&lt;em&gt;international&lt;/em&gt;为true（不是默认值），则使用国际货币符号。</target>
        </trans-unit>
        <trans-unit id="bfd8c08933483893f75b8b7fdb1a5319adb8fe8b" translate="yes" xml:space="preserve">
          <source>The returned value is shell-escaped to protect against injection vulnerabilities (see &lt;a href=&quot;#shlex.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">返回的值是转义的shell，以防止注入漏洞（请参阅&lt;a href=&quot;#shlex.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f6e2d49d3bb8bfbea2c5c7323f9693333c6fa08d" translate="yes" xml:space="preserve">
          <source>The returned value will be a copy of the result of the call or a proxy to a new shared object &amp;ndash; see documentation for the &lt;em&gt;method_to_typeid&lt;/em&gt; argument of &lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt;&lt;code&gt;BaseManager.register()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值将是调用结果的副本或新共享对象的代理-请参阅&lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt; &lt;code&gt;BaseManager.register()&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;method_to_typeid&lt;/em&gt;参数的文档。</target>
        </trans-unit>
        <trans-unit id="cb70bf1a9ac2dc854c2a93668773c6b77481b4f9" translate="yes" xml:space="preserve">
          <source>The root item may not be deleted.</source>
          <target state="translated">根项目不得删除。</target>
        </trans-unit>
        <trans-unit id="3890ffaf0a29880883c4c861690ab01939538879" translate="yes" xml:space="preserve">
          <source>The root item may not be detached.</source>
          <target state="translated">根项不得脱离。</target>
        </trans-unit>
        <trans-unit id="8724776bb36627ef8324ed2cee8596adf2c111ef" translate="yes" xml:space="preserve">
          <source>The root logger must specify a level and a list of handlers. An example of a root logger section is given below.</source>
          <target state="translated">根记录器必须指定一个级别和一个处理程序列表。下面给出了一个根记录器部分的例子。</target>
        </trans-unit>
        <trans-unit id="c8aa0536a231f439ca03f4c8eab15fc8b24452be" translate="yes" xml:space="preserve">
          <source>The root of the numeric hierarchy. If you just want to check if an argument &lt;em&gt;x&lt;/em&gt; is a number, without caring what kind, use &lt;code&gt;isinstance(x, Number)&lt;/code&gt;.</source>
          <target state="translated">数字层次结构的根。如果只想检查参数&lt;em&gt;x&lt;/em&gt;是否为数字，而又不关心哪种类型，请使用 &lt;code&gt;isinstance(x, Number)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9b3ac7015fd4390c4695675d6ffe8261b0a5c14" translate="yes" xml:space="preserve">
          <source>The routine takes time proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">该例程所花费的时间与 &lt;code&gt;len(fragment)&lt;/code&gt; 成正比。</target>
        </trans-unit>
        <trans-unit id="c458d0b0fe448ae2d0a4d83d7ec4609f7e529b08" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to never expose Future objects in user-facing APIs, and the recommended way to create a Future object is to call &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt;&lt;code&gt;loop.create_future()&lt;/code&gt;&lt;/a&gt;. This way alternative event loop implementations can inject their own optimized implementations of a Future object.</source>
          <target state="translated">经验法则是从不公开面向用户的API中的Future对象，建议的创建Future对象的方法是调用&lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt; &lt;code&gt;loop.create_future()&lt;/code&gt; &lt;/a&gt;。这样，备用事件循环实现可以注入自己对Future对象的优化实现。</target>
        </trans-unit>
        <trans-unit id="b9d329adbb453311cb1f83021747ba8fe74b77e2" translate="yes" xml:space="preserve">
          <source>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, etc.), descriptors (methods are also descriptors), and variable names listed in &lt;code&gt;_ignore_&lt;/code&gt;.</source>
          <target state="translated">允许使用的规则如下：以单个下划线开头和结尾的名称被枚举保留，不能使用；枚举中定义的所有其他属性将成为该枚举的成员，但特殊方法（&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt;等），描述符（方法也是描述符）和 &lt;code&gt;_ignore_&lt;/code&gt; 中列出的变量名称除外。</target>
        </trans-unit>
        <trans-unit id="ebe703515002487a2b0312a4527a4116966e227c" translate="yes" xml:space="preserve">
          <source>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, etc.), descriptors (methods are also descriptors), and variable names listed in &lt;code&gt;_ignore_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61698b0a1acd1e3ec12a3341214499d204a64941" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;fallback&lt;/code&gt; argument can be used with the &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt;&lt;code&gt;getint()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt;&lt;code&gt;getfloat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt; methods, for example:</source>
          <target state="translated">相同的 &lt;code&gt;fallback&lt;/code&gt; 参数可以与&lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt; &lt;code&gt;getint()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt; &lt;code&gt;getfloat()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt;方法一起使用，例如：</target>
        </trans-unit>
        <trans-unit id="fe0ad54a153c9c16fc953f6457e2a08391e6ddfd" translate="yes" xml:space="preserve">
          <source>The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file.</source>
          <target state="translated">同样的道理也适用于用系统默认编码以外的其他编码写法:在打开输出文件时指定编码参数。</target>
        </trans-unit>
        <trans-unit id="ee42da4190d9eab8ed782585f2b56ceaaa52fe60" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;7bit&lt;/code&gt;, except that the returned value is bytes.</source>
          <target state="translated">如果&lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;7bit&lt;/code&gt; ，则与&lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，不同之处在于返回的值是字节。</target>
        </trans-unit>
        <trans-unit id="d0e9d4a97e7a8c08a403fe0b581fce1bbbca7af2" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.Policy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, except that the returned value should be a bytes object rather than a string.</source>
          <target state="translated">与&lt;a href=&quot;#email.policy.Policy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;相同，除了返回的值应该是字节对象而不是字符串。</target>
        </trans-unit>
        <trans-unit id="d6e3c5f083440fe9bbf887c7f88bf5f04da824a4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be &amp;ldquo;correct&amp;rdquo;.)</source>
          <target state="translated">与&lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt;相同，除了应将返回的迭代器的结果顺序视为任意顺序。（只有在只有一个工作进程时，才能保证订单是&amp;ldquo;正确的&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4f0e693b02ea181bbef1c28375701342551141cd" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt;&lt;code&gt;RawArray()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes array.</source>
          <target state="translated">与&lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt; &lt;code&gt;RawArray()&lt;/code&gt; &lt;/a&gt;相同，不同之处在于，取决于&lt;em&gt;锁&lt;/em&gt;的值，可以返回进程安全的同步包装而不是原始ctypes数组。</target>
        </trans-unit>
        <trans-unit id="6cfb2c05572cc99d847c223df250f30149473f05" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt;&lt;code&gt;RawValue()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes object.</source>
          <target state="translated">与&lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt; &lt;code&gt;RawValue()&lt;/code&gt; &lt;/a&gt;相同，除了根据&lt;em&gt;锁&lt;/em&gt;的值可以返回进程安全的同步包装程序而不是原始ctypes对象之外。</target>
        </trans-unit>
        <trans-unit id="f1a01b84361f53398479056f09464345f02bd043" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;found&amp;rsquo; response.</source>
          <target state="translated">与&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt;相同，但是要求&amp;ldquo;找到&amp;rdquo;响应。</target>
        </trans-unit>
        <trans-unit id="750e1ad255c0e380db439ef1dab8b7f8f0852e72" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;see other&amp;rsquo; response.</source>
          <target state="translated">与&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt;相同，但是要求&amp;ldquo;查看其他&amp;rdquo;响应。</target>
        </trans-unit>
        <trans-unit id="49feac63317adae6711e747adbff6e95df411957" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;temporary redirect&amp;rsquo; response.</source>
          <target state="translated">与&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt;相同，但是需要&amp;ldquo;临时重定向&amp;rdquo;响应。</target>
        </trans-unit>
        <trans-unit id="8230ae470e5c59b6f3c4881b2a39dc38aedffae8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'d'&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;'d'&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="916ed3638cece914ee2fc8b1652dfd07c219904b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">同为 &lt;code&gt;'s'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="829e5aa2fdb08ee46435ea6cf88e99987eb1e392" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;SMTP&lt;/code&gt; except that &lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. Useful for serializing messages to a message store without using encoded words in the headers. Should only be used for SMTP transmission if the sender or recipient addresses have non-ASCII characters (the &lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt;&lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt;&lt;/a&gt; method handles this automatically).</source>
          <target state="translated">与 &lt;code&gt;SMTP&lt;/code&gt; 相同，只是&lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;True&lt;/code&gt; 。在不使用标头中的编码字的情况下，将消息序列化到消息存储很有用。如果发件人或收件人地址具有非ASCII字符（&lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt; &lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt; &lt;/a&gt;方法自动处理），则仅应将其用于SMTP传输。</target>
        </trans-unit>
        <trans-unit id="532039e29cf202190420d4e6121e0b76b86ef2f9" translate="yes" xml:space="preserve">
          <source>The same as the ellipsis literal &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;. Special value used mostly in conjunction with extended slicing syntax for user-defined container data types.</source>
          <target state="translated">与省略号&amp;ldquo; &lt;code&gt;...&lt;/code&gt; &amp;rdquo;相同。特殊值，通常与用户定义的容器数据类型的扩展切片语法结合使用。</target>
        </trans-unit>
        <trans-unit id="b854b52ef7bd2ccfd324aed6049a603fc8fb7751" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#timeit.Timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; class and its methods:</source>
          <target state="translated">使用&lt;a href=&quot;#timeit.Timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt;类及其方法可以完成相同的操作：</target>
        </trans-unit>
        <trans-unit id="e4760c18be62a9d7dec114efc1c14ea346862762" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#zipapp.create_archive&quot;&gt;&lt;code&gt;create_archive()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">使用&lt;a href=&quot;#zipapp.create_archive&quot;&gt; &lt;code&gt;create_archive()&lt;/code&gt; &lt;/a&gt;函数可以完成相同的操作：</target>
        </trans-unit>
        <trans-unit id="1b0e747134e643ee7b418317f6324c54e529d2a3" translate="yes" xml:space="preserve">
          <source>The same effect may be had by simply calling the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">只需调用&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;实例，就可以达到相同的效果。</target>
        </trans-unit>
        <trans-unit id="7ee95343967fc42163ec543a6a7c5d8e1c5cae20" translate="yes" xml:space="preserve">
          <source>The same example using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句的相同示例：</target>
        </trans-unit>
        <trans-unit id="3136db70fec32537a20098587fa73ba76fdb2570" translate="yes" xml:space="preserve">
          <source>The same example using the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21bc4fc65a842a8845b57c261870ced2cf68832" translate="yes" xml:space="preserve">
          <source>The same pattern can be used for other similar decorators: &lt;code&gt;staticmethod&lt;/code&gt;, &lt;code&gt;abstractmethod&lt;/code&gt;, and others.</source>
          <target state="translated">可以将相同的模式用于其他类似的装饰器： &lt;code&gt;staticmethod&lt;/code&gt; ， &lt;code&gt;abstractmethod&lt;/code&gt; 以及其他。</target>
        </trans-unit>
        <trans-unit id="f3dc1e5cb29f2f7aa6277b41a35ebe97be0cfb65" translate="yes" xml:space="preserve">
          <source>The same thing can be achieved in the constructor call to mocks:</source>
          <target state="translated">同样的事情也可以在mocks的构造函数调用中实现。</target>
        </trans-unit>
        <trans-unit id="9af275e54fe0509a959d2873010a1018b8c67266" translate="yes" xml:space="preserve">
          <source>The same, in reverse, has to be applied when converting from 8 to 16, 24 or 32 bit width samples.</source>
          <target state="translated">当从8位转换到16位、24位或32位宽度的样本时,同样的情况必须反过来应用。</target>
        </trans-unit>
        <trans-unit id="c88a256e1b82c972fc3255b212954b50fdc69e36" translate="yes" xml:space="preserve">
          <source>The sample mean gives an unbiased estimate of the true population mean, so that when taken on average over all the possible samples, &lt;code&gt;mean(sample)&lt;/code&gt; converges on the true mean of the entire population. If &lt;em&gt;data&lt;/em&gt; represents the entire population rather than a sample, then &lt;code&gt;mean(data)&lt;/code&gt; is equivalent to calculating the true population mean &amp;mu;.</source>
          <target state="translated">样本均值给出了真实总体均值的无偏估计，因此，在所有可能的样本中取平均值时， &lt;code&gt;mean(sample)&lt;/code&gt; 收敛于整个总体的真实均值。如果&lt;em&gt;数据&lt;/em&gt;代表整个总体而不是样本，则 &lt;code&gt;mean(data)&lt;/code&gt; 等同于计算真实总体平均值&amp;mu;。</target>
        </trans-unit>
        <trans-unit id="1b6d6ef4afe2bb1824ced5480b576fe34f8770f0" translate="yes" xml:space="preserve">
          <source>The scheduling priority for a scheduling policy.</source>
          <target state="translated">排程策略的排程优先级。</target>
        </trans-unit>
        <trans-unit id="a789b28f90e6a13336b5a43d081ce2c14e0e32bb" translate="yes" xml:space="preserve">
          <source>The schema describes a set of logging objects - loggers, handlers, formatters, filters - which are connected to each other in an object graph. Thus, the schema needs to represent connections between the objects. For example, say that, once configured, a particular logger has attached to it a particular handler. For the purposes of this discussion, we can say that the logger represents the source, and the handler the destination, of a connection between the two. Of course in the configured objects this is represented by the logger holding a reference to the handler. In the configuration dict, this is done by giving each destination object an id which identifies it unambiguously, and then using the id in the source object&amp;rsquo;s configuration to indicate that a connection exists between the source and the destination object with that id.</source>
          <target state="translated">该模式描述了一组记录对象-记录器，处理程序，格式化程序，过滤器-它们在对象图中相互连接。因此，该模式需要表示对象之间的连接。例如，假设配置后，特定的记录器便已附加了特定的处理程序。出于讨论的目的，我们可以说记录器代表两者之间连接的源，而处理程序则代表两者的目的地。当然，在已配置的对象中，这由记录器代表对处理程序的引用来表示。在配置命令中，这是通过给每个目标对象一个明确标识它的ID来完成的，然后使用源对象的配置中的ID来指示在具有该ID的源和目标对象之间存在连接。</target>
        </trans-unit>
        <trans-unit id="357034175b5af2bba561f08e5abd996027ed8d5a" translate="yes" xml:space="preserve">
          <source>The schema supports user-defined objects for handlers, filters and formatters. (Loggers do not need to have different types for different instances, so there is no support in this configuration schema for user-defined logger classes.)</source>
          <target state="translated">该模式支持用户定义的处理程序、过滤器和格式化对象。记录仪不需要为不同的实例拥有不同的类型,因此在此配置模式中不支持用户定义的记录仪类)。</target>
        </trans-unit>
        <trans-unit id="f5cf05c8728d612453b8e5fe6be79e83aec4e76a" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; in the Python source distribution is a GUI tool for test discovery and execution. This is intended largely for ease of use for those new to unit testing. For production environments it is recommended that tests be driven by a continuous integration system such as &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; or &lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson&lt;/a&gt;.</source>
          <target state="translated">Python源代码分发中的脚本 &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; 是用于测试发现和执行的GUI工具。这主要是为了使单元测试新手易于使用。对于生产环境，建议使用诸如&lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;，&lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;或&lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson之&lt;/a&gt;类的持续集成系统来驱动测试。</target>
        </trans-unit>
        <trans-unit id="c4d31cf92666ad824bb699fb1bd45276cded366b" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; in the Python source distribution is a GUI tool for test discovery and execution. This is intended largely for ease of use for those new to unit testing. For production environments it is recommended that tests be driven by a continuous integration system such as &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; or &lt;a href=&quot;https://travis-ci.com&quot;&gt;Travis-CI&lt;/a&gt;, or &lt;a href=&quot;https://www.appveyor.com/&quot;&gt;AppVeyor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590472629c42696a37ed0e6a09a2aa0815298d38" translate="yes" xml:space="preserve">
          <source>The script &lt;strong&gt;webbrowser&lt;/strong&gt; can be used as a command-line interface for the module. It accepts a URL as the argument. It accepts the following optional parameters: &lt;code&gt;-n&lt;/code&gt; opens the URL in a new browser window, if possible; &lt;code&gt;-t&lt;/code&gt; opens the URL in a new browser page (&amp;ldquo;tab&amp;rdquo;). The options are, naturally, mutually exclusive. Usage example:</source>
          <target state="translated">脚本&lt;strong&gt;Webbrowser&lt;/strong&gt;可用作模块的命令行界面。它接受URL作为参数。它接受以下可选参数： &lt;code&gt;-n&lt;/code&gt; 如果可能，在新的浏览器窗口中打开URL； &lt;code&gt;-t&lt;/code&gt; 在新的浏览器页面（&amp;ldquo;选项卡&amp;rdquo;）中打开URL。这些选项自然是互斥的。用法示例：</target>
        </trans-unit>
        <trans-unit id="09613d977f5c11ceb44df4f71da6d33551c96b71" translate="yes" xml:space="preserve">
          <source>The script does not close the file explicitly. By default, Python does not emit any warning. Example using README.txt, which has 269 lines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abc03b295e1e06c729bb0d780860fe53a6dc23c" translate="yes" xml:space="preserve">
          <source>The script that is going to get analyzed later on (bacon.py):</source>
          <target state="translated">稍后要分析的脚本(bacon.py)。</target>
        </trans-unit>
        <trans-unit id="ee5b7d667b6a893a07a7bd795cbb225c3559dadb" translate="yes" xml:space="preserve">
          <source>The script that will output the report of bacon.py:</source>
          <target state="translated">将输出bacon.py报告的脚本。</target>
        </trans-unit>
        <trans-unit id="5c61673a55b5a1642add6c59c9e42d35514177fa" translate="yes" xml:space="preserve">
          <source>The script&amp;rsquo;s input is connected to the client too, and sometimes the form data is read this way; at other times the form data is passed via the &amp;ldquo;query string&amp;rdquo; part of the URL. This module is intended to take care of the different cases and provide a simpler interface to the Python script. It also provides a number of utilities that help in debugging scripts, and the latest addition is support for file uploads from a form (if your browser supports it).</source>
          <target state="translated">脚本的输入也连接到客户端，有时以这种方式读取表单数据。在其他时候，表单数据是通过URL的&amp;ldquo;查询字符串&amp;rdquo;部分传递的。该模块旨在处理不同的情况，并为Python脚本提供更简单的界面。它还提供了许多有助于调试脚本的实用程序，并且最新添加的功能是支持从表单上传文件（如果您的浏览器支持的话）。</target>
        </trans-unit>
        <trans-unit id="441a890d73099fc8af230e1050ed5b9319ec7466" translate="yes" xml:space="preserve">
          <source>The scroll bar widget.</source>
          <target state="translated">滚动条小部件。</target>
        </trans-unit>
        <trans-unit id="0b2bbe283f6190e08707f30471c6201f3310ca5a" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;em&gt;source&lt;/em&gt; of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the &lt;code&gt;start&lt;/code&gt; parameter to specify a different starting value). A new class derived from &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is returned. In other words, the above assignment to &lt;code&gt;Animal&lt;/code&gt; is equivalent to:</source>
          <target state="translated">第二个参数是枚举成员名称的&lt;em&gt;来源&lt;/em&gt;。它可以是由空格分隔的名称字符串，名称序列，带有键/值对的2元组序列或名称到值的映射（例如字典）。最后两个选项可为枚举分配任意值；其他自动分配以1开头的递增整数（使用 &lt;code&gt;start&lt;/code&gt; 参数指定其他起始值）。返回从&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;派生的新类。换句话说，上面对 &lt;code&gt;Animal&lt;/code&gt; 的赋值等效于：</target>
        </trans-unit>
        <trans-unit id="3efff11fbd76f900b41de117b028cbaa28815d1e" translate="yes" xml:space="preserve">
          <source>The second argument, if present, specifies the file location to copy to (if absent, the location will be a tempfile with a generated name). The third argument, if present, is a callable that will be called once on establishment of the network connection and once after each block read thereafter. The callable will be passed three arguments; a count of blocks transferred so far, a block size in bytes, and the total size of the file. The third argument may be &lt;code&gt;-1&lt;/code&gt; on older FTP servers which do not return a file size in response to a retrieval request.</source>
          <target state="translated">第二个参数（如果存在）指定要复制到的文件位置（如果不存在，该位置将是具有生成名称的临时文件）。第三个参数（如果存在）是可调用的，它将在建立网络连接时被调用一次，此后每个块读取一次。可调用对象将被传递三个参数。到目前为止已传输的块数，块大小（以字节为单位）以及文件的总大小。在较旧的FTP服务器上，第三个参数可能为 &lt;code&gt;-1&lt;/code&gt; ，而这些FTP服务器不会响应检索请求而返回文件大小。</target>
        </trans-unit>
        <trans-unit id="cc342d27fa2c9d42507affce95a9a6a6d772b584" translate="yes" xml:space="preserve">
          <source>The second case may be used on Mac OS X and FreeBSD where &lt;em&gt;headers&lt;/em&gt; and &lt;em&gt;trailers&lt;/em&gt; are arbitrary sequences of buffers that are written before and after the data from &lt;em&gt;in&lt;/em&gt; is written. It returns the same as the first case.</source>
          <target state="translated">第二壳体可在Mac OS X和FreeBSD，其中可以使用&lt;em&gt;报头&lt;/em&gt;和&lt;em&gt;拖车&lt;/em&gt;是被之前和之后的数据从写入缓冲器的任意序列&lt;em&gt;中&lt;/em&gt;被写入。返回的结果与第一种情况相同。</target>
        </trans-unit>
        <trans-unit id="dc9ed3bf0e51e74a14ebf33737b710029623e678" translate="yes" xml:space="preserve">
          <source>The second case may be used on Mac OS X and FreeBSD where &lt;em&gt;headers&lt;/em&gt; and &lt;em&gt;trailers&lt;/em&gt; are arbitrary sequences of buffers that are written before and after the data from &lt;em&gt;in_fd&lt;/em&gt; is written. It returns the same as the first case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15a93322f7f76be0339398712074ec97be438ed" translate="yes" xml:space="preserve">
          <source>The second form of the constructor sets the corresponding attributes, described below. The attributes default to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not specified. For backwards compatibility, if three arguments are passed, the &lt;a href=&quot;#BaseException.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; attribute contains only a 2-tuple of the first two constructor arguments.</source>
          <target state="translated">构造函数的第二种形式设置相应的属性，如下所述。如果未指定，则属性默认为&lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。为了向后兼容，如果传递了三个参数，则&lt;a href=&quot;#BaseException.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt;属性仅包含前两个构造函数参数中的2元组。</target>
        </trans-unit>
        <trans-unit id="34296b7537391f3024117b10f7c3a5ff4dd5b9d8" translate="yes" xml:space="preserve">
          <source>The second group of options controls how test failures are reported:</source>
          <target state="translated">第二组选项控制测试失败的报告方式。</target>
        </trans-unit>
        <trans-unit id="a82684db899d668b167ed8174dc94a018b1dcbae" translate="yes" xml:space="preserve">
          <source>The second issue is more general to mocking. If you refactor some of your code, rename members and so on, any tests for code that is still using the &lt;em&gt;old api&lt;/em&gt; but uses mocks instead of the real objects will still pass. This means your tests can all pass even though your code is broken.</source>
          <target state="translated">第二个问题对嘲讽更为笼统。如果您重构某些代码，重命名成员等，则仍在使用&lt;em&gt;旧api&lt;/em&gt;但使用模拟而不是真实对象的任何代码测试仍将通过。这意味着即使代码已损坏，您的测试也可以全部通过。</target>
        </trans-unit>
        <trans-unit id="8e61c328cb69d5d01b94c637cb52d86809c1a81f" translate="yes" xml:space="preserve">
          <source>The second optional keyword argument is &lt;em&gt;stack_info&lt;/em&gt;, which defaults to &lt;code&gt;False&lt;/code&gt;. If true, stack information is added to the logging message, including the actual logging call. Note that this is not the same stack information as that displayed through specifying &lt;em&gt;exc_info&lt;/em&gt;: The former is stack frames from the bottom of the stack up to the logging call in the current thread, whereas the latter is information about stack frames which have been unwound, following an exception, while searching for exception handlers.</source>
          <target state="translated">第二个可选关键字参数是&lt;em&gt;stack_info&lt;/em&gt;，默认为 &lt;code&gt;False&lt;/code&gt; 。如果为true，则将堆栈信息添加到日志消息中，包括实际的日志调用。请注意，这与通过指定&lt;em&gt;exc_info&lt;/em&gt;显示的堆栈信息&lt;em&gt;不同&lt;/em&gt;：前者是从堆栈底部一直到当前线程中的日志记录调用的堆栈帧，而后者是有关已&lt;em&gt;取消缠绕&lt;/em&gt;的堆栈帧的信息，在搜索异常处理程序时跟踪异常。</target>
        </trans-unit>
        <trans-unit id="2e4c730e515ea8c7e6ed22283aa940b7c170b41b" translate="yes" xml:space="preserve">
          <source>The second problem is that it &amp;ldquo;takes a while&amp;rdquo; from when an event is dispatched until the profiler&amp;rsquo;s call to get the time actually &lt;em&gt;gets&lt;/em&gt; the state of the clock. Similarly, there is a certain lag when exiting the profiler event handler from the time that the clock&amp;rsquo;s value was obtained (and then squirreled away), until the user&amp;rsquo;s code is once again executing. As a result, functions that are called many times, or call many functions, will typically accumulate this error. The error that accumulates in this fashion is typically less than the accuracy of the clock (less than one clock tick), but it &lt;em&gt;can&lt;/em&gt; accumulate and become very significant.</source>
          <target state="translated">第二个问题是，它&amp;ldquo;需要一段时间，&amp;rdquo;从当事件被分派到分析器的调用来获取时实际&lt;em&gt;获得&lt;/em&gt;的时钟的状态。类似地，从获取时钟值（然后松散）开始，退出探查器事件处理程序会有一定的滞后，直到再次执行用户的代码为止。结果，被多次调用或调用许多函数的函数通常会累积此错误。以这种方式累积的误差通常小于时钟的精度（小于一个时钟滴答），但是&lt;em&gt;会&lt;/em&gt;累积并变得非常重要。</target>
        </trans-unit>
        <trans-unit id="d32a81f75e96772b4383da9bf4edd54a00fffcf6" translate="yes" xml:space="preserve">
          <source>The second section is usually HTML, which allows the client software to display nicely formatted text with header, in-line images, etc. Here&amp;rsquo;s Python code that prints a simple piece of HTML:</source>
          <target state="translated">第二部分通常是HTML，它允许客户端软件显示带有标题，行内图像等格式良好的文本。这是打印简单HTML的Python代码：</target>
        </trans-unit>
        <trans-unit id="3983ca9591946a2e35ceee565ce274efeaded338" translate="yes" xml:space="preserve">
          <source>The second subclass allows for connections created by a child process:</source>
          <target state="translated">第二个子类允许子进程创建的连接。</target>
        </trans-unit>
        <trans-unit id="5434750abc7b69faf1ffb090ae9381c4aab45452" translate="yes" xml:space="preserve">
          <source>The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement &amp;ldquo;diamond diagrams&amp;rdquo; where multiple base classes implement the same method. Good design dictates that this method have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime).</source>
          <target state="translated">第二个用例是在动态执行环境中支持协作式多重继承。该用例是Python特有的，在静态编译语言或仅支持单继承的语言中找不到。这样就可以在多个基类实现相同方法的情况下实现&amp;ldquo;菱形图&amp;rdquo;。良好的设计表明，此方法在每种情况下都具有相同的调用签名（因为调用的顺序是在运行时确定的，因为该顺序可以适应类层次结构中的更改，并且因为该顺序可以包含在运行时之前未知的同级类）。</target>
        </trans-unit>
        <trans-unit id="817bae41c43a2fdb49bd2ccee3ff54cd1276a64e" translate="yes" xml:space="preserve">
          <source>The sections below first document the header base classes and their attributes, followed by the API for modifying the behavior of &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;, and finally the support classes used to represent the data parsed from structured headers.</source>
          <target state="translated">以下各节首先介绍标头基类及其属性，然后介绍用于修改&lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; &lt;/a&gt;行为的API ，最后介绍用于表示从结构化标头解析的数据的支持类。</target>
        </trans-unit>
        <trans-unit id="fb511a5d628d8dbbb4b6bf34bfa204b91e9c7783" translate="yes" xml:space="preserve">
          <source>The semantics of this API resemble &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt;. The first argument of the call to &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is the name of the enumeration.</source>
          <target state="translated">该API的语义类似于&lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt;。调用&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;的第一个参数是枚举的名称。</target>
        </trans-unit>
        <trans-unit id="070609838b02b470a8593f64b9dca1e4232bafbd" translate="yes" xml:space="preserve">
          <source>The separator to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">要搜索的分隔符可以是任何&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a1f8c4e94dd9abb089388f1b1ab583d5c673046" translate="yes" xml:space="preserve">
          <source>The separator to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a15dc4df39babea8600cb0111121e4e21f2adba" translate="yes" xml:space="preserve">
          <source>The sequence</source>
          <target state="translated">顺序</target>
        </trans-unit>
        <trans-unit id="82ce3ee65d071578dc915ee005e2223c40e5f9b4" translate="yes" xml:space="preserve">
          <source>The sequence has an undefined order. Use the &lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt;&lt;code&gt;Snapshot.statistics()&lt;/code&gt;&lt;/a&gt; method to get a sorted list of statistics.</source>
          <target state="translated">序列具有不确定的顺序。使用&lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt; &lt;code&gt;Snapshot.statistics()&lt;/code&gt; &lt;/a&gt;方法可获取统计信息的排序列表。</target>
        </trans-unit>
        <trans-unit id="1e213b00d5ff7dbdcab5c0f7b3a984b54b08ecc6" translate="yes" xml:space="preserve">
          <source>The server classes support the following class variables:</source>
          <target state="translated">服务器类支持以下类变量。</target>
        </trans-unit>
        <trans-unit id="2786e902b7d48dcd206d583f8d5ed7f8b2845e8e" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the &lt;em&gt;from_addr&lt;/em&gt;.</source>
          <target state="translated">服务器不接受&lt;em&gt;from_addr&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="56dd79533db4c4efca4e68373ada164e963dde44" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the username/password combination.</source>
          <target state="translated">服务器不接受用户名/密码组合。</target>
        </trans-unit>
        <trans-unit id="4911a0a87661df881e8634adaa418fd9f284c0c2" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t reply properly to the &lt;code&gt;HELO&lt;/code&gt; greeting.</source>
          <target state="translated">服务器未正确回复 &lt;code&gt;HELO&lt;/code&gt; 问候。</target>
        </trans-unit>
        <trans-unit id="5e0a6b36ffd22e5731e4b5053ab3b1d2dd12a232" translate="yes" xml:space="preserve">
          <source>The server does not support the STARTTLS extension.</source>
          <target state="translated">服务器不支持STARTTLS扩展。</target>
        </trans-unit>
        <trans-unit id="69216622a0765e77ffc28455a50eaf3e224cceab" translate="yes" xml:space="preserve">
          <source>The server is closed asynchronously, use the &lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt;&lt;code&gt;wait_closed()&lt;/code&gt;&lt;/a&gt; coroutine to wait until the server is closed.</source>
          <target state="translated">服务器异步关闭，请使用&lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt; &lt;code&gt;wait_closed()&lt;/code&gt; &lt;/a&gt;协程等待直到服务器关闭。</target>
        </trans-unit>
        <trans-unit id="24fe7057b721b26d1b1fa4ea7e7e689979456761" translate="yes" xml:space="preserve">
          <source>The server refused our &lt;code&gt;HELO&lt;/code&gt; message.</source>
          <target state="translated">服务器拒绝了我们的 &lt;code&gt;HELO&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="fa1ff148e95189ffe6cc323c779c0d739606eede" translate="yes" xml:space="preserve">
          <source>The server replied with an unexpected error code (other than a refusal of a recipient).</source>
          <target state="translated">服务器回复了一个出乎意料的错误代码(除拒绝接收者外)。</target>
        </trans-unit>
        <trans-unit id="34d989e84ddbda8dd5a139555512942415e2023b" translate="yes" xml:space="preserve">
          <source>The set of &lt;em&gt;accessible&lt;/em&gt; functions depends on what modules have been imported into the user process, including those imported by Idle itself, and what definitions have been run, all since the last restart.</source>
          <target state="translated">自上次重新启动以来，&lt;em&gt;可访问&lt;/em&gt;功能集取决于已将哪些模块导入到用户进程中，包括由Idle本身导入的模块以及已运行的定义。</target>
        </trans-unit>
        <trans-unit id="48c2643a6d821c9e78c60b17ecf9140e016a1333" translate="yes" xml:space="preserve">
          <source>The set of all exceptions (as a tuple) that methods of &lt;a href=&quot;#ftplib.FTP&quot;&gt;&lt;code&gt;FTP&lt;/code&gt;&lt;/a&gt; instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller). This set includes the four exceptions listed above as well as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于FTP连接出现问题（与调用程序所犯的编程错误相对），&lt;a href=&quot;#ftplib.FTP&quot;&gt; &lt;code&gt;FTP&lt;/code&gt; &lt;/a&gt;实例的方法可能会引发的所有异常（作为一个元组）的集合。该集合包括上面列出的四个异常以及&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="081bb73a699c6efaecd1c8a3d733213e189df822" translate="yes" xml:space="preserve">
          <source>The set of allowed values can be extended by registering a new named error handler:</source>
          <target state="translated">允许的值集可以通过注册一个新的命名错误处理程序来扩展。</target>
        </trans-unit>
        <trans-unit id="5bdaaae3a7f0eacb814dd25f88847cfdd23e3933" translate="yes" xml:space="preserve">
          <source>The set of allowed values for the &lt;em&gt;errors&lt;/em&gt; argument can be extended with &lt;a href=&quot;#codecs.register_error&quot;&gt;&lt;code&gt;register_error()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#codecs.register_error&quot;&gt; &lt;code&gt;register_error()&lt;/code&gt; &lt;/a&gt;扩展&lt;em&gt;errors&lt;/em&gt;参数的允许值集。</target>
        </trans-unit>
        <trans-unit id="e65a0797dbedaa6af76d1a9826a2a818a37cd72e" translate="yes" xml:space="preserve">
          <source>The settings are: &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt;&lt;code&gt;OP_NO_SSLv2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt;&lt;code&gt;OP_NO_SSLv3&lt;/code&gt;&lt;/a&gt; with high encryption cipher suites without RC4 and without unauthenticated cipher suites. Passing &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt;&lt;code&gt;SERVER_AUTH&lt;/code&gt;&lt;/a&gt; as &lt;em&gt;purpose&lt;/em&gt; sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and either loads CA certificates (when at least one of &lt;em&gt;cafile&lt;/em&gt;, &lt;em&gt;capath&lt;/em&gt; or &lt;em&gt;cadata&lt;/em&gt; is given) or uses &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt; to load default CA certificates.</source>
          <target state="translated">设置为：&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt; &lt;code&gt;OP_NO_SSLv2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt; &lt;code&gt;OP_NO_SSLv3&lt;/code&gt; &lt;/a&gt;，具有不带RC4和不经过身份验证的密码套件的高加密密码套件。传递&lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt; &lt;code&gt;SERVER_AUTH&lt;/code&gt; &lt;/a&gt;作为&lt;em&gt;目的&lt;/em&gt;套&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt;到&lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;和任一负载CA证书（当在至少一个&lt;em&gt;凭证档案错误&lt;/em&gt;，&lt;em&gt;capath&lt;/em&gt;或&lt;em&gt;cadata&lt;/em&gt;给出）或用途&lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt;到负载默认的CA证书。</target>
        </trans-unit>
        <trans-unit id="5cb18ec6e44e05a517a8cfdcf1bf458112bc1e30" translate="yes" xml:space="preserve">
          <source>The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.</source>
          <target state="translated">地址表示的简式,省略了组中的前导零,完全由零组成的组的最长序列折叠成一个空组。</target>
        </trans-unit>
        <trans-unit id="f805bdc410d66fc8341d2186ebae9680f77ff29d" translate="yes" xml:space="preserve">
          <source>The sign of the result, if non-zero, is the same as that of the original dividend.</source>
          <target state="translated">如果结果非零,则与原红利的符号相同。</target>
        </trans-unit>
        <trans-unit id="ab3c6eb2972d1f89e19cb7d944ab96116d4e6c57" translate="yes" xml:space="preserve">
          <source>The sign should follow the value and currency symbol.</source>
          <target state="translated">该标志应跟随价值和货币符号。</target>
        </trans-unit>
        <trans-unit id="70ec6f78774cba196da7610b04897fe7592363d5" translate="yes" xml:space="preserve">
          <source>The sign should immediately follow the value.</source>
          <target state="translated">符号应紧跟在数值之后。</target>
        </trans-unit>
        <trans-unit id="919da334d12a2fc5f18dd4ceab7e1aada7a25231" translate="yes" xml:space="preserve">
          <source>The sign should immediately precede the value.</source>
          <target state="translated">符号应紧接在数值之前。</target>
        </trans-unit>
        <trans-unit id="1ee0667d587bb1414e44874e7413805eb554c41c" translate="yes" xml:space="preserve">
          <source>The sign should precede the value and currency symbol.</source>
          <target state="translated">符号应在价值和货币符号之前。</target>
        </trans-unit>
        <trans-unit id="7ea136642c5a17d8b5d39f8f1b4e4126da0bc289" translate="yes" xml:space="preserve">
          <source>The signal corresponding to the</source>
          <target state="translated">对应的信号</target>
        </trans-unit>
        <trans-unit id="fafae547732d3513c2c8c57b95879cfa52d4ca03" translate="yes" xml:space="preserve">
          <source>The signature of this function is dependent on what it calls. For example, the default binding (e.g. &lt;code&gt;pdb.set_trace()&lt;/code&gt;) expects no arguments, but you might bind it to a function that expects additional arguments (positional and/or keyword). The built-in &lt;code&gt;breakpoint()&lt;/code&gt; function passes its &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt; straight through. Whatever &lt;code&gt;breakpointhooks()&lt;/code&gt; returns is returned from &lt;code&gt;breakpoint()&lt;/code&gt;.</source>
          <target state="translated">该函数的签名取决于其调用的内容。例如，默认绑定（例如 &lt;code&gt;pdb.set_trace()&lt;/code&gt; ）不包含任何参数，但是您可以将其绑定到包含附加参数（位置和/或关键字）的函数。内置的 &lt;code&gt;breakpoint()&lt;/code&gt; 函数直接传递其 &lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kws&lt;/code&gt; 。无论 &lt;code&gt;breakpointhooks()&lt;/code&gt; 返回什么，都是从 &lt;code&gt;breakpoint()&lt;/code&gt; 返回的。</target>
        </trans-unit>
        <trans-unit id="8a5369a3811941d7b19f88daec4a5ed4519eb65c" translate="yes" xml:space="preserve">
          <source>The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision. Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational.</source>
          <target state="translated">有符号的零可能来自于计算的下溢。它们保留了如果进行更精确的计算会产生的符号。由于它们的大小为零,正零和负零都被视为相等,它们的符号是信息性的。</target>
        </trans-unit>
        <trans-unit id="b5a379b2046ce18280ecfda42b964c9631b600d9" translate="yes" xml:space="preserve">
          <source>The significance of a new Decimal is determined solely by the number of digits input. Context precision and rounding only come into play during arithmetic operations.</source>
          <target state="translated">一个新的十进制的意义完全由输入的数字决定。上下文的精确性和四舍五入只在算术操作中起作用。</target>
        </trans-unit>
        <trans-unit id="5c480e405fd8149079611892ee8838388cee67f5" translate="yes" xml:space="preserve">
          <source>The simplest &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; subclass will simply implement a test method (i.e. a method whose name starts with &lt;code&gt;test&lt;/code&gt;) in order to perform specific testing code:</source>
          <target state="translated">最简单的&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;子类将仅实现一个测试方法（即，名称以 &lt;code&gt;test&lt;/code&gt; 开头的方法），以执行特定的测试代码：</target>
        </trans-unit>
        <trans-unit id="6ef8da768f5e2727f7736cc3454383ef6bb831f4" translate="yes" xml:space="preserve">
          <source>The simplest example of reading a CSV file:</source>
          <target state="translated">读取CSV文件的最简单例子。</target>
        </trans-unit>
        <trans-unit id="9b3118dc14604e79ea95cac54e20a71a059c73c8" translate="yes" xml:space="preserve">
          <source>The simplest possible invocation is:</source>
          <target state="translated">最简单的调用是:</target>
        </trans-unit>
        <trans-unit id="a713cae0a63f36592c0cdcb2740d27248af6066e" translate="yes" xml:space="preserve">
          <source>The simplest text encoding (called &lt;code&gt;'latin-1'&lt;/code&gt; or &lt;code&gt;'iso-8859-1'&lt;/code&gt;) maps the code points 0&amp;ndash;255 to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;, which means that a string object that contains code points above &lt;code&gt;U+00FF&lt;/code&gt; can&amp;rsquo;t be encoded with this codec. Doing so will raise a &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt;&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;/a&gt; that looks like the following (although the details of the error message may differ): &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in
position 3: ordinal not in range(256)&lt;/code&gt;.</source>
          <target state="translated">最简单的文本编码（称为 &lt;code&gt;'latin-1'&lt;/code&gt; 或 &lt;code&gt;'iso-8859-1'&lt;/code&gt; ）将代码点0&amp;ndash;255映射到字节 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; ，这意味着包含 &lt;code&gt;U+00FF&lt;/code&gt; 以上代码点的字符串对象可以&amp;rdquo;用此编解码器编码。这样做将引发类似于以下内容的&lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt; &lt;code&gt;UnicodeEncodeError&lt;/code&gt; &lt;/a&gt;（尽管错误消息的详细信息可能有所不同）： &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1521438669cce749a2e881659e485a36336dd6cd" translate="yes" xml:space="preserve">
          <source>The simplest way to make a mock raise an exception when called is to make &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; an exception class or instance:</source>
          <target state="translated">使模拟程序在调用时引发异常的最简单方法是使&lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt;成为异常类或实例：</target>
        </trans-unit>
        <trans-unit id="881f0a260df9ba8efbf5efc927ddd30e7cae61c4" translate="yes" xml:space="preserve">
          <source>The simplest way to start using doctest (but not necessarily the way you&amp;rsquo;ll continue to do it) is to end each module &lt;code&gt;M&lt;/code&gt; with:</source>
          <target state="translated">开始使用doctest的最简单方法（但不一定是继续进行操作的方法）是使用以下命令结束每个模块 &lt;code&gt;M&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8b54b057c8ffc4d06da8fb7b215fbfa86896bff1" translate="yes" xml:space="preserve">
          <source>The single address encoded by the header value. If the header value actually contains more than one address (which would be a violation of the RFC under the default &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;), accessing this attribute will result in a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标头值编码的单个地址。如果标头值实际上包含多个地址（根据默认&lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt;，这将违反RFC ），则访问此属性将导致&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="509bf276c918b44de715498fbc395a90c417d509" translate="yes" xml:space="preserve">
          <source>The size field (a 32-bit value, encoded using big-endian byte order) gives the size of the chunk data, not including the 8-byte header.</source>
          <target state="translated">大小字段(一个32位的值,使用大字节顺序编码)给出了数据块的大小,不包括8字节的头。</target>
        </trans-unit>
        <trans-unit id="6e201cfab01f0ab4e9096a6984beacdf66e54219" translate="yes" xml:space="preserve">
          <source>The size in bytes of each element of the memoryview:</source>
          <target state="translated">内存视图中每个元素的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="266d615bc372b351e64c4e77ca0efca9ec569184" translate="yes" xml:space="preserve">
          <source>The size of any &lt;em&gt;master&lt;/em&gt; widget is determined by the size of the &amp;ldquo;slave widgets&amp;rdquo; inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed.</source>
          <target state="translated">任何&lt;em&gt;主&lt;/em&gt;窗口小部件的大小均由内部&amp;ldquo;从属窗口小部件&amp;rdquo;的大小确定。打包程序用于控制从属窗口小部件在打包它们的主窗口中出现的位置。您可以将小部件打包到框架中，也可以将框架打包到其他框架中，以实现所需的布局。此外，一旦打包，就可以动态调整该配置以适应配置的增量更改。</target>
        </trans-unit>
        <trans-unit id="0ffb029747b436ca658b1039a56350ec7fac8bf4" translate="yes" xml:space="preserve">
          <source>The size of the buffer used when &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is true. A new buffer size can be set by assigning a new integer value to this attribute. When the size is changed, the buffer will be flushed.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; &lt;/a&gt;为true 时使用的缓冲区大小。可以通过为该属性分配新的整数值来设置新的缓冲区大小。更改大小后，缓冲区将被刷新。</target>
        </trans-unit>
        <trans-unit id="ae18b13f964bb5f503e73d7da58605cb96240f81" translate="yes" xml:space="preserve">
          <source>The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to &lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt;&lt;code&gt;request_queue_size&lt;/code&gt;&lt;/a&gt; requests. Once the queue is full, further requests from clients will get a &amp;ldquo;Connection denied&amp;rdquo; error. The default value is usually 5, but this can be overridden by subclasses.</source>
          <target state="translated">请求队列的大小。如果处理单个请求需要很长时间，则将服务器繁忙时到达的所有请求放入队列，直到&lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt; &lt;code&gt;request_queue_size&lt;/code&gt; &lt;/a&gt;请求为止。一旦队列已满，来自客户端的其他请求将收到&amp;ldquo;拒绝连接&amp;rdquo;错误。默认值通常为5，但是可以被子类覆盖。</target>
        </trans-unit>
        <trans-unit id="afeaf7758b49b0bcc1c2c4a7eb27cb9ef94f1147" translate="yes" xml:space="preserve">
          <source>The size of the resulting HMAC digest in bytes.</source>
          <target state="translated">所产生的HMAC摘要的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="13040a9b4dff3237ab2d730c7d05724f985824ba" translate="yes" xml:space="preserve">
          <source>The size of the resulting hash in bytes.</source>
          <target state="translated">散列结果的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="b22005a99782de0058b087c6cd11f9d2f0afc9c5" translate="yes" xml:space="preserve">
          <source>The slash operator helps create child paths, similarly to &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">斜线运算符有助于创建子路径，类似于&lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="57467a0e7d5bab9bfe84eafe9f1864e336216635" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; is defined as the sequence of items with index &lt;em&gt;k&lt;/em&gt; such that &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is greater than &lt;code&gt;len(s)&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;j&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is greater than or equal to &lt;em&gt;j&lt;/em&gt;, the slice is empty.</source>
          <target state="translated">从&lt;em&gt;i&lt;/em&gt;到&lt;em&gt;j&lt;/em&gt;的&lt;em&gt;s&lt;/em&gt;切片被定义为索引为&lt;em&gt;k&lt;/em&gt;的项目序列，使得 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt; 。如果&lt;em&gt;i&lt;/em&gt;或&lt;em&gt;j&lt;/em&gt;大于 &lt;code&gt;len(s)&lt;/code&gt; ，请使用 &lt;code&gt;len(s)&lt;/code&gt; 。如果省略&lt;em&gt;i&lt;/em&gt;或 &lt;code&gt;None&lt;/code&gt; ，则使用 &lt;code&gt;0&lt;/code&gt; 。如果省略&lt;em&gt;j&lt;/em&gt;或 &lt;code&gt;None&lt;/code&gt; ，则使用 &lt;code&gt;len(s)&lt;/code&gt; 。如果&lt;em&gt;i&lt;/em&gt;大于或等于&lt;em&gt;j&lt;/em&gt;，则切片为空。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db14a0b504a58a7eab89d8facc7e4bc4aeddf239" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; with step &lt;em&gt;k&lt;/em&gt; is defined as the sequence of items with index &lt;code&gt;x = i + n*k&lt;/code&gt; such that &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt;. In other words, the indices are &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;i+k&lt;/code&gt;, &lt;code&gt;i+2*k&lt;/code&gt;, &lt;code&gt;i+3*k&lt;/code&gt; and so on, stopping when &lt;em&gt;j&lt;/em&gt; is reached (but never including &lt;em&gt;j&lt;/em&gt;). When &lt;em&gt;k&lt;/em&gt; is positive, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s)&lt;/code&gt; if they are greater. When &lt;em&gt;k&lt;/em&gt; is negative, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s) - 1&lt;/code&gt; if they are greater. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; are omitted or &lt;code&gt;None&lt;/code&gt;, they become &amp;ldquo;end&amp;rdquo; values (which end depends on the sign of &lt;em&gt;k&lt;/em&gt;). Note, &lt;em&gt;k&lt;/em&gt; cannot be zero. If &lt;em&gt;k&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, it is treated like &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">的切片&lt;em&gt;小号&lt;/em&gt;从&lt;em&gt;我&lt;/em&gt;到&lt;em&gt;Ĵ&lt;/em&gt;与步骤&lt;em&gt;ķ&lt;/em&gt;被定义为与索引项的序列 &lt;code&gt;x = i + n*k&lt;/code&gt; ，使得 &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt; 。换句话说，索引是 &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;i+k&lt;/code&gt; ， &lt;code&gt;i+2*k&lt;/code&gt; ， &lt;code&gt;i+3*k&lt;/code&gt; 等，直到达到&lt;em&gt;j&lt;/em&gt;时停止（但不包括&lt;em&gt;j&lt;/em&gt;）。当&lt;em&gt;k&lt;/em&gt;为正时，如果&lt;em&gt;i&lt;/em&gt;和&lt;em&gt;j&lt;/em&gt;较大，则将它们减小为 &lt;code&gt;len(s)&lt;/code&gt; 。当&lt;em&gt;k&lt;/em&gt;为负数时，&lt;em&gt;i&lt;/em&gt;和&lt;em&gt;j&lt;/em&gt;如果更大，则减小为 &lt;code&gt;len(s) - 1&lt;/code&gt; 。如果省略&lt;em&gt;i&lt;/em&gt;或&lt;em&gt;j&lt;/em&gt;或 &lt;code&gt;None&lt;/code&gt; ，它们将成为&amp;ldquo;结束&amp;rdquo;值（该结束取决于&lt;em&gt;k&lt;/em&gt;的符号）。注意，&lt;em&gt;k&lt;/em&gt;不能为零。如果&lt;em&gt;k&lt;/em&gt;为 &lt;code&gt;None&lt;/code&gt; ，则将其视为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afdb447ab4240dc7c528e0d82c283987648888fa" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">非相等&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;对象之间的最小可能差异 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90720b6f330c793f876d3bf1fd81961094e9877c" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;, although note that arithmetic on &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects is not supported.</source>
          <target state="translated">非相等&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;对象之间的最小可能差异 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; ，尽管请注意，不支持对&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;对象进行算术运算。</target>
        </trans-unit>
        <trans-unit id="afa9031721d8fc24f5ec4d17be75903371aa9acc" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">非相等&lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt;对象之间的最小可能差异 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8b267b31e001c792ef50cc23ab663368acac284" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal date objects, &lt;code&gt;timedelta(days=1)&lt;/code&gt;.</source>
          <target state="translated">非相等日期对象之间的最小可能差异 &lt;code&gt;timedelta(days=1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0564cff39070c9ab1eb076afb4a73ed5e6110583" translate="yes" xml:space="preserve">
          <source>The smallest year number allowed in a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. &lt;a href=&quot;#datetime.MINYEAR&quot;&gt;&lt;code&gt;MINYEAR&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;对象中允许的最小年份。&lt;a href=&quot;#datetime.MINYEAR&quot;&gt; &lt;code&gt;MINYEAR&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac827978185abe9e1d5f1031d46773536abfd304" translate="yes" xml:space="preserve">
          <source>The snapshot does not include memory blocks allocated before the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module started to trace memory allocations.</source>
          <target state="translated">快照不包括在&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt;模块开始跟踪内存分配之前分配的内存块。</target>
        </trans-unit>
        <trans-unit id="3518947197e510fbdae4f25cd9160d2281238301" translate="yes" xml:space="preserve">
          <source>The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in &lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt;. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.</source>
          <target state="translated">所谓的CSV（逗号分隔值）格式是电子表格和数据库最常用的导入和导出格式。在尝试以&lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt;中的标准化方式描述格式之前，CSV格式已使用了很多年。缺乏明确定义的标准意味着在不同应用程序生成和使用的数据中经常存在细微的差异。这些差异会使处理来自多个来源的CSV文件变得烦人。尽管如此，尽管定界符和引号字符有所不同，但总体格式足够相似，因此有可能编写一个可以有效处理此类数据的模块，从而避免了程序员对数据进行读写的细节。</target>
        </trans-unit>
        <trans-unit id="b36cc9ba1945c3f902c1340bc4df70ac928ebe63" translate="yes" xml:space="preserve">
          <source>The socket always appears &amp;lsquo;ready&amp;rsquo; and excess packets are dropped. An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;errno&lt;/code&gt; set to &lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt;&lt;code&gt;errno.ENOBUFS&lt;/code&gt;&lt;/a&gt; may or may not be raised; if it is raised, it will be reported to &lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt;&lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt;&lt;/a&gt; but otherwise ignored.</source>
          <target state="translated">套接字始终显示为&amp;ldquo;就绪&amp;rdquo;，多余的数据包将被丢弃。将 &lt;code&gt;errno&lt;/code&gt; 设置为errno的&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;。可能会或可能不会引发&lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt; &lt;code&gt;errno.ENOBUFS&lt;/code&gt; &lt;/a&gt;。如果被提出，它将被报告给&lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt; &lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt; &lt;/a&gt;，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="580375be802eccfa86b27c314a834daee2716ca5" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt; depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">套接字系列可以是&lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; ,&lt;/a&gt;具体取决于&lt;em&gt;主机&lt;/em&gt;（或提供的&lt;em&gt;Family&lt;/em&gt;参数）。</target>
        </trans-unit>
        <trans-unit id="fb23c07f91f47b0410aeac381022de5cc7bbffa6" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;, depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">套接字系列可以是&lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt;，具体取决于&lt;em&gt;主机&lt;/em&gt;（或提供的&lt;em&gt;Family&lt;/em&gt;参数）。</target>
        </trans-unit>
        <trans-unit id="07fedf17c5be40a26d98bb4e876e8380b9555b75" translate="yes" xml:space="preserve">
          <source>The socket family will be &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;; socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">套接字系列将为&lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt;；套接字类型为&lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b011b1d05810914e76faef6742cb676cbb631c4d" translate="yes" xml:space="preserve">
          <source>The socket family.</source>
          <target state="translated">插座家族。</target>
        </trans-unit>
        <trans-unit id="9d7aba26239da54cf438e8cc238babf966b10025" translate="yes" xml:space="preserve">
          <source>The socket must be bound to an address and listening for connections. The return value is a pair &lt;code&gt;(conn, address)&lt;/code&gt; where &lt;em&gt;conn&lt;/em&gt; is a &lt;em&gt;new&lt;/em&gt; socket object usable to send and receive data on the connection, and &lt;em&gt;address&lt;/em&gt; is the address bound to the socket on the other end of the connection.</source>
          <target state="translated">套接字必须绑定到一个地址并监听连接。返回值是一对 &lt;code&gt;(conn, address)&lt;/code&gt; ，其中&lt;em&gt;conn&lt;/em&gt;是可用于在连接上发送和接收数据的&lt;em&gt;新&lt;/em&gt;套接字对象，而&lt;em&gt;address&lt;/em&gt;是在连接另一端绑定到套接字的地址。</target>
        </trans-unit>
        <trans-unit id="638e4e32be2380339f29cabd9e12ac1b0fe0dcf2" translate="yes" xml:space="preserve">
          <source>The socket must be in blocking mode; it can have a timeout, but the file object&amp;rsquo;s internal buffer may end up in an inconsistent state if a timeout occurs.</source>
          <target state="translated">套接字必须处于阻止模式；它可以有一个超时，但是如果发生超时，文件对象的内部缓冲区可能会以不一致的状态结束。</target>
        </trans-unit>
        <trans-unit id="1d9b4b9003d10f23e4489c6bcfd88b97fc92ec67" translate="yes" xml:space="preserve">
          <source>The socket object on which the server will listen for incoming requests.</source>
          <target state="translated">服务器监听传入请求的套接字对象。</target>
        </trans-unit>
        <trans-unit id="26023ee861897f5dc0dfc453c9dcce20c871b174" translate="yes" xml:space="preserve">
          <source>The socket protocol.</source>
          <target state="translated">套接字协议。</target>
        </trans-unit>
        <trans-unit id="e2c94f7721fba4bae8a8259834b5d12fe4ec41fc" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">套接字类型将为&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4389e8f1de40e8b0d84b0639d44300ab08f5992c" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">套接字类型将为&lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76aee9ff5ed1acb81a710cf6c05b57b815c4d8f6" translate="yes" xml:space="preserve">
          <source>The socket type.</source>
          <target state="translated">插座类型。</target>
        </trans-unit>
        <trans-unit id="887f45826cd1154d00bb13afc1d5d24e35e6e8ea" translate="yes" xml:space="preserve">
          <source>The sockets that represent existing incoming client connections are left open.</source>
          <target state="translated">代表现有传入客户端连接的套接字是开放的。</target>
        </trans-unit>
        <trans-unit id="0fa5477e7dba26b484b00fa654ca357c05ecf60e" translate="yes" xml:space="preserve">
          <source>The sole value of the type &lt;code&gt;NoneType&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to &lt;code&gt;None&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型 &lt;code&gt;NoneType&lt;/code&gt; 的唯一值。当没有将默认参数传递给函数时，通常不使用 &lt;code&gt;None&lt;/code&gt; 来表示缺少值。分配给 &lt;code&gt;None&lt;/code&gt; 是非法的，并引发&lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85af829c0490dff673d58821b4d8b8d4f6478909" translate="yes" xml:space="preserve">
          <source>The solution is either to increase precision or to force rounding of inputs using the unary plus operation:</source>
          <target state="translated">解决的办法是提高精度,或者用单数加运算强制输入四舍五入。</target>
        </trans-unit>
        <trans-unit id="07e7971104c97772932547de9d78450a15b11c66" translate="yes" xml:space="preserve">
          <source>The solution is safe but it has a significant overhead when handling a big number of processes (&lt;em&gt;O(n)&lt;/em&gt; each time a &lt;code&gt;SIGCHLD&lt;/code&gt; is received).</source>
          <target state="translated">该解决方案是安全的，但是在处理大量进程时（每次收到 &lt;code&gt;SIGCHLD&lt;/code&gt; 时为&lt;em&gt;O（n）），&lt;/em&gt;它的开销很大。</target>
        </trans-unit>
        <trans-unit id="d4ae167e2456ec13e75cf55d1b00b0bdde55b895" translate="yes" xml:space="preserve">
          <source>The solution is to use Python&amp;rsquo;s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with &lt;code&gt;'r'&lt;/code&gt;. So &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; is a two-character string containing &lt;code&gt;'\'&lt;/code&gt; and &lt;code&gt;'n'&lt;/code&gt;, while &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.</source>
          <target state="translated">解决方案是将Python的原始字符串表示法用于正则表达式模式。反斜杠在以 &lt;code&gt;'r'&lt;/code&gt; 开头的字符串文字中不会以任何特殊方式处理。所以 &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; 是一个包含 &lt;code&gt;'\'&lt;/code&gt; 和 &lt;code&gt;'n'&lt;/code&gt; 的两个字符的字符串，而 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 是一个包含换行符的一个单字符的字符串。通常，模式将使用此原始字符串表示法在Python代码中表示。</target>
        </trans-unit>
        <trans-unit id="630211a218ed284023e80ddd9d174a4ffb85cd53" translate="yes" xml:space="preserve">
          <source>The source code for &lt;code&gt;asyncio.run()&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib/asyncio/runners.py&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;asyncio.run()&lt;/code&gt; 的源代码可以在&lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib / asyncio / runners.py中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20ad04c27726a886512a55970c3c9a2ccf70d8b8" translate="yes" xml:space="preserve">
          <source>The source code for &lt;code&gt;asyncio.run()&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/runners.py&quot;&gt;Lib/asyncio/runners.py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c7008356b1938d975233f6572bb32b9d0c6037" translate="yes" xml:space="preserve">
          <source>The source code for asyncio can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib/asyncio/&lt;/a&gt;.</source>
          <target state="translated">asyncio的源代码可以在&lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib / asyncio /中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfde801a2f8277858a1333b9a5702f14671cb49a" translate="yes" xml:space="preserve">
          <source>The source code for asyncio can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/&quot;&gt;Lib/asyncio/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afea0ea275bb3d4fffc9ec00b2df6d074be239a" translate="yes" xml:space="preserve">
          <source>The sp_namp and sp_pwdp items are strings, all others are integers. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">sp_namp和sp_pwdp项是字符串，所有其他都是整数。如果找不到要求的条目，则会引发&lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d8373511020db5acc21c29f54afacf07efb1307" translate="yes" xml:space="preserve">
          <source>The spec also applies to instantiated classes (i.e. the return value of specced mocks):</source>
          <target state="translated">该规范也适用于实例化的类(即规范化的mocks的返回值)。</target>
        </trans-unit>
        <trans-unit id="958f1bbb6de4a402e06c21a9ae860adbb3f32eb3" translate="yes" xml:space="preserve">
          <source>The spec only applies to the mock itself, so we still have the same issue with any methods on the mock:</source>
          <target state="translated">该规范只适用于mock本身,所以我们对mock上的任何方法仍有同样的问题。</target>
        </trans-unit>
        <trans-unit id="b10e3e2928198f4f7fc663290ec0cccc17419f3f" translate="yes" xml:space="preserve">
          <source>The special attribute &lt;code&gt;__members__&lt;/code&gt; is a read-only ordered mapping of names to members. It includes all names defined in the enumeration, including the aliases:</source>
          <target state="translated">特殊属性 &lt;code&gt;__members__&lt;/code&gt; 是名称到成员的只读有序映射。它包括枚举中定义的所有名称，包括别名：</target>
        </trans-unit>
        <trans-unit id="e8125b61331573562956037df84be471f1f84f34" translate="yes" xml:space="preserve">
          <source>The special behaviour of the console can be overridden by setting the environment variable PYTHONLEGACYWINDOWSSTDIO before starting Python. In that case, the console codepages are used as for any other character device.</source>
          <target state="translated">通过在启动 Python 之前设置环境变量 PYTHONLEGACYWINDOWSSTDIO,可以覆盖控制台的特殊行为。在这种情况下,控制台的代码页和其它字符设备一样使用。</target>
        </trans-unit>
        <trans-unit id="d6872f052fa8d0d34b453f09198a77148fe33e51" translate="yes" xml:space="preserve">
          <source>The special characters are:</source>
          <target state="translated">特殊字符是:</target>
        </trans-unit>
        <trans-unit id="7a5ee27573a32396d3ae3dc89046e9d91aa80669" translate="yes" xml:space="preserve">
          <source>The special global variables &lt;code&gt;__name__&lt;/code&gt;, &lt;code&gt;__spec__&lt;/code&gt;, &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; are set in the globals dictionary before the module code is executed (Note that this is a minimal set of variables - other variables may be set implicitly as an interpreter implementation detail).</source>
          <target state="translated">特殊全局变量 &lt;code&gt;__name__&lt;/code&gt; ， &lt;code&gt;__spec__&lt;/code&gt; ， &lt;code&gt;__file__&lt;/code&gt; ， &lt;code&gt;__cached__&lt;/code&gt; ， &lt;code&gt;__loader__&lt;/code&gt; 和 &lt;code&gt;__package__&lt;/code&gt; 执行模块代码之前（注意，这是一组变量最小-其他变量可以被隐式设置为一个解释实现细节）都在全局集字典。</target>
        </trans-unit>
        <trans-unit id="9467123089d6aa38d3e2e72ebf08b05d73247208" translate="yes" xml:space="preserve">
          <source>The special sequences consist of &lt;code&gt;'\'&lt;/code&gt; and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, &lt;code&gt;\$&lt;/code&gt; matches the character &lt;code&gt;'$'&lt;/code&gt;.</source>
          <target state="translated">特殊序列由 &lt;code&gt;'\'&lt;/code&gt; 和下面列表中的字符组成。如果普通字符不是ASCII数字或ASCII字母，则结果RE将与第二个字符匹配。例如， &lt;code&gt;\$&lt;/code&gt; 匹配字符 &lt;code&gt;'$'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dcbe5116b95cd6dc7867c87774d04cf7173a3e1" translate="yes" xml:space="preserve">
          <source>The specific resources that can be limited are system dependent. They are described in the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit(2)&lt;/a&gt;&lt;/em&gt; man page. The resources listed below are supported when the underlying operating system supports them; resources which cannot be checked or controlled by the operating system are not defined in this module for those platforms.</source>
          <target state="translated">可以限制的特定资源取决于系统。它们在&lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit（2）&lt;/a&gt;&lt;/em&gt;手册页中进行了描述。当底层操作系统支持它们时，将支持以下列出的资源；那些平台无法在该模块中定义操作系统无法检查或控制的资源。</target>
        </trans-unit>
        <trans-unit id="679e621b066d4106ebdb3517733d1d8a6e844edc" translate="yes" xml:space="preserve">
          <source>The specification of the original Netscape cookie protocol. Though this is still the dominant protocol, the &amp;lsquo;Netscape cookie protocol&amp;rsquo; implemented by all the major browsers (and &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt;) only bears a passing resemblance to the one sketched out in &lt;code&gt;cookie_spec.html&lt;/code&gt;.</source>
          <target state="translated">原始Netscape cookie协议的规范。尽管这仍然是主要协议，但是由所有主要浏览器（和&lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt;）实现的&amp;ldquo; Netscape cookie协议&amp;rdquo; 仅与cookie_spec.html中所描绘的 &lt;code&gt;cookie_spec.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a5ef525a4f38d6c8baa2c8948ff2da032e2bfc" translate="yes" xml:space="preserve">
          <source>The specification provided by the W3C defines the DOM API for Java, ECMAScript, and OMG IDL. The Python mapping defined here is based in large part on the IDL version of the specification, but strict compliance is not required (though implementations are free to support the strict mapping from IDL). See section &lt;a href=&quot;#dom-conformance&quot;&gt;Conformance&lt;/a&gt; for a detailed discussion of mapping requirements.</source>
          <target state="translated">W3C提供的规范定义了Java，ECMAScript和OMG IDL的DOM API。此处定义的Python映射在很大程度上基于规范的IDL版本，但不需要严格遵守（尽管实现可以自由地支持IDL的严格映射）。有关映射要求的详细讨论，请参见&lt;a href=&quot;#dom-conformance&quot;&gt;一致性&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="a5a54865c96e9fc0cf2ce3bd609a52643dbb3a5d" translate="yes" xml:space="preserve">
          <source>The specification, background, and examples for the Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句的规范，背景和示例。</target>
        </trans-unit>
        <trans-unit id="0dbc88255d5b29447d25f2517106794b852b1e4a" translate="yes" xml:space="preserve">
          <source>The specification, background, and examples for the Python &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53ba21dee295896d8c0fc9de128483f4c1f4d26" translate="yes" xml:space="preserve">
          <source>The specified loggers will be configured according to the level, propagation, filters and handlers specified.</source>
          <target state="translated">指定的记录仪将根据指定的级别、传播、过滤器和处理程序进行配置。</target>
        </trans-unit>
        <trans-unit id="e0612ec14e7221d85b8658075b6926be56ede2bc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;em&gt;name&lt;/em&gt; is a &amp;ldquo;dotted name&amp;rdquo; that may resolve either to a module, a test case class, a test method within a test case class, a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance, or a callable object which returns a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance. These checks are applied in the order listed here; that is, a method on a possible test case class will be picked up as &amp;ldquo;a test method within a test case class&amp;rdquo;, rather than &amp;ldquo;a callable object&amp;rdquo;.</source>
          <target state="translated">指定者&lt;em&gt;名称&lt;/em&gt;是&amp;ldquo;点分名称&amp;rdquo;，可以解析为模块，测试用例类，测试用例类中的测试方法，&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt;实例或返回&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt;实例的可调用对象。这些检查按照此处列出的顺序进行；也就是说，将在可能的测试用例类上的方法选择为&amp;ldquo;测试用例类内的测试方法&amp;rdquo;，而不是&amp;ldquo;可调用对象&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8327e74724788e9fd23faafae57d70e63b944955" translate="yes" xml:space="preserve">
          <source>The spinbox widget generates an &lt;strong&gt;&amp;lt;&amp;lt;Increment&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Up&amp;gt;, and a &lt;strong&gt;&amp;lt;&amp;lt;Decrement&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Down&amp;gt;.</source>
          <target state="translated">当用户按下&amp;lt;Up&amp;gt;时，spinbox小部件将生成一个&lt;strong&gt;&amp;lt;&amp;lt; Increment &amp;gt;&amp;gt;&lt;/strong&gt;虚拟事件，而当用户按下&amp;lt;Down&amp;gt;时将生成一个&lt;strong&gt;&amp;lt;&amp;lt; Decrement &amp;gt;&amp;gt;&lt;/strong&gt;虚拟事件。</target>
        </trans-unit>
        <trans-unit id="51a445c74beda03ed7a0326a9352f92f1dd4d706" translate="yes" xml:space="preserve">
          <source>The sqlite3 module is not built with loadable extension support by default, because some platforms (notably Mac OS X) have SQLite libraries which are compiled without this feature. To get loadable extension support, you must pass &amp;ndash;enable-loadable-sqlite-extensions to configure.</source>
          <target state="translated">默认情况下，sqlite3模块不具有可加载扩展支持，因为某些平台（尤其是Mac OS X）具有SQLite库，这些库在编译时没有此功能。要获得可加载扩展支持，您必须传递&amp;ndash;enable-loadable-sqlite-extensions进行配置。</target>
        </trans-unit>
        <trans-unit id="2c357cdf2607bac2f5dbe1953aebb35c44af932e" translate="yes" xml:space="preserve">
          <source>The sqlite3 module was written by Gerhard H&amp;auml;ring. It provides a SQL interface compliant with the DB-API 2.0 specification described by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">sqlite3模块由GerhardH&amp;auml;ring编写。它提供了一个符合&lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249&lt;/strong&gt;&lt;/a&gt;描述的DB-API 2.0规范的SQL接口。</target>
        </trans-unit>
        <trans-unit id="bac169ab637e97d8d04b333be4d5b9e88d67748b" translate="yes" xml:space="preserve">
          <source>The standalone backport of this module provides more information on &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;using importlib.resources&lt;/a&gt; and &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;migrating from pkg_resources to importlib.resources&lt;/a&gt;.</source>
          <target state="translated">该模块的独立backport提供有关&lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;使用importlib.resources&lt;/a&gt;以及&lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;从pkg_resources迁移到importlib.resources的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="b77674a95bf51acfb62957a46af0656c170047b7" translate="yes" xml:space="preserve">
          <source>The standard Python IMAP module.</source>
          <target state="translated">标准的Python IMAP模块。</target>
        </trans-unit>
        <trans-unit id="68889788aae8ae70cfc40e3231e1f8e78cb10352" translate="yes" xml:space="preserve">
          <source>The standard X cursor names from &lt;code&gt;cursorfont.h&lt;/code&gt; can be used, without the &lt;code&gt;XC_&lt;/code&gt; prefix. For example to get a hand cursor (&lt;code&gt;XC_hand2&lt;/code&gt;), use the string &lt;code&gt;&quot;hand2&quot;&lt;/code&gt;. You can also specify a bitmap and mask file of your own. See page 179 of Ousterhout&amp;rsquo;s book.</source>
          <target state="translated">可以使用 &lt;code&gt;cursorfont.h&lt;/code&gt; 中的标准X游标名称，而不带 &lt;code&gt;XC_&lt;/code&gt; 前缀。例如，要获取手形光标（ &lt;code&gt;XC_hand2&lt;/code&gt; ），请使用字符串 &lt;code&gt;&quot;hand2&quot;&lt;/code&gt; 。您还可以指定自己的位图和掩码文件。参见Ousterhout书的第179页。</target>
        </trans-unit>
        <trans-unit id="48c570e26b992a39c9c6ac01d765d07ba873d695" translate="yes" xml:space="preserve">
          <source>The standard error device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">标准错误设备。最初，这是活动的控制台屏幕缓冲区 &lt;code&gt;CONOUT$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="838902f3ab46b04d98965c4728b7b35218852253" translate="yes" xml:space="preserve">
          <source>The standard format of the &lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; environment variable is (whitespace added for clarity):</source>
          <target state="translated">&lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; 环境变量的标准格式为（为清楚起见添加了空格）：</target>
        </trans-unit>
        <trans-unit id="cb7f906caa68565a322b0c38155c9958a70af129" translate="yes" xml:space="preserve">
          <source>The standard input device. Initially, this is the console input buffer, &lt;code&gt;CONIN$&lt;/code&gt;.</source>
          <target state="translated">标准输入设备。最初，这是控制台输入缓冲区 &lt;code&gt;CONIN$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9fe9bf76be36079397d2cae51a3b2aece1a0ca0" translate="yes" xml:space="preserve">
          <source>The standard module &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; defines functions and constants that are useful for extracting information from a &lt;code&gt;stat&lt;/code&gt; structure. (On Windows, some items are filled with dummy values.)</source>
          <target state="translated">标准模块&lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;定义了对从 &lt;code&gt;stat&lt;/code&gt; 结构中提取信息有用的函数和常量。（在Windows上，某些项目填充有伪值。）</target>
        </trans-unit>
        <trans-unit id="6cdc8bfcbf49383bc1e73500c1b4de14a0e0fed5" translate="yes" xml:space="preserve">
          <source>The standard output and standard error streams are buffered during the test run. Output during a passing test is discarded. Output is echoed normally on test fail or error and is added to the failure messages.</source>
          <target state="translated">标准输出和标准错误流在测试运行期间被缓冲。测试通过时的输出会被丢弃。测试失败或出错时,输出会正常回传,并被添加到失败信息中。</target>
        </trans-unit>
        <trans-unit id="eb7cf066e8af540cf727db7cac24accf30ce076f" translate="yes" xml:space="preserve">
          <source>The standard output device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">标准输出设备。最初，这是活动的控制台屏幕缓冲区 &lt;code&gt;CONOUT$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bedde387bc6937840daa67ab375a6cae23a47eb7" translate="yes" xml:space="preserve">
          <source>The standard way to exit is &lt;code&gt;sys.exit(n)&lt;/code&gt;. &lt;a href=&quot;#os._exit&quot;&gt;&lt;code&gt;_exit()&lt;/code&gt;&lt;/a&gt; should normally only be used in the child process after a &lt;a href=&quot;#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">退出的标准方法是 &lt;code&gt;sys.exit(n)&lt;/code&gt; 。&lt;a href=&quot;#os._exit&quot;&gt; &lt;code&gt;_exit()&lt;/code&gt; &lt;/a&gt;通常仅应在&lt;a href=&quot;#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt;之后的子进程中使用。</target>
        </trans-unit>
        <trans-unit id="a3ee6195d1060ec2a3f2616df734ae62aafdf49e" translate="yes" xml:space="preserve">
          <source>The standard way to open files for reading and writing with Python.</source>
          <target state="translated">用Python打开文件读写的标准方法。</target>
        </trans-unit>
        <trans-unit id="68d5384e54c19f936c634b6d988aedf31c295bf3" translate="yes" xml:space="preserve">
          <source>The start index of &lt;em&gt;doc&lt;/em&gt; where parsing failed.</source>
          <target state="translated">解析失败的&lt;em&gt;doc&lt;/em&gt;的起始索引。</target>
        </trans-unit>
        <trans-unit id="85b13200690d7aa62326c7849f57cc6925206c71" translate="yes" xml:space="preserve">
          <source>The starting column doesn&amp;rsquo;t matter:</source>
          <target state="translated">起始列无关紧要：</target>
        </trans-unit>
        <trans-unit id="de2b727684bc631a4d8eca489abadd7633848760" translate="yes" xml:space="preserve">
          <source>The stateless encoding and decoding functions. These must be functions or methods which have the same interface as the &lt;a href=&quot;#codecs.Codec.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.Codec.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; methods of Codec instances (see &lt;a href=&quot;#codec-objects&quot;&gt;Codec Interface&lt;/a&gt;). The functions or methods are expected to work in a stateless mode.</source>
          <target state="translated">无状态编码和解码功能。这些具有相同接口作为必须是函数或方法&lt;a href=&quot;#codecs.Codec.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#codecs.Codec.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt;编解码器的实例的方法（参见&lt;a href=&quot;#codec-objects&quot;&gt;编解码器接口&lt;/a&gt;）。这些功能或方法应在无状态模式下工作。</target>
        </trans-unit>
        <trans-unit id="fc37fae53ad3d2cf8bbbb3fbc6970158d324b500" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;import spam.ham&lt;/code&gt; results in this call:</source>
          <target state="translated">语句 &lt;code&gt;import spam.ham&lt;/code&gt; 导致此调用：</target>
        </trans-unit>
        <trans-unit id="57343ca400818c99d89cc954bac7f25bd563f12b" translate="yes" xml:space="preserve">
          <source>The statement:</source>
          <target state="translated">该声明:</target>
        </trans-unit>
        <trans-unit id="5f7f5bd7cdc067527c840f51d511b9f3a881789d" translate="yes" xml:space="preserve">
          <source>The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:</source>
          <target state="translated">静态类型检查器会将新类型视为原始类型的子类。这对于帮助发现逻辑错误很有用。</target>
        </trans-unit>
        <trans-unit id="acb7f81b54e59ac66887405065b4bf032855f1db" translate="yes" xml:space="preserve">
          <source>The stdlib implementation is based on &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; module. It was written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt; based on C implementation written by &lt;em&gt;Samuel Neves&lt;/em&gt;. The documentation was copied from &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; and written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt;.</source>
          <target state="translated">stdlib实现基于&lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt;模块。它由&lt;em&gt;Dmitry Chestnykh&lt;/em&gt;基于&lt;em&gt;Samuel Neves&lt;/em&gt;编写的C实现编写。该文档是从&lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt;复制并由&lt;em&gt;Dmitry Chestnykh&lt;/em&gt;编写的。</target>
        </trans-unit>
        <trans-unit id="a6771d7c766fdf223fc75b578682b8b43ecb7225" translate="yes" xml:space="preserve">
          <source>The steps to create a standalone archive are as follows:</source>
          <target state="translated">创建独立档案的步骤如下。</target>
        </trans-unit>
        <trans-unit id="b08826ba03bafb388c1bd5be0f5d0ef0f9774b35" translate="yes" xml:space="preserve">
          <source>The straightforward translation into ctypes code would be this, but it does not work:</source>
          <target state="translated">直接翻译成ctypes代码是这样的,但是不能用。</target>
        </trans-unit>
        <trans-unit id="3bbd18af7e807a1ecde8e654eeae316aad16083d" translate="yes" xml:space="preserve">
          <source>The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are &lt;em&gt;k&lt;/em&gt;, not &lt;code&gt;a[k]&lt;/code&gt;:</source>
          <target state="translated">上面的奇怪不变式是表示比赛的有效记忆形式。以下数字是&lt;em&gt;k&lt;/em&gt;，而不是 &lt;code&gt;a[k]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f3f83287161100c9dc848427c687a8403242c4e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'01234567'&lt;/code&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;'01234567'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="081b65b640d4fd9a1348073d2be076165e5d402b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789'&lt;/code&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;'0123456789'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc062e91d1dfe0b46d43e731a7d26c8429acd1c" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e169e91e10e1724d8d6b7fcde6b5762907d6051" translate="yes" xml:space="preserve">
          <source>The string &lt;em&gt;hash_name&lt;/em&gt; is the desired name of the hash digest algorithm for HMAC, e.g. &amp;lsquo;sha1&amp;rsquo; or &amp;lsquo;sha256&amp;rsquo;. &lt;em&gt;password&lt;/em&gt; and &lt;em&gt;salt&lt;/em&gt; are interpreted as buffers of bytes. Applications and libraries should limit &lt;em&gt;password&lt;/em&gt; to a sensible length (e.g. 1024). &lt;em&gt;salt&lt;/em&gt; should be about 16 or more bytes from a proper source, e.g. &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串&lt;em&gt;hash_name&lt;/em&gt;是HMAC的哈希摘要算法的期望名称，例如'sha1'或'sha256'。&lt;em&gt;密码&lt;/em&gt;和&lt;em&gt;盐&lt;/em&gt;被解释为字节缓冲区。应用程序和库应将&lt;em&gt;密码&lt;/em&gt;限制为合理的长度（例如1024）。&lt;em&gt;盐&lt;/em&gt;应该来自适当的来源（例如&lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; )&lt;/a&gt;约16个或更多字节。</target>
        </trans-unit>
        <trans-unit id="974fbe45930e6c9f7ed0ba945f3ca1dfc34eddbd" translate="yes" xml:space="preserve">
          <source>The string of characters accepted for the command prefix.</source>
          <target state="translated">命令前缀接受的字符串。</target>
        </trans-unit>
        <trans-unit id="218df02f3b43ffd3271f33dc44503b415fe71878" translate="yes" xml:space="preserve">
          <source>The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just &lt;code&gt;'#'&lt;/code&gt; by default.</source>
          <target state="translated">被视为注释初学者的字符串。从注释初学者到行尾的所有字符都将被忽略。默认情况下仅包含 &lt;code&gt;'#'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08ac626721e1a485bd3af4b431e4c2809aea979e" translate="yes" xml:space="preserve">
          <source>The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore. In POSIX mode, the accented characters in the Latin-1 set are also included. If &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt; is not empty, the characters &lt;code&gt;~-./*?=&lt;/code&gt;, which can appear in filename specifications and command line parameters, will also be included in this attribute, and any characters which appear in &lt;code&gt;punctuation_chars&lt;/code&gt; will be removed from &lt;code&gt;wordchars&lt;/code&gt; if they are present there. If &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;True&lt;/code&gt;, this will have no effect.</source>
          <target state="translated">将累积为多字符标记的字符串。默认情况下，包括所有ASCII字母数字和下划线。在POSIX模式下，还包括Latin-1集中的重音字符。如果&lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; &lt;/a&gt;不为空，则出现在文件名规范和命令行参数中的字符 &lt;code&gt;~-./*?=&lt;/code&gt; 也将包含在此属性中，如果 &lt;code&gt;punctuation_chars&lt;/code&gt; 中出现的任何字符都被从 &lt;code&gt;wordchars&lt;/code&gt; 删除，则它们将被删除。在那儿。如果将&lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;True&lt;/code&gt; ，则将无效。</target>
        </trans-unit>
        <trans-unit id="4659a50925d6df425ac6596dfc8a23084e3a4010" translate="yes" xml:space="preserve">
          <source>The string passed to &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">传递给&lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt;的字符串。</target>
        </trans-unit>
        <trans-unit id="5d5d7729b640e49a8b83a3c394f3b0662bfab3da" translate="yes" xml:space="preserve">
          <source>The string representation in dotted decimal notation. Leading zeroes are never included in the representation.</source>
          <target state="translated">以点阵十进制符号表示的字符串。在表示方式中不包含前导零。</target>
        </trans-unit>
        <trans-unit id="36dad8efe406905d6d09a273705ad1e8e58e3f5c" translate="yes" xml:space="preserve">
          <source>The string representation of a path is the raw filesystem path itself (in native form, e.g. with backslashes under Windows), which you can pass to any function taking a file path as a string:</source>
          <target state="translated">路径的字符串表示是原始文件系统路径本身(原生形式,例如在Windows下有反斜杠),你可以将其传递给任何将文件路径作为字符串的函数。</target>
        </trans-unit>
        <trans-unit id="323edf4f9c5d0894188d9673d9f925fd1eae3209" translate="yes" xml:space="preserve">
          <source>The string representation returned when calling &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;#zoneinfo.ZoneInfo&quot;&gt;&lt;code&gt;ZoneInfo&lt;/code&gt;&lt;/a&gt; object defaults to using the &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt;&lt;code&gt;ZoneInfo.key&lt;/code&gt;&lt;/a&gt; attribute (see the note on usage in the attribute documentation):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c60d280d907f21f86f32a46a5575681700d147" translate="yes" xml:space="preserve">
          <source>The string that the test was extracted from, or &lt;code&gt;None&lt;/code&gt; if the string is unavailable, or if the test was not extracted from a string.</source>
          <target state="translated">从中提取测试的字符串，如果该字符串不可用，或者未从字符串中提取测试，则为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3d2b7a50a86f575f6fd45d43bbe5cf13d19875c" translate="yes" xml:space="preserve">
          <source>The string to be used to terminate lines in serialized output. The default is &lt;code&gt;\n&lt;/code&gt; because that&amp;rsquo;s the internal end-of-line discipline used by Python, though &lt;code&gt;\r\n&lt;/code&gt; is required by the RFCs.</source>
          <target state="translated">用于终止串行化输出中的行的字符串。默认值为 &lt;code&gt;\n&lt;/code&gt; 因为这是Python使用的内部行尾规则，尽管RFC要求 &lt;code&gt;\r\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2ea49d3d095e008ddabf5c5d79618ebc583572" translate="yes" xml:space="preserve">
          <source>The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as &lt;code&gt;'\n'&lt;/code&gt; for POSIX, or multiple characters, for example, &lt;code&gt;'\r\n'&lt;/code&gt; for Windows. Do not use &lt;em&gt;os.linesep&lt;/em&gt; as a line terminator when writing files opened in text mode (the default); use a single &lt;code&gt;'\n'&lt;/code&gt; instead, on all platforms.</source>
          <target state="translated">在当前平台上用于分隔（或终止）行的字符串。这可以是单个字符，例如对于POSIX 是 &lt;code&gt;'\n'&lt;/code&gt; ，也可以是多个字符，例如对于Windows是 &lt;code&gt;'\r\n'&lt;/code&gt; 。写入以文本模式打开的文件时，请不要使用&lt;em&gt;os.linesep&lt;/em&gt;作为行终止符（默认）；在所有平台上都使用一个 &lt;code&gt;'\n'&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="8ea85089ca50f62fa2ade25bca0d6a593de3d007" translate="yes" xml:space="preserve">
          <source>The string used to terminate lines produced by the &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt;. It defaults to &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">该字符串用于终止由所述生产线&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt;。默认为 &lt;code&gt;'\r\n'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cf8db53ba3ecf1804cef93b7a3f29860b461c29" translate="yes" xml:space="preserve">
          <source>The structure of INI files is described &lt;a href=&quot;#supported-ini-file-structure&quot;&gt;in the following section&lt;/a&gt;. Essentially, the file consists of sections, each of which contains keys with values. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; classes can read and write such files. Let&amp;rsquo;s start by creating the above configuration file programmatically.</source>
          <target state="translated">INI文件的结构&lt;a href=&quot;#supported-ini-file-structure&quot;&gt;在以下部分中介绍&lt;/a&gt;。本质上，该文件由多个部分组成，每个部分都包含带有值的键。&lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt;类可以读取和写入此类文件。让我们开始以编程方式创建上述配置文件。</target>
        </trans-unit>
        <trans-unit id="57ac7e21799c7f677af76b9cfb1a314919d92910" translate="yes" xml:space="preserve">
          <source>The subclass shown above sets &lt;code&gt;__slots__&lt;/code&gt; to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries.</source>
          <target state="translated">上面显示的子类将 &lt;code&gt;__slots__&lt;/code&gt; 设置为一个空元组。通过防止创建实例字典，这有助于将内存需求保持在较低水平。</target>
        </trans-unit>
        <trans-unit id="1049894083da3d6136643ae40107b301d4f0a75b" translate="yes" xml:space="preserve">
          <source>The subnets that join to make the current network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be increased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns an iterator of network objects.</source>
          <target state="translated">加入的子网构成当前的网络定义，具体取决于参数值。&lt;em&gt;prefixlen_diff&lt;/em&gt;是前缀长度应增加的量。&lt;em&gt;new_prefix&lt;/em&gt;是所需的子网新前缀；它必须大于我们的前缀。必须设置&lt;em&gt;prefixlen_diff&lt;/em&gt;和&lt;em&gt;new_prefix中的&lt;/em&gt;仅一个。返回网络对象的迭代器。</target>
        </trans-unit>
        <trans-unit id="9437b122f21ab7e79496b92a68b7f9e5eeaac2be" translate="yes" xml:space="preserve">
          <source>The subpath within the ZIP file where modules are searched. This is the empty string for zipimporter objects which point to the root of the ZIP file.</source>
          <target state="translated">在ZIP文件中搜索模块的子路径。对于指向ZIP文件根部的zipimporter对象来说,这是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="326ec51a05e2c8d6e7c26dd0d96fea0857cfc5e7" translate="yes" xml:space="preserve">
          <source>The subprocess is created by th &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">子流程是通过&lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt;方法创建的：</target>
        </trans-unit>
        <trans-unit id="830a5ed8adcd9cd5ec5ebf36f7cf9f4fb4e3e294" translate="yes" xml:space="preserve">
          <source>The subprocess is created by the &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">子流程由&lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt;函数创建：</target>
        </trans-unit>
        <trans-unit id="8ea72797f0c5407f3306ccc7a80e8f6b73c93b68" translate="yes" xml:space="preserve">
          <source>The subprocess is created by the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195b42e9196a41c00a54c69540f8c3689b081015" translate="yes" xml:space="preserve">
          <source>The subscription syntax must always be used with exactly two values: the argument list and the return type. The argument list must be a list of types or an ellipsis; the return type must be a single type.</source>
          <target state="translated">订阅语法必须始终使用两个值:参数列表和返回类型。参数列表必须是类型列表或省略号;返回类型必须是单一类型。</target>
        </trans-unit>
        <trans-unit id="6a7c51bccf2dda395b8edfb0931dfbbc3947a4fd" translate="yes" xml:space="preserve">
          <source>The subsequence to search for and its replacement may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">要搜索和替换的子序列可以是任何&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e98c3e1145a59f2632009395f0542a0deeafc636" translate="yes" xml:space="preserve">
          <source>The subsequence to search for and its replacement may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20be2f3a12314bdd168b8b8dc36ec5a219e64be" translate="yes" xml:space="preserve">
          <source>The subsequence to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an integer in the range 0 to 255.</source>
          <target state="translated">要搜索的子序列可以是任何&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;，也可以是0到255之间的整数。</target>
        </trans-unit>
        <trans-unit id="e4f0f61cfe406164bd2b1bc218bfd4e6e5b9b5cc" translate="yes" xml:space="preserve">
          <source>The subsequence to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an integer in the range 0 to 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733f0146d975374d445236d55e27c28b82ab24a4" translate="yes" xml:space="preserve">
          <source>The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so &lt;em&gt;all&lt;/em&gt; of the following return &lt;code&gt;False&lt;/code&gt;: &lt;code&gt;a&amp;lt;b&lt;/code&gt;, &lt;code&gt;a==b&lt;/code&gt;, or &lt;code&gt;a&amp;gt;b&lt;/code&gt;.</source>
          <target state="translated">子集和相等性比较不能推广到总排序功能。例如，任何两个非空不交集都不相等，也不是彼此的子集，因此以下&lt;em&gt;所有&lt;/em&gt;返回 &lt;code&gt;False&lt;/code&gt; ： &lt;code&gt;a&amp;lt;b&lt;/code&gt; ， &lt;code&gt;a==b&lt;/code&gt; 或 &lt;code&gt;a&amp;gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d313acbcf2f63dafe9fec9edee3d8cece85e3a5f" translate="yes" xml:space="preserve">
          <source>The suffix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">要搜索的后缀可以是任何&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6b552f61d9fa84179bef81d55a59ca4effe2dd9" translate="yes" xml:space="preserve">
          <source>The suffix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8de5ade168ce8d52e288779f29cce661700e1e" translate="yes" xml:space="preserve">
          <source>The suggested launcher above uses the Python embedding API. This means that in your application, &lt;code&gt;sys.executable&lt;/code&gt; will be your application, and &lt;em&gt;not&lt;/em&gt; a conventional Python interpreter. Your code and its dependencies need to be prepared for this possibility. For example, if your application uses the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; module, it will need to call &lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt;&lt;code&gt;multiprocessing.set_executable()&lt;/code&gt;&lt;/a&gt; to let the module know where to find the standard Python interpreter.</source>
          <target state="translated">上面建议的启动器使用Python嵌入API。这意味着在您的应用程序中， &lt;code&gt;sys.executable&lt;/code&gt; 将是您的应用程序，而&lt;em&gt;不是&lt;/em&gt;常规的Python解释器。您的代码及其依赖项需要为此做好准备。例如，如果您的应用程序使用&lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt;模块，则需要调用&lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt; &lt;code&gt;multiprocessing.set_executable()&lt;/code&gt; &lt;/a&gt;来让模块知道在哪里可以找到标准的Python解释器。</target>
        </trans-unit>
        <trans-unit id="4ca94cda6ea6ac6e5a70ea1ff1f1c7c7cd83fb8d" translate="yes" xml:space="preserve">
          <source>The supernet containing this network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be decreased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns a single network object.</source>
          <target state="translated">包含此网络定义的超级网，取决于参数值。&lt;em&gt;prefixlen_diff&lt;/em&gt;是我们的前缀长度应减少的数量。&lt;em&gt;new_prefix&lt;/em&gt;是超级网所需的新前缀；它必须小于我们的前缀。必须设置&lt;em&gt;prefixlen_diff&lt;/em&gt;和&lt;em&gt;new_prefix中的&lt;/em&gt;仅一个。返回单个网络对象。</target>
        </trans-unit>
        <trans-unit id="652b878f95e736a80f9fc3181efc0a97692d08cf" translate="yes" xml:space="preserve">
          <source>The symbol module is deprecated and will be removed in future versions of Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a132475eefbff651be1e9f60f5a01256ac706" translate="yes" xml:space="preserve">
          <source>The symbolic &lt;code&gt;LOG_&lt;/code&gt; values are defined in &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; and mirror the values defined in the &lt;code&gt;sys/syslog.h&lt;/code&gt; header file.</source>
          <target state="translated">符号 &lt;code&gt;LOG_&lt;/code&gt; 值在&lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; &lt;/a&gt;中定义，并镜像 &lt;code&gt;sys/syslog.h&lt;/code&gt; 头文件中定义的值。</target>
        </trans-unit>
        <trans-unit id="2855402ac7e633af0e756490916e4b0509c9ee96" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the telnet commands are: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</source>
          <target state="translated">telnet命令的符号常量为:。IAC、DONT、DO、WONT、WILL、SE(子协商结束)、NOP(无操作)、DM(数据标记)、BRK(中断)、IP(中断过程)、AO(中止输出)、AYT(你在吗)、EC(擦除字符)、EL(擦除行)、GA(前进)、SB(子协商开始)。</target>
        </trans-unit>
        <trans-unit id="f8ce1d87c905659a0bf890b9cf481e55b1edc39a" translate="yes" xml:space="preserve">
          <source>The system handle used to access the library.</source>
          <target state="translated">用于访问图书馆的系统句柄。</target>
        </trans-unit>
        <trans-unit id="6fc6b22d1825c9f09c313587868ef00b4493d95a" translate="yes" xml:space="preserve">
          <source>The system identifier for the external subset of the document type definition. This will be a URI as a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">文档类型定义的外部子集的系统标识符。这将是一个字符串形式的URI或 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44d450cf187b52bfa50e049a62fae0de2e42ee87" translate="yes" xml:space="preserve">
          <source>The system is a domain controller.</source>
          <target state="translated">该系统是一个域控制器。</target>
        </trans-unit>
        <trans-unit id="40e3a3638774f49e1f39d0e71a7abdae17b2e149" translate="yes" xml:space="preserve">
          <source>The system is a server, but not a domain controller.</source>
          <target state="translated">系统是服务器,但不是域控制器。</target>
        </trans-unit>
        <trans-unit id="7c73a5e107d91be1df5f93f12cd8765ccebb12ce" translate="yes" xml:space="preserve">
          <source>The system is a workstation.</source>
          <target state="translated">该系统是一个工作站。</target>
        </trans-unit>
        <trans-unit id="f71c2f2dbbdfd4c5e6a5631f52c2bebfb1487e55" translate="yes" xml:space="preserve">
          <source>The system must have a current leap second table in order for this to give the correct answer. PTP or NTP software can maintain a leap second table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ae6ebbe2e07465f0616803ac45ed0fa6855ad1" translate="yes" xml:space="preserve">
          <source>The system will save old log files by appending extensions to the filename. The extensions are date-and-time based, using the strftime format &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; or a leading portion thereof, depending on the rollover interval.</source>
          <target state="translated">系统将通过在文件名后附加扩展名来保存旧的日志文件。扩展是基于日期和时间的，取决于过渡间隔，使用strftime格式 &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; 或其前导部分。</target>
        </trans-unit>
        <trans-unit id="179fc435688f8e8cc38d18cd776581a529b4d5f3" translate="yes" xml:space="preserve">
          <source>The tab will not be displayed, but the associated window remains managed by the notebook and its configuration remembered. Hidden tabs may be restored with the &lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">该选项卡将不会显示，但关联的窗口仍由笔记本计算机管理并记住其配置。隐藏的选项卡可以使用&lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt;命令恢复。</target>
        </trans-unit>
        <trans-unit id="2b061342e7fcb41c80cbeeac10798ba4a35c7df9" translate="yes" xml:space="preserve">
          <source>The tab_id present in several methods of &lt;code&gt;ttk.Notebook&lt;/code&gt; may take any of the following forms:</source>
          <target state="translated">ttk.Notebook的几种方法中存在的 &lt;code&gt;ttk.Notebook&lt;/code&gt; 可以采用以下任何形式：</target>
        </trans-unit>
        <trans-unit id="2d522d8935e08991d14cdfc081478c07442e166b" translate="yes" xml:space="preserve">
          <source>The table below compares the syntax for creating shared ctypes objects from shared memory with the normal ctypes syntax. (In the table &lt;code&gt;MyStruct&lt;/code&gt; is some subclass of &lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt;&lt;code&gt;ctypes.Structure&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">下表将用于从共享内存创建共享ctypes对象的语法与普通ctypes语法进行了比较。（在表中 &lt;code&gt;MyStruct&lt;/code&gt; 是一些子类&lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt; &lt;code&gt;ctypes.Structure&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="7bccc06bc889ee84856fdd46b401f47559a82ae4" translate="yes" xml:space="preserve">
          <source>The table below provides a high-level comparison of &lt;code&gt;strftime()&lt;/code&gt; versus &lt;code&gt;strptime()&lt;/code&gt;:</source>
          <target state="translated">下表提供了 &lt;code&gt;strftime()&lt;/code&gt; 和 &lt;code&gt;strptime()&lt;/code&gt; 的高级比较：</target>
        </trans-unit>
        <trans-unit id="e3dbc221607127a001cdb67dd95041333051b2e0" translate="yes" xml:space="preserve">
          <source>The tar format was originally conceived to make backups on tape drives with the main focus on preserving file system information. Nowadays tar archives are commonly used for file distribution and exchanging archives over networks. One problem of the original format (which is the basis of all other formats) is that there is no concept of supporting different character encodings. For example, an ordinary tar archive created on a &lt;em&gt;UTF-8&lt;/em&gt; system cannot be read correctly on a &lt;em&gt;Latin-1&lt;/em&gt; system if it contains non-&lt;em&gt;ASCII&lt;/em&gt; characters. Textual metadata (like filenames, linknames, user/group names) will appear damaged. Unfortunately, there is no way to autodetect the encoding of an archive. The pax format was designed to solve this problem. It stores non-ASCII metadata using the universal character encoding &lt;em&gt;UTF-8&lt;/em&gt;.</source>
          <target state="translated">tar格式最初是为了在磁带驱动器上进行备份而设计的，其主要重点是保留文件系统信息。如今，tar档案通常用于文件分发和通过网络交换档案。原始格式（这是所有其他格式的基础）的一个问题是，没有支持不同字符编码的概念。例如，上创建一个普通的tar归档&lt;em&gt;UTF-8&lt;/em&gt;系统不能正确地一上阅读&lt;em&gt;Latin-1的&lt;/em&gt;系统，如果它包含非&lt;em&gt;ASCII&lt;/em&gt;字符。文本元数据（如文件名，链接名，用户/组名）将显示为已损坏。不幸的是，没有办法自动检测档案的编码。pax格式旨在解决此问题。它使用通用字符编码&lt;em&gt;UTF-8&lt;/em&gt;存储非ASCII元数据。</target>
        </trans-unit>
        <trans-unit id="613dcaffb8c0009159e594bde38781dfcc7c3d20" translate="yes" xml:space="preserve">
          <source>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, &lt;em&gt;not&lt;/em&gt; the directory of the Path object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39109a83b1e6877b05cef869c019b4e8c66ec92a" translate="yes" xml:space="preserve">
          <source>The task is executed in the loop returned by &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised if there is no running loop in current thread.</source>
          <target state="translated">该任务是通过返回循环中执行&lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;是如果在当前线程没有正在运行的循环上升。</target>
        </trans-unit>
        <trans-unit id="6cd178d789e9c72b2db2b532b1e1730e28430479" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;delegation to the parent&amp;rsquo; means that if a logger has a level of NOTSET, its chain of ancestor loggers is traversed until either an ancestor with a level other than NOTSET is found, or the root is reached.</source>
          <target state="translated">术语&amp;ldquo;委托给父代&amp;rdquo;是指如果记录器的级别为NOTSET，则遍历其祖先记录器链，直到找到非NOTSET级别的祖先或到达根为止。</target>
        </trans-unit>
        <trans-unit id="146eafd5f201d9458991952860d529510a852604" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;seconds since the epoch&lt;/em&gt; refers to the total number of elapsed seconds since the epoch, typically excluding &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt;. Leap seconds are excluded from this total on all POSIX-compliant platforms.</source>
          <target state="translated">术语&lt;em&gt;从epoch秒&lt;/em&gt;是指从epoch的经过的总秒数，典型地不包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;闰秒&lt;/a&gt;。在所有符合POSIX的平台上，秒不包括在此总数之内。</target>
        </trans-unit>
        <trans-unit id="e94bbf67fcc1b6bd4b3967baa1ebc9ad25d9c0c5" translate="yes" xml:space="preserve">
          <source>The test code can more easily be separated from shipped code.</source>
          <target state="translated">测试代码可以更容易地与发货代码分开。</target>
        </trans-unit>
        <trans-unit id="de4938c1a0bc8d676536f4fba441042877342846" translate="yes" xml:space="preserve">
          <source>The test function should return a string describing the image type if the test succeeded, or &lt;code&gt;None&lt;/code&gt; if it failed.</source>
          <target state="translated">如果测试成功，则测试功能应返回描述图像类型的字符串；如果测试失败，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="401d59c5ffb4d3b57f5880747f129772c3d55bd5" translate="yes" xml:space="preserve">
          <source>The test module can be run standalone from the command line.</source>
          <target state="translated">测试模块可以从命令行独立运行。</target>
        </trans-unit>
        <trans-unit id="060a6930386a9d1574b1aa1b3c3bc2d33784e7a8" translate="yes" xml:space="preserve">
          <source>The test passes if at least one message emitted inside the &lt;code&gt;with&lt;/code&gt; block matches the &lt;em&gt;logger&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt; conditions, otherwise it fails.</source>
          <target state="translated">如果 &lt;code&gt;with&lt;/code&gt; 块内发出的至少一条消息与&lt;em&gt;记录器&lt;/em&gt;和&lt;em&gt;级别&lt;/em&gt;条件匹配，则测试通过。否则，测试将失败。</target>
        </trans-unit>
        <trans-unit id="0c1c8392f06e470e9763ff342c0bf458700b10d0" translate="yes" xml:space="preserve">
          <source>The test runner&amp;rsquo;s display output can be controlled in two ways. First, an output function can be passed to &lt;code&gt;TestRunner.run()&lt;/code&gt;; this function will be called with strings that should be displayed. It defaults to &lt;code&gt;sys.stdout.write&lt;/code&gt;. If capturing the output is not sufficient, then the display output can be also customized by subclassing DocTestRunner, and overriding the methods &lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt;&lt;code&gt;report_start()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt;&lt;code&gt;report_success()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt;&lt;code&gt;report_unexpected_exception()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt;&lt;code&gt;report_failure()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过两种方式控制测试跑步者的显示输出。首先，可以将输出函数传递给 &lt;code&gt;TestRunner.run()&lt;/code&gt; ；将使用应显示的字符串调用此函数。默认为 &lt;code&gt;sys.stdout.write&lt;/code&gt; 。如果捕获输出还不够，那么还可以通过子类化DocTestRunner并覆盖方法&lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt; &lt;code&gt;report_start()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt; &lt;code&gt;report_success()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt; &lt;code&gt;report_unexpected_exception()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt; &lt;code&gt;report_failure()&lt;/code&gt; 来自&lt;/a&gt;定义显示输出。</target>
        </trans-unit>
        <trans-unit id="fb4a3424a4f1dda3e01eea1f89d1c0f58bff9865" translate="yes" xml:space="preserve">
          <source>The testing code of a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases.</source>
          <target state="translated">一个&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;实例的测试代码应该完全独立，这样它可以与任何数量的其他测试用例孤立地或任意组合地运行。</target>
        </trans-unit>
        <trans-unit id="4ae3f29483e2ee3ea0f7163c30937acfdb9d4b25" translate="yes" xml:space="preserve">
          <source>The testing suite should exercise all classes, functions, and constants. This includes not just the external API that is to be presented to the outside world but also &amp;ldquo;private&amp;rdquo; code.</source>
          <target state="translated">测试套件应使用所有类，函数和常量。这不仅包括要向外​​界展示的外部API，还包括&amp;ldquo;私有&amp;rdquo;代码。</target>
        </trans-unit>
        <trans-unit id="daaa85794b2e5ea58362f9c215438cdd2e5ff243" translate="yes" xml:space="preserve">
          <source>The text and background colors for the context pane can be configured under the Highlights tab in the Configure IDLE dialog.</source>
          <target state="translated">可以在 &quot;配置IDLE &quot;对话框中的 &quot;高亮 &quot;选项卡下配置上下文窗格的文本和背景颜色。</target>
        </trans-unit>
        <trans-unit id="4008857746bcc56c1a0c2edaedf3abb5a9bbbdd4" translate="yes" xml:space="preserve">
          <source>The text buffer is discarded when the &lt;a href=&quot;#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2ad191eeb4d0bbf960c378232847d949f175e9" translate="yes" xml:space="preserve">
          <source>The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches:</source>
          <target state="translated">文本类别是用正则表达式指定的。其技术是将这些类别合并为一个主正则表达式,并循环处理连续的匹配。</target>
        </trans-unit>
        <trans-unit id="6d833b1a3893c5d6101423fd99ed50cd0a6703e5" translate="yes" xml:space="preserve">
          <source>The text stream API is described in detail in the documentation of &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt;文档中详细描述了文本流API 。</target>
        </trans-unit>
        <trans-unit id="c6f2c2cd14f223c08b886437c2b9c2073b05f038" translate="yes" xml:space="preserve">
          <source>The text to display in the column heading.</source>
          <target state="translated">要在列标题中显示的文字。</target>
        </trans-unit>
        <trans-unit id="624bc91f26efa2f3c6b7ab6d643f9eaaecd49465" translate="yes" xml:space="preserve">
          <source>The text value of the attribute. This is a synonym for the &lt;code&gt;nodeValue&lt;/code&gt; attribute.</source>
          <target state="translated">属性的文本值。这是 &lt;code&gt;nodeValue&lt;/code&gt; 属性的同义词。</target>
        </trans-unit>
        <trans-unit id="b95c1297303c1f21bf34292066165290d2d2c55f" translate="yes" xml:space="preserve">
          <source>The text widget and scrollbar are packed together in a &lt;code&gt;Frame&lt;/code&gt;, and the methods of the &lt;code&gt;Grid&lt;/code&gt; and &lt;code&gt;Pack&lt;/code&gt; geometry managers are acquired from the &lt;code&gt;Frame&lt;/code&gt; object. This allows the &lt;a href=&quot;#tkinter.scrolledtext.ScrolledText&quot;&gt;&lt;code&gt;ScrolledText&lt;/code&gt;&lt;/a&gt; widget to be used directly to achieve most normal geometry management behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d2cdc643f2142769f11e3bf3f5f6639f0d087f" translate="yes" xml:space="preserve">
          <source>The text widget and scrollbar are packed together in a &lt;code&gt;Frame&lt;/code&gt;, and the methods of the &lt;code&gt;Grid&lt;/code&gt; and &lt;code&gt;Pack&lt;/code&gt; geometry managers are acquired from the &lt;code&gt;Frame&lt;/code&gt; object. This allows the &lt;code&gt;ScrolledText&lt;/code&gt; widget to be used directly to achieve most normal geometry management behavior.</source>
          <target state="translated">文本小部件和滚动条打包在 &lt;code&gt;Frame&lt;/code&gt; 中，并且从 &lt;code&gt;Frame&lt;/code&gt; 对象获取 &lt;code&gt;Grid&lt;/code&gt; 和 &lt;code&gt;Pack&lt;/code&gt; 几何管理器的方法。这允许 &lt;code&gt;ScrolledText&lt;/code&gt; 小部件直接用于实现大多数常规几何图形管理行为。</target>
        </trans-unit>
        <trans-unit id="781fd46cb32fb2d772f49135a740a4dd6122fbb5" translate="yes" xml:space="preserve">
          <source>The textual label to display for the item.</source>
          <target state="translated">项目要显示的文字标签。</target>
        </trans-unit>
        <trans-unit id="7e98aa474e18722e2a15841579721066227b8523" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;extra&lt;/em&gt; which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</source>
          <target state="translated">第三个可选关键字参数是&lt;em&gt;多余的&lt;/em&gt;，可用于传递字典，该字典用于使用用户定义的属性填充为日志事件创建的LogRecord的__dict__。然后可以根据需要使用这些自定义属性。例如，可以将它们合并到已记录的消息中。例如：</target>
        </trans-unit>
        <trans-unit id="665f31530d18339b9c188c1b9103b2b958ccad7e" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;stacklevel&lt;/em&gt;, which defaults to &lt;code&gt;1&lt;/code&gt;. If greater than 1, the corresponding number of stack frames are skipped when computing the line number and function name set in the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; created for the logging event. This can be used in logging helpers so that the function name, filename and line number recorded are not the information for the helper function/method, but rather its caller. The name of this parameter mirrors the equivalent one in the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">第三个可选关键字参数是&lt;em&gt;stacklevel&lt;/em&gt;，缺省值为 &lt;code&gt;1&lt;/code&gt; 。如果大于1，则在计算为日志记录事件创建的&lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 中&lt;/a&gt;设置的行号和函数名时，将跳过相应的堆栈帧数。可以在记录帮助程序时使用它，以便记录的函数名称，文件名和行号不是帮助程序功能/方法的信息，而是其调用方的信息。此参数的名称反映了&lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt;模块中的等效参数。</target>
        </trans-unit>
        <trans-unit id="8eb0c095fa10852ea09d13926b5914515b40f06b" translate="yes" xml:space="preserve">
          <source>The third-party &lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;regex&lt;/a&gt; module, which has an API compatible with the standard library &lt;a href=&quot;#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; module, but offers additional functionality and a more thorough Unicode support.</source>
          <target state="translated">第三&lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;方正则表达式&lt;/a&gt;模块具有与标准库&lt;a href=&quot;#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; &lt;/a&gt;模块兼容的API ，但是提供了附加功能和更全面的Unicode支持。</target>
        </trans-unit>
        <trans-unit id="afb06b3287857cf9d40f49ddb415dd4aae4a33b0" translate="yes" xml:space="preserve">
          <source>The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although &lt;code&gt;quick_ratio()&lt;/code&gt; and &lt;code&gt;real_quick_ratio()&lt;/code&gt; are always at least as large as &lt;code&gt;ratio()&lt;/code&gt;:</source>
          <target state="translated">尽管 &lt;code&gt;quick_ratio()&lt;/code&gt; 和 &lt;code&gt;real_quick_ratio()&lt;/code&gt; 总是至少与 &lt;code&gt;ratio()&lt;/code&gt; 一样大，但由于近似程度不同，返回匹配字符与总字符的比率的三种方法可能会给出不同的结果：</target>
        </trans-unit>
        <trans-unit id="702f3b2e21f5e77bbf53b54dae40e50493de58c9" translate="yes" xml:space="preserve">
          <source>The time and date of the last modification to the archive member. This is a tuple of six values:</source>
          <target state="translated">归档成员最后一次修改的时间和日期。这是一个由六个值组成的元组。</target>
        </trans-unit>
        <trans-unit id="973cda5cc6748314dfb6fc94d1ded91647c97ce5" translate="yes" xml:space="preserve">
          <source>The time is an absolute timestamp, using the same time reference as &lt;a href=&quot;#asyncio.loop.time&quot;&gt;&lt;code&gt;loop.time()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">时间是绝对时间戳，使用与&lt;a href=&quot;#asyncio.loop.time&quot;&gt; &lt;code&gt;loop.time()&lt;/code&gt; &lt;/a&gt;相同的时间参考。</target>
        </trans-unit>
        <trans-unit id="a0676e756a3ab92c3f906666f0e732cf57a4078c" translate="yes" xml:space="preserve">
          <source>The time limit (in microseconds) on CPU time that a process can spend under real-time scheduling without making a blocking syscall.</source>
          <target state="translated">在实时调度下,一个进程在不进行阻塞系统调用的情况下对CPU时间的限制(以微秒为单位)。</target>
        </trans-unit>
        <trans-unit id="f49b9982b8903d085f6ab35fedbabd6bf7292265" translate="yes" xml:space="preserve">
          <source>The time taken by this routine is proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">该例程花费的时间与 &lt;code&gt;len(fragment)&lt;/code&gt; 成正比。</target>
        </trans-unit>
        <trans-unit id="f9aa5984100afffa888154716c5fc64965cd814c" translate="yes" xml:space="preserve">
          <source>The time value as returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;, and accepted by &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.mktime&quot;&gt;&lt;code&gt;mktime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;, is a sequence of 9 integers. The return values of &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; also offer attribute names for individual fields.</source>
          <target state="translated">如通过返回的时间值&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt;）&lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt;所接受，并且&lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#time.mktime&quot;&gt; &lt;code&gt;mktime()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt;，是9个整数的序列。&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt;的返回值还提供了各个字段的属性名称。</target>
        </trans-unit>
        <trans-unit id="144ea8db2e1df67dd3e6bba4613f86171460dbd9" translate="yes" xml:space="preserve">
          <source>The timeout is long enough to prevent test failure: it takes into account that the client and the server can run in different threads or even different processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec99df5e279a279e7cacd8a5f4eb9d1cd8f983fa" translate="yes" xml:space="preserve">
          <source>The timeout is short enough to prevent a test to wait for too long if the Internet request is blocked for whatever reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7943289bae9e7d567106c49f45467d0b1f6837" translate="yes" xml:space="preserve">
          <source>The timeout should be long enough for &lt;a href=&quot;socket#socket.socket.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;socket#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab441716da6934485838efd0cc96e45a465e34ee" translate="yes" xml:space="preserve">
          <source>The timeout value depends on the regrtest &lt;code&gt;--timeout&lt;/code&gt; command line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383501791bf73fad29eacbd1434a825d90dcda3d" translate="yes" xml:space="preserve">
          <source>The title bar contains the name of the file, the full path, and the version of Python and IDLE running the window. The status bar contains the line number (&amp;lsquo;Ln&amp;rsquo;) and column number (&amp;lsquo;Col&amp;rsquo;). Line numbers start with 1; column numbers with 0.</source>
          <target state="translated">标题栏包含文件名，完整路径以及运行该窗口的Python和IDLE的版本。状态栏包含行号（'Ln'）和列号（'Col'）。行号以1开头；列号为0。</target>
        </trans-unit>
        <trans-unit id="eb0ed541e548fb76d9c95f3b320418110775e844" translate="yes" xml:space="preserve">
          <source>The token buffer. It may be useful to examine this when catching exceptions.</source>
          <target state="translated">令牌缓冲区。在捕捉异常时,检查这个缓冲区可能很有用。</target>
        </trans-unit>
        <trans-unit id="af5684156d0632efbb688be764db6d9de4886083" translate="yes" xml:space="preserve">
          <source>The token constants are:</source>
          <target state="translated">令牌常数是:</target>
        </trans-unit>
        <trans-unit id="6369db38b3c0c1619322ec307a8d31c67ea8b3e6" translate="yes" xml:space="preserve">
          <source>The token is an opaque object (that supports equality testing) identifying the current version of the abstract base class cache for virtual subclasses. The token changes with every call to &lt;a href=&quot;#abc.ABCMeta.register&quot;&gt;&lt;code&gt;ABCMeta.register()&lt;/code&gt;&lt;/a&gt; on any ABC.</source>
          <target state="translated">令牌是一个不透明的对象（支持相等性测试），用于标识虚拟子类的抽象基类缓存的当前版本。在任何ABC上，每次调用&lt;a href=&quot;#abc.ABCMeta.register&quot;&gt; &lt;code&gt;ABCMeta.register()&lt;/code&gt; &lt;/a&gt;都会更改令牌。</target>
        </trans-unit>
        <trans-unit id="39df4a005bd76c17fb119282afd8e40603dd44b7" translate="yes" xml:space="preserve">
          <source>The tokenizer produces the following output:</source>
          <target state="translated">tokenizer产生以下输出。</target>
        </trans-unit>
        <trans-unit id="2e1221339de21aeb616c4d21ccf9328f0f362ac4" translate="yes" xml:space="preserve">
          <source>The total number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;) of expected bytes.</source>
          <target state="translated">预期字节的总数（&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="43f447355b23a2390fda8e4efbaeb61ee2a32abe" translate="yes" xml:space="preserve">
          <source>The total number of addresses in the network.</source>
          <target state="translated">网络中的地址总数。</target>
        </trans-unit>
        <trans-unit id="533c0b6ab55091223e2fa983b0fc2fb594c66022" translate="yes" xml:space="preserve">
          <source>The total number of bits in the address representation for this version: &lt;code&gt;32&lt;/code&gt; for IPv4, &lt;code&gt;128&lt;/code&gt; for IPv6.</source>
          <target state="translated">此版本的地址表示形式中的总位数：对于IPv4 为 &lt;code&gt;32&lt;/code&gt; ，对于IPv6 为 &lt;code&gt;128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fa2435ac265900a21416de414ab6af83ae21237" translate="yes" xml:space="preserve">
          <source>The total number of tests run so far.</source>
          <target state="translated">到目前为止运行的测试总数。</target>
        </trans-unit>
        <trans-unit id="e85ca4d6aa52bdeda7f809afceddc2f2528db8a5" translate="yes" xml:space="preserve">
          <source>The total number of to be consumed bytes.</source>
          <target state="translated">消耗的总字节数。</target>
        </trans-unit>
        <trans-unit id="ffa71222143917a1eb6464750e264a1c1dc0389a" translate="yes" xml:space="preserve">
          <source>The trace function is invoked (with &lt;em&gt;event&lt;/em&gt; set to &lt;code&gt;'call'&lt;/code&gt;) whenever a new local scope is entered; it should return a reference to a local trace function to be used for the new scope, or &lt;code&gt;None&lt;/code&gt; if the scope shouldn&amp;rsquo;t be traced.</source>
          <target state="translated">每当输入新的本地范围时，都会调用trace函数（&lt;em&gt;事件&lt;/em&gt;设置为 &lt;code&gt;'call'&lt;/code&gt; ）。它应该返回对要用于新作用域的本地跟踪函数的引用；如果不应该跟踪作用域，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0276db0e37cffd313334d18dfb0ebfdd11f2c19" translate="yes" xml:space="preserve">
          <source>The traceback header is followed by an optional traceback stack, whose contents are ignored by doctest. The traceback stack is typically omitted, or copied verbatim from an interactive session.</source>
          <target state="translated">回溯头后面是一个可选的回溯栈,其内容被doctest忽略。回溯栈通常被省略,或者从交互式会话中逐字复制。</target>
        </trans-unit>
        <trans-unit id="2d935d9b67ec8b6f96388a84f36cbe32492b44c2" translate="yes" xml:space="preserve">
          <source>The traceback stack is followed by the most interesting part: the line(s) containing the exception type and detail. This is usually the last line of a traceback, but can extend across multiple lines if the exception has a multi-line detail:</source>
          <target state="translated">回溯堆栈之后是最有趣的部分:包含异常类型和细节的行。这通常是回溯的最后一行,但如果异常有多行细节,则可以延伸到多行。</target>
        </trans-unit>
        <trans-unit id="16b1db494b134e9c8220a976eba1115a13e23b7c" translate="yes" xml:space="preserve">
          <source>The tracemalloc module is a debug tool to trace memory blocks allocated by Python. It provides the following information:</source>
          <target state="translated">tracemalloc 模块是一个调试工具,用于跟踪 Python 分配的内存块。它提供了以下信息。</target>
        </trans-unit>
        <trans-unit id="31a9ce8a876ac0217c1463774c12a24481761b30" translate="yes" xml:space="preserve">
          <source>The traditional method with a 2 character salt and 13 characters of hash. This is the weakest method.</source>
          <target state="translated">传统的方法,2个字符的盐和13个字符的哈希。这是最弱的方法。</target>
        </trans-unit>
        <trans-unit id="16acab894e31876506303b91db879f68d418dbb4" translate="yes" xml:space="preserve">
          <source>The transport classes are &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;not thread safe&lt;/a&gt;.</source>
          <target state="translated">传输类&lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;不是线程安全的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1d4addb81580c66d88e12e490015db638f34f42" translate="yes" xml:space="preserve">
          <source>The tree area.</source>
          <target state="translated">树区。</target>
        </trans-unit>
        <trans-unit id="63c5e92c4fd607dfc132dae25b1bde5801ce3c8a" translate="yes" xml:space="preserve">
          <source>The tree column has ID #0.</source>
          <target state="translated">树列的ID为0号。</target>
        </trans-unit>
        <trans-unit id="a7f4322c232ab22c451a4f904178e963f0c2b60b" translate="yes" xml:space="preserve">
          <source>The true value of the &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; type. Assignments to &lt;code&gt;True&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;类型的真实值。分配给 &lt;code&gt;True&lt;/code&gt; 是非法的，并引发&lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1385bf813f5ebaee50787de55cade7aa2ad93e9" translate="yes" xml:space="preserve">
          <source>The tuple of arguments given to the exception constructor. Some built-in exceptions (like &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.</source>
          <target state="translated">给异常构造函数的参数的元组。一些内置的异常（例如&lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;）期望有一定数量的参数，并为此元组的元素分配特殊的含义，而其他一些异常通常仅使用给出错误消息的单个字符串来调用。</target>
        </trans-unit>
        <trans-unit id="539f38dbbfed03502ac81a27a897e9fba44d57ad" translate="yes" xml:space="preserve">
          <source>The tuple of arguments merged into &lt;code&gt;msg&lt;/code&gt; to produce &lt;code&gt;message&lt;/code&gt;, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</source>
          <target state="translated">参数的元组合并到 &lt;code&gt;msg&lt;/code&gt; 中以生成 &lt;code&gt;message&lt;/code&gt; ，或者将其值用于合并的dict（当只有一个参数且它是一本字典时）。</target>
        </trans-unit>
        <trans-unit id="a56707db067b73f69f1d7eabd20ac87c56e218eb" translate="yes" xml:space="preserve">
          <source>The tuple of base classes of a class object.</source>
          <target state="translated">一个类对象的基类元组。</target>
        </trans-unit>
        <trans-unit id="39d9df05b4cf019ab0db7e17a8ec1ef2c24c1ad6" translate="yes" xml:space="preserve">
          <source>The turtle module provides turtle graphics primitives, in both object-oriented and procedure-oriented ways. Because it uses &lt;a href=&quot;tkinter#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; for the underlying graphics, it needs a version of Python installed with Tk support.</source>
          <target state="translated">乌龟模块以面向对象和面向过程的方式提供乌龟图形基元。由于它使用&lt;a href=&quot;tkinter#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt;作为基础图形，因此需要安装有Tk支持的Python版本。</target>
        </trans-unit>
        <trans-unit id="a905845d53cd321a94fdd9df15627053d06b84e2" translate="yes" xml:space="preserve">
          <source>The two connection objects returned by &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt; represent the two ends of the pipe. Each connection object has &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the &lt;em&gt;same&lt;/em&gt; end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt;返回的两个连接对象代表管道的两端。每个连接对象都有 &lt;code&gt;send()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt; 方法（以及其他方法）。请注意，如果两个进程（或线程）试图同时读取或写入管道的&lt;em&gt;同一&lt;/em&gt;端，则管道中的数据可能会损坏。当然，不存在同时使用管道不同端的过程造成损坏的风险。</target>
        </trans-unit>
        <trans-unit id="33638c8f9ee12ee7ff74956b792e2571ed375108" translate="yes" xml:space="preserve">
          <source>The two equality methods, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt;, are special. They do the default equality comparison on identity, using the &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; attribute, unless you change their return value to return something else:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt;这两个相等方法很特殊。他们使用&lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt;属性对身份进行默认的相等比较，除非您更改其返回值以返回其他内容：</target>
        </trans-unit>
        <trans-unit id="a0872f8b41c8731e6a21444642be7996b3a7fda9" translate="yes" xml:space="preserve">
          <source>The two equality methods, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt;, are special. They do the default equality comparison on identity, using the &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; attribute, unless you change their return value to return something else:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272ded31de2db6b1c275e8c03cf46f61287b0fca" translate="yes" xml:space="preserve">
          <source>The two following opening hooks are provided by this module:</source>
          <target state="translated">本模块提供了以下两个开头的钩子。</target>
        </trans-unit>
        <trans-unit id="aead13a3bf658785dba6c96c3877cce7bfdcf9ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;DOMString&lt;/code&gt; maps to Python strings. &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; supports either bytes or strings, but will normally produce strings. Values of type &lt;code&gt;DOMString&lt;/code&gt; may also be &lt;code&gt;None&lt;/code&gt; where allowed to have the IDL &lt;code&gt;null&lt;/code&gt; value by the DOM specification from the W3C.</source>
          <target state="translated">&lt;code&gt;DOMString&lt;/code&gt; 类型映射到Python字符串。&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt;支持字节或字符串，但通常会产生字符串。类型的值 &lt;code&gt;DOMString&lt;/code&gt; 也可以是 &lt;code&gt;None&lt;/code&gt; ，其中允许有IDL &lt;code&gt;null&lt;/code&gt; 通过从W3C DOM规范值。</target>
        </trans-unit>
        <trans-unit id="c595e9e60344120fd8650e635fb09cc7f554fb8e" translate="yes" xml:space="preserve">
          <source>The type for cell objects: such objects are used as containers for a function&amp;rsquo;s free variables.</source>
          <target state="translated">单元格对象的类型：此类对象用作函数的自由变量的容器。</target>
        </trans-unit>
        <trans-unit id="71d15bb94ba8cba5ce52cb311ed2945413c1e6a5" translate="yes" xml:space="preserve">
          <source>The type for code objects such as returned by &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">代码对象的类型，例如&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt;返回的类型。</target>
        </trans-unit>
        <trans-unit id="92c00f883941b35d8d88ec760276dd05ae566ab3" translate="yes" xml:space="preserve">
          <source>The type info for introspection can be accessed via &lt;code&gt;Point2D.__annotations__&lt;/code&gt; and &lt;code&gt;Point2D.__total__&lt;/code&gt;. To allow using this feature with older versions of Python that do not support &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;TypedDict&lt;/code&gt; supports two additional equivalent syntactic forms:</source>
          <target state="translated">可以通过 &lt;code&gt;Point2D.__annotations__&lt;/code&gt; 和 &lt;code&gt;Point2D.__total__&lt;/code&gt; 访问自省的类型信息。为了允许在不支持&lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;的Python较旧版本中使用此功能， &lt;code&gt;TypedDict&lt;/code&gt; 支持两种其他等效的语法形式：</target>
        </trans-unit>
        <trans-unit id="6883894e6bd2bb4b3e1642682cba68f7b9cb4b42" translate="yes" xml:space="preserve">
          <source>The type info for introspection can be accessed via &lt;code&gt;Point2D.__annotations__&lt;/code&gt; and &lt;code&gt;Point2D.__total__&lt;/code&gt;. To allow using this feature with older versions of Python that do not support &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;TypedDict&lt;/code&gt; supports two additional equivalent syntactic forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd18bd83b257d2f4e8efd82d8c82ff0e7639a2fe" translate="yes" xml:space="preserve">
          <source>The type is roughly equivalent to the following code:</source>
          <target state="translated">该类型大致相当于下面的代码。</target>
        </trans-unit>
        <trans-unit id="207228c87acec3636f2d576ab4dc507cd348293d" translate="yes" xml:space="preserve">
          <source>The type object for proxies of callable objects.</source>
          <target state="translated">可调用对象的代理类型对象。</target>
        </trans-unit>
        <trans-unit id="e2b65c714818fb9af6dfc2060e17b6ec9e44a466" translate="yes" xml:space="preserve">
          <source>The type object for proxies of objects which are not callable.</source>
          <target state="translated">不可调用的对象的代理类型对象。</target>
        </trans-unit>
        <trans-unit id="2f87adab9b428d0dbbf82d7c97420fce2530fdb4" translate="yes" xml:space="preserve">
          <source>The type object for weak references objects.</source>
          <target state="translated">弱引用对象的类型对象。</target>
        </trans-unit>
        <trans-unit id="aa5558fddf17c823ad3cef9043343cc8848a5e60" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt;-iterator objects, created by asynchronous generator functions.</source>
          <target state="translated">由异步生成器函数创建的异步生成&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;器&lt;/a&gt; -iterator对象的类型。</target>
        </trans-unit>
        <trans-unit id="fb3f39049fd95688f70b6d2f5803012a23c782f4" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; objects, created by &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;协程&lt;/a&gt;对象的类型，由&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt;函数创建。</target>
        </trans-unit>
        <trans-unit id="c085b6d1256e66aba3e73f22eb8afbb70e8ef9d0" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; returned by the &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function depends on the mode. When &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; is used to open a file in a text mode (&lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'rt'&lt;/code&gt;, etc.), it returns a subclass of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt; (specifically &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;). When used to open a file in a binary mode with buffering, the returned class is a subclass of &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;. The exact class varies: in read binary mode, it returns an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt;; in write binary and append binary modes, it returns an &lt;a href=&quot;io#io.BufferedWriter&quot;&gt;&lt;code&gt;io.BufferedWriter&lt;/code&gt;&lt;/a&gt;, and in read/write mode, it returns an &lt;a href=&quot;io#io.BufferedRandom&quot;&gt;&lt;code&gt;io.BufferedRandom&lt;/code&gt;&lt;/a&gt;. When buffering is disabled, the raw stream, a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;函数返回的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;的类型取决于模式。当使用&lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;以文本模式（ &lt;code&gt;'w'&lt;/code&gt; ， &lt;code&gt;'r'&lt;/code&gt; ， &lt;code&gt;'wt'&lt;/code&gt; ， &lt;code&gt;'rt'&lt;/code&gt; 等）打开文件时，它将返回&lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt;的子类（尤其是&lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt;）。当使用带缓冲的二进制模式打开文件时，返回的类是&lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt;的子类。确切的类有所不同：在读取二进制模式下，它返回&lt;a href=&quot;io#io.BufferedReader&quot;&gt; &lt;code&gt;io.BufferedReader&lt;/code&gt; &lt;/a&gt;；在写二进制和追加二进制模式下，它返回&lt;a href=&quot;io#io.BufferedWriter&quot;&gt; &lt;code&gt;io.BufferedWriter&lt;/code&gt; &lt;/a&gt;，在读/写模式下，它返回一个io.BufferedWriter。&lt;a href=&quot;io#io.BufferedRandom&quot;&gt; &lt;code&gt;io.BufferedRandom&lt;/code&gt; &lt;/a&gt;。当缓冲被禁用，原始流，的一个子类&lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt;，则返回。</target>
        </trans-unit>
        <trans-unit id="9137c1f6ce5bd7c384224288ce23eb4e33c57845" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator objects, created by generator functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;生成器&lt;/a&gt; -iterator对象的类型，由生成器函数创建。</target>
        </trans-unit>
        <trans-unit id="51c3737cac091c710a9cdbbb1a2fd03113a51fe7" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;modules&lt;/a&gt;. Constructor takes the name of the module to be created and optionally its &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;模块&lt;/a&gt;的类型。构造函数采用要创建的模块的名称，也可以采用其&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="291d37e4c9887ae702120f0529a3e97ebb306fbd" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt;-iterator objects, created by asynchronous generator functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b5b7b182a49432d464ffdc625a8f750463126a" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; objects, created by &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0962ea0fff94bd2389dc9ecff0d9c99235c182c1" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; returned by the &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function depends on the mode. When &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; is used to open a file in a text mode (&lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'rt'&lt;/code&gt;, etc.), it returns a subclass of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt; (specifically &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;). When used to open a file in a binary mode with buffering, the returned class is a subclass of &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;. The exact class varies: in read binary mode, it returns an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt;; in write binary and append binary modes, it returns an &lt;a href=&quot;io#io.BufferedWriter&quot;&gt;&lt;code&gt;io.BufferedWriter&lt;/code&gt;&lt;/a&gt;, and in read/write mode, it returns an &lt;a href=&quot;io#io.BufferedRandom&quot;&gt;&lt;code&gt;io.BufferedRandom&lt;/code&gt;&lt;/a&gt;. When buffering is disabled, the raw stream, a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02c8a5211cfd9d6991973dae5c80b19e6a1c2d8" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator objects, created by generator functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce115de470364ff83b5336167e2e5b10f9e8447a" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module&quot;&gt;modules&lt;/a&gt;. Constructor takes the name of the module to be created and optionally its &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ad83c0160d0aa864e6656bf7e1de1027e52421" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;stdtypes#types-genericalias&quot;&gt;parameterized generics&lt;/a&gt; such as &lt;code&gt;list[int]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851dfab6c777918e2e97801375bfa3600e1be478" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;self.request&lt;/code&gt; is different for datagram or stream services. For stream services, &lt;code&gt;self.request&lt;/code&gt; is a socket object; for datagram services, &lt;code&gt;self.request&lt;/code&gt; is a pair of string and socket.</source>
          <target state="translated">数据报或流服务的 &lt;code&gt;self.request&lt;/code&gt; 类型不同。对于流服务， &lt;code&gt;self.request&lt;/code&gt; 是一个套接字对象；对于数据报服务， &lt;code&gt;self.request&lt;/code&gt; 是一对字符串和套接字。</target>
        </trans-unit>
        <trans-unit id="39ace067e7b8a07177cd07450cb98fd890c32fb2" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;bound&lt;/em&gt; methods of some built-in data types and base classes. For example it is the type of &lt;code&gt;object().__str__&lt;/code&gt;.</source>
          <target state="translated">一些内置数据类型和基类的&lt;em&gt;绑定&lt;/em&gt;方法的类型。例如，它是 &lt;code&gt;object().__str__&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="054ec7ace9d8f1f81933bf82d68367c2b78aad15" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;unbound&lt;/em&gt; class methods of some built-in data types such as &lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt;.</source>
          <target state="translated">一些内置数据类型的&lt;em&gt;未绑定&lt;/em&gt;类方法的类型，例如 &lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edc6b284de88d85c6dcdc7c5fb2de19cafa4c532" translate="yes" xml:space="preserve">
          <source>The type of built-in functions like &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt;, and methods of built-in classes. (Here, the term &amp;ldquo;built-in&amp;rdquo; means &amp;ldquo;written in C&amp;rdquo;.)</source>
          <target state="translated">内置函数的类型（例如&lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; )&lt;/a&gt;以及内置类的方法。（在这里，术语&amp;ldquo;内置&amp;rdquo;是指&amp;ldquo;用C编写&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="e7a3e7e227b15d7de2c5d33d406e0fdb0848b0ef" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;body_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">编码类型（base64或带引号的可打印&lt;em&gt;格式&lt;/em&gt;）将基于&lt;em&gt;body_encoding&lt;/em&gt;属性。</target>
        </trans-unit>
        <trans-unit id="daa919876c8026bbd456f4980d7d66ce3c1e4e34" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;header_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">编码类型（base64或带引号的可打印&lt;em&gt;格式&lt;/em&gt;）将基于&lt;em&gt;header_encoding&lt;/em&gt;属性。</target>
        </trans-unit>
        <trans-unit id="5f3fdc1f795bc115fa25d9a7ee9f014076d623a1" translate="yes" xml:space="preserve">
          <source>The type of file objects supported depends on the platform: on Windows, sockets are supported, but not pipes, whereas on Unix, both are supported (some other types may be supported as well, such as fifos or special file devices).</source>
          <target state="translated">支持的文件对象类型取决于平台:在Windows上,支持套接字,但不支持管道,而在Unix上,两者都支持(也可能支持一些其他类型,如fifos或特殊文件设备)。</target>
        </trans-unit>
        <trans-unit id="3596a6e3c65ed88cc1d8e8b7d814d3dabfd3476a" translate="yes" xml:space="preserve">
          <source>The type of frame objects such as found in &lt;code&gt;tb.tb_frame&lt;/code&gt; if &lt;code&gt;tb&lt;/code&gt; is a traceback object.</source>
          <target state="translated">框架对象的类型，例如，如果 &lt;code&gt;tb&lt;/code&gt; 是回溯对象，则在 &lt;code&gt;tb.tb_frame&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="75460e66c894ac26297c70dd2c59bf341c1ac5d4" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types and base classes such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;object.__init__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;object.__lt__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一些内置数据类型和基类的方法类型，例如&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;object.__init__()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;object.__lt__()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="006cc434974d0c712e82a1fc52ff84f562270642" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types and base classes such as &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;object.__init__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;object.__lt__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802b8bb24f2cee63ab7e9a26db85ba1e69bde6fb" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types such as &lt;a href=&quot;stdtypes#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一些内置数据类型的方法类型，例如&lt;a href=&quot;stdtypes#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d0fea4bd572efbc49d1a1be2c36df840b937e1d" translate="yes" xml:space="preserve">
          <source>The type of methods of user-defined class instances.</source>
          <target state="translated">用户定义类实例的方法类型。</target>
        </trans-unit>
        <trans-unit id="d85b5663cf70afd56961d534baa36aa27fa3f1e2" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyGetSetDef&lt;/code&gt;, such as &lt;code&gt;FrameType.f_locals&lt;/code&gt; or &lt;code&gt;array.array.typecode&lt;/code&gt;. This type is used as descriptor for object attributes; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">在具有 &lt;code&gt;PyGetSetDef&lt;/code&gt; 的扩展模块中定义的对象的类型，例如 &lt;code&gt;FrameType.f_locals&lt;/code&gt; 或 &lt;code&gt;array.array.typecode&lt;/code&gt; 。此类型用作对象属性的描述符。它具有与&lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt;类型相同的目的，但用于扩展模块中定义的类。</target>
        </trans-unit>
        <trans-unit id="65d9791079f3a5f0479b8fc1fe7de9de776be32e" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyMemberDef&lt;/code&gt;, such as &lt;code&gt;datetime.timedelta.days&lt;/code&gt;. This type is used as descriptor for simple C data members which use standard conversion functions; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">在 &lt;code&gt;PyMemberDef&lt;/code&gt; 扩展模块中定义的对象类型，例如 &lt;code&gt;datetime.timedelta.days&lt;/code&gt; 。此类型用作使用标准转换函数的简单C数据成员的描述符；它具有与&lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt;类型相同的目的，但用于扩展模块中定义的类。</target>
        </trans-unit>
        <trans-unit id="af9c2c83b8c60dabd2c034b33bbb7fdb10e6d512" translate="yes" xml:space="preserve">
          <source>The type of socket used by the server; &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;socket.SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; are two common values.</source>
          <target state="translated">服务器使用的套接字类型；&lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt; &lt;/a&gt;是两个常见的值。</target>
        </trans-unit>
        <trans-unit id="be204b93125e9374a47e9c0607ad154bb8bb9d7d" translate="yes" xml:space="preserve">
          <source>The type of the connection is determined by &lt;em&gt;family&lt;/em&gt; argument, but this can generally be omitted since it can usually be inferred from the format of &lt;em&gt;address&lt;/em&gt;. (See &lt;a href=&quot;#multiprocessing-address-formats&quot;&gt;Address Formats&lt;/a&gt;)</source>
          <target state="translated">连接的类型由&lt;em&gt;Family&lt;/em&gt;参数确定，但通常可以省略，因为它通常可以从&lt;em&gt;address&lt;/em&gt;的格式推断出来。（请参阅&lt;a href=&quot;#multiprocessing-address-formats&quot;&gt;地址格式&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="bd30a5963bbcf91e157911dfc75bf91da7146bda" translate="yes" xml:space="preserve">
          <source>The type of the objects returned by &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt;返回的对象的类型。</target>
        </trans-unit>
        <trans-unit id="2415aa71d53e852131b074eb25a6c6db74a53fb6" translate="yes" xml:space="preserve">
          <source>The type of the return values from the &lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt;&lt;code&gt;ParserCreate()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt; &lt;code&gt;ParserCreate()&lt;/code&gt; &lt;/a&gt;函数的返回值的类型。</target>
        </trans-unit>
        <trans-unit id="f1e00a1edd876419fe2ebe3767b0aed891735220" translate="yes" xml:space="preserve">
          <source>The type of the time value sequence returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;. It is an object with a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; interface: values can be accessed by index and by attribute name. The following values are present:</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt;返回的时间值序列的类型。它是具有&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;命名元组&lt;/a&gt;接口的对象：可以通过索引和属性名称访问值。存在以下值：</target>
        </trans-unit>
        <trans-unit id="053a7afe80b04d32a06bfff90db5eb35bc914e6d" translate="yes" xml:space="preserve">
          <source>The type of the time value sequence returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;. It is an object with a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; interface: values can be accessed by index and by attribute name. The following values are present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a09ba982dc1f24bfd7bfea4ab6a3ce49113c82" translate="yes" xml:space="preserve">
          <source>The type of traceback objects such as found in &lt;code&gt;sys.exc_info()[2]&lt;/code&gt;.</source>
          <target state="translated">追溯对象的类型，例如在 &lt;code&gt;sys.exc_info()[2]&lt;/code&gt; 中找到的类型。</target>
        </trans-unit>
        <trans-unit id="14fb1882a83121d6512420b73ddf7c6df4b29e08" translate="yes" xml:space="preserve">
          <source>The type of user-defined functions and functions created by &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">用户定义函数的类型以及由&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt; &lt;code&gt;lambda&lt;/code&gt; &lt;/a&gt;表达式创建的函数。</target>
        </trans-unit>
        <trans-unit id="fdf47ff25ed233afa798ad63a4c3d489b4b155fe" translate="yes" xml:space="preserve">
          <source>The type of user-defined functions and functions created by &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#lambda&quot;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845e42910aebf464f039df10da42d715e332ff1d" translate="yes" xml:space="preserve">
          <source>The type system of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module is extensible in two ways: you can store additional Python types in a SQLite database via object adaptation, and you can let the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module convert SQLite types to different Python types via converters.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt;模块的类型系统可以通过两种方式扩展：您可以通过对象适配将其他Python类型存储在SQLite数据库中，并且可以让&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt;模块通过转换器将SQLite类型转换为不同的Python类型。</target>
        </trans-unit>
        <trans-unit id="f3a6af98017fdeff071bf353e1479e07931b4d2f" translate="yes" xml:space="preserve">
          <source>The typecode character used to create the array.</source>
          <target state="translated">用于创建数组的类型代码字符。</target>
        </trans-unit>
        <trans-unit id="0c959abb200e6f216cd6c46680afae3d3493423d" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;short int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, and &lt;code&gt;boolean&lt;/code&gt; all map to Python integer objects.</source>
          <target state="translated">类型 &lt;code&gt;short int&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;unsigned long long&lt;/code&gt; 和 &lt;code&gt;boolean&lt;/code&gt; 类型都映射到Python整数对象。</target>
        </trans-unit>
        <trans-unit id="4d560d8f900eca6af7a86605d169b14ce3732718" translate="yes" xml:space="preserve">
          <source>The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; repeatedly until they see the desired state, while threads that modify the state call &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity:</source>
          <target state="translated">典型的使用条件变量的编程风格使用锁来同步对某些共享状态的访问。对状态的特定更改感兴趣的线程会反复调用&lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;直到看到所需的状态，而对状态进行修改的线程在以某种可能的方式更改状态时会调用&lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt;。其中一个服务员的期望状态。例如，以下代码是具有无限缓冲区容量的一般生产者-消费者情况：</target>
        </trans-unit>
        <trans-unit id="6cce4ca16ef59a2c9a6e26b00995455dbe5b43db" translate="yes" xml:space="preserve">
          <source>The typical usage to break into the debugger from a running program is to insert</source>
          <target state="translated">从运行中的程序闯入调试器的典型用法是插入</target>
        </trans-unit>
        <trans-unit id="312b8c5e06e9b508c2dc3394df6f8c328dcdd28f" translate="yes" xml:space="preserve">
          <source>The typical usage to inspect a crashed program is:</source>
          <target state="translated">检查崩溃程序的典型用法是:。</target>
        </trans-unit>
        <trans-unit id="19aaa16d46a9088205f8b111d28555cd6514b9f9" translate="yes" xml:space="preserve">
          <source>The typical use is:</source>
          <target state="translated">典型的用途是:</target>
        </trans-unit>
        <trans-unit id="3f88d8816221987271260ee8ea49f5b5d7cf3e10" translate="yes" xml:space="preserve">
          <source>The uid and gid items are integers, all others are strings. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">uid和gid项目是整数，所有其他都是字符串。如果找不到要求的条目，则会引发&lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f5c1273b1d4b80fefb18a2d5748785e0ad812ac" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;sqlite3&lt;/code&gt; library operates in &lt;code&gt;autocommit&lt;/code&gt; mode by default, but the Python &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module by default does not.</source>
          <target state="translated">底层 &lt;code&gt;sqlite3&lt;/code&gt; 库默认情况下在 &lt;code&gt;autocommit&lt;/code&gt; 模式下运行，但Python &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt;模块默认情况下不运行。</target>
        </trans-unit>
        <trans-unit id="692c81225394c94ff32b84438ec4aa9ac22b33ab" translate="yes" xml:space="preserve">
          <source>The underlying Readline library API may be implemented by the &lt;code&gt;libedit&lt;/code&gt; library instead of GNU readline. On macOS the &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module detects which library is being used at run time.</source>
          <target state="translated">底层的Readline库API可以由 &lt;code&gt;libedit&lt;/code&gt; 库而不是GNU readline实现。在macOS上，&lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;模块检测运行时正在使用哪个库。</target>
        </trans-unit>
        <trans-unit id="cbd3a217e06ecf1e9ba395c9d3b83ea44a75be37" translate="yes" xml:space="preserve">
          <source>The underlying binary buffer (a &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist in some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt;处理的基础二进制缓冲区（一个&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt;实例）。这不是&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt; API的一部分，在某些实现中可能不存在。</target>
        </trans-unit>
        <trans-unit id="c099cf6d6c9538690a044409fa62678eb6541891" translate="yes" xml:space="preserve">
          <source>The underlying mappings are stored in a list. That list is public and can be accessed or updated using the &lt;em&gt;maps&lt;/em&gt; attribute. There is no other state.</source>
          <target state="translated">基础映射存储在列表中。该列表是公共的，可以使用&lt;em&gt;maps&lt;/em&gt;属性进行访问或更新。没有其他状态。</target>
        </trans-unit>
        <trans-unit id="c8ed57a843f0b2c56ec32e93f7034f9d564cc770" translate="yes" xml:space="preserve">
          <source>The underlying object of the memoryview:</source>
          <target state="translated">内存视图的底层对象。</target>
        </trans-unit>
        <trans-unit id="74ffc7561de47c1ca7be4db22d58088aa8da9469" translate="yes" xml:space="preserve">
          <source>The underlying process creation and management in this module is handled by the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; class. It offers a lot of flexibility so that developers are able to handle the less common cases not covered by the convenience functions.</source>
          <target state="translated">该模块中的基础流程创建和管理由&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt;类处理。它提供了很大的灵活性，以便开发人员能够处理便捷功能未涵盖的不太常见的情况。</target>
        </trans-unit>
        <trans-unit id="ba3e655d8ac47240c2d2f5980db91a3ca2ecc86b" translate="yes" xml:space="preserve">
          <source>The underlying raw stream (a &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist on some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt;处理的基础原始流（&lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt;实例）。这不是&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; API的一部分，在某些实现中可能不存在。</target>
        </trans-unit>
        <trans-unit id="d1573d571c13d16324a3c741bed96fa34d92b283" translate="yes" xml:space="preserve">
          <source>The unformatted error message.</source>
          <target state="translated">未格式化的错误信息。</target>
        </trans-unit>
        <trans-unit id="05f3ae582f0c0636a61039860a85ef0508aa13e0" translate="yes" xml:space="preserve">
          <source>The unittest module can be used from the command line to run tests from modules, classes or even individual test methods:</source>
          <target state="translated">unittest模块可以通过命令行来运行模块、类甚至单个测试方法的测试。</target>
        </trans-unit>
        <trans-unit id="6dde9ab65dc4b9f7975e19a23a1127cf92b2b035" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt;. This value is not locale-dependent and will not change.</source>
          <target state="translated">大写字母 &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt; 。此值与语言环境无关，并且不会更改。</target>
        </trans-unit>
        <trans-unit id="0854cdf9ca6554793143fab76b0e342cda85438d" translate="yes" xml:space="preserve">
          <source>The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">所使用的大写字母算法在Unicode标准的3.13节中有描述。</target>
        </trans-unit>
        <trans-unit id="f9b9af9c2a1fd50996417214bffd38cd04caabd4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;%Z&lt;/code&gt; is now deprecated, but the &lt;code&gt;%z&lt;/code&gt; escape that expands to the preferred hour/minute offset is not supported by all ANSI C libraries. Also, a strict reading of the original 1982 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; standard calls for a two-digit year (%y rather than %Y), but practice moved to 4-digit years long before the year 2000. After that, &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; became obsolete and the 4-digit year has been first recommended by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123&lt;/strong&gt;&lt;/a&gt; and then mandated by &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">现在已不建议使用 &lt;code&gt;%Z&lt;/code&gt; ，但并非所有ANSI C库都支持 &lt;code&gt;%z&lt;/code&gt; 转义扩展到首选的小时/分钟偏移量。同样，严格阅读原始1982 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt;标准要求使用两位数的年份（％y而不是％Y），但实践已转移到2000年之前的4位年份。在那之后，&lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt;变得过时了， 4位数字的年份首先由&lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123&lt;/strong&gt;&lt;/a&gt;建议，然后由&lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;规定。</target>
        </trans-unit>
        <trans-unit id="818e1de1ee279a3d12fd00fd42609c4b0aa39222" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;CDATASection&lt;/code&gt; node does not indicate that the node represents a complete CDATA marked section, only that the content of the node was part of a CDATA section. A single CDATA section may be represented by more than one node in the document tree. There is no way to determine whether two adjacent &lt;code&gt;CDATASection&lt;/code&gt; nodes represent different CDATA marked sections.</source>
          <target state="translated">使用 &lt;code&gt;CDATASection&lt;/code&gt; 节点并不表示该节点代表完整的CDATA标记部分，而仅表示该节点的内容是CDATA部分的一部分。单个CDATA节可由文档树中的多个节点表示。无法确定两个相邻的 &lt;code&gt;CDATASection&lt;/code&gt; 节点是否代表不同的CDATA标记部分。</target>
        </trans-unit>
        <trans-unit id="e59fb5d1424421341c7c08cd960ce1c43d8cae74" translate="yes" xml:space="preserve">
          <source>The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it&amp;rsquo;s acquired will go undetected.</source>
          <target state="translated">有界信号量的使用减少了导致信号量被释放超过获取量的编程错误不会被检测到的机会。</target>
        </trans-unit>
        <trans-unit id="503e039e7a7945e22e53e684cd41c8ddeb2296c8" translate="yes" xml:space="preserve">
          <source>The use of decimal floating point eliminates decimal representation error (making it possible to represent &lt;code&gt;0.1&lt;/code&gt; exactly); however, some operations can still incur round-off error when non-zero digits exceed the fixed precision.</source>
          <target state="translated">使用十进制浮点数消除了十进制表示错误（可以精确表示 &lt;code&gt;0.1&lt;/code&gt; ）；但是，当非零数字超过固定精度时，某些操作仍然会产生舍入错误。</target>
        </trans-unit>
        <trans-unit id="ef05d3a555addffe6383bb0c2ceb5c3b10ece3a4" translate="yes" xml:space="preserve">
          <source>The use of dynamic dispatching by &lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt;&lt;code&gt;Repr.repr1()&lt;/code&gt;&lt;/a&gt; allows subclasses of &lt;a href=&quot;#reprlib.Repr&quot;&gt;&lt;code&gt;Repr&lt;/code&gt;&lt;/a&gt; to add support for additional built-in object types or to modify the handling of types already supported. This example shows how special support for file objects could be added:</source>
          <target state="translated">&lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt; &lt;code&gt;Repr.repr1()&lt;/code&gt; &lt;/a&gt;使用动态分派允许&lt;a href=&quot;#reprlib.Repr&quot;&gt; &lt;code&gt;Repr&lt;/code&gt; 的&lt;/a&gt;子类添加对其他内置对象类型的支持或修改已经支持的类型的处理。此示例说明如何添加对文件对象的特殊支持：</target>
        </trans-unit>
        <trans-unit id="52d05a35e93648db761f9430668b0f890705b58d" translate="yes" xml:space="preserve">
          <source>The useful mapping keys in a &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; are given in the section on &lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord属性&lt;/a&gt;部分提供了&lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt;中有用的映射键。</target>
        </trans-unit>
        <trans-unit id="61191e6c79c749cd7aba4196b38f6b9a262afba8" translate="yes" xml:space="preserve">
          <source>The user does not instantiate a transport directly; they call a utility function, passing it a protocol factory and other information necessary to create the transport and protocol.</source>
          <target state="translated">用户并不直接实例化一个传输,而是调用一个实用函数,向其传递协议工厂和其他创建传输和协议所需的信息。</target>
        </trans-unit>
        <trans-unit id="799492a2bc4f8c18e914c5fd6750e59de66fb8b8" translate="yes" xml:space="preserve">
          <source>The user of &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt;&lt;code&gt;mkdtemp()&lt;/code&gt;&lt;/a&gt; is responsible for deleting the temporary directory and its contents when done with it.</source>
          <target state="translated">&lt;a href=&quot;#tempfile.mkdtemp&quot;&gt; &lt;code&gt;mkdtemp()&lt;/code&gt; &lt;/a&gt;的用户负责在完成后删除临时目录及其内容。</target>
        </trans-unit>
        <trans-unit id="50e266ba92d8277d2b2353b0363957a1543b30c2" translate="yes" xml:space="preserve">
          <source>The user-exposed type for the &lt;code&gt;GenericAlias&lt;/code&gt; object can be accessed from &lt;a href=&quot;types#types.GenericAlias&quot;&gt;&lt;code&gt;types.GenericAlias&lt;/code&gt;&lt;/a&gt; and used for &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; checks. It can also be used to create &lt;code&gt;GenericAlias&lt;/code&gt; objects directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee129ab0f90820dc953cf701d4d07af6a6196607" translate="yes" xml:space="preserve">
          <source>The user-provided request handler class; an instance of this class is created for each request.</source>
          <target state="translated">用户提供的请求处理类;该类的实例为每个请求创建。</target>
        </trans-unit>
        <trans-unit id="72b7902f1383f94a27baa827eb01bca89cc62cbc" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;queue#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;queue#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; exceptions from the standard library&amp;rsquo;s &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; module are raised to signal timeouts.</source>
          <target state="translated">标准库的&lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt;模块中的通常&lt;a href=&quot;queue#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;queue#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt;异常引发了超时。</target>
        </trans-unit>
        <trans-unit id="4fb214e67950bddad6409524a77147f01c797d75" translate="yes" xml:space="preserve">
          <source>The usual approach to working with decimals is to create &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instances and then apply arithmetic operations which take place within the current context for the active thread. An alternative approach is to use context methods for calculating within a specific context. The methods are similar to those for the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; class and are only briefly recounted here.</source>
          <target state="translated">处理小数的通常方法是创建&lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt;实例，然后应用在活动线程的当前上下文内发生的算术运算。一种替代方法是使用上下文方法在特定上下文中进行计算。这些方法与&lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt;类的方法相似，在此仅作简要介绍。</target>
        </trans-unit>
        <trans-unit id="7e0cd4e412d5835966f4133590beac72566aa7f2" translate="yes" xml:space="preserve">
          <source>The usual dictionary methods are available for &lt;a href=&quot;#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; objects except for two which work differently for counters.</source>
          <target state="translated">常用的字典方法可用于&lt;a href=&quot;#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt;对象，但两种方法对计数器的工作方式不同。</target>
        </trans-unit>
        <trans-unit id="fc3dad1947c78cee7834b38256f73aa158a2e66a" translate="yes" xml:space="preserve">
          <source>The usual fix is to either await the coroutine or call the &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">通常的解决方法是等待协程或调用&lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="ab66de48e5569d8b04e6ed1de85c17b699cb8d3c" translate="yes" xml:space="preserve">
          <source>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</source>
          <target state="translated">通常的pickling限制是适用的:可picklable enums必须在一个模块的顶层定义,因为unpickling要求它们可以从该模块导入。</target>
        </trans-unit>
        <trans-unit id="e12393a3161a5ffd9c52bf6911f34c236e2c9953" translate="yes" xml:space="preserve">
          <source>The usual start to using decimals is importing the module, viewing the current context with &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; and, if necessary, setting new values for precision, rounding, or enabled traps:</source>
          <target state="translated">使用小数的通常开始是导入模块，使用&lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt;查看当前上下文，并在必要时设置精度，舍入或启用陷阱的新值：</target>
        </trans-unit>
        <trans-unit id="2008881e3db430ce4e534a59aaba96d96406f254" translate="yes" xml:space="preserve">
          <source>The valid options/values are:</source>
          <target state="translated">有效的选项/值是:</target>
        </trans-unit>
        <trans-unit id="833f8e1091d762b7c244ed494067360a08b6e65e" translate="yes" xml:space="preserve">
          <source>The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is outside that range.</source>
          <target state="translated">参数的有效范围是从0到1,114,111（以16为底的0x10FFFF）。如果&lt;em&gt;我&lt;/em&gt;超出该范围，将引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3f14b8f02287106623bf0b009141cb29a66c076" translate="yes" xml:space="preserve">
          <source>The value &lt;em&gt;n&lt;/em&gt; is an integer, or an object implementing &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;. Zero and negative values of &lt;em&gt;n&lt;/em&gt; clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for &lt;code&gt;s * n&lt;/code&gt; under &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt;.</source>
          <target state="translated">值&lt;em&gt;n&lt;/em&gt;是整数，或者是实现&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt;的对象。&lt;em&gt;n的&lt;/em&gt;零值和负值将清除序列。序列中的项目不会被复制；它们被多次引用，如&amp;ldquo; &lt;a href=&quot;#typesseq-common&quot;&gt;公共序列操作&amp;rdquo;中&lt;/a&gt;对 &lt;code&gt;s * n&lt;/code&gt; 解释。</target>
        </trans-unit>
        <trans-unit id="1ba1cd83c4ea949f698df2968249e46ad9293fd5" translate="yes" xml:space="preserve">
          <source>The value &lt;em&gt;n&lt;/em&gt; is an integer, or an object implementing &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;. Zero and negative values of &lt;em&gt;n&lt;/em&gt; clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for &lt;code&gt;s * n&lt;/code&gt; under &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f91839dd752530537b6fc14cfb59cfb821e2678" translate="yes" xml:space="preserve">
          <source>The value conversion will use the &amp;ldquo;alternate form&amp;rdquo; (where defined below).</source>
          <target state="translated">值转换将使用&amp;ldquo;替代形式&amp;rdquo;（在下面定义）。</target>
        </trans-unit>
        <trans-unit id="a2668d51d3a069a8b17be6a5bdb69b22691876de" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;True&lt;/code&gt;. Deprecated, because Python now always has threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd7f69b5373d9254a89d97b317bed89c36400a6" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;endpos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string beyond which the RE engine will not go.</source>
          <target state="translated">传递给&lt;a href=&quot;#re-objects&quot;&gt;正则表达式对象&lt;/a&gt;的&lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt;方法的&lt;em&gt;endpos&lt;/em&gt;的值。这是字符串的索引，RE引擎将超出该索引。</target>
        </trans-unit>
        <trans-unit id="4d524ce944ce6faac364cea7cad2143666016939" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;pos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string at which the RE engine started looking for a match.</source>
          <target state="translated">传递给&lt;a href=&quot;#re-objects&quot;&gt;正则表达式对象&lt;/a&gt;的&lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt;方法的&lt;em&gt;pos&lt;/em&gt;值。这是RE引擎开始寻找匹配项的字符串索引。</target>
        </trans-unit>
        <trans-unit id="2e998dbaff3bb1395e14cf6d02ecba7f97ecf5de" translate="yes" xml:space="preserve">
          <source>The value of each item is either a string, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not present.</source>
          <target state="translated">每个项目的值可以是一个字符串，或者&lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;如果不存在。</target>
        </trans-unit>
        <trans-unit id="894da0d8a1deaf4025187c213b697678d4d8eea2" translate="yes" xml:space="preserve">
          <source>The value of the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; reporting flags in effect before the function was called is returned by the function.</source>
          <target state="translated">该函数将返回调用该函数之前有效的&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt;报告标志的值。</target>
        </trans-unit>
        <trans-unit id="f4b6f6af5fd914e4e1977bd8812ad275e173d35e" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;start&lt;/em&gt; parameter (or &lt;code&gt;0&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;开始&lt;/em&gt;参数的值（如果未提供该参数，则为 &lt;code&gt;0&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9ee46e1de13205f2274d5b605d7f91d5eb44066d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;step&lt;/em&gt; parameter (or &lt;code&gt;1&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;step&lt;/em&gt;参数的值（如果未提供该参数，则为 &lt;code&gt;1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3effb996f3fdf8925f1c3f71f6aef7653bb530e1" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;stop&lt;/em&gt; parameter</source>
          <target state="translated">&lt;em&gt;停止&lt;/em&gt;参数的值</target>
        </trans-unit>
        <trans-unit id="b6df41c014faa1a95a93823c98dc9147024275f4" translate="yes" xml:space="preserve">
          <source>The value of the cookie.</source>
          <target state="translated">Cookie的值。</target>
        </trans-unit>
        <trans-unit id="c946fe7e22930d8d97dd543837147d8b1bce64ca" translate="yes" xml:space="preserve">
          <source>The value of the registry item.</source>
          <target state="translated">登记处项目的价值。</target>
        </trans-unit>
        <trans-unit id="88e44b4995d1d06c008be0ccf6fee3422ea4e070" translate="yes" xml:space="preserve">
          <source>The value of this variable can be changed before calling &lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and the new value will take effect.</source>
          <target state="translated">可以在调用&lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt;之前更改此变量的值，新值将生效。</target>
        </trans-unit>
        <trans-unit id="bde8c85afabd3e8125721b1ff7d5b17f9d9dee96" translate="yes" xml:space="preserve">
          <source>The value resulting from &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; is equal to the value that would be obtained by computing &lt;code&gt;(x**y)
% modulo&lt;/code&gt; with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;modulo&lt;/code&gt;. The result is always exact.</source>
          <target state="translated">从得到的值 &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; 等于将通过计算获得的值 &lt;code&gt;(x**y) % modulo&lt;/code&gt; 与无界的精度，但被更有效地计算出来。无论 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;modulo&lt;/code&gt; 的指数如何，结果的指数均为零。结果总是准确的。</target>
        </trans-unit>
        <trans-unit id="c59b0eb2c27f951fa0cace7c837f6202b755a295" translate="yes" xml:space="preserve">
          <source>The value returned is a named tuple of type &lt;a href=&quot;os#os.terminal_size&quot;&gt;&lt;code&gt;os.terminal_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值是&lt;a href=&quot;os#os.terminal_size&quot;&gt; &lt;code&gt;os.terminal_size&lt;/code&gt; &lt;/a&gt;类型的命名元组。</target>
        </trans-unit>
        <trans-unit id="7bc5693e6a9c72e20f0575057dd4ee5bc74f98db" translate="yes" xml:space="preserve">
          <source>The value returned may be larger than the &lt;em&gt;item&lt;/em&gt; added. If that isn&amp;rsquo;t desired, consider using &lt;a href=&quot;#heapq.heappushpop&quot;&gt;&lt;code&gt;heappushpop()&lt;/code&gt;&lt;/a&gt; instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap.</source>
          <target state="translated">返回的值可能大于添加的&lt;em&gt;项目&lt;/em&gt;。如果不希望这样做，请考虑改用&lt;a href=&quot;#heapq.heappushpop&quot;&gt; &lt;code&gt;heappushpop()&lt;/code&gt; &lt;/a&gt;。它的推/弹出组合返回两个值中较小的一个，而将较大的值保留在堆上。</target>
        </trans-unit>
        <trans-unit id="d795005d4b340675bfb305f1568f0d0d9ec61967" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multiprocess&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">用于 &lt;code&gt;wsgi.multiprocess&lt;/code&gt; 环境变量的值。在&lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 中&lt;/a&gt;，它默认为true ，但在其他子类中可能具有不同的默认值（或由构造函数设置）。</target>
        </trans-unit>
        <trans-unit id="a90b6e14952af2c1c7e8dc26e1fb8bc2a1a91cdc" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multithread&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">用于 &lt;code&gt;wsgi.multithread&lt;/code&gt; 环境变量的值。在&lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 中&lt;/a&gt;，它默认为true ，但在其他子类中可能具有不同的默认值（或由构造函数设置）。</target>
        </trans-unit>
        <trans-unit id="16e4c0519d360e3b8f5f9b274c196a4c6f3d4db2" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.run_once&lt;/code&gt; environment variable. It defaults to false in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt; sets it to true by default.</source>
          <target state="translated">用于 &lt;code&gt;wsgi.run_once&lt;/code&gt; 环境变量的值。在&lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 中&lt;/a&gt;，它默认为false ，但&lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt;默认将其设置为true。</target>
        </trans-unit>
        <trans-unit id="78bd89035d6220ea534538c62645a0424951cebd" translate="yes" xml:space="preserve">
          <source>The value used to indicate that no namespace is associated with a node in the DOM. This is typically found as the &lt;code&gt;namespaceURI&lt;/code&gt; of a node, or used as the &lt;em&gt;namespaceURI&lt;/em&gt; parameter to a namespaces-specific method.</source>
          <target state="translated">用于指示没有名称空间与DOM中的节点关联的值。通常将其作为节点的 &lt;code&gt;namespaceURI&lt;/code&gt; 或用作特定于命名空间的方法的&lt;em&gt;namespaceURI&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="64a84954e88a246f210c2cf21b6b1dd5abec1148" translate="yes" xml:space="preserve">
          <source>The values are chosen by &lt;code&gt;_generate_next_value_()&lt;/code&gt;, which can be overridden:</source>
          <target state="translated">这些值由 &lt;code&gt;_generate_next_value_()&lt;/code&gt; 选择，可以覆盖：</target>
        </trans-unit>
        <trans-unit id="9db8f1c845539b8dab56c95400b090e5768cb33d" translate="yes" xml:space="preserve">
          <source>The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then &lt;em&gt;literal_text&lt;/em&gt; will be a zero-length string. If there is no replacement field, then the values of &lt;em&gt;field_name&lt;/em&gt;, &lt;em&gt;format_spec&lt;/em&gt; and &lt;em&gt;conversion&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">元组中的值在概念上表示文字文本的范围，后跟单个替换字段。如果没有文字文本（如果连续出现两个替换字段，则可能会发生），那么&lt;em&gt;literal_text&lt;/em&gt;将是长度为零的字符串。如果没有替换字段，则&lt;em&gt;field_name&lt;/em&gt;，&lt;em&gt;format_spec&lt;/em&gt;和&lt;em&gt;conversion&lt;/em&gt;的值将为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d52d8d3fc67f68d8f2426d8c8de4306ccc1f8e09" translate="yes" xml:space="preserve">
          <source>The values of the first two fields are constants defined in the &lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt;&lt;code&gt;xml.parsers.expat.model&lt;/code&gt;&lt;/a&gt; module. These constants can be collected in two groups: the model type group and the quantifier group.</source>
          <target state="translated">前两个字段的值是在&lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt; &lt;code&gt;xml.parsers.expat.model&lt;/code&gt; &lt;/a&gt;模块中定义的常量。这些常量可以分为两组：模型类型组和量词组。</target>
        </trans-unit>
        <trans-unit id="5e1cd2108af5c3d292a414e185f45717815413a4" translate="yes" xml:space="preserve">
          <source>The variables below define the flags used in the &lt;a href=&quot;#stat.ST_MODE&quot;&gt;&lt;code&gt;ST_MODE&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">下面的变量定义了&lt;a href=&quot;#stat.ST_MODE&quot;&gt; &lt;code&gt;ST_MODE&lt;/code&gt; &lt;/a&gt;字段中使用的标志。</target>
        </trans-unit>
        <trans-unit id="570a00c886bbaa011554650d24fe55f6f0971a79" translate="yes" xml:space="preserve">
          <source>The variables defined in the &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module are:</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt;模块中定义的变量是：</target>
        </trans-unit>
        <trans-unit id="ee64058d781eef751c586d91741d6ad13c91889d" translate="yes" xml:space="preserve">
          <source>The variants which include a &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">在末尾包含&amp;ldquo; p&amp;rdquo;的变体（&lt;a href=&quot;#os.execlp&quot;&gt; &lt;code&gt;execlp()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.execlpe&quot;&gt; &lt;code&gt;execlpe()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.execvp&quot;&gt; &lt;code&gt;execvp()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#os.execvpe&quot;&gt; &lt;code&gt;execvpe()&lt;/code&gt; &lt;/a&gt;）将使用 &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; 环境变量来定位程序&lt;em&gt;文件&lt;/em&gt;。当替换环境时（使用&lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*e&lt;/code&gt; &lt;/a&gt;变体之一，将在下一段中讨论），新环境将用作 &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; 变量的源。其他变体&lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;execl()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.execle&quot;&gt; &lt;code&gt;execle()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt;不会使用 &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; 变量来定位可执行文件。&lt;em&gt;路径&lt;/em&gt; 必须包含适当的绝对或相对路径。</target>
        </trans-unit>
        <trans-unit id="055f633c5b8ba910989ddc0879461a87b09eb587" translate="yes" xml:space="preserve">
          <source>The variants which include a &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-29&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-30&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9193f1ef76fbd673e45f1225a537e38ac8bf4170" translate="yes" xml:space="preserve">
          <source>The variants which include a second &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">在末尾包含第二个&amp;ldquo; p&amp;rdquo;的变体（&lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.spawnlpe&quot;&gt; &lt;code&gt;spawnlpe()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.spawnvp&quot;&gt; &lt;code&gt;spawnvp()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt;）将使用 &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; 环境变量来定位程序&lt;em&gt;文件&lt;/em&gt;。当替换环境时（使用下一个讨论的&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*e&lt;/code&gt; &lt;/a&gt;变体之一），新环境将用作 &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; 变量的源。其他变体&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawnl()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.spawnle&quot;&gt; &lt;code&gt;spawnle()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#os.spawnv&quot;&gt; &lt;code&gt;spawnv()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#os.spawnve&quot;&gt; &lt;code&gt;spawnve()&lt;/code&gt; &lt;/a&gt;不会使用 &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; 变量来定位可执行文件。&lt;em&gt;路径&lt;/em&gt; 必须包含适当的绝对或相对路径。</target>
        </trans-unit>
        <trans-unit id="6d6d9fa3e86467cc65004fa718f6f51be22a4063" translate="yes" xml:space="preserve">
          <source>The variants which include a second &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-35&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-36&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f460136362370229598b52a9bcbe0209c61fd006" translate="yes" xml:space="preserve">
          <source>The various &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; functions take a list of arguments for the new program loaded into the process. In each case, the first of these arguments is passed to the new program as its own name rather than as an argument a user may have typed on a command line. For the C programmer, this is the &lt;code&gt;argv[0]&lt;/code&gt; passed to a program&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt;. For example, &lt;code&gt;os.execv('/bin/echo',
['foo', 'bar'])&lt;/code&gt; will only print &lt;code&gt;bar&lt;/code&gt; on standard output; &lt;code&gt;foo&lt;/code&gt; will seem to be ignored.</source>
          <target state="translated">各种&lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt;函数采用加载到进程中的新程序的参数列表。在每种情况下，这些参数中的第一个作为其自己的名称传递给新程序，而不是作为用户可能在命令行上键入的参数传递给新程序。对于C程序员，这是传递给程序的 &lt;code&gt;main()&lt;/code&gt; 的 &lt;code&gt;argv[0]&lt;/code&gt; 。例如， &lt;code&gt;os.execv('/bin/echo', ['foo', 'bar'])&lt;/code&gt; 将仅在标准输出上打印 &lt;code&gt;bar&lt;/code&gt; ； &lt;code&gt;foo&lt;/code&gt; 似乎将被忽略。</target>
        </trans-unit>
        <trans-unit id="39516d842ad2ebf0ccc0148be3b60ceb8e23f56b" translate="yes" xml:space="preserve">
          <source>The various named parameters found in &lt;em&gt;Set-Cookie&lt;/em&gt; and &lt;em&gt;Set-Cookie2&lt;/em&gt; headers (eg. &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;expires&lt;/code&gt;) are conventionally referred to as &lt;em&gt;attributes&lt;/em&gt;. To distinguish them from Python attributes, the documentation for this module uses the term &lt;em&gt;cookie-attribute&lt;/em&gt; instead.</source>
          <target state="translated">在&lt;em&gt;Set-Cookie&lt;/em&gt;和&lt;em&gt;Set-Cookie2&lt;/em&gt;标头中找到的各种命名参数（例如 &lt;code&gt;domain&lt;/code&gt; 和 &lt;code&gt;expires&lt;/code&gt; ）通常称为&lt;em&gt;属性&lt;/em&gt;。为了将它们与Python属性区分开，该模块的文档改用了&lt;em&gt;cookie属性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a9102cf75be9fce05b52770c18e9074f93ffc76b" translate="yes" xml:space="preserve">
          <source>The version number as a string, with any whitespace and/or comments removed.</source>
          <target state="translated">版本号为字符串,去掉任何空格和/或注释。</target>
        </trans-unit>
        <trans-unit id="609eb97fd5216df593e456b08820fbdecce59af0" translate="yes" xml:space="preserve">
          <source>The version number encoded as a single integer. This is guaranteed to increase with each version, including proper support for non-production releases. For example, to test that the Python interpreter is at least version 1.5.2, use:</source>
          <target state="translated">编码为单整数的版本号。这个版本号保证随着版本的增加而增加,包括对非生产版本的适当支持。例如,要测试Python解释器是否至少是1.5.2版本,请使用。</target>
        </trans-unit>
        <trans-unit id="d8b4cf55cc9ba4af98dcfd2188bb39d0808a2000" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a string.</source>
          <target state="translated">运行时SQLite库的版本号,为字符串。</target>
        </trans-unit>
        <trans-unit id="83cfbef62783b9adbc5d82cbd03374d9ffac04a3" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a tuple of integers.</source>
          <target state="translated">运行时SQLite库的版本号,为整数元组。</target>
        </trans-unit>
        <trans-unit id="82ad32d0ec3913612c3c798f838cb1d4b90e0ca4" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a string. This is not the version of the SQLite library.</source>
          <target state="translated">这个模块的版本号,是一个字符串。这不是SQLite库的版本。</target>
        </trans-unit>
        <trans-unit id="b2bf9e254a8f2ed1bc7d1d04b5316dcc3367de2d" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a tuple of integers. This is not the version of the SQLite library.</source>
          <target state="translated">这个模块的版本号,是一个整数元组。这不是SQLite库的版本。</target>
        </trans-unit>
        <trans-unit id="6e547ed29557b93784e133bf96efb332e811697d" translate="yes" xml:space="preserve">
          <source>The version number used to form registry keys on Windows platforms. This is stored as string resource 1000 in the Python DLL. The value is normally the first three characters of &lt;a href=&quot;#sys.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt;. It is provided in the &lt;a href=&quot;#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; module for informational purposes; modifying this value has no effect on the registry keys used by Python.</source>
          <target state="translated">Windows平台上用于形成注册表项的版本号。这作为字符串资源1000存储在Python DLL中。该值通常是&lt;a href=&quot;#sys.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt;的前三个字符。&lt;a href=&quot;#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt;模块中提供了此信息，仅供参考；修改此值不会影响Python使用的注册表项。</target>
        </trans-unit>
        <trans-unit id="fd9dddc1a822657d560f74f81863263cdf639a3e" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt;&lt;code&gt;BUILD_MAP&lt;/code&gt;&lt;/a&gt; specialized for constant keys. &lt;em&gt;count&lt;/em&gt; values are consumed from the stack. The top element on the stack contains a tuple of keys.</source>
          <target state="translated">&lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt; &lt;code&gt;BUILD_MAP&lt;/code&gt; &lt;/a&gt;的版本专用于常数键。&lt;em&gt;计&lt;/em&gt;数值从堆栈中消耗。堆栈顶部的元素包含一个键元组。</target>
        </trans-unit>
        <trans-unit id="7e5971513ba2095f033e5bb93d0a5852c2eeb055" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt;&lt;code&gt;BUILD_MAP&lt;/code&gt;&lt;/a&gt; specialized for constant keys. Pops the top element on the stack which contains a tuple of keys, then starting from &lt;code&gt;TOS1&lt;/code&gt;, pops &lt;em&gt;count&lt;/em&gt; values to form values in the built dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb4e85c9ec212eecd8d18482a8624ea4b9d922a" translate="yes" xml:space="preserve">
          <source>The version of the Unicode database used in this module.</source>
          <target state="translated">本模块中使用的Unicode数据库的版本。</target>
        </trans-unit>
        <trans-unit id="056761a5a01ae0e3f3f5bb2776ef234db9b6782e" translate="yes" xml:space="preserve">
          <source>The version string of the OpenSSL library loaded by the interpreter:</source>
          <target state="translated">解释器加载的OpenSSL库的版本字符串。</target>
        </trans-unit>
        <trans-unit id="68f2bb2ab063964d03cb7301ec9bedfef871e189" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library actually loaded by the interpreter.</source>
          <target state="translated">解释器实际加载的zlib库的版本字符串。</target>
        </trans-unit>
        <trans-unit id="66895485e5b6e2239606f9c0e8f020dc482fd6aa" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library that was used for building the module. This may be different from the zlib library actually used at runtime, which is available as &lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt;&lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于构建模块的zlib库的版本字符串。这可能与运行时实际使用的zlib库有所不同，该库可以作为&lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt; &lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt; 使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a928dd1d5b35bf2574f665823c8388fc665c61e" translate="yes" xml:space="preserve">
          <source>The virtual screen may be updated by a &lt;a href=&quot;#curses.window.noutrefresh&quot;&gt;&lt;code&gt;noutrefresh()&lt;/code&gt;&lt;/a&gt; call after write operations such as &lt;a href=&quot;#curses.window.addstr&quot;&gt;&lt;code&gt;addstr()&lt;/code&gt;&lt;/a&gt; have been performed on a window. The normal &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; call is simply &lt;code&gt;noutrefresh()&lt;/code&gt; followed by &lt;code&gt;doupdate()&lt;/code&gt;; if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing &lt;code&gt;noutrefresh()&lt;/code&gt; calls on all windows, followed by a single &lt;code&gt;doupdate()&lt;/code&gt;.</source>
          <target state="translated">在窗口上执行了诸如&lt;a href=&quot;#curses.window.addstr&quot;&gt; &lt;code&gt;addstr()&lt;/code&gt; 之&lt;/a&gt;类的写操作之后，可以通过&lt;a href=&quot;#curses.window.noutrefresh&quot;&gt; &lt;code&gt;noutrefresh()&lt;/code&gt; &lt;/a&gt;调用来更新虚拟屏幕。正常的&lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt;调用只是 &lt;code&gt;noutrefresh()&lt;/code&gt; ,然后是 &lt;code&gt;doupdate()&lt;/code&gt; ；如果必须更新多个窗口，则可以通过在所有窗口上发出 &lt;code&gt;noutrefresh()&lt;/code&gt; 调用，然后执行单个 &lt;code&gt;doupdate()&lt;/code&gt; 来提高性能，并可能减少屏幕闪烁。</target>
        </trans-unit>
        <trans-unit id="fe10e8128cec2a8b853d046a9f0502bfff7b4b2b" translate="yes" xml:space="preserve">
          <source>The warnings filter controls whether warnings are ignored, displayed, or turned into errors (raising an exception).</source>
          <target state="translated">警告过滤器控制警告是被忽略、显示还是变成错误(引发异常)。</target>
        </trans-unit>
        <trans-unit id="81d6c008939066a9c786b974f1a35df744af57e8" translate="yes" xml:space="preserve">
          <source>The warnings filter is initialized by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; options passed to the Python interpreter command line and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable. The interpreter saves the arguments for all supplied entries without interpretation in &lt;a href=&quot;sys#sys.warnoptions&quot;&gt;&lt;code&gt;sys.warnoptions&lt;/code&gt;&lt;/a&gt;; the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module parses these when it is first imported (invalid options are ignored, after printing a message to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">警告过滤器由传递给Python解释器命令行的&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt;选项和&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; &lt;/a&gt;环境变量初始化。解释器将为所有提供的条目保存参数，而不在&lt;a href=&quot;sys#sys.warnoptions&quot;&gt; &lt;code&gt;sys.warnoptions&lt;/code&gt; 中&lt;/a&gt;进行解释；该&lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt;模块解析这些当第一进口（无效选项将被忽略，打印的消息后&lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="68eed415d9086a5dea30cb8df62a2a15e9f46d08" translate="yes" xml:space="preserve">
          <source>The warnings filter is initialized by &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; options passed to the Python interpreter command line and the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable. The interpreter saves the arguments for all supplied entries without interpretation in &lt;a href=&quot;sys#sys.warnoptions&quot;&gt;&lt;code&gt;sys.warnoptions&lt;/code&gt;&lt;/a&gt;; the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module parses these when it is first imported (invalid options are ignored, after printing a message to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2742895327f8f1c5d2fcfda5a226fa7f537c878" translate="yes" xml:space="preserve">
          <source>The watcher avoids disrupting other code spawning processes by polling every process explicitly on a &lt;code&gt;SIGCHLD&lt;/code&gt; signal.</source>
          <target state="translated">监视程序通过在 &lt;code&gt;SIGCHLD&lt;/code&gt; 信号上显式轮询每个进程来避免破坏其他代码生成进程。</target>
        </trans-unit>
        <trans-unit id="10a8f59f5f02b63085e6b7ff709cd3f0f1ce5558" translate="yes" xml:space="preserve">
          <source>The way &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; are recorded means that where nested calls are made, the parameters of ancestor calls are not recorded and so will always compare equal:</source>
          <target state="translated">记录&lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt;调用的方式意味着在进行嵌套调用的地方，祖先调用的参数不会被记录，因此总是比较相等：</target>
        </trans-unit>
        <trans-unit id="07fd27b7e683afd9d6a2777d2e2bc0e02e57826f" translate="yes" xml:space="preserve">
          <source>The widget state is a bitmap of independent state flags.</source>
          <target state="translated">小组件状态是一个独立状态标志的位图。</target>
        </trans-unit>
        <trans-unit id="ad9e57f84a79be5923c4fad7f02f67bfce0d0138" translate="yes" xml:space="preserve">
          <source>The widget&amp;rsquo;s value is invalid</source>
          <target state="translated">窗口小部件的值无效</target>
        </trans-unit>
        <trans-unit id="7a5decf7ad4f9356a33597c56799bfaaba97e9ea" translate="yes" xml:space="preserve">
          <source>The width of the column in pixels.</source>
          <target state="translated">列的宽度,单位为像素。</target>
        </trans-unit>
        <trans-unit id="4be2057a0cedbaf57fa943fdd00e63d3ccac6ee5" translate="yes" xml:space="preserve">
          <source>The wrapped function is instrumented with a &lt;code&gt;cache_parameters()&lt;/code&gt; function that returns a new &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; showing the values for &lt;em&gt;maxsize&lt;/em&gt; and &lt;em&gt;typed&lt;/em&gt;. This is for information purposes only. Mutating the values has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13a55fc25371355d16c8ccfbb2ea8fb626f5b8b" translate="yes" xml:space="preserve">
          <source>The zero-based Julian day (0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). Leap days are counted, and it is possible to refer to February 29.</source>
          <target state="translated">从零开始的儒略日（0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365）。日被计算在内，可以参考2月29日。</target>
        </trans-unit>
        <trans-unit id="38a94f537c497bc41758e7de7dc18b5dc9e5aa4b" translate="yes" xml:space="preserve">
          <source>The zip file format allows arbitrary data to be prepended to a zip file. The zip application format uses this ability to prepend a standard POSIX &amp;ldquo;shebang&amp;rdquo; line to the file (&lt;code&gt;#!/path/to/interpreter&lt;/code&gt;).</source>
          <target state="translated">zip文件格式允许将任意数据放在zip文件之前。zip应用程序格式使用此功能将标准POSIX&amp;ldquo; shebang&amp;rdquo;行添加到文件（ &lt;code&gt;#!/path/to/interpreter&lt;/code&gt; ）之前。</target>
        </trans-unit>
        <trans-unit id="5e0f5450f31911228fbdcb1860dad56d3814c81e" translate="yes" xml:space="preserve">
          <source>The zlib library home page.</source>
          <target state="translated">zlib库的主页。</target>
        </trans-unit>
        <trans-unit id="8affd2d9f0cad819c09a176405cd6b5206cef756" translate="yes" xml:space="preserve">
          <source>The zlib manual explains the semantics and usage of the library&amp;rsquo;s many functions.</source>
          <target state="translated">zlib手册解释了库的许多功能的语义和用法。</target>
        </trans-unit>
        <trans-unit id="190b6a003d5b9ea453b301c3e6ce588721c176be" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; gets a chance. If it accepts &lt;code&gt;a&lt;/code&gt;, all is well.</source>
          <target state="translated">然后 &lt;code&gt;B&lt;/code&gt; 的&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt;得到了机会。如果它接受 &lt;code&gt;a&lt;/code&gt; ，一切都很好。</target>
        </trans-unit>
        <trans-unit id="9f1e41ec37276bd4db3f77340d349801df4b385c" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; gets a chance. If it accepts &lt;code&gt;a&lt;/code&gt;, all is well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f3cfe2af54d2f5c805181fe58a7558eae8452c" translate="yes" xml:space="preserve">
          <source>Then an interactive Python session may look like this:</source>
          <target state="translated">那么一个交互式的 Python 会话可能是这样的。</target>
        </trans-unit>
        <trans-unit id="c575aa8053687837f8a56e8486b23babe4c92cdd" translate="yes" xml:space="preserve">
          <source>Then follows a blank line signifying the end of the headers, and then the contents of the file are output. If the file&amp;rsquo;s MIME type starts with &lt;code&gt;text/&lt;/code&gt; the file is opened in text mode; otherwise binary mode is used.</source>
          <target state="translated">然后跟随一个空白行，表示标题的末尾，然后输出文件的内容。如果文件的MIME类型以 &lt;code&gt;text/&lt;/code&gt; 开头/则以文本模式打开文件；否则使用二进制模式。</target>
        </trans-unit>
        <trans-unit id="e0f553f569d6ec90354bbb3b909858d32b9e9096" translate="yes" xml:space="preserve">
          <source>Then the following version-specific directories are added to &lt;code&gt;sys.path&lt;/code&gt;, in this order:</source>
          <target state="translated">然后，将以下特定于版本的目录按此顺序添加到 &lt;code&gt;sys.path&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="82f978014fab5239e5ba8297d9634d6b6d533b89" translate="yes" xml:space="preserve">
          <source>Then use &lt;em&gt;code&lt;/em&gt; as the encoding for &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">然后使用&lt;em&gt;代码&lt;/em&gt;作为&lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt;调用的编码。</target>
        </trans-unit>
        <trans-unit id="9e9915c4a4ddc41d5c5b32ca75771fe219177f58" translate="yes" xml:space="preserve">
          <source>Then when you inherit from &lt;code&gt;AutoNumber&lt;/code&gt; you can write your own &lt;code&gt;__init__&lt;/code&gt; to handle any extra arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5799d48128610654dfc6147c53f4b2206c78fb2" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll read data from the &lt;code&gt;connstream&lt;/code&gt; and do something with it till you are finished with the client (or the client is finished with you):</source>
          <target state="translated">然后，您将从 &lt;code&gt;connstream&lt;/code&gt; 中读取数据并对其进行处理，直到完成客户端工作（或客户端完成工作）为止：</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="5b1e898fc07d61e53c63f3002ef704c95490010b" translate="yes" xml:space="preserve">
          <source>Theory</source>
          <target state="translated">Theory</target>
        </trans-unit>
        <trans-unit id="7fa259f892d2f161a72fca4bf8158be9adf1787b" translate="yes" xml:space="preserve">
          <source>There are 5 different cases for a mixed-type operation on subclasses of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt;. I&amp;rsquo;ll refer to all of the above code that doesn&amp;rsquo;t refer to &lt;code&gt;MyIntegral&lt;/code&gt; and &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; as &amp;ldquo;boilerplate&amp;rdquo;. &lt;code&gt;a&lt;/code&gt; will be an instance of &lt;code&gt;A&lt;/code&gt;, which is a subtype of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt;), and &lt;code&gt;b : B &amp;lt;:
Complex&lt;/code&gt;. I&amp;rsquo;ll consider &lt;code&gt;a + b&lt;/code&gt;:</source>
          <target state="translated">对&lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; 的&lt;/a&gt;子类进行混合类型操作有5种不同的情况。我将把以上所有未引用 &lt;code&gt;MyIntegral&lt;/code&gt; 和 &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; 的代码称为&amp;ldquo;样板&amp;rdquo;。 &lt;code&gt;a&lt;/code&gt; 将是 &lt;code&gt;A&lt;/code&gt; 的实例，它是&lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt; ）和 &lt;code&gt;b : B &amp;lt;: Complex&lt;/code&gt; 。我会考虑 &lt;code&gt;a + b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3f8916b69856c2223ef6abca8e6fa0e94754e630" translate="yes" xml:space="preserve">
          <source>There are a couple of useful utilities provided in the &lt;a href=&quot;#module-email.utils&quot;&gt;&lt;code&gt;email.utils&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-email.utils&quot;&gt; &lt;code&gt;email.utils&lt;/code&gt; &lt;/a&gt;模块中提供了几个有用的实用程序：</target>
        </trans-unit>
        <trans-unit id="db73f983c1ef412f0f0bf991d5c7b1526f785874" translate="yes" xml:space="preserve">
          <source>There are a few different ways of resolving this problem. The easiest, but not necessarily the least annoying, way is to simply set the required attributes on the mock after creation. Just because &lt;em&gt;autospec&lt;/em&gt; doesn&amp;rsquo;t allow you to fetch attributes that don&amp;rsquo;t exist on the spec it doesn&amp;rsquo;t prevent you setting them:</source>
          <target state="translated">有几种解决此问题的方法。最简单但不一定最烦人的方法是在创建模拟后简单地设置所需属性。仅仅因为&lt;em&gt;autospec&lt;/em&gt;不允许您获取规范中不存在的属性，它并不能阻止您设置它们：</target>
        </trans-unit>
        <trans-unit id="d3aeadae92ca7f5170f43648b0bf091b7291fb4d" translate="yes" xml:space="preserve">
          <source>There are a few extra restriction which don&amp;rsquo;t apply to the &lt;em&gt;fork&lt;/em&gt; start method.</source>
          <target state="translated">有一些额外的限制不适用于&lt;em&gt;fork&lt;/em&gt;启动方法。</target>
        </trans-unit>
        <trans-unit id="d38135d96a58a5ba6397af560568ea76e6c5aa3e" translate="yes" xml:space="preserve">
          <source>There are a few things to note about this module which are important to making use of the data structures created. This is not a tutorial on editing the parse trees for Python code, but some examples of using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module are presented.</source>
          <target state="translated">关于此模块，需要注意一些事项，这些事项对于使用创建的数据结构非常重要。这不是关于为Python代码编辑解析树的教程，而是提供了一些使用&lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt;模块的示例。</target>
        </trans-unit>
        <trans-unit id="6a6fd0b5587b688c222bcb3323758db69747ea41" translate="yes" xml:space="preserve">
          <source>There are a few tools to extract the strings meant for translation. The original GNU &lt;strong&gt;gettext&lt;/strong&gt; only supported C or C++ source code but its extended version &lt;strong&gt;xgettext&lt;/strong&gt; scans code written in a number of languages, including Python, to find strings marked as translatable. &lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt; is a Python internationalization library that includes a &lt;code&gt;pybabel&lt;/code&gt; script to extract and compile message catalogs. Fran&amp;ccedil;ois Pinard&amp;rsquo;s program called &lt;strong&gt;xpot&lt;/strong&gt; does a similar job and is available as part of his &lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;po-utils package&lt;/a&gt;.</source>
          <target state="translated">有一些工具可以提取要翻译的字符串。原始的GNU &lt;strong&gt;gettext&lt;/strong&gt;仅支持C或C ++源代码，但其扩展版本&lt;strong&gt;xgettext会&lt;/strong&gt;扫描以多种语言（包括Python）编写的代码，以查找标记为可翻译的字符串。&lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt;是一个Python国际化库，其中包含 &lt;code&gt;pybabel&lt;/code&gt; 脚本以提取和编译消息目录。弗朗索瓦&amp;middot;皮纳得的程序调用&lt;strong&gt;XPOT&lt;/strong&gt;做类似的工作，可作为他的一部分，&lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;PO-utils软件包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26f97faaa25467594fb9160eb8740b560db6b4f9" translate="yes" xml:space="preserve">
          <source>There are a few utility functions for framework authors to enable control-c handling functionality within test frameworks.</source>
          <target state="translated">对于框架作者来说,有一些实用功能可以在测试框架中实现控制-c处理功能。</target>
        </trans-unit>
        <trans-unit id="c0bb7e25ceb0ffba66ad1c049f198424ce2c3808" translate="yes" xml:space="preserve">
          <source>There are a number of built-in exceptions that represent warning categories. This categorization is useful to be able to filter out groups of warnings.</source>
          <target state="translated">有一些内置的异常代表了警告类别。这种分类对于能够过滤出警告组很有用。</target>
        </trans-unit>
        <trans-unit id="ab4deb2b4c65697178a9e91e651f82ce32bff537" translate="yes" xml:space="preserve">
          <source>There are a number of other caveats:</source>
          <target state="translated">还有其他一些注意事项。</target>
        </trans-unit>
        <trans-unit id="740a6e1a370e644b8acad66b626c4251477d08b6" translate="yes" xml:space="preserve">
          <source>There are a number of uses for the &lt;em&gt;func&lt;/em&gt; argument. It can be set to &lt;a href=&quot;functions#min&quot;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt; for a running minimum, &lt;a href=&quot;functions#max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; for a running maximum, or &lt;a href=&quot;operator#operator.mul&quot;&gt;&lt;code&gt;operator.mul()&lt;/code&gt;&lt;/a&gt; for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;recurrence relations&lt;/a&gt; can be modeled by supplying the initial value in the iterable and using only the accumulated total in &lt;em&gt;func&lt;/em&gt; argument:</source>
          <target state="translated">&lt;em&gt;func&lt;/em&gt;参数有许多用途。对于运行中的最小值，可以将其设置为&lt;a href=&quot;functions#min&quot;&gt; &lt;code&gt;min()&lt;/code&gt; ;&lt;/a&gt;对于运行中的最大值，可以将其设置为&lt;a href=&quot;functions#max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt;；对于运行中的产品，可以将其设置为&lt;a href=&quot;operator#operator.mul&quot;&gt; &lt;code&gt;operator.mul()&lt;/code&gt; &lt;/a&gt;。可以通过累计利息和应用付款来建立摊销表。一阶&lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;递归关系&lt;/a&gt;可以通过提供可迭代的初始值并仅使用&lt;em&gt;func&lt;/em&gt;参数中的累加总数来建模：</target>
        </trans-unit>
        <trans-unit id="6d2c1754d16fc36acf6343a01e5a606d44c91330" translate="yes" xml:space="preserve">
          <source>There are actually two parser interfaces available for use, the &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API and the incremental &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; API. The &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API is most useful if you have the entire text of the message in memory, or if the entire message lives in a file on the file system. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; is more appropriate when you are reading the message from a stream which might block waiting for more input (such as reading an email message from a socket). The &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; can consume and parse the message incrementally, and only returns the root object when you close the parser.</source>
          <target state="translated">实际上，有两个解析器接口可供使用：&lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; API和增量&lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; API。该&lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt;如果有消息的整个文本在内存API是最有用的，或者整个消息生活在文件系统上的文件。当您从流中读取消息（可能会阻止等待更多输入）（例如，从套接字读取电子邮件）时，&lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt;更合适。该&lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt;可以消耗并逐步解析消息，只有当你关闭分析器返回根对象。</target>
        </trans-unit>
        <trans-unit id="039266eeef2dff97e5e5130bed399d4f0600c2da" translate="yes" xml:space="preserve">
          <source>There are all kinds of additional metadata available on the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">&lt;code&gt;Distribution&lt;/code&gt; 实例上还有各种其他可用的元数据：</target>
        </trans-unit>
        <trans-unit id="ddebb36a5d0bbfeddcd3da60a21d96401142db63" translate="yes" xml:space="preserve">
          <source>There are also experimental methods that give this class more mapping behavior. You can use them or you can use the standardized &lt;code&gt;getAttribute*()&lt;/code&gt; family of methods on the &lt;code&gt;Element&lt;/code&gt; objects.</source>
          <target state="translated">也有实验方法使此类具有更多映射行为。您可以使用它们，也可以对 &lt;code&gt;Element&lt;/code&gt; 对象使用标准化的 &lt;code&gt;getAttribute*()&lt;/code&gt; 方法族。</target>
        </trans-unit>
        <trans-unit id="1bc97db34ca865c4f6e13f984f32b85cf0430a9c" translate="yes" xml:space="preserve">
          <source>There are also other methods used to perform more specific checks, such as:</source>
          <target state="translated">还有其他方法用于执行更具体的检查,例如:</target>
        </trans-unit>
        <trans-unit id="dd66bff89abb178647e31e8d7b36f2b277e325f3" translate="yes" xml:space="preserve">
          <source>There are also several readonly attributes available:</source>
          <target state="translated">还有几种可读属性。</target>
        </trans-unit>
        <trans-unit id="4dbe98b62c6ac402e4adf807336479d380787150" translate="yes" xml:space="preserve">
          <source>There are also specific options for tabs:</source>
          <target state="translated">标签也有特定的选项。</target>
        </trans-unit>
        <trans-unit id="64b4683225cbfb5d8247369d9cbda217bda79fc7" translate="yes" xml:space="preserve">
          <source>There are also variants of these methods that simply return a string instead of printing it:</source>
          <target state="translated">这些方法还有一些变体,只是返回一个字符串而不是打印它。</target>
        </trans-unit>
        <trans-unit id="c959f4df3c12c67509677745222747e6ef2cf83a" translate="yes" xml:space="preserve">
          <source>There are cases, however, when applications need to use prefixes in character data or in attribute values, where they cannot safely be expanded automatically; the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events supply the information to the application to expand prefixes in those contexts itself, if necessary.</source>
          <target state="translated">但是，在某些情况下，当应用程序需要在字符数据或属性值中使用前缀时，无法安全地自动扩展它们；在&lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt;事件提供的信息，应用程序扩展前缀在这些上下文本身，如果需要的话。</target>
        </trans-unit>
        <trans-unit id="8ba631db31ee48915b3b121db2e36c181d8ccc00" translate="yes" xml:space="preserve">
          <source>There are certain guidelines and idioms which should be adhered to when using &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt;时，应遵循某些准则和习惯用法。</target>
        </trans-unit>
        <trans-unit id="827dd66505bcf022799f1772f83bac7872cd90a3" translate="yes" xml:space="preserve">
          <source>There are currently 6 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced.</source>
          <target state="translated">目前有6种不同的协议可以用于pickling。使用的协议越高,读取生成的pickle所需的Python版本越新。</target>
        </trans-unit>
        <trans-unit id="ead616e7256dcb5719abe40d028e6090d64aa306" translate="yes" xml:space="preserve">
          <source>There are currently two built-in set types, &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; type is mutable &amp;mdash; the contents can be changed using methods like &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt;. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; type is immutable and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; &amp;mdash; its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</source>
          <target state="translated">当前有两种内置的set类型，&lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt;类型是可变的-内容可使用类似的方法来改变 &lt;code&gt;add()&lt;/code&gt; 和 &lt;code&gt;remove()&lt;/code&gt; 由于它是可变的，因此它没有哈希值，因此不能用作字典键或另一个集合的元素。该&lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt;类型是不可改变的，&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;可哈希&lt;/a&gt; -它被创建后其内容不能被改变;因此，它可以用作字典键或用作另一个集合的元素。</target>
        </trans-unit>
        <trans-unit id="25dd1db02d57c5f3fcb570b27f1ec4c898afb3f1" translate="yes" xml:space="preserve">
          <source>There are currently two built-in set types, &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; type is mutable &amp;mdash; the contents can be changed using methods like &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt;. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; type is immutable and &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; &amp;mdash; its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e48ec5af476b663fb0695c8e11aa6c35b465db" translate="yes" xml:space="preserve">
          <source>There are default adapters for the date and datetime types in the datetime module. They will be sent as ISO dates/ISO timestamps to SQLite.</source>
          <target state="translated">在datetime模块中,日期和日期时间类型有默认的适配器。它们将作为ISO日期/ISO时间戳发送到SQLite。</target>
        </trans-unit>
        <trans-unit id="c9f000a68af366a9a5eefed22b9b119e2b234e96" translate="yes" xml:space="preserve">
          <source>There are eight built-in, named bitmaps: &lt;code&gt;'error'&lt;/code&gt;, &lt;code&gt;'gray25'&lt;/code&gt;, &lt;code&gt;'gray50'&lt;/code&gt;, &lt;code&gt;'hourglass'&lt;/code&gt;, &lt;code&gt;'info'&lt;/code&gt;, &lt;code&gt;'questhead'&lt;/code&gt;, &lt;code&gt;'question'&lt;/code&gt;, &lt;code&gt;'warning'&lt;/code&gt;. To specify an X bitmap filename, give the full path to the file, preceded with an &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt;.</source>
          <target state="translated">有八个内置的命名位图： &lt;code&gt;'error'&lt;/code&gt; ， &lt;code&gt;'gray25'&lt;/code&gt; ， &lt;code&gt;'gray50'&lt;/code&gt; ， &lt;code&gt;'hourglass'&lt;/code&gt; ， &lt;code&gt;'info'&lt;/code&gt; ， &lt;code&gt;'questhead'&lt;/code&gt; ， &lt;code&gt;'question'&lt;/code&gt; ， &lt;code&gt;'warning'&lt;/code&gt; 。要指定X位图文件名，请提供文件的完整路径，并以 &lt;code&gt;@&lt;/code&gt; 开头，如 &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdfda48041a9be25615bc1e181ea720f1ed03d01" translate="yes" xml:space="preserve">
          <source>There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; is equivalent to &lt;code&gt;x &amp;lt; y and
y &amp;lt;= z&lt;/code&gt;, except that &lt;em&gt;y&lt;/em&gt; is evaluated only once (but in both cases &lt;em&gt;z&lt;/em&gt; is not evaluated at all when &lt;code&gt;x &amp;lt; y&lt;/code&gt; is found to be false).</source>
          <target state="translated">Python中有八种比较操作。它们都具有相同的优先级（高于布尔运算的优先级）。比较可以任意链接；例如， &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; 等效于 &lt;code&gt;x &amp;lt; y and y &amp;lt;= z&lt;/code&gt; ，除了&lt;em&gt;y&lt;/em&gt;仅被评估一次（但是在两种情况下，当 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 被发现为假时，&lt;em&gt;z&lt;/em&gt;都不被评估）。</target>
        </trans-unit>
        <trans-unit id="6ba9237bbf2789014dc169fd8c3d198b4953c139" translate="yes" xml:space="preserve">
          <source>There are five classes in an inheritance diagram, four of which represent synchronous servers of four types:</source>
          <target state="translated">在继承图中有五个类,其中四个类代表四种类型的同步服务器。</target>
        </trans-unit>
        <trans-unit id="121f7346d52a69a5317d8485ce670ca978d629c2" translate="yes" xml:space="preserve">
          <source>There are four basic concrete server classes:</source>
          <target state="translated">有四个基本的混凝土服务器类。</target>
        </trans-unit>
        <trans-unit id="28d84994e74ad89bc8bd10dab4568463a23f06e4" translate="yes" xml:space="preserve">
          <source>There are four keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt;, &lt;em&gt;stack_info&lt;/em&gt;, &lt;em&gt;stacklevel&lt;/em&gt; and &lt;em&gt;extra&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;kwargs&lt;/em&gt;中检查了四个关键字参数：&lt;em&gt;exc_info&lt;/em&gt;，&lt;em&gt;stack_info&lt;/em&gt;，&lt;em&gt;stacklevel&lt;/em&gt;和&lt;em&gt;extra&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c8904775f6163564a009e440caf9e4700413f210" translate="yes" xml:space="preserve">
          <source>There are four main kinds of services provided by this module: type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.</source>
          <target state="translated">该模块提供的服务主要有四种:类型检查、获取源代码、检查类和函数、检查解释器栈。</target>
        </trans-unit>
        <trans-unit id="607a56c6d25a7712202e05cdfe56d0f4635a21c9" translate="yes" xml:space="preserve">
          <source>There are functions that read/write files as well as functions operating on bytes-like objects.</source>
          <target state="translated">有读/写文件的函数,也有操作类似字节对象的函数。</target>
        </trans-unit>
        <trans-unit id="3aa3669afb266251babb0404fcc0d929459102f0" translate="yes" xml:space="preserve">
          <source>There are fundamental differences between the pickle protocols and &lt;a href=&quot;http://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt;:</source>
          <target state="translated">pickle协议和&lt;a href=&quot;http://json.org&quot;&gt;JSON（JavaScript对象表示法）&lt;/a&gt;之间存在根本差异：</target>
        </trans-unit>
        <trans-unit id="eff3e0b7d4ac0260b5fcec0fd569b30b6694a180" translate="yes" xml:space="preserve">
          <source>There are many useful subclasses of Variable already defined: &lt;code&gt;StringVar&lt;/code&gt;, &lt;code&gt;IntVar&lt;/code&gt;, &lt;code&gt;DoubleVar&lt;/code&gt;, and &lt;code&gt;BooleanVar&lt;/code&gt;. To read the current value of such a variable, call the &lt;code&gt;get()&lt;/code&gt; method on it, and to change its value you call the &lt;code&gt;set()&lt;/code&gt; method. If you follow this protocol, the widget will always track the value of the variable, with no further intervention on your part.</source>
          <target state="translated">已经定义了许多有用的Variable子类： &lt;code&gt;StringVar&lt;/code&gt; ， &lt;code&gt;IntVar&lt;/code&gt; ， &lt;code&gt;DoubleVar&lt;/code&gt; 和 &lt;code&gt;BooleanVar&lt;/code&gt; 。要读取此类变量的当前值，请对其调用 &lt;code&gt;get()&lt;/code&gt; 方法，然后通过调用 &lt;code&gt;set()&lt;/code&gt; 方法来更改其值。如果您遵循此协议，则小部件将始终跟踪变量的值，而无需您进行任何干预。</target>
        </trans-unit>
        <trans-unit id="bf2f9d53cf6bf41d410d3108dd0294a79a931d55" translate="yes" xml:space="preserve">
          <source>There are nearly as many INI format variants as there are applications using it. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; goes a long way to provide support for the largest sensible set of INI styles available. The default functionality is mainly dictated by historical background and it&amp;rsquo;s very likely that you will want to customize some of the features.</source>
          <target state="translated">INI格式变体几乎与使用它的应用程序一样多。&lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt;在为最大的可用INI样式集提供支持方面做了大量工作。默认功能主要由历史背景决定，很可能您希望自定义某些功能。</target>
        </trans-unit>
        <trans-unit id="3265267da2983bf14017aa5df9e7283accfab3d4" translate="yes" xml:space="preserve">
          <source>There are only two ways to have a program on a single processor do &amp;ldquo;more than one thing at a time.&amp;rdquo; Multi-threaded programming is the simplest and most popular way to do it, but there is another very different technique, that lets you have nearly all the advantages of multi-threading, without actually using multiple threads. It&amp;rsquo;s really only practical if your program is largely I/O bound. If your program is processor bound, then pre-emptive scheduled threads are probably what you really need. Network servers are rarely processor bound, however.</source>
          <target state="translated">只有一种方法可以使程序在单个处理器上&amp;ldquo;一次完成一个以上的事情&amp;rdquo;。多线程编程是最简单，最流行的方法，但是还有另一种非常不同的技术，它使您几乎拥有多线程的所有优点，而无需实际使用多个线程。仅当您的程序很大程度上受I / O约束时，这才是切实可行的。如果您的程序受处理器限制，那么抢占式预定线程可能正是您真正需要的。但是，网络服务器很少受处理器限制。</target>
        </trans-unit>
        <trans-unit id="634f390469439c342320f71f9c406a991d40d6d4" translate="yes" xml:space="preserve">
          <source>There are others, but you get the idea.</source>
          <target state="translated">还有其他的,但你懂的。</target>
        </trans-unit>
        <trans-unit id="1134b66828043dd74bbedfe812d93fef9cb20d28" translate="yes" xml:space="preserve">
          <source>There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types.</source>
          <target state="translated">函数对象其实有两种味道:内置函数和用户自定义函数。两者都支持同样的操作(调用函数),但实现方式不同,因此对象类型不同。</target>
        </trans-unit>
        <trans-unit id="c6e44b629dc613ba239924b475b903b7f82838d4" translate="yes" xml:space="preserve">
          <source>There are several equivalent ways to specify IP network masks. A &lt;em&gt;prefix&lt;/em&gt;&lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; is a notation that denotes how many high-order bits are set in the network mask. A &lt;em&gt;net mask&lt;/em&gt; is an IP address with some number of high-order bits set. Thus the prefix &lt;code&gt;/24&lt;/code&gt; is equivalent to the net mask &lt;code&gt;255.255.255.0&lt;/code&gt; in IPv4, or &lt;code&gt;ffff:ff00::&lt;/code&gt; in IPv6. In addition, a &lt;em&gt;host mask&lt;/em&gt; is the logical inverse of a &lt;em&gt;net mask&lt;/em&gt;, and is sometimes used (for example in Cisco access control lists) to denote a network mask. The host mask equivalent to &lt;code&gt;/24&lt;/code&gt; in IPv4 is &lt;code&gt;0.0.0.255&lt;/code&gt;.</source>
          <target state="translated">有几种等效的方法可以指定IP网络掩码。甲&lt;em&gt;前缀&lt;/em&gt; &lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; 是一个符号，它表示许多高阶位是如何在网络掩码中设置。甲&lt;em&gt;网络掩码&lt;/em&gt;是一个IP地址与一些数量设置为高序位的。因此，前缀 &lt;code&gt;/24&lt;/code&gt; 等效于IPv4中的网络掩码 &lt;code&gt;255.255.255.0&lt;/code&gt; ，或IPv6中的 &lt;code&gt;ffff:ff00::&lt;/code&gt; 。另外，&lt;em&gt;主机掩码&lt;/em&gt;是&lt;em&gt;网络掩码&lt;/em&gt;的逻辑倒数，有时（例如在Cisco访问控制列表中）用于表示网络掩码。与IPv4中的 &lt;code&gt;/24&lt;/code&gt; 等效的主机掩码为 &lt;code&gt;0.0.0.255&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3033320704915eae39fe9125e77acd8933f72624" translate="yes" xml:space="preserve">
          <source>There are several ways to enable asyncio debug mode:</source>
          <target state="translated">有几种方法可以启用asyncio调试模式。</target>
        </trans-unit>
        <trans-unit id="dd3b8d5ccd917cf795ff7b17c62847945d840d34" translate="yes" xml:space="preserve">
          <source>There are several ways to load shared libraries into the Python process. One way is to instantiate one of the following classes:</source>
          <target state="translated">有几种方法可以将共享库加载到 Python 进程中。一种方法是实例化下面的一个类。</target>
        </trans-unit>
        <trans-unit id="3558a0588ae9ae9394f53aa612b4c8aa871ac418" translate="yes" xml:space="preserve">
          <source>There are some edges in &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; where you might expect something other than what actually happens.</source>
          <target state="translated">在&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; 中&lt;/a&gt;，您可能会期望一些实际发生的事情以外的其他事情。</target>
        </trans-unit>
        <trans-unit id="672b298f2b28f05dcbc4d251f921b55fca7bb3d1" translate="yes" xml:space="preserve">
          <source>There are some limitations to the process of bundling your application into a single file. In most, if not all, cases they can be addressed without needing major changes to your application.</source>
          <target state="translated">将您的应用程序捆绑成一个文件的过程有一些限制。在大多数情况下,即使不是全部,也可以在不需要对您的应用程序进行重大修改的情况下解决这些限制。</target>
        </trans-unit>
        <trans-unit id="f8efcbf8ecf4671c1e1fcda5c45fbcf4a0ffec20" translate="yes" xml:space="preserve">
          <source>There are some more variants of the tar format which can be read, but not created:</source>
          <target state="translated">还有一些焦油格式的变体,可以读取,但不能创建。</target>
        </trans-unit>
        <trans-unit id="14e72aad41ffed86193f1ed0cab701906fad72ac" translate="yes" xml:space="preserve">
          <source>There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator &lt;code&gt;%&lt;/code&gt; is applied to Decimal objects, the sign of the result is the sign of the &lt;em&gt;dividend&lt;/em&gt; rather than the sign of the divisor:</source>
          <target state="translated">小数对象的算术与整数和浮点数的算术之间存在一些细微差异。当余运算符 &lt;code&gt;%&lt;/code&gt; 被施加到小数对象时，结果的符号是的符号&lt;em&gt;被除数&lt;/em&gt;而不是除数的符号：</target>
        </trans-unit>
        <trans-unit id="b9b322cbdf6ae8c9c74fcf1ab35d16b9dd8646b3" translate="yes" xml:space="preserve">
          <source>There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of &lt;a href=&quot;#binaryseq&quot;&gt;binary data&lt;/a&gt; and &lt;a href=&quot;#textseq&quot;&gt;text strings&lt;/a&gt; are described in dedicated sections.</source>
          <target state="translated">共有三种基本序列类型：列表，元组和范围对象。在专用部分中介绍了为处理&lt;a href=&quot;#binaryseq&quot;&gt;二进制数据&lt;/a&gt;和&lt;a href=&quot;#textseq&quot;&gt;文本字符串&lt;/a&gt;而定制的其他序列类型。</target>
        </trans-unit>
        <trans-unit id="b817f8bcc6d4362e55e4611c3d0e8efda6956674" translate="yes" xml:space="preserve">
          <source>There are three different ways to call this function:</source>
          <target state="translated">有三种不同的方式来调用这个函数。</target>
        </trans-unit>
        <trans-unit id="1b0c875a78b7f62cbc06fe3fdf0cb3be83425f3f" translate="yes" xml:space="preserve">
          <source>There are three distinct numeric types: &lt;em&gt;integers&lt;/em&gt;, &lt;em&gt;floating point numbers&lt;/em&gt;, and &lt;em&gt;complex numbers&lt;/em&gt;. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using &lt;code&gt;double&lt;/code&gt; in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in &lt;a href=&quot;sys#sys.float_info&quot;&gt;&lt;code&gt;sys.float_info&lt;/code&gt;&lt;/a&gt;. Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number &lt;em&gt;z&lt;/em&gt;, use &lt;code&gt;z.real&lt;/code&gt; and &lt;code&gt;z.imag&lt;/code&gt;. (The standard library includes the additional numeric types &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt;, for rationals, and &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;, for floating-point numbers with user-definable precision.)</source>
          <target state="translated">共有三种不同的数字类型：&lt;em&gt;整数&lt;/em&gt;，&lt;em&gt;浮点数&lt;/em&gt;和&lt;em&gt;复数&lt;/em&gt;。另外，布尔值是整数的子类型。整数具有无限精度。浮点数通常使用C中的 &lt;code&gt;double&lt;/code&gt; 来实现；&lt;a href=&quot;sys#sys.float_info&quot;&gt; &lt;code&gt;sys.float_info&lt;/code&gt; 中&lt;/a&gt;提供了有关运行程序的计算机的浮点数的精度和内部表示形式的信息。复数具有实部和虚部，每个均是浮点数。要从复数&lt;em&gt;z&lt;/em&gt;提取这些部分，请使用 &lt;code&gt;z.real&lt;/code&gt; 和 &lt;code&gt;z.imag&lt;/code&gt; 。 （标准库包含其他数字类型&lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt;（对于有理数，分数是分数，对于用户定义的精度的浮点数是小数。&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="333c521b638ab05e83b6cf3986fc6b02269383b6" translate="yes" xml:space="preserve">
          <source>There are three keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt; which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) or an exception instance is provided, it is used; otherwise, &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt; is called to get the exception information.</source>
          <target state="translated">在&lt;em&gt;kwargs&lt;/em&gt;中检查了三个关键字参数：&lt;em&gt;exc_info&lt;/em&gt;，如果不将其评估为false，则会将异常信息添加到日志消息中。如果提供了一个异常元组（以&lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt;返回的格式）或一个异常实例，则使用它；否则，将使用它。否则，将调用&lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt;以获取异常信息。</target>
        </trans-unit>
        <trans-unit id="0d04821ea3634b3338603d35f9ecfca678dbd808" translate="yes" xml:space="preserve">
          <source>There are three main types of &lt;em&gt;awaitable&lt;/em&gt; objects: &lt;strong&gt;coroutines&lt;/strong&gt;, &lt;strong&gt;Tasks&lt;/strong&gt;, and &lt;strong&gt;Futures&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;等待&lt;/em&gt;对象主要有三种类型：&lt;strong&gt;协程&lt;/strong&gt;，&lt;strong&gt;任务&lt;/strong&gt;和&lt;strong&gt;期货&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9fe52cdc5c5e174e3a2732474be4c6eb0d0cd83e" translate="yes" xml:space="preserve">
          <source>There are three tar formats that can be created with the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">可以使用&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt;模块创建三种tar格式：</target>
        </trans-unit>
        <trans-unit id="9f8a6f9ebe421ba57fcfb4b59357400f94e96a60" translate="yes" xml:space="preserve">
          <source>There are times where a configuration needs to refer to objects external to the configuration, for example &lt;code&gt;sys.stderr&lt;/code&gt;. If the configuration dict is constructed using Python code, this is straightforward, but a problem arises when the configuration is provided via a text file (e.g. JSON, YAML). In a text file, there is no standard way to distinguish &lt;code&gt;sys.stderr&lt;/code&gt; from the literal string &lt;code&gt;'sys.stderr'&lt;/code&gt;. To facilitate this distinction, the configuration system looks for certain special prefixes in string values and treat them specially. For example, if the literal string &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; is provided as a value in the configuration, then the &lt;code&gt;ext://&lt;/code&gt; will be stripped off and the remainder of the value processed using normal import mechanisms.</source>
          <target state="translated">在某些情况下，配置需要引用配置外部的对象，例如 &lt;code&gt;sys.stderr&lt;/code&gt; 。如果配置命令是使用Python代码构造的，这很简单，但是当通过文本文件（例如JSON，YAML）提供配置时会出现问题。在文本文件中，没有标准的方法可以将 &lt;code&gt;sys.stderr&lt;/code&gt; 与文字字符串 &lt;code&gt;'sys.stderr'&lt;/code&gt; 区分开。为了促进这种区分，配置系统会在字符串值中查找某些特殊前缀，并对其进行特殊处理。例如，如果在配置中将文字字符串 &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; 作为值提供，则 &lt;code&gt;ext://&lt;/code&gt; 将被剥离，其余的值将使用常规导入机制进行处理。</target>
        </trans-unit>
        <trans-unit id="b952a5fd1b6e29bf7f14c99f1285b4bf5b966ccf" translate="yes" xml:space="preserve">
          <source>There are two &lt;code&gt;MagicMock&lt;/code&gt; variants: &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt;&lt;code&gt;NonCallableMagicMock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有两种 &lt;code&gt;MagicMock&lt;/code&gt; 变体：&lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt; &lt;code&gt;NonCallableMagicMock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1e5423c30972002ca80c24e40aa5624a40bd0af" translate="yes" xml:space="preserve">
          <source>There are two common ways to use this function. In both approaches, you use the fd to wake up when a signal arrives, but then they differ in how they determine &lt;em&gt;which&lt;/em&gt; signal or signals have arrived.</source>
          <target state="translated">有两种使用此功能的常用方法。在这两种方法中，您都使用fd在信号到达时唤醒，但是在确定&lt;em&gt;一个&lt;/em&gt;或多个信号到达的方式上却有所不同。</target>
        </trans-unit>
        <trans-unit id="9a9936ddf454d83f25fcc05dfb55a4648a3db888" translate="yes" xml:space="preserve">
          <source>There are two exceptions that may be raised by &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">&lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; &lt;/a&gt;实例可能会引发两个异常：</target>
        </trans-unit>
        <trans-unit id="5d6e02d2cfc3072839fb97bd9bedd2f8db9ebdbd" translate="yes" xml:space="preserve">
          <source>There are two interfaces provided by this module. The modern interface supports encoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; to ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, and decoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; or strings containing ASCII to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Both base-64 alphabets defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; (normal, and URL- and filesystem-safe) are supported.</source>
          <target state="translated">此模块提供两个接口。现代接口支持将&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;编码为ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;或包含ASCII的字符串解码为&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;。支持&lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548中&lt;/strong&gt;&lt;/a&gt;定义的两种base-64字母（普通，URL和文件系统安全）。</target>
        </trans-unit>
        <trans-unit id="2f66a95e6684310c68284ed5fc12fb871f267fa3" translate="yes" xml:space="preserve">
          <source>There are two interfaces provided by this module. The modern interface supports encoding &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; to ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, and decoding &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; or strings containing ASCII to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Both base-64 alphabets defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; (normal, and URL- and filesystem-safe) are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8ad7fa0c084245a8ddab7ad38f2502a86776e1" translate="yes" xml:space="preserve">
          <source>There are two main functions for creating &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; instances from text files and modules with doctests:</source>
          <target state="translated">从文本文件和带有doctests的模块创建&lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt;实例有两个主要功能：</target>
        </trans-unit>
        <trans-unit id="e0fdb9b9b06f75f219fccefe4c88b64af94e44fb" translate="yes" xml:space="preserve">
          <source>There are two optional keyword-only arguments. The &lt;em&gt;key&lt;/em&gt; argument specifies a one-argument ordering function like that used for &lt;a href=&quot;stdtypes#list.sort&quot;&gt;&lt;code&gt;list.sort()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;default&lt;/em&gt; argument specifies an object to return if the provided iterable is empty. If the iterable is empty and &lt;em&gt;default&lt;/em&gt; is not provided, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">有两个可选的仅关键字参数。的&lt;em&gt;关键&lt;/em&gt;参数指定一个一个参数的排序函数那样的用于&lt;a href=&quot;stdtypes#list.sort&quot;&gt; &lt;code&gt;list.sort()&lt;/code&gt; &lt;/a&gt;。该&lt;em&gt;默认&lt;/em&gt;参数指定的对象返回如果提供的迭代是空的。如果iterable为空且未提供&lt;em&gt;默认值&lt;/em&gt;，则会引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40e73167bc2dd539e8cb18681323426ef95edb7e" translate="yes" xml:space="preserve">
          <source>There are two parts to this job:</source>
          <target state="translated">这项工作有两个部分。</target>
        </trans-unit>
        <trans-unit id="9f617732163ef9ffd09291d0e0a3a8c64bfdd701" translate="yes" xml:space="preserve">
          <source>There are two stages in warning control: first, each time a warning is issued, a determination is made whether a message should be issued or not; next, if a message is to be issued, it is formatted and printed using a user-settable hook.</source>
          <target state="translated">警告控制有两个阶段:首先,每次发出警告时,都要确定是否要发出消息;接下来,如果要发出消息,就要用用户可设置的钩子对消息进行格式化和打印。</target>
        </trans-unit>
        <trans-unit id="bcfdafc8223a5b68a92a7d9394d696f0c5a9a642" translate="yes" xml:space="preserve">
          <source>There are two typical use cases for &lt;em&gt;super&lt;/em&gt;. In a class hierarchy with single inheritance, &lt;em&gt;super&lt;/em&gt; can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of &lt;em&gt;super&lt;/em&gt; in other programming languages.</source>
          <target state="translated">&lt;em&gt;super&lt;/em&gt;有两个典型的用例。在具有单一继承的类层次结构中，&lt;em&gt;super&lt;/em&gt;可以用于引用父类而无需显式命名它们，从而使代码更具可维护性。这种用法与其他编程语言中&lt;em&gt;super的&lt;/em&gt;用法非常相似。</target>
        </trans-unit>
        <trans-unit id="00afd891065ebece62243a2dd46e14fbe49e11f8" translate="yes" xml:space="preserve">
          <source>There are two ways to enable the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module to adapt a custom Python type to one of the supported ones.</source>
          <target state="translated">有两种方法可以使&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt;模块将自定义Python类型适配为受支持的Python类型之一。</target>
        </trans-unit>
        <trans-unit id="f0dd5354b3d81e371357acf3a005a58e85ee468a" translate="yes" xml:space="preserve">
          <source>There are various server methods that can be overridden by subclasses of base server classes like &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;; these methods aren&amp;rsquo;t useful to external users of the server object.</source>
          <target state="translated">基本服务器类的子类（例如&lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; )&lt;/a&gt;可以覆盖各种服务器方法；这些方法对服务器对象的外部用户没有用。</target>
        </trans-unit>
        <trans-unit id="4b102f0e1bd4efb4a95d03bb36b1a10aab39e47d" translate="yes" xml:space="preserve">
          <source>There are, however, enough ways to crash Python with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;, so you should be careful anyway. The &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt;&lt;code&gt;faulthandler&lt;/code&gt;&lt;/a&gt; module can be helpful in debugging crashes (e.g. from segmentation faults produced by erroneous C library calls).</source>
          <target state="translated">但是，有足够的方法用&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;使Python崩溃，因此无论如何您都应该小心。所述&lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt; &lt;code&gt;faulthandler&lt;/code&gt; &lt;/a&gt;模块可以在调试崩溃有用（例如，从由错误C库调用所生成的分割故障）。</target>
        </trans-unit>
        <trans-unit id="60e879387c2e07da69183eca12d6268a65a716b3" translate="yes" xml:space="preserve">
          <source>There are, of course, more possible ABCs for numbers, and this would be a poor hierarchy if it precluded the possibility of adding those. You can add &lt;code&gt;MyFoo&lt;/code&gt; between &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numbers.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; with:</source>
          <target state="translated">当然，数字可能还有更多的ABC，如果排除了添加这些数字的可能性，这将是一个糟糕的等级体系。您可以使用 &lt;code&gt;MyFoo&lt;/code&gt; 在&lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numbers.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;之间添加MyFoo：</target>
        </trans-unit>
        <trans-unit id="7e142c652134bf8d6bf541d434c33320b8252989" translate="yes" xml:space="preserve">
          <source>There can be a &lt;code&gt;turtle.cfg&lt;/code&gt; file in the directory where &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; is stored and an additional one in the current working directory. The latter will override the settings of the first one.</source>
          <target state="translated">在存储&lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt;的目录中可以有一个 &lt;code&gt;turtle.cfg&lt;/code&gt; 文件，而在当前工作目录中可以有另外一个。后者将覆盖第一个的设置。</target>
        </trans-unit>
        <trans-unit id="1a4413a268d4ebd32ee4dba0e329af575a824d1b" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;main thread&amp;rdquo; object; this corresponds to the initial thread of control in the Python program. It is not a daemon thread.</source>
          <target state="translated">有一个&amp;ldquo;主线程&amp;rdquo;对象；这对应于Python程序中的初始控制线程。它不是守护程序线程。</target>
        </trans-unit>
        <trans-unit id="1e29d6e10b2c6956c33cb943f01fb5492ba9c5d5" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; flag to set, in order to prevent this, &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt;:</source>
          <target state="translated">为了防止这种情况，有一个&lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;标志需要设置 &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e47e83e62ae2ee4ea0b5b657d1278fc1527f7e36" translate="yes" xml:space="preserve">
          <source>There is a backport of &lt;a href=&quot;#module-unittest.mock&quot;&gt;&lt;code&gt;unittest.mock&lt;/code&gt;&lt;/a&gt; for earlier versions of Python, available as &lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;mock on PyPI&lt;/a&gt;.</source>
          <target state="translated">有一个用于早期版本Python 的&lt;a href=&quot;#module-unittest.mock&quot;&gt; &lt;code&gt;unittest.mock&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;反向端口&lt;/a&gt;，可以在PyPI上以模拟方式获得。</target>
        </trans-unit>
        <trans-unit id="ab37ed1de9956ad2db535992c1cb4eab9ce74122" translate="yes" xml:space="preserve">
          <source>There is a certain baseline overhead associated with executing a pass statement. The code here doesn&amp;rsquo;t try to hide it, but you should be aware of it. The baseline overhead can be measured by invoking the program without arguments, and it might differ between Python versions.</source>
          <target state="translated">执行pass语句有一定的基线开销。此处的代码不会尝试隐藏它，但是您应该意识到这一点。基线开销可以通过不带参数的程序来测量，并且在两个Python版本之间可能有所不同。</target>
        </trans-unit>
        <trans-unit id="482dc1fc316fb8aa025fb46e7933e55a2e4fe842" translate="yes" xml:space="preserve">
          <source>There is a default policy used by all classes in the email package. For all of the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; classes and the related convenience functions, and for the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class, this is the &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt; policy, via its corresponding pre-defined instance &lt;a href=&quot;#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;. This policy provides for complete backward compatibility (in some cases, including bug compatibility) with the pre-Python3.3 version of the email package.</source>
          <target state="translated">电子邮件包中的所有类都使用默认策略。对于所有&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt;类和相关的便利功能，以及对于&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;类，这是&lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; &lt;/a&gt;策略，通过其对应的预定义实例&lt;a href=&quot;#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt;。此策略提供与电子邮件包的Python3.3之前版本的完全向后兼容性（在某些情况下，包括错误兼容性）。</target>
        </trans-unit>
        <trans-unit id="55d1a9e95df13365d139013a6923e69a48124ab1" translate="yes" xml:space="preserve">
          <source>There is a more aggressive version of both &lt;em&gt;spec&lt;/em&gt; and &lt;em&gt;autospec&lt;/em&gt; that &lt;em&gt;does&lt;/em&gt; prevent you setting non-existent attributes. This is useful if you want to ensure your code only &lt;em&gt;sets&lt;/em&gt; valid attributes too, but obviously it prevents this particular scenario:</source>
          <target state="translated">有两个更积极的版本&lt;em&gt;规格&lt;/em&gt;和&lt;em&gt;autospec&lt;/em&gt;这&lt;em&gt;不&lt;/em&gt;妨碍你设置不存在的属性。如果您想确保代码也只&lt;em&gt;设置&lt;/em&gt;有效的属性，这很有用，但是显然可以防止这种特殊情况：</target>
        </trans-unit>
        <trans-unit id="1beb9533846807b3cddb163730145908edcba46e" translate="yes" xml:space="preserve">
          <source>There is a tiny performance penalty when using &lt;code&gt;frozen=True&lt;/code&gt;: &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; cannot use simple assignment to initialize fields, and must use &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;object.__setattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;frozen=True&lt;/code&gt; 时，性能会受到很小的影响：&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt;不能使用简单的赋值来初始化字段，而必须使用&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;object.__setattr__()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49fbe885a03f63d401b2b0a3ffbb2939e259105a" translate="yes" xml:space="preserve">
          <source>There is a tiny performance penalty when using &lt;code&gt;frozen=True&lt;/code&gt;: &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; cannot use simple assignment to initialize fields, and must use &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;object.__setattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b27f43395afb40755c882e8f8377026ef5693d" translate="yes" xml:space="preserve">
          <source>There is a utility to create a dictionary the keys of which are the method names and the values of which are the docstrings of the public methods of the classes Screen and Turtle.</source>
          <target state="translated">有一个实用程序来创建一个字典,其键是方法名,其值是Screen和Turtle类的公共方法的docstrings。</target>
        </trans-unit>
        <trans-unit id="e7eae78a69e9371dbae0111468f3b5d1fc309bfa" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; for setting values in a dictionary just during a scope and restoring the dictionary to its original state when the test ends:</source>
          <target state="translated">还有&lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt;用于仅在范围内设置字典中的值，并在测试结束时将字典恢复为其原始状态：</target>
        </trans-unit>
        <trans-unit id="e684d0160793e96041b51aa12fbbadc464d12889" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the file name(s) on the command line:</source>
          <target state="translated">还有一个用于运行&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt;的命令行快捷方式。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行中传递文件名：</target>
        </trans-unit>
        <trans-unit id="d111a6794d7726b882e407d115339caecd4e6077" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the module name(s) on the command line:</source>
          <target state="translated">还有一个用于运行&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt;的命令行快捷方式。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行中传递模块名称：</target>
        </trans-unit>
        <trans-unit id="d79a9d980254c0558deebdb3ff6a0c81b5f4f60f" translate="yes" xml:space="preserve">
          <source>There is also a module-level convenience function:</source>
          <target state="translated">还有一个模块级的便利功能。</target>
        </trans-unit>
        <trans-unit id="eb180552aa6e02363503fb5c4bb76b55eebe73da" translate="yes" xml:space="preserve">
          <source>There is also a way to register new option flag names, though this isn&amp;rsquo;t useful unless you intend to extend &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; internals via subclassing:</source>
          <target state="translated">还有一种注册新选项标志名称的方法，尽管除非您打算通过子类扩展&lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt;内部结构，否则这没有用：</target>
        </trans-unit>
        <trans-unit id="2907b710c13ff58245f3fab419cf0626710f8bc4" translate="yes" xml:space="preserve">
          <source>There is also no mutable string type, but &lt;a href=&quot;#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; can be used to efficiently construct strings from multiple fragments.</source>
          <target state="translated">也没有可变的字符串类型，但是可以使用&lt;a href=&quot;#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt;从多个片段有效地构造字符串。</target>
        </trans-unit>
        <trans-unit id="d67e4f42d4de885a7414466b8f08bd4f8bc181d8" translate="yes" xml:space="preserve">
          <source>There is always a 1:1 relationship between transport and protocol objects: the protocol calls transport methods to send data, while the transport calls protocol methods to pass it data that has been received.</source>
          <target state="translated">传输对象和协议对象之间总是存在着1:1的关系:协议调用传输方法发送数据,而传输调用协议方法向它传递已经收到的数据。</target>
        </trans-unit>
        <trans-unit id="3e56625ac1cadac7545d7b1c51dea55a42570abf" translate="yes" xml:space="preserve">
          <source>There is an additional mode character permitted, &lt;code&gt;'U'&lt;/code&gt;, which no longer has any effect, and is considered deprecated. It previously enabled &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the &lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt; parameter for further details.</source>
          <target state="translated">允许使用其他模式字符 &lt;code&gt;'U'&lt;/code&gt; ，该字符不再起作用，被认为已弃用。它以前在文本模式下启用了&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;通用换行符&lt;/a&gt;，这成为了Python 3.0中的默认行为。有关更多详细信息，请参考&lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt;参数的文档。</target>
        </trans-unit>
        <trans-unit id="a887f026af45aa30903a5f15ed3395bf260ebab8" translate="yes" xml:space="preserve">
          <source>There is an additional mode character permitted, &lt;code&gt;'U'&lt;/code&gt;, which no longer has any effect, and is considered deprecated. It previously enabled &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the &lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt; parameter for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935265d6d70dd5bf2f00c18ebafbd01ee2301fae" translate="yes" xml:space="preserve">
          <source>There is an alternative, more powerful interface to the coder and decoder, see the source for details.</source>
          <target state="translated">有另一种更强大的编解码接口,详见源码。</target>
        </trans-unit>
        <trans-unit id="74c4518e8428116ce41d38c6760bba0be948a71b" translate="yes" xml:space="preserve">
          <source>There is an obsolete function &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">有一个过时的功能 &lt;code&gt;warn&lt;/code&gt; ，功能上与 &lt;code&gt;warning&lt;/code&gt; 相同。由于不建议使用 &lt;code&gt;warn&lt;/code&gt; ，请不要使用它- 而是使用 &lt;code&gt;warning&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9565a2b6830f7e297c9c91221ecf38feac62a37" translate="yes" xml:space="preserve">
          <source>There is an obsolete method &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">有一种过时的方法 &lt;code&gt;warn&lt;/code&gt; ，功能上与 &lt;code&gt;warning&lt;/code&gt; 相同。由于不建议使用 &lt;code&gt;warn&lt;/code&gt; ，请不要使用它- 而是使用 &lt;code&gt;warning&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c04d008df0b3902a3f5080424926193dc66981f" translate="yes" xml:space="preserve">
          <source>There is currently no way to schedule coroutines or callbacks directly from a different process (such as one started with &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;asyncio-eventloop#asyncio-event-loop&quot;&gt;Event Loop Methods&lt;/a&gt; section lists APIs that can read from pipes and watch file descriptors without blocking the event loop. In addition, asyncio&amp;rsquo;s &lt;a href=&quot;asyncio-subprocess#asyncio-subprocess&quot;&gt;Subprocess&lt;/a&gt; APIs provide a way to start a process and communicate with it from the event loop. Lastly, the aforementioned &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt;&lt;code&gt;loop.run_in_executor()&lt;/code&gt;&lt;/a&gt; method can also be used with a &lt;a href=&quot;concurrent.futures#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;concurrent.futures.ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt; to execute code in a different process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a894765372946cbd728f24442f80a275c531295d" translate="yes" xml:space="preserve">
          <source>There is data to read</source>
          <target state="translated">有数据可读</target>
        </trans-unit>
        <trans-unit id="e75c6cbe07532d2502dde4b485373249588d95da" translate="yes" xml:space="preserve">
          <source>There is less temptation to change test code to fit the code it tests without a good reason.</source>
          <target state="translated">在没有充分理由的情况下,减少了改变测试代码以适应其测试的代码的诱惑。</target>
        </trans-unit>
        <trans-unit id="4bd88caba77eb2e0f96b475391a639aa16965d22" translate="yes" xml:space="preserve">
          <source>There is no &lt;em&gt;do_handshake_on_connect&lt;/em&gt; machinery. You must always manually call &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt; to start the handshake.</source>
          <target state="translated">没有&lt;em&gt;do_handshake_on_connect&lt;/em&gt;机制。您必须始终手动调用&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt;来开始握手。</target>
        </trans-unit>
        <trans-unit id="17646ebf84b2cc6d3d2aa087f8fe20aa0ea84904" translate="yes" xml:space="preserve">
          <source>There is no command-line option to control the optimization level used by the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function, because the Python interpreter itself already provides the option: &lt;strong&gt;python -O -m compileall&lt;/strong&gt;.</source>
          <target state="translated">没有命令行选项可以控制&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt;函数使用的优化级别，因为Python解释器本身已经提供了以下选项：&lt;strong&gt;python -O -m compileall&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a339402e2c08e68357d4607ca200a87f81869499" translate="yes" xml:space="preserve">
          <source>There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor:</source>
          <target state="translated">字节数组对象没有专门的文字语法,它们总是通过调用构造函数来创建。</target>
        </trans-unit>
        <trans-unit id="ab1e290a57c9a8c7c0ca47e3789793780590484a" translate="yes" xml:space="preserve">
          <source>There is no default implementation</source>
          <target state="translated">没有默认执行</target>
        </trans-unit>
        <trans-unit id="4cfcfdb7a55717a78c7053ebb53cb164835e6d05" translate="yes" xml:space="preserve">
          <source>There is no handling of &lt;em&gt;suppress_ragged_eofs&lt;/em&gt;. All end-of-file conditions that are in violation of the protocol are reported via the &lt;a href=&quot;#ssl.SSLEOFError&quot;&gt;&lt;code&gt;SSLEOFError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">有没有处理的&lt;em&gt;suppress_ragged_eofs&lt;/em&gt;。通过&lt;a href=&quot;#ssl.SSLEOFError&quot;&gt; &lt;code&gt;SSLEOFError&lt;/code&gt; &lt;/a&gt;异常报告所有违反协议的文件结束条件。</target>
        </trans-unit>
        <trans-unit id="354d47c9f2be30d4225e6edd3dac13f743ff4c56" translate="yes" xml:space="preserve">
          <source>There is no limitation for running subprocesses from different threads once the watcher is installed.</source>
          <target state="translated">安装了看板后,从不同线程运行子进程没有限制。</target>
        </trans-unit>
        <trans-unit id="78052c50fd1ad0400209b2cf6aa7fbfab4c2eea6" translate="yes" xml:space="preserve">
          <source>There is no method to obtain the POSIX timestamp directly from a naive &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance representing UTC time. If your application uses this convention and your system timezone is not set to UTC, you can obtain the POSIX timestamp by supplying &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt;:</source>
          <target state="translated">没有直接从表示UTC时间的朴素的&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;实例获取POSIX时间戳的方法。如果您的应用程序使用此约定，并且系统时区未设置为UTC，则可以通过提供 &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt; 获得POSIX时间戳：</target>
        </trans-unit>
        <trans-unit id="3ccc659c3dddb17a0d08925d775d9c79df47ca5e" translate="yes" xml:space="preserve">
          <source>There is no module-level &lt;code&gt;wrap_bio()&lt;/code&gt; call like there is for &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; is always created via an &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">没有模块级 &lt;code&gt;wrap_bio()&lt;/code&gt; 调用，比如有针对&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt;。一个&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;总是通过创建&lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="979783c6e7664e6582aa3da703198e886d977840" translate="yes" xml:space="preserve">
          <source>There is no need to install the default policy manually. asyncio is configured to use the default policy automatically.</source>
          <target state="translated">无需手动安装默认策略,asyncio被配置为自动使用默认策略。</target>
        </trans-unit>
        <trans-unit id="84f726f27659d6fc6e9b60e5ca57b5dfa4b12f91" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates), but stating a thread per process requires extra memory.</source>
          <target state="translated">处理大量子代时（每次子代终止时均为&lt;em&gt;O（1））&lt;/em&gt;时，没有明显的开销，但是在每个进程中声明一个线程需要额外的内存。</target>
        </trans-unit>
        <trans-unit id="eb98ad1710a337cd30d3185a62ee9740d3de4bde" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates).</source>
          <target state="translated">处理大量子代时（每次子代终止时均为&lt;em&gt;O（1）），&lt;/em&gt;没有明显的开销。</target>
        </trans-unit>
        <trans-unit id="7ea5b79c20fda2d876e2837855af83a60a9f3d1e" translate="yes" xml:space="preserve">
          <source>There is no requirement that &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instances be used to represent messages retrieved using &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances. In some situations, the time and memory required to generate &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; representations might not be acceptable. For such situations, &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances also offer string and file-like representations, and a custom message factory may be specified when a &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance is initialized.</source>
          <target state="translated">不需要使用&lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;实例来表示使用&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt;实例检索的消息。在某些情况下，生成&lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt;表示形式所需的时间和内存可能不可接受。在这种情况下，&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt;实例还提供字符串和类似文件的表示形式，并且在初始化&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt;实例时可以指定自定义消息工厂。</target>
        </trans-unit>
        <trans-unit id="b3ae3451c579ac5b5dbb261bd25097c72e8278dd" translate="yes" xml:space="preserve">
          <source>There is no requirement that the tools in this module are used to create application archives - the module is a convenience, but archives in the above format created by any means are acceptable to Python.</source>
          <target state="translated">本模块中的工具并没有要求用来创建应用程序存档--本模块是一种方便,但通过任何方式创建的上述格式的存档都是Python可以接受的。</target>
        </trans-unit>
        <trans-unit id="f4cb2262ca8f74431c7529f7caba934501312915" translate="yes" xml:space="preserve">
          <source>There is no return value.</source>
          <target state="translated">没有返回值。</target>
        </trans-unit>
        <trans-unit id="626b4419124dc05c7ee6eecb962399deb2c5e434" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6755c18f7a4a50204cd008eb3d1159aadb9e5a90" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">这些属性没有运行时检查。有关更多详细信息，请参见&lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59014a17300c50cea45a4a6358e449e5248694af" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">这些属性没有运行时检查。有关更多详细信息，请参见&lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b8a967536096b023a787a204a97de48dac9e487" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-62&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d266ba42289c7350fb4e3a1db7c80f501f09db" translate="yes" xml:space="preserve">
          <source>There is no syntax to indicate optional or keyword arguments; such function types are rarely used as callback types. &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; (literal ellipsis) can be used to type hint a callable taking any number of arguments and returning &lt;code&gt;ReturnType&lt;/code&gt;. A plain &lt;a href=&quot;#typing.Callable&quot;&gt;&lt;code&gt;Callable&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;code&gt;Callable[..., Any]&lt;/code&gt;, and in turn to &lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt;&lt;code&gt;collections.abc.Callable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">没有语法指示可选参数或关键字参数。这种函数类型很少用作回调类型。 &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; （大写省略号）可用于使用任何数量的参数并返回 &lt;code&gt;ReturnType&lt;/code&gt; 来键入提示可调用的提示。普通的&lt;a href=&quot;#typing.Callable&quot;&gt; &lt;code&gt;Callable&lt;/code&gt; &lt;/a&gt;等效于 &lt;code&gt;Callable[..., Any]&lt;/code&gt; ，然后等效于&lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt; &lt;code&gt;collections.abc.Callable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b473b64f202d7735b92adfb4667a5ab7ed7dcc5" translate="yes" xml:space="preserve">
          <source>There is no way for CGI code to tell whether the option was set, so a separate handler class is provided. It is used in the same way as &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;, i.e., by calling &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt;, where &lt;code&gt;app&lt;/code&gt; is the WSGI application object you wish to invoke.</source>
          <target state="translated">CGI代码无法得知是否设置了该选项，因此提供了一个单独的处理程序类。它的使用方式与&lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt;相同，即调用 &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt; ，其中 &lt;code&gt;app&lt;/code&gt; 是您要调用的WSGI应用程序对象。</target>
        </trans-unit>
        <trans-unit id="d0fe2afc95bd9dd12af3411b4ecc87fbcc97df95" translate="yes" xml:space="preserve">
          <source>There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of &lt;code&gt;'&amp;lt;'&lt;/code&gt; or &lt;code&gt;'&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">无法指示非本机字节顺序（强制字节交换）。使用 &lt;code&gt;'&amp;lt;'&lt;/code&gt; 或 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 的适当选择。</target>
        </trans-unit>
        <trans-unit id="d70cda3946eb643babc8c8abe059a00b30a0a0e3" translate="yes" xml:space="preserve">
          <source>There is no way to perform case conversions and character classifications according to the locale. For (Unicode) text strings these are done according to the character value only, while for byte strings, the conversions and classifications are done according to the ASCII value of the byte, and bytes whose high bit is set (i.e., non-ASCII bytes) are never converted or considered part of a character class such as letter or whitespace.</source>
          <target state="translated">没有办法根据本地环境进行大小写转换和字符分类。对于(Unicode)文本字符串,这些都是根据字符值来进行的,而对于字节字符串,转换和分类是根据字节的ASCII值来进行的,高位被设置的字节(即非ASCII字节)永远不会被转换,也不会被视为字符类的一部分,如字母或空白。</target>
        </trans-unit>
        <trans-unit id="5b9cc71dc4ff206cec212895ed53756aab2a7764" translate="yes" xml:space="preserve">
          <source>There is no way to say &amp;ldquo;python X.Y or later&amp;rdquo;, so be careful of using an exact version like &amp;ldquo;/usr/bin/env python3.4&amp;rdquo; as you will need to change your shebang line for users of Python 3.5, for example.</source>
          <target state="translated">没有办法说&amp;ldquo; python XY或更高版本&amp;rdquo;，因此请谨慎使用&amp;ldquo; / usr / bin / env python3.4&amp;rdquo;之类的确切版本，因为您将需要为Python 3.5的用户更改shebang行。</target>
        </trans-unit>
        <trans-unit id="d2369966e324eb7a0bb66ca53d7e0b8023f09ca6" translate="yes" xml:space="preserve">
          <source>There is no way to unregister a function.</source>
          <target state="translated">没有办法取消注册一个函数。</target>
        </trans-unit>
        <trans-unit id="59f1410dd1d1d6d9c22b365f413457bba1605111" translate="yes" xml:space="preserve">
          <source>There is one class defined for each left-hand side symbol in the abstract grammar (for example, &lt;code&gt;ast.stmt&lt;/code&gt; or &lt;code&gt;ast.expr&lt;/code&gt;). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, &lt;a href=&quot;#ast.BinOp&quot;&gt;&lt;code&gt;ast.BinOp&lt;/code&gt;&lt;/a&gt; inherits from &lt;code&gt;ast.expr&lt;/code&gt;. For production rules with alternatives (aka &amp;ldquo;sums&amp;rdquo;), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd0e13bda3ae598cc30ece116faadf286e65f28" translate="yes" xml:space="preserve">
          <source>There is one class defined for each left-hand side symbol in the abstract grammar (for example, &lt;code&gt;ast.stmt&lt;/code&gt; or &lt;code&gt;ast.expr&lt;/code&gt;). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, &lt;code&gt;ast.BinOp&lt;/code&gt; inherits from &lt;code&gt;ast.expr&lt;/code&gt;. For production rules with alternatives (aka &amp;ldquo;sums&amp;rdquo;), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</source>
          <target state="translated">在抽象语法中，为每个左侧符号定义了一个类（例如 &lt;code&gt;ast.stmt&lt;/code&gt; 或 &lt;code&gt;ast.expr&lt;/code&gt; ）。另外，在右侧为每个构造函数定义了一个类。这些类继承自左侧树的类。例如， &lt;code&gt;ast.BinOp&lt;/code&gt; 继承自 &lt;code&gt;ast.expr&lt;/code&gt; 。对于带有替代选项（又称&amp;ldquo;和&amp;rdquo;）的生产规则，左侧类是抽象的：仅创建特定构造函数节点的实例。</target>
        </trans-unit>
        <trans-unit id="8aabd37fa9d78fbac35e4cc9ca691f0871edeeca" translate="yes" xml:space="preserve">
          <source>There is one classmethod to make a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance for a filesystem file:</source>
          <target state="translated">有一种类方法可以为文件系统文件创建&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt;实例：</target>
        </trans-unit>
        <trans-unit id="0412fae0e9a520771b5fcb2cddecf67855d8aff1" translate="yes" xml:space="preserve">
          <source>There is one constructor method named for each type of &lt;em&gt;hash&lt;/em&gt;. All return a hash object with the same simple interface. For example: use &lt;code&gt;sha256()&lt;/code&gt; to create a SHA-256 hash object. You can now feed this object with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; (normally &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) using the &lt;code&gt;update()&lt;/code&gt; method. At any point you can ask it for the &lt;em&gt;digest&lt;/em&gt; of the concatenation of the data fed to it so far using the &lt;code&gt;digest()&lt;/code&gt; or &lt;code&gt;hexdigest()&lt;/code&gt; methods.</source>
          <target state="translated">每种&lt;em&gt;哈希&lt;/em&gt;类型都有一个构造函数方法。全部返回具有相同简单接口的哈希对象。例如：使用 &lt;code&gt;sha256()&lt;/code&gt; 创建一个SHA-256哈希对象。现在，您可以使用 &lt;code&gt;update()&lt;/code&gt; 方法为该对象提供&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;类似字节的对象&lt;/a&gt;（通常为&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;）。在任何时候，你可以要求它为&lt;em&gt;消化&lt;/em&gt;进料给它迄今使用的数据的级联 &lt;code&gt;digest()&lt;/code&gt; 或 &lt;code&gt;hexdigest()&lt;/code&gt; 方法。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3117c0dab3215247b68ccd2e04cecc535a1ca1b6" translate="yes" xml:space="preserve">
          <source>There is one constructor method named for each type of &lt;em&gt;hash&lt;/em&gt;. All return a hash object with the same simple interface. For example: use &lt;code&gt;sha256()&lt;/code&gt; to create a SHA-256 hash object. You can now feed this object with &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; (normally &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) using the &lt;code&gt;update()&lt;/code&gt; method. At any point you can ask it for the &lt;em&gt;digest&lt;/em&gt; of the concatenation of the data fed to it so far using the &lt;code&gt;digest()&lt;/code&gt; or &lt;code&gt;hexdigest()&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8120f8e5075cd93d0d190c702aaa96797cb5168" translate="yes" xml:space="preserve">
          <source>There is one more &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; method that a subclass may wish to override:</source>
          <target state="translated">子类可能希望覆盖另一个&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="fe629198154ae18d59378c3ddd10ff8afbe6fa19" translate="yes" xml:space="preserve">
          <source>There is really only one valid value for the &lt;em&gt;MIME-Version&lt;/em&gt; header, and that is &lt;code&gt;1.0&lt;/code&gt;. For future proofing, this header class supports other valid version numbers. If a version number has a valid value per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, then the header object will have non-&lt;code&gt;None&lt;/code&gt; values for the following attributes:</source>
          <target state="translated">&lt;em&gt;MIME-Version&lt;/em&gt;标头实际上只有一个有效值，即 &lt;code&gt;1.0&lt;/code&gt; 。为了将来验证，此标头类支持其他有效的版本号。如果版本号根据&lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;具有有效值，则标头对象的以下属性将具有非 &lt;code&gt;None&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="453b4f6d9769fd9f210579ed35f0b45ec2a4f635" translate="yes" xml:space="preserve">
          <source>There is the possibility that &amp;ldquo;dummy thread objects&amp;rdquo; are created. These are thread objects corresponding to &amp;ldquo;alien threads&amp;rdquo;, which are threads of control started outside the threading module, such as directly from C code. Dummy thread objects have limited functionality; they are always considered alive and daemonic, and cannot be &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;ed. They are never deleted, since it is impossible to detect the termination of alien threads.</source>
          <target state="translated">有可能会创建&amp;ldquo;虚拟线程对象&amp;rdquo;。这些是与&amp;ldquo;外来线程&amp;rdquo;相对应的线程对象，&amp;ldquo;外来线程&amp;rdquo;是在线程模块外部启动的控制线程，例如直接从C代码开始的线程。虚拟线程对象的功能有限。它们始终被认为是活动的和守护程序，不能被&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;编辑。它们永远不会被删除，因为不可能检测到外来线程的终止。</target>
        </trans-unit>
        <trans-unit id="29a71b710bb3b88050806003b5991d9687cac929" translate="yes" xml:space="preserve">
          <source>There is urgent data to read</source>
          <target state="translated">有紧急数据要读</target>
        </trans-unit>
        <trans-unit id="268075deb39485d79f07bf18d036ea245830ce43" translate="yes" xml:space="preserve">
          <source>There should be a function to query whether a particular URL is in the cache.</source>
          <target state="translated">应该有一个函数来查询某个URL是否在缓存中。</target>
        </trans-unit>
        <trans-unit id="e6e797c6f8f25641f56be38527a8196278af7bbb" translate="yes" xml:space="preserve">
          <source>There was an error parsing a text declaration in an external entity.</source>
          <target state="translated">在解析外部实体中的文本声明时出现了错误。</target>
        </trans-unit>
        <trans-unit id="d17e4f0895a59fce0176b492223bf84fc53d1057" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a subclass for secure connections:</source>
          <target state="translated">还有一个用于安全连接的子类：</target>
        </trans-unit>
        <trans-unit id="04529db9fc59784d175f6c070f6a41e39f0d9ba0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another encoding that is able to encoding the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four &lt;code&gt;1&lt;/code&gt; bits followed by a &lt;code&gt;0&lt;/code&gt; bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</source>
          <target state="translated">还有另一种能够对所有Unicode字符进行编码的编码：UTF-8。UTF-8是8位编码，这意味着UTF-8中的字节顺序没有问题。UTF-8字节序列中的每个字节都由两部分组成：标记位（最高有效位）和有效载荷位。标记位是从零到四个 &lt;code&gt;1&lt;/code&gt; 位的序列，后跟一个 &lt;code&gt;0&lt;/code&gt; 位。Unicode字符的编码是这样的（x是有效载荷位，当连接时会给出Unicode字符）：</target>
        </trans-unit>
        <trans-unit id="0bacbeb7a867039aeb31684676f8649929ec6809" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these code points are mapped to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;. To see how this is done simply open e.g. &lt;code&gt;encodings/cp1252.py&lt;/code&gt; (which is an encoding that is used primarily on Windows). There&amp;rsquo;s a string constant with 256 characters that shows you which character is mapped to which byte value.</source>
          <target state="translated">还有另一组编码（所谓的charmap编码），它们选择所有Unicode代码点的不同子集，以及如何将这些代码点映射到字节 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; 。要查看如何完成此操作，只需打开例如 &lt;code&gt;encodings/cp1252.py&lt;/code&gt; （这是主要在Windows上使用的编码）即可。有一个包含256个字符的字符串常量，向您显示哪个字符映射到哪个字节值。</target>
        </trans-unit>
        <trans-unit id="d17e73f60746e10f8033ef47e930f87715709ed8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no output! That&amp;rsquo;s normal, and it means all the examples worked. Pass &lt;code&gt;-v&lt;/code&gt; to the script, and &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; prints a detailed log of what it&amp;rsquo;s trying, and prints a summary at the end:</source>
          <target state="translated">没有输出！这是正常现象，这意味着所有示例均有效。将 &lt;code&gt;-v&lt;/code&gt; 传递给脚本，然后&lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt;打印正在尝试执行的操作的详细日志，并在最后输出摘要：</target>
        </trans-unit>
        <trans-unit id="5107e764cbcf99be3db8a02a597dc9e0dfb5249e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one important rule: if you invoke an external program (via the &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt; functions. or others with similar functionality), make very sure you don&amp;rsquo;t pass arbitrary strings received from the client to the shell. This is a well-known security hole whereby clever hackers anywhere on the Web can exploit a gullible CGI script to invoke arbitrary shell commands. Even parts of the URL or field names cannot be trusted, since the request doesn&amp;rsquo;t have to come from your form!</source>
          <target state="translated">有一条重要的规则：如果调用外部程序（通过&lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt;函数或其他具有类似功能的函数），请确保不要将从客户端收到的任意字符串传递给贝壳。这是一个众所周知的安全漏洞，Web上任何地方的聪明黑客都可以利用可感染的CGI脚本来调用任意shell命令。甚至URL或字段名称的一部分也不能被信任，因为请求不必来自您的表单！</target>
        </trans-unit>
        <trans-unit id="465b85dd3cb1dcf881030f6e1facbd759bc882ac" translate="yes" xml:space="preserve">
          <source>Therefore it is probably best to only consider using &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate&lt;/code&gt;&lt;/a&gt; on processes which never use any shared resources.</source>
          <target state="translated">因此，最好只考虑在从未使用任何共享资源的进程上使用&lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d7ac873aab905d0d19416bd5a2e507b4093a46a" translate="yes" xml:space="preserve">
          <source>Therefore, the appropriate way to read form data values was to always use the code which checks whether the obtained value is a single value or a list of values. That&amp;rsquo;s annoying and leads to less readable scripts.</source>
          <target state="translated">因此，读取表单数据值的适当方法是始终使用代码检查所获得的值是单个值还是值列表。这很烦人，导致脚本的可读性降低。</target>
        </trans-unit>
        <trans-unit id="ee0e8bc4ddad651cd810b740467094854c86f22f" translate="yes" xml:space="preserve">
          <source>Therefore, the same rules apply as with &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;: The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held.</source>
          <target state="translated">因此，使用与&lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;相同的规则：调用时必须保留该锁，并在返回时重新获取该锁。谓词在持有锁的情况下进行评估。</target>
        </trans-unit>
        <trans-unit id="7837e5032c97f9de99277b75a2524a30220ac2b0" translate="yes" xml:space="preserve">
          <source>Therefore, unless the connection object was produced using &lt;code&gt;Pipe()&lt;/code&gt; you should only use the &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; methods after performing some sort of authentication. See &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;Authentication keys&lt;/a&gt;.</source>
          <target state="translated">因此，除非连接对象是使用 &lt;code&gt;Pipe()&lt;/code&gt; 生成的，否则您仅应在执行某种身份验证后使用&lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;方法。请参阅&lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;身份验证密钥&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96533ee7558cd28344275b7b6faa62d8e6b52b05" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt;&lt;code&gt;BaseRequestHandler&lt;/code&gt;&lt;/a&gt; subclasses override the &lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt;&lt;code&gt;finish()&lt;/code&gt;&lt;/a&gt; methods, and provide &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes. The &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes can be read or written, respectively, to get the request data or return data to the client.</source>
          <target state="translated">这些&lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt; &lt;code&gt;BaseRequestHandler&lt;/code&gt; &lt;/a&gt;子类覆盖&lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt; &lt;code&gt;setup()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt; &lt;code&gt;finish()&lt;/code&gt; &lt;/a&gt;方法，并提供 &lt;code&gt;self.rfile&lt;/code&gt; 和 &lt;code&gt;self.wfile&lt;/code&gt; 属性。该 &lt;code&gt;self.rfile&lt;/code&gt; 和 &lt;code&gt;self.wfile&lt;/code&gt; 属性可以被读取或写入，分别获得请求的数据或数据返回到客户端。</target>
        </trans-unit>
        <trans-unit id="43420a1e7f2d338a26313b513562211f7c319bad" translate="yes" xml:space="preserve">
          <source>These ABCs allow us to ask classes or instances if they provide particular functionality, for example:</source>
          <target state="translated">例如,这些ABC允许我们询问类或实例是否提供了特定的功能。</target>
        </trans-unit>
        <trans-unit id="79eb154c9b38c333e433efadc74ad44c819279e7" translate="yes" xml:space="preserve">
          <source>These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt;) is converted into an ASCII-compatible encoding (ACE, such as &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt;). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP &lt;em&gt;Host&lt;/em&gt; fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user.</source>
          <target state="translated">这些RFC共同定义了一种协议，以支持域名中的非ASCII字符。包含非ASCII字符的域名（例如 &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt; ）将转换为与ASCII兼容的编码（ACE，例如 &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt; ）。域名的ACE形式然后在协议不允许使用任意字符的所有地方使用，例如DNS查询，HTTP &lt;em&gt;Host&lt;/em&gt;字段等。该转换在应用程序中进行；如果可能对用户不可见：应用程序应在将导线呈现给用户之前，将Unicode域标签透明地转换为IDNA，并将ACE标签转换回Unicode。</target>
        </trans-unit>
        <trans-unit id="ae0960be459bc3a6043cacd2025edb486fd19f0b" translate="yes" xml:space="preserve">
          <source>These are available only after &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">这些仅在&lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt;之后可用。</target>
        </trans-unit>
        <trans-unit id="8865173ab02152cd75e5e2adf536e021d990b831" translate="yes" xml:space="preserve">
          <source>These are not used in annotations. They are building blocks for creating generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbbc79b314368b7b552cdbf5c2628b93b45f0a7" translate="yes" xml:space="preserve">
          <source>These are not used in annotations. They are building blocks for declaring types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5c32d3a29bd1ff89416b3ae09cf4c6ae4a7c9d" translate="yes" xml:space="preserve">
          <source>These are string constants containing Bluetooth addresses with special meanings. For example, &lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt;&lt;code&gt;BDADDR_ANY&lt;/code&gt;&lt;/a&gt; can be used to indicate any address when specifying the binding socket with &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt;.</source>
          <target state="translated">这些是包含具有特殊含义的蓝牙地址的字符串常量。例如，当用 &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt; 指定绑定套接字时，&lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt; &lt;code&gt;BDADDR_ANY&lt;/code&gt; &lt;/a&gt;可用于指示任何地址。</target>
        </trans-unit>
        <trans-unit id="6e329deebb0b200060e6eef68196fa813fcd6a7c" translate="yes" xml:space="preserve">
          <source>These are the Boolean operations, ordered by ascending priority:</source>
          <target state="translated">这些是布尔运算,按优先级升序排列。</target>
        </trans-unit>
        <trans-unit id="257015f45893c1795d9d847c44cd903ea49c2017" translate="yes" xml:space="preserve">
          <source>These are the fundamental ctypes data types:</source>
          <target state="translated">这些是基本的ctypes数据类型。</target>
        </trans-unit>
        <trans-unit id="26144cb516a5e752da5774e85f8525ae1b490465" translate="yes" xml:space="preserve">
          <source>These are the operations that dictionaries support (and therefore, custom mapping types should support too):</source>
          <target state="translated">这些都是字典所支持的操作(因此,自定义映射类型也应该支持)。</target>
        </trans-unit>
        <trans-unit id="6e52dbf7f9d96621e5053b5b96e01b2cb4d2ddd1" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;code&gt;si_code&lt;/code&gt; in the result returned by &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些是&lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt;返回的结果中 &lt;code&gt;si_code&lt;/code&gt; 的可能值。</target>
        </trans-unit>
        <trans-unit id="33d6686360d4d96617294fd588956382c26c1e0b" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;em&gt;idtype&lt;/em&gt; in &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;. They affect how &lt;em&gt;id&lt;/em&gt; is interpreted.</source>
          <target state="translated">这些是可能的值&lt;em&gt;idtype&lt;/em&gt;在&lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt;。它们影响&lt;em&gt;id&lt;/em&gt;的解释方式。</target>
        </trans-unit>
        <trans-unit id="869f56b514f44bafe3fe22e39f703595a56c9bf4" translate="yes" xml:space="preserve">
          <source>These are useful if you want more control, or if you want to employ some of the algorithms implemented in this module in other circumstances.</source>
          <target state="translated">如果你想要更多的控制,或者你想在其他情况下使用本模块中实现的一些算法,这些都是有用的。</target>
        </trans-unit>
        <trans-unit id="01bf0efec17a4834e0a6b4b11da2c6d1b42d7b04" translate="yes" xml:space="preserve">
          <source>These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.</source>
          <target state="translated">如果网络地址和广播地址都为真,那么这些属性对整个网络来说就是真。</target>
        </trans-unit>
        <trans-unit id="181a67606af87af42c5d3ffd8630c69cbabfe1e4" translate="yes" xml:space="preserve">
          <source>These attributes are deleted at the context manager exit.</source>
          <target state="translated">这些属性在上下文管理器退出时被删除。</target>
        </trans-unit>
        <trans-unit id="6e7b417bf2efa43f13fc4f3e2f96d7bb14f2e3d8" translate="yes" xml:space="preserve">
          <source>These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.</source>
          <target state="translated">如果网络地址和广播地址都是真的,那么这些属性对整个网络来说就是真的。</target>
        </trans-unit>
        <trans-unit id="2fe7aee32b05e735896ae2f06ad4b1db866432e5" translate="yes" xml:space="preserve">
          <source>These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the &lt;em&gt;text&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s start tag and its first child or end tag, or &lt;code&gt;None&lt;/code&gt;, and the &lt;em&gt;tail&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s end tag and the next tag, or &lt;code&gt;None&lt;/code&gt;. For the XML data</source>
          <target state="translated">这些属性可用于保存与元素关联的其他数据。它们的值通常是字符串，但可以是任何特定于应用程序的对象。如果元素是从XML文件创建的，则&lt;em&gt;text&lt;/em&gt;属性将保留元素的开始标记与其第一个子标记或结束标记之间的文本，或者 &lt;code&gt;None&lt;/code&gt; ，而&lt;em&gt;tail&lt;/em&gt;属性将保留元素的结束标记与下一个标记之间的文本。或 &lt;code&gt;None&lt;/code&gt; 。对于XML数据</target>
        </trans-unit>
        <trans-unit id="6fd5033e1290cc940ad7cf71f9886488f34ab1aa" translate="yes" xml:space="preserve">
          <source>These bytes can be used to seed user-space random number generators or for cryptographic purposes.</source>
          <target state="translated">这些字节可用于用户空间随机数生成器的种子或用于加密目的。</target>
        </trans-unit>
        <trans-unit id="44ca4afebbdb6d250b9740f34fbdbf566762d631" translate="yes" xml:space="preserve">
          <source>These calls are only made if control is expected to return to the Python interpreter. A typical &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; launch will not trigger them as the child is not going to re-enter the interpreter.</source>
          <target state="translated">仅当期望控制权返回到Python解释器时才进行这些调用。典型的&lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;启动不会触发它们，因为子级不会重新输入解释器。</target>
        </trans-unit>
        <trans-unit id="864edae1c9ec3018b8088f575c6cbd03c733ee84" translate="yes" xml:space="preserve">
          <source>These can be used as types in annotations and do not support &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3cd0fdf581abcbc624a1353cfbd4046417caef" translate="yes" xml:space="preserve">
          <source>These can be used as types in annotations using &lt;code&gt;[]&lt;/code&gt;, each having a unique syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853ef506dfaaa56fab906e6007dbe61b8f184b47" translate="yes" xml:space="preserve">
          <source>These classes are pre-defined using the mix-in classes.</source>
          <target state="translated">这些类是使用混合类预先定义的。</target>
        </trans-unit>
        <trans-unit id="429a7cf26e573ef062098c538c098cd4acba2cab" translate="yes" xml:space="preserve">
          <source>These classes are provided for the purposes of organizing certain functions under one namespace. They aren&amp;rsquo;t meant to be instantiated independently.</source>
          <target state="translated">提供这些类是为了在一个名称空间下组织某些功能。它们并不是要独立实例化。</target>
        </trans-unit>
        <trans-unit id="ae47495c57f5eaa0f0f8df13652cd694013c4578" translate="yes" xml:space="preserve">
          <source>These classes extend the above classes to serve HTML documentation in response to HTTP GET requests. Servers can either be free standing, using &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt;&lt;code&gt;DocXMLRPCServer&lt;/code&gt;&lt;/a&gt;, or embedded in a CGI environment, using &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些类扩展了上述类，以响应HTTP GET请求而提供HTML文档。服务器可以是自由站立，用&lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt; &lt;code&gt;DocXMLRPCServer&lt;/code&gt; &lt;/a&gt;，或嵌入CGI环境下，用&lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="771117257d089fde13c49bce5d82474423521fb2" translate="yes" xml:space="preserve">
          <source>These collections are provided for automatic introspection of bytecode instructions:</source>
          <target state="translated">这些集合是为了自动反省字节码指令而提供的。</target>
        </trans-unit>
        <trans-unit id="bb46852d445b6630c8fabc91fcd9b4c4b7f185c5" translate="yes" xml:space="preserve">
          <source>These commands and their arguments will be passed to a C function in the &lt;code&gt;_tkinter&lt;/code&gt; - note the underscore - extension module.</source>
          <target state="translated">这些命令及其参数将传递给 &lt;code&gt;_tkinter&lt;/code&gt; 中的C函数-注意下划线-扩展模块。</target>
        </trans-unit>
        <trans-unit id="7cc8a232ffec17a0509c73cdc3cc5da82cc0c3b0" translate="yes" xml:space="preserve">
          <source>These constants are used as parameters for &lt;a href=&quot;#time.clock_getres&quot;&gt;&lt;code&gt;clock_getres()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.clock_gettime&quot;&gt;&lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些常量用作&lt;a href=&quot;#time.clock_getres&quot;&gt; &lt;code&gt;clock_getres()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#time.clock_gettime&quot;&gt; &lt;code&gt;clock_gettime()&lt;/code&gt; 的参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f706a07e280b246aec2eb24a7a6cf4e80c4fad0" translate="yes" xml:space="preserve">
          <source>These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams to indicate the byte order used, and in UTF-8 as a Unicode signature. &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; depending on the platform&amp;rsquo;s native byte order, &lt;a href=&quot;#codecs.BOM&quot;&gt;&lt;code&gt;BOM&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codecs.BOM_LE&quot;&gt;&lt;code&gt;BOM_LE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.BOM_BE&quot;&gt;&lt;code&gt;BOM_BE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt;. The others represent the BOM in UTF-8 and UTF-32 encodings.</source>
          <target state="translated">这些常量定义了各种字节序列，它们是用于几种编码的Unicode字节顺序标记（BOM）。在UTF-16和UTF-32数据流中使用它们来指示使用的字节顺序，在UTF-8中将它们用作Unicode签名。&lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt;要么&lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt;取决于平台的本机字节顺序，&lt;a href=&quot;#codecs.BOM&quot;&gt; &lt;code&gt;BOM&lt;/code&gt; &lt;/a&gt;是一个别名&lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#codecs.BOM_LE&quot;&gt; &lt;code&gt;BOM_LE&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#codecs.BOM_BE&quot;&gt; &lt;code&gt;BOM_BE&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt;。其他代表UTF-8和UTF-32编码的BOM。</target>
        </trans-unit>
        <trans-unit id="11075a028b89f1287b800e88d2a70525b45b0b3e" translate="yes" xml:space="preserve">
          <source>These constants represent the address (and protocol) families, used for the first argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. If the &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; constant is not defined then this protocol is unsupported. More constants may be available depending on the system.</source>
          <target state="translated">这些常量表示地址（和协议）系列，用于&lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt;的第一个参数。如果未定义&lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt;常量，则不支持此协议。根据系统，可能会有更多的常量可用。</target>
        </trans-unit>
        <trans-unit id="3636a3cbc66bf8adda778cce9b23ca921f64aa56" translate="yes" xml:space="preserve">
          <source>These constants represent the socket types, used for the second argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. More constants may be available depending on the system. (Only &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; appear to be generally useful.)</source>
          <target state="translated">这些常量表示套接字类型，用于&lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt;的第二个参数。根据系统，可能会有更多的常量可用。（通常，只有&lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt;有用。）</target>
        </trans-unit>
        <trans-unit id="3850a5b66faf07220246584613141a4ed6ecd46e" translate="yes" xml:space="preserve">
          <source>These context managers may suppress exceptions just as they normally would if used directly as part of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">这些上下文管理器可以像平常直接将其用作&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句的一部分一样抑制异常。</target>
        </trans-unit>
        <trans-unit id="c5b59d1f5bf42fa2ad941913b587997df815979c" translate="yes" xml:space="preserve">
          <source>These context managers may suppress exceptions just as they normally would if used directly as part of a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd856ad1addbac2083c18edada1fee2ecb93a1c" translate="yes" xml:space="preserve">
          <source>These flags can be passed to &lt;a href=&quot;#os.memfd_create&quot;&gt;&lt;code&gt;memfd_create()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些标志可以传递给&lt;a href=&quot;#os.memfd_create&quot;&gt; &lt;code&gt;memfd_create()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d893a5018493b1ad1f01b4884c32e1257195fdf" translate="yes" xml:space="preserve">
          <source>These four classes process requests &lt;em&gt;synchronously&lt;/em&gt;; each request must be completed before the next request can be started. This isn&amp;rsquo;t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt;&lt;code&gt;ForkingMixIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; mix-in classes can be used to support asynchronous behaviour.</source>
          <target state="translated">这四个类&lt;em&gt;同步&lt;/em&gt;处理请求; 必须先完成每个请求，然后才能开始下一个请求。如果每个请求都需要很长时间才能完成，这是不合适的，因为它需要大量的计算，或者因为它返回了很多客户端处理缓慢的数据。解决方案是创建一个单独的进程或线程来处理每个请求。在&lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt; &lt;code&gt;ForkingMixIn&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt;混入物类可用于支持异步行为。</target>
        </trans-unit>
        <trans-unit id="72acb5b09128de39b246ae899d12597305851702" translate="yes" xml:space="preserve">
          <source>These functions accept either integers or single-character strings; when the argument is a string, it is first converted using the built-in function &lt;a href=&quot;functions#ord&quot;&gt;&lt;code&gt;ord()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些函数接受整数或单字符字符串。当参数是字符串时，首先使用内置函数&lt;a href=&quot;functions#ord&quot;&gt; &lt;code&gt;ord()&lt;/code&gt; 进行转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15117243b94d605b572f5691b43a112efe192336" translate="yes" xml:space="preserve">
          <source>These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">这些功能都执行一个新程序，以替换当前进程。他们不回来。在Unix上，新的可执行文件已加载到当前进程中，并且将具有与调用方相同的进程ID。错误将报告为&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="5b6139927d660d5e1dad5ec0f32107d8c628a1f2" translate="yes" xml:space="preserve">
          <source>These functions and data items provide information and operate on the current process and user.</source>
          <target state="translated">这些功能和数据项提供信息,并对当前进程和用户进行操作。</target>
        </trans-unit>
        <trans-unit id="65b2f130f9e56bca14a7379055f6e9bfc0f55b6b" translate="yes" xml:space="preserve">
          <source>These functions are all available on Linux only.</source>
          <target state="translated">这些功能仅在Linux上可用。</target>
        </trans-unit>
        <trans-unit id="4b7ea423186e1ad3686c673479b4eab2cfb592f4" translate="yes" xml:space="preserve">
          <source>These functions are described in &lt;a href=&quot;#os-file-dir&quot;&gt;Files and Directories&lt;/a&gt;.</source>
          <target state="translated">这些功能在&amp;ldquo; &lt;a href=&quot;#os-file-dir&quot;&gt;文件和目录&amp;rdquo;中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="0b95d0027dd729f2509f2876394ae457eb98ec95" translate="yes" xml:space="preserve">
          <source>These functions are used to retrieve resource usage information:</source>
          <target state="translated">这些功能用于检索资源使用信息。</target>
        </trans-unit>
        <trans-unit id="13a1f4f79e7d240a9400f9b84efbdcb7fe5617a9" translate="yes" xml:space="preserve">
          <source>These functions calculate a measure of how much the population or sample tends to deviate from the typical or average values.</source>
          <target state="translated">这些函数计算人口或样本偏离典型值或平均值的程度。</target>
        </trans-unit>
        <trans-unit id="c7e658bb4b32599c516696e577ad91941fcdf933" translate="yes" xml:space="preserve">
          <source>These functions calculate an average or typical value from a population or sample.</source>
          <target state="translated">这些函数从一个群体或样本中计算出一个平均值或典型值。</target>
        </trans-unit>
        <trans-unit id="a0ae98a3415f470fd255b1fc3b22d36ac3e83e02" translate="yes" xml:space="preserve">
          <source>These functions cannot be used with complex numbers; use the functions of the same name from the &lt;a href=&quot;cmath#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don&amp;rsquo;t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.</source>
          <target state="translated">这些函数不能与复数一起使用。如果需要支持复数，请使用&lt;a href=&quot;cmath#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; &lt;/a&gt;模块中的同名函数。由于大多数用户不想学习理解复数所需的数学知识，因此区分支持复数的函数和不支持复数的函数。通过接收异常而不是复杂的结果，可以更早地检测出用作参数的意外复数，以便程序员可以首先确定其生成方式和生成原因。</target>
        </trans-unit>
        <trans-unit id="54bc89086a46bb862ee0519c0f004dabc70edbc5" translate="yes" xml:space="preserve">
          <source>These functions control how a process is allocated CPU time by the operating system. They are only available on some Unix platforms. For more detailed information, consult your Unix manpages.</source>
          <target state="translated">这些功能控制操作系统如何分配进程的CPU时间。它们只在某些Unix平台上可用。更详细的信息,请查阅你的Unix手册。</target>
        </trans-unit>
        <trans-unit id="f9d98b250a452db69c03659fe4d2049d567fb07a" translate="yes" xml:space="preserve">
          <source>These functions create new &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. (See also &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; for opening file descriptors.)</source>
          <target state="translated">这些函数创建新的&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;。（有关&lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;文件描述符的信息，另请参见open（）。）</target>
        </trans-unit>
        <trans-unit id="8f604f19cecd1ba0c9a46f93d4cd24e19f43a25f" translate="yes" xml:space="preserve">
          <source>These functions create new &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. (See also &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; for opening file descriptors.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b3e1b34cce84fdb913bf10862151ad4e21d563" translate="yes" xml:space="preserve">
          <source>These functions expose the Windows registry API to Python. Instead of using an integer as the registry handle, a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt; is used to ensure that the handles are closed correctly, even if the programmer neglects to explicitly close them.</source>
          <target state="translated">这些函数将Windows注册表API公开给Python。使用&lt;a href=&quot;#handle-object&quot;&gt;句柄对象&lt;/a&gt;可以确保正确关闭了句柄，而不是使用整数作为注册表句柄，即使程序员忽略显式关闭它们也是如此。</target>
        </trans-unit>
        <trans-unit id="64ca6341c263d0eee46813e38f713dafca73d87a" translate="yes" xml:space="preserve">
          <source>These functions may be used to create and manage processes.</source>
          <target state="translated">这些功能可用于创建和管理流程。</target>
        </trans-unit>
        <trans-unit id="65e8df50f0bf89eb9f4d3f60786c6448bf4847aa" translate="yes" xml:space="preserve">
          <source>These functions operate on I/O streams referenced using file descriptors.</source>
          <target state="translated">这些函数对使用文件描述符引用的I/O流进行操作。</target>
        </trans-unit>
        <trans-unit id="62bfedde268bc00986bbe311ebb5f0786bf6963c" translate="yes" xml:space="preserve">
          <source>These functions provide access to some useful capabilities on Windows platforms. Some higher-level modules use these functions to build the Windows implementations of their services. For example, the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass&lt;/code&gt;&lt;/a&gt; module uses this in the implementation of the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">这些功能提供对Windows平台上某些有用功能的访问。一些更高级别的模块使用这些功能来构建其服务的Windows实现。例如，&lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass&lt;/code&gt; &lt;/a&gt;模块在&lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass()&lt;/code&gt; &lt;/a&gt;函数的实现中使用此方法。</target>
        </trans-unit>
        <trans-unit id="0280d48461c7d32aa95410598911229c46dae797" translate="yes" xml:space="preserve">
          <source>These functions return the corresponding hash objects for calculating BLAKE2b or BLAKE2s. They optionally take these general parameters:</source>
          <target state="translated">这些函数返回相应的哈希对象,用于计算BLAKE2b或BLAKE2s。它们可以选择使用这些通用参数。</target>
        </trans-unit>
        <trans-unit id="228f30ca6935d93886c690db3fc546e4320724bb" translate="yes" xml:space="preserve">
          <source>These functions should be avoided in Python 3, because they return encoded bytes. It&amp;rsquo;s much better to use alternatives which return Unicode strings instead, since most Python applications will want to manipulate human readable text as strings instead of bytes. Further, it&amp;rsquo;s possible that you may get unexpected Unicode-related exceptions if there are encoding problems with the translated strings.</source>
          <target state="translated">在Python 3中应避免使用这些函数，因为它们返回编码的字节。最好使用替代方法返回Unicode字符串，因为大多数Python应用程序都希望将人类可读文本作为字符串而不是字节来处理。此外，如果翻译后的字符串存在编码问题，则可能会出现与Unicode相关的意外异常。</target>
        </trans-unit>
        <trans-unit id="152b061e5d33249f6e76f6fd12669c7d70fbc3d2" translate="yes" xml:space="preserve">
          <source>These interfaces extend the &lt;code&gt;Node&lt;/code&gt; interface. They cannot have child nodes.</source>
          <target state="translated">这些接口扩展了 &lt;code&gt;Node&lt;/code&gt; 接口。他们不能有子节点。</target>
        </trans-unit>
        <trans-unit id="799c1f5dbfcbd19d6e5bb337ef29e540c95dfa79" translate="yes" xml:space="preserve">
          <source>These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt;&lt;code&gt;find_longest_match()&lt;/code&gt;&lt;/a&gt; method&amp;rsquo;s &lt;em&gt;isjunk&lt;/em&gt; parameter for an explanation.</source>
          <target state="translated">这些垃圾过滤功能可加快匹配速度以发现差异，并且不会导致任何不同的行或字符被忽略。阅读&lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt; &lt;code&gt;find_longest_match()&lt;/code&gt; &lt;/a&gt;方法的&lt;em&gt;isjunk&lt;/em&gt;参数的描述以获得解释。</target>
        </trans-unit>
        <trans-unit id="364d64d52986eda4fa8d78b737587ffa8380e1f3" translate="yes" xml:space="preserve">
          <source>These may not be available on all platforms when used with the &lt;code&gt;strftime()&lt;/code&gt; method. The ISO 8601 year and ISO 8601 week directives are not interchangeable with the year and week number directives above. Calling &lt;code&gt;strptime()&lt;/code&gt; with incomplete or ambiguous ISO 8601 directives will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当与 &lt;code&gt;strftime()&lt;/code&gt; 方法一起使用时，这些功能可能并非在所有平台上都可用。ISO 8601年和ISO 8601周指令与上面的年和周编号指令不可互换。使用不完整或不明确的ISO 8601指令调用 &lt;code&gt;strptime()&lt;/code&gt; 会引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cefa5663c6968d98cda435b00eb0b38f51c7e77" translate="yes" xml:space="preserve">
          <source>These methods are available on &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt;&lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">这些方法在&lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt; &lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt; &lt;/a&gt;对象上可用。</target>
        </trans-unit>
        <trans-unit id="5911df52a37a2f5a8a67b79ea06a439077506bd9" translate="yes" xml:space="preserve">
          <source>These methods are called by a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object, in response to their methods of the same names. A &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object passes itself as the argument, and a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object passes &lt;code&gt;None&lt;/code&gt; as the argument. A &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass&amp;rsquo;s methods should therefore be prepared to accept a &lt;em&gt;dt&lt;/em&gt; argument of &lt;code&gt;None&lt;/code&gt;, or of class &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些方法由&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;或时间对象调用，以响应它们的相同名称的方法。甲&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;对象本身传递作为参数，和一个&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;物体通过 &lt;code&gt;None&lt;/code&gt; 作为参数。一个&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt;的子类的方法，因此应准备接受一个&lt;em&gt;DT&lt;/em&gt;的说法 &lt;code&gt;None&lt;/code&gt; ，或者类的&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18aea1bbbb44bf54322bd21581fcc7fef2dcc544" translate="yes" xml:space="preserve">
          <source>These methods generate unique file names based upon the current process ID. When using multiple threads, undetected name clashes may occur and cause corruption of the mailbox unless threads are coordinated to avoid using these methods to manipulate the same mailbox simultaneously.</source>
          <target state="translated">这些方法会根据当前进程ID生成唯一的文件名。当使用多个线程时,可能会发生未检测到的名称冲突,并导致邮箱损坏,除非协调线程以避免同时使用这些方法来操作同一个邮箱。</target>
        </trans-unit>
        <trans-unit id="a460e54883612c01c96877b5d32c7a52f41e8cec" translate="yes" xml:space="preserve">
          <source>These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.</source>
          <target state="translated">这些方法会立即删除消息。没有使用MH的惯例,即在邮件名称前加一个逗号来标记要删除的邮件。</target>
        </trans-unit>
        <trans-unit id="5940fc3a6f4d0793d0ba67cd0795eb41381f9f36" translate="yes" xml:space="preserve">
          <source>These methods should be avoided in Python 3. See the warning for the &lt;a href=&quot;#gettext.lgettext&quot;&gt;&lt;code&gt;lgettext()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">在Python 3中应避免使用这些方法。请参见&lt;a href=&quot;#gettext.lgettext&quot;&gt; &lt;code&gt;lgettext()&lt;/code&gt; &lt;/a&gt;函数的警告。</target>
        </trans-unit>
        <trans-unit id="7b48daa7e8c1e0cff066d2e0a4920c8cbfbcd31c" translate="yes" xml:space="preserve">
          <source>These modified docstrings are created automatically together with the function definitions that are derived from the methods at import time.</source>
          <target state="translated">这些修改后的 docstrings 与导入时从方法中导出的函数定义一起自动创建。</target>
        </trans-unit>
        <trans-unit id="37a911174119b81cc68b901672ebc6a9480f0a44" translate="yes" xml:space="preserve">
          <source>These more infrequently used classes are similar to the TCP and UDP classes, but use Unix domain sockets; they&amp;rsquo;re not available on non-Unix platforms. The parameters are the same as for &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些不经常使用的类类似于TCP和UDP类，但是使用Unix域套接字。它们在非Unix平台上不可用。参数与&lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="1a0feedd3b398644d890b41707a8d3ab57269dc3" translate="yes" xml:space="preserve">
          <source>These must be implemented as class methods:</source>
          <target state="translated">这些必须作为类方法来实现。</target>
        </trans-unit>
        <trans-unit id="7cbdf0b741bfed107869c8df02810045e53d52c4" translate="yes" xml:space="preserve">
          <source>These objects also support being used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will automatically close them when done.</source>
          <target state="translated">这些对象还支持在&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;语句中使用，完成后将自动关闭它们。</target>
        </trans-unit>
        <trans-unit id="4e722b3425b184238de0635b8e8dcc0ea887357b" translate="yes" xml:space="preserve">
          <source>These objects also support being used in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will automatically close them when done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad08a7358df1d2a66eb1de7e37514f52255da7a" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt;, &lt;code&gt;excepthook&lt;/code&gt;, and &lt;code&gt;unraisablehook&lt;/code&gt; at the start of the program. They are saved so that &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt; and &lt;code&gt;excepthook&lt;/code&gt;, &lt;code&gt;unraisablehook&lt;/code&gt; can be restored in case they happen to get replaced with broken or alternative objects.</source>
          <target state="translated">这些对象包含的原始值 &lt;code&gt;breakpointhook&lt;/code&gt; ， &lt;code&gt;displayhook&lt;/code&gt; ， &lt;code&gt;excepthook&lt;/code&gt; 和 &lt;code&gt;unraisablehook&lt;/code&gt; 在节目的开始。它们被保存，以便 &lt;code&gt;breakpointhook&lt;/code&gt; ， &lt;code&gt;displayhook&lt;/code&gt; 和 &lt;code&gt;excepthook&lt;/code&gt; ， &lt;code&gt;unraisablehook&lt;/code&gt; 可以的情况下，恢复他们碰巧得到与损坏或替代物取代。</target>
        </trans-unit>
        <trans-unit id="6ca96d692b02c7b885bfcd6a1ee8049c02cbf749" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the &lt;code&gt;sys.std*&lt;/code&gt; object has been redirected.</source>
          <target state="translated">这些对象在程序开始时包含 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 的原始值。它们在完成过程中使用，并且无论是否已重定向 &lt;code&gt;sys.std*&lt;/code&gt; 对象，将其打印到实际的标准流都很有用。</target>
        </trans-unit>
        <trans-unit id="c79b4fd295e293df8d67f19b3b67a6719463f333" translate="yes" xml:space="preserve">
          <source>These options can be passed to &lt;a href=&quot;#mmap.mmap.madvise&quot;&gt;&lt;code&gt;mmap.madvise()&lt;/code&gt;&lt;/a&gt;. Not every option will be present on every system.</source>
          <target state="translated">这些选项可以传递给&lt;a href=&quot;#mmap.mmap.madvise&quot;&gt; &lt;code&gt;mmap.madvise()&lt;/code&gt; &lt;/a&gt;。并非每个选项都会出现在每个系统上。</target>
        </trans-unit>
        <trans-unit id="9926e9592428ba78a5e1b23082749828067c3a4d" translate="yes" xml:space="preserve">
          <source>These options may be repeated multiple times.</source>
          <target state="translated">这些选项可以重复多次。</target>
        </trans-unit>
        <trans-unit id="4d457330f80a34e6080d306cadcb1e3ad2dc2766" translate="yes" xml:space="preserve">
          <source>These options, along with all of the other options, are described in more detail in the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor documentation.</source>
          <target state="translated">这些选项以及所有其他选项在&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt;构造函数文档中有更详细的描述。</target>
        </trans-unit>
        <trans-unit id="1dc76ffa679003835a09fce6bfd595ccfec9bd93" translate="yes" xml:space="preserve">
          <source>These parsers do not support all the argparse features, and will raise exceptions if unsupported features are used. In particular, subparsers, &lt;code&gt;argparse.REMAINDER&lt;/code&gt;, and mutually exclusive groups that include both optionals and positionals are not supported.</source>
          <target state="translated">这些解析器不支持所有的argparse功能，如果使用了不受支持的功能，则会引发异常。特别是，不支持子解析器 &lt;code&gt;argparse.REMAINDER&lt;/code&gt; 以及同时包含可选和位置的互斥组。</target>
        </trans-unit>
        <trans-unit id="22dba5743cf8255132f82cfb61a9e3e78ed086d7" translate="yes" xml:space="preserve">
          <source>These prefabricated library loaders are available:</source>
          <target state="translated">这些预制的图书馆装载机都可以使用。</target>
        </trans-unit>
        <trans-unit id="4e92aef4b27a0b69320cf0a2f7f9c5efc2f4fd1c" translate="yes" xml:space="preserve">
          <source>These protocols are decorated with &lt;a href=&quot;#typing.runtime_checkable&quot;&gt;&lt;code&gt;runtime_checkable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef266eadbe60582ab001bde9ad9c46caee2dc9f" translate="yes" xml:space="preserve">
          <source>These restrictions are why picklable functions and classes must be defined in the top level of a module.</source>
          <target state="translated">这些限制是为什么可拾取的函数和类必须在模块的顶层定义。</target>
        </trans-unit>
        <trans-unit id="35bc8bcd8d7bb38d5e825c33344aa3d246936c4a" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward convenience in the most common use cases.</source>
          <target state="translated">这些语义上的差异是有意的,在最常见的用例中偏向于方便。</target>
        </trans-unit>
        <trans-unit id="2e9d492a24219c745ba294aeae2b21be77edbc2b" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward maximal convenience.</source>
          <target state="translated">这些语义上的差异是有意的,是偏向于最大限度的方便。</target>
        </trans-unit>
        <trans-unit id="390560ef8845b8bdb712a7c8bf8f16cdd1ae320d" translate="yes" xml:space="preserve">
          <source>These should be implemented as functions:</source>
          <target state="translated">这些都应该作为函数来实现。</target>
        </trans-unit>
        <trans-unit id="ceca439cc106eb947129c153f66b43d43dadf38e" translate="yes" xml:space="preserve">
          <source>These sizes are available as module &lt;a href=&quot;#constants&quot;&gt;constants&lt;/a&gt; described below.</source>
          <target state="translated">这些大小可用作下面描述的模块&lt;a href=&quot;#constants&quot;&gt;常数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48b7b72381b7aee41373544eef3f010c5c76d709" translate="yes" xml:space="preserve">
          <source>These standard library collections support parameterized generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800725d5ea46f65c695489e6472f9a85853adeb" translate="yes" xml:space="preserve">
          <source>These streams are regular &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;text files&lt;/a&gt; like those returned by the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. Their parameters are chosen as follows:</source>
          <target state="translated">这些流是常规&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;文本文件，&lt;/a&gt;如&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;函数返回的文本文件。它们的参数选择如下：</target>
        </trans-unit>
        <trans-unit id="85b6d6a6d2d948a358037771f7c838becde52be5" translate="yes" xml:space="preserve">
          <source>These streams are regular &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-file&quot;&gt;text files&lt;/a&gt; like those returned by the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. Their parameters are chosen as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34d0790d235872a36ccb0f116d30f629c65d5a7" translate="yes" xml:space="preserve">
          <source>These symbols define resources whose consumption can be controlled using the &lt;a href=&quot;#resource.setrlimit&quot;&gt;&lt;code&gt;setrlimit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#resource.getrlimit&quot;&gt;&lt;code&gt;getrlimit()&lt;/code&gt;&lt;/a&gt; functions described below. The values of these symbols are exactly the constants used by C programs.</source>
          <target state="translated">这些符号定义了资源的消耗，可以使用下面描述的&lt;a href=&quot;#resource.setrlimit&quot;&gt; &lt;code&gt;setrlimit()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#resource.getrlimit&quot;&gt; &lt;code&gt;getrlimit()&lt;/code&gt; &lt;/a&gt;函数来控制其消耗。这些符号的值恰好是C程序使用的常数。</target>
        </trans-unit>
        <trans-unit id="32d519f5749336b639a376599af558d7266a105d" translate="yes" xml:space="preserve">
          <source>These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; to enter the post-mortem debugger; see &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module for more information.)</source>
          <target state="translated">这三个变量并非总是定义的。当未处理异常且解释器打印错误消息和堆栈回溯时，将设置它们。它们的预期用途是允许交互式用户导入调试器模块并进行事后调试，而不必重新执行导致错误的命令。（通常使用 &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; 进入事后调试器；有关更多信息，请参见&lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt;模块。）</target>
        </trans-unit>
        <trans-unit id="19392b851464bd02aa15e872a0539674c54e509e" translate="yes" xml:space="preserve">
          <source>These time zones also support the &lt;a href=&quot;datetime#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute introduced in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0495&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 495&lt;/strong&gt;&lt;/a&gt;. During offset transitions which induce ambiguous times (such as a daylight saving time to standard time transition), the offset from &lt;em&gt;before&lt;/em&gt; the transition is used when &lt;code&gt;fold=0&lt;/code&gt;, and the offset &lt;em&gt;after&lt;/em&gt; the transition is used when &lt;code&gt;fold=1&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b700f59257d82022d76d6670b95dd0556a5db8f6" translate="yes" xml:space="preserve">
          <source>These tools and their built-in counterparts also work well with the high-speed functions in the &lt;a href=&quot;operator#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module. For example, the multiplication operator can be mapped across two vectors to form an efficient dot-product: &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt;.</source>
          <target state="translated">这些工具及其内置的对应工具也可以与&lt;a href=&quot;operator#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt;模块中的高速功能配合使用。例如，可以将乘法运算符映射到两个向量上以形成有效的点积： &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e77fbc4d220030bbcd6181d10d369921bab3851a" translate="yes" xml:space="preserve">
          <source>These tuples correspond to the C library &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt;, &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt;, and &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API calls used to prepare for the &lt;code&gt;posix_spawn()&lt;/code&gt; call itself.</source>
          <target state="translated">这些元组对应于C库 &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt; ， &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt; 和 &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API调用，用于准备 &lt;code&gt;posix_spawn()&lt;/code&gt; 调用本身。</target>
        </trans-unit>
        <trans-unit id="dbf6e0e647e0d38489bb73abd84ff4677afacaad" translate="yes" xml:space="preserve">
          <source>These two approaches both output:</source>
          <target state="translated">这两种方法都有输出。</target>
        </trans-unit>
        <trans-unit id="7c080ba8814228ce441c13011c88627af47951fe" translate="yes" xml:space="preserve">
          <source>These two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).</source>
          <target state="translated">这两个常量如果被定义,可以与套接字类型相结合,并允许你原子地设置一些标志(从而避免可能的竞赛条件和需要单独调用)。</target>
        </trans-unit>
        <trans-unit id="3a39e6e21e19b9d8817c24d832895a8746655153" translate="yes" xml:space="preserve">
          <source>These two make it possible to view the heap as a regular Python list without surprises: &lt;code&gt;heap[0]&lt;/code&gt; is the smallest item, and &lt;code&gt;heap.sort()&lt;/code&gt; maintains the heap invariant!</source>
          <target state="translated">这两个使得可以将堆作为常规Python列表查看而不会感到惊讶： &lt;code&gt;heap[0]&lt;/code&gt; 是最小的项，而 &lt;code&gt;heap.sort()&lt;/code&gt; 保持堆不变！</target>
        </trans-unit>
        <trans-unit id="164431ebbd6018da434ddafc8673fa593bda252e" translate="yes" xml:space="preserve">
          <source>These two values (measured in number of bytes) control when the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;protocol.pause_writing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt;&lt;code&gt;protocol.resume_writing()&lt;/code&gt;&lt;/a&gt; methods are called. If specified, the low watermark must be less than or equal to the high watermark. Neither &lt;em&gt;high&lt;/em&gt; nor &lt;em&gt;low&lt;/em&gt; can be negative.</source>
          <target state="translated">这两个值（以字节数为单位）控制何时调用协议的&lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;protocol.pause_writing()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt; &lt;code&gt;protocol.resume_writing()&lt;/code&gt; &lt;/a&gt;方法。如果指定，则低水印必须小于或等于高水印。无论是&lt;em&gt;高&lt;/em&gt;还是&lt;em&gt;低&lt;/em&gt;可以为负。</target>
        </trans-unit>
        <trans-unit id="574630dc61934cf9f92e574ac1641bd851cae54b" translate="yes" xml:space="preserve">
          <source>These type aliases correspond to the return types from &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;re#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt;. These types (and the corresponding functions) are generic in &lt;code&gt;AnyStr&lt;/code&gt; and can be made specific by writing &lt;code&gt;Pattern[str]&lt;/code&gt;, &lt;code&gt;Pattern[bytes]&lt;/code&gt;, &lt;code&gt;Match[str]&lt;/code&gt;, or &lt;code&gt;Match[bytes]&lt;/code&gt;.</source>
          <target state="translated">这些类型别名对应于&lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;re#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt;的返回类型。这些类型（以及相应的函数）在 &lt;code&gt;AnyStr&lt;/code&gt; 中是通用的，可以通过编写 &lt;code&gt;Pattern[str]&lt;/code&gt; ， &lt;code&gt;Pattern[bytes]&lt;/code&gt; ， &lt;code&gt;Match[str]&lt;/code&gt; 或 &lt;code&gt;Match[bytes]&lt;/code&gt; 使其变得特定。</target>
        </trans-unit>
        <trans-unit id="6c8845c2683fe62464e3412e8c25d2712718fdbe" translate="yes" xml:space="preserve">
          <source>These type aliases correspond to the return types from &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;re#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt;. These types (and the corresponding functions) are generic in &lt;code&gt;AnyStr&lt;/code&gt; and can be made specific by writing &lt;code&gt;Pattern[str]&lt;/code&gt;, &lt;code&gt;Pattern[bytes]&lt;/code&gt;, &lt;code&gt;Match[str]&lt;/code&gt;, or &lt;code&gt;Match[bytes]&lt;/code&gt;. These types are also in the &lt;code&gt;typing.re&lt;/code&gt; namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dff30429da744e3abeb83ca67b97f13e80951a" translate="yes" xml:space="preserve">
          <source>These uses have different requirements, and it is important to distinguish them. In particular, filling your docstrings with obscure test cases makes for bad documentation.</source>
          <target state="translated">这些用途有不同的要求,区分它们很重要。特别是,用晦涩的测试用例来填充你的 docstrings 会使文档变得糟糕。</target>
        </trans-unit>
        <trans-unit id="77174f1e7631bf4075a0d95eafd9f3a93f86cee8" translate="yes" xml:space="preserve">
          <source>These values are not designed to be exposed to end-users; for user facing elements, applications should use something like CLDR (the Unicode Common Locale Data Repository) to get more user-friendly strings. See also the cautionary note on &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt;&lt;code&gt;ZoneInfo.key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f38c67d7afb9e3ad667bc8f7a956cfa60d4f17" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt;, respectively.</source>
          <target state="translated">它们分别写为 &lt;code&gt;False&lt;/code&gt; 和 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90b1fe661130f08bec50f79a318e33e031b7d747" translate="yes" xml:space="preserve">
          <source>They must have since the parser can&amp;rsquo;t tell the type of the operands.</source>
          <target state="translated">因为解析器无法分辨操作数的类型，所以它们必须具有。</target>
        </trans-unit>
        <trans-unit id="560fa1e47346eab1954f144c298efe7129116f9d" translate="yes" xml:space="preserve">
          <source>Third-party event loops can use their own subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for interoperability. In this case, the result type is a subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">第三方事件循环可以使用其自己的&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;子类来实现互操作性。在这种情况下，结果类型是&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="6885413c3edcf4b3482d003002d40466d1c7529c" translate="yes" xml:space="preserve">
          <source>Third-party event loops implementations might not support custom child watchers. For such event loops, using &lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt;&lt;code&gt;set_child_watcher()&lt;/code&gt;&lt;/a&gt; might be prohibited or have no effect.</source>
          <target state="translated">第三方事件循环实现可能不支持自定义子观察者。对于此类事件循环，可能会禁止使用&lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt; &lt;code&gt;set_child_watcher()&lt;/code&gt; &lt;/a&gt;或无效。</target>
        </trans-unit>
        <trans-unit id="d6d33edc8f37f7925e4e4194d0d68db3b29628f3" translate="yes" xml:space="preserve">
          <source>Third-party library with expanded time zone and parsing support.</source>
          <target state="translated">具有扩展时区和解析支持的第三方库。</target>
        </trans-unit>
        <trans-unit id="537a50311943cfeb994000528b2810d2698fd99b" translate="yes" xml:space="preserve">
          <source>Third-party unittest framework with a lighter-weight syntax for writing tests. For example, &lt;code&gt;assert func(10) == 42&lt;/code&gt;.</source>
          <target state="translated">第三方单元测试框架，用于编写测试的语法较轻。例如， &lt;code&gt;assert func(10) == 42&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3b9ee4043cb6de20c067db3fc4ab5a88de0e0da" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; class method returns bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">此&lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;类方法返回bytearray对象，并解码给定的字符串对象。该字符串每个字节必须包含两个十六进制数字，而ASCII空格将被忽略。</target>
        </trans-unit>
        <trans-unit id="9f39db7a12ab223e5060700f28e89f71e712b838" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">此&lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;类方法返回一个bytes对象，对给定的字符串对象进行解码。该字符串每个字节必须包含两个十六进制数字，而ASCII空格将被忽略。</target>
        </trans-unit>
        <trans-unit id="25c5a3603bbf6dde0a60e8a1166341e81b90d9ce" translate="yes" xml:space="preserve">
          <source>This C function is able to make calls into other C modules, including the C functions that make up the Tk library. Tk is implemented in C and some Tcl. The Tcl part of the Tk widgets is used to bind certain default behaviors to widgets, and is executed once at the point where the Python &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package is imported. (The user never sees this stage).</source>
          <target state="translated">此C函数能够调用其他C模块，包括构成Tk库的C函数。Tk在C和某些Tcl中实现。Tk小部件的Tcl部分用于将某些默认行为绑定到小部件，并在导入Python &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt;包时执行一次。（用户永远不会看到此阶段）。</target>
        </trans-unit>
        <trans-unit id="1d6579a392f5cf7ff657ccc443a5878443ad506e" translate="yes" xml:space="preserve">
          <source>This ExampleService demo can be invoked from the command line:</source>
          <target state="translated">这个ExampleService演示可以从命令行调用。</target>
        </trans-unit>
        <trans-unit id="66603e0f2e17db55d8047fa37dc46cc24b89b2cc" translate="yes" xml:space="preserve">
          <source>This Life Preserver was written by Matt Conway at the University of Virginia.</source>
          <target state="translated">这个生命保护者是由弗吉尼亚大学的马特-康威撰写的。</target>
        </trans-unit>
        <trans-unit id="ff67911a0956c12902ae446cfb25b06222d6404b" translate="yes" xml:space="preserve">
          <source>This RFC defined the encoding of data which was XDR at the time this module was originally written. It has apparently been obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">该RFC定义了最初编写该模块时数据的编码方式，即XDR。显然它已被&lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832&lt;/strong&gt;&lt;/a&gt;淘汰。</target>
        </trans-unit>
        <trans-unit id="842c2f73983d293e723e4d1bf4e9d2c64a72c57e" translate="yes" xml:space="preserve">
          <source>This Request For Comments includes the rules for joining an absolute and a relative URL, including a fair number of &amp;ldquo;Abnormal Examples&amp;rdquo; which govern the treatment of border cases.</source>
          <target state="translated">该征求意见书包括用于连接绝对URL和相对URL的规则，其中包括用于处理边境案件的相当数量的&amp;ldquo;异常示例&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="135088776289217c28423276fa3c4b5d93458f2e" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;clearscreen&lt;/code&gt;. The global function &lt;code&gt;clear&lt;/code&gt; is a different one derived from the Turtle method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">该TurtleScreen方法仅在名称 &lt;code&gt;clearscreen&lt;/code&gt; 下可用作全局函数。全局函数 &lt;code&gt;clear&lt;/code&gt; 是从Turtle方法 &lt;code&gt;clear&lt;/code&gt; 派生的另一函数。</target>
        </trans-unit>
        <trans-unit id="9a5c7fbfb12e64e80a50cd253b77207e3f8d1c22" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;onscreenclick&lt;/code&gt;. The global function &lt;code&gt;onclick&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">该TurtleScreen方法仅在名称 &lt;code&gt;onscreenclick&lt;/code&gt; 下可用作全局函数。全局函数 &lt;code&gt;onclick&lt;/code&gt; 是从Turtle方法 &lt;code&gt;onclick&lt;/code&gt; 派生的另一个函数。</target>
        </trans-unit>
        <trans-unit id="cbcf70844f55515130094216c6263e62345d52b8" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;resetscreen&lt;/code&gt;. The global function &lt;code&gt;reset&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">该TurtleScreen方法仅在名称 &lt;code&gt;resetscreen&lt;/code&gt; 下可用作全局函数。全局函数 &lt;code&gt;reset&lt;/code&gt; 是从Turtle方法 &lt;code&gt;reset&lt;/code&gt; 派生的另一个函数。</target>
        </trans-unit>
        <trans-unit id="4f4aceb05d95d7a494f76ab4488a09282ba3d5bb" translate="yes" xml:space="preserve">
          <source>This activates a special exception handler that will display detailed reports in the Web browser if any errors occur. If you&amp;rsquo;d rather not show the guts of your program to users of your script, you can have the reports saved to files instead, with code like this:</source>
          <target state="translated">这将激活一个特殊的异常处理程序，如果发生任何错误，该异常处理程序将在Web浏览器中显示详细的报告。如果您不希望向脚本用户显示程序的胆量，则可以使用以下代码将报告保存到文件中：</target>
        </trans-unit>
        <trans-unit id="943d36d8edb0b61bc7c78f04ba488758674799cf" translate="yes" xml:space="preserve">
          <source>This affects &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt;&lt;code&gt;getTestCaseNames()&lt;/code&gt;&lt;/a&gt; and all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">这会影响&lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt; &lt;code&gt;getTestCaseNames()&lt;/code&gt; &lt;/a&gt;和所有 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4c629e7d2eb45c1763b440d04e7b2f6f6d1af0f0" translate="yes" xml:space="preserve">
          <source>This affects all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">这会影响所有 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7e1a9d70f32008ed3c96c0e9a74a6e82daf6f746" translate="yes" xml:space="preserve">
          <source>This allows applications to get a suspend-aware monotonic clock without having to deal with the complications of &lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt;&lt;code&gt;CLOCK_REALTIME&lt;/code&gt;&lt;/a&gt;, which may have discontinuities if the time is changed using &lt;code&gt;settimeofday()&lt;/code&gt; or similar.</source>
          <target state="translated">这允许应用程序获得可感知暂停的单调时钟，而不必处理&lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt; &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; &lt;/a&gt;的复杂性，如果使用 &lt;code&gt;settimeofday()&lt;/code&gt; 或类似方法更改时间，则可能会出现中断。</target>
        </trans-unit>
        <trans-unit id="019306589ee6acae06fdeea2a2650ea3f4d68bd9" translate="yes" xml:space="preserve">
          <source>This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see &lt;a href=&quot;enum#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt; for an example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc2bd0016562761a167a94107ea18ecde7bcee3" translate="yes" xml:space="preserve">
          <source>This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see Enum for an example).</source>
          <target state="translated">这使得人们可以在一个实例上拥有活动的属性,并在类上拥有同名的虚拟属性(参见Enum的例子)。</target>
        </trans-unit>
        <trans-unit id="f35eea3e328469bbb9e12d321786f404340c6df4" translate="yes" xml:space="preserve">
          <source>This allows the intended cleanup up behaviour to be made explicit up front, rather than requiring a separate flag variable.</source>
          <target state="translated">这样就可以在前面明确预期的清理行为,而不是需要一个单独的标志变量。</target>
        </trans-unit>
        <trans-unit id="fca28bc4acec436ecfcdadf8513fc13af190b783" translate="yes" xml:space="preserve">
          <source>This allows the newly spawned Python interpreter to safely import the module and then run the module&amp;rsquo;s &lt;code&gt;foo()&lt;/code&gt; function.</source>
          <target state="translated">这使新产生的Python解释器可以安全地导入模块，然后运行模块的 &lt;code&gt;foo()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="57868094fc52a1cd6c9af993bb993a3e5544da0a" translate="yes" xml:space="preserve">
          <source>This allows you to use the shell filename completion to specify the test module. The file specified must still be importable as a module. The path is converted to a module name by removing the &amp;lsquo;.py&amp;rsquo; and converting path separators into &amp;lsquo;.&amp;rsquo;. If you want to execute a test file that isn&amp;rsquo;t importable as a module you should execute the file directly instead.</source>
          <target state="translated">这使您可以使用Shell文件名完成来指定测试模块。指定的文件必须仍然可以作为模块导入。通过删除&amp;ldquo; .py&amp;rdquo;并将路径分隔符转换为&amp;ldquo;。&amp;rdquo;，可将该路径转换为模块名称。如果要执行不可作为模块导入的测试文件，则应直接执行该文件。</target>
        </trans-unit>
        <trans-unit id="38d1a626d9c7a8c9eaba4801730692cd5ed50152" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to create a subtype of &lt;code&gt;Derived&lt;/code&gt; since it is an identity function at runtime, not an actual type:</source>
          <target state="translated">这也意味着不可能创建 &lt;code&gt;Derived&lt;/code&gt; 的子类型，因为它是运行时的标识函数，而不是实际类型：</target>
        </trans-unit>
        <trans-unit id="80557a359ae07843f1afe80a27523489463324a4" translate="yes" xml:space="preserve">
          <source>This applies to &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt;&lt;code&gt;assert_has_calls()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt;&lt;code&gt;assert_any_call()&lt;/code&gt;&lt;/a&gt;. When &lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing&lt;/a&gt;, it will also apply to method calls on the mock object.</source>
          <target state="translated">这适用于&lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt; &lt;code&gt;assert_has_calls()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt; &lt;code&gt;assert_any_call()&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing时&lt;/a&gt;，它也将应用于模拟对象上的方法调用。</target>
        </trans-unit>
        <trans-unit id="537b430af62b891eeb9751af6b5c80e259818d26" translate="yes" xml:space="preserve">
          <source>This approach has been first presented in &lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;a discussion on xmlrpc.com&lt;/a&gt;.</source>
          <target state="translated">最初&lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;在xmlrpc.com上的讨论中&lt;/a&gt;介绍了这种方法。</target>
        </trans-unit>
        <trans-unit id="fb8573037230d3969561b2945452190c58711f18" translate="yes" xml:space="preserve">
          <source>This approach is perhaps less convenient than employing nested &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt; for most use cases but also demonstrates a level of control over the synchronization.</source>
          <target state="translated">对于大多数用例而言，此方法可能不如采用嵌套的&lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;代理对象&lt;/a&gt;方便，但它还演示了对同步的控制级别。</target>
        </trans-unit>
        <trans-unit id="a12a4abb0591cce4c8aa99900d108da46a55a5b6" translate="yes" xml:space="preserve">
          <source>This arranges for a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception to be thrown into the wrapped coroutine on the next cycle of the event loop.</source>
          <target state="translated">这安排在事件循环的下一个周期将&lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt;异常引发到包装的协程中。</target>
        </trans-unit>
        <trans-unit id="e81de60ddc5e6cb663061f6459f34a67618bb9be" translate="yes" xml:space="preserve">
          <source>This asks the thread to terminate, and then waits for it to do so. Note that if you don&amp;rsquo;t call this before your application exits, there may be some records still left on the queue, which won&amp;rsquo;t be processed.</source>
          <target state="translated">这要求线程终止，然后等待它终止。请注意，如果您在应用程序退出之前未调用此命令，则队列中可能仍有一些记录，这些记录将不会被处理。</target>
        </trans-unit>
        <trans-unit id="d862b47fe45aa6e17de78d8754a167b3ff452f1d" translate="yes" xml:space="preserve">
          <source>This attribute contains a mapping of error code integers to two-element tuples containing a short and long message. For example, &lt;code&gt;{code: (shortmessage,
longmessage)}&lt;/code&gt;. The &lt;em&gt;shortmessage&lt;/em&gt; is usually used as the &lt;em&gt;message&lt;/em&gt; key in an error response, and &lt;em&gt;longmessage&lt;/em&gt; as the &lt;em&gt;explain&lt;/em&gt; key. It is used by &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt;&lt;code&gt;send_response_only()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt;&lt;code&gt;send_error()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">此属性包含错误代码整数到包含短消息和长消息的两个元素的元组的映射。例如， &lt;code&gt;{code: (shortmessage, longmessage)}&lt;/code&gt; 。的&lt;em&gt;短消息&lt;/em&gt;通常被用作所述&lt;em&gt;消息&lt;/em&gt;中的错误响应密钥，并且&lt;em&gt;longmessage&lt;/em&gt;作为&lt;em&gt;解释&lt;/em&gt;键。它用于由&lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt; &lt;code&gt;send_response_only()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt; &lt;code&gt;send_error()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="3265ec6de83e09f5a858d9d1321fb30470037593" translate="yes" xml:space="preserve">
          <source>This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string.</source>
          <target state="translated">这个属性包含了实例的实际值,对于整数和指针类型,它是一个整数,对于字符类型,它是一个单字符字节对象或字符串,对于字符指针类型,它是一个Python字节对象或字符串。对于整数和指针类型,它是一个整数,对于字符类型,它是一个单一的字符字节对象或字符串,对于字符指针类型,它是一个Python字节对象或字符串。</target>
        </trans-unit>
        <trans-unit id="ce1d216ac33ce7f92dd6899eec472d3df9018600" translate="yes" xml:space="preserve">
          <source>This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are &lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt;&lt;code&gt;assertSequenceEqual()&lt;/code&gt;&lt;/a&gt; (including all the sequence comparison methods that delegate to it), &lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt;&lt;code&gt;assertDictEqual()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt;&lt;code&gt;assertMultiLineEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性控制通过报告失败时的差异的assert方法来控制差异输出的最大长度。默认为80 * 8个字符。受此属性影响的断言方法为&lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt; &lt;code&gt;assertSequenceEqual()&lt;/code&gt; &lt;/a&gt;（包括委派给它的所有序列比较方法），&lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt; &lt;code&gt;assertDictEqual()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt; &lt;code&gt;assertMultiLineEqual()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b756a9463a6c4c6c113805675dfcd1ed425d592" translate="yes" xml:space="preserve">
          <source>This attribute has no effect if the traceback limit is &lt;code&gt;1&lt;/code&gt;. See the &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; function and &lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt;&lt;code&gt;Snapshot.traceback_limit&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">如果回溯限制为 &lt;code&gt;1&lt;/code&gt; ,则此属性无效。请参见&lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt; &lt;code&gt;Snapshot.traceback_limit&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="efb0d29d4166e46dd3615e90c15f7c9725a59567" translate="yes" xml:space="preserve">
          <source>This attribute is &lt;code&gt;None&lt;/code&gt; by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the &lt;code&gt;source&lt;/code&gt; keyword in various shells. That is, the immediately following token will be opened as a filename and input will be taken from that stream until EOF, at which point the &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.</source>
          <target state="translated">默认情况下，此属性为&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 。如果为它分配一个字符串，则该字符串将被识别为词法级包含请求，类似于各种shell中的 &lt;code&gt;source&lt;/code&gt; 关键字。也就是说，紧随其后的令牌将作为文件名打开，并且将从该流中获取输入，直到EOF，这时将调用该流的&lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;方法，并且输入源将再次成为原始输入流。源请求可以堆叠任何数量的深度。</target>
        </trans-unit>
        <trans-unit id="e56bfc00c2caadc75dfd2a7c48b1a839469727cd" translate="yes" xml:space="preserve">
          <source>This attribute is a &lt;a href=&quot;#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; (possibly of length 1) of generic types passed to the original &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__class_getitem__&quot;&gt;&lt;code&gt;__class_getitem__()&lt;/code&gt;&lt;/a&gt; of the generic container:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2994dd43b52b07e7e69d05397ea676fc07397b4c" translate="yes" xml:space="preserve">
          <source>This attribute is a flag which controls the interpretation of blanks in the window. When it is on, trailing blanks on each line are ignored; any cursor motion that would land the cursor on a trailing blank goes to the end of that line instead, and trailing blanks are stripped when the window contents are gathered.</source>
          <target state="translated">这个属性是一个标志,它控制了对窗口中空白的解释。当它开启时,每行的尾部空白会被忽略;任何会使光标落在尾部空白上的光标运动都会转到该行的末尾,并且当窗口内容被收集时,尾部空白会被删除。</target>
        </trans-unit>
        <trans-unit id="8ea2adbc6d1d9d5676b59f71f289e2286049808c" translate="yes" xml:space="preserve">
          <source>This attribute is a lazily computed tuple (possibly empty) of unique type variables found in &lt;code&gt;__args__&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0657bd69ee21a9f9148b59c9e8f837030cf6e4" translate="yes" xml:space="preserve">
          <source>This attribute is a tuple of classes that are considered when looking for base classes during method resolution.</source>
          <target state="translated">这个属性是在方法解析过程中寻找基类时考虑的类的元组。</target>
        </trans-unit>
        <trans-unit id="78c2006f554cfe40d6509a13774214ddca5bbec4" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.0g or newer.</source>
          <target state="translated">这个属性是不可用的,除非ssl模块是用OpenSSL 1.1.0g或更新的版本编译的。</target>
        </trans-unit>
        <trans-unit id="166affef6e28f80e71c9ea85c86be9204124b32a" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.1 or newer.</source>
          <target state="translated">这个属性是不可用的,除非ssl模块是用OpenSSL 1.1.1或更新的版本编译的。</target>
        </trans-unit>
        <trans-unit id="d549f5791df423d3f994ffbd043feb8576e017c0" translate="yes" xml:space="preserve">
          <source>This attribute is used by the &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; method; it is initialized from the first argument to the constructor, if present, or to &lt;code&gt;None&lt;/code&gt;, if absent.</source>
          <target state="translated">&lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt;方法使用此属性；它从第一个参数初始化为构造函数（如果存在），或者初始化为 &lt;code&gt;None&lt;/code&gt; （如果不存在）。</target>
        </trans-unit>
        <trans-unit id="d4130011af63fce83b7e1131abe74fced7d57bfb" translate="yes" xml:space="preserve">
          <source>This attribute points at the non-parameterized generic class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779ab2149480aad2f6fe229a1b14fecb93369fd5" translate="yes" xml:space="preserve">
          <source>This attribute should be set to a true value if the handler&amp;rsquo;s &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt;&lt;code&gt;_write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt;&lt;code&gt;_flush()&lt;/code&gt;&lt;/a&gt; are being used to communicate directly to the client, rather than via a CGI-like gateway protocol that wants the HTTP status in a special &lt;code&gt;Status:&lt;/code&gt; header.</source>
          <target state="translated">如果使用处理程序的&lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt; &lt;code&gt;_write()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt; &lt;code&gt;_flush()&lt;/code&gt; &lt;/a&gt;直接与客户端通信，而不是通过希望在特殊 &lt;code&gt;Status:&lt;/code&gt; 标头中使用HTTP状态的类似于CGI的网关协议，则将此属性设置为true值。</target>
        </trans-unit>
        <trans-unit id="81e7c664cabc787942b1a455028793b2341024c0" translate="yes" xml:space="preserve">
          <source>This attribute&amp;rsquo;s default value is true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but false in &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该属性的默认值在&lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 中&lt;/a&gt;为true，在&lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; 中为&lt;/a&gt; false 。</target>
        </trans-unit>
        <trans-unit id="f563e489bccd3156ff8203cb8818c4bd46df456e" translate="yes" xml:space="preserve">
          <source>This base class defines the following read-only properties:</source>
          <target state="translated">这个基类定义了以下只读属性。</target>
        </trans-unit>
        <trans-unit id="5540e595f1d0ce1ff248b688c117efa9d0c46875" translate="yes" xml:space="preserve">
          <source>This base class raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;. Subclasses may leave this method unimplemented.</source>
          <target state="translated">该基类引发&lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;。子类可能使此方法未实现。</target>
        </trans-unit>
        <trans-unit id="63a8a8b933d05fd353efb75eb303a3e9a79cadd5" translate="yes" xml:space="preserve">
          <source>This behaves exactly like &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;, except that it yields a 4-tuple &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt;, and it supports &lt;code&gt;dir_fd&lt;/code&gt;.</source>
          <target state="translated">它的行为与&lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt;完全一样，除了它产生一个四元组 &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt; ，并且它支持 &lt;code&gt;dir_fd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f89ee084a5c3fb6a9b18d5de21c78508c481f569" translate="yes" xml:space="preserve">
          <source>This behavior allows &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to be used as an &lt;em&gt;escape hatch&lt;/em&gt; when you need to mix dynamically and statically typed code.</source>
          <target state="translated">当您需要混合动态和静态类型的代码时，此行为允许将&lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt;用作&lt;em&gt;转义图案&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3b455e95c88343559228644a42667890d61597cf" translate="yes" xml:space="preserve">
          <source>This behavior can be customized by assigning to special attributes of the foreign function object.</source>
          <target state="translated">这种行为可以通过分配给外来函数对象的特殊属性来定制。</target>
        </trans-unit>
        <trans-unit id="a7379b341b2ba41615597b4e4d0b80854cab35ed" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the following handler attributes:</source>
          <target state="translated">这种行为由以下处理程序属性控制。</target>
        </trans-unit>
        <trans-unit id="957754b3567b9946eb2150398bc70e91ad0ce381" translate="yes" xml:space="preserve">
          <source>This behaviour may be overridden by setting &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt;, or &lt;em&gt;universal_newlines&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; as described in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; and &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;#frequently-used-arguments&quot;&gt;经常使用的参数&lt;/a&gt;和&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; 中&lt;/a&gt;所述，可以通过将&lt;em&gt;text&lt;/em&gt;，&lt;em&gt;encoding&lt;/em&gt;，&lt;em&gt;errors&lt;/em&gt;或&lt;em&gt;universal_newlines设置&lt;/em&gt;为 &lt;code&gt;True&lt;/code&gt; 来覆盖此行为。</target>
        </trans-unit>
        <trans-unit id="3e39c78a1690e05498b30b508c8ee358893459e4" translate="yes" xml:space="preserve">
          <source>This brings up another issue. It is relatively common to provide a default value of &lt;code&gt;None&lt;/code&gt; for members that will later be an object of a different type. &lt;code&gt;None&lt;/code&gt; would be useless as a spec because it wouldn&amp;rsquo;t let you access &lt;em&gt;any&lt;/em&gt; attributes or methods on it. As &lt;code&gt;None&lt;/code&gt; is &lt;em&gt;never&lt;/em&gt; going to be useful as a spec, and probably indicates a member that will normally of some other type, autospec doesn&amp;rsquo;t use a spec for members that are set to &lt;code&gt;None&lt;/code&gt;. These will just be ordinary mocks (well - MagicMocks):</source>
          <target state="translated">这带来了另一个问题。为成员提供默认值 &lt;code&gt;None&lt;/code&gt; 相对普遍，这些成员以后将成为不同类型的对象。 &lt;code&gt;None&lt;/code&gt; 会成为规范，因为它不会让您访问&lt;em&gt;任何&lt;/em&gt;属性或方法。由于 &lt;code&gt;None&lt;/code&gt; 被&lt;em&gt;永远&lt;/em&gt;将是有用的天赋，而且很可能表明，通常一些其他类型的，autospec不使用规范的被设置为成员的成员 &lt;code&gt;None&lt;/code&gt; 。这些只是普通的模拟游戏（嗯-MagicMocks）：</target>
        </trans-unit>
        <trans-unit id="a01ade15639ca8f0fb9908b5bc15eb94fe21614a" translate="yes" xml:space="preserve">
          <source>This call (say, for example, creating a button widget), is implemented in the &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package, which is written in Python. This Python function will parse the commands and the arguments and convert them into a form that makes them look as if they had come from a Tk script instead of a Python script.</source>
          <target state="translated">此调用（例如，创建按钮小部件）在用Python编写的&lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt;包中实现。该Python函数将解析命令和参数，并将其转换为某种形式，使它们看起来好像来自Tk脚本而不是Python脚本。</target>
        </trans-unit>
        <trans-unit id="2a3932daa8300dd15eb1238ca7766ace7be0b25b" translate="yes" xml:space="preserve">
          <source>This call decodes uuencoded file &lt;em&gt;in_file&lt;/em&gt; placing the result on file &lt;em&gt;out_file&lt;/em&gt;. If &lt;em&gt;out_file&lt;/em&gt; is a pathname, &lt;em&gt;mode&lt;/em&gt; is used to set the permission bits if the file must be created. Defaults for &lt;em&gt;out_file&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; are taken from the uuencode header. However, if the file specified in the header already exists, a &lt;a href=&quot;#uu.Error&quot;&gt;&lt;code&gt;uu.Error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">此调用对uuencoded文件&lt;em&gt;in_file进行&lt;/em&gt;解码，将结果放置在文件&lt;em&gt;out_file上&lt;/em&gt;。如果&lt;em&gt;out_file&lt;/em&gt;是路径名，如果必须创建文件，则使用&lt;em&gt;mode&lt;/em&gt;设置权限位。&lt;em&gt;out_file&lt;/em&gt;和&lt;em&gt;mode的&lt;/em&gt;默认值来自uuencode标头。但是，如果标头中指定的文件已经存在，&lt;a href=&quot;#uu.Error&quot;&gt; &lt;code&gt;uu.Error&lt;/code&gt; &lt;/a&gt;引发uu.Error。</target>
        </trans-unit>
        <trans-unit id="c674f16cfd26246b43950a59f15b8c54770ceded" translate="yes" xml:space="preserve">
          <source>This call will print in the standard output the information returned by &lt;a href=&quot;#sysconfig.get_platform&quot;&gt;&lt;code&gt;get_platform()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_python_version&quot;&gt;&lt;code&gt;get_python_version()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_path&quot;&gt;&lt;code&gt;get_path()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt;&lt;code&gt;get_config_vars()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此调用将在标准输出中打印&lt;a href=&quot;#sysconfig.get_platform&quot;&gt; &lt;code&gt;get_platform()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#sysconfig.get_python_version&quot;&gt; &lt;code&gt;get_python_version()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#sysconfig.get_path&quot;&gt; &lt;code&gt;get_path()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt; &lt;code&gt;get_config_vars()&lt;/code&gt; 返回的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6469546206837a94e51f0f2845bca660667742c" translate="yes" xml:space="preserve">
          <source>This can be achieved from the &lt;a href=&quot;#python-interface&quot;&gt;Python Interface&lt;/a&gt; with:</source>
          <target state="translated">这可以通过&lt;a href=&quot;#python-interface&quot;&gt;Python接口&lt;/a&gt;使用以下方法实现：</target>
        </trans-unit>
        <trans-unit id="9d1d697fe2b31a15d36e206e65de28f58571ea8c" translate="yes" xml:space="preserve">
          <source>This can be called multiple times.</source>
          <target state="translated">这可以多次调用。</target>
        </trans-unit>
        <trans-unit id="2b67e671a1c54666dadf6cd890333be68c8592ef" translate="yes" xml:space="preserve">
          <source>This can be especially problematic for the user to see if she&amp;rsquo;s using a proportional font to edit the file. That is why when your application does not need values with empty lines, you should consider disallowing them. This will make empty lines split keys every time. In the example above, it would produce two keys, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">对于用户来说，查看她是否使用比例字体来编辑文件可能尤其成问题。这就是为什么当您的应用程序不需要空行的值时，应该考虑禁止使用它们。这将使空行每次都拆分键。在上面的示例中，它将产生两个键， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a82ddd14e1f001ea8311d0bd0c24af21a7865d61" translate="yes" xml:space="preserve">
          <source>This can be used for safely evaluating strings containing Python values from untrusted sources without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.</source>
          <target state="translated">它可以用于安全地评估包含来自不受信任来源的 Python 值的字符串,而不需要自己去解析这些值。它不能评估任意复杂的表达式,例如涉及运算符或索引。</target>
        </trans-unit>
        <trans-unit id="a97c97150e89825c650323ea068e2c86fe1ae6b9" translate="yes" xml:space="preserve">
          <source>This can be used to build a shell for SQLite, as in the following example:</source>
          <target state="translated">这可以用来构建一个SQLite的shell,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="b9fd3ddc0879e99d9c02d07c898720ba4d93e0c4" translate="yes" xml:space="preserve">
          <source>This can be used to decode a JSON document from a string that may have extraneous data at the end.</source>
          <target state="translated">这可以用来从一个字符串中解码JSON文档,这个字符串的末尾可能有无关的数据。</target>
        </trans-unit>
        <trans-unit id="0497025141b27c807ca46930213e57d7c9800435" translate="yes" xml:space="preserve">
          <source>This can be used to make triple-quoted strings line up with the left edge of the display, while still presenting them in the source code in indented form.</source>
          <target state="translated">这可以用来使三引号的字符串与显示的左边缘对齐,同时在源代码中仍然以缩进的形式显示它们。</target>
        </trans-unit>
        <trans-unit id="62fbb7012806d21eb05599eae86ce39d18cddf93" translate="yes" xml:space="preserve">
          <source>This can be useful where you want to make a series of assertions that reuse the same object. Note that &lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt;&lt;code&gt;reset_mock()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; clear the return value, &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; or any child attributes you have set using normal assignment by default. In case you want to reset &lt;em&gt;return_value&lt;/em&gt; or &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt;, then pass the corresponding parameter as &lt;code&gt;True&lt;/code&gt;. Child mocks and the return value mock (if any) are reset as well.</source>
          <target state="translated">在您要进行一系列重用同一对象的断言时，这很有用。请注意，&lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt; &lt;code&gt;reset_mock()&lt;/code&gt; &lt;/a&gt;&lt;em&gt;不会&lt;/em&gt;清除返回值，&lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt;或您使用常规分配设置的任何子属性。如果您想重置&lt;em&gt;return_value&lt;/em&gt;或&lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt;，则将相应的参数传递为 &lt;code&gt;True&lt;/code&gt; 。子模拟和返回值模拟（如果有）也将重置。</target>
        </trans-unit>
        <trans-unit id="fc685bbf811c69a67bb2bc60d0369711e84128df" translate="yes" xml:space="preserve">
          <source>This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</source>
          <target state="translated">这可以是在调用mock时被调用的函数,也可以是一个迭代函数或一个异常(类或实例)。</target>
        </trans-unit>
        <trans-unit id="66804a317957a21867ce8e32ff07c321923752e6" translate="yes" xml:space="preserve">
          <source>This causes the module to behave as it does when initially imported. For example, &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; will be called on the first &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt; call (if &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t already been called), and &lt;em&gt;ident&lt;/em&gt; and other &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; parameters are reset to defaults.</source>
          <target state="translated">这导致模块的行为与最初导入时的行为相同。例如，&lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt;将在第一被呼叫&lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt;调用（如果&lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt;尚未被调用），和&lt;em&gt;IDENT&lt;/em&gt;等&lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt;的参数重置为默认值。</target>
        </trans-unit>
        <trans-unit id="17a078e1ca7ba133e471917a29a6b9a67bd6369b" translate="yes" xml:space="preserve">
          <source>This change is just syntactic sugar for any construct of the following form:</source>
          <target state="translated">这种变化只是对以下形式的任何构造的句法糖。</target>
        </trans-unit>
        <trans-unit id="20f0e4e7771296269c67abcb6e85f794dfe25cba" translate="yes" xml:space="preserve">
          <source>This class &lt;strong&gt;only&lt;/strong&gt; works with loaders that define &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; as control over what module type is used for the module is required. For those same reasons, the loader&amp;rsquo;s &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; method must return &lt;code&gt;None&lt;/code&gt; or a type for which its &lt;code&gt;__class__&lt;/code&gt; attribute can be mutated along with not using &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slots&lt;/a&gt;. Finally, modules which substitute the object placed into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; will not work as there is no way to properly replace the module references throughout the interpreter safely; &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if such a substitution is detected.</source>
          <target state="translated">此类&lt;strong&gt;仅&lt;/strong&gt;适用于将&lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt;定义为控制需要使用哪种模块类型的加载程序。出于同样的原因，加载器的&lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt;方法必须返回 &lt;code&gt;None&lt;/code&gt; 或可以对其 &lt;code&gt;__class__&lt;/code&gt; 属性进行更改且不使用&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slot的类型&lt;/a&gt;。最后，替换无法放入&lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 中&lt;/a&gt;的对象的模块将无法工作，因为无法安全地正确替换整个解释器中的模块引用；如果检测到这样的替换，则会引发&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac439cfa9809ee47c3e7d79677f27b5eb953b22d" translate="yes" xml:space="preserve">
          <source>This class &lt;strong&gt;only&lt;/strong&gt; works with loaders that define &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; as control over what module type is used for the module is required. For those same reasons, the loader&amp;rsquo;s &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; method must return &lt;code&gt;None&lt;/code&gt; or a type for which its &lt;code&gt;__class__&lt;/code&gt; attribute can be mutated along with not using &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-slots&quot;&gt;slots&lt;/a&gt;. Finally, modules which substitute the object placed into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; will not work as there is no way to properly replace the module references throughout the interpreter safely; &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if such a substitution is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e680d4b2bbf72f285c1df68c923cf072d3a40f63" translate="yes" xml:space="preserve">
          <source>This class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists.</source>
          <target state="translated">这个类作为列表对象的包装器。它是一个有用的基类,你可以继承你自己的列表类,覆盖现有的方法或添加新的方法。通过这种方式,人们可以为列表添加新的行为。</target>
        </trans-unit>
        <trans-unit id="1370cfdacaa0f9c4d0d1e1fcd0d6c3556803396d" translate="yes" xml:space="preserve">
          <source>This class attribute determines what happens when a custom failure message is passed as the msg argument to an assertXYY call that fails. &lt;code&gt;True&lt;/code&gt; is the default value. In this case, the custom message is appended to the end of the standard failure message. When set to &lt;code&gt;False&lt;/code&gt;, the custom message replaces the standard message.</source>
          <target state="translated">此类属性确定将自定义失败消息作为msg参数传递给失败的assertXYY调用时发生的情况。默认值为 &lt;code&gt;True&lt;/code&gt; 。在这种情况下，自定义消息将附加到标准失败消息的末尾。设置为 &lt;code&gt;False&lt;/code&gt; 时，自定义消息将替换标准消息。</target>
        </trans-unit>
        <trans-unit id="3288c0e4b6772fb834239a23818e745ac39e3d7b" translate="yes" xml:space="preserve">
          <source>This class attribute gives the exception raised by the test method. If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to &amp;ldquo;play fair&amp;rdquo; with the framework. The initial value of this attribute is &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类属性给出了test方法引发的异常。如果测试框架需要使用专门的异常（可能带有其他信息），则它必须将该异常子类化，以便与框架&amp;ldquo;公平竞争&amp;rdquo;。此属性的初始值为&lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="786df7dd07465af2e7bc8b322a7dd7be2995de77" translate="yes" xml:space="preserve">
          <source>This class builds on the &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt; class by storing the server address as instance variables named &lt;code&gt;server_name&lt;/code&gt; and &lt;code&gt;server_port&lt;/code&gt;. The server is accessible by the handler, typically through the handler&amp;rsquo;s &lt;code&gt;server&lt;/code&gt; instance variable.</source>
          <target state="translated">此类通过将服务器地址存储为名为 &lt;code&gt;server_name&lt;/code&gt; 和 &lt;code&gt;server_port&lt;/code&gt; 的实例变量来构建&lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt;类。处理程序通常可以通过处理程序的 &lt;code&gt;server&lt;/code&gt; 实例变量来访问服务器。</target>
        </trans-unit>
        <trans-unit id="a61b50fa9056bcc99d4dfaa7d5cc4c9f738f3886" translate="yes" xml:space="preserve">
          <source>This class can be used to create an HTML table (or a complete HTML file containing the table) showing a side by side, line by line comparison of text with inter-line and intra-line change highlights. The table can be generated in either full or contextual difference mode.</source>
          <target state="translated">该类可用于创建一个HTML表格(或包含该表格的完整HTML文件),显示文本的并排、逐行比较,并带有行间和行内变化高亮。该表格可以以完全或上下文差异模式生成。</target>
        </trans-unit>
        <trans-unit id="1a485c6be944a5121095f4313a2ac49f87922ce2" translate="yes" xml:space="preserve">
          <source>This class can be used to generate HTML calendars.</source>
          <target state="translated">这个类可以用来生成HTML日历。</target>
        </trans-unit>
        <trans-unit id="24117e29e79a5bae324849b9f5e3b8f11a5140c9" translate="yes" xml:space="preserve">
          <source>This class can be used to generate plain text calendars.</source>
          <target state="translated">该类可用于生成纯文本日历。</target>
        </trans-unit>
        <trans-unit id="a69c7233ae85db1ae66cdbf46d18176f63d3a972" translate="yes" xml:space="preserve">
          <source>This class can then be used as follows:</source>
          <target state="translated">这个类就可以按以下方式使用。</target>
        </trans-unit>
        <trans-unit id="11039fec5c3d2704158aa1016ef70969433af2d0" translate="yes" xml:space="preserve">
          <source>This class constructor creates an instance of a &amp;ldquo;statistics object&amp;rdquo; from a &lt;em&gt;filename&lt;/em&gt; (or list of filenames) or from a &lt;code&gt;Profile&lt;/code&gt; instance. Output will be printed to the stream specified by &lt;em&gt;stream&lt;/em&gt;.</source>
          <target state="translated">此类的构造函数根据&lt;em&gt;文件名&lt;/em&gt;（或文件名列表）或 &lt;code&gt;Profile&lt;/code&gt; 实例创建&amp;ldquo;统计对象&amp;rdquo;的实例。输出将被打印到stream指定的&lt;em&gt;流上&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="997df475040ccebecaae3cb4fcd72a5ae6e0b056" translate="yes" xml:space="preserve">
          <source>This class deals with parsing and interpreter state (the user&amp;rsquo;s namespace); it does not deal with input buffering or prompting or input file naming (the filename is always passed in explicitly). The optional &lt;em&gt;locals&lt;/em&gt; argument specifies the dictionary in which code will be executed; it defaults to a newly created dictionary with key &lt;code&gt;'__name__'&lt;/code&gt; set to &lt;code&gt;'__console__'&lt;/code&gt; and key &lt;code&gt;'__doc__'&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">此类处理解析和解释器状态（用户的名称空间）；它不处理输入缓冲或提示或输入文件命名（文件名始终显式传递）。可选的&lt;em&gt;locals&lt;/em&gt;参数指定将在其中执行代码的字典；它默认为新创建的字典，其键 &lt;code&gt;'__name__'&lt;/code&gt; 设置为 &lt;code&gt;'__console__'&lt;/code&gt; ，键 &lt;code&gt;'__doc__'&lt;/code&gt; 设置为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea6ff78f901f2fc6ecc7723c952f97db4d6143dc" translate="yes" xml:space="preserve">
          <source>This class defines the following properties, and thus values for the following may be passed in the constructor of any policy class:</source>
          <target state="translated">该类定义了以下属性,因此可以在任何策略类的构造函数中传递以下属性的值。</target>
        </trans-unit>
        <trans-unit id="62521481dfb6022d4e3553654487427b9e7ec310" translate="yes" xml:space="preserve">
          <source>This class derives from &lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt;&lt;code&gt;BaseCookie&lt;/code&gt;&lt;/a&gt; and overrides &lt;code&gt;value_decode()&lt;/code&gt; and &lt;code&gt;value_encode()&lt;/code&gt;. SimpleCookie supports strings as cookie values. When setting the value, SimpleCookie calls the builtin &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; to convert the value to a string. Values received from HTTP are kept as strings.</source>
          <target state="translated">此类从&lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt; &lt;code&gt;BaseCookie&lt;/code&gt; &lt;/a&gt;派生，并覆盖 &lt;code&gt;value_decode()&lt;/code&gt; 和 &lt;code&gt;value_encode()&lt;/code&gt; 。SimpleCookie支持将字符串作为Cookie值。设置值时，SimpleCookie调用内置的&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt;将值转换为字符串。从HTTP接收的值保留为字符串。</target>
        </trans-unit>
        <trans-unit id="31f80205c6eb10e35876f4bf787d88c5b1b59257" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#bz2.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;. If you need to decompress a multi-stream input with &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt;&lt;code&gt;BZ2Decompressor&lt;/code&gt;&lt;/a&gt;, you must use a new decompressor for each stream.</source>
          <target state="translated">与&lt;a href=&quot;#bz2.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt;不同，此类不会透明地处理包含多个压缩流的输入。如果需要使用&lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt; &lt;code&gt;BZ2Decompressor&lt;/code&gt; &lt;/a&gt;解压缩多流输入，则必须为每个流使用一个新的解压缩器。</target>
        </trans-unit>
        <trans-unit id="dd0facb251a427869a35ff99157b4dc88e7a7c37" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#lzma.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;. To decompress a multi-stream input with &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;, you must create a new decompressor for each stream.</source>
          <target state="translated">与&lt;a href=&quot;#lzma.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt;不同，此类不会透明地处理包含多个压缩流的输入。要使用&lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt;解压缩多流输入，必须为每个流创建一个新的解压缩器。</target>
        </trans-unit>
        <trans-unit id="874f644bbcdf96eb234234a971de4328d832635e" translate="yes" xml:space="preserve">
          <source>This class has custom assertion methods for inspecting bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa75e4118b76769ba47ad4be121a41b62ae457bf" translate="yes" xml:space="preserve">
          <source>This class has many &lt;code&gt;read_*()&lt;/code&gt; methods. Note that some of them raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; when the end of the connection is read, because they can return an empty string for other reasons. See the individual descriptions below.</source>
          <target state="translated">此类具有许多 &lt;code&gt;read_*()&lt;/code&gt; 方法。请注意，其中一些会在读取连接结束时引发&lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt;，因为它们可能由于其他原因而返回空字符串。请参阅下面的个别说明。</target>
        </trans-unit>
        <trans-unit id="80f48affba28f3bca43510cbebf5f583a8d03e11" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance must be created using the &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;wrap_bio()&lt;/code&gt;&lt;/a&gt; method. This method will create the &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance and bind it to a pair of BIOs. The &lt;em&gt;incoming&lt;/em&gt; BIO is used to pass data from Python to the SSL protocol instance, while the &lt;em&gt;outgoing&lt;/em&gt; BIO is used to pass data the other way around.</source>
          <target state="translated">此类没有公共构造函数。必须使用&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;wrap_bio()&lt;/code&gt; &lt;/a&gt;方法创建一个&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;实例。此方法将创建&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;实例并将其绑定到一对BIO。该&lt;em&gt;传入&lt;/em&gt; BIO用于从Python的数据传递到所述SSL协议实例，而&lt;em&gt;传出&lt;/em&gt; BIO用于围绕传递数据的其他方式。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d597fa762f6194a350ab0c738e09d5a34ddc0834" translate="yes" xml:space="preserve">
          <source>This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate &amp;ldquo;BIO&amp;rdquo; objects which are OpenSSL&amp;rsquo;s IO abstraction layer.</source>
          <target state="translated">此类在OpenSSL所实现的低级SSL对象之上实现接口。该对象捕获SSL连接的状态，但不提供任何网络IO本身。IO需要通过单独的&amp;ldquo; BIO&amp;rdquo;对象执行，这些对象是OpenSSL的IO抽象层。</target>
        </trans-unit>
        <trans-unit id="914712e8832275f17564086e782d3f6685437de0" translate="yes" xml:space="preserve">
          <source>This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread.</source>
          <target state="translated">这个类实现了条件变量对象。条件变量允许一个或多个线程等待,直到它们被另一个线程通知。</target>
        </trans-unit>
        <trans-unit id="878bdcd121b4b294dea82e17949c61b8c083f5ce" translate="yes" xml:space="preserve">
          <source>This class implements reentrant lock objects. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</source>
          <target state="translated">这个类实现了重入锁对象。一个重入锁必须由获取它的线程释放。一旦一个线程获得了一个重入锁,同一个线程可以在不阻塞的情况下再次获得它;线程每获得一次重入锁,就必须释放一次重入锁。</target>
        </trans-unit>
        <trans-unit id="f24265f6cb6b6c3d8739448c1ec326c1945fc991" translate="yes" xml:space="preserve">
          <source>This class implements semaphore objects. A semaphore manages an atomic counter representing the number of &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; calls minus the number of &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; calls, plus an initial value. The &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method blocks if necessary until it can return without making the counter negative. If not given, &lt;em&gt;value&lt;/em&gt; defaults to 1.</source>
          <target state="translated">此类实现信号量对象。信号量管理一个原子计数器，该计数器代表&lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;调用的数量减去&lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;调用的数量以及初始值。如果有必要，&lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;方法将阻塞直到可以返回而不会使计数器为负数。如果没有给出，&lt;em&gt;值&lt;/em&gt;默认为1。</target>
        </trans-unit>
        <trans-unit id="06f375996fb5283c367303d6d557ff26404aa722" translate="yes" xml:space="preserve">
          <source>This class implements temporary breakpoints, ignore counts, disabling and (re-)enabling, and conditionals.</source>
          <target state="translated">该类实现了临时断点、忽略计数、禁用和(重新)启用以及条件。</target>
        </trans-unit>
        <trans-unit id="ef8ab9b1f017689b8221855e12ddfb98f5fab5ae" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; interface by writing SAX events back into an XML document. In other words, using an &lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt;&lt;code&gt;XMLGenerator&lt;/code&gt;&lt;/a&gt; as the content handler will reproduce the original document being parsed. &lt;em&gt;out&lt;/em&gt; should be a file-like object which will default to &lt;em&gt;sys.stdout&lt;/em&gt;. &lt;em&gt;encoding&lt;/em&gt; is the encoding of the output stream which defaults to &lt;code&gt;'iso-8859-1'&lt;/code&gt;. &lt;em&gt;short_empty_elements&lt;/em&gt; controls the formatting of elements that contain no content: if &lt;code&gt;False&lt;/code&gt; (the default) they are emitted as a pair of start/end tags, if set to &lt;code&gt;True&lt;/code&gt; they are emitted as a single self-closed tag.</source>
          <target state="translated">此类通过将SAX事件写回到XML文档中来实现&lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;接口。换句话说，使用&lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt; &lt;code&gt;XMLGenerator&lt;/code&gt; &lt;/a&gt;作为内容处理程序将重现正在解析的原始文档。&lt;em&gt;out&lt;/em&gt;应该是类似文件的对象，默认为&lt;em&gt;sys.stdout&lt;/em&gt;。&lt;em&gt;encoding&lt;/em&gt;是输出流的编码，默认为 &lt;code&gt;'iso-8859-1'&lt;/code&gt; 。&lt;em&gt;short_empty_elements&lt;/em&gt;控制不包含任何内容的元素的格式：如果为 &lt;code&gt;False&lt;/code&gt; （默认值），则将它们作为一对开始/结束标签发出；如果设置为 &lt;code&gt;True&lt;/code&gt; ，则将它们作为单个自闭合标签发出。</target>
        </trans-unit>
        <trans-unit id="c98a08502c61e88276fa107a306b9bc8b9b51f82" translate="yes" xml:space="preserve">
          <source>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4 port (143) is used.</source>
          <target state="translated">此类实现实际的IMAP4协议。实例初始化时，将创建连接并确定协议版本（IMAP4或IMAP4rev1）。如果&lt;em&gt;主机&lt;/em&gt;没有指定， &lt;code&gt;''&lt;/code&gt; （本地主机）被使用。如果省略&lt;em&gt;端口&lt;/em&gt;，则使用标准IMAP4端口（143）。</target>
        </trans-unit>
        <trans-unit id="2f061eb8879697c7b6070feb82741ebb04708bc3" translate="yes" xml:space="preserve">
          <source>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4 port (143) is used. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0180b25a093580d58646f91f83b8f7e9cbab599d" translate="yes" xml:space="preserve">
          <source>This class implements the actual POP3 protocol. The connection is created when the instance is initialized. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard POP3 port (110) is used. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for the connection attempt (if not specified, the global default timeout setting will be used).</source>
          <target state="translated">此类实现实际的POP3协议。实例初始化时创建连接。如果省略&lt;em&gt;端口&lt;/em&gt;，则使用标准的POP3端口（110）。可选的&lt;em&gt;timeout&lt;/em&gt;参数指定连接尝试的超时时间（以秒为单位）（如果未指定，将使用全局默认超时设置）。</target>
        </trans-unit>
        <trans-unit id="3a79142561e96a9c93e4a6f25d9a885ccc0ed19a" translate="yes" xml:space="preserve">
          <source>This class implements the portion of the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; interface which allows the test runner to drive the test, but does not provide the methods which test code can use to check and report errors. This is used to create test cases using legacy test code, allowing it to be integrated into a &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;-based test framework.</source>
          <target state="translated">此类实现&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt;接口的一部分，该部分允许测试运行程序进行测试，但不提供测试代码可用来检查和报告错误的方法。这是用来创建使用旧的测试代码的测试用例，允许它被集成到一个&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt;为基础的测试框架。</target>
        </trans-unit>
        <trans-unit id="1b5d0a87fabd812ddac703c4acba87065679d185" translate="yes" xml:space="preserve">
          <source>This class is &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;not thread safe&lt;/a&gt;.</source>
          <target state="translated">此类&lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;不是线程安全的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99bb71c8691256ec79b26eef0240bf9f20850bd6" translate="yes" xml:space="preserve">
          <source>This class is a dictionary-like object whose keys are strings and whose values are &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt; instances. Note that upon setting a key to a value, the value is first converted to a &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt; containing the key and the value.</source>
          <target state="translated">此类是类似于字典的对象，其键是字符串，其值是&lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt;实例。请注意，在将键设置为值时，该值首先转换为包含键和值的&lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ca616b29a0013c8896bdb2f5eebfbd623fd044" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#asyncio.Handle&quot;&gt;&lt;code&gt;Handle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类是&lt;a href=&quot;#asyncio.Handle&quot;&gt; &lt;code&gt;Handle&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="bc1a4fba51c4143a764de9b3702c6dad4e57616d" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; that sets &lt;code&gt;wsgi.run_once&lt;/code&gt; to true, &lt;code&gt;wsgi.multithread&lt;/code&gt; to false, and &lt;code&gt;wsgi.multiprocess&lt;/code&gt; to true, and always uses &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; to obtain the necessary CGI streams and environment.</source>
          <target state="translated">这个类的子类&lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt;该套 &lt;code&gt;wsgi.run_once&lt;/code&gt; 为true， &lt;code&gt;wsgi.multithread&lt;/code&gt; 为假，并 &lt;code&gt;wsgi.multiprocess&lt;/code&gt; 为true，并且始终使用&lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt;，以获得必要的CGI流和环境。</target>
        </trans-unit>
        <trans-unit id="8380c0b548cc2e264460ea64612afb578b6a25a2" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;. It overrides the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;get_stdin()&lt;/code&gt;, &lt;code&gt;get_stderr()&lt;/code&gt;, &lt;code&gt;add_cgi_vars()&lt;/code&gt;, &lt;code&gt;_write()&lt;/code&gt;, and &lt;code&gt;_flush()&lt;/code&gt; methods to support explicitly setting the environment and streams via the constructor. The supplied environment and streams are stored in the &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;, and &lt;code&gt;environ&lt;/code&gt; attributes.</source>
          <target state="translated">此类是&lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt;的子类。它覆盖了&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;get_stdin()&lt;/code&gt; ， &lt;code&gt;get_stderr()&lt;/code&gt; ， &lt;code&gt;add_cgi_vars()&lt;/code&gt; ， &lt;code&gt;_write()&lt;/code&gt; ，和 &lt;code&gt;_flush()&lt;/code&gt; 方法来支持明确设置通过构造环境和溪流。提供的环境和流存储在 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; ， &lt;code&gt;stderr&lt;/code&gt; 和 &lt;code&gt;environ&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="e1548ced0e2c22f69a3171c551d6503b32f508fd" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;. It overrides the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;get_stdin()&lt;/code&gt;, &lt;code&gt;get_stderr()&lt;/code&gt;, &lt;code&gt;add_cgi_vars()&lt;/code&gt;, &lt;code&gt;_write()&lt;/code&gt;, and &lt;code&gt;_flush()&lt;/code&gt; methods to support explicitly setting the environment and streams via the constructor. The supplied environment and streams are stored in the &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;, and &lt;code&gt;environ&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e951623508bbecd101c96001b60f6dffab7df5d" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt;&lt;code&gt;SimpleHandler&lt;/code&gt;&lt;/a&gt; intended for use with software other than HTTP &amp;ldquo;origin servers&amp;rdquo;. If you are writing a gateway protocol implementation (such as CGI, FastCGI, SCGI, etc.) that uses a &lt;code&gt;Status:&lt;/code&gt; header to send an HTTP status, you probably want to subclass this instead of &lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt;&lt;code&gt;SimpleHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类是&lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt; &lt;code&gt;SimpleHandler&lt;/code&gt; &lt;/a&gt;的子类，旨在与HTTP&amp;ldquo;起源服务器&amp;rdquo;以外的软件一起使用。如果您正在编写使用 &lt;code&gt;Status:&lt;/code&gt; 标头发送HTTP状态的网关协议实现（例如CGI，FastCGI，SCGI等），则可能要对此子类化，而不是&lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt; &lt;code&gt;SimpleHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c92ecd5d85f70cf680d95261e8d2ae49751975a2" translate="yes" xml:space="preserve">
          <source>This class is an abstract subclass of &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;. To make practical use of the code you must subclass &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt;, providing meaningful &lt;a href=&quot;#asynchat.async_chat.collect_incoming_data&quot;&gt;&lt;code&gt;collect_incoming_data()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; methods. The &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt; methods can be used, although not all make sense in a message/response context.</source>
          <target state="translated">此类是&lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt;的抽象子类。要实际使用该代码，您必须将&lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; &lt;/a&gt;子类化，提供有意义的&lt;a href=&quot;#asynchat.async_chat.collect_incoming_data&quot;&gt; &lt;code&gt;collect_incoming_data()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt;方法。所述&lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt;方法可用于，虽然不是在消息/响应上下文的所有有意义。</target>
        </trans-unit>
        <trans-unit id="087906235606c3c8fcaffe0693c559a88547f320" translate="yes" xml:space="preserve">
          <source>This class is an abstraction of a URL request.</source>
          <target state="translated">这个类是一个URL请求的抽象。</target>
        </trans-unit>
        <trans-unit id="0c6a034b6a98360f469f65a28d42a14f807ea562" translate="yes" xml:space="preserve">
          <source>This class is deliberately simple, just an &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, &lt;a href=&quot;functions#vars&quot;&gt;&lt;code&gt;vars()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此类是故意简化的，只是具有可读字符串表示形式的&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;子类。如果您更喜欢具有类似dict的属性视图，则可以使用标准的Python习惯用法&lt;a href=&quot;functions#vars&quot;&gt; &lt;code&gt;vars()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a5fcd1581caf40e9e0df5f205f111b1168737d46" translate="yes" xml:space="preserve">
          <source>This class is designed to have a similar API to the &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt; class, but there are some notable differences:</source>
          <target state="translated">此类设计为具有与&lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt;类类似的API ，但有一些显着区别：</target>
        </trans-unit>
        <trans-unit id="548e5fba14e42ef23c63d6ed78e4af70b26ae4c7" translate="yes" xml:space="preserve">
          <source>This class is designed to sit between an &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; and the client application&amp;rsquo;s event handlers. By default, it does nothing but pass requests up to the reader and events on to the handlers unmodified, but subclasses can override specific methods to modify the event stream or the configuration requests as they pass through.</source>
          <target state="translated">此类设计为位于&lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt;与客户端应用程序的事件处理程序之间。默认情况下，它什么都不做，只是将请求传递到读取器，并将事件未经修改地传递到处理程序，但是子类可以覆盖特定的方法，以在事件流或配置请求通过时修改它们。</target>
        </trans-unit>
        <trans-unit id="efbe53f191c0337a6044ecda5cb8ff2affeb594f" translate="yes" xml:space="preserve">
          <source>This class is identical to HTTPServer but uses threads to handle requests by using the &lt;a href=&quot;socketserver#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt;. This is useful to handle web browsers pre-opening sockets, on which &lt;a href=&quot;#http.server.HTTPServer&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt; would wait indefinitely.</source>
          <target state="translated">此类与HTTPServer相同，但是使用线程通过&lt;a href=&quot;socketserver#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt;处理请求。这对于处理预打开套接字的Web浏览器很有用，&lt;a href=&quot;#http.server.HTTPServer&quot;&gt; &lt;code&gt;HTTPServer&lt;/code&gt; &lt;/a&gt;会无限期等待该套接字。</target>
        </trans-unit>
        <trans-unit id="782b34777524d6fe446584f87d0601af4116f199" translate="yes" xml:space="preserve">
          <source>This class is meant to be subclassed, with the subclass adding visitor methods.</source>
          <target state="translated">这个类是要被子类化的,子类要增加访问者方法。</target>
        </trans-unit>
        <trans-unit id="f0df1f01557aa8ffb4f27cded6abda03c3defe24" translate="yes" xml:space="preserve">
          <source>This class is normally only used if more precise control over profiling is needed than what the &lt;code&gt;cProfile.run()&lt;/code&gt; function provides.</source>
          <target state="translated">通常仅在需要对配置文件进行比 &lt;code&gt;cProfile.run()&lt;/code&gt; 函数提供的功能更精确的控制时，才使用此类。</target>
        </trans-unit>
        <trans-unit id="dedbc6f4178266f9137c0a6e0806aaa414d428e9" translate="yes" xml:space="preserve">
          <source>This class is parallel to &lt;a href=&quot;#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt;, but handles string input.</source>
          <target state="translated">此类与&lt;a href=&quot;#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; &lt;/a&gt;并行，但处理字符串输入。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
