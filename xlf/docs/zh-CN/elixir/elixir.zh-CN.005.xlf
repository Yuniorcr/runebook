<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="9bac89af66dd6a427b4aa3efe3deb03cf5a1fe14" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;kernel.specialforms&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir还具有始终导入的特殊形式，不能跳过。这些在&lt;a href=&quot;kernel.specialforms&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; 中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="f6faa91bfb900d671613a6ab47e73da0ae09fa34" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="translated">药剂还包括下面的双下划线格式五个特殊形式：&lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;检索有关当前环境编译时的信息，而&lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt;检索堆栈跟踪当前异常。</target>
        </trans-unit>
        <trans-unit id="243375bae75a446726d90d677eb7c983b489e516" translate="yes" xml:space="preserve">
          <source>Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given.</source>
          <target state="translated">Elixir还利用函数子句中的模式匹配和防护措施,在给出无效参数时提供清晰的错误信息。</target>
        </trans-unit>
        <trans-unit id="e898bf471d8f0d3097ac913073c090b0a995d7eb" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; to manipulate lists:</source>
          <target state="translated">Elixir还提供 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 操作列表：</target>
        </trans-unit>
        <trans-unit id="ac31c787a75befbe1897dbbb6fdd942221f00c86" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; as comparison operators:</source>
          <target state="translated">Elixir还提供 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;===&lt;/code&gt; ， &lt;code&gt;!==&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为比较运算符：</target>
        </trans-unit>
        <trans-unit id="969c208849fcc11446141a26b255b57b75a2b0ba" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;Reference&lt;/code&gt;, and &lt;code&gt;PID&lt;/code&gt; as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let&amp;rsquo;s take a look at some of the basic operators that go with our basic types.</source>
          <target state="translated">Elixir还提供 &lt;code&gt;Port&lt;/code&gt; ， &lt;code&gt;Reference&lt;/code&gt; 和 &lt;code&gt;PID&lt;/code&gt; 作为数据类型（通常在过程通信中使用），在讨论过程时，我们将对其进行快速介绍。现在，让我们看一下与基本类型一起使用的一些基本运算符。</target>
        </trans-unit>
        <trans-unit id="dd8a8082108a2f1897c7e7583cc32113fdc162fe" translate="yes" xml:space="preserve">
          <source>Elixir also provides anonymous functions. Anonymous functions allow us to store and pass executable code around as if it was an integer or a string. They are delimited by the keywords &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">Elixir还提供匿名功能。匿名函数使我们能够存储和传递可执行代码，就好像它是整数或字符串一样。它们由关键字 &lt;code&gt;fn&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分隔：</target>
        </trans-unit>
        <trans-unit id="f6f4bfc221320e14428c9be4379f06c74f568d51" translate="yes" xml:space="preserve">
          <source>Elixir also provides other data types that are built on top of the types listed above. Some of them are:</source>
          <target state="translated">Elixir还提供了建立在上述类型之上的其他数据类型。其中一些类型是:</target>
        </trans-unit>
        <trans-unit id="9cf0686be60034d3cedafe5362a85407c3741f2a" translate="yes" xml:space="preserve">
          <source>Elixir also provides ranges:</source>
          <target state="translated">伊莱克斯还提供范围。</target>
        </trans-unit>
        <trans-unit id="5fcce84b0f48ff34d06fe32176864fe647eb61ef" translate="yes" xml:space="preserve">
          <source>Elixir also provides three boolean operators: &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;. These operators are strict in the sense that they expect something that evaluates to a boolean (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) as their first argument:</source>
          <target state="translated">Elixir还提供了三个布尔运算符： &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; 而 &lt;code&gt;not&lt;/code&gt; 。这些运算符是严格意义上的，因为它们期望将第一个参数评估为布尔值（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8d3fab2e2b3e4ed4bda1748059118a3b75cf1e13" translate="yes" xml:space="preserve">
          <source>Elixir also supports &lt;code&gt;left not in right&lt;/code&gt;, which evaluates to &lt;code&gt;not(left in right)&lt;/code&gt;:</source>
          <target state="translated">Elixir还支持 &lt;code&gt;left not in right&lt;/code&gt; ，其结果为 &lt;code&gt;not(left in right)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5a36737e425de601f0dbbe73bf7e68eed9cd0ed3" translate="yes" xml:space="preserve">
          <source>Elixir also supports Unicode in identifiers since Elixir v1.5, as defined in the &lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode Annex #31&lt;/a&gt;. The focus of this document is to describe how Elixir implements the requirements outlined in the Unicode Annex. These requirements are referred to as R1, R6 and so on.</source>
          <target state="translated">从Elixir v1.5开始，Elixir还支持标识符中的&lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode&lt;/a&gt;（如Unicode附件＃31中所定义）。本文档的重点是描述Elixir如何实现Unicode附件中概述的要求。这些要求称为R1，R6等。</target>
        </trans-unit>
        <trans-unit id="831831bd1adbcc4e3da08a8f57e2923a4e93799a" translate="yes" xml:space="preserve">
          <source>Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following:</source>
          <target state="translated">Elixir还支持一种语法,如果调用的最后一个参数是关键字列表,那么可以跳过方括号。这意味着,下面的。</target>
        </trans-unit>
        <trans-unit id="51de5cd58455d962f06640f299cca5e324e9a622" translate="yes" xml:space="preserve">
          <source>Elixir also supports private macros via &lt;code&gt;defmacrop&lt;/code&gt;. As private functions, these macros are only available inside the module that defines them, and only at compilation time.</source>
          <target state="translated">Elixir还通过 &lt;code&gt;defmacrop&lt;/code&gt; 支持私有宏。作为专用函数，这些宏仅在定义它们的模块内部可用，并且仅在编译时可用。</target>
        </trans-unit>
        <trans-unit id="f11824c210053777bec7ddf3a89c32be210d45f2" translate="yes" xml:space="preserve">
          <source>Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:</source>
          <target state="translated">Elixir还支持输入二进制、八进制和十六进制数字的快捷符号。</target>
        </trans-unit>
        <trans-unit id="6b48fb3c07925bbce80ec4c8c677ff0705ab892b" translate="yes" xml:space="preserve">
          <source>Elixir also supports string interpolation:</source>
          <target state="translated">Elixir还支持字符串插值。</target>
        </trans-unit>
        <trans-unit id="f27c2220090ae1ef4a23c356a5a485deee8ca35d" translate="yes" xml:space="preserve">
          <source>Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:</source>
          <target state="translated">Elixir只对最新的次要分支进行错误修复。最近5个次要分支都有安全补丁。</target>
        </trans-unit>
        <trans-unit id="1480fcb21427da507d41fe00e9730d3102cc1601" translate="yes" xml:space="preserve">
          <source>Elixir brings the concept of module attributes from Erlang. For example:</source>
          <target state="translated">Elixir从Erlang引入了模块属性的概念。例如:</target>
        </trans-unit>
        <trans-unit id="f52903a1f8e7fe32784dca96bfb06586e6419189" translate="yes" xml:space="preserve">
          <source>Elixir build information.</source>
          <target state="translated">Elixir构建信息。</target>
        </trans-unit>
        <trans-unit id="b2a6e08225deb1351d7c526d4a6fc2d20b9e7df8" translate="yes" xml:space="preserve">
          <source>Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:</source>
          <target state="translated">Elixir带有一个用于声明类型和规范的符号。Elixir是一种动态类型化的语言,因此,编译器从不使用类型规范来优化或修改代码。不过,使用类型规范还是很有用的,因为。</target>
        </trans-unit>
        <trans-unit id="93e98cb33410c274eb01c0b51b9f879f209f597d" translate="yes" xml:space="preserve">
          <source>Elixir converts switches to underscored atoms, so &lt;code&gt;--source-path&lt;/code&gt; becomes &lt;code&gt;:source_path&lt;/code&gt;. This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches.</source>
          <target state="translated">Elixir将开关转换为带下划线的原子，因此 &lt;code&gt;--source-path&lt;/code&gt; 变为 &lt;code&gt;:source_path&lt;/code&gt; 。这样做是为了更好地适应Elixir约定。但是，这意味着开关不能包含下划线，并且包含下划线的开关总是在无效开关列表中返回。</target>
        </trans-unit>
        <trans-unit id="515cdde695b80400042e85d03697fe8c3de3f321" translate="yes" xml:space="preserve">
          <source>Elixir deprecations happen in 3 steps:</source>
          <target state="translated">Elixir的废弃分三步走。</target>
        </trans-unit>
        <trans-unit id="7ea52283db054d97df43a259e29d9ebc73278a8f" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, etc.:</source>
          <target state="translated">Elixir开发人员在定义变量，函数名称，模块属性等时必须使用 &lt;code&gt;snake_case&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="67460a48d2b2975fa71d28207c9deda3618cb78d" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;This blog post&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="translated">Elixir开发人员通常在使用 &lt;code&gt;Map&lt;/code&gt; 时更喜欢使用 &lt;code&gt;map.field&lt;/code&gt; 语法和模式匹配而不是Map模块中的函数，因为它们会导致断言的编程风格。&lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;这篇博客文章&lt;/a&gt;提供了有关如何通过在Elixir中编写断言代码来获得更简洁，更快的软件的见解和示例。</target>
        </trans-unit>
        <trans-unit id="c6ccd31147a48e978a78387a61b5eaefec5c15c1" translate="yes" xml:space="preserve">
          <source>Elixir developers will often use module attributes as constants:</source>
          <target state="translated">Elixir开发人员经常会将模块属性作为常量。</target>
        </trans-unit>
        <trans-unit id="7edf337af4809fac0491b9f969182b600dc4a216" translate="yes" xml:space="preserve">
          <source>Elixir discourages the use of the &lt;code&gt;string()&lt;/code&gt; type. The &lt;code&gt;string()&lt;/code&gt; type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type &lt;code&gt;string()&lt;/code&gt;, Elixir will emit a warning. You should use &lt;code&gt;charlist()&lt;/code&gt;, &lt;code&gt;nonempty_charlist()&lt;/code&gt;, &lt;code&gt;binary()&lt;/code&gt; or &lt;code&gt;String.t()&lt;/code&gt; accordingly, or any of the several literal representations for these types.</source>
          <target state="translated">Elixir不鼓励使用 &lt;code&gt;string()&lt;/code&gt; 类型。的 &lt;code&gt;string()&lt;/code&gt; 类型指的Erlang字符串，这被称为在药剂&amp;ldquo;charlists&amp;rdquo;。它们不引用Elixir字符串，后者是UTF-8编码的二进制文件。为避免混淆，如果尝试使用 &lt;code&gt;string()&lt;/code&gt; 类型，Elixir将发出警告。您应该相应地使用 &lt;code&gt;charlist()&lt;/code&gt; ， &lt;code&gt;nonempty_charlist()&lt;/code&gt; ， &lt;code&gt;binary()&lt;/code&gt; 或 &lt;code&gt;String.t()&lt;/code&gt; 或这些类型的几种文字表示形式中的任何一种。</target>
        </trans-unit>
        <trans-unit id="d6df36f3b70e0d4fb5ddb48d10dbf25423b1cc5a" translate="yes" xml:space="preserve">
          <source>Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are:</source>
          <target state="translated">Elixir文件还包括 &quot;页面 &quot;部分的辅助文件。这些文件是:</target>
        </trans-unit>
        <trans-unit id="dfbdabad266a6ed24abe7282e3054447cc34c95a" translate="yes" xml:space="preserve">
          <source>Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the ones available at GitHub as a getting started point:</source>
          <target state="translated">Elixir的文档是用Markdown编写的。网上有很多关于Markdown的指南,我们推荐GitHub上的指南作为入门点。</target>
        </trans-unit>
        <trans-unit id="b8ad464d7c3f98c28d6c1301d748b4474f625349" translate="yes" xml:space="preserve">
          <source>Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. R1b is guaranteed for backwards compatibility purposes.</source>
          <target state="translated">Elixir不允许在标识符中使用ZWJ或ZWNJ,因此没有实现R1a。为了向后兼容,保证R1b。</target>
        </trans-unit>
        <trans-unit id="d746cd61df3db6f2fe47fafb3741869cc1431ba6" translate="yes" xml:space="preserve">
          <source>Elixir does not contain a function similar to &lt;code&gt;printf&lt;/code&gt; found in C and other languages. Luckily, the Erlang standard library functions &lt;code&gt;:io.format/2&lt;/code&gt; and &lt;code&gt;:io_lib.format/2&lt;/code&gt; may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from &lt;code&gt;printf&lt;/code&gt;, &lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;refer to the Erlang documentation for details&lt;/a&gt;.</source>
          <target state="translated">Elixir不包含类似于用C和其他语言找到的 &lt;code&gt;printf&lt;/code&gt; 的功能。幸运的是，可以使用Erlang标准库函数 &lt;code&gt;:io.format/2&lt;/code&gt; 和 &lt;code&gt;:io_lib.format/2&lt;/code&gt; 。第一种格式为终端输出，第二种格式为iolist。格式说明符与 &lt;code&gt;printf&lt;/code&gt; 不同，&lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;有关详细信息&lt;/a&gt;，请参见Erlang文档。</target>
        </trans-unit>
        <trans-unit id="979dd9d85c61d8b521a5dc2ef6b2263883c16c08" translate="yes" xml:space="preserve">
          <source>Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:</source>
          <target state="translated">Elixir有少量的保留属性。下面是其中几个最常用的属性。</target>
        </trans-unit>
        <trans-unit id="da143eaa5f18150282df48049071c1cc1a0e242a" translate="yes" xml:space="preserve">
          <source>Elixir has functions, like &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, that &lt;em&gt;only&lt;/em&gt; work with booleans, but also functions that work with these truthy/falsy values, like &lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir具有像&lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; 之&lt;/a&gt;类的函数，该函数&lt;em&gt;仅&lt;/em&gt;适用于布尔值，还具有与这些真实/虚假值一起使用的函数，如&lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#!/1&quot;&gt; &lt;code&gt;!/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88f2b25faa45986049480c976c00dd5855a6e36c" translate="yes" xml:space="preserve">
          <source>Elixir has three error mechanisms: errors, throws, and exits. In this chapter, we will explore each of them and include remarks about when each should be used.</source>
          <target state="translated">Elixir有三种错误机制:错误、抛出和退出。在这一章中,我们将对它们中的每一种进行探讨,并包括关于何时应该使用每一种机制的备注。</target>
        </trans-unit>
        <trans-unit id="0713d95ea58614452d3bd4a78be0cb70359f5d00" translate="yes" xml:space="preserve">
          <source>Elixir has three options for endianness: &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, and &lt;code&gt;native&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;:</source>
          <target state="translated">Elixir的字节序有三种选择： &lt;code&gt;big&lt;/code&gt; ， &lt;code&gt;little&lt;/code&gt; 和 &lt;code&gt;native&lt;/code&gt; 。默认值为 &lt;code&gt;big&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe30cf194fcc420b9fc8698a6260db192b62dfe9" translate="yes" xml:space="preserve">
          <source>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</source>
          <target state="translated">Elixir有两种函数调用的语法。有parens和无parens。默认情况下,Elixir会给所有调用添加parens,但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="5ea9e99a9db02305c5b70e98171ae53976e93c92" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are inferred by the runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="translated">Elixir是一种动态类型化的语言，因此Elixir中的所有类型均由运行时推断。但是，Elixir带有&lt;strong&gt;typespecs&lt;/strong&gt;，这是一种用于以下目的的符号：</target>
        </trans-unit>
        <trans-unit id="e56a48282c5929f27448e4f74f02e189acbe3204" translate="yes" xml:space="preserve">
          <source>Elixir is an extensible and very customizable programming language thanks to its meta-programming support. Most meta-programming in Elixir is done through macros, which are very useful in several situations, especially for writing DSLs. We have written a short guide that explains the basic mechanisms behind macros, shows how to write macros, and how to use macros to create DSLs:</source>
          <target state="translated">Elixir是一种可扩展的、非常可定制的编程语言,这要归功于它的元编程支持。在Elixir中,大部分元编程都是通过宏来完成的,宏在一些情况下非常有用,特别是对于编写DSL来说。我们写了一个简短的指南,解释了宏背后的基本机制,展示了如何编写宏,以及如何使用宏来创建DSL。</target>
        </trans-unit>
        <trans-unit id="63771eaf5ff6c9a6bd6258b28e240e5f31e971be" translate="yes" xml:space="preserve">
          <source>Elixir is an immutable language where nothing is shared by default. If we want to share information, which can be read and modified from multiple places, we have two main options in Elixir:</source>
          <target state="translated">Elixir是一种不可改变的语言,默认情况下没有任何东西是可以共享的。如果我们想共享信息,可以从多个地方读取和修改信息,在Elixir中我们有两个主要选项。</target>
        </trans-unit>
        <trans-unit id="52c491dbf300477fadaef34d4fecd5fbbc6358fa" translate="yes" xml:space="preserve">
          <source>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are &lt;em&gt;used&lt;/em&gt; by Elixir: for example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are used by Elixir for addition and boolean &lt;em&gt;or&lt;/em&gt;, but &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; is not used (but valid).</source>
          <target state="translated">Elixir能够解析一组预定义的运算符；这意味着不可能定义新的运算符（例如，可以在Haskell中进行定义）。但是，并非Elixir &lt;em&gt;使用&lt;/em&gt; Elixir可以解析的所有运算符：例如 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 。由Elixir用于加法和boolean &lt;em&gt;或&lt;/em&gt;，但不使用 &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; （但有效）。</target>
        </trans-unit>
        <trans-unit id="119a6b69354b723a3119d7eb9b274e46b1a606de" translate="yes" xml:space="preserve">
          <source>Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.</source>
          <target state="translated">Elixir目前是主要版本v1,每6个月会发布一个新的向后兼容的次要版本。补丁的发布不在计划之内,只要有错误修复或安全补丁就会发布。</target>
        </trans-unit>
        <trans-unit id="92e6a9f7e2024169f36143b3110efa2bf4ec167a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="translated">Elixir足够聪明，可以将分辨率延迟到最新的时刻。因此，如果您在引号内调用 &lt;code&gt;length([1, 2, 3])&lt;/code&gt; ，但没有&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;函数可用，那么它将在调用方中扩展：</target>
        </trans-unit>
        <trans-unit id="94be6db8aa623aad96175d2a4f009eb3d49d1f72" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to recompile only files that have changed and their dependencies. This means if &lt;code&gt;lib/a.ex&lt;/code&gt; is invoking a function defined over &lt;code&gt;lib/b.ex&lt;/code&gt;, whenever &lt;code&gt;lib/b.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; is also recompiled.</source>
          <target state="translated">Elixir足够聪明，可以仅重新编译已更改的文件及其依赖项。这意味着，如果 &lt;code&gt;lib/a.ex&lt;/code&gt; 调用了通过 &lt;code&gt;lib/b.ex&lt;/code&gt; 定义的函数，则每当 &lt;code&gt;lib/b.ex&lt;/code&gt; 更改时，也会重新编译 &lt;code&gt;lib/a.ex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a352a9b0a3e5c7519c223a1075bc3428e61e0561" translate="yes" xml:space="preserve">
          <source>Elixir is versioned according to a vMAJOR.MINOR.PATCH schema.</source>
          <target state="translated">Elixir根据vMAJOR.MINOR.PATCH模式进行版本调整。</target>
        </trans-unit>
        <trans-unit id="d990d24327822ea7a421e913e80e0202d0dfa1bb" translate="yes" xml:space="preserve">
          <source>Elixir macros have late resolution. This guarantees that a variable defined inside a quote won&amp;rsquo;t conflict with a variable defined in the context where that macro is expanded. For example:</source>
          <target state="translated">Elixir宏的解析度较晚。这样可以保证在引号内定义的变量不会与在该宏展开的上下文中定义的变量冲突。例如：</target>
        </trans-unit>
        <trans-unit id="6c0929a451e1f448275dcbe066bf77535364105c" translate="yes" xml:space="preserve">
          <source>Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions.</source>
          <target state="translated">Elixir的次要版本和补丁版本是向后兼容的:在特定版本中定义良好的行为和文档化的API将继续在未来的版本中工作。</target>
        </trans-unit>
        <trans-unit id="f4a72643c7a8a6ed5341995de6e14044af2a034d" translate="yes" xml:space="preserve">
          <source>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</source>
          <target state="translated">Elixir模块名称可以动态生成。这在使用宏时非常有用。例如,我们可以写道</target>
        </trans-unit>
        <trans-unit id="e063af00bef300726332e4ffbf98de73c83bdc5a" translate="yes" xml:space="preserve">
          <source>Elixir on Discord</source>
          <target state="translated">Elixir on Discord</target>
        </trans-unit>
        <trans-unit id="005e7c25a3d3787c9fd9aad492021fe09a8bd012" translate="yes" xml:space="preserve">
          <source>Elixir on Slack</source>
          <target state="translated">Elixir在Slack上</target>
        </trans-unit>
        <trans-unit id="6ec353d0b43e8fcc2bae198d8d18d71fc59a96c0" translate="yes" xml:space="preserve">
          <source>Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library.</source>
          <target state="translated">Elixir程序应该更倾向于尽可能接近最终用户的数据验证,这样错误很容易定位和修复。这种做法也省去了在库的内部编写防御性代码。</target>
        </trans-unit>
        <trans-unit id="34badf132890db803056b8a329274a11ed6c00d4" translate="yes" xml:space="preserve">
          <source>Elixir projects are usually organized into three directories:</source>
          <target state="translated">Elixir项目通常分为三个目录。</target>
        </trans-unit>
        <trans-unit id="bd498b5c0b475852faf005a008b3295d3968391d" translate="yes" xml:space="preserve">
          <source>Elixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text. We can access the documentation of any compiled module directly from IEx:</source>
          <target state="translated">Elixir提倡使用Markdown与heredocs来编写可读文档。Heredocs是多行字符串,它们以三个双引号开头和结尾,保留了内文的格式。我们可以直接从IEx中访问任何编译模块的文档。</target>
        </trans-unit>
        <trans-unit id="8cd089c42b27bd178061d32f4f832a4a6ee4ad2d" translate="yes" xml:space="preserve">
          <source>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library. Regexes also support modifiers. For example, the &lt;code&gt;i&lt;/code&gt; modifier makes a regular expression case insensitive:</source>
          <target state="translated">Elixir提供了由&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;库实现的Perl兼容正则表达式（regexes）。正则表达式还支持修饰符。例如， &lt;code&gt;i&lt;/code&gt; 修饰符使正则表达式不区分大小写：</target>
        </trans-unit>
        <trans-unit id="ea04f299ea8e7d138416f7682d04dace2f8332f3" translate="yes" xml:space="preserve">
          <source>Elixir provides a bunch of predicate functions to check for a value type. For example, the &lt;code&gt;is_boolean/1&lt;/code&gt; function can be used to check if a value is a boolean or not:</source>
          <target state="translated">Elixir提供了一堆谓词函数来检查值类型。例如， &lt;code&gt;is_boolean/1&lt;/code&gt; 函数可用于检查值是否为布尔值：</target>
        </trans-unit>
        <trans-unit id="f9d0324f32083b4357effd55af42179e669e80ba" translate="yes" xml:space="preserve">
          <source>Elixir provides a special and more concise syntax for keyword lists that looks like this:</source>
          <target state="translated">Elixir为关键字列表提供了一种特殊的、更简洁的语法,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="3fb7d8bf0ef1942795033493f666d84321055fe3" translate="yes" xml:space="preserve">
          <source>Elixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.</source>
          <target state="translated">Elixir提供了与Erlang库的良好互操作性。事实上,Elixir不鼓励简单地包装Erlang库,而是直接与Erlang代码进行接口。在本节中,我们将介绍一些在Elixir中找不到的最常见、最有用的Erlang功能。</target>
        </trans-unit>
        <trans-unit id="b3b982e7fff9bd521206b036c548d296e906492a" translate="yes" xml:space="preserve">
          <source>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.</source>
          <target state="translated">Elixir提供了宏,作为元编程(编写生成代码的代码)的一种机制。宏在编译时被扩展。</target>
        </trans-unit>
        <trans-unit id="2c38afe5476b8521de1ce73619db182fce82f5c4" translate="yes" xml:space="preserve">
          <source>Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below.</source>
          <target state="translated">Elixir 为使用 port 提供了许多便利,也有一些缺点。我们将在下文中探讨这些缺点。</target>
        </trans-unit>
        <trans-unit id="86797814ddc42c874f88a51b77e92d177f55b7bc" translate="yes" xml:space="preserve">
          <source>Elixir provides optional parentheses for non-qualified and qualified calls.</source>
          <target state="translated">Elixir为非限定和限定调用提供了可选的括号。</target>
        </trans-unit>
        <trans-unit id="ab1e334b03a647f5918bb69c761fab411cd3e870" translate="yes" xml:space="preserve">
          <source>Elixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like &lt;code&gt;var!/2&lt;/code&gt; and &lt;code&gt;alias!/1&lt;/code&gt;, although one must be careful when using those as they directly change the user environment.</source>
          <target state="translated">Elixir也提供了类似的导入和别名机制。这保证了宏将按照其源模块指定的方式运行，而不与扩展该宏的目标模块发生冲突。在特定情况下，可以使用 &lt;code&gt;var!/2&lt;/code&gt; 和 &lt;code&gt;alias!/1&lt;/code&gt; 这样的宏来绕过卫生措施，尽管在使用它们时会特别注意，因为它们会直接更改用户环境。</target>
        </trans-unit>
        <trans-unit id="7ee83992e184ceb0497492aa46813f6e12944aa3" translate="yes" xml:space="preserve">
          <source>Elixir provides the concept of enumerables and &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;the &lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt; to work with them. We have already learned two enumerables: lists and maps.</source>
          <target state="translated">Elixir提供了可枚举的概念和用于它们&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;的 &lt;code&gt;Enum&lt;/code&gt; 模块&lt;/a&gt;。我们已经学习了两个可枚举的对象：列表和地图。</target>
        </trans-unit>
        <trans-unit id="c38b66bd0f1f07df9af68419dad5d7545d3eb5b0" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators:</source>
          <target state="translated">Elixir提供了以下内置比较运算符。</target>
        </trans-unit>
        <trans-unit id="ac046d5521e866f330d69759ab8c6306ded55946" translate="yes" xml:space="preserve">
          <source>Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</source>
          <target state="translated">Elixir引号/解引号机制提供了一种称为解引号片段的功能。取消引号片段提供了一种简单的方法来快速生成函数。请看这个例子。</target>
        </trans-unit>
        <trans-unit id="8d30f35ec7987f572743e95ef255bb1ce5bee72e" translate="yes" xml:space="preserve">
          <source>Elixir relies on underscores in different situations.</source>
          <target state="translated">Elixir在不同的情况下依靠下划线。</target>
        </trans-unit>
        <trans-unit id="ecffee7d986ded673e3f20c49d26acf93d1febaf" translate="yes" xml:space="preserve">
          <source>Elixir represents &lt;code&gt;Foo.Bar&lt;/code&gt; as &lt;code&gt;__aliases__&lt;/code&gt; so calls can be unambiguously identified by the operator &lt;code&gt;:.&lt;/code&gt;. For example:</source>
          <target state="translated">Elixir将 &lt;code&gt;Foo.Bar&lt;/code&gt; 表示为 &lt;code&gt;__aliases__&lt;/code&gt; ,因此操作员可以清楚地标识呼叫 &lt;code&gt;:.&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="e6bdbab87b861494b0b9df9b50e56bb5cc5d2563" translate="yes" xml:space="preserve">
          <source>Elixir requires all atoms and variables to be in NFC form. Any other form will fail with a relevant error message. Quoted-atoms and strings can, however, be in any form and are not verified by the parser.</source>
          <target state="translated">Elixir要求所有原子和变量都是NFC形式。任何其他形式的原子和变量都会以相关错误信息的形式出现。然而,被引用的原子和字符串可以是任何形式的,并且不会被解析器验证。</target>
        </trans-unit>
        <trans-unit id="edacc18f14ad696b0fd9cee85daa785d105406a3" translate="yes" xml:space="preserve">
          <source>Elixir reserves the following module names: &lt;code&gt;Elixir&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;BitString&lt;/code&gt;, &lt;code&gt;PID&lt;/code&gt;, and &lt;code&gt;Reference&lt;/code&gt;.</source>
          <target state="translated">Elixir保留以下模块名称： &lt;code&gt;Elixir&lt;/code&gt; ， &lt;code&gt;Any&lt;/code&gt; ， &lt;code&gt;BitString&lt;/code&gt; ， &lt;code&gt;PID&lt;/code&gt; 和 &lt;code&gt;Reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a2a631e623ec7dcc0aeb7c643dc24be890d814b" translate="yes" xml:space="preserve">
          <source>Elixir runs on the Erlang Virtual Machine and, sooner or later, an Elixir developer will want to interface with existing Erlang libraries. Here&amp;rsquo;s a list of online resources that cover Erlang&amp;rsquo;s fundamentals and its more advanced features:</source>
          <target state="translated">Elixir在Erlang虚拟机上运行，​​迟早Elixir开发人员将希望与现有的Erlang库进行交互。以下是涵盖Erlang基本知识及其更高级功能的在线资源列表：</target>
        </trans-unit>
        <trans-unit id="4a5fefa1f8798cec1647f9fe4a71993a0c63afa5" translate="yes" xml:space="preserve">
          <source>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</source>
          <target state="translated">Elixir 看到右侧是一个函数调用,就会用管道连接到它。这意味着,如果你想管道到匿名或捕获的函数,它也必须被显式调用。</target>
        </trans-unit>
        <trans-unit id="a8974a1be92f4c12c0a0c52c8b32e2ca1e35088a" translate="yes" xml:space="preserve">
          <source>Elixir ships with facilities to connect nodes and exchange information between them. In fact, we use the same concepts of processes, message passing and receiving messages when working in a distributed environment because Elixir processes are &lt;em&gt;location transparent&lt;/em&gt;. This means that when sending a message, it doesn&amp;rsquo;t matter if the recipient process is on the same node or on another node, the</source>
          <target state="translated">Elixir附带了用于连接节点并在节点之间交换信息的设施。实际上，由于Elixir进程是&lt;em&gt;位置透明的，&lt;/em&gt;因此在分布式环境中工作时，我们使用相同的过程概念，即消息传递和接收消息。这意味着在发送消息时，接收方进程是在同一节点还是在另一个节点上都没有关系，</target>
        </trans-unit>
        <trans-unit id="5c11d827abbb7cde35b0a581d6299d5d74cd7a62" translate="yes" xml:space="preserve">
          <source>Elixir ships with some built-in protocols. In previous chapters, we have discussed the &lt;code&gt;Enum&lt;/code&gt; module which provides many functions that work with any data structure that implements the &lt;code&gt;Enumerable&lt;/code&gt; protocol:</source>
          <target state="translated">Elixir附带了一些内置协议。在前面的章节中，我们讨论了 &lt;code&gt;Enum&lt;/code&gt; 模块，该模块提供了许多功能，可与实现 &lt;code&gt;Enumerable&lt;/code&gt; 协议的任何数据结构一起使用：</target>
        </trans-unit>
        <trans-unit id="8d3a064f8543389f89760aca91a7bf4bd3fe1730" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) still has the group leader of the current node (&lt;code&gt;bar&lt;/code&gt;). We have briefly talked about group leaders in the &lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO chapter&lt;/a&gt;.</source>
          <target state="translated">Elixir在另一个节点上生成了一个进程，并返回了它的pid。然后，该代码在存在 &lt;code&gt;Hello.world/0&lt;/code&gt; 函数的另一个节点上执行并调用该函数。注意，&amp;ldquo; hello world&amp;rdquo;的结果打印在当前节点 &lt;code&gt;bar&lt;/code&gt; 而不是 &lt;code&gt;foo&lt;/code&gt; 上。换句话说，要被打印的消息被发送从后 &lt;code&gt;foo&lt;/code&gt; 到 &lt;code&gt;bar&lt;/code&gt; 。发生这种情况是因为在另一个节点（ &lt;code&gt;foo&lt;/code&gt; ）上产生的进程仍具有当前节点（ &lt;code&gt;bar&lt;/code&gt; ）的组长。在&lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO章&lt;/a&gt;中，我们简要讨论了组长。</target>
        </trans-unit>
        <trans-unit id="cdde1bffc734f7ff0a1635ad03d752544e76408f" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="translated">Elixir将文档存储在字节码中的预定义块中。可以使用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;函数从Elixir进行访问。这也意味着仅在需要时访问文档，而在虚拟机加载模块时不访问文档。唯一的缺点是内存中定义的模块（如IEx中定义的模块）无法访问其文档，因为它们未将字节码写入磁盘。</target>
        </trans-unit>
        <trans-unit id="ba4784f8c761fcb64ca50be28ca3ee0726dd1e34" translate="yes" xml:space="preserve">
          <source>Elixir supports &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; as booleans:</source>
          <target state="translated">Elixir支持布尔值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c1fca4af1967c47f797a528ad384a0b6142eeed4" translate="yes" xml:space="preserve">
          <source>Elixir supports Unicode throughout the language.</source>
          <target state="translated">Elixir在整个语言中支持Unicode。</target>
        </trans-unit>
        <trans-unit id="1f173b2bc2f5965b36c7172e06c818c7bd04ae05" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;. You can see all the built-in types provided by Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;in the typespecs docs&lt;/a&gt;.</source>
          <target state="translated">Elixir也支持化合物类型。例如，整数列表的类型为 &lt;code&gt;[integer]&lt;/code&gt; 。您可以&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;在typespecs docs中查看&lt;/a&gt; Elixir提供的所有内置类型。</target>
        </trans-unit>
        <trans-unit id="96cc8eea24e4342cdb1b99a08ca9183edff74d45" translate="yes" xml:space="preserve">
          <source>Elixir supports conversions from charlists which contains any Unicode code point.</source>
          <target state="translated">Elixir支持从包含任何Unicode码点的字符表进行转换。</target>
        </trans-unit>
        <trans-unit id="c47342d7972fff0f119dd077cbc8a84f69c35e4d" translate="yes" xml:space="preserve">
          <source>Elixir supports only code points &lt;code&gt;\t&lt;/code&gt; (0009), &lt;code&gt;\n&lt;/code&gt; (000A), &lt;code&gt;\r&lt;/code&gt; (000D) and &lt;code&gt;\s&lt;/code&gt; (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.</source>
          <target state="translated">Elixir仅支持代码点 &lt;code&gt;\t&lt;/code&gt; （0009）， &lt;code&gt;\n&lt;/code&gt; （000A）， &lt;code&gt;\r&lt;/code&gt; （000D）和 &lt;code&gt;\s&lt;/code&gt; （0020）作为空白，因此不符合要求R3。R3需要支持更多种类的空格和语法字符。</target>
        </trans-unit>
        <trans-unit id="310bbc013224b7904b922e667f4bf7001bdc5fa3" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements:</source>
          <target state="translated">Elixir语法被设计成有一个直接转换为抽象语法树(AST)。Elixir的AST是一个常规的Elixir数据结构,由以下元素组成。</target>
        </trans-unit>
        <trans-unit id="ff71b1cca0c9586eb958681a7c3aaf58f79bc884" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms.</source>
          <target state="translated">Elixir语法被设计成可以直接转换为抽象语法树(AST)。这意味着Elixir语法大多是统一的,并有少量的 &quot;语法糖 &quot;结构,以减少Elixir常见习语中的噪音。</target>
        </trans-unit>
        <trans-unit id="ce4861615a3c3b43c097938810a51ecb7a613f3a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.</source>
          <target state="translated">Elixir将文档和代码注释视为不同的概念。文档是您和您的应用编程接口(API)用户之间的明确契约,无论是第三方开发者、同事还是您未来的自己。如果模块和函数是您的API的一部分,那么它们必须始终被记录下来。</target>
        </trans-unit>
        <trans-unit id="94ab78733fcffaa0c8d9d75151f47ea7434ea05a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation as a first-class citizen. This means documentation should be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices and doctests.</source>
          <target state="translated">Elixir将文档视为一等公民。这意味着文档应该易于编写和阅读。在本文档中,你将学习如何在Elixir中编写文档,包括模块属性、风格实践和doctests等结构。</target>
        </trans-unit>
        <trans-unit id="c067ad566a52ceb3738f6cd14c05e81b89ddb512" translate="yes" xml:space="preserve">
          <source>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:</source>
          <target state="translated">Elixir使用大括号来定义元组。像列表一样,元组可以容纳任何值。</target>
        </trans-unit>
        <trans-unit id="b7437bc89e4d7cd42e4777ca92ac246386afa15d" translate="yes" xml:space="preserve">
          <source>Elixir uses single quotes to define charlists:</source>
          <target state="translated">Elixir使用单引号来定义charlists。</target>
        </trans-unit>
        <trans-unit id="0a0c9ca226ff9075b8b4027dc040b09a7fc4c136" translate="yes" xml:space="preserve">
          <source>Elixir uses square brackets to specify a list of values. Values can be of any type:</source>
          <target state="translated">Elixir使用方括号来指定一个值的列表。值可以是任何类型。</target>
        </trans-unit>
        <trans-unit id="7410ee1b8baed2ca63c0da7fbd59f8909583c454" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;code#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Elixir v1.7采用&lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt;，这是一种新的文档格式，可以在所有BEAM语言之间共享。&lt;a href=&quot;code#get_docs/2&quot;&gt; &lt;code&gt;Code.get_docs/2&lt;/code&gt; &lt;/a&gt;使用的旧格式不再可用，因此此函数始终返回 &lt;code&gt;nil&lt;/code&gt; 。请改用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2c8e7ddf395da597d9d7092789c372c5e9cb894" translate="yes" xml:space="preserve">
          <source>Elixir version</source>
          <target state="translated">Elixir版本</target>
        </trans-unit>
        <trans-unit id="3ef1a22d73c732ddfb0e37deb22c5920363b7ef9" translate="yes" xml:space="preserve">
          <source>Elixir version information.</source>
          <target state="translated">Elixir版本信息。</target>
        </trans-unit>
        <trans-unit id="2d1a3e13eeda4320739159e4214187b33436ad5e" translate="yes" xml:space="preserve">
          <source>Elixir will accept any module name as long as the expression passed as the first argument to &lt;a href=&quot;#defmodule/2&quot;&gt;&lt;code&gt;defmodule/2&lt;/code&gt;&lt;/a&gt; evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.</source>
          <target state="translated">只要将作为&lt;a href=&quot;#defmodule/2&quot;&gt; &lt;code&gt;defmodule/2&lt;/code&gt; &lt;/a&gt;的第一个参数传递的表达式求值为原子，Elixir就会接受任何模块名称。请注意，使用动态名称时，Elixir不会将名称嵌套在当前模块下，也不会自动设置别名。</target>
        </trans-unit>
        <trans-unit id="0c3a96ef15c7b10a131a32d7fe611882ee9f141c" translate="yes" xml:space="preserve">
          <source>Elixir will automatically wrap the function body in a &lt;code&gt;try&lt;/code&gt; whenever one of &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; is specified.</source>
          <target state="translated">只要指定了 &lt;code&gt;after&lt;/code&gt; ， &lt;code&gt;rescue&lt;/code&gt; 或 &lt;code&gt;catch&lt;/code&gt; 之一，Elixir就会自动 &lt;code&gt;try&lt;/code&gt; 包装功能主体。</target>
        </trans-unit>
        <trans-unit id="a85970e0faad243447c5114389dcdeb0a39d337f" translate="yes" xml:space="preserve">
          <source>Elixir&amp;rsquo;s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</source>
          <target state="translated">Elixir的进程不应与操作系统进程混淆。就内存和CPU而言，Elixir中的进程极为轻巧（即使与许多其他编程语言中使用的线程相比也是如此）。因此，同时运行成千上万的进程并不罕见。</target>
        </trans-unit>
        <trans-unit id="74afface970af5cae73731659047f9af84feb478" translate="yes" xml:space="preserve">
          <source>Elixir's AST (Abstract Syntax Tree)</source>
          <target state="translated">Elixir的AST(抽象语法树)。</target>
        </trans-unit>
        <trans-unit id="ce6d269d872319624d23c6d1f8a1436923e77f5d" translate="yes" xml:space="preserve">
          <source>Elixir's interactive shell.</source>
          <target state="translated">Elixir的交互式外壳。</target>
        </trans-unit>
        <trans-unit id="b500d25431abdc8af2398b8e041e9fe8f8aee8f4" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;application&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir的标准库包含一些常用的行为，例如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;application&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9c075ef1bb96e78c3aeb788db6fdaa2ad6900d8" translate="yes" xml:space="preserve">
          <source>Else</source>
          <target state="translated">Else</target>
        </trans-unit>
        <trans-unit id="5b3a40099a2074128eab39c61a99ee9cc8c97d42" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given accumulator.</source>
          <target state="translated">发出一个给定累加器的数值序列。</target>
        </trans-unit>
        <trans-unit id="13f5c3f168a677e832d55a71220e8084e5ebb435" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given resource.</source>
          <target state="translated">发出给定资源的值的序列。</target>
        </trans-unit>
        <trans-unit id="ee36a1b257d40c27de1319e9f52bd4df213a780a" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values, starting with &lt;code&gt;start_value&lt;/code&gt;. Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; on the previous value.</source>
          <target state="translated">发出一系列值，从 &lt;code&gt;start_value&lt;/code&gt; 开始。通过对前一个值调用 &lt;code&gt;next_fun&lt;/code&gt; 来生成连续值。</target>
        </trans-unit>
        <trans-unit id="c167634bd4b2e54cc64b0ca7da7acd698bd3f926" translate="yes" xml:space="preserve">
          <source>Empty list elements are discarded.</source>
          <target state="translated">空列表元素将被丢弃。</target>
        </trans-unit>
        <trans-unit id="2965dae66a63ca2f32957370b2d3c71d31f0404a" translate="yes" xml:space="preserve">
          <source>Empty list elements from &lt;code&gt;list&lt;/code&gt; are discarded, but not the ones from &lt;code&gt;tail&lt;/code&gt;.</source>
          <target state="translated">list中的空列表元素 &lt;code&gt;list&lt;/code&gt; 被丢弃，而 &lt;code&gt;tail&lt;/code&gt; 中的元素将不被丢弃。</target>
        </trans-unit>
        <trans-unit id="e62ffd3f17608b67830975574d7151f053f3b91e" translate="yes" xml:space="preserve">
          <source>Empty strings are only removed from the result if the &lt;code&gt;:trim&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;:trim&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ,则仅从结果中删除空字符串。</target>
        </trans-unit>
        <trans-unit id="55e69718479729085dd821e5465e25f44c0324fa" translate="yes" xml:space="preserve">
          <source>Enables logging for the current process.</source>
          <target state="translated">启用当前进程的日志记录。</target>
        </trans-unit>
        <trans-unit id="e2d19b78121686bc349ccaa09a8452830a7f9140" translate="yes" xml:space="preserve">
          <source>Encircled.</source>
          <target state="translated">Encircled.</target>
        </trans-unit>
        <trans-unit id="c616c5fe7020dabc2f93906e0a5f2e05bdc7d8a9" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">将 &lt;code&gt;string&lt;/code&gt; 编码为&amp;ldquo; x-www-form-urlencoded&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="89ea780eda521b71e81ed735656c9b61d9499afc" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 16 encoded string.</source>
          <target state="translated">将二进制字符串编码为16进制编码的字符串。</target>
        </trans-unit>
        <trans-unit id="b7e8311ecf9de60bb4c8128af17fdd4f6e19c5bd" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet.</source>
          <target state="translated">将一个二进制字符串编码成一个以扩展的十六进制字母为基础的32编码字符串。</target>
        </trans-unit>
        <trans-unit id="36e80d95ff066a33ec7f84aa78c9dbee7b1c006d" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string.</source>
          <target state="translated">将二进制字符串编码为32基编码的字符串。</target>
        </trans-unit>
        <trans-unit id="02f9836e91d8d8f20631bf25f980c01911623202" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet.</source>
          <target state="translated">将一个二进制字符串编码成基数为64的编码字符串,并使用URL和文件名安全字母。</target>
        </trans-unit>
        <trans-unit id="598559f4be54955449341d6458c6b1bc5c089d2a" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string.</source>
          <target state="translated">将二进制字符串编码为64基编码的字符串。</target>
        </trans-unit>
        <trans-unit id="669885d2c33e97774bece663078c5982ab0c0947" translate="yes" xml:space="preserve">
          <source>Encodes an enumerable into a query string.</source>
          <target state="translated">将一个数值编码为一个查询字符串。</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="322c5d3730703ae50125a473e7a7c3d0e9ef2301" translate="yes" xml:space="preserve">
          <source>Endianness</source>
          <target state="translated">Endianness</target>
        </trans-unit>
        <trans-unit id="2ea89f176d80e61e2fa991e7665230fc139bc40d" translate="yes" xml:space="preserve">
          <source>Enforcing keys</source>
          <target state="translated">强制执行钥匙</target>
        </trans-unit>
        <trans-unit id="c1f65ddb75ed7d97e701168af35171410be8f9e7" translate="yes" xml:space="preserve">
          <source>Engine</source>
          <target state="translated">Engine</target>
        </trans-unit>
        <trans-unit id="428bd921a8f300c3b20c8266821204a755c68434" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; and its applications are started.</source>
          <target state="translated">确保给定的 &lt;code&gt;app&lt;/code&gt; 及其应用程序已启动。</target>
        </trans-unit>
        <trans-unit id="5fb7dedc1a9428584a4069438797a9ae78f66928" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is started.</source>
          <target state="translated">确保给定的 &lt;code&gt;app&lt;/code&gt; 已启动。</target>
        </trans-unit>
        <trans-unit id="23ee0124a924556d787c30d38fea8fafda3318c2" translate="yes" xml:space="preserve">
          <source>Ensures the given module is compiled and loaded.</source>
          <target state="translated">确保给定的模块被编译和加载。</target>
        </trans-unit>
        <trans-unit id="c639ba03accf3baf6f605c3c0a367752ac1ba4b8" translate="yes" xml:space="preserve">
          <source>Ensures the given module is loaded.</source>
          <target state="translated">确保给定的模块被加载。</target>
        </trans-unit>
        <trans-unit id="02d3338a85e66444166e14ec820ab3f756bc5765" translate="yes" xml:space="preserve">
          <source>Ensures the project structure for the given project exists.</source>
          <target state="translated">确保给定项目的项目结构存在。</target>
        </trans-unit>
        <trans-unit id="dd06dfc909fbc0c4ad3d2dc1fed376ba517fa970" translate="yes" xml:space="preserve">
          <source>Entries with duplicated keys end up in the same keyword list.</source>
          <target state="translated">有重复键的条目最终会出现在同一个关键词列表中。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="44a9d3cb7758b69424c29688d3733784f2d7beb8" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError</source>
          <target state="translated">Enum.EmptyError</target>
        </trans-unit>
        <trans-unit id="203f8ecd57ba73b4d911d61ce2b2e0bbecd88546" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.EmptyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92ff846ccb27bb1237f0fe73dffd1111a34febfd" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError</source>
          <target state="translated">Enum.OutOfBoundsError</target>
        </trans-unit>
        <trans-unit id="64fce429b4436d311f9ed265caf9dbd13748ca8e" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.OutOfBoundsError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="83df7a7ef8fa21dd3116045758d3e9407ca3149d" translate="yes" xml:space="preserve">
          <source>Enumerable</source>
          <target state="translated">Enumerable</target>
        </trans-unit>
        <trans-unit id="a8bd4b8016c41ed593121704b28a0f638927292f" translate="yes" xml:space="preserve">
          <source>Enumerable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">可数&lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f5c0dbf914d64832e2d144e52e6254adb376dd46" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;map#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;map#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;map#drop/2&quot;&gt; &lt;code&gt;Map.drop/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;map#split/2&quot;&gt; &lt;code&gt;Map.split/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map#take/2&quot;&gt; &lt;code&gt;Map.take/2&lt;/code&gt; 中的&lt;/a&gt;可枚举键</target>
        </trans-unit>
        <trans-unit id="140efbf707d0a7d6c39e74eac70140aecd0e5c56" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块使用的可枚举协议。</target>
        </trans-unit>
        <trans-unit id="d50ecedb47e87b1d9271881d5fe0a9349ed165af" translate="yes" xml:space="preserve">
          <source>Enumerable.acc (0)</source>
          <target state="translated">Enumerable.acc (0)</target>
        </trans-unit>
        <trans-unit id="165c38b0e896ed9f5159922dce36f171ef2320bb" translate="yes" xml:space="preserve">
          <source>Enumerable.continuation (0)</source>
          <target state="translated">Enumerable.continuation (0)</target>
        </trans-unit>
        <trans-unit id="ba612d94bc0277c74713f344be3f6d833e339b91" translate="yes" xml:space="preserve">
          <source>Enumerable.count (1)</source>
          <target state="translated">Enumerable.count (1)</target>
        </trans-unit>
        <trans-unit id="c8a16ef4893a246c5d44ffbd9b826395af284553" translate="yes" xml:space="preserve">
          <source>Enumerable.member? (2)</source>
          <target state="translated">Enumerable.成员? (2)</target>
        </trans-unit>
        <trans-unit id="a9bae250bd6ab01ed637153931cbca7969a9d2fd" translate="yes" xml:space="preserve">
          <source>Enumerable.reduce (3)</source>
          <target state="translated">Enumerable.reduce (3)</target>
        </trans-unit>
        <trans-unit id="ee6aa06bf997d33de46b0f36134133d251942cde" translate="yes" xml:space="preserve">
          <source>Enumerable.reducer (0)</source>
          <target state="translated">Enumerable.reducer (0)</target>
        </trans-unit>
        <trans-unit id="642806a29777279924e9371db22138badd652470" translate="yes" xml:space="preserve">
          <source>Enumerable.result (0)</source>
          <target state="translated">Enumerable.result (0)</target>
        </trans-unit>
        <trans-unit id="67feaa35a2d44a604538ef39106d006cede14270" translate="yes" xml:space="preserve">
          <source>Enumerable.slice (1)</source>
          <target state="translated">Enumerable.slice (1)</target>
        </trans-unit>
        <trans-unit id="976e95d4d549c47ec6aacfa3aeb87430d06ae485" translate="yes" xml:space="preserve">
          <source>Enumerable.slicing_fun (0)</source>
          <target state="translated">Enumerable.slicing_fun (0)</target>
        </trans-unit>
        <trans-unit id="8099438503374b0f111ad8c4312c5674efd4704f" translate="yes" xml:space="preserve">
          <source>Enumerable.t (0)</source>
          <target state="translated">Enumerable.t (0)</target>
        </trans-unit>
        <trans-unit id="7d2e28d9448f286359bfee7b46440bedbb9fdf58" translate="yes" xml:space="preserve">
          <source>Enumerables</source>
          <target state="translated">Enumerables</target>
        </trans-unit>
        <trans-unit id="1dc0acb1a8bb4c81550d3ac71c2122f2718c66f7" translate="yes" xml:space="preserve">
          <source>Enumerables and Streams</source>
          <target state="translated">枚举和串联</target>
        </trans-unit>
        <trans-unit id="30d600c6cc439356af01777f989e3d24add2e962" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, by removing the elements for which function &lt;code&gt;fun&lt;/code&gt; returned duplicate elements.</source>
          <target state="translated">通过删除函数 &lt;code&gt;fun&lt;/code&gt; 返回其重复元素的元素来枚举 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0710d3c7a9e2c2a7ab19f785bc7e4ac156c8c8ae" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, removing all duplicated elements.</source>
          <target state="translated">枚举 &lt;code&gt;enumerable&lt;/code&gt; ，删除所有重复的元素。</target>
        </trans-unit>
        <trans-unit id="d63d851ffe5d4b54e805b90b32ec2610b7cdc775" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, returning a list where all consecutive duplicated elements are collapsed to a single element.</source>
          <target state="translated">枚举 &lt;code&gt;enumerable&lt;/code&gt; ，返回一个列表，其中所有连续重复的元素都折叠为一个元素。</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="e22b06d69ee07489bc27f1054e5551d2fb3ffec1" translate="yes" xml:space="preserve">
          <source>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;, for example:</source>
          <target state="translated">不打算保留值（基本上充当标志）的环境变量应设置为 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;true&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="5d9ca98304ae0b29eb5edae09971f0cda610aca2" translate="yes" xml:space="preserve">
          <source>Erlang Term Storage</source>
          <target state="translated">Erlang术语存储</target>
        </trans-unit>
        <trans-unit id="873eaae56cb75c28c82e887676a81c9c926d3d76" translate="yes" xml:space="preserve">
          <source>Erlang VM process identifier.</source>
          <target state="translated">Erlang虚拟机进程标识符。</target>
        </trans-unit>
        <trans-unit id="5d81fb4bfd2d9c41c1a7ce9b604e0403471792c0" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode codepoints. Bytes (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode codepoints (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="translated">Erlang和Elixir也有&lt;a href=&quot;#t:chardata/0&quot;&gt; &lt;code&gt;chardata/0&lt;/code&gt; &lt;/a&gt;的想法。Chardata与IO数据非常相似：唯一的区别是IO数据中的整数表示字节，而chardata中的整数表示Unicode代码点。字节（&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;byte/0&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;0..255&lt;/code&gt; 范围内的整数，而Unicode代码点（&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;char/0&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;0..0x10FFFF&lt;/code&gt; 范围内的整数。在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块提供&lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt;为chardata作为的&amp;ldquo;计数器部分的&amp;rdquo;功能&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;功能IO的数据。</target>
        </trans-unit>
        <trans-unit id="2ad841c6351d40f6ce14b1c3365f66f45cf90f9a" translate="yes" xml:space="preserve">
          <source>Erlang configuration - options that handle integration with Erlang's logging facilities</source>
          <target state="translated">Erlang配置-处理与Erlang日志设施集成的选项。</target>
        </trans-unit>
        <trans-unit id="dcdbc42e4590fc1cd5b2780008879d7043463df9" translate="yes" xml:space="preserve">
          <source>Erlang errors</source>
          <target state="translated">获取错误</target>
        </trans-unit>
        <trans-unit id="afd9042ead7605c46c0058e1b4e52ac063ec4da4" translate="yes" xml:space="preserve">
          <source>Erlang errors are transformed into Elixir ones when rescuing:</source>
          <target state="translated">救援时,Erlang的错误会转化为Elixir的错误。</target>
        </trans-unit>
        <trans-unit id="80e47b987c75aeed2cf56f80f3a45202d7a9cade" translate="yes" xml:space="preserve">
          <source>Erlang has two modes to load code: interactive and embedded.</source>
          <target state="translated">Erlang有两种加载代码的模式:交互式和嵌入式。</target>
        </trans-unit>
        <trans-unit id="c4aea0a9415c252cca77b12b8e68bf25c0600b44" translate="yes" xml:space="preserve">
          <source>Erlang libraries</source>
          <target state="translated">Erlang库</target>
        </trans-unit>
        <trans-unit id="947adf59db0f5074b68cab24e83d10f84084f65d" translate="yes" xml:space="preserve">
          <source>Erlang projects</source>
          <target state="translated">Erlang项目</target>
        </trans-unit>
        <trans-unit id="353a427c9c3948990fb1397e32a17449450dd341" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;tutorial&lt;/a&gt; with pictures that briefly describe Erlang&amp;rsquo;s primitives for concurrent programming.</source>
          <target state="translated">Erlang的官方网站上有一个简短的&lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;教程，&lt;/a&gt;其中包含图片，简要描述了Erlang用于并发编程的原语。</target>
        </trans-unit>
        <trans-unit id="64b602b5d1c8c7cedbd11a4c46c7bec0f2ef6328" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 19 onwards</source>
          <target state="translated">Erlang/OTP 19以上</target>
        </trans-unit>
        <trans-unit id="9f3b0640f155508325d5fd627bb055c21f7b1145" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 20 onwards</source>
          <target state="translated">Erlang/OTP 20以上</target>
        </trans-unit>
        <trans-unit id="0240f7d16642d7d18aa4135e9508d4430ca6ed28" translate="yes" xml:space="preserve">
          <source>Erlang/OTP versioning is independent from the versioning of Elixir. Each version of Elixir supports a specific range of Erlang/OTP versions. The compatibility table is shown below.</source>
          <target state="translated">Erlang/OTP的版本管理是独立于Elixir的版本管理的。Elixir的每个版本都支持特定范围的Erlang/OTP版本。兼容性表如下所示。</target>
        </trans-unit>
        <trans-unit id="95b539190ee1df5b25c9d30c7a60632c2c6242b6" translate="yes" xml:space="preserve">
          <source>ErlangError</source>
          <target state="translated">ErlangError</target>
        </trans-unit>
        <trans-unit id="eb887d05f639b63c61d49ed79af8fbf4426605b6" translate="yes" xml:space="preserve">
          <source>ErlangError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ErlangError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="6a37b79ee438a25b4b00f639862f12f01079bb8d" translate="yes" xml:space="preserve">
          <source>Error logger configuration</source>
          <target state="translated">错误记录器配置</target>
        </trans-unit>
        <trans-unit id="9497fa3a6a15769b096afdea76d16a9bb93c4394" translate="yes" xml:space="preserve">
          <source>Error reasons</source>
          <target state="translated">错误原因</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e4b51562d8691be50e95ec4d102a96ec94cfc7fc" translate="yes" xml:space="preserve">
          <source>Errors (or &lt;em&gt;exceptions&lt;/em&gt;) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number into an atom:</source>
          <target state="translated">当代码中发生异常情况时，将使用错误（或&lt;em&gt;异常&lt;/em&gt;）。可以通过尝试向原子中添加数字来检索示例错误：</target>
        </trans-unit>
        <trans-unit id="1e769d29496e91df4803194e858296cef49f583c" translate="yes" xml:space="preserve">
          <source>Errors can be &lt;strong&gt;rescued&lt;/strong&gt; using the &lt;code&gt;try/rescue&lt;/code&gt; construct:</source>
          <target state="translated">可以使用 &lt;code&gt;try/rescue&lt;/code&gt; 构造来&lt;strong&gt;挽救&lt;/strong&gt;错误：</target>
        </trans-unit>
        <trans-unit id="7cf06e4f5765ec1423667355b26bedd03532387d" translate="yes" xml:space="preserve">
          <source>Escapes a string to be literally matched in a regex.</source>
          <target state="translated">在regex中逃避一个字符串的字面匹配。</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="ef08760354a34230fab73487dfba3c92eef3db07" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="translated">应将脚本用作开发人员之间共享脚本的机制，而不应将其用作部署机制。对于运行实时系统，请考虑使用&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;或构建发行版。有关系统生命周期的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9a5a63b505c94b9715c6cb22738effadf43970a2" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">建立到 &lt;code&gt;node&lt;/code&gt; 的连接。</target>
        </trans-unit>
        <trans-unit id="5197d13a701e91968e7385a64eaafa020ebb9b3e" translate="yes" xml:space="preserve">
          <source>Evals the given file.</source>
          <target state="translated">评估给定的文件。</target>
        </trans-unit>
        <trans-unit id="c61e6ac1811baae3135839c7b54f099f020838b7" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;code&gt;eval_string&lt;/code&gt;) or a file (&lt;code&gt;eval_file&lt;/code&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="translated">直接评估一个字符串（ &lt;code&gt;eval_string&lt;/code&gt; ）或一个文件（ &lt;code&gt;eval_file&lt;/code&gt; ）。这是最简单使用的API，但也是最慢的API，因为该代码之前是经过评估而不编译的。</target>
        </trans-unit>
        <trans-unit id="b6b73d4e37c0e2fc6bcd10607ad1cdb1b13313ab" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">评估板 &lt;code&gt;fun&lt;/code&gt; ，并将结果下 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; ，除非 &lt;code&gt;key&lt;/code&gt; 是已经存在。</target>
        </trans-unit>
        <trans-unit id="47fea9e50d94c5ba5334f9182ab4da272971ff69" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in keyword list unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">评估板 &lt;code&gt;fun&lt;/code&gt; ，并将结果下 &lt;code&gt;key&lt;/code&gt; 在关键字列表，除非 &lt;code&gt;key&lt;/code&gt; 是已经存在。</target>
        </trans-unit>
        <trans-unit id="6d2ad4fd562a8770695759664566e68c79e896d7" translate="yes" xml:space="preserve">
          <source>Evaluates the contents given by &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;string&lt;/code&gt; 给出的内容。</target>
        </trans-unit>
        <trans-unit id="3f66e28bdcb030fa5267d28739b480d4ccf00895" translate="yes" xml:space="preserve">
          <source>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</source>
          <target state="translated">评估第一个子句对应的表达式,该表达式评估为truthhy值。</target>
        </trans-unit>
        <trans-unit id="f9da9d74593adcfa13d94962a59c2dd76ee78247" translate="yes" xml:space="preserve">
          <source>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</source>
          <target state="translated">评估给定的表达式,并处理任何可能发生的错误、退出或抛出。</target>
        </trans-unit>
        <trans-unit id="8c971533ea3061f79d23aaa5efa90e539f841e09" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents in the given module's context.</source>
          <target state="translated">评估给定模块上下文中引用的内容。</target>
        </trans-unit>
        <trans-unit id="faed542c6d7a022474593aebff34b62313141b57" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents.</source>
          <target state="translated">对所引用的内容进行评估。</target>
        </trans-unit>
        <trans-unit id="af2f0cacf83a79f7f113163a613ddccc7608558d" translate="yes" xml:space="preserve">
          <source>Even a map is represented as a call to &lt;code&gt;%{}&lt;/code&gt;:</source>
          <target state="translated">甚至地图也表示为对 &lt;code&gt;%{}&lt;/code&gt; 的调用：</target>
        </trans-unit>
        <trans-unit id="9379ba740718a45c562052c55dae060f6e11aa7a" translate="yes" xml:space="preserve">
          <source>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</source>
          <target state="translated">即使定时器已经过期,消息已经发送,这个功能也不会告诉你超时消息是否已经到达目的地。</target>
        </trans-unit>
        <trans-unit id="27ed9c8d1ab5b1899cff5f812cb51b56f1af0736" translate="yes" xml:space="preserve">
          <source>Even if we have type-specific functions for getting the size built into Elixir (such as &lt;code&gt;tuple_size/1&lt;/code&gt;), we could implement a generic &lt;code&gt;Size&lt;/code&gt; protocol that all data structures for which size is pre-computed would implement.</source>
          <target state="translated">即使我们具有特定类型的函数来获取内置到Elixir中的大小（例如 &lt;code&gt;tuple_size/1&lt;/code&gt; ），我们也可以实现通用的 &lt;code&gt;Size&lt;/code&gt; 协议，该协议将为所有预先计算大小的数据结构实现。</target>
        </trans-unit>
        <trans-unit id="9d8348e73cb5ab059583fd7f108ed8a332dfe09b" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it&amp;rsquo;s considered to be bad style to use them when they&amp;rsquo;re not necessary. So write macros responsibly.</source>
          <target state="translated">即使Elixir尽最大努力为宏提供安全的环境，但使用宏编写干净的代码的主要责任仍落在开发人员身上。宏比普通的Elixir函数更难编写，并且在不需要它们时使用宏被认为是不好的样式。因此，负责任地编写宏。</target>
        </trans-unit>
        <trans-unit id="52a8ac08291fe93f3d696a3c45b1d1387494b7dc" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly.</source>
          <target state="translated">尽管Elixir尽力为宏提供一个安全的环境,但用宏写出干净的代码的主要责任还是落在开发人员身上。宏比普通的Elixir函数更难写,而且在没有必要的情况下使用宏被认为是一种不良风格。所以要负责任地写宏。</target>
        </trans-unit>
        <trans-unit id="028b9d4259c03a084cc43fe3d1014cc325f783d4" translate="yes" xml:space="preserve">
          <source>Even though the directory is empty and there is no &lt;code&gt;.app&lt;/code&gt; file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash &lt;code&gt;-&lt;/code&gt; which is considered to be the app version and it is removed for the lookup purposes:</source>
          <target state="translated">即使目录为空并且没有 &lt;code&gt;.app&lt;/code&gt; 文件，它也被视为基于名称&amp;ldquo; foo / ebin&amp;rdquo;的应用程序目录。名称中可能包含短划线 &lt;code&gt;-&lt;/code&gt; 它被认为是应用程序的版本，出于查找目的将其删除：</target>
        </trans-unit>
        <trans-unit id="0521395297ab7a58030d272e2c72be5c8cdef7df" translate="yes" xml:space="preserve">
          <source>Even though the match works, &lt;code&gt;assert&lt;/code&gt; still expects a truth value. In such cases, simply use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;Kernel.==/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">即使匹配成功， &lt;code&gt;assert&lt;/code&gt; 仍然期望真值。在这种情况下，只需使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;Kernel.==/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; 即可&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84e3c9de2ccf9da0f358458d3784bc3f849f3c2c" translate="yes" xml:space="preserve">
          <source>Even though we haven't specified &lt;code&gt;--debug&lt;/code&gt; in the list of switches, it is part of the returned options. This would also work:</source>
          <target state="translated">即使我们没有在开关列表中指定 &lt;code&gt;--debug&lt;/code&gt; ，它也是返回的选项的一部分。这也将起作用：</target>
        </trans-unit>
        <trans-unit id="7cb4e4b7449c91102c58fcbb978127750613197b" translate="yes" xml:space="preserve">
          <source>Even with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:</source>
          <target state="translated">即使有这样的保证,开发者在负责任地编写宏时也起着很大的作用。如果你有信心需要借助宏,请记住,宏不是你的API。保持你的宏定义简短,包括其引用的内容。例如,不要写这样的宏。</target>
        </trans-unit>
        <trans-unit id="f153167a1bbb1f584f7f422c6cb126c95946d20e" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="translated">每个describe块都会收到一个名称，该名称将用作即将进行的测试的前缀。在一个块内，可以调用&lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt; &lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt; &lt;/a&gt;，它将定义仅在当前块上运行的安装回调。描述名称也作为标记添加，允许开发人员针对特定块运行测试。</target>
        </trans-unit>
        <trans-unit id="6ef3d6f408824f6647a6e0d3de1a30549693b5c2" translate="yes" xml:space="preserve">
          <source>Every function clause dispatches the appropriate command to the &lt;code&gt;KV.Registry&lt;/code&gt; server that we registered during the &lt;code&gt;:kv&lt;/code&gt; application startup. Since our &lt;code&gt;:kv_server&lt;/code&gt; depends on the &lt;code&gt;:kv&lt;/code&gt; application, it is completely fine to depend on the services it provides.</source>
          <target state="translated">每个函数子句都会将适当的命令调度到我们在 &lt;code&gt;:kv&lt;/code&gt; 应用程序启动期间注册的 &lt;code&gt;KV.Registry&lt;/code&gt; 服务器。由于我们的 &lt;code&gt;:kv_server&lt;/code&gt; 依赖于 &lt;code&gt;:kv&lt;/code&gt; 应用程序，因此完全可以依赖它提供的服务。</target>
        </trans-unit>
        <trans-unit id="76e353e9635feb9762b1896c7c1b95987d4b25d4" translate="yes" xml:space="preserve">
          <source>Every project has a &lt;code&gt;mix.exs&lt;/code&gt; file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a &lt;code&gt;lib&lt;/code&gt; directory, which includes Elixir source code, and a &lt;code&gt;test&lt;/code&gt; directory. A &lt;code&gt;src&lt;/code&gt; directory may also exist for Erlang sources.</source>
          <target state="translated">每个项目都有一个 &lt;code&gt;mix.exs&lt;/code&gt; 文件，其中包含有关如何构建，编译，运行测试等的说明。库通常具有一个 &lt;code&gt;lib&lt;/code&gt; 目录（其中包括Elixir源代码）和一个 &lt;code&gt;test&lt;/code&gt; 目录。一个 &lt;code&gt;src&lt;/code&gt; 目录中也可能存在Erlang的来源。</target>
        </trans-unit>
        <trans-unit id="02a22b2e5fd456a7ae0a76d486db20f724d54096" translate="yes" xml:space="preserve">
          <source>Every release contains an environment file, named &lt;code&gt;env.sh&lt;/code&gt; on Unix-like systems and &lt;code&gt;env.bat&lt;/code&gt; on Windows machines, that executes before the Elixir system starts. In this file, you can execute any OS-level code, such as invoke other applications, set environment variables and so on. Some of those environment variables can even configure how the release itself runs.</source>
          <target state="translated">每个发行版都包含一个环境文件，在类似Unix的系统上名为 &lt;code&gt;env.sh&lt;/code&gt; ，在Windows机器上名为 &lt;code&gt;env.bat&lt;/code&gt; ，该文件在Elixir系统启动之前执行。在此文件中，您可以执行任何操作系统级别的代码，例如调用其他应用程序，设置环境变量等。其中一些环境变量甚至可以配置发行版本身的运行方式。</target>
        </trans-unit>
        <trans-unit id="b3ec0c5ca215e236f63402da7cfee38e03a48ba1" translate="yes" xml:space="preserve">
          <source>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</source>
          <target state="translated">每次打开一个文件,Elixir都会生成一个新的进程。写入文件相当于向写入文件描述符的进程发送消息。</target>
        </trans-unit>
        <trans-unit id="8195a151075d5ab9fbd9a600b260682c39388d0f" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful to be used as storage during module compilation.</source>
          <target state="translated">每次在函数中读取一个属性时,都会采集其当前值的快照。换句话说,这个值是在编译时而不是在运行时读取的。正如我们将要看到的那样,这也使得属性在模块编译时被用作存储。</target>
        </trans-unit>
        <trans-unit id="78b99dda1ab8cad5aa5dc088e4709cd8ffa9a689" translate="yes" xml:space="preserve">
          <source>Every time we need to look up a bucket, we need to send a message to the registry. In case our registry is being accessed concurrently by multiple processes, the registry may become a bottleneck!</source>
          <target state="translated">每当我们需要查询一个桶的时候,我们需要向注册表发送一条消息。万一我们的注册表被多个进程并发访问,注册表可能会成为一个瓶颈!</target>
        </trans-unit>
        <trans-unit id="62cee6babe5c5a8fa4e03c567fac109731766e5f" translate="yes" xml:space="preserve">
          <source>Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes. In this case, we are using &lt;code&gt;:one_for_one&lt;/code&gt; and the &lt;code&gt;KV.Registry&lt;/code&gt; is started before &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;.</source>
          <target state="translated">每次将新的子代添加到主管中时，重要的是要评估主管策略是否正确以及子进程的顺序。在这种情况下，我们使用 &lt;code&gt;:one_for_one&lt;/code&gt; ，并且 &lt;code&gt;KV.Registry&lt;/code&gt; 在 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 之前启动。</target>
        </trans-unit>
        <trans-unit id="b446cdb18e309af06e8229f9b0fda9244ac6da3e" translate="yes" xml:space="preserve">
          <source>Every time you concatenate binaries or use interpolation (&lt;code&gt;#{}&lt;/code&gt;) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data:</source>
          <target state="translated">每次串联二进制文件或使用插值（ &lt;code&gt;#{}&lt;/code&gt; ）时，您都在复制这些二进制文件。但是，在许多情况下，创建完整的二进制文件时并不需要完整的二进制文件，而只是在最后将其打印出来或发送到某个地方。在这种情况下，可以通过创建IO数据来构造二进制文件：</target>
        </trans-unit>
        <trans-unit id="962675beca29d3a850376db901731b3eb3593d3c" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;genserver#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每次执行&lt;a href=&quot;genserver#call/3&quot;&gt; &lt;code&gt;GenServer.call/3&lt;/code&gt; 时&lt;/a&gt;，客户端都会发送一条消息，该消息必须由GenServer中的&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;回调处理。甲&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;消息必须由处理&lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;时，将实现7种可能的回调。唯一需要的回调是&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3205df423b3d81a662d949f234ea958bc947b117" translate="yes" xml:space="preserve">
          <source>Every value in the map is a string, and these are:</source>
          <target state="translated">地图中的每个值都是一个字符串,这些都是。</target>
        </trans-unit>
        <trans-unit id="bd021f13376bc32f27e40804859460a61c19bc80" translate="yes" xml:space="preserve">
          <source>Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.</source>
          <target state="translated">我们传递给代理的函数里面的一切都发生在代理进程中。在这种情况下,由于代理进程是接收和响应我们的消息的,我们说代理进程是服务器。函数之外的一切都发生在客户端。</target>
        </trans-unit>
        <trans-unit id="1cf46969c22298bcd54d98e6e2c526dc85b4471b" translate="yes" xml:space="preserve">
          <source>Everything we have done so far could have been implemented with an &lt;code&gt;Agent&lt;/code&gt;. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.</source>
          <target state="translated">到目前为止，我们所做的一切都可以通过 &lt;code&gt;Agent&lt;/code&gt; 来实现。在本节中，我们将介绍通过GenServer可以实现的许多功能之一，而代理则无法实现。</target>
        </trans-unit>
        <trans-unit id="76820f41cc3743792e89eb2f8f24b62c9538f00b" translate="yes" xml:space="preserve">
          <source>ExUnit</source>
          <target state="translated">ExUnit</target>
        </trans-unit>
        <trans-unit id="b0bdc79e9fc2af1de5a45467b3f1630138afbfe1" translate="yes" xml:space="preserve">
          <source>ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging.</source>
          <target state="translated">ExUnit可以选择抑制打印测试期间产生的日志信息。运行测试时产生的日志信息会被捕获,只有当测试失败时才会被打印出来以帮助调试。</target>
        </trans-unit>
        <trans-unit id="c48c9be568f6b4c0f2e197839d3d8f36c2515f00" translate="yes" xml:space="preserve">
          <source>ExUnit provides tags and filtering functionality that allow developers to select which tests to run. The most common functionality is to exclude some particular tests from running by default in your test helper file:</source>
          <target state="translated">ExUnit提供了标签和过滤功能,允许开发人员选择要运行的测试。最常见的功能是在你的测试帮助文件中默认排除一些特定的测试运行。</target>
        </trans-unit>
        <trans-unit id="745dfe2a60f037338c2fefadc9162188f364f731" translate="yes" xml:space="preserve">
          <source>ExUnit supports the following options:</source>
          <target state="translated">ExUnit支持以下选项。</target>
        </trans-unit>
        <trans-unit id="f25c6298726d908d1e5e794bcc788478aa5fad10" translate="yes" xml:space="preserve">
          <source>ExUnit.Assertions</source>
          <target state="translated">ExUnit.Assertions</target>
        </trans-unit>
        <trans-unit id="57cef9f68db32989085431b21b29a52b82750643" translate="yes" xml:space="preserve">
          <source>ExUnit.Callbacks</source>
          <target state="translated">ExUnit.Callbacks</target>
        </trans-unit>
        <trans-unit id="b2783ae3bb7e24c853deac54a917d583149053c2" translate="yes" xml:space="preserve">
          <source>ExUnit.Case</source>
          <target state="translated">ExUnit.Case</target>
        </trans-unit>
        <trans-unit id="987b4f38599b32760dd676508e3a70f39b41abee" translate="yes" xml:space="preserve">
          <source>ExUnit.CaseTemplate</source>
          <target state="translated">ExUnit.CaseTemplate</target>
        </trans-unit>
        <trans-unit id="c5c72bd93dc7e3f0a7d2fffbd54cf9bb0f675038" translate="yes" xml:space="preserve">
          <source>ExUnit.Test</source>
          <target state="translated">ExUnit.Test</target>
        </trans-unit>
        <trans-unit id="97bb13a74b9a963a04a1d616ace7b7ad0af2e626" translate="yes" xml:space="preserve">
          <source>ExUnit.TestModule</source>
          <target state="translated">ExUnit.TestModule</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">产出示例:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b67cde3e2893f45e1d2342cc89a6c494050168c1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#is_list/1&quot;&gt; &lt;code&gt;Kernel.is_list/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fba0066e54914f2c201f52bafe91a91ee882db71" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59e48be0f15bfe533102ec4eff7ccf70153ea050" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;kernel#map_size/1&quot;&gt; &lt;code&gt;Kernel.map_size/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8894d30453776d313609dc175c436a396fe228a1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实例：&lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt; &lt;code&gt;Mix.debug?/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;string#contains?/2&quot;&gt; &lt;code&gt;String.contains?/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80519cae3a2fe4f658e3d881595a3f1c8312fcf3" translate="yes" xml:space="preserve">
          <source>Excellent!</source>
          <target state="translated">Excellent!</target>
        </trans-unit>
        <trans-unit id="60ec7b5f4ed1c9f91fe92c8f85e12cb5b5d0e653" translate="yes" xml:space="preserve">
          <source>Excellent! A release was assembled in &lt;code&gt;_build/prod/rel/foo&lt;/code&gt;. Inside the release, there will be a &lt;code&gt;bin/foo&lt;/code&gt; file which is the entry point to your system. It supports multiple commands, such as:</source>
          <target state="translated">优秀的！在 &lt;code&gt;_build/prod/rel/foo&lt;/code&gt; 中组装了一个发行版。在发行版内部，将有一个 &lt;code&gt;bin/foo&lt;/code&gt; 文件，这是系统的入口点。它支持多个命令，例如：</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="44e97cbdae038c2c5424f2954134819fe68f1b89" translate="yes" xml:space="preserve">
          <source>Exception &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">异常&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="3d517d7c8883cc469bb6f0690fb53e26f6870d0a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="translated">异常是由实现&lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为的模块支持的结构。该&lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为需要中实现两个功能：</target>
        </trans-unit>
        <trans-unit id="f5f7c811b0be5635dd0fe494c23bb6038a54a491" translate="yes" xml:space="preserve">
          <source>Exceptions in the &lt;code&gt;else&lt;/code&gt; block are not caught. If no pattern inside the &lt;code&gt;else&lt;/code&gt; block matches, an exception will be raised; this exception is not caught by the current &lt;code&gt;try/catch/rescue/after&lt;/code&gt; block.</source>
          <target state="translated">不会捕获 &lt;code&gt;else&lt;/code&gt; 块中的异常。如果 &lt;code&gt;else&lt;/code&gt; 块中没有任何模式匹配，则将引发异常；否则，将引发异常。当前的 &lt;code&gt;try/catch/rescue/after&lt;/code&gt; 块未捕获此异常。</target>
        </trans-unit>
        <trans-unit id="ea74b62ed292a57db053839d4dd2cfb1e0f29152" translate="yes" xml:space="preserve">
          <source>Excluded (via :exclude filters)</source>
          <target state="translated">排除(通过:排除过滤器)</target>
        </trans-unit>
        <trans-unit id="70a317365d7713ea507b0cb5d939c290a69f7da8" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;args&lt;/code&gt; 执行给定 &lt;code&gt;command&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8de8bb94364b91423f5a970361d0ca351b0ec3d4" translate="yes" xml:space="preserve">
          <source>Executes the given command and forwards its messages to the current process.</source>
          <target state="translated">执行给定的命令,并将其信息转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="c1372af04a9efd8163a10572859082b925f8dafa" translate="yes" xml:space="preserve">
          <source>Executes the given command and prints its output to stdout as it comes.</source>
          <target state="translated">执行给定的命令,并将其输出打印到stdout。</target>
        </trans-unit>
        <trans-unit id="4004d7a200a9edc8cf038043abae23d5809c733f" translate="yes" xml:space="preserve">
          <source>Executes the given command.</source>
          <target state="translated">执行给定的命令。</target>
        </trans-unit>
        <trans-unit id="55f164b4c64455051e302faf23d4842520137933" translate="yes" xml:space="preserve">
          <source>Executes the given function for each element.</source>
          <target state="translated">对每个元素执行给定的函数。</target>
        </trans-unit>
        <trans-unit id="b5ce416e76da997843fde479e97ac42967b3d692" translate="yes" xml:space="preserve">
          <source>Executes the tasks separated by comma.</source>
          <target state="translated">执行由逗号分隔的任务。</target>
        </trans-unit>
        <trans-unit id="7ac90140fbd596d3f7878d936c650ac9466a6ee5" translate="yes" xml:space="preserve">
          <source>Exit reasons and restarts</source>
          <target state="translated">退出原因和重新启动</target>
        </trans-unit>
        <trans-unit id="53b33039635fa494645e1b43b50ac67531129d6a" translate="yes" xml:space="preserve">
          <source>Exiting the shell</source>
          <target state="translated">退出外壳</target>
        </trans-unit>
        <trans-unit id="31a12820b55617ff15b68585a3da10bfbeb53dca" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</source>
          <target state="translated">以任何其他理由退出都被认为是不正常的,并被视为崩溃。这意味着默认的主管行为会启动,发出错误报告等。</target>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="7977d0a8642620960ce842afec7459a90da93ce6" translate="yes" xml:space="preserve">
          <source>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;:</source>
          <target state="translated">OTP使用退出来确定一个进程是否异常退出。下列退出被认为是 &quot;正常 &quot;的:</target>
        </trans-unit>
        <trans-unit id="d2a34bd07d0e86299a6bc287e4921ca1aef50681" translate="yes" xml:space="preserve">
          <source>Expands the path relative to the path given as the second argument expanding any &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; characters.</source>
          <target state="translated">相对于第二个参数any给出的路径扩展路径 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="56faca74d01072fe618cfc8860e3704b0f548536" translate="yes" xml:space="preserve">
          <source>Expands the struct given by &lt;code&gt;module&lt;/code&gt; in the given &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">扩展给定 &lt;code&gt;env&lt;/code&gt; 中 &lt;code&gt;module&lt;/code&gt; 的结构。</target>
        </trans-unit>
        <trans-unit id="a58d845ac21beded647c9679bfd179b6ae8af84c" translate="yes" xml:space="preserve">
          <source>Expands to something akin to:</source>
          <target state="translated">扩张到类似于的东西。</target>
        </trans-unit>
        <trans-unit id="91a8dae3c7e0a7461d109ccac314fd3b05583329" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, date}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="36147c4004a324e8f3e4b2ea0f84715a379f133f" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="b1f148de03b18e5985298d31921d5f1111620987" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, time}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="6d58782f27892aec9906a2b37b517051b421e83e" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">需要与&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;相同的命令行选项。</target>
        </trans-unit>
        <trans-unit id="8185e179a98e4c14d7d2dc6601e54859946ed332" translate="yes" xml:space="preserve">
          <source>Explicit derivations can now be called via &lt;code&gt;__deriving__&lt;/code&gt;:</source>
          <target state="translated">现在可以通过 &lt;code&gt;__deriving__&lt;/code&gt; 调用显式派生：</target>
        </trans-unit>
        <trans-unit id="a311e0f546569e17c6cb9a033783cc3c973c3f50" translate="yes" xml:space="preserve">
          <source>Exploring</source>
          <target state="translated">Exploring</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd636ca0127e991954457d5520bc826a5790bde1" translate="yes" xml:space="preserve">
          <source>Expressions in IEx</source>
          <target state="translated">IEx中的表达式</target>
        </trans-unit>
        <trans-unit id="8fdb5d77c0ea69e962db331c0331d4ccd1f6e481" translate="yes" xml:space="preserve">
          <source>External dependencies</source>
          <target state="translated">外部依赖性</target>
        </trans-unit>
        <trans-unit id="ecfbef1298f91628d1f080163cdf6946c9def817" translate="yes" xml:space="preserve">
          <source>External dependencies are the ones not tied to your business domain. For example, if you need an HTTP API for your distributed KV application, you can use the &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; project as an external dependency.</source>
          <target state="translated">外部依赖关系是与您的业务领域无关的关系。例如，如果您的分布式KV应用程序需要HTTP API，则可以将&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;项目用作外部依赖项。</target>
        </trans-unit>
        <trans-unit id="95e8ae6e88b22e27a03f7d64d058e8d835494561" translate="yes" xml:space="preserve">
          <source>Extracts all protocols from the given paths.</source>
          <target state="translated">从给定路径中提取所有协议。</target>
        </trans-unit>
        <trans-unit id="6672f515f4795b7a00946cd73a72fe3b0d731698" translate="yes" xml:space="preserve">
          <source>Extracts all records information from an Erlang file.</source>
          <target state="translated">从Erlang文件中提取所有记录信息。</target>
        </trans-unit>
        <trans-unit id="0aa4ae6318b818f36730be7bf017b931ef4ea73b" translate="yes" xml:space="preserve">
          <source>Extracts all types implemented for the given protocol from the given paths.</source>
          <target state="translated">从给定的路径中提取所有给定协议的实现类型。</target>
        </trans-unit>
        <trans-unit id="fe0c75ba33dd78a4066417d5f149fc1b26fb8202" translate="yes" xml:space="preserve">
          <source>Extracts record information from an Erlang file.</source>
          <target state="translated">从Erlang文件中提取记录信息。</target>
        </trans-unit>
        <trans-unit id="574d59827e0eb28bc33410c7d28d8d1801cae6ee" translate="yes" xml:space="preserve">
          <source>Extracts the part of the binary starting at &lt;code&gt;start&lt;/code&gt; with length &lt;code&gt;length&lt;/code&gt;. Binaries are zero-indexed.</source>
          <target state="translated">从长度 &lt;code&gt;length&lt;/code&gt; 处 &lt;code&gt;start&lt;/code&gt; 提取二进制的部分。二进制文件是零索引的。</target>
        </trans-unit>
        <trans-unit id="09fef5d8d9a3c86b2523fef60d512606e7fe0003" translate="yes" xml:space="preserve">
          <source>Failed</source>
          <target state="translated">Failed</target>
        </trans-unit>
        <trans-unit id="96fff357d65451f89027b22467cd65b418ae720a" translate="yes" xml:space="preserve">
          <source>Failing guards</source>
          <target state="translated">失败的警卫</target>
        </trans-unit>
        <trans-unit id="1652d7e1326512444d5398f784563f91db27adf9" translate="yes" xml:space="preserve">
          <source>Failing to specify the size for the non-last causes compilation to fail:</source>
          <target state="translated">未指定非最后的大小会导致编译失败。</target>
        </trans-unit>
        <trans-unit id="a8f785f9330c1e75e28a2a7140d3aec99d182b95" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="translated">如果名称未注册到任何PID或端口，则失败，出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6d0b09e283994372eb19fd9e9acdd66b7d8a5ff" translate="yes" xml:space="preserve">
          <source>Fails with a message.</source>
          <target state="translated">失败的消息。</target>
        </trans-unit>
        <trans-unit id="d98c0b711b96d90c648aa1ba79214b16cf3c847f" translate="yes" xml:space="preserve">
          <source>Faint (decreased intensity). Not widely supported.</source>
          <target state="translated">微弱(强度降低)。未得到广泛支持。</target>
        </trans-unit>
        <trans-unit id="80eafe8c844b802892eae9dec9a932d3aae704a2" translate="yes" xml:space="preserve">
          <source>Fallback to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">后退到 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e83224357f427a57043b90f12511c5e7c2761fe6" translate="yes" xml:space="preserve">
          <source>Falsy values (of which there are exactly two):</source>
          <target state="translated">虚值(其中正好有两个)。</target>
        </trans-unit>
        <trans-unit id="84961cf65129825950c4fb505dbebfa0af3c33d5" translate="yes" xml:space="preserve">
          <source>Feel free to go ahead and do the changes above and write some unit tests. The idea is that your tests will start an instance of the &lt;code&gt;KV.Registry&lt;/code&gt; and pass it as an argument to &lt;code&gt;run/2&lt;/code&gt; instead of relying on the global &lt;code&gt;KV.Registry&lt;/code&gt;. This has the advantage of keeping our tests asynchronous as there is no shared state.</source>
          <target state="translated">请继续进行上述更改并编写一些单元测试。这个想法是，您的测试将启动 &lt;code&gt;KV.Registry&lt;/code&gt; 的实例并将其作为参数传递给 &lt;code&gt;run/2&lt;/code&gt; ,而不是依赖于全局 &lt;code&gt;KV.Registry&lt;/code&gt; 。由于没有共享状态，因此具有使测试保持异步的优势。</target>
        </trans-unit>
        <trans-unit id="c0e97bf839fe5fe85207b4a9d492c885c7fec652" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; and returns it in a tuple.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值，并将其返回到元组。</target>
        </trans-unit>
        <trans-unit id="e51d5ee9800fb6a00e8f93feaec0009d2b77b447" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;, erroring out if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取给定 &lt;code&gt;map&lt;/code&gt; 特定 &lt;code&gt;key&lt;/code&gt; 的值，如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则会出错。</target>
        </trans-unit>
        <trans-unit id="a43e0afb7d744e48d3c341e4b08f1f780c55b575" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">获取给定 &lt;code&gt;map&lt;/code&gt; 特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e32be0757ce9c975d2425bacc76ae29c90d94cf3" translate="yes" xml:space="preserve">
          <source>Fetches the value for specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f5f8f513b41db299570bc23df8a5cd56d7a7348b" translate="yes" xml:space="preserve">
          <source>Fetches the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取容器中给定键的值（实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="31798ce3f2f936a238f0a2c5ab7cdb503c7ea839" translate="yes" xml:space="preserve">
          <source>File permissions are specified by adding together the following octal modes:</source>
          <target state="translated">文件权限通过将以下八进制模式相加来指定。</target>
        </trans-unit>
        <trans-unit id="e9762f0351951cf7ed47c0893d9de2c36796a05d" translate="yes" xml:space="preserve">
          <source>File.CopyError</source>
          <target state="translated">File.CopyError</target>
        </trans-unit>
        <trans-unit id="7b57f930765dd268a9cde88eaefc8e395b0beb29" translate="yes" xml:space="preserve">
          <source>File.CopyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.CopyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="27e1fc83e1258e80dfd4127d0a4ce93324162992" translate="yes" xml:space="preserve">
          <source>File.Error</source>
          <target state="translated">File.Error</target>
        </trans-unit>
        <trans-unit id="8354290eb6b6ea2cbcbaa3bd4c48c21f5649591a" translate="yes" xml:space="preserve">
          <source>File.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.Error &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5561cc6859be7830bb0219495771f2109757df2e" translate="yes" xml:space="preserve">
          <source>File.LinkError</source>
          <target state="translated">File.LinkError</target>
        </trans-unit>
        <trans-unit id="ff963e9e333fceee8593af446c12736218860d8a" translate="yes" xml:space="preserve">
          <source>File.LinkError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.LinkError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="34595af71c483f8de72a2abf0c30fcef3475a04a" translate="yes" xml:space="preserve">
          <source>File.RenameError</source>
          <target state="translated">File.RenameError</target>
        </trans-unit>
        <trans-unit id="918afebd70d1938336f0bcc22b61603501a5ef93" translate="yes" xml:space="preserve">
          <source>File.RenameError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.RenameError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="26a6590f983813e802ea4c694400ea32fe379883" translate="yes" xml:space="preserve">
          <source>File.Stat</source>
          <target state="translated">File.Stat</target>
        </trans-unit>
        <trans-unit id="665c1dadb9609c9481c5f8ebc57dca4f06031e23" translate="yes" xml:space="preserve">
          <source>File.Stream</source>
          <target state="translated">File.Stream</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="e4b01a2510691aed09a9f3e1dbbc4fcd455e3aee" translate="yes" xml:space="preserve">
          <source>Filters can also be given:</source>
          <target state="translated">也可以给过滤器。</target>
        </trans-unit>
        <trans-unit id="8e53af0e96b0cc30e1acdc06f0e1e173375388aa" translate="yes" xml:space="preserve">
          <source>Filters the &lt;code&gt;enumerable&lt;/code&gt;, i.e. returns only those elements for which &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">过滤 &lt;code&gt;enumerable&lt;/code&gt; ，即仅返回 &lt;code&gt;fun&lt;/code&gt; 返回其真实值的那些元素。</target>
        </trans-unit>
        <trans-unit id="38e91ba97986e6ce700c58bdd7ad300d67734ab8" translate="yes" xml:space="preserve">
          <source>Final note</source>
          <target state="translated">最后说明</target>
        </trans-unit>
        <trans-unit id="35edd1c925c63232dc7f42b120954fad87230406" translate="yes" xml:space="preserve">
          <source>Finally note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it may be removed after consolidation.</source>
          <target state="translated">最后注意，所有协议都编译 &lt;code&gt;debug_info&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 的，不管选项集 &lt;code&gt;elixirc&lt;/code&gt; 编译器。调试信息用于合并，合并后可以将其删除。</target>
        </trans-unit>
        <trans-unit id="04fdf1c25fdd5f8a57c6967c66cfb3a7de5f847e" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;setup_all&lt;/code&gt; callbacks run in a separate process per module, while all &lt;code&gt;setup&lt;/code&gt; callbacks run in the same process as the test itself. &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt; callbacks always run in a separate process, as implied by their name. The test process always exits with reason &lt;code&gt;:shutdown&lt;/code&gt;, which means any process linked to the test process will also exit, although asynchronously. Therefore it is preferred to use &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; to guarantee synchronous termination.</source>
          <target state="translated">最后， &lt;code&gt;setup_all&lt;/code&gt; 回调在每个模块的单独进程中运行，而所有 &lt;code&gt;setup&lt;/code&gt; 回调在与测试本身相同的进程中运行。&lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt;回调始终如其名称所暗示的那样在单独的进程中运行。测试过程总是以 &lt;code&gt;:shutdown&lt;/code&gt; 原因退出，这意味着链接到测试过程的任何进程也将退出，尽管是异步的。因此，最好使用&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt;来保证同步终止。</target>
        </trans-unit>
        <trans-unit id="4a48b23e11b49db2f57e13074e7a2452579f61b9" translate="yes" xml:space="preserve">
          <source>Finally, Elixir has a construct called aliases which we will explore later. Aliases start in upper case and are also atoms:</source>
          <target state="translated">最后,Elixir有一个叫做别名的构造,我们将在后面探讨。别名以大写字母开头,也是原子。</target>
        </trans-unit>
        <trans-unit id="f1f7036035e55443b9fb00eab5b0f156761b7796" translate="yes" xml:space="preserve">
          <source>Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix help archive.build&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix help escript.build&lt;/code&gt;&lt;/a&gt; for more detail.</source>
          <target state="translated">最后，Elixir提供了诸如脚本和存档之类的工具，它们是打包应用程序的不同机制。通常在必须在开发人员之间共享工具而不是将其作为部署选项时使用。有关更多详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix help archive.build&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix help escript.build&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51f5f67bdc287fa28acb4c9223c262389c58e3ea" translate="yes" xml:space="preserve">
          <source>Finally, aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;mix.tasks.clean&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="translated">最后，别名也可以用于扩充现有任务。假设您想增加&lt;a href=&quot;mix.tasks.clean&quot;&gt; &lt;code&gt;mix clean&lt;/code&gt; &lt;/a&gt;来清理Mix不知道的另一个目录：</target>
        </trans-unit>
        <trans-unit id="191e1198a5b11d86c8e069a1379cf393ac7fbbc2" translate="yes" xml:space="preserve">
          <source>Finally, anonymous functions are also closures and as such they can access variables that are in scope when the function is defined. Let&amp;rsquo;s define a new anonymous function that uses the &lt;code&gt;add&lt;/code&gt; anonymous function we have previously defined:</source>
          <target state="translated">最后，匿名函数也是闭包，因此，它们可以访问定义函数时范围内的变量。让我们定义一个新的匿名函数，该函数使用我们先前定义的 &lt;code&gt;add&lt;/code&gt; 匿名函数：</target>
        </trans-unit>
        <trans-unit id="4f8f9ee80a4128eebbd8b8d0785f0bf4b51354e3" translate="yes" xml:space="preserve">
          <source>Finally, attributes can also be read inside functions:</source>
          <target state="translated">最后,属性也可以在函数里面读取。</target>
        </trans-unit>
        <trans-unit id="668fb656f73feadaab2b70bd66310c5a6a4ae07c" translate="yes" xml:space="preserve">
          <source>Finally, beware of redundant code comments, such as the ones describing the exact same that the code does:</source>
          <target state="translated">最后,要小心多余的代码注释,比如描述与代码完全相同的代码。</target>
        </trans-unit>
        <trans-unit id="1083a91a64ef83410037ffb35fd49e9fb40c270f" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="translated">最后，检查&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;以了解其他受支持的操作。</target>
        </trans-unit>
        <trans-unit id="f726a5d73225d60359e8c4f7a62c08247c5e3152" translate="yes" xml:space="preserve">
          <source>Finally, copy the &lt;code&gt;kv&lt;/code&gt; application we have built so far to the &lt;code&gt;apps&lt;/code&gt; directory in our new umbrella project. The final directory structure should match the structure we mentioned earlier:</source>
          <target state="translated">最后，将到目前为止已构建的 &lt;code&gt;kv&lt;/code&gt; 应用程序复制到新的伞项目中的 &lt;code&gt;apps&lt;/code&gt; 目录中。最终目录结构应与我们前面提到的结构匹配：</target>
        </trans-unit>
        <trans-unit id="fab90ae3564b828d174f4a1339c23b2f23ef10c1" translate="yes" xml:space="preserve">
          <source>Finally, developers should also avoid defining functions inside the &lt;code&gt;__using__/1&lt;/code&gt; callback, unless those functions are the default implementation of a previously defined &lt;code&gt;@callback&lt;/code&gt; or are functions meant to be overridden (see &lt;a href=&quot;#defoverridable/1&quot;&gt;&lt;code&gt;defoverridable/1&lt;/code&gt;&lt;/a&gt;). Even in these cases, defining functions should be seen as a &quot;last resort&quot;.</source>
          <target state="translated">最后，开发人员还应避免在 &lt;code&gt;__using__/1&lt;/code&gt; 回调中定义函数，除非这些函数是先前定义的 &lt;code&gt;@callback&lt;/code&gt; 的默认实现或要重写的函数（请参阅&lt;a href=&quot;#defoverridable/1&quot;&gt; &lt;code&gt;defoverridable/1&lt;/code&gt; &lt;/a&gt;）。即使在这些情况下，定义功能也应被视为&amp;ldquo;万不得已&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a5904f73dbbcd0930c32f8ef2421f6ebf86cef4" translate="yes" xml:space="preserve">
          <source>Finally, different from the other callbacks, we have defined a &amp;ldquo;catch-all&amp;rdquo; clause for &lt;code&gt;handle_info/2&lt;/code&gt; that discards any unknown message. To understand why, let&amp;rsquo;s move on to the next section.</source>
          <target state="translated">最后，与其他回调不同，我们为 &lt;code&gt;handle_info/2&lt;/code&gt; 定义了一个&amp;ldquo; catch-all&amp;rdquo;子句，该子句会丢弃所有未知消息。要了解原因，让我们继续下一节。</target>
        </trans-unit>
        <trans-unit id="2dca70c0e3d6a9acaabab7bc96177fe2d9c44844" translate="yes" xml:space="preserve">
          <source>Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">最后,不要在Unicode模式的IO设备上使用这个函数,因为它会返回错误的结果。</target>
        </trans-unit>
        <trans-unit id="b0a0fcc78d43cdb2d5efe08a2aa140520d91d3bf" translate="yes" xml:space="preserve">
          <source>Finally, it also documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="translated">最后，它还记录了两种特殊形式&lt;a href=&quot;#__block__/1&quot;&gt; &lt;code&gt;__block__/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt;，它们不希望开发人员直接调用，但它们出现在引用的内容中，因为它们在Elixir的构造中必不可少。</target>
        </trans-unit>
        <trans-unit id="f74f8991d0d3c9a479fe59d35b99b4abf4e6cf52" translate="yes" xml:space="preserve">
          <source>Finally, it's advised to profile your program with the &lt;code&gt;prod&lt;/code&gt; environment, since this should provide more realistic insights into bottlenecks.</source>
          <target state="translated">最后，建议您在 &lt;code&gt;prod&lt;/code&gt; 环境中分析您的程序，因为这样可以对瓶颈提供更实际的见解。</target>
        </trans-unit>
        <trans-unit id="04258f441df3a0685acf7dc84f54350179d26c35" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that applications in an umbrella project all share the same configurations and dependencies. If two applications in your umbrella need to configure the same dependency in drastically different ways or even use different versions, you have probably outgrown the benefits brought by umbrellas. Remember you can break the umbrella and still leverage the benefits behind &amp;ldquo;mono-repos&amp;rdquo;.</source>
          <target state="translated">最后，请记住，伞项目中的应用程序都共享相同的配置和依赖项。如果您的保护伞中的两个应用程序需要以完全不同的方式甚至使用不同的版本来配置相同的依赖项，那么您可能已经超出了保护伞所带来的好处。请记住，您可以打起伞，仍然可以利用&amp;ldquo;单一回购协议&amp;rdquo;背后的好处。</target>
        </trans-unit>
        <trans-unit id="b17d2e9b41800db01905629d7c64202ebf54e9fc" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="translated">最后,请记住,在理解体内部的变量赋值,无论是在生成器、过滤器还是在块内部,都不会反映在理解体外部。</target>
        </trans-unit>
        <trans-unit id="7b0dc026cfea9e2e7b1becee88cabf1eed936967" translate="yes" xml:space="preserve">
          <source>Finally, note &lt;code&gt;cond&lt;/code&gt; considers any value besides &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to be true:</source>
          <target state="translated">最后，注意 &lt;code&gt;cond&lt;/code&gt; 认为除 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 之外的任何值都为true：</target>
        </trans-unit>
        <trans-unit id="7a86bfddfc1fd1f3cd3bcab92a5988d59aa4d019" translate="yes" xml:space="preserve">
          <source>Finally, note it is also possible to simply pass the &lt;code&gt;Stack&lt;/code&gt; module as a child:</source>
          <target state="translated">最后，请注意，也可以简单地将 &lt;code&gt;Stack&lt;/code&gt; 模块作为子代传递：</target>
        </trans-unit>
        <trans-unit id="60bc3c90be2296af6dc74f8ac6ed31dee639afd7" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="translated">最后，请注意&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数急切：它们将在被调用后立即遍历可枚举。当使用无穷枚举时，这特别危险。在这种情况下，应使用&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块，该模块允许您懒散地表示计算而无需遍历集合，并可以处理无限个集合。有关示例和文档，请参见&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="12f0160206d216529166c8634dc691e626760b5b" translate="yes" xml:space="preserve">
          <source>Finally, notice that attributes can also be read inside functions:</source>
          <target state="translated">最后,请注意,属性也可以在函数里面读取。</target>
        </trans-unit>
        <trans-unit id="232829bb783ca862d2a7fbdd06c1982a8e6d4a55" translate="yes" xml:space="preserve">
          <source>Finally, remember you can also get a mini-overview of the runtime info by calling &lt;code&gt;runtime_info/0&lt;/code&gt; directly in IEx.</source>
          <target state="translated">最后，请记住，您还可以通过直接在IEx中调用 &lt;code&gt;runtime_info/0&lt;/code&gt; 来获得运行时信息的小型概述。</target>
        </trans-unit>
        <trans-unit id="3d4e093b24b7868fdbb88889dcf9d11e7ebbe5c8" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; will import other config files, based on the current Mix environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">最后，行 &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; 将基于当前Mix环境导入其他配置文件，例如 &lt;code&gt;config/dev.exs&lt;/code&gt; 和 &lt;code&gt;config/test.exs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="321ba25e566c212d784496c47ffc76a0ad896628" translate="yes" xml:space="preserve">
          <source>Finally, the stacktrace relates to the failure itself, giving information about the test and often the place the failure was generated from within the source files.</source>
          <target state="translated">最后,stacktrace与失败本身有关,给出了有关测试的信息,而且往往是失败从源文件中产生的地方。</target>
        </trans-unit>
        <trans-unit id="3f56c580dd08d36a6b47e54333acfe9e1d8d30e4" translate="yes" xml:space="preserve">
          <source>Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as &lt;a href=&quot;#to_doc/2&quot;&gt;&lt;code&gt;to_doc/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最后，该模块还包含与Elixir相关的功能，与Elixir格式有点联系，例如&lt;a href=&quot;#to_doc/2&quot;&gt; &lt;code&gt;to_doc/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29c7d0203ff19b759dff9a8dcf709329c059ef93" translate="yes" xml:space="preserve">
          <source>Finally, you may have observed that each doctest corresponds to a different test in our suite, which now reports a total of 7 doctests. That is because ExUnit considers the following to define two different doctests:</source>
          <target state="translated">最后,你可能已经观察到,在我们的套件中,每个doctest对应一个不同的测试,现在总共报告了7个doctests。这是因为ExUnit认为下面定义了两个不同的doctests。</target>
        </trans-unit>
        <trans-unit id="82318fe7e7a021f4fa35e9409276a28582c98da1" translate="yes" xml:space="preserve">
          <source>Find more about the pipe operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;by reading its documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;通过阅读其文档，&lt;/a&gt;找到有关管道操作员的更多信息。</target>
        </trans-unit>
        <trans-unit id="e44a6c20b46b4eb7ebeba1748cd0e7795b1fd20f" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;{pid, value}&lt;/code&gt; pair for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; in no particular order.</source>
          <target state="translated">发现 &lt;code&gt;{pid, value}&lt;/code&gt; 对，用于给定的 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;registry&lt;/code&gt; 中没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="d980122971e9d4fe80a33e7b799338a83929abd3" translate="yes" xml:space="preserve">
          <source>Finds the element at the given &lt;code&gt;index&lt;/code&gt; (zero-based).</source>
          <target state="translated">查找给定 &lt;code&gt;index&lt;/code&gt; 处的元素（从零开始）。</target>
        </trans-unit>
        <trans-unit id="fdbbbf2a367be4fcd9eca718811c5a61aea8c66b" translate="yes" xml:space="preserve">
          <source>First of all, since we generated this project inside &lt;code&gt;kv_umbrella/apps&lt;/code&gt;, Mix automatically detected the umbrella structure and added four lines to the project definition:</source>
          <target state="translated">首先，由于我们在 &lt;code&gt;kv_umbrella/apps&lt;/code&gt; 内部生成了此项目，因此Mix自动检测到了伞形结构，并在项目定义中添加了四行：</target>
        </trans-unit>
        <trans-unit id="0b225f4fd1da05fdbc3ee99a9f166606b1d95c47" translate="yes" xml:space="preserve">
          <source>First, if the routing tables are the opposite of each other, such as &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; in one node and &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; in the other, you can have a routing request that will run recursively in the cluster infinitely. This can be tackled at the application level by making sure you pass a list of seen nodes when we route, such as &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt;. Then by checking if the node being dispatched to was already visited, we can avoid the cycle. Implementing and testing this functionality will be left as an exercise.</source>
          <target state="translated">首先，如果路由表彼此相反，例如 &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; 在一个节点和 &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; 在另一方面，可以有一个路由请求，该请求将在群集中无限递归地运行。这可以在应用程序级别通过确保您在路由时传递可见节点列表来解决，例如 &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt; 。然后通过检查被调度到的节点是否已经被访问，我们可以避免周期。实施和测试此功能将作为练习。</target>
        </trans-unit>
        <trans-unit id="fe6a7fa579eecc0b0104d2aa94bc63bd9d9aa9d6" translate="yes" xml:space="preserve">
          <source>First, the &lt;code&gt;request&lt;/code&gt; is sent to every node in &lt;code&gt;nodes&lt;/code&gt;; then, the caller waits for the replies. This function returns a two-element tuple &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; where:</source>
          <target state="translated">首先， &lt;code&gt;request&lt;/code&gt; 被发送到节点中的每个 &lt;code&gt;nodes&lt;/code&gt; ；然后，呼叫者等待答复。此函数返回一个由两个元素组成的元组 &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="60398b803dd263be0dc63a6c96308aea282994d5" translate="yes" xml:space="preserve">
          <source>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. Optional behaviour, such as &lt;code&gt;:rename_deprecated_at&lt;/code&gt;, is allowed to break this guarantee.</source>
          <target state="translated">首先，格式化程序默认情况下不会更改代码的语义。这意味着输入AST和输出AST是等效的。允许使用可选行为，例如 &lt;code&gt;:rename_deprecated_at&lt;/code&gt; 来打破此保证。</target>
        </trans-unit>
        <trans-unit id="761d6955efc7722bb7c5e17c7ad9ae6eee0e3a82" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists.</source>
          <target state="translated">展平嵌套列表的给定 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="384278e07033851614565e0c9f8e0ea314279560" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists. The list &lt;code&gt;tail&lt;/code&gt; will be added at the end of the flattened list.</source>
          <target state="translated">展平嵌套列表的给定 &lt;code&gt;list&lt;/code&gt; 。列表 &lt;code&gt;tail&lt;/code&gt; 将添加到拼合列表的末尾。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="e0ed30f7614c69e32cbce2c9fd0bd8fcaa7586e6" translate="yes" xml:space="preserve">
          <source>Float numbers require a dot followed by at least one digit and also support &lt;code&gt;e&lt;/code&gt; for scientific notation:</source>
          <target state="translated">浮点数要求点号后跟至少一位数字，并且还支持 &lt;code&gt;e&lt;/code&gt; 表示科学计数法：</target>
        </trans-unit>
        <trans-unit id="a4495969af61f575a24ee4711fa76dfaafb26d0e" translate="yes" xml:space="preserve">
          <source>Floats in Elixir are 64-bit double precision.</source>
          <target state="translated">Elixir中的浮点数为64位双精度。</target>
        </trans-unit>
        <trans-unit id="9ee393efb1b19d0c371e21c8a5d6360e13a111b0" translate="yes" xml:space="preserve">
          <source>Flushes all &lt;code&gt;:mix_shell&lt;/code&gt; and &lt;code&gt;:mix_shell_input&lt;/code&gt; messages from the current process.</source>
          <target state="translated">刷新当前进程中的所有 &lt;code&gt;:mix_shell&lt;/code&gt; 和 &lt;code&gt;:mix_shell_input&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="1f37e32316ff57285093c07bcc6fa68a47a4a700" translate="yes" xml:space="preserve">
          <source>Flushes the logger.</source>
          <target state="translated">刷新记录仪。</target>
        </trans-unit>
        <trans-unit id="d44af71a2582a2b67261bbce0307838133bc552a" translate="yes" xml:space="preserve">
          <source>Flushes the output buffer and returns its current contents.</source>
          <target state="translated">刷新输出缓冲区并返回当前内容。</target>
        </trans-unit>
        <trans-unit id="1fd9c42d3180adcefdbd370b8adb9856f5a36877" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the left with a function. Requires an accumulator.</source>
          <target state="translated">用一个函数将给定的列表从左边折叠(减少)。需要一个累加器。</target>
        </trans-unit>
        <trans-unit id="569c663a35f673e18e4fd8649f95dd98dfc6e9c3" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the right with a function. Requires an accumulator.</source>
          <target state="translated">用一个函数将给定的列表从右边折叠(减少)。需要一个累加器。</target>
        </trans-unit>
        <trans-unit id="2fa0635488dcee65136d608f773cf5f9ef5e7acf" translate="yes" xml:space="preserve">
          <source>Folds a list of documents into a document using the given folder function.</source>
          <target state="translated">使用给定的文件夹功能将一个文档列表折叠成一个文档。</target>
        </trans-unit>
        <trans-unit id="708d44cdbbf26cc5087abdc9244c378da50e27f8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;call/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_call/3&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt;, the process from which we received the request (&lt;code&gt;_from&lt;/code&gt;), and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_call/3&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt;. The first element of the tuple, &lt;code&gt;:reply&lt;/code&gt;, indicates that the server should send a reply back to the client. The second element, &lt;code&gt;reply&lt;/code&gt;, is what will be sent to the client while the third, &lt;code&gt;new_state&lt;/code&gt; is the new server state.</source>
          <target state="translated">对于 &lt;code&gt;call/2&lt;/code&gt; 请求，我们实现了一个 &lt;code&gt;handle_call/3&lt;/code&gt; 回调 &lt;code&gt;_from&lt;/code&gt; ，该回调函数接收 &lt;code&gt;request&lt;/code&gt; ，接收请求的过程（_from）和当前服务器状态（ &lt;code&gt;names&lt;/code&gt; ）。所述 &lt;code&gt;handle_call/3&lt;/code&gt; 回调返回格式的元组 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 。元组的第一个元素 &lt;code&gt;:reply&lt;/code&gt; ，指示服务器应将回复发送回客户端。第二个元素 &lt;code&gt;reply&lt;/code&gt; 是将发送到客户端的内容，第三个元素 &lt;code&gt;new_state&lt;/code&gt; 是新服务器状态。</target>
        </trans-unit>
        <trans-unit id="85fe9a9b5eab6f7837fd7ce17f20db0e36c96d5e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cast/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_cast/2&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt; and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_cast/2&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:noreply, new_state}&lt;/code&gt;. Note that in a real application we would have probably implemented the callback for &lt;code&gt;:create&lt;/code&gt; with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.</source>
          <target state="translated">对于 &lt;code&gt;cast/2&lt;/code&gt; 请求，我们实现了 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调，该回调接收 &lt;code&gt;request&lt;/code&gt; 和当前服务器状态（ &lt;code&gt;names&lt;/code&gt; ）。所述 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调格式返回一个元组 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 。请注意，在实际的应用程序中，我们可能会使用同步调用而不是异步强制转换来实现 &lt;code&gt;:create&lt;/code&gt; 的回调。我们通过这种方式来说明如何实现强制转换回调。</target>
        </trans-unit>
        <trans-unit id="3c507ce5e858adfd9920b90e4c749fbfaa148e35" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt; &lt;code&gt;:compile.file/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e1748b035236f7578aca77841e51909dcda09f3" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt;&lt;code&gt;:yecc.file/1&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt; &lt;code&gt;:yecc.file/1&lt;/code&gt; &lt;/a&gt;。注意 &lt;code&gt;:report&lt;/code&gt; ， &lt;code&gt;:return_errors&lt;/code&gt; 和 &lt;code&gt;:return_warnings&lt;/code&gt; 选项被此编译器覆盖，因此设置它们无效。</target>
        </trans-unit>
        <trans-unit id="5de5c09f365a342ca1f4adef5fcae8f98c944b89" translate="yes" xml:space="preserve">
          <source>For a detailed explanation it's worth reading the analysis in &lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;Erlang/OTP documentation for fprof&lt;/a&gt;.</source>
          <target state="translated">有关详细说明，值得阅读&lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;fprof的Erlang / OTP文档中的分析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="455bca35994e1d4d5c63a42b082bcc28685c8fab" translate="yes" xml:space="preserve">
          <source>For a more complete rundown on the VM support for different times, see the &lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;chapter on time and time correction&lt;/a&gt; in the Erlang docs.</source>
          <target state="translated">有关不同时间对VM支持的更全面的了解，请参阅Erlang文档中&lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;有关时间和时间校正&lt;/a&gt;的章节。</target>
        </trans-unit>
        <trans-unit id="2ad3bd05a62d0ba912c71da5b141b89b54b65bc7" translate="yes" xml:space="preserve">
          <source>For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section.</source>
          <target state="translated">要想更全面地了解退出原因及其影响,请参见 &quot;退出原因与重启 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="282328027889720b4154eca4c4806b544bc3a754" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更深入的说明，请阅读&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;关闭值（：shutdown）&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="37b344bcdc0c7b8779f65785a14e8c7aa3e5ded0" translate="yes" xml:space="preserve">
          <source>For accessing atom keys, one may also &lt;code&gt;map.key&lt;/code&gt;. Note that while &lt;code&gt;map[key]&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;map.key&lt;/code&gt; will raise if &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;.</source>
          <target state="translated">为了访问原子密钥，还可以使用 &lt;code&gt;map.key&lt;/code&gt; 。请注意，如果 &lt;code&gt;map[key]&lt;/code&gt; 如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;map.key&lt;/code&gt; 如果 &lt;code&gt;map&lt;/code&gt; 不包含key &lt;code&gt;:key&lt;/code&gt; ，则map.key将引发。</target>
        </trans-unit>
        <trans-unit id="57b9d70004f10cc3b53d8d1fb3e515752a611d21" translate="yes" xml:space="preserve">
          <source>For all other time zones, it returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt;.</source>
          <target state="translated">对于所有其他时区，它返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f912dfac4d0836d413b5ac057a2a5efa533103ff" translate="yes" xml:space="preserve">
          <source>For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration.</source>
          <target state="translated">对于其余所有的场景,库不应该强迫用户使用应用环境进行配置。如果库的用户认为某些参数应该全局配置,那么他们可以用自己的应用环境配置来包装库的功能。</target>
        </trans-unit>
        <trans-unit id="5c0878fd6cedf49cadfbc1ce37dc2efcc64e9280" translate="yes" xml:space="preserve">
          <source>For anonymous functions, there is also information about any of the atoms &lt;code&gt;:index&lt;/code&gt;, &lt;code&gt;:new_index&lt;/code&gt;, &lt;code&gt;:new_uniq&lt;/code&gt;, &lt;code&gt;:uniq&lt;/code&gt;, and &lt;code&gt;:pid&lt;/code&gt;. For a named function, the value of any of these items is always the atom &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">对于匿名函数，还提供有关任何原子的信息 &lt;code&gt;:index&lt;/code&gt; ， &lt;code&gt;:new_index&lt;/code&gt; ， &lt;code&gt;:new_uniq&lt;/code&gt; ， &lt;code&gt;:uniq&lt;/code&gt; 和 &lt;code&gt;:pid&lt;/code&gt; 。对于命名函数，这些项目中任何一项的值始终为atom &lt;code&gt;:undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b4ad9d30cceadfeb05cba1ddc74ec23c371587e" translate="yes" xml:space="preserve">
          <source>For any function, the information asked for can be any of the atoms &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:name&lt;/code&gt;, &lt;code&gt;:arity&lt;/code&gt;, &lt;code&gt;:env&lt;/code&gt;, or &lt;code&gt;:type&lt;/code&gt;.</source>
          <target state="translated">对于任何功能，要求的信息可以是原子 &lt;code&gt;:module&lt;/code&gt; ， &lt;code&gt;:name&lt;/code&gt; ， &lt;code&gt;:arity&lt;/code&gt; ， &lt;code&gt;:env&lt;/code&gt; 或 &lt;code&gt;:type&lt;/code&gt; 中的任何一个。</target>
        </trans-unit>
        <trans-unit id="19051a75616b4ec98796f8226da734aa9dd4e72d" translate="yes" xml:space="preserve">
          <source>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</source>
          <target state="translated">对于二进制文件,默认是二进制文件的大小。只有匹配中的最后一个二进制文件可以使用默认大小。所有其他的二进制文件必须明确地指定它们的大小,即使匹配是毫不含糊的。例如</target>
        </trans-unit>
        <trans-unit id="bee446e092800012625413c21226bed4c6f88b01" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="translated">对于上述情况，&lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bcf46e59d6f52359a868d6e88a0b7c5725001a1" translate="yes" xml:space="preserve">
          <source>For companies and teams, we recommend developers to run &lt;code&gt;mix format --check-formatted&lt;/code&gt; on their continuous integration servers, ensuring all current and future code follows the standard.</source>
          <target state="translated">对于公司和团队，我们建议开发人员在其连续集成服务器上运行 &lt;code&gt;mix format --check-formatted&lt;/code&gt; ，以确保当前和将来的所有代码均符合标准。</target>
        </trans-unit>
        <trans-unit id="5b735130a48640def7fafe41aafe71355bd32d99" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关同时编译许多文件的信息，请参见&lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc1c26fa0cb08e8439005305225bde72db303603" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="translated">为方便起见，您可以传递&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，并且当前环境中定义的所有导入，需求和别名将自动保留：</target>
        </trans-unit>
        <trans-unit id="98082b67d38ae575b213c7f51ae3f6f67492121c" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="translated">为了方便起见，您可以传递&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，所有选项将自动从当前环境中提取：</target>
        </trans-unit>
        <trans-unit id="54af569b6a029610c5091d98fd6f8fdc1073fe13" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="translated">为了方便起见，您可以将任何&lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;结构（例如&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;）作为第一个参数或选项。模块和所有选项都将自动从环境中提取：</target>
        </trans-unit>
        <trans-unit id="74cba56f60db3c6914d9e9b93e9bb138f70a33f1" translate="yes" xml:space="preserve">
          <source>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's &lt;code&gt;:unicode&lt;/code&gt; module.</source>
          <target state="translated">有关将二进制文件转换为其他编码以及Unicode规范化机制的信息，请参见Erlang的 &lt;code&gt;:unicode&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="6add89b99abcbf70ca9badb7516b8595c553f524" translate="yes" xml:space="preserve">
          <source>For debugging complex systems, jumping at the code is not enough. It is necessary to have an understanding of the whole virtual machine, processes, applications, as well as set up tracing mechanisms. Luckily this can be achieved in Erlang with &lt;code&gt;:observer&lt;/code&gt;. In your application:</source>
          <target state="translated">对于调试复杂的系统，仅跳转代码是不够的。必须了解整个虚拟机，进程，应用程序以及设置跟踪机制。幸运的是，可以使用 &lt;code&gt;:observer&lt;/code&gt; 在Erlang中实现。在您的应用程序中：</target>
        </trans-unit>
        <trans-unit id="312205920e8b42c10300fdc1c0d355fb769ce4d0" translate="yes" xml:space="preserve">
          <source>For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">有关代码点和字素的详细信息，请参见&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块文档。</target>
        </trans-unit>
        <trans-unit id="0f4a8cd91cf5db5cd126fba13df45a267644abde" translate="yes" xml:space="preserve">
          <source>For duplicate registries:</source>
          <target state="translated">对于重复的登记册:</target>
        </trans-unit>
        <trans-unit id="72d0f0434fbcec9eb207f396a9fc529d7587b375" translate="yes" xml:space="preserve">
          <source>For dynamically logging messages, see &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt;. But note that &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; always evaluates its arguments (unless the argument is an anonymous function).</source>
          <target state="translated">有关动态记录消息的信息，请参见&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt;。但是请注意，&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt;始终评估其参数（除非该参数是匿名函数）。</target>
        </trans-unit>
        <trans-unit id="1a7f7d68ad358e0a245cd7d3ae221748af013919" translate="yes" xml:space="preserve">
          <source>For each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (rhs) of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">对于每次失败，ExUnit都会打印一份详细报告，其中包含带有测试用例的测试名称，失败的代码以及 &lt;code&gt;==&lt;/code&gt; 运算符的左侧和右侧（rhs）的值。</target>
        </trans-unit>
        <trans-unit id="e0fb1546f77232688d241d37ca1d325018f6f776" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;protocol#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于 &lt;code&gt;@derive&lt;/code&gt; 列表中的每个协议，Elixir将断言该协议已针对 &lt;code&gt;Any&lt;/code&gt; 实施。如果 &lt;code&gt;Any&lt;/code&gt; 实现定义了 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调，则将调用该回调，并且应定义实现模块。否则，将自动派生仅指向 &lt;code&gt;Any&lt;/code&gt; 实现的实现。有关 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调的更多信息，请参见&lt;a href=&quot;protocol#derive/3&quot;&gt; &lt;code&gt;Protocol.derive/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ce575e007b24aad8c7c6a66939213cc21ace30a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;the Ecto library&lt;/a&gt; makes use of these features to provide an elegant DSL for writing database queries:</source>
          <target state="translated">例如，&lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;Ecto库&lt;/a&gt;利用这些功能为编写数据库查询提供了优雅的DSL：</target>
        </trans-unit>
        <trans-unit id="72de0d4d0cc3d700aee14fc5035d60936c6b125d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;keyword#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keyword#delete/3&quot;&gt;&lt;code&gt;Keyword.delete/3&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note that operations that require keys to be found in the keyword list (like &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt;) need to traverse the list in order to find keys, so these operations may be slower than their map counterparts.</source>
          <target state="translated">例如，&lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt;将获取与给定键匹配的第一个条目，而不管是否存在重复的条目。同样，&lt;a href=&quot;keyword#put/3&quot;&gt; &lt;code&gt;Keyword.put/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;keyword#delete/3&quot;&gt; &lt;code&gt;Keyword.delete/3&lt;/code&gt; &lt;/a&gt;确保在调用时删除给定键的所有重复条目。请注意，需要在关键字列表中找到键的操作（例如&lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt;）需要遍历列表才能找到键，因此这些操作可能比对应的地图操作慢。</target>
        </trans-unit>
        <trans-unit id="0e6838c5c681ffb29b6c7310ee5d238a1c820319" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="translated">例如，随着输入的增加，&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;将花费更长的时间。另一方面，&lt;a href=&quot;kernel#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt;始终在恒定时间内运行（即，不管输入大小如何）。</target>
        </trans-unit>
        <trans-unit id="c8c117e3a1a342b1f8160acdddadbc25ed7792af" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, and &lt;code&gt;:error&lt;/code&gt; will be printed to the console. If your log level is set to &lt;code&gt;:warn&lt;/code&gt;, only &lt;code&gt;:warn&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt; will be printed.</source>
          <target state="translated">例如， &lt;code&gt;:info&lt;/code&gt; 优先于 &lt;code&gt;:debug&lt;/code&gt; 。如果您的日志级别设置为 &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:warn&lt;/code&gt; 和 &lt;code&gt;:error&lt;/code&gt; ,则会输出到控制台。如果您的日志级别设置为 &lt;code&gt;:warn&lt;/code&gt; ，则仅输出 &lt;code&gt;:warn&lt;/code&gt; 和 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4af1c4caff42157f9481064fecc0d437c1cbd415" translate="yes" xml:space="preserve">
          <source>For example, a bitstring generator can be used with the &lt;code&gt;:into&lt;/code&gt; option in order to easily remove all spaces in a string:</source>
          <target state="translated">例如，位串生成器可以与 &lt;code&gt;:into&lt;/code&gt; 选项一起使用，以便轻松删除字符串中的所有空格：</target>
        </trans-unit>
        <trans-unit id="e07fb9806a4d8ebf20cacc02e52f4a77448a86cc" translate="yes" xml:space="preserve">
          <source>For example, a value that is not meant to be used must be assigned to &lt;code&gt;_&lt;/code&gt; or to a variable starting with underscore:</source>
          <target state="translated">例如，必须将不希望使用的值分配给 &lt;code&gt;_&lt;/code&gt; 或下划线开头的变量：</target>
        </trans-unit>
        <trans-unit id="bafc7c87cc4324b3f378e1b55b1f860c335be286" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="translated">例如，对于&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，我们有：</target>
        </trans-unit>
        <trans-unit id="9f456eb16f2bcd93d7684bd1cc3f45a1a1b9a12d" translate="yes" xml:space="preserve">
          <source>For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages.</source>
          <target state="translated">例如,如果你正在等待一个进程执行某些动作,最好用消息来传达这种动作的进展。</target>
        </trans-unit>
        <trans-unit id="3fcebcea9fb6c7cf3c366b1c527f43067e4ff086" translate="yes" xml:space="preserve">
          <source>For example, if you push the &lt;code&gt;kv&lt;/code&gt; project to a Git repository, you&amp;rsquo;ll need to list it in your deps code in order to use it:</source>
          <target state="translated">例如，如果将 &lt;code&gt;kv&lt;/code&gt; 项目推送到Git存储库，则需要在deps代码中列出它才能使用它：</target>
        </trans-unit>
        <trans-unit id="aa3f335cc98a4af2b77268595737e5b7b1ed0489" translate="yes" xml:space="preserve">
          <source>For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt;, we want to return the map &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt;.</source>
          <target state="translated">例如，假设您有一个带字母的二进制文件，您想计算每个小写字母出现的次数，而忽略所有大写字母。例如，对于字符串 &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt; ，我们想返回映射 &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92738f48db6bf8520616d3f910c86cb70b6a91a2" translate="yes" xml:space="preserve">
          <source>For example, imagine we want to implement a Validator module which provides a data validation domain-specific language. We could implement it using data structures, functions or macros. Let&amp;rsquo;s see what those different DSLs would look like:</source>
          <target state="translated">例如，假设我们要实现一个Validator模块，该模块提供一种数据验证域特定的语言。我们可以使用数据结构，函数或宏来实现它。让我们看看那些不同的DSL是什么样的：</target>
        </trans-unit>
        <trans-unit id="2ea959d5faa9cf257e82d7007ec084b4f335c593" translate="yes" xml:space="preserve">
          <source>For example, imagine you have a variable &lt;code&gt;number&lt;/code&gt; which contains the number you want to inject inside a quoted expression.</source>
          <target state="translated">例如，假设您有一个可变 &lt;code&gt;number&lt;/code&gt; ，其中包含要插入带引号的表达式中的数字。</target>
        </trans-unit>
        <trans-unit id="a2be4f8e8e8f8a802e09e5114bdae52f10f3c768" translate="yes" xml:space="preserve">
          <source>For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this:</source>
          <target state="translated">例如,想象一下你有一个API,它接收一个二进制的文件名。在某些时候,你会想要向这个文件写入。你可以有一个这样的函数。</target>
        </trans-unit>
        <trans-unit id="36f70d74391e0cf5d436981e9565a03fd1f683a6" translate="yes" xml:space="preserve">
          <source>For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like:</source>
          <target state="translated">例如,想象一下,你需要从一个JSON文件中加载一些配置,并将其加载到系统中。所说的配置提供者会是这样的。</target>
        </trans-unit>
        <trans-unit id="e595982d4d16b2fed73877c7eb51c758ba09c9f8" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How do you often fix it? By restarting it. Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="translated">例如,想象一下你的电脑、路由器、打印机或其他什么设备不能正常工作。你经常如何修复它?通过重启它。一旦我们重启设备,我们就会将设备重置回初始状态,这是经得起考验的,并保证能正常工作。在Elixir中,我们将这种方法应用于软件:每当一个进程崩溃时,我们就会启动一个新的进程来执行与崩溃进程相同的工作。</target>
        </trans-unit>
        <trans-unit id="f3cd6f9b58acaa3e0524e83ef7217c631726de0e" translate="yes" xml:space="preserve">
          <source>For example, in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">例如， &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5132419edebfb5538ebf32de072ef747449be00a" translate="yes" xml:space="preserve">
          <source>For example, in order to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">例如，为了写测试用例使用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;设置有药剂框架，显影剂应该 &lt;code&gt;use&lt;/code&gt; 的&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="d7d72e926d93f3ca1c487388374604ee39ad35ad" translate="yes" xml:space="preserve">
          <source>For example, in order to write tests using the ExUnit framework, a developer should use the &lt;code&gt;ExUnit.Case&lt;/code&gt; module:</source>
          <target state="translated">例如，为了使用ExUnit框架编写测试，开发人员应使用 &lt;code&gt;ExUnit.Case&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="3a8a1f3ca0f4f6e6f52cd5c38c70ee3321a7257d" translate="yes" xml:space="preserve">
          <source>For example, setting the mode &lt;code&gt;0o755&lt;/code&gt; gives it write, read and execute permission to the owner and both read and execute permission to group and others.</source>
          <target state="translated">例如，将模式设置为 &lt;code&gt;0o755&lt;/code&gt; ,将其授予所有者的写，读和执行权限，同时授予组和其他用户的读和执行权限。</target>
        </trans-unit>
        <trans-unit id="aa476bb5aa4307e87b6892c3eef680e2a1027574" translate="yes" xml:space="preserve">
          <source>For example, someone using your application can override its &lt;code&gt;:redis_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">例如，某人使用您的应用程序可以覆盖其 &lt;code&gt;:redis_host&lt;/code&gt; 环境变量，如下所示：</target>
        </trans-unit>
        <trans-unit id="c1f9245784df422bc589c02556ded2ebe4df04fc" translate="yes" xml:space="preserve">
          <source>For example, take a group document represented as &lt;code&gt;[1, 2, 3]&lt;/code&gt; where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as:</source>
          <target state="translated">例如，以表示为 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 的组文档为例，其中每个逗号后的空格是一个分隔符。当以上文档不适合一行时，将启用所有分隔符，从而使文档呈现为：</target>
        </trans-unit>
        <trans-unit id="5d84b09dd24eed2b37c8292a1e28d040806e59c5" translate="yes" xml:space="preserve">
          <source>For example, take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，使用以下 &lt;code&gt;.iex.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="dabd9937e48a29e73846df5608de823548c08b1e" translate="yes" xml:space="preserve">
          <source>For example, the code point &quot;&amp;eacute;&quot; is two bytes:</source>
          <target state="translated">例如，代码点&amp;ldquo;&amp;eacute;&amp;rdquo;是两个字节：</target>
        </trans-unit>
        <trans-unit id="d5c30e8005c0c98d6e53ce8dd367db66742e7504" translate="yes" xml:space="preserve">
          <source>For example, the following agent implements a counter:</source>
          <target state="translated">例如,下面的代理实现了一个计数器。</target>
        </trans-unit>
        <trans-unit id="f261112170af791387e9b66db2c2a75a6ec23785" translate="yes" xml:space="preserve">
          <source>For example, the following is a keyword list:</source>
          <target state="translated">例如,以下是一个关键词列表。</target>
        </trans-unit>
        <trans-unit id="b821bcc62d19a98d61faaca345d43a31156e0565" translate="yes" xml:space="preserve">
          <source>For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:</source>
          <target state="translated">例如,数字0.1和0.01是其中的两个,什么意思是0.1的平方的结果不给0.01既不是最接近的代表。下面是这种情况下的情况。</target>
        </trans-unit>
        <trans-unit id="4009f5a45e54514dcb5423e242c0ca43c71a40ed" translate="yes" xml:space="preserve">
          <source>For example, to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; to redirect all Erlang messages using a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;配置为使用 &lt;code&gt;config/config.exs&lt;/code&gt; 文件重定向所有Erlang消息：</target>
        </trans-unit>
        <trans-unit id="97810dcc8560ef61b772f3bdcad87ca93ff037d4" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:backends&lt;/code&gt; and purge all calls that happen at compile time with level lower than &lt;code&gt;:info&lt;/code&gt; in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，配置 &lt;code&gt;:backends&lt;/code&gt; 并清除与水平发生在编译时低于所有来电 &lt;code&gt;:info&lt;/code&gt; 在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="21a8e2abf86d2318a5a86e1829eeef5e5857c798" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:level&lt;/code&gt; and &lt;code&gt;:truncate&lt;/code&gt; options in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，要在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:level&lt;/code&gt; 和 &lt;code&gt;:truncate&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="a0b9557028bd4e04dc9baddf4fcbc9b36f7fb55a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;erlc_options&lt;/code&gt; for your Erlang project you may run:</source>
          <target state="translated">例如，要为您的Erlang项目配置 &lt;code&gt;erlc_options&lt;/code&gt; ，可以运行：</target>
        </trans-unit>
        <trans-unit id="76a5d4e647864137abb48e20144e766fb0c89015" translate="yes" xml:space="preserve">
          <source>For example, to disable color, one may use the configuration:</source>
          <target state="translated">例如,要禁用颜色,可以使用配置。</target>
        </trans-unit>
        <trans-unit id="a765ecc41513328acb3598f8f52b46ee7deada9a" translate="yes" xml:space="preserve">
          <source>For example, to lookup a server process, monitor it and send a cast to it:</source>
          <target state="translated">例如,查找一个服务器进程,监控它并向它发送投。</target>
        </trans-unit>
        <trans-unit id="49838731982f45b819651e28face607e270a0d83" translate="yes" xml:space="preserve">
          <source>For example, to update a map inside another map:</source>
          <target state="translated">例如,要在另一张地图内更新地图。</target>
        </trans-unit>
        <trans-unit id="16fe3a971c511fed7157a7e0a03e09bb51dcfcf2" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Just open &lt;code&gt;config/config.exs&lt;/code&gt; and add the following to the end:</source>
          <target state="translated">例如，我们可以将IEx默认提示配置为另一个值。只需打开 &lt;code&gt;config/config.exs&lt;/code&gt; 并添加以下内容：</target>
        </trans-unit>
        <trans-unit id="65ea0a674f1ce41ff4c22e2d07ee72ff95421ac9" translate="yes" xml:space="preserve">
          <source>For example, we can map a list of integers into their squared values:</source>
          <target state="translated">例如,我们可以将整数列表映射成它们的平方值。</target>
        </trans-unit>
        <trans-unit id="ecebd23ebfe4f1d1acd8ff8a2d9a8722555dc40b" translate="yes" xml:space="preserve">
          <source>For example, we can use bitstring generators with the &lt;code&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:</source>
          <target state="translated">例如，我们可以使用带 &lt;code&gt;:into&lt;/code&gt; 选项的位串生成器来轻松删除字符串中的所有空格：</target>
        </trans-unit>
        <trans-unit id="825bc9fd2268ad4ced535baaab0a761647bf3261" translate="yes" xml:space="preserve">
          <source>For example, we could implement &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">例如，我们可以按照&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; 的方式&lt;/a&gt;实现&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，如下所示：</target>
        </trans-unit>
        <trans-unit id="678b43ac2ccf82f31c5e6153c0e2834d16a5b6ca" translate="yes" xml:space="preserve">
          <source>For example, we could start and register our &lt;code&gt;Stack&lt;/code&gt; server locally as follows:</source>
          <target state="translated">例如，我们可以在本地启动并注册我们的 &lt;code&gt;Stack&lt;/code&gt; 服务器，如下所示：</target>
        </trans-unit>
        <trans-unit id="9a4ed3f8957553e26e0d94986089ddb6888e33a8" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode characters, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="translated">例如，到目前为止，我们已经使用了4个计数函数： &lt;code&gt;byte_size/1&lt;/code&gt; （用于表示字符串中的字节数）， &lt;code&gt;tuple_size/1&lt;/code&gt; （用于表示元组大小）， &lt;code&gt;length/1&lt;/code&gt; （用于列表长度）和 &lt;code&gt;String.length/1&lt;/code&gt; （字符串中的字素数量）。我们使用 &lt;code&gt;byte_size&lt;/code&gt; 来获取字符串中的字节数&amp;ndash;一种廉价的操作。另一方面，检索Unicode字符的数目使用 &lt;code&gt;String.length&lt;/code&gt; ，并且由于它依赖于遍历整个字符串，因此可能很昂贵。</target>
        </trans-unit>
        <trans-unit id="8e82002b46a7bc98e04a53b8f0787d96d507b69d" translate="yes" xml:space="preserve">
          <source>For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt;. This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it.</source>
          <target state="translated">例如，我们建议开发人员始终在主管下启动任务。这提供了更大的可见性，并允许您控制节点关闭时如何终止这些任务。可能看起来像 &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt; 。这意味着，尽管您的代码是调用任务的代码，但任务的实际祖先是主管，因为主管是有效启动该任务的人。</target>
        </trans-unit>
        <trans-unit id="0dcb9a644dbae1acdb996808b23645d55e2f6941" translate="yes" xml:space="preserve">
          <source>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; is not validated against a time zone, such errors would go unnoticed.</source>
          <target state="translated">例如，当某个地区应用夏令时时，时钟通常向前或向后移动一小时。这意味着某些日期时间永远不会发生或可能会发生多次。由于未针对时区对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;进行验证，因此此类错误不会引起注意。</target>
        </trans-unit>
        <trans-unit id="0134d97aaa5f44efc896482193ec373596c0207e" translate="yes" xml:space="preserve">
          <source>For example, you could specify a &lt;code&gt;URI.Parser&lt;/code&gt; behaviour as follows:</source>
          <target state="translated">例如，您可以指定 &lt;code&gt;URI.Parser&lt;/code&gt; 行为，如下所示：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="4e3a66cb565ce65f19a6ff578510f5919a4c4a12" translate="yes" xml:space="preserve">
          <source>For examples on how to use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol and &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;into/1&lt;/code&gt;&lt;/a&gt; see the module documentation.</source>
          <target state="translated">有关如何使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议和&lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;into/1&lt;/code&gt; 的&lt;/a&gt;示例，请参见模块文档。</target>
        </trans-unit>
        <trans-unit id="e4c21cf1cac5889764a4444020c6074013f406cd" translate="yes" xml:space="preserve">
          <source>For floats, it is 64. For floats, &lt;code&gt;size * unit&lt;/code&gt; must result in 32 or 64, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32 and binary64, respectively.</source>
          <target state="translated">对于浮点数，它是64。对于浮点数， &lt;code&gt;size * unit&lt;/code&gt; 必须为32或64，分别对应于&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32和binary64。</target>
        </trans-unit>
        <trans-unit id="e0863812afa8bda24138da4ec3b1ecff0d4ecc46" translate="yes" xml:space="preserve">
          <source>For fun, let's define a simple module in this shell too:</source>
          <target state="translated">为了好玩,让我们在这个shell中也定义一个简单的模块。</target>
        </trans-unit>
        <trans-unit id="979ac34509c51f5dab54e261eec8b56be64ab620" translate="yes" xml:space="preserve">
          <source>For further details on applications please check the documentation of the &lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt;&lt;code&gt;application&lt;/code&gt;&lt;/a&gt; Erlang module, and the &lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;Applications&lt;/a&gt; section of the &lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP Design Principles User's Guide&lt;/a&gt;.</source>
          <target state="translated">有关应用程序的更多详细信息，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt; &lt;code&gt;application&lt;/code&gt; &lt;/a&gt; Erlang模块的文档以及《&lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP设计原则用户指南》的&amp;ldquo; &lt;/a&gt;&lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;应用程序&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="f91858e05de05b595ba22a40c6d98a7a27a8e926" translate="yes" xml:space="preserve">
          <source>For grouping tests together, see &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; in this module.</source>
          <target state="translated">要将测试分组在一起，请参阅本模块中的&lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77ab7e6ee8d58a006653e5dfc1bb9f58088937ba" translate="yes" xml:space="preserve">
          <source>For instance one period could be the summer of 2018 in &quot;Europe/London&quot; where summer time / daylight saving time is in effect and lasts from spring to autumn. At autumn the &lt;code&gt;std_offset&lt;/code&gt; changes along with the &lt;code&gt;zone_abbr&lt;/code&gt; so a different period is needed during winter.</source>
          <target state="translated">例如，一个时期可能是&amp;ldquo;欧洲/伦敦&amp;rdquo;的2018年夏季，夏令时/夏令时生效，持续时间从春季到秋季。在秋季 &lt;code&gt;std_offset&lt;/code&gt; 与变化一起 &lt;code&gt;zone_abbr&lt;/code&gt; 因此在冬季需要一个不同的时期。</target>
        </trans-unit>
        <trans-unit id="e51496febe42a068541cd5f1776cfef4dbdc9e31" translate="yes" xml:space="preserve">
          <source>For instance, given a user map with the &lt;code&gt;:name&lt;/code&gt; and &lt;code&gt;:languages&lt;/code&gt; keys, here is how to deeply traverse the map and convert all language names to uppercase:</source>
          <target state="translated">例如，给定一个带有 &lt;code&gt;:name&lt;/code&gt; 和 &lt;code&gt;:languages&lt;/code&gt; 键的用户映射，以下是如何深入遍历该映射并将所有语言名称转换为大写的方法：</target>
        </trans-unit>
        <trans-unit id="0fa8784dfc2e01f4f7777294a47b6dd71b0ca392" translate="yes" xml:space="preserve">
          <source>For instance, releases run using short-names (&lt;code&gt;--sname&lt;/code&gt;). However, if you want to actually run a distributed key-value store in production, you will need multiple nodes and start the release with the &lt;code&gt;--name&lt;/code&gt; option. We can achieve this by setting the &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; environment variable inside the &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; files. Mix already has a template for said files which we can customize, so let&amp;rsquo;s ask Mix to copy them to our application:</source>
          <target state="translated">例如，发布使用短名称（ &lt;code&gt;--sname&lt;/code&gt; ）运行。但是，如果要在生产环境中实际运行分布式键值存储，则将需要多个节点并使用 &lt;code&gt;--name&lt;/code&gt; 选项开始发布。我们可以通过在 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 文件中设置 &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; 环境变量来实现此目的。Mix已经有了一个可以自定义的上述文件的模板，所以让我们将Mix复制到我们的应用程序中：</target>
        </trans-unit>
        <trans-unit id="098abe87bcf54674f294a660fdeca753e3973228" translate="yes" xml:space="preserve">
          <source>For instance, we can create a file called &lt;code&gt;math.exs&lt;/code&gt;:</source>
          <target state="translated">例如，我们可以创建一个名为 &lt;code&gt;math.exs&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="915841eb2ae9437182185facdb407e9c03dade23" translate="yes" xml:space="preserve">
          <source>For intensive workloads, the registry may also be partitioned (by specifying the &lt;code&gt;:partitions&lt;/code&gt; option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available:</source>
          <target state="translated">对于繁重的工作负载，还可以对注册表进行分区（通过指定 &lt;code&gt;:partitions&lt;/code&gt; 选项）。如果需要分区，那么一个很好的默认设置是将分区数设置为可用的调度程序数：</target>
        </trans-unit>
        <trans-unit id="0be2313f13029f16466fa64d8d779bb84d194911" translate="yes" xml:space="preserve">
          <source>For maps, the first tuple element must be a &lt;code&gt;{key, value}&lt;/code&gt; tuple.</source>
          <target state="translated">对于地图，第一个元组元素必须是 &lt;code&gt;{key, value}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="9ef87b3ee1067750a0799faa766ca960ddec15e8" translate="yes" xml:space="preserve">
          <source>For maps, the function expects a key-value tuple.</source>
          <target state="translated">对于地图,函数期望一个键值元组。</target>
        </trans-unit>
        <trans-unit id="f65055eecdf00696b65a9b430fcafe6f22952a12" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关监视所有节点的状态更改，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt; &lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a50d8c364812d16e018ab6d0f72a5d0030e8481" translate="yes" xml:space="preserve">
          <source>For more advanced options available when defining custom attributes, see &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关定义自定义属性时可用的更多高级选项，请参见&lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;register_attribute/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="095613a0c71daec41f22ebf762f9ec5144c17212" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt;&lt;code&gt;:file.read_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt; &lt;code&gt;:file.read_link/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c85e5081a17eac440f3c5a413306106ced5d9c19" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt;&lt;code&gt;:file.read_link_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt; &lt;code&gt;:file.read_link_info/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c734b39d3add7d597fc3e2a0a8f87e008c1a861a" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更多详细信息，请阅读&amp;ldquo; &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;字符列表 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="95147adb3177256a490cdad3827bcc51779e68e4" translate="yes" xml:space="preserve">
          <source>For more information about IO data, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">有关IO数据的更多信息，请参见模块文档中的&lt;a href=&quot;#module-io-data&quot;&gt;&amp;ldquo; IO数据&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="1c3a9dad7c543d1c63c29b6ca8ca500c85b4a2b7" translate="yes" xml:space="preserve">
          <source>For more information about chardata, see the &lt;a href=&quot;#module-chardata&quot;&gt;&quot;Chardata&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">有关chardata的更多信息，请参见模块文档中的&lt;a href=&quot;#module-chardata&quot;&gt;&amp;ldquo; Chardata&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="edd1a5e1d2ce7f216383d5f43648eb3d76f38089" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关结构的更多信息，请检查&lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59d3cf884555506ee92cff193a1929009e874d1e" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &quot;Aliasing&quot; section in the docs for &lt;a href=&quot;mix&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关任务别名的更多信息，请参阅&lt;a href=&quot;mix&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;文档中的&amp;ldquo;别名&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="da00729bbfd1619462b29a7b8fa0dab41f7868c6" translate="yes" xml:space="preserve">
          <source>For more information and the list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息和选项列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt; &lt;code&gt;:erlang.open_port/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc7ee954ed549f3663bd8fb004277a09d86223c0" translate="yes" xml:space="preserve">
          <source>For more information and to open any module or function, see &lt;a href=&quot;#open/1&quot;&gt;&lt;code&gt;open/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息以及要打开任何模块或功能，请参见&lt;a href=&quot;#open/1&quot;&gt; &lt;code&gt;open/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0b21c46bc07a705dfc9fb743eebf812b0cdc892" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;code&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">有关代码路径的更多信息，请检查Elixir中的&lt;a href=&quot;code&quot;&gt; &lt;code&gt;Code&lt;/code&gt; &lt;/a&gt;模块以及Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bd6c86df060a9a0da50c17d815720a12995dd04" translate="yes" xml:space="preserve">
          <source>For more information on each of the possible returned values, see &lt;a href=&quot;#info/1&quot;&gt;&lt;code&gt;info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关每个可能的返回值的更多信息，请参见&lt;a href=&quot;#info/1&quot;&gt; &lt;code&gt;info/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a372c9bd101c94685e235eb649743902f58f48c" translate="yes" xml:space="preserve">
          <source>For more information on how the break is inserted, see &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关如何插入中断的更多信息，请参见&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65a28bc1907c5e0ff21b3bd1d4bbcdfcc5c5acaf" translate="yes" xml:space="preserve">
          <source>For more information on running your project, see the official &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix documentation&lt;/a&gt;.</source>
          <target state="translated">有关运行项目的更多信息，请参见《&lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix＆OTP&lt;/a&gt;官方指南》或《&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix文档》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eff11d18fedd9846c96b5c225d02a932e7b86b50" translate="yes" xml:space="preserve">
          <source>For more information read the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt; section in the Wikipedia article of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; standard.</source>
          <target state="translated">有关更多信息，请阅读&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;标准的Wikipedia文章中的&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="c1311002c3a957f544a2fb2f22b854fa11815412" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt;&lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt; &lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cd3be4a21a8ffdb5484f382332800faea93a58f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt;&lt;code&gt;:erlang.halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt; &lt;code&gt;:erlang.halt/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48be8c3bec9fc07a6ce3cee60d8a8e670e70ad06" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt;&lt;code&gt;:erlang.monitor_node/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt; &lt;code&gt;:erlang.monitor_node/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb3eefbbccd2c205683a61d85dab5af738a1f1d7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt;&lt;code&gt;:erlang.monitor_node/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt; &lt;code&gt;:erlang.monitor_node/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c9d37564a53538860067ee2ce72a5278d51bbde" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt;&lt;code&gt;:erlang.nodes/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt; &lt;code&gt;:erlang.nodes/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb045622e309576ede0093587a78e27c6a80e60" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt;&lt;code&gt;:erlang.port_close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt; &lt;code&gt;:erlang.port_close/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74569ddc9dafdb010b29df91efd894806768f74c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt;&lt;code&gt;:erlang.port_command/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt; &lt;code&gt;:erlang.port_command/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db0e4c8249cd1b3c3788a38e7bf3c3b9d4b6ceab" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt;&lt;code&gt;:erlang.port_connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt; &lt;code&gt;:erlang.port_connect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ce86a1871484a9008f73d0c702d7521b667af6c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt;&lt;code&gt;:erlang.port_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt; &lt;code&gt;:erlang.port_info/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80edbd442183f322a586734d8b1f7c8a23af48b7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt;&lt;code&gt;:erlang.port_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt; &lt;code&gt;:erlang.port_info/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82424b64f3a822c3b698f3418f074d1a59050668" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt;&lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt; &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef58581a2fb238d3165babba36ae1b31c20add22" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt;&lt;code&gt;:os.getpid/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt; &lt;code&gt;:os.getpid/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ba2f8e0812ba8129e28893614e39bd76a33546b" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块，&lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt; &lt;code&gt;Supervisor.child_spec/0&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="3d95ccf97994d2d052649c07b5320d1f38bf9f6a" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;git config&lt;/code&gt; 文档：https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</target>
        </trans-unit>
        <trans-unit id="1db1a5e08950211f4efaa987901db5f4cb9b8017" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">有关更多选项，请关注有关单个Mix任务的文档。很好的例子是&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务和所有特定的编译器任务（例如&lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="df72e64eacb9e3850dc8419637a02be86b270033" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s move on and explore the world of I/O in Elixir.</source>
          <target state="translated">现在，让我们继续探索Elixir中的I / O世界。</target>
        </trans-unit>
        <trans-unit id="f53fcbcb4286cbc82f5367680ea1d01a64e91602" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="translated">现在，让我们开始运行代表Interactive Elixir的 &lt;code&gt;iex&lt;/code&gt; （如果在Windows上 &lt;code&gt;iex.bat&lt;/code&gt; ）。在交互模式下，我们可以键入任何Elixir表达式并获取其结果。让我们用一些基本表达式进行热身。</target>
        </trans-unit>
        <trans-unit id="8f7af079e462a2a151d8084f9a25584ba5fdb2e5" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s write some tests to guarantee our GenServer works as expected.</source>
          <target state="translated">现在，让我们编写一些测试以确保GenServer能够按预期工作。</target>
        </trans-unit>
        <trans-unit id="148e18f793d17b1f034ccd4f65b51bd7c72b46fe" translate="yes" xml:space="preserve">
          <source>For now, there is a more important bug we need to fix: what happens if our TCP acceptor crashes? Since there is no supervision, the server dies and we won&amp;rsquo;t be able to serve more requests, because it won&amp;rsquo;t be restarted. That&amp;rsquo;s why we must move our server to a supervision tree.</source>
          <target state="translated">目前，我们需要修复一个更重要的错误：如果TCP接收器崩溃，会发生什么？由于没有监督，服务器死了，我们将无法处理更多请求，因为它不会重新启动。这就是为什么我们必须将服务器移至监管树。</target>
        </trans-unit>
        <trans-unit id="87f6316211bcc19e1a9eaf598a9dc404f5c35c3f" translate="yes" xml:space="preserve">
          <source>For now, we don&amp;rsquo;t have a mechanism to run tests, but we know that a function named &amp;ldquo;test hello&amp;rdquo; was defined behind the scenes. When we invoke it, it should fail:</source>
          <target state="translated">目前，我们没有运行测试的机制，但是我们知道在幕后定义了一个名为&amp;ldquo; test hello&amp;rdquo;的函数。当我们调用它时，它应该失败：</target>
        </trans-unit>
        <trans-unit id="c1b2f8891476cbc97734acacb2637f18c16dc0b0" translate="yes" xml:space="preserve">
          <source>For now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.</source>
          <target state="translated">现在,我们将只为我们的 bucket 注册逻辑编写服务器回调,而不提供适当的 API,这一点我们将在后面做。</target>
        </trans-unit>
        <trans-unit id="cdf1e2badff2fb623eee0d15afc921e9e14a706d" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;node#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">对于网络中的其他节点，这与发生故障的节点相同。仅当节点以&lt;a href=&quot;node#start/3&quot;&gt; &lt;code&gt;Node.start/3&lt;/code&gt; &lt;/a&gt;启动时才可能，否则返回 &lt;code&gt;{:error, :not_allowed}&lt;/code&gt; 。如果本地节点未处于活动状态 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 返回{：error，：not_found}。</target>
        </trans-unit>
        <trans-unit id="6dc55533805b090f117cb41ae2a4faf8a8f47746" translate="yes" xml:space="preserve">
          <source>For our routing layer, we are going to use tasks, but feel free to explore the other alternatives too.</source>
          <target state="translated">对于我们的路由层,我们将使用任务,但也可以自由探索其他选择。</target>
        </trans-unit>
        <trans-unit id="40e9bcfd5323b3ba76bb77edb0dbd378b076a7c8" translate="yes" xml:space="preserve">
          <source>For qualified calls, Elixir also allows the function name to be written between double- or single-quotes, allowing calls such as &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt;. Operators can be used as qualified calls without a need for quote, such as &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt;.</source>
          <target state="translated">对于合格的调用，Elixir还允许在双引号或单引号之间编写函数名称，从而允许进行诸如 &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt; 调用。运算符可以用作合格的调用而无需引用，例如 &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42f87f4978894da77ca58ac8711d1cc43114d9dc" translate="yes" xml:space="preserve">
          <source>For reference information about operators (and ordering), check the &lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;reference page on operators&lt;/a&gt;.</source>
          <target state="translated">有关操作员（和订购）的参考信息，请查看&lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;关于操作员&lt;/a&gt;的参考页。</target>
        </trans-unit>
        <trans-unit id="cf040e76c44787262309528d14284c46bf630986" translate="yes" xml:space="preserve">
          <source>For selecting a maximum value out of two consider using &lt;a href=&quot;kernel#max/2&quot;&gt;&lt;code&gt;Kernel.max/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#max/2&quot;&gt; &lt;code&gt;Kernel.max/2&lt;/code&gt; &lt;/a&gt;两个中选择一个最大值，请考虑使用Kernel.max / 2。</target>
        </trans-unit>
        <trans-unit id="1562be9dbea9e9ca6fb9c201080d343b056ee54f" translate="yes" xml:space="preserve">
          <source>For selecting a minimal value out of two consider using &lt;a href=&quot;kernel#min/2&quot;&gt;&lt;code&gt;Kernel.min/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#min/2&quot;&gt; &lt;code&gt;Kernel.min/2&lt;/code&gt; &lt;/a&gt;两个中选择一个最小值，请考虑使用Kernel.min / 2。</target>
        </trans-unit>
        <trans-unit id="57260814a626a0bc7ec7efb7558c4019fed8ea33" translate="yes" xml:space="preserve">
          <source>For such cases, there is a special break-trigger (&lt;code&gt;#iex:break&lt;/code&gt;) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</source>
          <target state="translated">在这种情况下，有一个特殊的break-trigger（ &lt;code&gt;#iex:break&lt;/code&gt; ），当它本身在一行上遇到时，将迫使shell脱离任何挂起的表达式并返回其正常状态：</target>
        </trans-unit>
        <trans-unit id="b2bcf831b712f7880bfa8b2d774584d0dac9e8fa" translate="yes" xml:space="preserve">
          <source>For such, you can explicitly pass the current module scope as argument:</source>
          <target state="translated">对于这种情况,你可以显式地传递当前模块范围作为参数。</target>
        </trans-unit>
        <trans-unit id="f5574a61794819cd12b11f08763b8c0faad5bbf7" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关实际的日期，时间和日期时间结构，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd4507d56d8ae26835032192a96f8f942cf347e1" translate="yes" xml:space="preserve">
          <source>For the cases where you do expect a file to exist (and the lack of that file is truly an &lt;em&gt;error&lt;/em&gt;) you may use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="translated">对于确实希望文件存在的情况（缺少该文件确实是一个&lt;em&gt;错误&lt;/em&gt;），可以使用 &lt;code&gt;File.read!/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="feff331a64ed11f441e7848a674afa89ee8071f6" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt;&lt;code&gt;:erlang.spawn/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt; &lt;code&gt;:erlang.spawn/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6639a98f71e3255b9d9416659477b36d9f9e63f9" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt;&lt;code&gt;:erlang.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt; &lt;code&gt;:erlang.spawn/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d102dfda15fab2a12aecfca86ecdab6b9328f4c7" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt;&lt;code&gt;:erlang.spawn/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt; &lt;code&gt;:erlang.spawn/5&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="147c5308097c95403b6c3b710471092817aba390" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt;&lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt; &lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad4e9a7fc7900bbb60654000287c4ad75fc0eadd" translate="yes" xml:space="preserve">
          <source>For the list of supported warnings, see &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;&lt;code&gt;:dialyzer&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">有关受支持的警告的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt; &lt;code&gt;:dialyzer&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a293fce2f70fe18d9d7bb3411509a1883ca74c72" translate="yes" xml:space="preserve">
          <source>For this chapter, we will be using files instead of running code samples in IEx. That&amp;rsquo;s because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a &lt;code&gt;macros.exs&lt;/code&gt; file and running it with &lt;code&gt;elixir macros.exs&lt;/code&gt; or &lt;code&gt;iex macros.exs&lt;/code&gt;.</source>
          <target state="translated">在本章中，我们将使用文件而不是在IEx中运行代码示例。这是因为代码示例将跨越多行代码，并且在IEx中键入它们都可能适得其反。您应该能够通过将代码示例保存到 &lt;code&gt;macros.exs&lt;/code&gt; 文件中并使用 &lt;code&gt;elixir macros.exs&lt;/code&gt; 或 &lt;code&gt;iex macros.exs&lt;/code&gt; 来运行它们。</target>
        </trans-unit>
        <trans-unit id="945a8597b683042909912d13ab0af0f05f4a1912" translate="yes" xml:space="preserve">
          <source>For this reason, Mix also provides an &lt;code&gt;--only&lt;/code&gt; option that excludes all tests and includes only the given ones:</source>
          <target state="translated">因此，Mix还提供了 &lt;code&gt;--only&lt;/code&gt; 选项，该选项排除所有测试，仅包括给定的测试：</target>
        </trans-unit>
        <trans-unit id="5942291bf8303552448ccf23f92c1cc85a264e74" translate="yes" xml:space="preserve">
          <source>For this reason, Mix supports &amp;ldquo;umbrella projects&amp;rdquo;. Umbrella projects are used to build applications that run together in a single repository. That is exactly the style we are going to explore in the next sections.</source>
          <target state="translated">因此，Mix支持&amp;ldquo;伞项目&amp;rdquo;。伞项目用于构建在单个存储库中一起运行的应用程序。这正是我们将在下一部分中探讨的样式。</target>
        </trans-unit>
        <trans-unit id="db439eca1a575baf9e479914a743abe4e55ae0ad" translate="yes" xml:space="preserve">
          <source>For this reason, the task touches your &lt;code&gt;:compile_path&lt;/code&gt; directory and sets the modification time to the current time and date at the end of each compilation. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">出于这个原因，该任务触摸您的 &lt;code&gt;:compile_path&lt;/code&gt; 目录，并将修改时间设置为每次编译结束时的当前时间和日期。您可以通过传递 &lt;code&gt;--force&lt;/code&gt; 选项来强制编译，而不考虑修改时间。</target>
        </trans-unit>
        <trans-unit id="cfae34045d5d895009311d2a2a010463848d8c45" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module:</source>
          <target state="translated">对于那些喜欢断点但对可视调试器非常感兴趣的人，Erlang / OTP附带了一个图形调试器，命名为 &lt;code&gt;:debugger&lt;/code&gt; 。让我们定义一个模块：</target>
        </trans-unit>
        <trans-unit id="bc2d3f32f1c4138eee3831b35b324f9d5504e4b5" translate="yes" xml:space="preserve">
          <source>For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value.</source>
          <target state="translated">对于独特的注册表,它可以用来根据键是否与某一特定值相匹配而有条件地取消注册。</target>
        </trans-unit>
        <trans-unit id="14cd0b7637eff1b0c6bd870cfbdfa9301754b7b7" translate="yes" xml:space="preserve">
          <source>For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up.</source>
          <target state="translated">对于唯一的注册表,必须进行单一分区查询。对于重复的注册表,必须查找所有分区。</target>
        </trans-unit>
        <trans-unit id="a33570d2441921e7831b3c41af0473896917c621" translate="yes" xml:space="preserve">
          <source>For unique registries:</source>
          <target state="translated">对于独特的登记册:</target>
        </trans-unit>
        <trans-unit id="a494479b1595316138e63803f01b27c1d049ecb0" translate="yes" xml:space="preserve">
          <source>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</source>
          <target state="translated">对于变量来说,任何以下划线开头的标识符都表示一个未使用的变量。例如:</target>
        </trans-unit>
        <trans-unit id="c93842334df0e58537ff9e4564650c5a06d71f1b" translate="yes" xml:space="preserve">
          <source>Forces the current group to be unfit.</source>
          <target state="translated">强制当前组不适合。</target>
        </trans-unit>
        <trans-unit id="c5bf5789dde7373724874c65a12c156bc9c3ab1f" translate="yes" xml:space="preserve">
          <source>Forces the disconnection of a node.</source>
          <target state="translated">强制断开一个节点的连接。</target>
        </trans-unit>
        <trans-unit id="815a28d19a43ab21cf99300b9b2fd43fa459fe43" translate="yes" xml:space="preserve">
          <source>Forces the path to be a relative path.</source>
          <target state="translated">强制将路径设置为相对路径。</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="5c35ec0ad733522cc571cfec85232066d155794d" translate="yes" xml:space="preserve">
          <source>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</source>
          <target state="translated">通过将命名的ANSI序列转换为实际的ANSI代码,形成一个类似chardata的参数。</target>
        </trans-unit>
        <trans-unit id="2207193e5d684c4dc9f415ae14757dea81eca345" translate="yes" xml:space="preserve">
          <source>Formats a file.</source>
          <target state="translated">对文件进行格式化。</target>
        </trans-unit>
        <trans-unit id="cafa245a564712637537f38b69c740ea4dde1a5f" translate="yes" xml:space="preserve">
          <source>Formats a given document for a given width.</source>
          <target state="translated">对给定宽度的文档进行格式化。</target>
        </trans-unit>
        <trans-unit id="8dfa3afe7b66a75ca4db90cdffb1c56ec5f2cef4" translate="yes" xml:space="preserve">
          <source>Formats an exit. It returns a string.</source>
          <target state="translated">形成一个出口。它返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="6efb90c18f18ca530ad6f75b186ea9a0dab0abb7" translate="yes" xml:space="preserve">
          <source>Formats and truncates messages on the client to avoid clogging &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; backends.</source>
          <target state="translated">在客户端上格式化和截断消息，以避免阻塞&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;后端。</target>
        </trans-unit>
        <trans-unit id="56622496774bb19434d2ebee47141c996a87f22d" translate="yes" xml:space="preserve">
          <source>Formats date as chardata.</source>
          <target state="translated">格式化日期为chardata。</target>
        </trans-unit>
        <trans-unit id="aa53a753f568d1640d41923f79bf478cc8554997" translate="yes" xml:space="preserve">
          <source>Formats the error reason returned by &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;ensure_started/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unload/1&quot;&gt;&lt;code&gt;unload/1&lt;/code&gt;&lt;/a&gt;, returns a string.</source>
          <target state="translated">格式化由&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ensure_started/2&quot;&gt; &lt;code&gt;ensure_started/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unload/1&quot;&gt; &lt;code&gt;unload/1&lt;/code&gt; &lt;/a&gt;返回的错误原因，返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="7f7ec50c392208c557864813c0cfdc9b2645d9c5" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces. If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">格式化给定的 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; ，如stacktraces中所示。如果任何值为 &lt;code&gt;nil&lt;/code&gt; ，则将其省略。</target>
        </trans-unit>
        <trans-unit id="43daea1857449413e5d2961950390283bfbd89a9" translate="yes" xml:space="preserve">
          <source>Formats the given code &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">格式化给定的代码 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="095114a79701908ee2dfdcd7beb556b92bb7fa82" translate="yes" xml:space="preserve">
          <source>Formats the stacktrace.</source>
          <target state="translated">形成堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bc17a3e28e6db9da82c06d3e64dd8f9133ab1362" translate="yes" xml:space="preserve">
          <source>Formats time as chardata.</source>
          <target state="translated">将时间格式化为chardata。</target>
        </trans-unit>
        <trans-unit id="15bac6318ac5108c02b6ce4ab557e2ea1f9cdf7e" translate="yes" xml:space="preserve">
          <source>Formatted text output</source>
          <target state="translated">格式化文本输出</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="8b2cd2532672c31ff20ceae8b0d526cd937086f0" translate="yes" xml:space="preserve">
          <source>Forwards the error to the current process.</source>
          <target state="translated">将错误转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="9fdf06a3445d03e7647fe9c67a18a17eb8735986" translate="yes" xml:space="preserve">
          <source>Forwards the message to the current process.</source>
          <target state="translated">将消息转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="addaa186164be6af6cfe3af8285a06cb4198e95d" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;naivedatetime#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">小&lt;a href=&quot;naivedatetime#add/2&quot;&gt; &lt;code&gt;NaiveDateTime.add/2&lt;/code&gt; &lt;/a&gt;精度与NaiveDateTime.add / 2相似，保持不变。</target>
        </trans-unit>
        <trans-unit id="4802179f7c5db9ab1d4360e530bc8c507bf436cc" translate="yes" xml:space="preserve">
          <source>Framed.</source>
          <target state="translated">Framed.</target>
        </trans-unit>
        <trans-unit id="37cd4097eb3a24362095532952b9b30616bd33e9" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under &lt;code&gt;MyApp&lt;/code&gt;, you can alias the modules &lt;code&gt;MyApp.Foo&lt;/code&gt;, &lt;code&gt;MyApp.Bar&lt;/code&gt; and &lt;code&gt;MyApp.Baz&lt;/code&gt; at once as follows:</source>
          <target state="translated">从Elixir v1.2开始，可以一次别名，导入或需要多个模块。一旦我们开始嵌套模块，这将特别有用，这在构建Elixir应用程序时非常常见。例如，假设您有一个应用程序，其中所有模块都嵌套在 &lt;code&gt;MyApp&lt;/code&gt; 下，则可以一次对模块 &lt;code&gt;MyApp.Foo&lt;/code&gt; ， &lt;code&gt;MyApp.Bar&lt;/code&gt; 和 &lt;code&gt;MyApp.Baz&lt;/code&gt; 进行别名，如下所示：</target>
        </trans-unit>
        <trans-unit id="5f129d8dac3eb2b485d35cfaa8fcb065c8677f2f" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, protocol consolidation happens automatically for all projects. We will build our own project in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">从Elixir v1.2开始，所有项目都会自动进行协议合并。我们将在&lt;strong&gt;&lt;em&gt;Mix and OTP指南中&lt;/em&gt;&lt;/strong&gt;构建自己的项目。</target>
        </trans-unit>
        <trans-unit id="a9cab3793941ece60ffc8a0b775c34f6a348677a" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 21, &lt;code&gt;:handle_sasl_reports&lt;/code&gt; only has an effect if &lt;code&gt;:handle_otp_reports&lt;/code&gt; is true.</source>
          <target state="translated">从Erlang / OTP 21开始，只有 &lt;code&gt;:handle_otp_reports&lt;/code&gt; 为true时， &lt;code&gt;:handle_sasl_reports&lt;/code&gt; 才有效。</target>
        </trans-unit>
        <trans-unit id="1b5ac9d2f1ffaa0f16939a6691b3606f6f5495e8" translate="yes" xml:space="preserve">
          <source>From inside &lt;code&gt;bar@computer-name&lt;/code&gt;, we can now spawn a task directly on the other node via the supervisor:</source>
          <target state="translated">现在，在 &lt;code&gt;bar@computer-name&lt;/code&gt; 内部，我们可以通过主管在另一个节点上直接生成任务：</target>
        </trans-unit>
        <trans-unit id="cee07fcd21c8e4081421ab00fc5d8c03d08b554f" translate="yes" xml:space="preserve">
          <source>From now on, ExUnit will not run any test that has the &lt;code&gt;:external&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;. This behaviour can be reversed with the &lt;code&gt;:include&lt;/code&gt; option which is usually passed through the command line:</source>
          <target state="translated">从现在开始，ExUnit将不会运行任何将 &lt;code&gt;:external&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; 的测试。可以通过通常在命令行中传递的 &lt;code&gt;:include&lt;/code&gt; 选项来逆转此行为：</target>
        </trans-unit>
        <trans-unit id="3c26276a10f65beef569c18570dfcc2f42f56636" translate="yes" xml:space="preserve">
          <source>From now on, we will be using the term &quot;event handler&quot; to refer to your custom backend, as we head into implementation details.</source>
          <target state="translated">从现在开始,我们将使用术语 &quot;事件处理程序 &quot;来指代你的自定义后端,因为我们将进入实施细节。</target>
        </trans-unit>
        <trans-unit id="938617f06857d43f6a085cfd6bce09c1655cac4a" translate="yes" xml:space="preserve">
          <source>From our quick exploration, we could conclude that we should use &lt;code&gt;Node.spawn_link/2&lt;/code&gt; to spawn processes on a remote node every time we need to do a distributed computation. However, we have learned throughout this guide that spawning processes outside of supervision trees should be avoided if possible, so we need to look for other options.</source>
          <target state="translated">从我们的快速探索中，我们可以得出结论，每次需要进行分布式计算时，都应该使用 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 在远程节点上生成进程。但是，我们在整个指南中了解到，如果可能，应避免在监督树之外生成程序，因此我们需要寻找其他选择。</target>
        </trans-unit>
        <trans-unit id="4db16168eb1bd7c62518bc09890c1b7ba6baa6ce" translate="yes" xml:space="preserve">
          <source>From the printed information, we can see far fewer files are generated. The generated &lt;code&gt;mix.exs&lt;/code&gt; file is different too. Let&amp;rsquo;s take a look (comments have been removed):</source>
          <target state="translated">从打印的信息中，我们可以看到生成的文件要少得多。生成的 &lt;code&gt;mix.exs&lt;/code&gt; 文件也不同。让我们看一下（注释已删除）：</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="8e40024a6b83dbe7056d1e4a40db12942b440d4e" translate="yes" xml:space="preserve">
          <source>Function Arguments</source>
          <target state="translated">函数参数</target>
        </trans-unit>
        <trans-unit id="bc1254dc5150511a2a061bfd2a8e778f130ed9a6" translate="yes" xml:space="preserve">
          <source>Function and variable names</source>
          <target state="translated">函数和变量名称</target>
        </trans-unit>
        <trans-unit id="83ade9ad4e94b4c5006286b88e8447b8a91c444a" translate="yes" xml:space="preserve">
          <source>Function and variable names have the following syntax: A &lt;em&gt;lowercase ASCII letter&lt;/em&gt; or an &lt;em&gt;underscore&lt;/em&gt;, followed by any number of &lt;em&gt;lowercase or uppercase ASCII letters&lt;/em&gt;, &lt;em&gt;numbers&lt;/em&gt;, or &lt;em&gt;underscores&lt;/em&gt;. Optionally they can end in either an &lt;em&gt;exclamation mark&lt;/em&gt; or a &lt;em&gt;question mark&lt;/em&gt;.</source>
          <target state="translated">函数和变量名称具有以下语法：&lt;em&gt;小写ASCII字母&lt;/em&gt;或&lt;em&gt;下划线&lt;/em&gt;，后跟任意数量的&lt;em&gt;小写或大写ASCII字母&lt;/em&gt;，&lt;em&gt;数字&lt;/em&gt;或&lt;em&gt;下划线&lt;/em&gt;。任选地，他们可以在任一个端&lt;em&gt;感叹号&lt;/em&gt;或&lt;em&gt;问号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="23cced316c3006e2ae03dfcedc7e3c98513a344d" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does. For example, the following two functions are equivalent:</source>
          <target state="translated">功能主体像&lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt;一样支持 &lt;code&gt;rescue&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 功能。例如，以下两个功能是等效的：</target>
        </trans-unit>
        <trans-unit id="a06abcd236c2b1c30e0ad208ebb8f15fa6b429ec" translate="yes" xml:space="preserve">
          <source>Function capturing</source>
          <target state="translated">功能捕获</target>
        </trans-unit>
        <trans-unit id="f1329761aa64d73b0a0135229f12fe0d0ace1793" translate="yes" xml:space="preserve">
          <source>Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:</source>
          <target state="translated">函数声明还支持守护和多子句。如果一个函数有多个子句,Elixir会尝试每个子句,直到找到匹配的子句。下面是一个检查给定数字是否为零的函数的实现。</target>
        </trans-unit>
        <trans-unit id="2a8ac45592076c6753dc5eab45709c494a73fe32" translate="yes" xml:space="preserve">
          <source>Function names may also start with an underscore. Such functions are never imported by default:</source>
          <target state="translated">函数名称也可以以下划线开头。默认情况下,这些函数不会被导入。</target>
        </trans-unit>
        <trans-unit id="1ac07c5c5d769c317e4ee149161ad79dd547886a" translate="yes" xml:space="preserve">
          <source>Function specifications</source>
          <target state="translated">功能规格</target>
        </trans-unit>
        <trans-unit id="b1d1d233c6e9151086e11b68520f3c88ddfbfd71" translate="yes" xml:space="preserve">
          <source>FunctionClauseError</source>
          <target state="translated">FunctionClauseError</target>
        </trans-unit>
        <trans-unit id="59d46903ce38ffaa562b785d06c23f1fe1bd7e8e" translate="yes" xml:space="preserve">
          <source>FunctionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">FunctionClauseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="981f29fc45464a2117ff8d90e767ed44d91b4bb6" translate="yes" xml:space="preserve">
          <source>Functionality to render ANSI escape sequences.</source>
          <target state="translated">具有渲染ANSI转义序列的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="e331cf0e4275fe631ca417060a2f8f10e15a256d" translate="yes" xml:space="preserve">
          <source>Functions as keys</source>
          <target state="translated">功能键</target>
        </trans-unit>
        <trans-unit id="5b08dda4461297f97d2d935f4b6c312c57879282" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">用&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;定义的函数是公共的，可以从定义它们的模块外部调用，就好像它们是使用&lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt;定义的一样。因此，&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;与扩展当前模块的公共API有关。如果要在不使用其完整模块名的情况下调用另一个模块中定义的函数，请使用&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;缩短模块名，或使用&lt;a href=&quot;kernel.specialforms#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;来在不使用模块名的情况下调用该函数。</target>
        </trans-unit>
        <trans-unit id="5339f05867719070151c5f9212ec9691343c3dfd" translate="yes" xml:space="preserve">
          <source>Functions for creating and composing streams.</source>
          <target state="translated">用于创建和组成流的功能。</target>
        </trans-unit>
        <trans-unit id="a92a126ef94a3c0fc6addeadb2500f9ae863a5be" translate="yes" xml:space="preserve">
          <source>Functions for interacting with the external world through ports.</source>
          <target state="translated">通过端口与外部世界交互的功能。</target>
        </trans-unit>
        <trans-unit id="595e959d0a21e0d09abbd2c4fba3e39601ca613b" translate="yes" xml:space="preserve">
          <source>Functions for parsing and matching versions against requirements.</source>
          <target state="translated">用于解析和匹配版本与需求的函数。</target>
        </trans-unit>
        <trans-unit id="3f33806c59ce33f63b6d6eac23d2c5c308d0f02e" translate="yes" xml:space="preserve">
          <source>Functions for parsing command line arguments.</source>
          <target state="translated">用于解析命令行参数的函数。</target>
        </trans-unit>
        <trans-unit id="be344dfaebcc716a7113914fb8d65d65aad9cdfb" translate="yes" xml:space="preserve">
          <source>Functions for working with floating-point numbers.</source>
          <target state="translated">用于处理浮点数的函数。</target>
        </trans-unit>
        <trans-unit id="4581129055260f253b0f9a10ce8940c3ae082007" translate="yes" xml:space="preserve">
          <source>Functions for working with integers.</source>
          <target state="translated">用于处理整数的函数。</target>
        </trans-unit>
        <trans-unit id="ac038c429b16ac4da6a1c54de055fde121e86832" translate="yes" xml:space="preserve">
          <source>Functions for working with tuples.</source>
          <target state="translated">用于处理元组的函数。</target>
        </trans-unit>
        <trans-unit id="b012c35607b405f40246b484e5594c562e5fd7b1" translate="yes" xml:space="preserve">
          <source>Functions handling input/output (IO).</source>
          <target state="translated">处理输入/输出(IO)的函数。</target>
        </trans-unit>
        <trans-unit id="120d9dcde7287a0528aec2f3d5f7e2e3f5cd376a" translate="yes" xml:space="preserve">
          <source>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. &lt;code&gt;round/1&lt;/code&gt; identifies the function which is named &lt;code&gt;round&lt;/code&gt; and takes &lt;code&gt;1&lt;/code&gt; argument, whereas &lt;code&gt;round/2&lt;/code&gt; identifies a different (nonexistent) function with the same name but with an arity of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Elixir中的功能通过名称和名称进行标识。函数的多样性描述了函数采用的参数数量。从这一点开始，我们将在整个文档中使用函数名称及其辅助性来描述函数。 &lt;code&gt;round/1&lt;/code&gt; 标识名为 &lt;code&gt;round&lt;/code&gt; 并带有 &lt;code&gt;1&lt;/code&gt; 个参数的函数，而 &lt;code&gt;round/2&lt;/code&gt; 标识具有相同名称但Arity为 &lt;code&gt;2&lt;/code&gt; 的另一个（不存在）函数。</target>
        </trans-unit>
        <trans-unit id="18780274d7513230569a4133845253288a279bc6" translate="yes" xml:space="preserve">
          <source>Functions related to VM nodes.</source>
          <target state="translated">与VM节点相关的功能。</target>
        </trans-unit>
        <trans-unit id="2ecc259041cce0328acd0d9abf2a78e6d378235f" translate="yes" xml:space="preserve">
          <source>Functions that return a boolean are named with a trailing question mark.</source>
          <target state="translated">返回布尔函数的函数用尾部的问号命名。</target>
        </trans-unit>
        <trans-unit id="3abac8dc3938de4ae338c2914b66903b6d6216cf" translate="yes" xml:space="preserve">
          <source>Functions that work on (linked) lists.</source>
          <target state="translated">在(链接)列表上工作的函数。</target>
        </trans-unit>
        <trans-unit id="d6d5cb54b94547b27cdb53ea8f156b69b0e891a7" translate="yes" xml:space="preserve">
          <source>Functions that work on sets.</source>
          <target state="translated">在套路上起作用的功能。</target>
        </trans-unit>
        <trans-unit id="c2171b2fcb9b756c41905c9675c92ab582aa67f4" translate="yes" xml:space="preserve">
          <source>Functions to format throw/catch/exit and exceptions.</source>
          <target state="translated">用于格式化抛出/捕获/退出和异常的函数。</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">更多信息</target>
        </trans-unit>
        <trans-unit id="6d6208ba2074c10f21b8ca78cfba95b5238a4367" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;logger.translator&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此外，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;允许Erlang发送的消息通过翻译器转换为Elixir格式。可以随时使用&lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; API 添加翻译器。检查&lt;a href=&quot;logger.translator&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f484c5ceae64ae91667e53e8fabec77fcc0eab91" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">此外，&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;可能由于以下POSIX原因之一而失败：</target>
        </trans-unit>
        <trans-unit id="186edc3e57a9d838cd0ada8549562af323cf60a5" translate="yes" xml:space="preserve">
          <source>Furthermore, a &lt;code&gt;:suspend&lt;/code&gt; call must always be followed by another call, eventually halting or continuing until the end.</source>
          <target state="translated">此外， &lt;code&gt;:suspend&lt;/code&gt; 调用必须始终跟随另一个调用，最终停止或继续直到结束。</target>
        </trans-unit>
        <trans-unit id="c260bcd5ae1bdde9983d663eb92d5fcd82188b68" translate="yes" xml:space="preserve">
          <source>Furthermore, all applications listed in the &lt;code&gt;:applications&lt;/code&gt; key must be explicitly started before this application is. If not, &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; is returned, where &lt;code&gt;app&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">此外， &lt;code&gt;:applications&lt;/code&gt; 项中列出的所有应用程序必须在此应用程序之前被明确启动。如果不是，则返回 &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; ，其中 &lt;code&gt;app&lt;/code&gt; 是缺少的应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="26e72ab288d2e99c66734f21d67d33280ac839df" translate="yes" xml:space="preserve">
          <source>Furthermore, backends can be configured via the &lt;a href=&quot;#configure_backend/2&quot;&gt;&lt;code&gt;configure_backend/2&lt;/code&gt;&lt;/a&gt; function which requires event handlers to handle calls of the following format:</source>
          <target state="translated">此外，可以通过&lt;a href=&quot;#configure_backend/2&quot;&gt; &lt;code&gt;configure_backend/2&lt;/code&gt; &lt;/a&gt;函数配置后端，该函数需要事件处理程序来处理以下格式的调用：</target>
        </trans-unit>
        <trans-unit id="03045b903b2a4efd2fad95378e0e7416cbdc8700" translate="yes" xml:space="preserve">
          <source>Furthermore, because the state returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.</source>
          <target state="translated">此外，由于可以将&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的状态写入基于文本的配置文件，因此应仅将其限制为简单的数据类型，例如整数，字符串，原子，元组，映射和列表。PID，引用和函数等条目无法序列化。</target>
        </trans-unit>
        <trans-unit id="e12a025bc34e52444d91865482fafd1b4bcb1476" translate="yes" xml:space="preserve">
          <source>Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors:</source>
          <target state="translated">另外,如果在调度时,由于注册不好,出现了故障,调度总是会失败,注册的流程也不会被通知。因此,我们至少要确保我们对这些错误进行包装和报告。</target>
        </trans-unit>
        <trans-unit id="42529d32de08bd15f27eb4312be9cc48b68c13b2" translate="yes" xml:space="preserve">
          <source>Furthermore, they are composable because we can pipe many stream operations:</source>
          <target state="translated">此外,它们是可以组合的,因为我们可以管很多流操作。</target>
        </trans-unit>
        <trans-unit id="3381a6c76f92b142faec11ca6cffe41f63f7d1f2" translate="yes" xml:space="preserve">
          <source>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;&amp;eacute;&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points):</source>
          <target state="translated">此外，该模块还提出了字素簇的概念（从现在开始称为字素）。字素可以由多个代码点组成，读者可以将其视为一个字符。例如，&amp;ldquo;&amp;eacute;&amp;rdquo;可以表示为单个&amp;ldquo; e与尖音&amp;rdquo;代码点，也可以表示为字母&amp;ldquo; e&amp;rdquo;，后跟&amp;ldquo;组合重音符号&amp;rdquo;（两个代码点）：</target>
        </trans-unit>
        <trans-unit id="5c727a56b05e846df29f24d1daf2419df88964fa" translate="yes" xml:space="preserve">
          <source>Furthermore, with &lt;code&gt;@impl&lt;/code&gt; you can also make sure that you are implementing the &lt;strong&gt;correct&lt;/strong&gt; callbacks from the given behaviour in an explicit manner. For example, the following parser implements both &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt;, however thanks to a typo, &lt;code&gt;BADParser&lt;/code&gt; is implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;.</source>
          <target state="translated">此外，使用 &lt;code&gt;@impl&lt;/code&gt; 还可以确保以显式方式从给定的行为实现&lt;strong&gt;正确的&lt;/strong&gt;回调。例如，以下解析器同时实现了 &lt;code&gt;parse&lt;/code&gt; 和 &lt;code&gt;extensions&lt;/code&gt; ，但是由于输入错误， &lt;code&gt;BADParser&lt;/code&gt; 实现了 &lt;code&gt;parse/0&lt;/code&gt; 而不是 &lt;code&gt;parse/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae57bdba0f435d58b5575a45dc3b5fb6eb566cf8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let&amp;rsquo;s make the test fail on purpose and see what happens.</source>
          <target state="translated">此外，您可以看到ExUnit为每个成功的测试打印一个点，并且也会自动将测试随机化。让我们故意使测试失败，看看会发生什么。</target>
        </trans-unit>
        <trans-unit id="26e2a4f823a98eca42ddcd53fd08f4fc5631d231" translate="yes" xml:space="preserve">
          <source>GenEvent</source>
          <target state="translated">GenEvent</target>
        </trans-unit>
        <trans-unit id="52f5451d0a005c032b5bd9e0f39e525431bee3e4" translate="yes" xml:space="preserve">
          <source>GenEvent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenEvent &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f1f7460d4b0df6c99ec51f3b8a78fab0ab241364" translate="yes" xml:space="preserve">
          <source>GenServer</source>
          <target state="translated">GenServer</target>
        </trans-unit>
        <trans-unit id="c41a8053324929c4122055404c6f497f28026d3e" translate="yes" xml:space="preserve">
          <source>GenServer - Elixir's Getting Started Guide</source>
          <target state="translated">GenServer-Elixir入门指南</target>
        </trans-unit>
        <trans-unit id="eca82733cdfcb3649b72cda06a30a922552032d8" translate="yes" xml:space="preserve">
          <source>GenServer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenServer &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6b938fbce44ec15ef7cf28460d3d3a0b7b6e45c7" translate="yes" xml:space="preserve">
          <source>GenServer callbacks</source>
          <target state="translated">GenServer回调</target>
        </trans-unit>
        <trans-unit id="60a02fde0f842f29309800909cd00e720e3567d0" translate="yes" xml:space="preserve">
          <source>GenServers, as &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;special processes&lt;/a&gt;, can be debugged using the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt;. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</source>
          <target state="translated">GenServers作为&lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;特殊进程&lt;/a&gt;，可以使用&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块&lt;/a&gt;进行调试。通过各种挂钩，该模块使开发人员可以对流程的状态进行自省，并跟踪流程执行期间发生的系统事件，例如接收到的消息，发送的答复和状态更改。</target>
        </trans-unit>
        <trans-unit id="8e2323fdcd5a3410a0abfe44a2176b41a6905683" translate="yes" xml:space="preserve">
          <source>GenStage</source>
          <target state="translated">GenStage</target>
        </trans-unit>
        <trans-unit id="26811be9b4758ef85d12185318d245ac23863706" translate="yes" xml:space="preserve">
          <source>Generally speaking, filenames follow the &lt;code&gt;snake_case&lt;/code&gt; convention of the module they define. For example, &lt;code&gt;MyApp&lt;/code&gt; should be defined inside the &lt;code&gt;my_app.ex&lt;/code&gt; file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.</source>
          <target state="translated">一般来说，文件名遵循它们定义的模块的 &lt;code&gt;snake_case&lt;/code&gt; 约定。例如，应在 &lt;code&gt;my_app.ex&lt;/code&gt; 文件中定义 &lt;code&gt;MyApp&lt;/code&gt; 。但是，这只是一个约定。在一天结束时，可以使用任何文件名，因为它们不会以任何方式影响编译后的代码。</target>
        </trans-unit>
        <trans-unit id="c4e59b7746a9b324c29c497d15613e18d32b2ec0" translate="yes" xml:space="preserve">
          <source>Generally speaking, the VM provides three time measurements:</source>
          <target state="translated">一般来说,虚拟机提供三种时间测量。</target>
        </trans-unit>
        <trans-unit id="3853e87a8cfcd1a2826b60877e31dac6ddc354ee" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following module:</source>
          <target state="translated">一般来说,以下模块:</target>
        </trans-unit>
        <trans-unit id="bc78aa7ca2c1bb33572b17a7f6a38317ada6e607" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;macro#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;macro#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt;为给定数量的必需参数变量生成AST节点。</target>
        </trans-unit>
        <trans-unit id="7914afeb7e94d7ae59d1fa355821ee7cf902a612" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the file contents.</source>
          <target state="translated">从文件内容中生成一个函数定义。</target>
        </trans-unit>
        <trans-unit id="6f28a47721aec6c56f1e4f3f4b046459fb2d421f" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the string.</source>
          <target state="translated">从字符串中生成一个函数定义。</target>
        </trans-unit>
        <trans-unit id="3ed0a940ace5bee6a5a44c402162f201a0b4df48" translate="yes" xml:space="preserve">
          <source>Generates a macro suitable for use in guard expressions.</source>
          <target state="translated">生成一个适合在防护表达式中使用的宏。</target>
        </trans-unit>
        <trans-unit id="f89a805aedce9f9ff7961406995dc39283b2ba6f" translate="yes" xml:space="preserve">
          <source>Generates a private macro suitable for use in guard expressions.</source>
          <target state="translated">生成一个适合在防护表达式中使用的私有宏。</target>
        </trans-unit>
        <trans-unit id="d022a23ab156502d4cd22511016df2db248a08d8" translate="yes" xml:space="preserve">
          <source>Generates an AST node representing the variable given by the atoms &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">生成一个AST节点，表示由 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;context&lt;/code&gt; 原子给定的变量。</target>
        </trans-unit>
        <trans-unit id="39399ecc6eafac75945962b0e75d0ddca1662821" translate="yes" xml:space="preserve">
          <source>Generates and returns an integer that is unique in the current runtime instance.</source>
          <target state="translated">生成并返回一个在当前运行时实例中唯一的整数。</target>
        </trans-unit>
        <trans-unit id="5539e5b1ece965094ab6defc81d9ab18e23afa6b" translate="yes" xml:space="preserve">
          <source>Generator expressions also support pattern matching on their left-hand side; all non-matching patterns are &lt;em&gt;ignored&lt;/em&gt;. Imagine that, instead of a range, we have a keyword list where the key is the atom &lt;code&gt;:good&lt;/code&gt; or &lt;code&gt;:bad&lt;/code&gt; and we only want to compute the square of the &lt;code&gt;:good&lt;/code&gt; values:</source>
          <target state="translated">生成器表达式的左侧也支持模式匹配；所有不匹配的模式都将&lt;em&gt;被忽略&lt;/em&gt;。想象一下，我们有一个关键字列表，而不是一个范围，其中关键字是原子 &lt;code&gt;:good&lt;/code&gt; 或 &lt;code&gt;:bad&lt;/code&gt; ,而我们只想计算 &lt;code&gt;:good&lt;/code&gt; 值的平方：</target>
        </trans-unit>
        <trans-unit id="191fe63ca19d74852f4f8e0438c53a7c9f2fad58" translate="yes" xml:space="preserve">
          <source>Generators and filters</source>
          <target state="translated">发电机和过滤器</target>
        </trans-unit>
        <trans-unit id="b0f6dc9f4ecd590c4554fad6675925837bd4c03b" translate="yes" xml:space="preserve">
          <source>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">生成器还可以用于过滤，因为它会删除与 &lt;code&gt;&amp;lt;-&lt;/code&gt; 左侧的模式不匹配的任何值：</target>
        </trans-unit>
        <trans-unit id="6a24751485eed378e568d03e0c111b00b1ca2106" translate="yes" xml:space="preserve">
          <source>Generic API for dictionaries.</source>
          <target state="translated">字典的通用API。</target>
        </trans-unit>
        <trans-unit id="f74ee225a82269c197985a3a933abeea994529f8" translate="yes" xml:space="preserve">
          <source>Generic API for sets.</source>
          <target state="translated">集的通用API。</target>
        </trans-unit>
        <trans-unit id="342a929853c668da7bea5b8678d33654ddad6c44" translate="yes" xml:space="preserve">
          <source>Get all keys in the registry.</source>
          <target state="translated">获取注册表中的所有键。</target>
        </trans-unit>
        <trans-unit id="15d4328951079f5b0c0d666980c03b21bfcda99d" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;filename&lt;/code&gt; 并使用 &lt;code&gt;bindings&lt;/code&gt; 评估值。</target>
        </trans-unit>
        <trans-unit id="e09423213d70047599b0fbcfb55a1d216ed0bceb" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">获取 &lt;code&gt;filename&lt;/code&gt; 并生成带引号的表达式，该表达式可由Elixir评估或编译为函数。</target>
        </trans-unit>
        <trans-unit id="11ce297c5b4ae23b4a6d01356ff4f29ad16e92ef" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from IO device &lt;code&gt;:stdio&lt;/code&gt;.</source>
          <target state="translated">从IO设备 &lt;code&gt;:stdio&lt;/code&gt; 获取多个字节。</target>
        </trans-unit>
        <trans-unit id="aef78a3cc35c0eec4a213bb06eb18783344f5a30" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">从IO &lt;code&gt;device&lt;/code&gt; 获取多个字节。</target>
        </trans-unit>
        <trans-unit id="464c10475e938f50f88715c59eebddca575584e5" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">获取字符串 &lt;code&gt;source&lt;/code&gt; 并使用 &lt;code&gt;bindings&lt;/code&gt; 评估值。</target>
        </trans-unit>
        <trans-unit id="dce9c015f4c3caacfed76da20580dc567b349125" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">获取字符串 &lt;code&gt;source&lt;/code&gt; 并生成带引号的表达式，该表达式可以由Elixir评估或编译为函数。</target>
        </trans-unit>
        <trans-unit id="77a47a00f7c2dc7431f1fd26f1f6a07c0721fc92" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested data structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">获取值并通过给定 &lt;code&gt;path&lt;/code&gt; 更新嵌套的数据结构。</target>
        </trans-unit>
        <trans-unit id="197bee8d14aabe7ecd2c0b8cae48772622a49701" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested structure.</source>
          <target state="translated">获取一个值并更新一个嵌套结构。</target>
        </trans-unit>
        <trans-unit id="24fc43c308b364700a4a6b0c3e1ab5a6e0a34321" translate="yes" xml:space="preserve">
          <source>Gets a value from a nested structure.</source>
          <target state="translated">从嵌套结构中获取一个值。</target>
        </trans-unit>
        <trans-unit id="234783729be10591273a98e34996adf814d0af2b" translate="yes" xml:space="preserve">
          <source>Gets all values for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 所有值。</target>
        </trans-unit>
        <trans-unit id="337ee14d7455079870c96913a5344151625e3a44" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数获取一个代理值。</target>
        </trans-unit>
        <trans-unit id="cc4728d1ab03bf9e6b17772b1edd930d1db3e60f" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given function.</source>
          <target state="translated">通过给定的函数获得一个代理值。</target>
        </trans-unit>
        <trans-unit id="7ccc56cd7cf9a38cdbce42e3b62827d91b072aca" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数在一次操作中获取并更新代理状态。</target>
        </trans-unit>
        <trans-unit id="8e2c80c38d6dbae8b378d7ea7441399c6dccc722" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given function.</source>
          <target state="translated">通过给定的函数在一次操作中获取并更新代理状态。</target>
        </trans-unit>
        <trans-unit id="096ecee5005ebff9401bca63004bd1e4271d321f" translate="yes" xml:space="preserve">
          <source>Gets and updates the given key in a &lt;code&gt;container&lt;/code&gt; (a map, a keyword list, a struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取并更新 &lt;code&gt;container&lt;/code&gt; 的给定键（映射，关键字列表，实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的结构）。</target>
        </trans-unit>
        <trans-unit id="87f10d7ccf1593e9cf40f6046fb73ed64260d10f" translate="yes" xml:space="preserve">
          <source>Gets preferred CLI environment for the task.</source>
          <target state="translated">获取任务的首选CLI环境。</target>
        </trans-unit>
        <trans-unit id="7ae776c4b4f195b1f36b2be173094733049a81b3" translate="yes" xml:space="preserve">
          <source>Gets the application for the given module.</source>
          <target state="translated">获取指定模块的应用程序。</target>
        </trans-unit>
        <trans-unit id="a3186207a243a3a8619e9edb98a5c2ef194e1cbc" translate="yes" xml:space="preserve">
          <source>Gets the compilation options from the code server.</source>
          <target state="translated">从代码服务器获取编译选项。</target>
        </trans-unit>
        <trans-unit id="224e4a732cfad5d058a4b2c327797e2a8a3c70d9" translate="yes" xml:space="preserve">
          <source>Gets the current time zone database.</source>
          <target state="translated">获取当前时区数据库。</target>
        </trans-unit>
        <trans-unit id="1f02096a4a7d41ef362ad56dd8a049be60b3048f" translate="yes" xml:space="preserve">
          <source>Gets the current working directory.</source>
          <target state="translated">获取当前工作目录。</target>
        </trans-unit>
        <trans-unit id="8890fe17865bc33bcf4596b3f99ac374608009ec" translate="yes" xml:space="preserve">
          <source>Gets the directory for app.</source>
          <target state="translated">获取app的目录。</target>
        </trans-unit>
        <trans-unit id="a0d384aa0e95a00ba787ac060a94eb0ed4d124ec" translate="yes" xml:space="preserve">
          <source>Gets the element at the zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;tuple&lt;/code&gt; 中从零开始的 &lt;code&gt;index&lt;/code&gt; 处获取元素。</target>
        </trans-unit>
        <trans-unit id="ff598d3e96b472f599f3428af98b3592d274ed04" translate="yes" xml:space="preserve">
          <source>Gets the given attribute from a module.</source>
          <target state="translated">从模块中获取给定属性。</target>
        </trans-unit>
        <trans-unit id="d86f7fa0e05aedae7d11fde1051d7047e16a9a64" translate="yes" xml:space="preserve">
          <source>Gets the message for an &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">获取有关 &lt;code&gt;exception&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="d01b62b32cf43c3c1a84005842e75a1a8e58e56a" translate="yes" xml:space="preserve">
          <source>Gets the moduledoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">获取给定任务 &lt;code&gt;module&lt;/code&gt; 的moduledoc 。</target>
        </trans-unit>
        <trans-unit id="b0dee9f2cb9d3796fb7a48d547b0b2fb9dd7e266" translate="yes" xml:space="preserve">
          <source>Gets the representation of any expression.</source>
          <target state="translated">获取任何表达式的表示。</target>
        </trans-unit>
        <trans-unit id="aacf11051abfff1af3276a82387ff290a1040ef2" translate="yes" xml:space="preserve">
          <source>Gets the shortdoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">获取给定任务 &lt;code&gt;module&lt;/code&gt; 的shortdoc 。</target>
        </trans-unit>
        <trans-unit id="985fa8a31c64d1abf929750e6b62fcffb66d5d21" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">获取特定的价值 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2670bc6c3a1d135ba35e9b1dd103fad35687d05" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="cd6a6dd9113df059c87999c56f37603a31759691" translate="yes" xml:space="preserve">
          <source>Gets the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取容器中给定键的值（实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="8bbd7b83737713a8cdf97c7e1c36926c053390c6" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass.</source>
          <target state="translated">一 &lt;code&gt;key&lt;/code&gt; 获取键值并进行更新。</target>
        </trans-unit>
        <trans-unit id="eb0a567720e720098dfad63e9f3f00ec9b4e381f" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 获取值并更新它。如果没有 &lt;code&gt;key&lt;/code&gt; ，则引发。</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="efe79cf11081ba631fe2c7b862ea12b5382475d7" translate="yes" xml:space="preserve">
          <source>Getting started guide</source>
          <target state="translated">入门指南</target>
        </trans-unit>
        <trans-unit id="621916a4cc49b2e7a0bda3364f0574a16aa3088a" translate="yes" xml:space="preserve">
          <source>Getting the head or the tail of an empty list throws an error:</source>
          <target state="translated">获取空列表的头或尾会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="e8fbc4cd9319e626e1ccf7f2fcd4c822c8a5bcbe" translate="yes" xml:space="preserve">
          <source>Git options (&lt;code&gt;:git&lt;/code&gt;)</source>
          <target state="translated">Git选项（ &lt;code&gt;:git&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="37a8f2d730b24d981ab8fef7024613f2ad9ff494" translate="yes" xml:space="preserve">
          <source>Given a query string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt;, this function inserts each key-value pair in the query string as one entry in the given &lt;code&gt;map&lt;/code&gt;. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</source>
          <target state="translated">给定形式为 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 的查询字符串，此函数将查询字符串中的每个键值对作为给定 &lt;code&gt;map&lt;/code&gt; 中的一个条目插入。结果映射中的键和值将是二进制的。键和值将转义百分号。</target>
        </trans-unit>
        <trans-unit id="681fb9c4d5bed925cb73d7a24ad5b09e42d58e91" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements right before element &lt;code&gt;start_index&lt;/code&gt;, then takes &lt;code&gt;amount&lt;/code&gt; of elements, returning as many elements as possible if there are not enough elements.</source>
          <target state="translated">给定一个 &lt;code&gt;enumerable&lt;/code&gt; ，它会在元素 &lt;code&gt;start_index&lt;/code&gt; 之前放下元素，然后获取元素 &lt;code&gt;amount&lt;/code&gt; ，如果没有足够的元素，则返回尽可能多的元素。</target>
        </trans-unit>
        <trans-unit id="9abc0837abc465b4295e2cadea49184fb4cb4c6a" translate="yes" xml:space="preserve">
          <source>Given an enumerable of enumerables, concatenates the &lt;code&gt;enumerables&lt;/code&gt; into a single list.</source>
          <target state="translated">给定可枚举的枚举，将 &lt;code&gt;enumerables&lt;/code&gt; 枚举串联到单个列表中。</target>
        </trans-unit>
        <trans-unit id="f3677630682772650b101e7db35f800ba5311f07" translate="yes" xml:space="preserve">
          <source>Given the anonymous function:</source>
          <target state="translated">鉴于匿名函数:</target>
        </trans-unit>
        <trans-unit id="cd1d5229cdbf0e79ed32d47a41c7e0424cb85df8" translate="yes" xml:space="preserve">
          <source>Given three vertices, find the shortest path from the first to the last.</source>
          <target state="translated">给定三个顶点,找出从第一个顶点到最后一个顶点的最短路径。</target>
        </trans-unit>
        <trans-unit id="eb698f945d96926994811a109269c63fcc2c2588" translate="yes" xml:space="preserve">
          <source>Giving an argument that does not match any of the clauses raises an error.</source>
          <target state="translated">给出一个不符合任何一个子句的论点会引起错误。</target>
        </trans-unit>
        <trans-unit id="6962fecddec56252c7eb488f5a99ecedf3c0d3ff" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting a &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; given by &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">&lt;code&gt;doc2&lt;/code&gt; 两个文档（ &lt;code&gt;doc1&lt;/code&gt; 和doc2），在它们之间插入由 &lt;code&gt;break_string&lt;/code&gt; 给出的&lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a76459e82605f9a2f2ab9a4295c080bd4d42cf0" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting the given break &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">粘贴两个文档（ &lt;code&gt;doc1&lt;/code&gt; 和 &lt;code&gt;doc2&lt;/code&gt; ），在它们之间插入给定的break &lt;code&gt;break_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb7c805f7de70037ed1803ff9f5f16721be43e5" translate="yes" xml:space="preserve">
          <source>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module.</source>
          <target state="translated">字词也可以是两个字符,但有些语言将其解释为一个字符。例如,有些语言可能将 &quot;ch &quot;视为一个字符。然而,由于这一信息取决于当地语言,本模块没有考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="d6bc40a0f5a48e1cfea2b0fd464f5f6f31570bd2" translate="yes" xml:space="preserve">
          <source>Guard clauses can also be given to the match:</source>
          <target state="translated">守护条款也可以给比赛。</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="cd32950893cbba732683c916fdaa3f7721bfbc75" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed.</source>
          <target state="translated">守护是用更复杂的检查来增强模式匹配的一种方式。它们被允许在预先定义的一组允许模式匹配的构造中使用。</target>
        </trans-unit>
        <trans-unit id="f51e7c885b3316cf13c1a89511ab0220e376f9ff" translate="yes" xml:space="preserve">
          <source>Guards can be used in patterns as well:</source>
          <target state="translated">护栏也可以用在图案中。</target>
        </trans-unit>
        <trans-unit id="da2c059bdbc9e50988efa18e14c41ef3278c8017" translate="yes" xml:space="preserve">
          <source>Guards can be used to restrict type variables given as arguments to the function.</source>
          <target state="translated">守卫可以用来限制作为函数参数的类型变量。</target>
        </trans-unit>
        <trans-unit id="3d4e06fce5066ed597d68206744c09c068cc26cf" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; keyword, which is followed by a boolean expression (we will define the grammar of guards more formally later on).</source>
          <target state="translated">警卫队以 &lt;code&gt;when&lt;/code&gt; 关键字开头，后跟一个布尔表达式（稍后我们将更正式地定义警卫队的语法）。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="d645d6ef806b49668fa2c86b98204a1d0cbd439f" translate="yes" xml:space="preserve">
          <source>Guide: Metaprogramming</source>
          <target state="translated">指南:元编程</target>
        </trans-unit>
        <trans-unit id="fc6d12560c986e5d173ff3f215b4fdc7dd78c449" translate="yes" xml:space="preserve">
          <source>Guide: Mix &amp;amp; OTP</source>
          <target state="translated">指南：混合和OTP</target>
        </trans-unit>
        <trans-unit id="1e562d47149e19ed5cad18f5c03b2789d427f02b" translate="yes" xml:space="preserve">
          <source>Handles assigns in quoted expressions.</source>
          <target state="translated">处理引号表达式中的赋值。</target>
        </trans-unit>
        <trans-unit id="ddf833f3c5194a503cfbad70c99e1db7094771aa" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~C&lt;/code&gt; for charlists.</source>
          <target state="translated">处理印记 &lt;code&gt;~C&lt;/code&gt; 为charlists。</target>
        </trans-unit>
        <trans-unit id="fb3ba3c1a95dbc32cd091a7bf8625e909b666103" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~D&lt;/code&gt; for dates.</source>
          <target state="translated">处理印记 &lt;code&gt;~D&lt;/code&gt; 的日期。</target>
        </trans-unit>
        <trans-unit id="982325391ef0142622780269edf1546f73b262a3" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~N&lt;/code&gt; for naive date times.</source>
          <target state="translated">处理印记 &lt;code&gt;~N&lt;/code&gt; 幼稚日期倍。</target>
        </trans-unit>
        <trans-unit id="61bcb2084c564ad8723451ec89fc1bbe6d5b39d6" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~R&lt;/code&gt; for regular expressions.</source>
          <target state="translated">处理印记 &lt;code&gt;~R&lt;/code&gt; 为正则表达式。</target>
        </trans-unit>
        <trans-unit id="ee65de02481e36f7795050fdcbac43c76b0097f0" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~S&lt;/code&gt; for strings.</source>
          <target state="translated">处理印记 &lt;code&gt;~S&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="021700491c061be385dd02126ab31483e68097c1" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~T&lt;/code&gt; for times.</source>
          <target state="translated">处理印记 &lt;code&gt;~T&lt;/code&gt; 的时间。</target>
        </trans-unit>
        <trans-unit id="2b0a2c1b8e946dd36ec07ae3f98021a22faab492" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">处理印记 &lt;code&gt;~U&lt;/code&gt; 创建UTC &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f52b59decaffdf3dbd50c018dec832cff60ddfc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~W&lt;/code&gt; for list of words.</source>
          <target state="translated">处理印记 &lt;code&gt;~W&lt;/code&gt; 单词的列表。</target>
        </trans-unit>
        <trans-unit id="3f9e6bb6b9375b71e2dd3e6c31781d8b7de4f2bc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~c&lt;/code&gt; for charlists.</source>
          <target state="translated">处理印记 &lt;code&gt;~c&lt;/code&gt; 为charlists。</target>
        </trans-unit>
        <trans-unit id="e93b408b9addb240b0d8fec06f1cc6fd6483cad8" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~r&lt;/code&gt; for regular expressions.</source>
          <target state="translated">处理印记 &lt;code&gt;~r&lt;/code&gt; 为正则表达式。</target>
        </trans-unit>
        <trans-unit id="5c8529f6bd35c204f46a458ef8fe33f88fe57b75" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~s&lt;/code&gt; for strings.</source>
          <target state="translated">处理印记 &lt;code&gt;~s&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="812d965b782f5a4cdb2aa6ca4e03193e8426a888" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~w&lt;/code&gt; for list of words.</source>
          <target state="translated">处理印记 &lt;code&gt;~w&lt;/code&gt; 单词的列表。</target>
        </trans-unit>
        <trans-unit id="7849ebf167a97ce455aff4c671cafc34086c2adc" translate="yes" xml:space="preserve">
          <source>Happy coding!</source>
          <target state="translated">编码快乐!</target>
        </trans-unit>
        <trans-unit id="e74fbc6484fa15dc5415ec3ea61b85c17ae16042" translate="yes" xml:space="preserve">
          <source>HashDict</source>
          <target state="translated">HashDict</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b4f9c2553efc8e434d9a14c06152b8e6c5d5f2d5" translate="yes" xml:space="preserve">
          <source>Help for all of those functions can be consulted directly from the command line using the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; helper itself. Try:</source>
          <target state="translated">可以使用&lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt;帮助器本身直接从命令行中查询所有这些功能的帮助。尝试：</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="c42a25368aea44b1d8b6e2caeca032b5ca554730" translate="yes" xml:space="preserve">
          <source>Helpers for defining test cases.</source>
          <target state="translated">定义测试用例的助手。</target>
        </trans-unit>
        <trans-unit id="d5c884b844c2ebd809f20b51b9edc72b238135da" translate="yes" xml:space="preserve">
          <source>Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated.</source>
          <target state="translated">因此被称为 &quot;柔性&quot;,它们在文件装配时更加灵活。另一方面,它们的价格比较昂贵,因为每次断裂都需要重新评估。</target>
        </trans-unit>
        <trans-unit id="b1aef6d0ceaad34efbe32b0b7338abfa12a31756" translate="yes" xml:space="preserve">
          <source>Here are some examples of working with different types and modifiers:</source>
          <target state="translated">下面是一些使用不同类型和修饰符的例子。</target>
        </trans-unit>
        <trans-unit id="42db1d3d86baee9f18579aec4c71f6475b37d168" translate="yes" xml:space="preserve">
          <source>Here are some invalid ones:</source>
          <target state="translated">下面是一些无效的。</target>
        </trans-unit>
        <trans-unit id="11442cf4a8b2c1cb2e42c80414e3bc9baaa0cb80" translate="yes" xml:space="preserve">
          <source>Here are some valid paths:</source>
          <target state="translated">以下是一些有效的路径。</target>
        </trans-unit>
        <trans-unit id="352db02f68b7960ade3f7f5b302deb2325291825" translate="yes" xml:space="preserve">
          <source>Here is a better implementation of our Stack module:</source>
          <target state="translated">下面是我们Stack模块的一个比较好的实现。</target>
        </trans-unit>
        <trans-unit id="d3dfbcd6177f2eeaaed92da7d1fa4ce5d577524c" translate="yes" xml:space="preserve">
          <source>Here is a rundown of the life-cycle of the test process:</source>
          <target state="translated">下面是测试过程的生命周期的简要介绍。</target>
        </trans-unit>
        <trans-unit id="b7fa9405686c3918f67bf3e27b8a6096e14cbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">这是如何在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:console&lt;/code&gt; 后端的示例：</target>
        </trans-unit>
        <trans-unit id="b3a43eba555f0c13a34172cd9439caffcb152633" translate="yes" xml:space="preserve">
          <source>Here is an example on how we mimic an echo server from the command line:</source>
          <target state="translated">下面是一个关于如何从命令行模拟回音服务器的例子。</target>
        </trans-unit>
        <trans-unit id="3edae206369380098d80617af169ddbd0abfffd5" translate="yes" xml:space="preserve">
          <source>Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2:</source>
          <target state="translated">下面是一个遍历列表中的偶数和奇数乘以2的例子。</target>
        </trans-unit>
        <trans-unit id="050a27ec30c2a26d404808ec75322f708750e58e" translate="yes" xml:space="preserve">
          <source>Here is the full echo server implementation:</source>
          <target state="translated">这里是完整的echo服务器实现。</target>
        </trans-unit>
        <trans-unit id="6f777b3d9caee14d91c8f30553a83cea3e2dc561" translate="yes" xml:space="preserve">
          <source>Here is the updated code for the &lt;code&gt;TestCase&lt;/code&gt; module:</source>
          <target state="translated">这是 &lt;code&gt;TestCase&lt;/code&gt; 模块的更新代码：</target>
        </trans-unit>
        <trans-unit id="84bb9c9b475cb5ae8d6aa130c97b79761a44437b" translate="yes" xml:space="preserve">
          <source>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and &lt;em&gt;mapping&lt;/em&gt; over it is known as a &lt;em&gt;map algorithm&lt;/em&gt;.</source>
          <target state="translated">在这里，我们使用了递归遍历一个列表，将每个元素加倍并返回一个新列表。获取列表并对其进行&lt;em&gt;映射&lt;/em&gt;的过程称为&lt;em&gt;映射算法&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5c22f5f67bc89de4473d36dd5d40a24915681d3c" translate="yes" xml:space="preserve">
          <source>Here we will use Agents, and create a module named &lt;code&gt;KV.Bucket&lt;/code&gt;, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.</source>
          <target state="translated">在这里，我们将使用代理，并创建一个名为 &lt;code&gt;KV.Bucket&lt;/code&gt; 的模块，该模块负责存储键值条目，使键值条目可以被其他进程读取和修改。</target>
        </trans-unit>
        <trans-unit id="bbd25c9ac39901e5a89af9e9cc14cd5e96101d55" translate="yes" xml:space="preserve">
          <source>Here, the arrow (&lt;code&gt;&amp;lt;--&lt;/code&gt;) indicates the &lt;strong&gt;marked&lt;/strong&gt; function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below).</source>
          <target state="translated">在此，箭头（ &lt;code&gt;&amp;lt;--&lt;/code&gt; ）表示&lt;strong&gt;标记的&lt;/strong&gt;功能-本段描述的功能。您还将看到其直接调用方（上方）和被调用函数（下方）。</target>
        </trans-unit>
        <trans-unit id="f90a2dd87f0e0e5b3fc18bbdd374ab3f255b75b6" translate="yes" xml:space="preserve">
          <source>Hex options (&lt;code&gt;:hex&lt;/code&gt;)</source>
          <target state="translated">十六进制选项（ &lt;code&gt;:hex&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="778ad2f9bcae03814f9abdf00cda4d6b0dd5b58c" translate="yes" xml:space="preserve">
          <source>Hexadecimals and Unicode code points will be escaped if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?x&lt;/code&gt;. Unicode code points if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?u&lt;/code&gt;.</source>
          <target state="translated">如果map函数对 &lt;code&gt;?x&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则十六进制和Unicode代码点将被转义。如果map函数对 &lt;code&gt;?u&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则Unicode代码指向。</target>
        </trans-unit>
        <trans-unit id="26e85f63826bec68a04b03d81896950af6108f8b" translate="yes" xml:space="preserve">
          <source>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</source>
          <target state="translated">不应激进地使用休眠,因为太多的时间可能会花在垃圾收集上。一般来说,只有在不希望很快收到消息的时候才使用休眠,而且尽量减少进程的内存是有益的。</target>
        </trans-unit>
        <trans-unit id="86c45c0195b718d67c0a438292af56b71a044d2f" translate="yes" xml:space="preserve">
          <source>Hiding Internal Modules and Functions</source>
          <target state="translated">隐藏内部模块和函数</target>
        </trans-unit>
        <trans-unit id="0ea7288fabe36d1374b87e85268bd81849d9bced" translate="yes" xml:space="preserve">
          <source>History size</source>
          <target state="translated">历史尺寸</target>
        </trans-unit>
        <trans-unit id="fc314201ff6cdd49c00bb54c2d3a38dc7360de1d" translate="yes" xml:space="preserve">
          <source>Hot code swapping</source>
          <target state="translated">热代码交换</target>
        </trans-unit>
        <trans-unit id="3935f3cf215c2daeec7c25cef51c0a03f6190f58" translate="yes" xml:space="preserve">
          <source>How can this line fail if we just created the bucket in the previous line?</source>
          <target state="translated">如果我们刚刚在上一行创建了bucket,这一行怎么会失败呢?</target>
        </trans-unit>
        <trans-unit id="04ccc44e58210facfedf9edfba2604fce3cfc2e4" translate="yes" xml:space="preserve">
          <source>How to supervise</source>
          <target state="translated">如何监督</target>
        </trans-unit>
        <trans-unit id="7cdfd34c64026a6f64366847c32473d397480980" translate="yes" xml:space="preserve">
          <source>However Elixir introduces a syntax sugar where the keywords above may be written as follows:</source>
          <target state="translated">然而Elixir引入了一个语法糖,上面的关键词可以写成如下。</target>
        </trans-unit>
        <trans-unit id="7d4e3b65932901a80bd0c8daa5e66bd16aedca07" translate="yes" xml:space="preserve">
          <source>However, a quoted variable is represented as:</source>
          <target state="translated">然而,引用的变量表示为:。</target>
        </trans-unit>
        <trans-unit id="057b67626d2f5f52a384b7c48714343f2812737b" translate="yes" xml:space="preserve">
          <source>However, after our project is compiled using a tool like Mix, we know all modules that have been defined, including protocols and their implementations. This way, the protocol can be consolidated into a very simple and fast dispatch module.</source>
          <target state="translated">但是,当我们的项目使用Mix这样的工具进行编译之后,我们就知道所有已经定义好的模块,包括协议及其实现。这样一来,协议就可以整合成一个非常简单快速的调度模块。</target>
        </trans-unit>
        <trans-unit id="30b8c9087b77b2def4f60524eab486ec77b7882f" translate="yes" xml:space="preserve">
          <source>However, do not provide &lt;code&gt;__using__/1&lt;/code&gt; if all it does is to import, alias or require the module itself. For example, avoid this:</source>
          <target state="translated">但是，如果仅用于导入，别名或需要模块本身，则不要提供 &lt;code&gt;__using__/1&lt;/code&gt; 。例如，避免这种情况：</target>
        </trans-unit>
        <trans-unit id="82776ff5a87946e16cbe8e021db6c7eca6df82eb" translate="yes" xml:space="preserve">
          <source>However, functions that return booleans and are valid in guards follow another convention, described next.</source>
          <target state="translated">然而,返回booleans并在guards中有效的函数遵循另一个惯例,接下来将介绍。</target>
        </trans-unit>
        <trans-unit id="e2f8333bf85aa3e6557d871123f4e54aa89129c2" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">但是，如果用单个字符&amp;ldquo;带有急性&amp;rdquo;重音的&amp;ldquo; e&amp;rdquo;表示&amp;ldquo;&amp;eacute;&amp;rdquo;，则它将返回 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dea6b01d6679272ba037abafc94d5ec1f3a1e91" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part:</source>
          <target state="translated">但是，如果用单个字符&amp;ldquo;具有尖锐的&amp;rdquo;重音符号表示&amp;ldquo;&amp;eacute;&amp;rdquo;，则它将字符串拆分成一个部分：</target>
        </trans-unit>
        <trans-unit id="43d541b3bc1e148da1c64ef9ffa0bbfd2e7364f7" translate="yes" xml:space="preserve">
          <source>However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as:</source>
          <target state="translated">但是,如果使用了弹性断点,那么每个断点在渲染时都会被重新评估,所以文档可能会被渲染成:。</target>
        </trans-unit>
        <trans-unit id="e59920d8100c9a8114a12d93422f9d86a0ab473f" translate="yes" xml:space="preserve">
          <source>However, if there is a need to access the user variable, nil can be given:</source>
          <target state="translated">但是,如果需要访问用户变量,可以给出nil。</target>
        </trans-unit>
        <trans-unit id="ebac26b5b96f39c6c425c9f7338b33aa11d33d44" translate="yes" xml:space="preserve">
          <source>However, if we use &lt;code&gt;string&lt;/code&gt;, then the string length is used, instead of byte size, correctly fitting:</source>
          <target state="translated">但是，如果我们使用 &lt;code&gt;string&lt;/code&gt; ，那么将使用字符串长度而不是字节大小来正确拟合：</target>
        </trans-unit>
        <trans-unit id="163ec0dc8d44d05de91c4d5e307d82258afc33ad" translate="yes" xml:space="preserve">
          <source>However, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:</source>
          <target state="translated">然而,如果你期望文件在那里,砰的变化更有用,因为它提出了一个有意义的错误信息。避免写。</target>
        </trans-unit>
        <trans-unit id="b26ef74513acb14878e64cf7d06f11768d520400" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (e.g. if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">然而,如果你期望结果总是成功的(例如,如果你期望文件总是存在的),bang变体可以更方便,并且会在失败时提出一个更有用的错误信息(比模式匹配失败)。</target>
        </trans-unit>
        <trans-unit id="12f2ae0ce38b2739810767448aba2df24da58505" translate="yes" xml:space="preserve">
          <source>However, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.</source>
          <target state="translated">然而,如果你把每一个应用都作为一个单独的项目推送到Git仓库中,你的项目可能会变得非常难以维护,因为你会花费大量的时间来管理这些Git仓库,而不是编写你的代码。</target>
        </trans-unit>
        <trans-unit id="c4db01e79b2e5a22ecea1d3f50d5983cb25a53b4" translate="yes" xml:space="preserve">
          <source>However, if you want to invoke a specific module, function and arguments, or give the task process a name, you need to define the task in its own module:</source>
          <target state="translated">但是,如果你想调用特定的模块、函数和参数,或者给任务进程命名,你需要在自己的模块中定义任务。</target>
        </trans-unit>
        <trans-unit id="ab714719ee8f889dd923393f22c68b77c2b16ffe" translate="yes" xml:space="preserve">
          <source>However, in some cases it may be desired to associate a value to the process using the alternate &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; tuple:</source>
          <target state="translated">但是，在某些情况下，可能希望使用备用 &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; 元组将值与流程相关联：</target>
        </trans-unit>
        <trans-unit id="d4761ed59b0d1afa93377c7f7b363dfb8fb4fda3" translate="yes" xml:space="preserve">
          <source>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the &lt;code&gt;^&lt;/code&gt; special form, colloquially known as the pin operator:</source>
          <target state="translated">但是，在某些情况下，与现有值匹配而不是重新绑定很有用。可以使用 &lt;code&gt;^&lt;/code&gt; 特殊形式来完成此操作，通常称为pin运算符：</target>
        </trans-unit>
        <trans-unit id="96e149dd0b884d4a6fa96fb42e3515395245b191" translate="yes" xml:space="preserve">
          <source>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</source>
          <target state="translated">然而,在大多数情况下,您希望将任务监督员添加到您的监督树中。</target>
        </trans-unit>
        <trans-unit id="dba0c307e5ca681865cce6227a859a96ae9a11f3" translate="yes" xml:space="preserve">
          <source>However, instead of adding more code to the &lt;code&gt;kv&lt;/code&gt; application, we are going to build the TCP server as another application that is a client of the &lt;code&gt;kv&lt;/code&gt; application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.</source>
          <target state="translated">但是，我们没有向 &lt;code&gt;kv&lt;/code&gt; 应用程序添加更多代码，而是将TCP服务器构建为作为 &lt;code&gt;kv&lt;/code&gt; 应用程序客户端的另一个应用程序。由于整个运行时和Elixir生态系统都面向应用程序，因此将我们的项目分解为可以协同工作的较小应用程序是有意义的，而不是构建大型的整体应用程序。</target>
        </trans-unit>
        <trans-unit id="1f2acb719b57d971a999b6feb20a4c47ae5bfcf5" translate="yes" xml:space="preserve">
          <source>However, keep in mind that adding &lt;code&gt;@doc false&lt;/code&gt; does not make the function private. The function above can still be invoked as &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt;. Not only that, if &lt;code&gt;MyApp.Sample&lt;/code&gt; is imported, the &lt;code&gt;add/2&lt;/code&gt; function will also be imported into the caller. For those reasons, be cautious when adding &lt;code&gt;@doc false&lt;/code&gt; to functions, instead use one of these two options:</source>
          <target state="translated">但是，请记住，添加 &lt;code&gt;@doc false&lt;/code&gt; 不会使函数私有。上面的函数仍然可以作为 &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt; 调用。不仅如此，如果导入 &lt;code&gt;MyApp.Sample&lt;/code&gt; ，则 &lt;code&gt;add/2&lt;/code&gt; 函数也将导入到调用方中。由于这些原因，在向函数添加 &lt;code&gt;@doc false&lt;/code&gt; 时要谨慎，而请使用以下两个选项之一：</target>
        </trans-unit>
        <trans-unit id="ce1e4503150dc2f3049f826f979cbe9905825d87" translate="yes" xml:space="preserve">
          <source>However, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run.</source>
          <target state="translated">然而,请记住,通过使测试分布式,我们可能会减少运行频率,因为我们可能不会在每次测试运行时都进行分布式设置。</target>
        </trans-unit>
        <trans-unit id="f5ae69f63821cec3eb4f2016854327b6c5df477d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">但是，请记住，这些情况通常不是问题。毕竟，PID引用的过程可能随时崩溃，包括从注册表获取值和向其发送消息之间。标准库的许多部分都为解决这一问题而设计，例如&lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;，如果受监视的进程已经死机，&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;立即传递 &lt;code&gt;:DOWN&lt;/code&gt; 消息；而Kernel.send / 2则充当死机的无操作。流程。</target>
        </trans-unit>
        <trans-unit id="9a395466f1651904a7d0044a0e96b1a814183371" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">但是，该语言还存在许多其他可枚举的内容，例如&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt;返回的数据类型，它允许遍历文件，就好像它是可枚举的一样。</target>
        </trans-unit>
        <trans-unit id="1b496aae43041f07a94c194092a1ee0cf80d4eec" translate="yes" xml:space="preserve">
          <source>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and &lt;strong&gt;we should never convert user input to atoms&lt;/strong&gt;. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</source>
          <target state="translated">但是，用原子命名动态过程是一个可怕的想法！如果使用原子，则需要将存储桶名称（通常是从外部客户端接收到的存储桶）&lt;strong&gt;转换&lt;/strong&gt;为原子，并且&lt;strong&gt;永远不要将用户输入转换为原子&lt;/strong&gt;。这是因为原子不是垃圾收集的。一旦创建了原子，就永远不会对其进行回收。根据用户输入生成原子意味着用户可以注入足够多的不同名称来耗尽我们的系统内存！</target>
        </trans-unit>
        <trans-unit id="77afe59f2cf778e4ba45a1656955754632ba1dec" translate="yes" xml:space="preserve">
          <source>However, should we be fine with the implementation for &lt;code&gt;Any&lt;/code&gt;, in order to use such implementation we would need to tell our struct to explicitly derive the &lt;code&gt;Size&lt;/code&gt; protocol:</source>
          <target state="translated">但是，如果我们对 &lt;code&gt;Any&lt;/code&gt; 的实现感到满意，为了使用这种实现，我们需要告诉我们的结构显式派生 &lt;code&gt;Size&lt;/code&gt; 协议：</target>
        </trans-unit>
        <trans-unit id="1f35366701d4be066fddfcbe4789ab0e44ff649f" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;KV.Registry.create/2&lt;/code&gt; is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</source>
          <target state="translated">但是，由于 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 是强制转换操作，因此该命令将在我们实际写入表之前返回！换句话说，这正在发生：</target>
        </trans-unit>
        <trans-unit id="b607bf41eed0b7acedbf1d601f4e6081a4cb7cfb" translate="yes" xml:space="preserve">
          <source>However, since structs are just maps, they work with the functions from the &lt;code&gt;Map&lt;/code&gt; module:</source>
          <target state="translated">但是，由于结构只是映射，因此它们可以使用 &lt;code&gt;Map&lt;/code&gt; 模块中的函数：</target>
        </trans-unit>
        <trans-unit id="e7b768f9063dad4bbd7d785c035b8dad45c243ae" translate="yes" xml:space="preserve">
          <source>However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the &lt;code&gt;start_link&lt;/code&gt; argument instead of the specification:</source>
          <target state="translated">但是，将每个子项的子项规范指定为映射可能会很容易出错，因为我们可能会更改Stack实现并忘记更新其规范。这就是Elixir允许您传递带有模块名称和 &lt;code&gt;start_link&lt;/code&gt; 参数而不是规范的元组的原因：</target>
        </trans-unit>
        <trans-unit id="496f233e2f16ce1ec282e5a3228096d9e60212a4" translate="yes" xml:space="preserve">
          <source>However, strings are just part of the story. If a string is a binary, and we have used the &lt;code&gt;is_binary/1&lt;/code&gt; function, Elixir must have an underlying type empowering strings. And it does! Let&amp;rsquo;s talk about binaries.</source>
          <target state="translated">但是，字符串只是故事的一部分。如果字符串是二进制的，并且我们使用了 &lt;code&gt;is_binary/1&lt;/code&gt; 函数，则Elixir必须具有底层类型来授权字符串。确实如此！让我们谈谈二进制文件。</target>
        </trans-unit>
        <trans-unit id="82b09700b9bf9936f190f1106abb6ccb1f220f41" translate="yes" xml:space="preserve">
          <source>However, the code below would work as long as &lt;code&gt;:option_parser_example&lt;/code&gt; atom is used at some point later (or earlier) &lt;strong&gt;in the same module&lt;/strong&gt;. For example:</source>
          <target state="translated">但是，只要稍后&lt;strong&gt;在同一模块中&lt;/strong&gt;（或更早）使用 &lt;code&gt;:option_parser_example&lt;/code&gt; 原子，以下代码就可以工作。例如：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b357c81b8f132fc24fbf479211e75b269f8fae9b" translate="yes" xml:space="preserve">
          <source>However, the size cannot be defined in the match outside the binary/bitstring match:</source>
          <target state="translated">但是,在二进制/位串匹配之外的匹配中不能定义大小。</target>
        </trans-unit>
        <trans-unit id="88399305a4f17930e312791fc1d3a07b6c89a0a2" translate="yes" xml:space="preserve">
          <source>However, there is a bug in our stack server. If we call &lt;code&gt;:pop&lt;/code&gt; and the stack is empty, it is going to crash because no clause matches:</source>
          <target state="translated">但是，我们的堆栈服务器中有一个错误。如果我们调用 &lt;code&gt;:pop&lt;/code&gt; 并且堆栈为空，则它将崩溃，因为没有子句匹配：</target>
        </trans-unit>
        <trans-unit id="6b30a9e6e90f8ae42f6ce5f8d5d4ee4d68edc7af" translate="yes" xml:space="preserve">
          <source>However, there is still one concern left, which are the restart strategies. Tasks, by default, have the &lt;code&gt;:restart&lt;/code&gt; value set to &lt;code&gt;:temporary&lt;/code&gt;, which means they are not restarted. This is an excellent default for the connections started via the &lt;code&gt;Task.Supervisor&lt;/code&gt;, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.</source>
          <target state="translated">但是，仍然存在一个问题，那就是重启策略。默认情况下，任务的 &lt;code&gt;:restart&lt;/code&gt; 值设置为 &lt;code&gt;:temporary&lt;/code&gt; ，这意味着它们不会重新启动。对于通过 &lt;code&gt;Task.Supervisor&lt;/code&gt; 启动的连接，这是一个很好的默认设置，因为重新启动失败的连接没有任何意义，但是对于接受者来说，这是一个糟糕的选择。如果受体崩溃，我们希望使受体重新启动并运行。</target>
        </trans-unit>
        <trans-unit id="2654066a02c149d51e371eeaac885d94072a55a8" translate="yes" xml:space="preserve">
          <source>However, this module returns the proper length:</source>
          <target state="translated">然而,这个模块返回的是适当的长度。</target>
        </trans-unit>
        <trans-unit id="41d8fdc77d8f21adeb6b27918df1a329fe13ff18" translate="yes" xml:space="preserve">
          <source>However, using lists in IO operations requires some attention. A list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the &lt;code&gt;IO&lt;/code&gt; module starting with &lt;code&gt;bin*&lt;/code&gt; must be used. Those functions expect an &lt;code&gt;iodata&lt;/code&gt; as an argument; i.e., they expect a list of integers representing bytes or binaries to be given.</source>
          <target state="translated">但是，在IO操作中使用列表需要引起注意。列表可以表示一堆字节或一堆字符，要使用哪个列表取决于IO设备的编码。如果打开文件时未进行编码，则文件应处于原始模式，并且必须使用 &lt;code&gt;IO&lt;/code&gt; 模块中以 &lt;code&gt;bin*&lt;/code&gt; 开头的功能。这些函数期望使用 &lt;code&gt;iodata&lt;/code&gt; 作为参数。即，他们期望给出代表字节或二进制数的整数列表。</target>
        </trans-unit>
        <trans-unit id="b77af23f35c905af8889b972cb68357936576822" translate="yes" xml:space="preserve">
          <source>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the &lt;code&gt;=&lt;/code&gt; operator):</source>
          <target state="translated">但是，在匹配中分配的变量在函数调用之外将不可用（与使用 &lt;code&gt;=&lt;/code&gt; 运算符进行常规模式匹配不同）：</target>
        </trans-unit>
        <trans-unit id="5c24fd6169426183241dcc9a0bdf50f1c21b8290" translate="yes" xml:space="preserve">
          <source>However, variables explicitly bound in the clause &quot;body&quot; are accessible from the outer context:</source>
          <target state="translated">但是,在子句 &quot;body &quot;中明确绑定的变量可以从外部上下文中访问。</target>
        </trans-unit>
        <trans-unit id="a2b5a965ef9a419fe17594f66438c5b71c746d05" translate="yes" xml:space="preserve">
          <source>However, we can connect to the other shell remotely. Open up the &lt;code&gt;User switch command&lt;/code&gt; prompt (Ctrl+G) and type:</source>
          <target state="translated">但是，我们可以远程连接到另一个外壳。打开 &lt;code&gt;User switch command&lt;/code&gt; 提示符（Ctrl + G）并键入：</target>
        </trans-unit>
        <trans-unit id="b76f1491e39a30e4f05d47d9af534982461917de" translate="yes" xml:space="preserve">
          <source>However, we can spawn a new process on &lt;code&gt;foo@computer-name&lt;/code&gt; from &lt;code&gt;bar@computer-name&lt;/code&gt;! Let&amp;rsquo;s give it a try (where &lt;code&gt;@computer-name&lt;/code&gt; is the one you see locally):</source>
          <target state="translated">然而，我们可以产生新的进程 &lt;code&gt;foo@computer-name&lt;/code&gt; 从 &lt;code&gt;bar@computer-name&lt;/code&gt; ！让我们尝试一下（其中 &lt;code&gt;@computer-name&lt;/code&gt; 是您在本地看到的名称）：</target>
        </trans-unit>
        <trans-unit id="f37bd2760f0cfed52b63715c0c0ee324352998b9" translate="yes" xml:space="preserve">
          <source>However, we can't invoke it as follows:</source>
          <target state="translated">但是,我们不能按以下方式调用它。</target>
        </trans-unit>
        <trans-unit id="693f31cc1e3b5ed02531511f77198af8ecfd7ceb" translate="yes" xml:space="preserve">
          <source>However, when an &lt;code&gt;else&lt;/code&gt; clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;rescue&lt;/code&gt; in the same &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">但是，当存在 &lt;code&gt;else&lt;/code&gt; 子句但表达式的结果与任何模式都不匹配时，将引发异常。在同一 &lt;code&gt;try&lt;/code&gt; 中，此异常不会被捕获或 &lt;code&gt;rescue&lt;/code&gt; &lt;code&gt;catch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4c77097fa9973bf214463e34dd009d5f8b620b4e" translate="yes" xml:space="preserve">
          <source>However, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.</source>
          <target state="translated">但是,当主管重启新的桶时,注册表并不知道它的存在。所以,我们会在主管中出现一个无人可以访问的空桶! 为了解决这个问题,我们想说的是,桶其实是暂时的。如果它们崩溃了,不管是什么原因,都不应该重新启动它们。</target>
        </trans-unit>
        <trans-unit id="aaa0ec2494f85dbc09c2cf136ebd0615520b8aec" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause simply fails to match:</source>
          <target state="translated">但是,如果用在卫士中,对应的子句根本无法匹配。</target>
        </trans-unit>
        <trans-unit id="659be2322a62899199e6224a02bca5b99ed29e51" translate="yes" xml:space="preserve">
          <source>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in &lt;code&gt;:raw&lt;/code&gt; mode. The options &lt;code&gt;:read_ahead&lt;/code&gt; and &lt;code&gt;:delayed_write&lt;/code&gt; are also useful when operating on large files or working with files in tight loops.</source>
          <target state="translated">但是，您可能并不总是希望为此抽象付出代价。在这种情况下，可以使用 &lt;code&gt;:raw&lt;/code&gt; 模式打开文件。 &lt;code&gt;:read_ahead&lt;/code&gt; 和 &lt;code&gt;:delayed_write&lt;/code&gt; 选项在处理大型文件或紧密循环使用文件时也很有用。</target>
        </trans-unit>
        <trans-unit id="f893640c0df5ffde8dd2c6fee00f09a1846f23f1" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could do:</source>
          <target state="translated">但是，您的生产环境可能有特定的需求。例如，现在我们正在对路由表进行硬编码，但是在生产中，您可能需要从磁盘，另一服务中读取路由表，甚至需要联系Kubernetes等编排工具。这可以通过添加 &lt;code&gt;config/releases.exs&lt;/code&gt; 来完成。顾名思义，此文件在每次发行版开始时运行。例如，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5ff8ae7f9913820c4cc328c8f087e28f17634493" translate="yes" xml:space="preserve">
          <source>Hygiene in aliases</source>
          <target state="translated">别名中的卫生问题</target>
        </trans-unit>
        <trans-unit id="93c4bc3fa55a161e49f6a7b16214db78fe9e8cb2" translate="yes" xml:space="preserve">
          <source>Hygiene in imports</source>
          <target state="translated">进口产品的卫生问题</target>
        </trans-unit>
        <trans-unit id="2569893e8a4ee578273b8aabe0ac087b41daa61c" translate="yes" xml:space="preserve">
          <source>Hygiene in variables</source>
          <target state="translated">变量中的卫生</target>
        </trans-unit>
        <trans-unit id="a8882cab0a9a900efc9a6181ff8e693783509bb4" translate="yes" xml:space="preserve">
          <source>IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.</source>
          <target state="translated">IANA提供的时区数据包括不同的UTC偏移量和时区标准偏移量的数据。</target>
        </trans-unit>
        <trans-unit id="c31397c072d7bdb4a10bd53b1d1d02f67a9c1ce2" translate="yes" xml:space="preserve">
          <source>ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus &lt;code&gt;Other_ID_Continue&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points.</source>
          <target state="translated">ID_Start字符，再加上具有非间距标记，间隔组合标记，十进制数，连接器标点符号，加的Unicode普通类字符 &lt;code&gt;Other_ID_Continue&lt;/code&gt; ，减去 &lt;code&gt;Pattern_Syntax&lt;/code&gt; 和 &lt;code&gt;Pattern_White_Space&lt;/code&gt; 代码点。</target>
        </trans-unit>
        <trans-unit id="c2ad7abf6ecd35c09ec969d6e5c5f626d2f547e0" translate="yes" xml:space="preserve">
          <source>IEx</source>
          <target state="translated">IEx</target>
        </trans-unit>
        <trans-unit id="bfd7d496a0b2c2b60b82d2300407f3ae22ad37d7" translate="yes" xml:space="preserve">
          <source>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</source>
          <target state="translated">IEx允许你以两种方式连接到另一个节点。首先,我们只有同时给当前的shell和我们想要连接的shell命名,才能连接到一个shell。</target>
        </trans-unit>
        <trans-unit id="8d4f60e469c0e609dec1269dbd88a28be0de6f53" translate="yes" xml:space="preserve">
          <source>IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function.</source>
          <target state="translated">IEx还能够在Elixir代码上设置断点,并 &quot;窥探 &quot;到正在运行的进程。这允许开发人员在给定的函数中运行一个 IEx 会话。</target>
        </trans-unit>
        <trans-unit id="de2b6b57cb35a438bfce75b9ed0826e918fad577" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx以一种热切的方式逐行评估其输入，这意味着，如果在一行的末尾看到的代码是一个完整的表达式，IEX将在那一点进行评估。此行为可能会导致已跨多行格式化的表达式产生错误，这通常是管道表达式的情况。考虑使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt;运算符的以下表达式：</target>
        </trans-unit>
        <trans-unit id="64c5dfd453f493f03e877d65639ce61fedbb37bc" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">IEx助手包括许多与断点有关的便利。在下面它们列出了完整的模块，例如&lt;a href=&quot;iex.helpers#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt;，但是请记住，可以在IEx内部将它们直接称为 &lt;code&gt;breaks()&lt;/code&gt; 。他们是：</target>
        </trans-unit>
        <trans-unit id="0c364f03a852b53d4a7a502b57654a110b1cce03" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;iex.helpers&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx提供了很多帮手。可以通过在外壳中键入 &lt;code&gt;h()&lt;/code&gt; 或作为&lt;a href=&quot;iex.helpers&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块的文档来访问它们。</target>
        </trans-unit>
        <trans-unit id="9fbe836e228d1004a30dd6875de1a22111586f81" translate="yes" xml:space="preserve">
          <source>IEx will also color inspected expressions using the &lt;code&gt;:syntax_colors&lt;/code&gt; option. Such can be disabled with:</source>
          <target state="translated">IEx还将使用 &lt;code&gt;:syntax_colors&lt;/code&gt; 选项为检查的表达式着色。可以通过以下方式禁用此功能：</target>
        </trans-unit>
        <trans-unit id="f04ddcbeb347ea8a966dd445a3b79f8b70364e41" translate="yes" xml:space="preserve">
          <source>IEx.Helpers</source>
          <target state="translated">IEx.Helpers</target>
        </trans-unit>
        <trans-unit id="785a031a616ad88bcb1b2cd5dbbc60681be53958" translate="yes" xml:space="preserve">
          <source>IEx.Server</source>
          <target state="translated">IEx.Server</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="5b2f49f5a657a5ef736fa25eed6851c434d0dac3" translate="yes" xml:space="preserve">
          <source>IO and the file system</source>
          <target state="translated">IO和文件系统</target>
        </trans-unit>
        <trans-unit id="bbc4e8881ad6a75f10bb6ea9bff4b74783ee6ecc" translate="yes" xml:space="preserve">
          <source>IO data</source>
          <target state="translated">IO数据</target>
        </trans-unit>
        <trans-unit id="ec099c7a428e418929af391ebb305d925a77dc9c" translate="yes" xml:space="preserve">
          <source>IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.</source>
          <target state="translated">IO数据之所以存在,是因为经常需要对较小块的二进制文件进行许多追加操作,以便创建一个更大的二进制文件。然而,在Erlang和Elixir中,连接二进制文件会将连接后的二进制文件复制到一个新的二进制文件中。</target>
        </trans-unit>
        <trans-unit id="9d9b6408eac92df9305226b9c32fd45d1762d634" translate="yes" xml:space="preserve">
          <source>IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.</source>
          <target state="translated">IO数据是一种数据类型,在某些情况下可以作为二进制数据更有效的替代。</target>
        </trans-unit>
        <trans-unit id="370428fc749a05dd70935487b7d4064e7d83c3fb" translate="yes" xml:space="preserve">
          <source>IO devices</source>
          <target state="translated">IO设备</target>
        </trans-unit>
        <trans-unit id="d2ef1a7a2a7b43d0fc955e96e915a7dad9160987" translate="yes" xml:space="preserve">
          <source>IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt;&lt;code&gt;:file.position/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">IO设备保持其位置，这意味着随后对任何读取或写入功能的调用将从上次访问该设备的位置开始。可以使用&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt; &lt;code&gt;:file.position/2&lt;/code&gt; &lt;/a&gt;函数更改文件的位置。</target>
        </trans-unit>
        <trans-unit id="b5cbeaffeb75ad57a2191d67bc818e573faa6d01" translate="yes" xml:space="preserve">
          <source>IO.ANSI</source>
          <target state="translated">IO.ANSI</target>
        </trans-unit>
        <trans-unit id="0089fd381dd7dfd8d488c15134d255be01885915" translate="yes" xml:space="preserve">
          <source>IO.Stream</source>
          <target state="translated">IO.Stream</target>
        </trans-unit>
        <trans-unit id="8139a358a2645d3cf610141a9bce4c7312be5781" translate="yes" xml:space="preserve">
          <source>IO.StreamError</source>
          <target state="translated">IO.StreamError</target>
        </trans-unit>
        <trans-unit id="3d7d3441a8eff66aaa0f0faa36a8a05b3a785de8" translate="yes" xml:space="preserve">
          <source>IO.StreamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">IO.StreamError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="77802d65267b1d073f6e93dafd03f4d02d064153" translate="yes" xml:space="preserve">
          <source>IO.inspect/2</source>
          <target state="translated">IO.inspect/2</target>
        </trans-unit>
        <trans-unit id="c1f9284c3367b68f5c96129104a3a9d0f4c9d187" translate="yes" xml:space="preserve">
          <source>Identifiers in Elixir are case sensitive.</source>
          <target state="translated">Elixir中的标识符是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="057deff008e9d8f83cd686c8b17c3d4c02169546" translate="yes" xml:space="preserve">
          <source>Identifying functions and documentation</source>
          <target state="translated">确定职能和文件</target>
        </trans-unit>
        <trans-unit id="537a4055c25749aea0df46647a3ecdd449be90bb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.</source>
          <target state="translated">如果&lt;a href=&quot;#after_suite/1&quot;&gt; &lt;code&gt;after_suite/1&lt;/code&gt; &lt;/a&gt;被多次调用，则回调将以相反的顺序被调用。换句话说，最后一个回调集将是第一个被调用的集。</target>
        </trans-unit>
        <trans-unit id="c2d101d3a59aa29536cff11d9f78612ab949d729" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:code_change/3&quot;&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/a&gt; raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</source>
          <target state="translated">如果&lt;a href=&quot;#c:code_change/3&quot;&gt; &lt;code&gt;code_change/3&lt;/code&gt; &lt;/a&gt;引发代码更改失败，则循环将继续其先前的状态。因此，此回调通常不包含副作用。</target>
        </trans-unit>
        <trans-unit id="1f1a0f874c702790d228021c47f6f58e4a98062d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt; is called before the application is loaded, the application environment values specified in the &lt;code&gt;.app&lt;/code&gt; file will override the ones previously set.</source>
          <target state="translated">如果在加载应用程序之前调用&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;.app&lt;/code&gt; 文件中指定的应用程序环境值将覆盖先前设置的值。</target>
        </trans-unit>
        <trans-unit id="9f537d260ef97992e561be1422ea408f4c00b527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:abort&lt;/code&gt;, the runtime system aborts producing a core dump, if that is enabled in the operating system.</source>
          <target state="translated">如果 &lt;code&gt;:abort&lt;/code&gt; ，则运行时系统将中止生成核心转储（如果在操作系统中启用了该核心转储）。</target>
        </trans-unit>
        <trans-unit id="e351673ad711ca575120b265bcb522e29ffb1ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:all&lt;/code&gt; is given, &lt;code&gt;:eof&lt;/code&gt; is never returned, but an empty string in case the device has reached EOF.</source>
          <target state="translated">如果给定 &lt;code&gt;:all&lt;/code&gt; ，则 &lt;code&gt;:eof&lt;/code&gt; 将永远不会返回，但如果设备已到达EOF，则为空字符串。</target>
        </trans-unit>
        <trans-unit id="664fc2657c2121b52010aad0e4fd4b13a3191a1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:build_per_environment&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it will create a new build per environment:</source>
          <target state="translated">如果 &lt;code&gt;:build_per_environment&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，它将根据环境创建一个新的构建：</target>
        </trans-unit>
        <trans-unit id="1cd0a5e0adcba1255cdaf72cd16d9cb0159c0426" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:discard&lt;/code&gt; is given in &lt;code&gt;leftover&lt;/code&gt;, the last chunk is discarded unless it has exactly &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果 &lt;code&gt;:discard&lt;/code&gt; 在 &lt;code&gt;leftover&lt;/code&gt; 部分中给出，则最后一个块将被丢弃，除非它具有完全 &lt;code&gt;count&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4ad666f68aa0c1c3e9b90d4547788465ffe950b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:stdio&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">如果 &lt;code&gt;:stdio&lt;/code&gt; 是Unicode设备，则 &lt;code&gt;count&lt;/code&gt; 表示要检索的Unicode代码点的数量。否则， &lt;code&gt;count&lt;/code&gt; 是要检索的原始字节数。</target>
        </trans-unit>
        <trans-unit id="1c37a0fde2ecc757cae6c2a1e1d8b99469865d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@behaviour&lt;/code&gt; has been defined, &lt;code&gt;defoverridable&lt;/code&gt; can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to &lt;code&gt;defoverridable&lt;/code&gt; will be marked as overridable.</source>
          <target state="translated">如果 &lt;code&gt;@behaviour&lt;/code&gt; 已定义， &lt;code&gt;defoverridable&lt;/code&gt; 也可以与一个模块作为参数来调用。从调用之上的行为到 &lt;code&gt;defoverridable&lt;/code&gt; 的所有已实现的回调将被标记为可重写。</target>
        </trans-unit>
        <trans-unit id="0535dd7868286893881566e917783949810a614d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is a negative number, it starts counting from the back to the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 是一个负数，则从 &lt;code&gt;enumerable&lt;/code&gt; 开始计数。</target>
        </trans-unit>
        <trans-unit id="128e0031d4c1374c0210ba717199fde5a91caf98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is greater than the size of the rest of the &lt;code&gt;enumerable&lt;/code&gt;, then this function will reverse the rest of the enumerable.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 大于其余 &lt;code&gt;enumerable&lt;/code&gt; 的大小，则此函数将反转其余可枚举的大小。</target>
        </trans-unit>
        <trans-unit id="64a4a2dc00ee57596c01d8e55272d16ee1731764" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is not provided, &lt;code&gt;nil&lt;/code&gt; is used.</source>
          <target state="translated">如果未提供 &lt;code&gt;default&lt;/code&gt; ，则使用 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4804fe88251de4efebed7a3b7f7ec9b900a0c7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is a PID, it must be the PID of a local process, dead or alive. If &lt;code&gt;dest&lt;/code&gt; is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</source>
          <target state="translated">如果 &lt;code&gt;dest&lt;/code&gt; 是PID，则它必须是本地进程的PID，无论该进程是死的还是活动的。如果 &lt;code&gt;dest&lt;/code&gt; 是原子，则它必须是在交付时查找的注册过程的名称。如果名称不涉及进程，则不会产生错误。</target>
        </trans-unit>
        <trans-unit id="2650eb70496be023811483cdbe9dcf267336d48b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">如果 &lt;code&gt;flag&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则打开监视。如果 &lt;code&gt;flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则关闭监视。</target>
        </trans-unit>
        <trans-unit id="f1c832ccf95731edf1d63b91b33e2d1fe522cd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, acc}&lt;/code&gt; the reduction is halted and the function returns &lt;code&gt;acc&lt;/code&gt;. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;fun&lt;/code&gt; 返回 &lt;code&gt;{:halt, acc}&lt;/code&gt; 则减少停止，函数返回 &lt;code&gt;acc&lt;/code&gt; 。否则，如果可枚举已用尽，该函数将返回最后一个 &lt;code&gt;{:cont, acc}&lt;/code&gt; 的累加器。</target>
        </trans-unit>
        <trans-unit id="448b014151f38127b8e5f6db3c5223d75cfbeb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index_range.last&lt;/code&gt; is out of bounds, then it is assigned as the index of the last element.</source>
          <target state="translated">如果 &lt;code&gt;index_range.last&lt;/code&gt; 超出范围，则将其指定为最后一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="44dafce589cc2560c530b258260863b84a7ad4e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to the empty binary.</source>
          <target state="translated">如果完全没有传递 &lt;code&gt;joiner&lt;/code&gt; ，则默认为空二进制。</target>
        </trans-unit>
        <trans-unit id="a91338d96953ddc227939bd5311d00c34a7770ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则会引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e25538be406057a69443efa5940b2d432b4b6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, lazily evaluates &lt;code&gt;fun&lt;/code&gt; and returns its result.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则懒惰地评估 &lt;code&gt;fun&lt;/code&gt; 并返回其结果。</target>
        </trans-unit>
        <trans-unit id="0a81a69a6fcff94ffbea2c950485431c58d11511" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, return the default value (&lt;code&gt;nil&lt;/code&gt; if no default value).</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回默认值（如果没有默认值，则返回 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ab5d096dab446f6e25ac353134ecfc0c4cc20f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是不存在 &lt;code&gt;keywords&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="b02bea90648629b86487eddfaee7cd58979250c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="d4150f660167317dcaba9e8183ce3412c0294207" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The initial value will not be passed through the update function.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在具有值 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; ，则 &lt;code&gt;fun&lt;/code&gt; 以参数 &lt;code&gt;value&lt;/code&gt; 调用，其结果用作 &lt;code&gt;key&lt;/code&gt; 的新值。如果 &lt;code&gt;map&lt;/code&gt; 中不存在 &lt;code&gt;key&lt;/code&gt; ，则将 &lt;code&gt;initial&lt;/code&gt; 作为 &lt;code&gt;key&lt;/code&gt; 的值插入。初始值将不会通过更新函数传递。</target>
        </trans-unit>
        <trans-unit id="75a038e3ca604bf73652a1d5909bc26acc1aa307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在具有值 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; ，则会使用参数 &lt;code&gt;value&lt;/code&gt; 调用 &lt;code&gt;fun&lt;/code&gt; ，并且将其结果用作 &lt;code&gt;key&lt;/code&gt; 的新值。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="15c9a821a2b57a999e05676dbebd003979e0547e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是存在于 &lt;code&gt;map&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;{value, new_map}&lt;/code&gt; 返回其中 &lt;code&gt;new_map&lt;/code&gt; 是去除的结果 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;map&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{default, map}&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="9a0d4a917aec182ae2652ab6e3733862784d7df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是存在于 &lt;code&gt;map&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;{value, new_map}&lt;/code&gt; 返回其中 &lt;code&gt;new_map&lt;/code&gt; 是去除的结果 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;map&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{fun_result, map}&lt;/code&gt; 返回，其中 &lt;code&gt;fun_result&lt;/code&gt; 是应用的结果 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be3edc2b3eeca76a785d6024f2cdb09fb2dfde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 存在于 &lt;code&gt;map&lt;/code&gt; 中，值为 &lt;code&gt;value&lt;/code&gt; ，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57db7be79a09b897065af1bdf410edac419b10e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 存在于 &lt;code&gt;map&lt;/code&gt; 中，值为 &lt;code&gt;value&lt;/code&gt; ，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，将评估 &lt;code&gt;fun&lt;/code&gt; 并返回其结果。</target>
        </trans-unit>
        <trans-unit id="022b1446733b2fda7810ec19631252125e1aa84b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keys&lt;/code&gt; contains keys that are not in &lt;code&gt;map&lt;/code&gt;, they're simply ignored.</source>
          <target state="translated">如果 &lt;code&gt;keys&lt;/code&gt; 包含不在 &lt;code&gt;map&lt;/code&gt; 中的键，则将它们简单地忽略。</target>
        </trans-unit>
        <trans-unit id="9ec06751513a7783f95f06711b8c297f9eb8290a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keywords2&lt;/code&gt; has duplicate keys, the given function will be invoked for each matching pair in &lt;code&gt;keywords1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;keywords2&lt;/code&gt; 有重复的键，给定的功能将被调用用于每个匹配对 &lt;code&gt;keywords1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cda0fc7deb1f2ca2778dbdfbc7cd47a0b34753a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;{:EXIT, pid}&lt;/code&gt;, it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.</source>
          <target state="translated">如果 &lt;code&gt;kind&lt;/code&gt; 为 &lt;code&gt;{:EXIT, pid}&lt;/code&gt; ，则不会生成堆栈跟踪，因为此类退出将作为没有堆栈跟踪的消息检索。</target>
        </trans-unit>
        <trans-unit id="bfc34d2fd024a4826aee6c45876a01c2984997a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; ；否则为false。否则返回 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bbd966d4ee1229ab0c4a3f43a8067bf69d0b551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ；否则为false。否则返回 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e10ea7dbc53bb25e7807935c07de908ca7820b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is an integer, that's the indentation appended to line breaks whenever they occur. If the level is &lt;code&gt;:cursor&lt;/code&gt;, the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is &lt;code&gt;:reset&lt;/code&gt;, it is set back to 0.</source>
          <target state="translated">如果 &lt;code&gt;level&lt;/code&gt; 是一个整数，则是每当换行符出现时缩进的缩进。如果级别为 &lt;code&gt;:cursor&lt;/code&gt; ，则文档中&amp;ldquo;光标&amp;rdquo;的当前位置将成为嵌套。如果级别为 &lt;code&gt;:reset&lt;/code&gt; ，则将其设置回0。</target>
        </trans-unit>
        <trans-unit id="167313c87cdf050139328eaa55e0c8e46388fa2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含具有值 &lt;code&gt;value&lt;/code&gt; 的给定 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6733d65c27213cccbcddb83b9fc95fccaae0b10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含给定的 &lt;code&gt;key&lt;/code&gt; ，则返回相应的值。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则会引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="35d7fd154ea4c9faf69570f99b8c5aa4a3ac9ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 之初 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9b141a234955b46f94cdff6fb97f75b39d6831d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 在结束 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9bdc0c8aedc4a0581ea9ca9cb9ad9a4fe54a0d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modifiers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</source>
          <target state="translated">如果 &lt;code&gt;modifiers&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，则返回唯一的整数（可以是正数或负数）。可以传递其他修饰符来更改返回整数的属性：</target>
        </trans-unit>
        <trans-unit id="ad9eab2323c428de698fefc4bfc22b40c45681ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is an Erlang module (as opposed to an Elixir module), this function always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;module&lt;/code&gt; 是Erlang模块（而不是Elixir模块），则此函数始终返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de03926a3208aa38b1bdc68fa4dd867a9992c7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;monitor_ref&lt;/code&gt; is a reference which the calling process obtained by calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;monitor/1&lt;/code&gt;&lt;/a&gt;, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">如果 &lt;code&gt;monitor_ref&lt;/code&gt; 是通过调用&lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;monitor/1&lt;/code&gt; &lt;/a&gt;获得的调用过程的引用，则该监视将关闭。如果监视已关闭，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="a32f1f48118a9d4a2686cda59499e6684c476f2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an atom, it just calls &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; with the atom as the first argument and &lt;code&gt;[]&lt;/code&gt; as the second argument.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是一个原子，则只调用&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;，并将该原子作为第一个参数，将 &lt;code&gt;[]&lt;/code&gt; 作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="e2591f3e8296742e9e675974bb3bfcb35d27b411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an exception struct, it is raised as is.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是异常结构，则按原样引发它。</target>
        </trans-unit>
        <trans-unit id="cefdb1ca1740aca5f5451a4dad984640e42d15f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是其他任何东西，则 &lt;code&gt;raise&lt;/code&gt; 将失败，并出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="737a631e71f8710e641fef02c56115e74ed17ea3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="bc62758814a2f1d1d281641eed97d732d6ff6ae5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned.</source>
          <target state="translated">如果 &lt;code&gt;node&lt;/code&gt; 不存在，则返回无用的PID。</target>
        </trans-unit>
        <trans-unit id="63d9a61082e21b3845e40428cb3a08f3ea73ce2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;enumerable&lt;/code&gt; is directly converted to a list, without &lt;code&gt;fun&lt;/code&gt; being ever applied.</source>
          <target state="translated">如果 &lt;code&gt;nth&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，然后 &lt;code&gt;enumerable&lt;/code&gt; 直接转换到一个列表，没有 &lt;code&gt;fun&lt;/code&gt; 被采用过。</target>
        </trans-unit>
        <trans-unit id="2840ae873ffd42facf8e147450543acef64559c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; exists and is a symlink, returns &lt;code&gt;{:ok, target}&lt;/code&gt;, otherwise returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 存在并且是符号链接，则返回 &lt;code&gt;{:ok, target}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c154c595d1b4a01fb083386caa6ace778641f9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;path#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是字符串，则它将用作&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; 中&lt;/a&gt;的路径。如果 &lt;code&gt;path&lt;/code&gt; 是字符串的列表，它将被接合（参见&lt;a href=&quot;path#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt;），并且结果将被用作内部的路径&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30981afdf653766b4f2d8e17a8e76f8900fd6c71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored. See also &lt;a href=&quot;#relative_to/2&quot;&gt;&lt;code&gt;relative_to/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 已经是绝对路径，则 &lt;code&gt;relative_to&lt;/code&gt; 将被忽略。另请参见&lt;a href=&quot;#relative_to/2&quot;&gt; &lt;code&gt;relative_to/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4964bfcbfec35a641632c64af60eb6aaa93a561b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; points to a file, prints its full path.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 指向文件，则打印其完整路径。</target>
        </trans-unit>
        <trans-unit id="4ed36549216e7c96c0405d66d46c768efd40ee4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is not trapping exits, &lt;code&gt;pid&lt;/code&gt; will exit with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 未捕获，则 &lt;code&gt;pid&lt;/code&gt; 将以给定的 &lt;code&gt;reason&lt;/code&gt; 退出。</target>
        </trans-unit>
        <trans-unit id="633950331a76abae7c27012953c6b5ce717504f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; 并传递到 &lt;code&gt;pid&lt;/code&gt; 的消息队列。</target>
        </trans-unit>
        <trans-unit id="edb5e8ad174fd02444bbcb56b3f2079cf73580c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix&lt;/code&gt; is an empty list, it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;prefix&lt;/code&gt; 是一个空列表，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26bd0886bea64b0650f1573c9fd139f06c9e5d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is neither &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, nor &lt;code&gt;{:shutdown, term}&lt;/code&gt; an error is logged.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 既不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 也不是 &lt;code&gt;{:shutdown, term}&lt;/code&gt; ，则将记录错误。</target>
        </trans-unit>
        <trans-unit id="5c120fe241858b080c2215e59c9d1dfe3c97d43f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:kill&lt;/code&gt;, that is if &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;pid&lt;/code&gt; which will unconditionally exit with reason &lt;code&gt;:killed&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是原子 &lt;code&gt;:kill&lt;/code&gt; ，即调用 &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; ，则将不可陷阱的退出信号发送到 &lt;code&gt;pid&lt;/code&gt; ，该信号将无条件退出，原因为 &lt;code&gt;:killed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72ae981d0ae09b809a5b5a5aa46cd4ec885a9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;pid&lt;/code&gt; will not exit (unless &lt;code&gt;pid&lt;/code&gt; is the calling process, in which case it will exit with the reason &lt;code&gt;:normal&lt;/code&gt;). If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是原子 &lt;code&gt;:normal&lt;/code&gt; ，则 &lt;code&gt;pid&lt;/code&gt; 将不会退出（除非 &lt;code&gt;pid&lt;/code&gt; 是调用进程，在这种情况下，它将以原因 &lt;code&gt;:normal&lt;/code&gt; 退出）。如果正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; 并传递到其消息队列。</target>
        </trans-unit>
        <trans-unit id="def9dbc5ab56f1b825b6729ff4b5f2b1cf2751f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or &lt;code&gt;{:ok, keywords | map}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">如果 &lt;code&gt;setup_all&lt;/code&gt; 或 &lt;code&gt;setup&lt;/code&gt; 返回关键字列表，地图或 &lt;code&gt;{:ok, keywords | map}&lt;/code&gt; ，关键字列表或映射将合并到当前上下文中，并将在所有后续 &lt;code&gt;setup_all&lt;/code&gt; ， &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 本身中可用。</target>
        </trans-unit>
        <trans-unit id="977e9939903f7075b75909cc132a74bc274c1bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a directory, or a symbolic link to it, then &lt;code&gt;destination&lt;/code&gt; must be an existent &lt;code&gt;directory&lt;/code&gt; or a symbolic link to one, or a path to a non-existent directory.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 是目录，或指向该目录的符号链接，则 &lt;code&gt;destination&lt;/code&gt; 必须是一个存在的 &lt;code&gt;directory&lt;/code&gt; 或者是指向该目录的符号链接，或者是一个不存在的目录的路径。</target>
        </trans-unit>
        <trans-unit id="1031bcdd561dcecee641f002ce883c7af7e61139" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a file or a symbolic link to it, &lt;code&gt;destination&lt;/code&gt; must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 是文件或指向它的符号链接，则 &lt;code&gt;destination&lt;/code&gt; 必须是到现有文件的路径，到一个文件的符号链接或到不存在的文件的路径。</target>
        </trans-unit>
        <trans-unit id="e57c5ea9358fe4a917bdf2d9fa6f002a7ca491dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果以二进制以外的任何方式引用了 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;length&lt;/code&gt; 引用，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="bd707d6ea9c236adf3d2d26891903697d910f532" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效要求，则会引发&lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f9f03b1dcc9dbff5dcc7644074dd977a2959ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效版本，则会引发&lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae363da5635ac26a38468a274fa68594bffd7223" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is already a list, it returns the list. If &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns an empty list.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 已经是列表，则返回列表。如果 &lt;code&gt;term&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="c189d5b72f733627440a207910c642f9ff77e60b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;%URI{}&lt;/code&gt; struct is given to this function, this function returns it unmodified.</source>
          <target state="translated">如果将 &lt;code&gt;%URI{}&lt;/code&gt; 结构给予此函数，则此函数将其返回为未经修改的结构。</target>
        </trans-unit>
        <trans-unit id="9cb5769774bfa8aa4c65da1e51375f078f53a47d" translate="yes" xml:space="preserve">
          <source>If a byte has 8 bits, what happens if we pass a size of 1 bit?</source>
          <target state="translated">如果一个字节有8位,如果我们传递一个大小为1位的字节会怎样?</target>
        </trans-unit>
        <trans-unit id="0ac581e270299e95270be44edc11d5d78635bdbb" translate="yes" xml:space="preserve">
          <source>If a callback is given, it is invoked for each received message.</source>
          <target state="translated">如果给定了一个回调,那么每收到一个消息就会调用它。</target>
        </trans-unit>
        <trans-unit id="9510d4ce0d205517cf9f92994b15bfbfe1510aa1" translate="yes" xml:space="preserve">
          <source>If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen).</source>
          <target state="translated">如果一个实现给定行为的回调模块没有导出该行为定义的所有函数和宏,在编译过程中会通过警告通知用户(不会发生错误)。</target>
        </trans-unit>
        <trans-unit id="69b52804cd17d7f8a0689854f3222713a2e4c149" translate="yes" xml:space="preserve">
          <source>If a child specification with the specified ID already exists, &lt;code&gt;child_spec&lt;/code&gt; is discarded and this function returns an error with &lt;code&gt;:already_started&lt;/code&gt; or &lt;code&gt;:already_present&lt;/code&gt; if the corresponding child process is running or not, respectively.</source>
          <target state="translated">如果具有指定ID的子规范已经存在， &lt;code&gt;child_spec&lt;/code&gt; 废弃child_spec，并且如果相应的子进程正在运行或未运行，则此函数分别返回带有 &lt;code&gt;:already_started&lt;/code&gt; 或 &lt;code&gt;:already_present&lt;/code&gt; 的错误。</target>
        </trans-unit>
        <trans-unit id="4e2890f26410463009016ad753f613992362cbef" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes &lt;code&gt;callback&lt;/code&gt;. &lt;code&gt;callback&lt;/code&gt; must be a function that takes two arguments: &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;. The callback should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果目标中已经存在一个文件，它将调用 &lt;code&gt;callback&lt;/code&gt; 。 &lt;code&gt;callback&lt;/code&gt; 必须是一个带有两个参数的函数： &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 。如果现有文件应被覆盖，则回调应返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cabdc7b8c3d548d6762d990a45e3c0db4093b48f" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes a callback which should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten, &lt;code&gt;false&lt;/code&gt; otherwise. The callback defaults to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果目标中已存在文件，则它将调用一个回调，如果应覆盖现有文件，则该回调应返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。回调默认返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f5282b08680f8cf98b1cf98c1763e902d8a8cf1" translate="yes" xml:space="preserve">
          <source>If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">如果提供了功能，则将创建设备并将其发送到该功能。函数返回时，设备将关闭。最终结果将是带有 &lt;code&gt;:ok&lt;/code&gt; 的元组和函数的结果。</target>
        </trans-unit>
        <trans-unit id="d38f06a2f29af4b9a58ad54b574b4b65c78e3313" translate="yes" xml:space="preserve">
          <source>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</source>
          <target state="translated">如果一个具有缺省值的函数有多个子句,则需要创建一个函数头(没有实际的主体)来声明缺省值。</target>
        </trans-unit>
        <trans-unit id="000c898cfeca7c250248fbd1fa1ca561171bdc1f" translate="yes" xml:space="preserve">
          <source>If a given line starts a &lt;code&gt;describe&lt;/code&gt; block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number.</source>
          <target state="translated">如果给定的行开始了 &lt;code&gt;describe&lt;/code&gt; 块，则该行过滤器将在其中运行所有测试。否则，它将在给定的行号上或之前运行最接近的测试。</target>
        </trans-unit>
        <trans-unit id="79925800db01e377c0a45bd22e7acc683fbfbe07" translate="yes" xml:space="preserve">
          <source>If a key is a function, the function will be invoked passing three arguments:</source>
          <target state="translated">如果一个键是一个函数,那么该函数将通过三个参数被调用。</target>
        </trans-unit>
        <trans-unit id="29fd70a945f925cf23cc7e6f8035b1a44027a7d0" translate="yes" xml:space="preserve">
          <source>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</source>
          <target state="translated">如果一个列表是由非负整数组成,其中每个整数代表一个Unicode码点,那么这个列表也可以称为charlist。这些整数必须:</target>
        </trans-unit>
        <trans-unit id="b421abd37694bae36c7d25d86ffa518fdbbea4dd" translate="yes" xml:space="preserve">
          <source>If a module adopting a given behaviour doesn&amp;rsquo;t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</source>
          <target state="translated">如果采用给定行为的模块未实现该行为所需的回调之一，则将生成编译时警告。</target>
        </trans-unit>
        <trans-unit id="883d15353620b14cbb9c9d5a06e95f6b6c4d20b6" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of elements will be taken from the end. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">如果得到否定的 &lt;code&gt;amount&lt;/code&gt; 已定，那么 &lt;code&gt;amount&lt;/code&gt; 元件将从端作出。该 &lt;code&gt;enumerable&lt;/code&gt; 将被枚举一次检索正确的索引和剩余的计算是从端部执行。</target>
        </trans-unit>
        <trans-unit id="6cc671d5a37ef968ded5582cc81fb0522d873170" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of last values will be dropped. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">如果得到否定的 &lt;code&gt;amount&lt;/code&gt; 已定，那么 &lt;code&gt;amount&lt;/code&gt; 最后的值将被丢弃。该 &lt;code&gt;enumerable&lt;/code&gt; 将被枚举一次检索正确的索引和剩余的计算是从端部执行。</target>
        </trans-unit>
        <trans-unit id="59caaee16729c3dbee5fe847e2d7d4842c9c683a" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;count&lt;/code&gt; is given, the last &lt;code&gt;count&lt;/code&gt; values will be taken. For such, the collection is fully enumerated keeping up to &lt;code&gt;2 * count&lt;/code&gt; elements in memory. Once the end of the collection is reached, the last &lt;code&gt;count&lt;/code&gt; elements will be executed. Therefore, using a negative &lt;code&gt;count&lt;/code&gt; on an infinite collection will never return.</source>
          <target state="translated">如果给出负 &lt;code&gt;count&lt;/code&gt; ，将取最后一个 &lt;code&gt;count&lt;/code&gt; 数值。为此，将充分枚举该集合，并在内存中最多保留 &lt;code&gt;2 * count&lt;/code&gt; 元素。一旦到达集合的末尾，将执行最后一个 &lt;code&gt;count&lt;/code&gt; 元素。因此，对无限集合使用负 &lt;code&gt;count&lt;/code&gt; 将永远不会返回。</target>
        </trans-unit>
        <trans-unit id="f69e4dbe00c1ada199c059c775f25efeb8310586" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;n&lt;/code&gt; is given, it will drop the last &lt;code&gt;n&lt;/code&gt; elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until &lt;code&gt;n&lt;/code&gt; additional elements have been emitted by the enum.</source>
          <target state="translated">如果给定一个负数 &lt;code&gt;n&lt;/code&gt; ，它将删除集合中的最后 &lt;code&gt;n&lt;/code&gt; 个元素。注意，实现该机制的机制将延迟任何元素的发射，直到枚举发射了 &lt;code&gt;n&lt;/code&gt; 个其他元素为止。</target>
        </trans-unit>
        <trans-unit id="1945f4f47fb811a9fdec36bceacc04e13f4b23dd" translate="yes" xml:space="preserve">
          <source>If a non-unique registry is given, an error is raised.</source>
          <target state="translated">如果给出了一个非唯一的注册表,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="7fe100a04f7f3c2228565ba1dad4a516ece48f3e" translate="yes" xml:space="preserve">
          <source>If a positive &lt;code&gt;amount&lt;/code&gt; is given, it takes the &lt;code&gt;amount&lt;/code&gt; elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果给出正 &lt;code&gt;amount&lt;/code&gt; ，则从 &lt;code&gt;enumerable&lt;/code&gt; 的开头开始取 &lt;code&gt;amount&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="273c42e7694ef6f6a0ae619fbbe7e5dc6c7edfb5" translate="yes" xml:space="preserve">
          <source>If a previous value is already stored, all entries are removed and the value is overridden.</source>
          <target state="translated">如果之前的值已经存储,则删除所有条目并覆盖该值。</target>
        </trans-unit>
        <trans-unit id="43fc3383844fcfe72ece54d10710bd0bd9f25337" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">如果找不到给定类型的协议实现，则除非将协议配置为回退为 &lt;code&gt;Any&lt;/code&gt; ,否则将调用该协议。也可以在现有的基础上构建实现的便利，请&lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;以获取有关派生协议的更多信息。</target>
        </trans-unit>
        <trans-unit id="a016d1410ce73603f7d41b32703713ab6681b5cb" translate="yes" xml:space="preserve">
          <source>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</source>
          <target state="translated">如果将一个范围传递到函数中,这个函数将在范围限制之间选取一个随机值,而不遍历整个范围(因此在恒定时间和恒定内存中执行)。</target>
        </trans-unit>
        <trans-unit id="4e6fe5e08b24cf20a9c0798353e64ac83dfa14b4" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">如果记录在默认值中定义了匿名函数，则将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。从使用匿名函数作为默认值的Erlang库中提取记录后定义记录时，可能会无意间发生这种情况。</target>
        </trans-unit>
        <trans-unit id="a6abb6313f6cc1303f397ef517fbdc8da84732e6" translate="yes" xml:space="preserve">
          <source>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1.</source>
          <target state="translated">如果是字符串,则会产生一个以状态为口号的Erlang崩溃转储,然后运行时系统以状态码1退出。</target>
        </trans-unit>
        <trans-unit id="126afd1abf58596ead958f3fd3541d1004b086cc" translate="yes" xml:space="preserve">
          <source>If a switch can't be parsed according to the given type, it is returned in the invalid options list.</source>
          <target state="translated">如果一个开关不能根据给定的类型进行解析,则会在无效选项列表中返回。</target>
        </trans-unit>
        <trans-unit id="2b1173f30bab1103a16e4d18afe172d1cf1918aa" translate="yes" xml:space="preserve">
          <source>If a tag is given more than once, the last value wins.</source>
          <target state="translated">如果一个标签被赋予多于一次,则最后一个值获胜。</target>
        </trans-unit>
        <trans-unit id="30a9473b0d912205c959737a706b0e7ee4a0ec9d" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;mix.project#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">如果任务需要定义一个项目或需要在项目内访问一个特殊的功能，任务可以调用&lt;a href=&quot;mix.project#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; &lt;/a&gt;，其失败&lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;在项目没有定义的情况下。</target>
        </trans-unit>
        <trans-unit id="c67bc32edf1527e959986e52e98d4224edd81679" translate="yes" xml:space="preserve">
          <source>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return &lt;code&gt;{:exit, :noproc}&lt;/code&gt; as the result or exit reason can not be determined.</source>
          <target state="translated">如果已经监视或接收了任务的监视器，并且消息队列中没有等待响应，则此函数将返回 &lt;code&gt;{:exit, :noproc}&lt;/code&gt; 因为无法确定结果或退出原因。</target>
        </trans-unit>
        <trans-unit id="1a77a9db2807ea258346d1c8035a43bea2a0103f" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same pattern:</source>
          <target state="translated">如果一个变量在一个模式中被多次提及,那么所有的引用都应该绑定到同一个模式。</target>
        </trans-unit>
        <trans-unit id="2d5176a6bc70715553073a28b4fe06e7f78373b7" translate="yes" xml:space="preserve">
          <source>If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</source>
          <target state="translated">如果所有子句都匹配，则执行 &lt;code&gt;do&lt;/code&gt; 块，并返回其结果。否则，链中止，并返回不匹配的值：</target>
        </trans-unit>
        <trans-unit id="e9c4638272580cddbbaefbc10d002d4b066670b8" translate="yes" xml:space="preserve">
          <source>If all of the conditions return &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, an error (&lt;code&gt;CondClauseError&lt;/code&gt;) is raised. For this reason, it may be necessary to add a final condition, equal to &lt;code&gt;true&lt;/code&gt;, which will always match:</source>
          <target state="translated">如果所有条件都返回 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，则会引发错误（ &lt;code&gt;CondClauseError&lt;/code&gt; ）。出于这个原因，可能有必要添加一个最终条件，该条件等于 &lt;code&gt;true&lt;/code&gt; ，它将始终匹配：</target>
        </trans-unit>
        <trans-unit id="1ce3955a535274dbe7df8b09ce910f413bd1bd52" translate="yes" xml:space="preserve">
          <source>If amount is &lt;code&gt;0&lt;/code&gt;, it returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果数量为 &lt;code&gt;0&lt;/code&gt; ，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195d921f30b7ca6822ad57816fd9a2da342da9c2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is present, it will match on the results of the &lt;code&gt;try&lt;/code&gt; block whenever the &lt;code&gt;try&lt;/code&gt; block finishes without a throw or an error.</source>
          <target state="translated">如果存在 &lt;code&gt;else&lt;/code&gt; 块，则只要 &lt;code&gt;try&lt;/code&gt; 块完成而没有抛出或错误，它将与 &lt;code&gt;try&lt;/code&gt; 块的结果匹配。</target>
        </trans-unit>
        <trans-unit id="570f497970d66b8882cf83a80169ce5e7a3f4622" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;withclauseerror&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果使用 &lt;code&gt;else&lt;/code&gt; 块且没有匹配子句，则会引发&lt;a href=&quot;withclauseerror&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="de3cca2420a70cac7a0a92d8ce5ec9857a32f5c0" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; clause is not present and no exceptions are raised, the result of the expression will be returned:</source>
          <target state="translated">如果 &lt;code&gt;else&lt;/code&gt; 子句不存在并且没有引发异常，则将返回表达式的结果：</target>
        </trans-unit>
        <trans-unit id="e2d3671c086be455d33d12466d3540943c7f121c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;offset&lt;/code&gt; is given, we will index from the given offset instead of from zero.</source>
          <target state="translated">如果给出了 &lt;code&gt;offset&lt;/code&gt; ，我们将从给定的偏移量而不是从零开始索引。</target>
        </trans-unit>
        <trans-unit id="0a648b7fb5579eaba477422e6520374ab96f3bbc" translate="yes" xml:space="preserve">
          <source>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</source>
          <target state="translated">如果一个应用程序有包含的应用程序,它们也会被加载。而如果它们又有包含的应用,那么这个过程就会反复出现。包含的应用程序与Mix伞形项目中的应用程序无关,它们是一个与协调启动有关的Erlang/OTP概念。</target>
        </trans-unit>
        <trans-unit id="346e510adb982fcdef487692a01e3558f4f43dd0" translate="yes" xml:space="preserve">
          <source>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</source>
          <target state="translated">如果给定了一个原子,则假定它是一个Elixir模块,所以将其转换为二进制,然后进行处理。</target>
        </trans-unit>
        <trans-unit id="1dd9c12e4c69c00fd419e79703f50c2f1eb25bbf" translate="yes" xml:space="preserve">
          <source>If an empty string is given, returns an empty list.</source>
          <target state="translated">如果给定一个空字符串,返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="b8c7e22d59114292a3302ce7be80d94101c6ff48" translate="yes" xml:space="preserve">
          <source>If an integer, the runtime system exits with the integer value which is returned to the operating system.</source>
          <target state="translated">如果是整数,则运行时系统退出时的整数值将返回给操作系统。</target>
        </trans-unit>
        <trans-unit id="7d3f5440412ded7562694390034be201abb74a66" translate="yes" xml:space="preserve">
          <source>If an umbrella project reenables a task, it is reenabled for all child projects.</source>
          <target state="translated">如果一个伞形项目重新启用了一个任务,它就会对所有子项目重新启用。</target>
        </trans-unit>
        <trans-unit id="033137dbcc6d7e358cdff1f234f1f034d23cee4d" translate="yes" xml:space="preserve">
          <source>If anything had to be compiled, you see some informative text, and get the &lt;code&gt;:ok&lt;/code&gt; atom back, otherwise the function is silent, and returns &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">如果必须编译任何内容，则会看到一些有用的文本，并返回 &lt;code&gt;:ok&lt;/code&gt; 原子，否则该函数为无提示，并返回 &lt;code&gt;:noop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4dc8078aeab160f01342b984c42012d0bb7fb7" translate="yes" xml:space="preserve">
          <source>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</source>
          <target state="translated">如果数据以无法转换为UTF-8的格式发送至文件,或者数据被函数读取,而返回的数据格式无法应对数据的字符范围,则会发生错误,文件将被关闭。</target>
        </trans-unit>
        <trans-unit id="9cb11ee612f8a6fa1dc16b1180f3c60b5d1e6218" translate="yes" xml:space="preserve">
          <source>If desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as &lt;code&gt;Enumerable&lt;/code&gt; and possibly &lt;code&gt;Size&lt;/code&gt;, for this data type.</source>
          <target state="translated">如果需要，您可以针对结构的大小提出自己的语义。不仅如此，您还可以使用结构来构建更健壮的数据类型（例如队列），并为此数据类型实现所有相关协议，例如 &lt;code&gt;Enumerable&lt;/code&gt; 以及可能的 &lt;code&gt;Size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea1cd1f61403fdf9495800bfd2ea11cb562ca0b5" translate="yes" xml:space="preserve">
          <source>If duplicated entries exist, the first one is returned. Use &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; to retrieve all entries.</source>
          <target state="translated">如果存在重复的条目，则返回第一个。使用&lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt;检索所有条目。</target>
        </trans-unit>
        <trans-unit id="0b592a69d9d8fd53bf0bd9cbfc055db4e81ec7c8" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. So this function will not detect empty tuples:</source>
          <target state="translated">如果每个守卫表达式总是返回一个布尔值,那么这两种形式是等价的。然而,请记住,如果一个守卫中的任何函数调用引发异常,整个守卫就会失败。所以这个函数不会检测空的元组。</target>
        </trans-unit>
        <trans-unit id="dbe27cd775ccec3c6324b3d4efb95e206746dc7f" translate="yes" xml:space="preserve">
          <source>If file &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten by the contents in &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">如果文件 &lt;code&gt;destination&lt;/code&gt; 已经存在，则将被 &lt;code&gt;source&lt;/code&gt; 中的内容覆盖。</target>
        </trans-unit>
        <trans-unit id="fdc28a9b8dcfe0a11c8bac1e062e822f6767ef47" translate="yes" xml:space="preserve">
          <source>If file is a relative, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">如果文件是相对的,则会相对扩展到当前配置文件所在的目录。</target>
        </trans-unit>
        <trans-unit id="42ddc2f0c1e4117e2bba8be8a09c43a0ea2ed1bd" translate="yes" xml:space="preserve">
          <source>If for some reason the application needs to be configured before it is started, the &lt;code&gt;--no-start&lt;/code&gt; option can be used and you are then responsible for starting all applications by using functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. For more information about the application life-cycle and dynamically configuring applications, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">如果出于某种原因需要在启动之前配置应用程序，则可以使用 &lt;code&gt;--no-start&lt;/code&gt; 选项，然后您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt; &lt;code&gt;Application.ensure_all_started/1&lt;/code&gt; 之类的&lt;/a&gt;功能来启动所有应用程序。有关应用程序生命周期和动态配置应用程序的更多信息，请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="8fe39f85acaae7d9c0b9ede161359eb45dcac7a2" translate="yes" xml:space="preserve">
          <source>If injection is suddenly interrupted, &lt;code&gt;:halt&lt;/code&gt; is passed and the function can return any value as it won't be used.</source>
          <target state="translated">如果注入突然中断，则 &lt;code&gt;:halt&lt;/code&gt; 将被传递，该函数可以返回任何值，因为它将不被使用。</target>
        </trans-unit>
        <trans-unit id="6ef0c2aa8f05db2c984cf1df62ac6db58c68621a" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;datetime#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">如果相反，您希望在不同时区中的同一点时间使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;datetime#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt;函数，该函数会将哥本哈根的2018-08-24 10:00:00转换为2018-08-24 08:00:00在UTC。</target>
        </trans-unit>
        <trans-unit id="d54c8e6a4382ff70ea26a411e39ab67c3f015ec3" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">如果给出了无效的参数，则&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;由&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;引发。&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;还期望一组严格的选项，如果给出未知或无效的选项，则会提高。</target>
        </trans-unit>
        <trans-unit id="d184a96a7452ebbaa15d901cdfcd5646962e673b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则返回 &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="bf2413d6f2f1077cec728a8783f14bba8e944a5b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则会引发ArgumentError。</target>
        </trans-unit>
        <trans-unit id="1b73ba22cd3093f832e74a316d5262bd0f987e0a" translate="yes" xml:space="preserve">
          <source>If it succeeds in loading the module, it returns &lt;code&gt;{:module, module}&lt;/code&gt;. If not, returns &lt;code&gt;{:error, reason}&lt;/code&gt; with the error reason.</source>
          <target state="translated">如果成功加载模块，则返回 &lt;code&gt;{:module, module}&lt;/code&gt; 。如果不是，则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 以及错误原因。</target>
        </trans-unit>
        <trans-unit id="375e4e6baa78eec72e85f76cd1b054d6bf11d173" translate="yes" xml:space="preserve">
          <source>If it succeeds opening the file, it returns the &lt;code&gt;function&lt;/code&gt; result on the IO device.</source>
          <target state="translated">如果成功打开文件，它将在IO设备上返回 &lt;code&gt;function&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="f34822921b36640bca1582de43cfc049c94f2bdc" translate="yes" xml:space="preserve">
          <source>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</source>
          <target state="translated">如果最后一个大于第一个,范围将从第一个到最后一个增加。如果first大于last,范围将从第一个到最后一个递减。如果第一个等于最后一个,范围将包含一个元素,也就是数字本身。</target>
        </trans-unit>
        <trans-unit id="73ef68acbf89df4484fb1238776c874300f89fd7" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal or minimal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最大或最小的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="1368a6e71ce1bea12a85b30b7509f054b5bc170d" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最大的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="c6a9685a98347f5efadc0b8611df565d7f389d71" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered minimal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最小的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="038bfba61cc7a83ddd7d63b5a01873632ce42b48" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; exists, returns the keyword list unchanged.</source>
          <target state="translated">如果不存在带有 &lt;code&gt;value&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; ，则返回不变的关键字列表。</target>
        </trans-unit>
        <trans-unit id="7c893bf9fd681a7f7a6fb13527c0cc5dfde15e8a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the value of the previous expression is used.</source>
          <target state="translated">如果没有给出参数,则使用前一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="1b6cea41585ef2678e551c971ce31fe417d9dd88" translate="yes" xml:space="preserve">
          <source>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like &lt;code&gt;_&lt;/code&gt;) which will always match.</source>
          <target state="translated">如果没有子句匹配，则会引发错误。出于这个原因，可能有必要添加一个最终匹配的最终子句（例如 &lt;code&gt;_&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fc7cd6fb4c53519f3c55037a05bd9ecc868e4492" translate="yes" xml:space="preserve">
          <source>If no configuration file is given, it loads the project's configuration file, &quot;config/config.exs&quot;, if it exists. Keep in mind that the &quot;config/config.exs&quot; file is always loaded by the CLI and invoking it is only required in cases you are starting Mix manually.</source>
          <target state="translated">如果没有给定配置文件,它会加载项目的配置文件 &quot;config/config.exs&quot;(如果存在)。请记住,&quot;config/config.exe &quot;文件总是由CLI加载的,只有当你手动启动Mix时才需要调用它。</target>
        </trans-unit>
        <trans-unit id="b7eed02542b79da944224ca91fcc920777715fa8" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project is used.</source>
          <target state="translated">如果没有给出配置,则使用当前项目的配置。</target>
        </trans-unit>
        <trans-unit id="87546bcf9e4f94845bd9b4719319d8f898876f32" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project will be used.</source>
          <target state="translated">如果没有给出配置,将使用当前项目的配置。</target>
        </trans-unit>
        <trans-unit id="8420e9f0ced4b5e2305fa85af7c948aac181698b" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有给出功能，则在迭代过程中检查每个元素的真实性。当一个元素的值为 &lt;code&gt;false&lt;/code&gt; （false或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止并返回 &lt;code&gt;false&lt;/code&gt; 。在所有其他情况下，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af73d9c2f1028c805fc39df68dad67f7b564dd8d" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有给出功能，则在迭代过程中检查每个元素的真实性。当一个元素的值为真时（既不是 &lt;code&gt;false&lt;/code&gt; 也不是 &lt;code&gt;nil&lt;/code&gt; ），迭代会立即停止并返回 &lt;code&gt;true&lt;/code&gt; 。在所有其他情况下，将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99cc65b0a766a1d7c750735c04a6ce040c2ecd5f" translate="yes" xml:space="preserve">
          <source>If no matching tuple is found, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到匹配的元组，则返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db86456e3e6a45125baab8b1b669e7d382cc2ad8" translate="yes" xml:space="preserve">
          <source>If none of the clauses match, an error is raised:</source>
          <target state="translated">如果没有一个子句匹配,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="e2a4d7b7ce6ed34ac382f69616d43a496e285e59" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果不存在，则将终止，因为没有提供任何Shell进程输入。 &lt;code&gt;value&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b534d3078a1eaf21555f5ec72f4135c6d9a40dd" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be a string.</source>
          <target state="translated">如果不存在，则将终止，因为没有提供任何Shell进程输入。 &lt;code&gt;value&lt;/code&gt; 必须是字符串。</target>
        </trans-unit>
        <trans-unit id="bccd76edbf5bdad5646dc98c00f42c25e3b6a1a0" translate="yes" xml:space="preserve">
          <source>If one is already registered, it is replaced.</source>
          <target state="translated">如果已经注册了,就会被替换。</target>
        </trans-unit>
        <trans-unit id="6d6821d80cd7273e1c9f60ea9b9bf87af913648b" translate="yes" xml:space="preserve">
          <source>If one is not registered, returns the word appended with an &quot;s&quot;.</source>
          <target state="translated">如果没有注册,则返回带 &quot;s &quot;后缀的单词。</target>
        </trans-unit>
        <trans-unit id="2a2ad82fe5366a9ffae6d450da5ae29fe95a85f3" translate="yes" xml:space="preserve">
          <source>If options are provided, the result will be &lt;code&gt;{:ok, pid}&lt;/code&gt;, returning the IO device created. The option &lt;code&gt;:capture_prompt&lt;/code&gt;, when set to &lt;code&gt;true&lt;/code&gt;, causes prompts (which are specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) to be included in the device's output.</source>
          <target state="translated">如果提供了选项，则结果为 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，返回创建的IO设备。选项 &lt;code&gt;:capture_prompt&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，会导致提示（指定为 &lt;code&gt;IO.get*&lt;/code&gt; 函数的参数）包含在设备的输出中。</target>
        </trans-unit>
        <trans-unit id="3b66a164bf9c0ed9cfb3107b0900a5b27ed87c86" translate="yes" xml:space="preserve">
          <source>If part of a supervision tree, a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</source>
          <target state="translated">如果属于监督树，则关闭该树时，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;会收到退出信号。退出信号基于儿童规范中的关闭策略，该值可以是：</target>
        </trans-unit>
        <trans-unit id="2c9a282865b6fe4119e199b1b0847cbb6040e103" translate="yes" xml:space="preserve">
          <source>If present, invoke the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在，则调用可选的回调&lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f857961c6609ab2fd7dcb4f431f75616d71eb634" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt;; when the binary cannot be coerced into a valid float, the atom &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt; 形式的元组；当二进制文件不能强制转换为有效的float时，将返回atom &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b120927e219fe332092528639b692b8090eba7eb" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt;. Otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果成功，则以 &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt; 的形式返回一个元组。否则 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b18774208db640d57cda0a230752786cd8f12b4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no child specification for the given child ID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果没有给定子ID的子规范，则此函数返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f06ad98d27407a8302c766c4bf1a51ac8c90c4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no process with the given PID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果没有使用给定PID的进程，则此函数返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b49684fdd544a95c54cc6ece8ce5787754e9bca3" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果未找到 &lt;code&gt;child_id&lt;/code&gt; ，或者当前进程正在运行或正在重新启动，则此函数可能返回带有适当错误元组的错误。</target>
        </trans-unit>
        <trans-unit id="94de3ea42072866e8652cd6fca38378bad81898f" translate="yes" xml:space="preserve">
          <source>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</source>
          <target state="translated">如果这样的链接已经存在,这个函数什么也不做,因为两个给定的进程之间只能有一个链接。如果一个进程试图创建一个与自己的链接,则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="82ad4a438a65f14d6cc2e31d27dc219d76d8743c" translate="yes" xml:space="preserve">
          <source>If such a tuple is not found, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">如果找不到这样的元组，则将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="481e39df28a67eb2b33dd5d88bf3b6bd30ab02a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback fails with &lt;code&gt;reason&lt;/code&gt;, this function returns &lt;code&gt;{:error, reason}&lt;/code&gt;. Otherwise, if it returns &lt;code&gt;{:stop, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;{:error, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">如果&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调由于 &lt;code&gt;reason&lt;/code&gt; 失败，则此函数返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。否则，如果返回 &lt;code&gt;{:stop, reason}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; ，则进程终止，此函数分别返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbcf489afc8a98baffdf14a35b5948b139352b97" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback returns &lt;code&gt;:ignore&lt;/code&gt;, this function returns &lt;code&gt;:ignore&lt;/code&gt; as well and the supervisor terminates with reason &lt;code&gt;:normal&lt;/code&gt;. If it fails or returns an incorrect value, this function returns &lt;code&gt;{:error, term}&lt;/code&gt; where &lt;code&gt;term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调返回 &lt;code&gt;:ignore&lt;/code&gt; ，则此函数也返回 &lt;code&gt;:ignore&lt;/code&gt; ，并且主管终止于原因 &lt;code&gt;:normal&lt;/code&gt; 。如果失败或返回不正确的值，则此函数返回 &lt;code&gt;{:error, term}&lt;/code&gt; ，其中 &lt;code&gt;term&lt;/code&gt; 是具有有关错误信息的术语，而主管则以原因 &lt;code&gt;term&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="71d6d6b5b64b37312988e1b6e5df55a665e7fb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; receives an exit signal (that is not &lt;code&gt;:normal&lt;/code&gt;) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. Note that a process does &lt;em&gt;NOT&lt;/em&gt; trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</source>
          <target state="translated">如果&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;在未捕获退出时从任何进程接收到退出信号（不是 &lt;code&gt;:normal&lt;/code&gt; ），则它将以相同的原因突然退出，因此不要调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。请注意，一个过程确实&lt;em&gt;NOT&lt;/em&gt;默认陷阱退出，并且当链接的过程退出或它的节点断开发送一个退出信号。</target>
        </trans-unit>
        <trans-unit id="f3eabf6d5616bb794992bd7e46ea46c1c3f02463" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:capture_prompt&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, prompts (specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) are captured in the output.</source>
          <target state="translated">如果 &lt;code&gt;:capture_prompt&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则在输出中捕获提示（指定为 &lt;code&gt;IO.get*&lt;/code&gt; 函数的参数）。</target>
        </trans-unit>
        <trans-unit id="e863cbc73eabe13e90d2206b9738ad4d5bc8e2e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:debug&lt;/code&gt; option is present, the corresponding function in the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; will be invoked.</source>
          <target state="translated">如果存在 &lt;code&gt;:debug&lt;/code&gt; 选项，则将调用&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块中&lt;/a&gt;的相应功能。</target>
        </trans-unit>
        <trans-unit id="0cc9742b5fac276e3c5db68eba998892b5d16666" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;:spawn_opt&lt;/code&gt; 选项，则其值将作为选项传递给基础进程，如&lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; 所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a17a9b3957177b112bf526bb40068d405551156b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:timeout&lt;/code&gt; option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;:timeout&lt;/code&gt; 选项，则允许该代理最多花费给定的毫秒数进行初始化，否则它将终止，并且启动功能将返回 &lt;code&gt;{:error, :timeout}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14ac11fca560d2d149b007098ce38791dba90a1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;Foo.Bar&lt;/code&gt; 模块移动到其他地方，则需要将 &lt;code&gt;Foo&lt;/code&gt; 模块中对 &lt;code&gt;Bar&lt;/code&gt; 的引用更新为完全限定的名称（ &lt;code&gt;Foo.Bar&lt;/code&gt; ），或者必须在 &lt;code&gt;Foo&lt;/code&gt; 模块的帮助下显式设置别名。&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a6368961da467df03a853267f8beaa74f1276b2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; is not loaded, the application will first be loaded using &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt;. Any included application, defined in the &lt;code&gt;:included_applications&lt;/code&gt; key of the &lt;code&gt;.app&lt;/code&gt; file will also be loaded, but they won't be started.</source>
          <target state="translated">如果 &lt;code&gt;app&lt;/code&gt; 没有被加载，则应用程序将首先使用加载&lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;.app&lt;/code&gt; 文件的 &lt;code&gt;:included_applications&lt;/code&gt; 项中定义的所有包含的应用程序也将被加载，但不会启动。</target>
        </trans-unit>
        <trans-unit id="0c322faf190500e641ef7c48d9a94611219b9f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;debugger&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package.</source>
          <target state="translated">如果 &lt;code&gt;debugger&lt;/code&gt; 未启动，则可能发生了以下情况：一些程序包管理器默认安装没有GUI支持WX绑定的最小化Erlang。在某些软件包管理器中，您可以用更完整的软件包替换无头的Erlang（在Debian / Ubuntu / Arch上查找名为 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 的软件包）。在其他管理员中，您可能需要安装单独的 &lt;code&gt;erlang-wx&lt;/code&gt; （或类似名称）软件包。</target>
        </trans-unit>
        <trans-unit id="cbb1dfcd54340620db2a4b1be8a4677dcef95965" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;element&lt;/code&gt; occurs more than once in the &lt;code&gt;list&lt;/code&gt;, just the first occurrence is removed.</source>
          <target state="translated">如果该 &lt;code&gt;element&lt;/code&gt; 在 &lt;code&gt;list&lt;/code&gt; 出现多次，则仅删除第一次出现的元素。</target>
        </trans-unit>
        <trans-unit id="c08aca5a16d9dc35535dd8000df0a013cccceba1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, inserts the given &lt;code&gt;initial&lt;/code&gt; value.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则插入给定的 &lt;code&gt;initial&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="1b90b4077be865683040b57e9dd5a794351c1f57" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bce3fad01881435afa04eb9438e26f3f17ad50a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbc4c11a6c23bf2afb4e21b6579dc04b19c27e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;map&lt;/code&gt; unchanged.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;map&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="f3debd0c004b80e32f0db2e8ec25052d54f08cfa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回关键字列表不变。</target>
        </trans-unit>
        <trans-unit id="62f2f316a709eec98605c56cf7264dcfb2bde687" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged. Use &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; to delete just the first entry in case of duplicated keys.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回不变的关键字列表。如果键重复，则使用&lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt;仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="03691d0408ebea241da0941314a2772b60f2370b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 操作数不是正确的列表，则返回不正确的列表。如果 &lt;code&gt;left&lt;/code&gt; 操作数不是正确的列表，则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37bfbc1115f3a777b2fb554294a534e238eccc25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unescape_map/1&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt;, the char is not escaped and the backslash is kept in the string.</source>
          <target state="translated">如果 &lt;code&gt;unescape_map/1&lt;/code&gt; 函数返回 &lt;code&gt;false&lt;/code&gt; ，则不会转义char并将反斜杠保留在字符串中。</target>
        </trans-unit>
        <trans-unit id="001e53accbd81c0682a50b72be746960fd2af2c9" translate="yes" xml:space="preserve">
          <source>If the IO &lt;code&gt;device&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">如果IO &lt;code&gt;device&lt;/code&gt; 是Unicode设备，则 &lt;code&gt;count&lt;/code&gt; 意味着要检索的Unicode代码点的数量。否则， &lt;code&gt;count&lt;/code&gt; 是要检索的原始字节数。</target>
        </trans-unit>
        <trans-unit id="00f4455df1d117303f7b4dec1a8e7c59907ae6e0" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">如果尚未引用别名，则失败，并出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。它处理字符列表，二进制文件和原子。</target>
        </trans-unit>
        <trans-unit id="066a1698eac217d09441d2b5fb8b66f936f99de7" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">如果应用程序未配置回调模块，则此时开始。否则，调用其&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调。此函数返回的顶级主管的PID由运行时存储，以供以后使用，并且返回的应用程序状态也将保存（如果有）。</target>
        </trans-unit>
        <trans-unit id="df94a702176ed26ed614862093d3a9baa0557531" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">如果参数 &lt;code&gt;msg&lt;/code&gt; 是二进制文件，则使用给定参数作为消息会引发&lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="71a4ad2c3571e6dc0648a7ce18db0a118f1fca6f" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">如果使用&lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将属性标记为 &lt;code&gt;accumulate&lt;/code&gt; ，则始终返回一个列表。如果未使用 &lt;code&gt;accumulate&lt;/code&gt; 标记该属性并且未将其设置为任何值，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adaf0c8947d55853c9d373e226af8475042db2c9" translate="yes" xml:space="preserve">
          <source>If the behaviour changes or &lt;code&gt;URI.HTTP&lt;/code&gt; does not implement one of the callbacks, a warning will be raised.</source>
          <target state="translated">如果行为更改或 &lt;code&gt;URI.HTTP&lt;/code&gt; 未实现回调之一，则将发出警告。</target>
        </trans-unit>
        <trans-unit id="99a1391ef43bb72cc7d48f8ee9698b12d1d27ff4" translate="yes" xml:space="preserve">
          <source>If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the &lt;code&gt;terminate&lt;/code&gt; callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor.</source>
          <target state="translated">如果子进程没有捕获出口，它将在收到第一个出口信号后立即关闭。如果子进程正在捕获退出，则将调用 &lt;code&gt;terminate&lt;/code&gt; 回调，并且子进程必须在合理的时间间隔内终止，然后由主管突然终止。</target>
        </trans-unit>
        <trans-unit id="05268b70bba2052aa1ccd1488036cae6ea1aa300" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the PID remains set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则PID保持设置为 &lt;code&gt;:undefined&lt;/code&gt; ,并且此函数返回 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c9cb2d2a33379f64c647839b2a1ab4dbc13e8f" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the child specification is added to the supervisor, the PID is set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则将子规范添加到主管中，PID设置为 &lt;code&gt;:undefined&lt;/code&gt; ,并且此函数返回 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef45b4e1f4c05bc44ee03bd5bad1f5e5a9ba93ef" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, then no child is added to the supervision tree and this function returns &lt;code&gt;:ignore&lt;/code&gt; too.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则没有任何子级添加到监视树，并且该函数也返回 &lt;code&gt;:ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93487fcca765523c971b5da517cfe6d46d7ca27a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, the PID is added to the supervisor and this function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; 或 &lt;code&gt;{:ok, child, info}&lt;/code&gt; ，则将PID添加到主管，并且此函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="92f41de707f645e7e03c7c77ffbddced905df221" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, then child specification and PID are added to the supervisor and this function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; 或 &lt;code&gt;{:ok, child, info}&lt;/code&gt; ，则将子规范和PID添加到主管，并且此函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="8a7852d163c87ef12689fc28578feaecfcacfb9c" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，该函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; ，其中 &lt;code&gt;error&lt;/code&gt; 是一个包含有关错误和子规范的信息的术语。</target>
        </trans-unit>
        <trans-unit id="971c2677787cebeaf5076ea02ea7abe46523d9e1" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is the error or erroneous value returned from child process start function, or failure reason if it fails.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，此函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; ，其中 &lt;code&gt;error&lt;/code&gt; 是从子进程启动函数返回的错误或错误值，或失败原因（如果失败）。</target>
        </trans-unit>
        <trans-unit id="4ed3068726af85a0584fbeb7b657ccca120db122" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns &lt;code&gt;{:error, error}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则该函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e556a251ad20ce02002d9e36048516e94aeb978" translate="yes" xml:space="preserve">
          <source>If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as &lt;code&gt;:'🌢 Elixir'&lt;/code&gt;, &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt;, and &lt;code&gt;:&quot;123&quot;&lt;/code&gt;.</source>
          <target state="translated">如果冒号后面紧跟着原子名称周围的一对双引号或单引号，则该原子被认为是被引号。在具有无引号原子相反，这一个可以由任何Unicode字符（不仅字母），如 &lt;code&gt;:'🌢 Elixir'&lt;/code&gt; ， &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt; ，和 &lt;code&gt;:&quot;123&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56beff3afd9994ddacaef88c1f904aa35af05474" translate="yes" xml:space="preserve">
          <source>If the condition given to &lt;code&gt;if/2&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, the body given between &lt;code&gt;do/end&lt;/code&gt; is not executed and instead it returns &lt;code&gt;nil&lt;/code&gt;. The opposite happens with &lt;code&gt;unless/2&lt;/code&gt;.</source>
          <target state="translated">如果给 &lt;code&gt;if/2&lt;/code&gt; 的条件返回 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则不会执行在 &lt;code&gt;do/end&lt;/code&gt; 之间给出的主体，而是返回 &lt;code&gt;nil&lt;/code&gt; 。相反的情况是， &lt;code&gt;unless/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b59e29ecc1dff1755220f8555df92bd2b4fe3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果配置参数不存在，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b800c2816d5b5f752096a4e8e30fb37f2f59391" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果配置参数不存在，则该函数返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a592ffaee07d8c5f17b9ba6b9f33ed8e98c54d6f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns the &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">如果配置参数不存在，该函数将返回 &lt;code&gt;default&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8f7a6151093f7c2a971f2852905fc785857fff18" translate="yes" xml:space="preserve">
          <source>If the element does not exist, it is added to the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果该元素不存在，则将其添加到 &lt;code&gt;list&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="9a1b44730d66c61b1f7aa74b49b7cfff54912615" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;varname&lt;/code&gt; is set, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned where &lt;code&gt;value&lt;/code&gt; is a string. If &lt;code&gt;varname&lt;/code&gt; is not set, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果设置了环境变量 &lt;code&gt;varname&lt;/code&gt; ，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是一个字符串。如果未设置 &lt;code&gt;varname&lt;/code&gt; ，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea743105c28535da020399869c10ba09ded50b63" translate="yes" xml:space="preserve">
          <source>If the exception module implements the optional &lt;a href=&quot;#c:blame/2&quot;&gt;&lt;code&gt;blame/2&lt;/code&gt;&lt;/a&gt; callback, it will be invoked to perform the computation.</source>
          <target state="translated">如果异常模块实现了可选的&lt;a href=&quot;#c:blame/2&quot;&gt; &lt;code&gt;blame/2&lt;/code&gt; &lt;/a&gt;回调，则将调用它执行计算。</target>
        </trans-unit>
        <trans-unit id="6ba3395fcc44d77deb4fad259828439fe83f301c" translate="yes" xml:space="preserve">
          <source>If the exit reason is not &lt;code&gt;:normal&lt;/code&gt;, all the processes linked to the process that exited will crash (unless they are trapping exits).</source>
          <target state="translated">如果退出原因不是 &lt;code&gt;:normal&lt;/code&gt; ，则所有链接到已退出进程的进程都将崩溃（除非它们正在捕获退出）。</target>
        </trans-unit>
        <trans-unit id="69bc5d1890437acbe1c535fa849ec2779651267d" translate="yes" xml:space="preserve">
          <source>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">如果不能展开表达式,则返回表达式本身。这个函数不遍历AST,只对根节点进行展开。</target>
        </trans-unit>
        <trans-unit id="dd469ee5a62e6b5a80b7c5e501b5ee43bbcd856c" translate="yes" xml:space="preserve">
          <source>If the file does exists, and if write is not combined with read, the file will be truncated.</source>
          <target state="translated">如果文件确实存在,并且如果写与读不结合,文件将被截断。</target>
        </trans-unit>
        <trans-unit id="4a926f33aaf552a1fcd49d45cc93ae59488a7d3e" translate="yes" xml:space="preserve">
          <source>If the file has been required, it returns &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">如果需要该文件，则返回 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d5c19fb123316598a0d9b3638a762db6e8c9b35b" translate="yes" xml:space="preserve">
          <source>If the file has not been required, it returns the list of modules:</source>
          <target state="translated">如果该文件没有被要求,则返回模块列表。</target>
        </trans-unit>
        <trans-unit id="f8fd33f5966315da13c7c5967bb4b7033821bc3d" translate="yes" xml:space="preserve">
          <source>If the function does not return &lt;code&gt;true&lt;/code&gt; for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</source>
          <target state="translated">如果函数对于相等的值未返回 &lt;code&gt;true&lt;/code&gt; ，则排序不稳定，并且相等项的顺序可能会被打乱。例如：</target>
        </trans-unit>
        <trans-unit id="46872c4f6b3b3d53e570bd775f9872272859aad0" translate="yes" xml:space="preserve">
          <source>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</source>
          <target state="translated">如果正在定义的函数/宏有多个子句,则会为每个子句调用钩子。</target>
        </trans-unit>
        <trans-unit id="49c229dbf0034a08eae6f9a0c1010fd39f336907" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;context&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (by default it is), the binding for the current context is returned.</source>
          <target state="translated">如果给定 &lt;code&gt;context&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; （默认为nil），则返回当前上下文的绑定。</target>
        </trans-unit>
        <trans-unit id="6978259d37eaf03d5b3cc55b25024a1b3148e5a5" translate="yes" xml:space="preserve">
          <source>If the given function callback fails, the function returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果给定的函数回调失败，则该函数返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3af8970b7302792aa5fbcf15bf7d3816a9358c60" translate="yes" xml:space="preserve">
          <source>If the given project configuration does not identify an umbrella project, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">如果给定的项目配置未标识总体项目，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46533ec867c9435d899cb6828abb727c8f1630e2" translate="yes" xml:space="preserve">
          <source>If the given project configuration identifies an umbrella project, the return value is a map of &lt;code&gt;app =&amp;gt; path&lt;/code&gt; where &lt;code&gt;app&lt;/code&gt; is a child app of the umbrella and &lt;code&gt;path&lt;/code&gt; is its path relative to the root of the umbrella project.</source>
          <target state="translated">如果给定的项目配置标识了伞项目，则返回值是 &lt;code&gt;app =&amp;gt; path&lt;/code&gt; 的映射，其中 &lt;code&gt;app&lt;/code&gt; 是伞的子应用，而 &lt;code&gt;path&lt;/code&gt; 是相对于伞项目根的路径。</target>
        </trans-unit>
        <trans-unit id="1a1e4f0e379f9bd60165b52c832ccce09165194e" translate="yes" xml:space="preserve">
          <source>If the given string is empty, an empty list is returned.</source>
          <target state="translated">如果给定的字符串为空,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="b5fa7671aa9ac1c4f631b6b91cdd66f8be6d72c5" translate="yes" xml:space="preserve">
          <source>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</source>
          <target state="translated">如果最后一个参数是一个数据结构,比如地图和列表,而且数据结构的开头与函数调用适合在同一行,那么就不会发生缩进,这就允许这样的代码。</target>
        </trans-unit>
        <trans-unit id="78f6031137384aa25684e5873b8f78717fddd500" translate="yes" xml:space="preserve">
          <source>If the last chunk does not have &lt;code&gt;count&lt;/code&gt; elements to fill the chunk, elements are taken from &lt;code&gt;leftover&lt;/code&gt; to fill in the chunk. If &lt;code&gt;leftover&lt;/code&gt; does not have enough elements to fill the chunk, then a partial chunk is returned with less than &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果最后一块没有 &lt;code&gt;count&lt;/code&gt; 元素来填充该块，则从 &lt;code&gt;leftover&lt;/code&gt; 部分中取出元素以填充该块。如果 &lt;code&gt;leftover&lt;/code&gt; 元素不足以填满该块，则将返回部分块，其中包含少于 &lt;code&gt;count&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="6d2f647fee30ac3b21a14f06f704594c6fc607f3" translate="yes" xml:space="preserve">
          <source>If the matching entry points to the node evaluating the request, then we&amp;rsquo;ve finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we&amp;rsquo;ll pass the request to this node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.</source>
          <target state="translated">如果匹配的条目指向评估请求的节点，则表明路由已完成，并且该节点将执行请求的操作。如果匹配的条目指向另一个节点，则将请求传递给该节点，该节点将查看其自己的路由表（可能与第一个节点中的路由表不同）并采取相应的措施。如果没有条目匹配，将引发错误。</target>
        </trans-unit>
        <trans-unit id="52158ebe3b1b3c65fb9901ffb1a952d081b6bc67" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this functions returns &lt;code&gt;{:error, :nofile}&lt;/code&gt;.</source>
          <target state="translated">如果正在检查的模块当前处于编译器死锁中，则此函数返回 &lt;code&gt;{:error, :nofile}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4057f0905e6629307a032b9c000b6e956f9d35d4" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</source>
          <target state="translated">如果模块已经被加载,它就会以no-op的方式工作,如果模块还没有被加载,它就会检查是否需要先编译,然后再尝试加载。如果模块还没有加载,它检查是否需要先编译,然后再尝试加载。</target>
        </trans-unit>
        <trans-unit id="e5e8ed6a3a6371fcd484a0f8c9f4271b4ee45925" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</source>
          <target state="translated">如果模块已经被加载,这将作为no-op工作。如果模块还没有加载,则尝试加载它。</target>
        </trans-unit>
        <trans-unit id="a53b9d6b0418ab1b2e4ace2c2f0d58e6dbe324b3" translate="yes" xml:space="preserve">
          <source>If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">如果未安装该模块，或者给定的函数没有断点，则为无操作，并返回 &lt;code&gt;:not_found&lt;/code&gt; 。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3287b87c75de3c7f69ccf215597988b7b4d5d83" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">如果要在其上调用函数的模块有一个长名称，例如 &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; ，并且发现它很冗长，则可以利用&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;特殊形式并将模块仍称为 &lt;code&gt;MyLib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80bfedd28d224208419788d64b48145856d28f2e" translate="yes" xml:space="preserve">
          <source>If the normalized &lt;code&gt;index_range.first&lt;/code&gt; is out of bounds of the given &lt;code&gt;enumerable&lt;/code&gt;, or this one is greater than the normalized &lt;code&gt;index_range.last&lt;/code&gt;, then &lt;code&gt;[]&lt;/code&gt; is returned.</source>
          <target state="translated">如果规范化的 &lt;code&gt;index_range.first&lt;/code&gt; 超出给定的 &lt;code&gt;enumerable&lt;/code&gt; 的范围，或者该值大于规范化的 &lt;code&gt;index_range.last&lt;/code&gt; ，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08e33554a9805c7015a58e968e41eb7b15679006" translate="yes" xml:space="preserve">
          <source>If the number is equidistant to the two nearest integers, rounds away from zero.</source>
          <target state="translated">如果数字与最接近的两个整数等距,则从零开始舍去。</target>
        </trans-unit>
        <trans-unit id="1ada57e8ed2825b579416e3a51bc87db286561fd" translate="yes" xml:space="preserve">
          <source>If the offset is greater than string length, then it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果偏移量大于字符串长度，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;:pop&lt;/code&gt; ，则此回调的返回值必须为 &lt;code&gt;{value, new_data}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;key&lt;/code&gt; 下的值（如果不存在，则为 &lt;code&gt;nil&lt;/code&gt; ），而 &lt;code&gt;new_data&lt;/code&gt; 是没有 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; ，则此回调的返回值应为 &lt;code&gt;{get_value, new_data}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="f3dea051cec0438020d90f4862f83ccd43c6add8" translate="yes" xml:space="preserve">
          <source>If the path given to &lt;code&gt;File.read/1&lt;/code&gt; exists, it returns a tuple with the atom &lt;code&gt;:ok&lt;/code&gt; as the first element and the file contents as the second. Otherwise, it returns a tuple with &lt;code&gt;:error&lt;/code&gt; and the error description.</source>
          <target state="translated">如果给定 &lt;code&gt;File.read/1&lt;/code&gt; 的路径存在，它将返回一个以原子 &lt;code&gt;:ok&lt;/code&gt; 作为第一个元素，而将文件内容作为第二个元素的元组。否则，它将返回带有 &lt;code&gt;:error&lt;/code&gt; 和错误描述的元组。</target>
        </trans-unit>
        <trans-unit id="53bd7b87b61d322c4fd45f7642221fa6272a8869" translate="yes" xml:space="preserve">
          <source>If the path is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored.</source>
          <target state="translated">如果该路径已经是绝对路径，则将忽略 &lt;code&gt;relative_to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4146f9776d17822883d0a24f1d05b48694b8cdc9" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly (be it by failing or providing a sane default).</source>
          <target state="translated">如果调用该函数之前的先前值为 &lt;code&gt;nil&lt;/code&gt; ，则该函数&lt;em&gt;将&lt;/em&gt;接收 &lt;code&gt;nil&lt;/code&gt; 作为值，并且必须进行相应处理（通过失败或提供合理的默认值）。</target>
        </trans-unit>
        <trans-unit id="4dbd652e27d03f3eda58f1454adbcc277b1cf2a2" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly.</source>
          <target state="translated">如果调用该函数之前的前一个值为 &lt;code&gt;nil&lt;/code&gt; ，则该函数&lt;em&gt;将&lt;/em&gt;接收 &lt;code&gt;nil&lt;/code&gt; 作为值，并且必须进行相应处理。</target>
        </trans-unit>
        <trans-unit id="c374c88228928cded93b273d043b81d7a9e4db50" translate="yes" xml:space="preserve">
          <source>If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then &lt;code&gt;handle_info/2&lt;/code&gt; will be called with &lt;code&gt;:timeout&lt;/code&gt; as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout.</source>
          <target state="translated">如果在设置超时时进程没有等待消息，并且经过指定的毫秒数而没有消息到达，则将以 &lt;code&gt;:timeout&lt;/code&gt; 作为第一个参数来调用 &lt;code&gt;handle_info/2&lt;/code&gt; 。如果有任何消息正在等待或在给定超时之前到达，则清除超时。</target>
        </trans-unit>
        <trans-unit id="029b68fe64722c4e17e93dd0458f45ae756acd0b" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;pid&lt;/code&gt; is alive (that is, it's not exiting and has not exited yet) than this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;pid&lt;/code&gt; 标识的进程仍处于活动状态（也就是说，它尚未退出并且尚未退出），则此函数将返回 &lt;code&gt;true&lt;/code&gt; 。否则，它返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69f0fc29573a8d218a644c814446337651d8b2a1" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">如果在调用&lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;时进程已死，则立即发送 &lt;code&gt;:DOWN&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="25b64d8d09022ae8fa6be42d0e689d9f55f93a0d" translate="yes" xml:space="preserve">
          <source>If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed.</source>
          <target state="translated">如果登记处有重复的键,则允许在同一键下从当前进程进行多次登记。</target>
        </trans-unit>
        <trans-unit id="296325dc97cde1334962459eb9c5ec5273a16093" translate="yes" xml:space="preserve">
          <source>If the registry has unique keys, it will return &lt;code&gt;{:ok, owner}&lt;/code&gt; unless the key is already associated to a PID, in which case it returns &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt;.</source>
          <target state="translated">如果注册表具有唯一键，除非键已经与PID关联，否则它将返回 &lt;code&gt;{:ok, owner}&lt;/code&gt; ，在这种情况下，它将返回 &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86406b94fdf6d0355c113c51cd4e50d8ab966009" translate="yes" xml:space="preserve">
          <source>If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and &lt;code&gt;parallel: true&lt;/code&gt; is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition.</source>
          <target state="translated">如果注册表已分区，则每个分区将多次调用该回调。如果注册表是分区且 &lt;code&gt;parallel: true&lt;/code&gt; 作为选项提供，则调度是并行进行的。在这两种情况下，仅当该分区有条目时才调用回调。</target>
        </trans-unit>
        <trans-unit id="ee4f792d4247d36f7519cbe4df3f7c9194b0d6d3" translate="yes" xml:space="preserve">
          <source>If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry.</source>
          <target state="translated">如果登记处是唯一的,则键是唯一的。否则,如果进程多次在同一键下注册,它们可能包含重复。如果进程已死或在该注册表中没有键,则列表为空。</target>
        </trans-unit>
        <trans-unit id="cc9c622905709241fd4a039cba6efcb68b163916" translate="yes" xml:space="preserve">
          <source>If the repository is private though, you may need to specify the private URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt;. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.</source>
          <target state="translated">如果存储库是私有的，则可能需要指定私有URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt; 。无论如何，只要您具有适当的凭据，Mix就能为您获取它。</target>
        </trans-unit>
        <trans-unit id="8f88ca4263ab5c36582e4eb171ede7757f5a8977" translate="yes" xml:space="preserve">
          <source>If the running process terminates, a new IEx session is started.</source>
          <target state="translated">如果正在运行的进程终止,则会启动一个新的 IEx 会话。</target>
        </trans-unit>
        <trans-unit id="85e3fc96a9666ea6c8e81e1cf2be2da940abf807" translate="yes" xml:space="preserve">
          <source>If the same key is set via &lt;code&gt;@tag&lt;/code&gt;, the &lt;code&gt;@tag&lt;/code&gt; value has higher precedence.</source>
          <target state="translated">如果通过 &lt;code&gt;@tag&lt;/code&gt; 设置了相同的键，则 &lt;code&gt;@tag&lt;/code&gt; 值具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="c381bd34f0f516da0adf5a6559d1022816298c76" translate="yes" xml:space="preserve">
          <source>If the scheme is unknown to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module, this function returns &lt;code&gt;nil&lt;/code&gt;. The default port for any scheme can be configured globally via &lt;a href=&quot;#default_port/2&quot;&gt;&lt;code&gt;default_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;模块不知道该方案，则此函数返回 &lt;code&gt;nil&lt;/code&gt; 。可以通过&lt;a href=&quot;#default_port/2&quot;&gt; &lt;code&gt;default_port/2&lt;/code&gt; &lt;/a&gt;全局配置任何方案的默认端口。</target>
        </trans-unit>
        <trans-unit id="1cf20abb00a9c7eb91eeec27cb0a3c2044ccf845" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, the function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If an agent with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">如果成功创建和初始化服务器，则该函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是服务器的PID。如果已经存在具有指定名称的代理，则该函数将使用该进程的PID 返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ae18b173fd4f257f191d68374b82b3609576f9a" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If a process with the specified server name already exists, this function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">如果成功创建和初始化服务器，则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是服务器的PID。如果已经存在具有指定服务器名称的进程，则此函数将返回带有该进程的PID的 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c79dacc73fa9835dcb970cb3bd153402ac7a2c0" translate="yes" xml:space="preserve">
          <source>If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:</source>
          <target state="translated">如果标示字母是大写的,则标示中不允许插值,否则其内容可能是动态的。比较下面的符码结果,以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="f0d8fa47818ba024a0ca6635125390659b191c06" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果浮体的大小超过最大大小 &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; ，所述&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="1f18c5146917295cd360116e64980d6814f74742" translate="yes" xml:space="preserve">
          <source>If the source is a file, it copies &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;. If the &lt;code&gt;source&lt;/code&gt; is a directory, it copies the contents inside source into the &lt;code&gt;destination&lt;/code&gt; directory.</source>
          <target state="translated">如果源是文件，它将 &lt;code&gt;source&lt;/code&gt; 复制到 &lt;code&gt;destination&lt;/code&gt; 。如果 &lt;code&gt;source&lt;/code&gt; 是目录，它将源内部的内容复制到 &lt;code&gt;destination&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="d79c1221466668c8f2fb37f46a9b0c4eff50c912" translate="yes" xml:space="preserve">
          <source>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason &lt;code&gt;:shutdown&lt;/code&gt; all the child processes that have already been started, and then terminates itself and returns &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt;.</source>
          <target state="translated">如果任何子进程的启动功能失败或返回错误的元组或错误的值，则主管首先以以下原因终止 &lt;code&gt;:shutdown&lt;/code&gt; 所有已启动的子进程，然后终止自身并返回 &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95311d242d980eca3e042ab39a6d275172dd2491" translate="yes" xml:space="preserve">
          <source>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果范围的开头不是给定字符串的有效偏移量，或者范围的顺序相反，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdd805e8128eab933d8276c52b9cb625ab5fad9b" translate="yes" xml:space="preserve">
          <source>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</source>
          <target state="translated">如果范围的开始或结束是负数,则首先遍历整个字符串,以便将负数指数转换为正数。</target>
        </trans-unit>
        <trans-unit id="fa648af6a9f14eed70d03b7bbaf8c1091284802b" translate="yes" xml:space="preserve">
          <source>If the supervisor already has N children in a way that N exceeds the amount of &lt;code&gt;:max_children&lt;/code&gt; set on the supervisor initialization (see &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;), then this function returns &lt;code&gt;{:error, :max_children}&lt;/code&gt;.</source>
          <target state="translated">如果管理者已经有N &lt;code&gt;:max_children&lt;/code&gt; ，而N超过了管理者初始化上设置的：max_children的数量（请参阅&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;），则此函数返回 &lt;code&gt;{:error, :max_children}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab3a50abd31e0fe599ff965258406372848105a0" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully spawned (if the start function of each child process returns &lt;code&gt;{:ok, child}&lt;/code&gt;, &lt;code&gt;{:ok, child, info}&lt;/code&gt;, or &lt;code&gt;:ignore&lt;/code&gt;) this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">如果成功生成了主管及其子进程（如果每个子进程的start函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; ， &lt;code&gt;{:ok, child, info}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; ），则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是主管的PID。如果为主管指定了一个名称，并且已经存在具有指定名称的进程，则该函数将返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是该进程的PID。</target>
        </trans-unit>
        <trans-unit id="ba930cdc55e703dfc4d9bcd1944d94e721ba5186" translate="yes" xml:space="preserve">
          <source>If the supervisor is successfully spawned, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">如果成功生成了超级用户，则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是超级用户的PID。如果为主管指定了名称，并且已经存在具有指定名称的进程，则该函数将返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是该进程的PID。</target>
        </trans-unit>
        <trans-unit id="e53af2f1716d98281bb0f2f71d348e2e0b0ca4dd" translate="yes" xml:space="preserve">
          <source>If the task or alias were already invoked, it does not run them again and simply aborts with &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">如果任务或别名已被调用，则不会再次运行它们，而只是通过 &lt;code&gt;:noop&lt;/code&gt; 中止。</target>
        </trans-unit>
        <trans-unit id="bdd5aaa87ae18322d70f284e647adedce16eae03" translate="yes" xml:space="preserve">
          <source>If the task was not yet invoked, it runs the task and returns the result.</source>
          <target state="translated">如果任务尚未被调用,则运行任务并返回结果。</target>
        </trans-unit>
        <trans-unit id="1ffe14eba0b86eb2256ef62d3f747347750fc072" translate="yes" xml:space="preserve">
          <source>If the terms compare equal, the first one is returned.</source>
          <target state="translated">如果比较条件相同,则返回第一个条件。</target>
        </trans-unit>
        <trans-unit id="76f5c2bf2f306f61b2cf3e6037db4001b825a0db" translate="yes" xml:space="preserve">
          <source>If the use case where you were using GenEvent requires more complex logic, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用GenEvent的用例需要更复杂的逻辑，则&lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt;提供了一个很好的选择。GenStage是Elixir团队维护的外部Elixir库。它提供了一种工具，用于实施以需求驱动方式交换事件的系统以及对背压的内置支持。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f3ba34b6884281919234bd65a5c27e05d943121" translate="yes" xml:space="preserve">
          <source>If there are duplicated keys, they are all removed and only the first one is updated.</source>
          <target state="translated">如果有重复的键,则全部删除,只更新第一个键。</target>
        </trans-unit>
        <trans-unit id="4cc5164cbf429134f06fc3a42dc1c775490799c5" translate="yes" xml:space="preserve">
          <source>If there are no errors, returns a &lt;code&gt;{parsed, rest}&lt;/code&gt; tuple where:</source>
          <target state="translated">如果没有错误，则返回一个 &lt;code&gt;{parsed, rest}&lt;/code&gt; 元组，其中：</target>
        </trans-unit>
        <trans-unit id="5f562d79d2233001e164c67b307f491a4295de9f" translate="yes" xml:space="preserve">
          <source>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</source>
          <target state="translated">如果括号周围没有换行,那么格式化器会尝试将所有内容放在一行中,比如下面的代码段</target>
        </trans-unit>
        <trans-unit id="8e379b9421d0be8405c193a1a3a55eda70ffe92a" translate="yes" xml:space="preserve">
          <source>If there is an alias with the same name, the alias will be invoked instead of the original task.</source>
          <target state="translated">如果有同名的别名,则会调用该别名代替原来的任务。</target>
        </trans-unit>
        <trans-unit id="742d780da366c9749e094a3e2601e05af9f19b1c" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">如果有兴趣在本地注册动态名称，请不要使用原子，因为原子绝不会被垃圾收集，因此动态生成的原子将不会被垃圾收集。在这种情况下，您可以使用&lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;模块来设置自己的本地注册表。</target>
        </trans-unit>
        <trans-unit id="1e0688b7a0e6bd6041bf3e04042b749415e0032c" translate="yes" xml:space="preserve">
          <source>If there is no current project, &lt;code&gt;nil&lt;/code&gt; is returned. This may happen in cases there is no &lt;code&gt;mix.exs&lt;/code&gt; in the current directory.</source>
          <target state="translated">如果没有当前项目，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果当前目录中没有 &lt;code&gt;mix.exs&lt;/code&gt; ，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="c639ca5dfec4193385c0f9daeb2b1d4be710cc52" translate="yes" xml:space="preserve">
          <source>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</source>
          <target state="translated">如果邮箱中没有与任何模式匹配的消息,当前进程将等待匹配的消息到达。也可以指定一个超时时间。</target>
        </trans-unit>
        <trans-unit id="8408450afd5b2f3e9042d1b8c13e9f58240f928f" translate="yes" xml:space="preserve">
          <source>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</source>
          <target state="translated">如果没有定义项目,它仍然返回一个带有默认值的关键字列表。这使得许多Mix任务可以在不需要底层项目的情况下工作。</target>
        </trans-unit>
        <trans-unit id="6b4a62bcf57109f5efa07a74f29988033109640c" translate="yes" xml:space="preserve">
          <source>If there is no such link, this function does nothing. If &lt;code&gt;pid_or_port&lt;/code&gt; does not exist, this function does not produce any errors and simply does nothing.</source>
          <target state="translated">如果没有这样的链接，则此功能不执行任何操作。如果 &lt;code&gt;pid_or_port&lt;/code&gt; 不存在，则此函数不会产生任何错误，并且只会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="690bb679a1fa855e4e7e99b242998643c82b454f" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, the a tuple with &lt;code&gt;:single&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">如果提供的 &lt;code&gt;datetime&lt;/code&gt; 只有一个可能的时间段，则返回带有 &lt;code&gt;:single&lt;/code&gt; 和 &lt;code&gt;time_zone_period&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="f87cf65c1843c87f5a9fb595853f1c2faf34fb20" translate="yes" xml:space="preserve">
          <source>If this function receives a binary, the same binary is returned.</source>
          <target state="translated">如果该函数接收到一个二进制,则返回相同的二进制。</target>
        </trans-unit>
        <trans-unit id="722410509d91a2ea35d8481e8dcb2edd1a9471e8" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;task#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;task#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt;，请使用Task.start / 1或考虑使用 &lt;code&gt;async_nolink&lt;/code&gt; 或 &lt;code&gt;start_child&lt;/code&gt; 在&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;下启动任务。</target>
        </trans-unit>
        <trans-unit id="885b568a39d2f2144bcbdbe9f088220630bb0f55" translate="yes" xml:space="preserve">
          <source>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</source>
          <target state="translated">如果不满足这些条件,行为是未定义的(在Erlang/OTP 21和更早的版本上)或将引发(在Erlang/OTP 22和更早的版本上)。</target>
        </trans-unit>
        <trans-unit id="c532c9eeb04daa8871cfe8c245158904c23d03c5" translate="yes" xml:space="preserve">
          <source>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">如果两个日历不兼容,我们只能在它们之间转换日期和时间。如果它们是兼容的,这意味着我们也可以在它们之间转换日期和天真的日期时间。</target>
        </trans-unit>
        <trans-unit id="6230d8e63d2f6528e6ac7ed7bd4bbeed089d2da9" translate="yes" xml:space="preserve">
          <source>If two modules &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are imported and they both contain a &lt;code&gt;foo&lt;/code&gt; function with an arity of &lt;code&gt;1&lt;/code&gt;, an error is only emitted if an ambiguous call to &lt;code&gt;foo/1&lt;/code&gt; is actually made; that is, the errors are emitted lazily, not eagerly.</source>
          <target state="translated">如果导入了两个模块 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，并且它们都包含Arity为 &lt;code&gt;1&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 函数，则仅当实际上对 &lt;code&gt;foo/1&lt;/code&gt; 进行了模棱两可的调用时，才会发出错误；也就是说，错误是懒惰而不是急于发出的。</target>
        </trans-unit>
        <trans-unit id="55cdfd10bc87ea7561c4ad8cc479f9faf3b27132" translate="yes" xml:space="preserve">
          <source>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</source>
          <target state="translated">如果有大写字母,作为保留缩略语的机制,它们不作任何修改。</target>
        </trans-unit>
        <trans-unit id="1343958b023308460ee2f6f5daf43ba1fb660edd" translate="yes" xml:space="preserve">
          <source>If we save the code above in a file named &amp;ldquo;concat.ex&amp;rdquo; and compile it, Elixir will emit the following warning:</source>
          <target state="translated">如果将上面的代码保存在名为&amp;ldquo; concat.ex&amp;rdquo;的文件中并进行编译，Elixir将发出以下警告：</target>
        </trans-unit>
        <trans-unit id="8fc6b97491613a1b35780efb44cacd0f0d9099d1" translate="yes" xml:space="preserve">
          <source>If we start our server, we can now send commands to it. For now, we will get two different responses: &amp;ldquo;OK&amp;rdquo; when the command is known and &amp;ldquo;UNKNOWN COMMAND&amp;rdquo; otherwise:</source>
          <target state="translated">如果启动服务器，我们现在可以向其发送命令。现在，我们将获得两种不同的响应：知道命令后为&amp;ldquo; OK&amp;rdquo;，否则为&amp;ldquo; UNKNOWN COMMAND&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="74591893e85cc364e81b230bedab46ae114fe665" translate="yes" xml:space="preserve">
          <source>If we try to dispatch to &lt;code&gt;Hello.world&lt;/code&gt;, it won't be available as it was defined only in the other shell:</source>
          <target state="translated">如果我们尝试分派到 &lt;code&gt;Hello.world&lt;/code&gt; ，则它将仅在另一个shell中定义，因此将不可用：</target>
        </trans-unit>
        <trans-unit id="51c60bac3d7f07a69c2caf5416fb9b2fa0580339" translate="yes" xml:space="preserve">
          <source>If we use chardata instead, it will work as expected:</source>
          <target state="translated">如果我们使用chardata来代替,它将按照预期的方式工作。</target>
        </trans-unit>
        <trans-unit id="5c38beec4d9e8627a3718fd3acf1efdd27ca154a" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;code&gt;:into&lt;/code&gt;, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</source>
          <target state="translated">如果要使用 &lt;code&gt;:into&lt;/code&gt; ，则需要一个数据类型，该数据类型可以计算每个元素包含的频率。尽管Elixir中没有此类数据类型，但您可以自己实现一个。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
