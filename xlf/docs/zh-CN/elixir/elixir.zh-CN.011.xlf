<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="814c5f11fc85ecacb301d5d1ff7a5207b63cc546" translate="yes" xml:space="preserve">
          <source>Starts monitoring the given &lt;code&gt;port&lt;/code&gt; from the calling process.</source>
          <target state="translated">从调用过程开始监视给定的 &lt;code&gt;port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32f7fdf8c34390c9e691d76ef8c0ec7bd0d81af7" translate="yes" xml:space="preserve">
          <source>Starts the current application and runs code.</source>
          <target state="translated">启动当前应用程序并运行代码。</target>
        </trans-unit>
        <trans-unit id="465701ca429a2dfabc3bc5f01a8bd60e3b9231c7" translate="yes" xml:space="preserve">
          <source>Starts the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">启动给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2271caeb4b7d5b3c207dd94c7b7c318ed2188f2" translate="yes" xml:space="preserve">
          <source>Starts the registry as a supervisor process.</source>
          <target state="translated">作为主管进程启动登记处。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="a04227ba1319a1fad4347603729d051498bac906" translate="yes" xml:space="preserve">
          <source>Static code analysis</source>
          <target state="translated">静态代码分析</target>
        </trans-unit>
        <trans-unit id="cdde4f20ba31a24db2cc7ae71135c8353631907b" translate="yes" xml:space="preserve">
          <source>Steps</source>
          <target state="translated">Steps</target>
        </trans-unit>
        <trans-unit id="a62a6d902db47855d8f77112868e3787eabbca53" translate="yes" xml:space="preserve">
          <source>Stopping an application with a callback module has three steps:</source>
          <target state="translated">使用回调模块停止应用程序有三个步骤。</target>
        </trans-unit>
        <trans-unit id="3753ad0cdb9c49b6498a88fe4f4514a2b9b36ece" translate="yes" xml:space="preserve">
          <source>Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op.</source>
          <target state="translated">在没有回调模块的情况下停止应用程序是有定义的,但除了一些系统跟踪外,实际上是没有操作的。</target>
        </trans-unit>
        <trans-unit id="d5b2d506e52eb47a1075dbad242127c01e521df7" translate="yes" xml:space="preserve">
          <source>Stopping applications</source>
          <target state="translated">停止申请</target>
        </trans-unit>
        <trans-unit id="16d9ee2c7e28df63e19079e90e7824e30d92fc9f" translate="yes" xml:space="preserve">
          <source>Stops a child process started via &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">停止通过&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt;启动的子进程。</target>
        </trans-unit>
        <trans-unit id="1d836dc29fd66efd06619857a7f3fbdbb2570615" translate="yes" xml:space="preserve">
          <source>Stops the IO device and returns the remaining input/output buffers.</source>
          <target state="translated">停止IO设备并返回剩余的输入/输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="420cba62897b963528b14026eceb60569ceedeae" translate="yes" xml:space="preserve">
          <source>Stops the execution of the calling process with the given reason.</source>
          <target state="translated">用给定的理由停止调用过程的执行。</target>
        </trans-unit>
        <trans-unit id="1b87ddfd2f0a1efe1c63c07d6457515d241e5a11" translate="yes" xml:space="preserve">
          <source>Stops the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">停止给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e5206ef2f4946342c59fa2df527c82ea74eb890" translate="yes" xml:space="preserve">
          <source>Stores a compilation option.</source>
          <target state="translated">存储一个编译选项。</target>
        </trans-unit>
        <trans-unit id="5e57817ff2a6b8e48e8d562b55890d766e0aa874" translate="yes" xml:space="preserve">
          <source>Stores all given compilation options.</source>
          <target state="translated">存储所有给定的编译选项。</target>
        </trans-unit>
        <trans-unit id="7a8ca646fdc158d3d531a0223dadbec6991917ca" translate="yes" xml:space="preserve">
          <source>Stores registry metadata.</source>
          <target state="translated">存储注册表元数据。</target>
        </trans-unit>
        <trans-unit id="486a63f10cb978abccfbd8ecf134b1efae0f41f9" translate="yes" xml:space="preserve">
          <source>Stores the given &lt;code&gt;key&lt;/code&gt;-&lt;code&gt;value&lt;/code&gt; pair in the process dictionary.</source>
          <target state="translated">将给定的 &lt;code&gt;key&lt;/code&gt; - &lt;code&gt;value&lt;/code&gt; 对存储在过程字典中。</target>
        </trans-unit>
        <trans-unit id="3a40588dab874cb0f15e4d524b5977f1cc44faf9" translate="yes" xml:space="preserve">
          <source>Storing information with attributes</source>
          <target state="translated">存储信息的属性</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="32937312f1205a985f371273166b0a08620a94b4" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">流是可组合的，惰性的可枚举的（有关可枚举的介绍，请参见&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块）。在枚举过程中一一生成元素的任何可枚举称为流。例如，Elixir的&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;是一个流：</target>
        </trans-unit>
        <trans-unit id="9c5426850f84369e2b7dbe33f323ee50c006981f" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">流是可组合的，惰性的可枚举的（有关可枚举的介绍，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块）。在枚举过程中一一生成元素的任何可枚举都称为流。例如，Elixir的&lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;是一个流：</target>
        </trans-unit>
        <trans-unit id="4d05b9a39a36694d426084ba23a5f9e69c3f3e62" translate="yes" xml:space="preserve">
          <source>Streams are lazy, composable enumerables.</source>
          <target state="translated">流是懒惰的,可组成的枚举式。</target>
        </trans-unit>
        <trans-unit id="712809970aa25b88c8417d13c741aaaed8cdc5c7" translate="yes" xml:space="preserve">
          <source>Streams the enumerable in chunks, containing &lt;code&gt;count&lt;/code&gt; elements each, where each new chunk starts &lt;code&gt;step&lt;/code&gt; elements into the enumerable.</source>
          <target state="translated">以块的形式流可枚举，每个枚举均包含 &lt;code&gt;count&lt;/code&gt; 元素，其中每个新块将 &lt;code&gt;step&lt;/code&gt; 元素开始到可枚举中。</target>
        </trans-unit>
        <trans-unit id="c3766632b158ff372c632bd5e459fa938b757447" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;and&quot; operator.</source>
          <target state="translated">严格的布尔 &quot;和 &quot;运算符。</target>
        </trans-unit>
        <trans-unit id="a5a9a0e0f16ce8cccca691f5a88a387331ed3a60" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;not&quot; operator.</source>
          <target state="translated">严格的布尔 &quot;非 &quot;运算符。</target>
        </trans-unit>
        <trans-unit id="307c1d3f27f897db66810f52b5d24b80983a2d95" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;or&quot; operator.</source>
          <target state="translated">严格的布尔 &quot;或 &quot;运算符。</target>
        </trans-unit>
        <trans-unit id="1134f2ebe54abc3c1e5e36f6931e4a7294126534" translate="yes" xml:space="preserve">
          <source>Strictly equal to operator.</source>
          <target state="translated">严格等于运营商。</target>
        </trans-unit>
        <trans-unit id="30cf2e475f38e7c13632c86b9147ef4d7d19d6a3" translate="yes" xml:space="preserve">
          <source>Strictly not equal to operator.</source>
          <target state="translated">严格来说不等于运营商。</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="642ccf43dc1d6fbbbae9dcb9d0b32837c15cd30f" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists use the lists concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">字符串（二进制）串联使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符，而字符列表使用列表串联运算符 &lt;code&gt;++&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b412c0d58e5e7ad2aecfd7b3150626c2d9ea814" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists, being lists, use the list concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">字符串（二进制）串联使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符，但作为列表的字符列表使用列表串联运算符 &lt;code&gt;++&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="83229f3ff8f7ea7a043154af3b38efd4909e3589" translate="yes" xml:space="preserve">
          <source>String and binary operations</source>
          <target state="translated">字符串和二进制操作</target>
        </trans-unit>
        <trans-unit id="bd850015d8baaaed30b4f3d5a9c9529f30dc8015" translate="yes" xml:space="preserve">
          <source>String concatenation is done with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">字符串连接使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 完成：</target>
        </trans-unit>
        <trans-unit id="d89992e6bf13c0c402335f758d9be996e2e01c23" translate="yes" xml:space="preserve">
          <source>String.Chars</source>
          <target state="translated">String.Chars</target>
        </trans-unit>
        <trans-unit id="34301512f5868a1de9803c4f3410c31c2c126816" translate="yes" xml:space="preserve">
          <source>String.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">String.Chars &lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1c5c736c504b053727fd9efef0379fa8c75be99f" translate="yes" xml:space="preserve">
          <source>String.Chars.t (0)</source>
          <target state="translated">String.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="53d34343625f2871cea1abc24cdb3f39da79c324" translate="yes" xml:space="preserve">
          <source>String.Chars.to_string (1)</source>
          <target state="translated">String.Chars.to_string (1)</target>
        </trans-unit>
        <trans-unit id="71b9f81312a912f581ac74b4c41e1dabf6deb89c" translate="yes" xml:space="preserve">
          <source>StringIO</source>
          <target state="translated">StringIO</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="4e070c4fd19657d532bad6b50d3c0bc3ada85afa" translate="yes" xml:space="preserve">
          <source>Strings are always represented as themselves in the AST.</source>
          <target state="translated">字符串在AST中总是以自己的形式表示。</target>
        </trans-unit>
        <trans-unit id="9189545cce6b22534b68d2a8c78d66e2e097a67a" translate="yes" xml:space="preserve">
          <source>Strings can have line breaks in them. You can introduce them using escape sequences:</source>
          <target state="translated">字符串中可以有换行符。你可以使用转义序列来引入它们。</target>
        </trans-unit>
        <trans-unit id="8d0eb9bbaa9223ef9b42ad1496081c266e99b1dd" translate="yes" xml:space="preserve">
          <source>Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the &lt;code&gt;#{}&lt;/code&gt; syntax:</source>
          <target state="translated">Elixir中的字符串也支持插值。这允许您使用 &lt;code&gt;#{}&lt;/code&gt; 语法在字符串中间放置一些值：</target>
        </trans-unit>
        <trans-unit id="ca18cb73f9036b31075a45d8b8797d8a39e4a864" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are UTF-8 encoded binaries.</source>
          <target state="translated">Elixir中的字符串是UTF-8编码的二进制文件。</target>
        </trans-unit>
        <trans-unit id="04815a1192ce7e3ea77d99b96198de07fc1d57e2" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as &lt;code&gt;&quot;hello&quot;&lt;/code&gt; and &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt;.</source>
          <target state="translated">Elixir中的字符串是Unicode字符序列，通常写在双引号字符串之间，例如 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca38f6c1fbddaf28313e82e08e3bdd20ed71adb5" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are delimited by double quotes, and they are encoded in UTF-8:</source>
          <target state="translated">Elixir中的字符串以双引号分隔,并以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="956ce6bc8b8fc3893f30f39eeac47f3c2031a779" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by binaries which are sequences of bytes:</source>
          <target state="translated">Elixir中的字符串在内部由二进制表示,二进制是字节的序列。</target>
        </trans-unit>
        <trans-unit id="06c215a72c89446e5cfff5f5e5552a7f7dfcebc0" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by contiguous sequences of bytes known as binaries:</source>
          <target state="translated">Elixir中的字符串在内部由称为二进制的连续字节序列来表示。</target>
        </trans-unit>
        <trans-unit id="949492a01a0acbead6a5b64c79b3a5208d1fa196" translate="yes" xml:space="preserve">
          <source>Strings, char lists, and word lists sigils</source>
          <target state="translated">字符串、字符表和单词表 sigils</target>
        </trans-unit>
        <trans-unit id="b1b0c17e89281d54da848221c3d7d64fce387af1" translate="yes" xml:space="preserve">
          <source>Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input</source>
          <target state="translated">字符串、字符表、原子和符号都保持原样。没有任何字符被自动转义或不转义。定界符的选择也受输入的影响。</target>
        </trans-unit>
        <trans-unit id="5f59a80be2040336e52379484730e3abaf9c3bdf" translate="yes" xml:space="preserve">
          <source>Strips a beam file for a release.</source>
          <target state="translated">剥离光束文件进行释放。</target>
        </trans-unit>
        <trans-unit id="a4ab848fe5c4b2e5f638f279c7f13cc481bac6da" translate="yes" xml:space="preserve">
          <source>Struct</source>
          <target state="translated">Struct</target>
        </trans-unit>
        <trans-unit id="21e310386df8cb3491068257a8769c52dadb5d7d" translate="yes" xml:space="preserve">
          <source>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, &lt;code&gt;10 + 11&lt;/code&gt; is evaluated at compile-time and the age field is stored with value &lt;code&gt;21&lt;/code&gt;:</source>
          <target state="translated">结构字段在编译时进行评估，这使它们可以动态化。在下面的示例中，在编译时评估 &lt;code&gt;10 + 11&lt;/code&gt; ，并且age字段存储为值 &lt;code&gt;21&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="66b9bcf6fa135918752a0ac296373b9fc45c7435" translate="yes" xml:space="preserve">
          <source>Structs</source>
          <target state="translated">Structs</target>
        </trans-unit>
        <trans-unit id="e48092358ab469205143fa60ac35c7155aef2e05" translate="yes" xml:space="preserve">
          <source>Structs (see below)</source>
          <target state="translated">结构(见下文)</target>
        </trans-unit>
        <trans-unit id="1fa66ef16d007913d84111c1caa8d36201a759a2" translate="yes" xml:space="preserve">
          <source>Structs alongside protocols provide one of the most important features for Elixir developers: data polymorphism. That&amp;rsquo;s what we will explore in the next chapter.</source>
          <target state="translated">结构与协议一起为Elixir开发人员提供了最重要的功能之一：数据多态。这就是我们将在下一章中探讨的内容。</target>
        </trans-unit>
        <trans-unit id="906ed9113d865df8c36d98027adb8b4c438462a1" translate="yes" xml:space="preserve">
          <source>Structs also allow pattern matching on the struct name:</source>
          <target state="translated">结构还允许在结构名上进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="403a81b60bd1b9d08b2aba9ce6f1c1e83a0ae9bd" translate="yes" xml:space="preserve">
          <source>Structs are bare maps underneath</source>
          <target state="translated">结构是下面的裸图</target>
        </trans-unit>
        <trans-unit id="ef8a5b2279bd1fda0dd17b3e4b37d53f5cabffc3" translate="yes" xml:space="preserve">
          <source>Structs are extensions built on top of maps that provide compile-time checks and default values.</source>
          <target state="translated">Structs是建立在map之上的扩展,提供编译时的检查和默认值。</target>
        </trans-unit>
        <trans-unit id="b2f574270028afc6da451166304e7163b0e325d1" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">结构通常是使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; &lt;/a&gt;宏定义的：</target>
        </trans-unit>
        <trans-unit id="57a5690039bdfaa887691c076af282fbfcd1e385" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">结构通常是使用&lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; &lt;/a&gt;宏定义的：</target>
        </trans-unit>
        <trans-unit id="abdab30b78e5e45d65ba3227273c7089180b1f6f" translate="yes" xml:space="preserve">
          <source>Structs built on the map syntax by passing the struct name between &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;{&lt;/code&gt;. For example, &lt;code&gt;%User{...}&lt;/code&gt;.</source>
          <target state="translated">通过在 &lt;code&gt;%&lt;/code&gt; 和 &lt;code&gt;{&lt;/code&gt; 之间传递结构名称，在地图语法上构建结构。例如， &lt;code&gt;%User{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce56958d9176de03025283b3099e3721e59a8eb" translate="yes" xml:space="preserve">
          <source>Structs can also be used in pattern matching, both for matching on the value of specific keys as well as for ensuring that the matching value is a struct of the same type as the matched value.</source>
          <target state="translated">Structs也可以用于模式匹配,既可以在特定键的值上进行匹配,也可以确保匹配值是与匹配值相同类型的结构。</target>
        </trans-unit>
        <trans-unit id="627a64dfd0ce65d3cdca0e3adc12f995862ee10f" translate="yes" xml:space="preserve">
          <source>Structs provide &lt;em&gt;compile-time&lt;/em&gt; guarantees that only the fields (and &lt;em&gt;all&lt;/em&gt; of them) defined through &lt;code&gt;defstruct&lt;/code&gt; will be allowed to exist in a struct:</source>
          <target state="translated">结构提供&lt;em&gt;编译时&lt;/em&gt;保证，只有通过 &lt;code&gt;defstruct&lt;/code&gt; 定义的字段（和&lt;em&gt;所有&lt;/em&gt;字段）才允许存在于结构中：</target>
        </trans-unit>
        <trans-unit id="9a421e5ee413973974fb1a4739a9e94164f81b8a" translate="yes" xml:space="preserve">
          <source>Structs take the name of the module they&amp;rsquo;re defined in. In the example above, we defined a struct named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">结构采用它们在其中定义的模块的名称。在上面的示例中，我们定义了一个名为 &lt;code&gt;User&lt;/code&gt; 的结构。</target>
        </trans-unit>
        <trans-unit id="4bcfdb993ad07d9903f21c6cf1477e9cf60ca26b" translate="yes" xml:space="preserve">
          <source>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the &lt;code&gt;@opaque&lt;/code&gt; attribute. Structs whose internal structure is public should use &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">内部结构专用于本地模块的结构（不允许使用与它们匹配的模式或直接访问其字段的结构）应使用 &lt;code&gt;@opaque&lt;/code&gt; 属性。内部结构公开的结构应使用 &lt;code&gt;@type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fdac6921d89e2c5b2bed6c0d9d18041f744d060" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;datetime2&lt;/code&gt; from &lt;code&gt;datetime1&lt;/code&gt;.</source>
          <target state="translated">减去 &lt;code&gt;datetime2&lt;/code&gt; 从 &lt;code&gt;datetime1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01f386a46810771df7fb30922411804e63bbb211" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;naive_datetime2&lt;/code&gt; from &lt;code&gt;naive_datetime1&lt;/code&gt;.</source>
          <target state="translated">减去 &lt;code&gt;naive_datetime2&lt;/code&gt; 从 &lt;code&gt;naive_datetime1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14da215035d163f8d2e9ac00ee5de927b8ce5918" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator (the initial value being the result returned by &lt;code&gt;start_fun&lt;/code&gt;) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns &lt;code&gt;{:halt, acc}&lt;/code&gt;.</source>
          <target state="translated">通过使用上一个累加器调用 &lt;code&gt;next_fun&lt;/code&gt; 来生成连续值（初始值是 &lt;code&gt;start_fun&lt;/code&gt; 返回的结果），它必须返回一个元组，其中包含要发射的元素列表和下一个累加器。如果返回 &lt;code&gt;{:halt, acc}&lt;/code&gt; 则枚举完成。</target>
        </trans-unit>
        <trans-unit id="522311cdcaf7b3267814d3b09a19e47dea3c8a0f" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">通过使用上一个累加器调用 &lt;code&gt;next_fun&lt;/code&gt; 来生成连续值，并且它必须返回具有当前值和下一个累加器的元组。如果返回 &lt;code&gt;nil&lt;/code&gt; ，则枚举完成。</target>
        </trans-unit>
        <trans-unit id="ec0597f1e250ca1cd4f549ebe479656572bafdd1" translate="yes" xml:space="preserve">
          <source>Such a guard would look like this:</source>
          <target state="translated">这样的守卫会是这样的。</target>
        </trans-unit>
        <trans-unit id="53658e37fb70788364f35c3ef3e5d3ef21ca3b29" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">无论范围大小如何，此类函数调用在内存方面都是有效的。&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的实现仅使用基于端点的逻辑，而没有实现整数的整个列表。</target>
        </trans-unit>
        <trans-unit id="966ec8ae3fe9132ccbf00f8e3b57331123098390" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">无论范围大小如何，此类函数调用在内存方面都是有效的。&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的实现仅使用基于端点的逻辑，而没有实现整数的整个列表。</target>
        </trans-unit>
        <trans-unit id="413448cc1d1e59d4180a2c1df46d6b20fc8b2386" translate="yes" xml:space="preserve">
          <source>Such is also useful when using update functions, allowing us to introduce values as we traverse the data structure for updates:</source>
          <target state="translated">这样的在使用更新函数时也很有用,允许我们在遍历数据结构进行更新时引入值。</target>
        </trans-unit>
        <trans-unit id="f0c8c931aa883a1710a5641257d627e0b793426c" translate="yes" xml:space="preserve">
          <source>Such is possible for duplicate registries though:</source>
          <target state="translated">不过这种是有可能重复注册的。</target>
        </trans-unit>
        <trans-unit id="af0451134f60a76766f000f3339e06b3c7fb942b" translate="yes" xml:space="preserve">
          <source>Suffix matches (&lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt;) are not valid patterns.</source>
          <target state="translated">后缀匹配（ &lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt; ）不是有效的模式。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9413f829dc8a9eeac79634a8fecd1c1711b00407" translate="yes" xml:space="preserve">
          <source>Summing up</source>
          <target state="translated">总结</target>
        </trans-unit>
        <trans-unit id="008681d0cf389abc8327426047cec2a8b18317d8" translate="yes" xml:space="preserve">
          <source>Supervised tasks</source>
          <target state="translated">监督任务</target>
        </trans-unit>
        <trans-unit id="908fa8f422bcf3bb9ccc6611b5129caf568648d9" translate="yes" xml:space="preserve">
          <source>Supervision trees</source>
          <target state="translated">监督树</target>
        </trans-unit>
        <trans-unit id="2cd4fa195ed5b220930149c31cc72fbb131921db" translate="yes" xml:space="preserve">
          <source>Supervisor</source>
          <target state="translated">Supervisor</target>
        </trans-unit>
        <trans-unit id="e1ea02d7a77e7dff85d3adb88e64fc729ba83f91" translate="yes" xml:space="preserve">
          <source>Supervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">主管&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d69abd18d455510b99f3ff0e898ca02a3c32b696" translate="yes" xml:space="preserve">
          <source>Supervisor and Application</source>
          <target state="translated">主管和应用</target>
        </trans-unit>
        <trans-unit id="def06f454fe2aafd60e9bf9113ffca345eac503e" translate="yes" xml:space="preserve">
          <source>Supervisor and GenServers</source>
          <target state="translated">监督员和GenServers</target>
        </trans-unit>
        <trans-unit id="12010eabcaf19b4380edc62ef8ef7afae10e6caa" translate="yes" xml:space="preserve">
          <source>Supervisor and worker options</source>
          <target state="translated">主管和工人的选择</target>
        </trans-unit>
        <trans-unit id="ef948fc60b8d6995f73a05206917fcdf6cd81c08" translate="yes" xml:space="preserve">
          <source>Supervisor.Spec</source>
          <target state="translated">Supervisor.Spec</target>
        </trans-unit>
        <trans-unit id="fb7cc714ff3123e658f82813b47d9835dd16af4d" translate="yes" xml:space="preserve">
          <source>Supervisors support different strategies; in the example above, we have chosen &lt;code&gt;:one_for_one&lt;/code&gt;. Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the &quot;Child specification&quot; section).</source>
          <target state="translated">主管支持不同的策略；在上面的示例中，我们选择了 &lt;code&gt;:one_for_one&lt;/code&gt; 。此外，每个主管可以将许多工作人员和/或主管作为孩子，每个人都有其自己的配置（如&amp;ldquo;孩子规范&amp;rdquo;部分所述）。</target>
        </trans-unit>
        <trans-unit id="0578994f188280cb99013a5c58ec4c81802bfe88" translate="yes" xml:space="preserve">
          <source>Supervisors support different supervision strategies (through the &lt;code&gt;:strategy&lt;/code&gt; option, as seen above):</source>
          <target state="translated">主管支持不同的监管策略（通过 &lt;code&gt;:strategy&lt;/code&gt; 选项，如上所示）：</target>
        </trans-unit>
        <trans-unit id="f32d5a3b17e614297417cc279a7ec1cd02274d65" translate="yes" xml:space="preserve">
          <source>Support</source>
          <target state="translated">Support</target>
        </trans-unit>
        <trans-unit id="e6e1e0cd205858fc9432c841e89bbd6483ce3fe6" translate="yes" xml:space="preserve">
          <source>Support for making &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;private functions&lt;/a&gt; overridable</source>
          <target state="translated">支持使&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;私有功能&lt;/a&gt;可重写</target>
        </trans-unit>
        <trans-unit id="a4eab47f32a482fa6a57e7d78931eebd65984bbe" translate="yes" xml:space="preserve">
          <source>Support for making private functions overridable</source>
          <target state="translated">支持使私有函数可被覆盖</target>
        </trans-unit>
        <trans-unit id="6afec07b7fa976af6cf8797ee913469e9babea8a" translate="yes" xml:space="preserve">
          <source>Supported Erlang/OTP versions</source>
          <target state="translated">支持的Erlang/OTP版本</target>
        </trans-unit>
        <trans-unit id="cc98180ca761a9afbf85fc26a48b02b6e25dbae6" translate="yes" xml:space="preserve">
          <source>Supported ID values</source>
          <target state="translated">支持的ID值</target>
        </trans-unit>
        <trans-unit id="59b7fd869e912d97d97078bf118935bf508cd7dc" translate="yes" xml:space="preserve">
          <source>Supported module values</source>
          <target state="translated">支持的模块值</target>
        </trans-unit>
        <trans-unit id="4ce9ab2c76a64f3bead6b697086605679c05ba0b" translate="yes" xml:space="preserve">
          <source>Supported restart values</source>
          <target state="translated">支持的重启值</target>
        </trans-unit>
        <trans-unit id="4754143afdbe77546c223d10dd545bf29beec5ec" translate="yes" xml:space="preserve">
          <source>Supported shutdown values</source>
          <target state="translated">支持的关机值</target>
        </trans-unit>
        <trans-unit id="556737ead8feb164936eb5c9d04fdbaa68615120" translate="yes" xml:space="preserve">
          <source>Supported strategies</source>
          <target state="translated">支持的战略</target>
        </trans-unit>
        <trans-unit id="011f076c3d846af2a7296431ecd45f9d0d9ceba4" translate="yes" xml:space="preserve">
          <source>Supported worker values</source>
          <target state="translated">支持的工人价值</target>
        </trans-unit>
        <trans-unit id="b1ffd261b167462587f7afeaf76db355c7359f62" translate="yes" xml:space="preserve">
          <source>Supporting documents</source>
          <target state="translated">证明文件</target>
        </trans-unit>
        <trans-unit id="5074c54fe3d2dada9edf83c0782274a9de618a17" translate="yes" xml:space="preserve">
          <source>Supports multiple backends which are automatically supervised when plugged into &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">支持多个后端，这些后端在插入&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;时会自动受到监管。</target>
        </trans-unit>
        <trans-unit id="63b71cb9682231a38f6cb8bfe3190bb22abb9ee8" translate="yes" xml:space="preserve">
          <source>Switch definitions</source>
          <target state="translated">开关定义</target>
        </trans-unit>
        <trans-unit id="3b07b3e7fad246aad851785b8640c09bc790a0c6" translate="yes" xml:space="preserve">
          <source>Switches can be specified via one of two options:</source>
          <target state="translated">开关可以通过两个选项之一来指定。</target>
        </trans-unit>
        <trans-unit id="10f820ab2456db02149e31f2047f0b2fc4844076" translate="yes" xml:space="preserve">
          <source>Switches can be specified with modifiers, which change how they behave. The following modifiers are supported:</source>
          <target state="translated">开关可以用修饰符来指定,从而改变它们的行为方式。支持以下修饰符。</target>
        </trans-unit>
        <trans-unit id="76095f9f5c83633412d257a75ee9b301147d2861" translate="yes" xml:space="preserve">
          <source>Switches followed by a value will be assigned the value, as a string. Switches without an argument will be set automatically to &lt;code&gt;true&lt;/code&gt;. Since we cannot assert the type of the switch value, it is preferred to use the &lt;code&gt;:strict&lt;/code&gt; option that accepts only known switches and always verify their types.</source>
          <target state="translated">开关后跟一个值，该值将被分配为字符串。不带参数的开关将自动设置为 &lt;code&gt;true&lt;/code&gt; 。由于我们不能断言开关值的类型，因此最好使用 &lt;code&gt;:strict&lt;/code&gt; 选项，该选项仅接受已知的开关并始终验证其类型。</target>
        </trans-unit>
        <trans-unit id="5845d5880bc5d8b451e5a4dd803aa622305d25f1" translate="yes" xml:space="preserve">
          <source>Switches parsed by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt; may take zero or one arguments.</source>
          <target state="translated">由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt;解析的开关可以采用零或一个参数。</target>
        </trans-unit>
        <trans-unit id="3687a859d3cbb75ed3b6669b03cb32119eb5e843" translate="yes" xml:space="preserve">
          <source>Synchronously stops the agent with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">根据给定的 &lt;code&gt;reason&lt;/code&gt; 同步停止代理。</target>
        </trans-unit>
        <trans-unit id="83e327b0ee0a0791c10736b6ce6e0977e644efa8" translate="yes" xml:space="preserve">
          <source>Synchronously stops the given supervisor with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">根据给定的 &lt;code&gt;reason&lt;/code&gt; 同步停止给定的主管。</target>
        </trans-unit>
        <trans-unit id="20daca0170b9cf17db723aa618e07ac24ddb1612" translate="yes" xml:space="preserve">
          <source>Synchronously stops the server with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">根据给定的 &lt;code&gt;reason&lt;/code&gt; 同步停止服务器。</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">合成糖</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8c15a6de8bd57bfcd07b3aef8fb9a4bc8f26c05e" translate="yes" xml:space="preserve">
          <source>Syntax reference</source>
          <target state="translated">语法参考</target>
        </trans-unit>
        <trans-unit id="de4af2ff6c0bd31526ce7f5f8ca08783d0cc5ed7" translate="yes" xml:space="preserve">
          <source>SyntaxError</source>
          <target state="translated">SyntaxError</target>
        </trans-unit>
        <trans-unit id="62e61480537cef04396517bf21f00631d5916b00" translate="yes" xml:space="preserve">
          <source>SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SyntaxError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="15a3c2ea878a67e7f83b1e5350d3a1c397e6870e" translate="yes" xml:space="preserve">
          <source>System messages such as timer messages and monitoring events</source>
          <target state="translated">系统信息,如定时器信息和监控事件。</target>
        </trans-unit>
        <trans-unit id="629539f2b0b3c31f1b5b674c293fc529369d30a0" translate="yes" xml:space="preserve">
          <source>System modules</source>
          <target state="translated">系统模块</target>
        </trans-unit>
        <trans-unit id="e1f03c30c4ad532e4c164e6bd797580a623de00e" translate="yes" xml:space="preserve">
          <source>SystemLimitError</source>
          <target state="translated">SystemLimitError</target>
        </trans-unit>
        <trans-unit id="87d2f1faf999bf62e28a61deae6996346ba925b4" translate="yes" xml:space="preserve">
          <source>SystemLimitError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SystemLimitError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="34fe46e18f0db15e3602c13218d0d43606ec62eb" translate="yes" xml:space="preserve">
          <source>Table of deprecations</source>
          <target state="translated">废弃表</target>
        </trans-unit>
        <trans-unit id="848eed0fbd5429f556b2982dec3ea87136e33e44" translate="yes" xml:space="preserve">
          <source>Tags</source>
          <target state="translated">Tags</target>
        </trans-unit>
        <trans-unit id="b6178fb349e0b28eda375aea2c569cd350dc4da1" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;exunit.casetemplate&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">与案例模板（&lt;a href=&quot;exunit.casetemplate&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt;）一起使用时，标记也非常有效，允许案例模板中的回调自定义测试行为。</target>
        </trans-unit>
        <trans-unit id="1e98eca58b343bf9eef58db2b4d0749342e87444" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">与案例模板（&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt;）一起使用时，标记也非常有效，允许案例模板中的回调自定义测试行为。</target>
        </trans-unit>
        <trans-unit id="fc249ccb61119dc450a78be8a81ac2c8c0e49629" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;exunit#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">标签还可以用于标识特定的测试，然后可以使用过滤器将其包含或排除。最常见的功能是排除某些特定的测试，这可以通过&lt;a href=&quot;exunit#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; 完成&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="fbe21cac3f1b836469722d6aaccceafc7c70d983" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">标签还可以用于标识特定的测试，然后可以使用过滤器将其包括或排除。最常见的功能是排除某些特定的测试，这可以通过&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; 完成&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8b6e5fd9a74ed5f0c910db816652873cf2d30599" translate="yes" xml:space="preserve">
          <source>Tags in ExUnit are used to annotate tests. Tags can be later used to filter tests. For example, you can avoid running external tests on your machine because they are slow and dependent on other services, while they can still be enabled in your build system.</source>
          <target state="translated">ExUnit中的标签是用来注释测试的。标签以后可以用来过滤测试。例如,你可以避免在你的机器上运行外部测试,因为它们很慢,而且依赖于其他服务,而它们仍然可以在你的构建系统中启用。</target>
        </trans-unit>
        <trans-unit id="001aa408e4c6ef94853eea6d535dd0cd3f2d9ecb" translate="yes" xml:space="preserve">
          <source>Take note of the second argument to &lt;code&gt;Macro.var/2&lt;/code&gt;. This is the context being used and will determine hygiene as described in the next section.</source>
          <target state="translated">注意 &lt;code&gt;Macro.var/2&lt;/code&gt; 的第二个参数。这是所使用的上下文，它将确定卫生状况，如下一节所述。</target>
        </trans-unit>
        <trans-unit id="396cb525a863762a0153f155bab5fa14c60b4b53" translate="yes" xml:space="preserve">
          <source>Take such cases as a suggestion that your code should be refactored:</source>
          <target state="translated">把这种情况当成是建议你的代码应该重构。</target>
        </trans-unit>
        <trans-unit id="0ec41530414c8186f413ef6553a9627c2edc74fd" translate="yes" xml:space="preserve">
          <source>Take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">取得以下 &lt;code&gt;.iex.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="3272b9a706ed0ca47f559e862d6dc2150998b033" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;count&lt;/code&gt; random elements from &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">花费 &lt;code&gt;count&lt;/code&gt; 从随机元素 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff00a34c033bd6b414639eb45fc22dcd00b26ff3" translate="yes" xml:space="preserve">
          <source>Takes a compiled format and injects the level, timestamp, message, and metadata keyword list and returns a properly formatted string.</source>
          <target state="translated">取一个编译的格式,并注入级别、时间戳、消息和元数据关键字列表,并返回一个正确格式化的字符串。</target>
        </trans-unit>
        <trans-unit id="fc0be3a7f7029dd2d434cb9dc499906bd7070ad7" translate="yes" xml:space="preserve">
          <source>Takes a time zone name and a point in time for UTC and returns a &lt;code&gt;time_zone_period&lt;/code&gt; for that point in time.</source>
          <target state="translated">获取时区名称和UTC的时间点，并返回该时间点的 &lt;code&gt;time_zone_period&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="108613966b46cb41abd8d09ea8bc76b57d639cc0" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given &lt;code&gt;keys&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and extracts them into a separate map.</source>
          <target state="translated">获取对应于 &lt;code&gt;map&lt;/code&gt; 给定 &lt;code&gt;keys&lt;/code&gt; 所有条目，并将它们提取到单独的地图中。</target>
        </trans-unit>
        <trans-unit id="a057f41d143426d964dc91f467aeae07be4b8c88" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</source>
          <target state="translated">读取与给定键对应的所有条目,并将其提取到一个单独的关键字列表中。</target>
        </trans-unit>
        <trans-unit id="22f2fcc0cd4b387311cd745e5116cafb06152b07" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and returns them in a new keyword list.</source>
          <target state="translated">读取与给定键对应的所有条目,并将其返回到一个新的关键字列表中。</target>
        </trans-unit>
        <trans-unit id="f01e74291caa1b3fb31a76131a0358dad5dd2b3a" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;amount&lt;/code&gt; of elements from the beginning or the end of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;enumerable&lt;/code&gt; 的开头或结尾取 &lt;code&gt;amount&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1f1f6557000f60347445111652f8c88ca3309153" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (e.g., a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">采用一个枚举，该枚举枚举为一个包含两个元素的元组的列表（例如，映射或关键字列表），并以 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 的形式返回一个字符串，其中，键和值均按照&lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa8eb6bc5f76dd6add111a9e6f96763d7be8a60" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (for instance, a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">采用一个枚举，该枚举枚举为一个包含两个元素的元组的列表（例如，映射或关键字列表），并以 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 的形式返回一个字符串，其中，键和值均按照&lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt;进行URL编码/ 1。</target>
        </trans-unit>
        <trans-unit id="e45acfd4331b2440feb53de6fbc1560baa366e61" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;character_limit&lt;/code&gt; as a second argument. If &lt;code&gt;character_limit&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, this function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">将可选的 &lt;code&gt;character_limit&lt;/code&gt; 作为第二个参数。如果 &lt;code&gt;character_limit&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则此函数将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="feadb0c8e9163376cb17aaa5d080783ed49a3087" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;limit&lt;/code&gt; as a second argument. &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt; only checks the printability of the list up to the &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">将可选 &lt;code&gt;limit&lt;/code&gt; 作为第二个参数。&lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; &lt;/a&gt;仅检查列表的可打印性，直到 &lt;code&gt;limit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b31890ea4f4df85c9832a1da5e1e6d04b9bbfbd0" translate="yes" xml:space="preserve">
          <source>Takes changes such as summer time/DST into account. This means that adding time can cause the wall time to &quot;go backwards&quot; during &quot;fall back&quot; during autumn. Adding just a few seconds to a datetime just before &quot;spring forward&quot; can cause wall time to increase by more than an hour.</source>
          <target state="translated">考虑到了夏季时间/夏令时等变化。这意味着,在秋季 &quot;倒春寒 &quot;期间,增加时间会导致墙面时间 &quot;倒退&quot;。在 &quot;春季前进 &quot;之前,只要在日期时间上增加几秒钟,就会使墙面时间增加一个小时以上。</target>
        </trans-unit>
        <trans-unit id="fae8e01301c7e0feb68a23236a2c9b3567e8ae34" translate="yes" xml:space="preserve">
          <source>Takes the elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">从 &lt;code&gt;enumerable&lt;/code&gt; 的开头获取元素，而 &lt;code&gt;fun&lt;/code&gt; 返回真实值。</target>
        </trans-unit>
        <trans-unit id="c5464b7fb8fc4c108c9bf24e8c373a4e9e4044e0" translate="yes" xml:space="preserve">
          <source>Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width.</source>
          <target state="translated">将最大宽度和要打印的文档作为参数,并返回给定宽度内文档最佳布局的IO数据表示。</target>
        </trans-unit>
        <trans-unit id="8282e151892442f9f2cf52b76a916f132d30c0f4" translate="yes" xml:space="preserve">
          <source>Target ABI (for example, musl or gnu)</source>
          <target state="translated">目标ABI(例如,musl或gnu)</target>
        </trans-unit>
        <trans-unit id="9af45fd9ac96ee8998b351868ee1becb19e802d4" translate="yes" xml:space="preserve">
          <source>Target architecture (for example, x86_64 or ARM)</source>
          <target state="translated">目标架构(例如,x86_64或ARM)</target>
        </trans-unit>
        <trans-unit id="8e253f67079c51fc720f2bde4e13e5c23c03b6de" translate="yes" xml:space="preserve">
          <source>Target vendor + operating system (for example, Windows, Linux, or Darwin/macOS)</source>
          <target state="translated">目标供应商+操作系统(例如,Windows、Linux或Darwin/macOS)。</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="56913f440f346fedff0613f1a58aff47c8c81efb" translate="yes" xml:space="preserve">
          <source>Task and gen_tcp</source>
          <target state="translated">任务和gen_tcp</target>
        </trans-unit>
        <trans-unit id="42d489b854c5dff6b39f3ae727392332235bf30a" translate="yes" xml:space="preserve">
          <source>Task supervisor</source>
          <target state="translated">任务主管</target>
        </trans-unit>
        <trans-unit id="0590ada27ec6762e406a036264c8d3a5f2c7e027" translate="yes" xml:space="preserve">
          <source>Task-specific options</source>
          <target state="translated">特定任务选项</target>
        </trans-unit>
        <trans-unit id="35a08efc9d440da7708c69812b0507ba330ba97d" translate="yes" xml:space="preserve">
          <source>Task.Supervisor</source>
          <target state="translated">Task.Supervisor</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="ba00cfab602d1779b811d576baf5eafe077e7cab" translate="yes" xml:space="preserve">
          <source>Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:</source>
          <target state="translated">任务是指在整个生命周期中执行一个特定动作的进程,通常与其他进程很少或没有通信。任务最常见的用例是通过异步计算一个值,将顺序代码转换为并发代码。</target>
        </trans-unit>
        <trans-unit id="8a0db3194d6f9d766302e10355f2237684a84453" translate="yes" xml:space="preserve">
          <source>Tasks are what make Mix extensible.</source>
          <target state="translated">任务是Mix可扩展的原因。</target>
        </trans-unit>
        <trans-unit id="a520f228dee983c80456da705995e99d0baf055b" translate="yes" xml:space="preserve">
          <source>Tasks build on top of the spawn functions to provide better error reports and introspection:</source>
          <target state="translated">任务建立在产卵功能之上,提供更好的错误报告和反省。</target>
        </trans-unit>
        <trans-unit id="0d54343e18426db24d51d0ad44751f910be12ca3" translate="yes" xml:space="preserve">
          <source>Tasks spawned with &lt;code&gt;async&lt;/code&gt; can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.</source>
          <target state="translated">如上例所示，可以通过其调用者进程（并且只有其调用者）等待 &lt;code&gt;async&lt;/code&gt; 生成的任务。通过执行一旦执行给定计算后就将消息发送给调用方的过程来实现它们。</target>
        </trans-unit>
        <trans-unit id="f19715ca7223bd4e0d3fbc34df5b7dcc7380e790" translate="yes" xml:space="preserve">
          <source>Tasks typically depend on the &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; task, when they need to access code from the current project with all apps already configured, or the &quot;app.start&quot; task, when they also need those apps to be already started:</source>
          <target state="translated">当任务需要访问已配置了所有应用程序的当前项目中的代码时，它们通常取决于 &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; 任务，而当它们也需要启动这些应用程序时，它们取决于&amp;ldquo; app.start&amp;rdquo;任务：</target>
        </trans-unit>
        <trans-unit id="0b4b058a048fc58f7cc9589f239b42e939508324" translate="yes" xml:space="preserve">
          <source>Techniques</source>
          <target state="translated">Techniques</target>
        </trans-unit>
        <trans-unit id="f36d34a8fff232dc61a718546ef8daf864665507" translate="yes" xml:space="preserve">
          <source>Tells whether the given process is alive on the local node.</source>
          <target state="translated">说明给定进程在本地节点上是否还活着。</target>
        </trans-unit>
        <trans-unit id="3c899cc5439be26f0cd7b582a42447cf769aca66" translate="yes" xml:space="preserve">
          <source>Temporarily blocks the current process waiting for a task reply.</source>
          <target state="translated">暂时阻止等待任务回复的当前进程。</target>
        </trans-unit>
        <trans-unit id="d33ebb237e98c8b9d937b2d694b2c125b79ca66f" translate="yes" xml:space="preserve">
          <source>Term ordering</source>
          <target state="translated">术语排序</target>
        </trans-unit>
        <trans-unit id="696845220c6e0a0d1e64cd82d61908625e60074a" translate="yes" xml:space="preserve">
          <source>Terminate the top-level supervisor.</source>
          <target state="translated">终止最高级主管的工作。</target>
        </trans-unit>
        <trans-unit id="37c2abf54c623c6250b581aced135fc94e351e86" translate="yes" xml:space="preserve">
          <source>Terminates the Erlang runtime system without properly shutting down applications and ports. Please see &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; for a careful shutdown of the system.</source>
          <target state="translated">在不正确关闭应用程序和端口的情况下终止Erlang运行时系统。请参阅&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;以了解系统的仔细关闭信息。</target>
        </trans-unit>
        <trans-unit id="3cd2179f3f59774aca5baa2c47c7a727d23960ae" translate="yes" xml:space="preserve">
          <source>Terminates the child with the given &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">用给定的 &lt;code&gt;pid&lt;/code&gt; 终止孩子。</target>
        </trans-unit>
        <trans-unit id="c4bb07a1089485a5deadcff889ffd042bd8e458f" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">终止由 &lt;code&gt;child_id&lt;/code&gt; 标识的给定孩子。</target>
        </trans-unit>
        <trans-unit id="a50fe58f5df366a9be1362e929ebd0084a28443a" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">终止由 &lt;code&gt;pid&lt;/code&gt; 标识的给定子级。</target>
        </trans-unit>
        <trans-unit id="a202094d471c445107dcaeee3f888512868cbcd8" translate="yes" xml:space="preserve">
          <source>Test filters and tags</source>
          <target state="translated">测试过滤器和标签</target>
        </trans-unit>
        <trans-unit id="6259e4e6f0c5acd8366ddcebaae6c7f8a418bd4b" translate="yes" xml:space="preserve">
          <source>Test setup with ExUnit callbacks</source>
          <target state="translated">使用ExUnit回调进行测试设置</target>
        </trans-unit>
        <trans-unit id="56c4fd8cce0fae76b0fc19e67eda41b7a30e0a0f" translate="yes" xml:space="preserve">
          <source>Testing a GenServer</source>
          <target state="translated">测试GenServer</target>
        </trans-unit>
        <trans-unit id="788b3affdeae419dc740b3f8cbcd405e20e4cc4b" translate="yes" xml:space="preserve">
          <source>Testing a GenServer is not much different from testing an agent. We will spawn the server on a setup callback and use it throughout our tests. Create a file at &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; with the following:</source>
          <target state="translated">测试GenServer与测试代理没有太大区别。我们将在设置回调中生成服务器，并在整个测试中使用它。使用以下命令在 &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; 中创建一个文件：</target>
        </trans-unit>
        <trans-unit id="187e41969f8b9137e679aa44737b6ab5557c6441" translate="yes" xml:space="preserve">
          <source>Tests are first excluded, then included, and then skipped (if any left).</source>
          <target state="translated">先排除测试,再纳入测试,然后跳过测试(如果有剩余)。</target>
        </trans-unit>
        <trans-unit id="85b9fcfc0f6fc72610f7a98efec365df258038e3" translate="yes" xml:space="preserve">
          <source>Tests in umbrella projects can be run from the root by specifying the full suite path, including &lt;code&gt;apps/my_app/test&lt;/code&gt;, in which case recursive tests for other child apps will be skipped completely:</source>
          <target state="translated">通过指定完整的套件路径（包括 &lt;code&gt;apps/my_app/test&lt;/code&gt; )，可以从根目录运行伞项目中的测试，在这种情况下，将完全跳过其他子应用程序的递归测试：</target>
        </trans-unit>
        <trans-unit id="c876e9844d9fdc72e6da9216815faacf651f395c" translate="yes" xml:space="preserve">
          <source>Text-based match operator. Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">基于文本的匹配运算符。匹配的术语 &lt;code&gt;left&lt;/code&gt; 反对对正则表达式或字符串 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="062dbf72aa69df4b2bf2e11e396bf97a679fa018" translate="yes" xml:space="preserve">
          <source>Thankfully, Elixir v1.2 introduced the &lt;code&gt;with&lt;/code&gt; construct, which allows you to simplify code like the above, replacing nested &lt;code&gt;case&lt;/code&gt; calls with a chain of matching clauses. Let&amp;rsquo;s rewrite the &lt;code&gt;serve/1&lt;/code&gt; function to use &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="translated">值得庆幸的是，Elixir v1.2引入了 &lt;code&gt;with&lt;/code&gt; 构造，它使您可以简化类似于上述的代码，用一串匹配子句代替嵌套的 &lt;code&gt;case&lt;/code&gt; 调用。让我们重写 &lt;code&gt;serve/1&lt;/code&gt; 功能使用 &lt;code&gt;with&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="01e9b39e30c1a0e15112939ef1fff61fe4a3aa75" translate="yes" xml:space="preserve">
          <source>Thanks to the agent server process, the counter can be safely incremented concurrently.</source>
          <target state="translated">由于代理服务器进程,计数器可以安全地同时递增。</target>
        </trans-unit>
        <trans-unit id="fb4fefaf1d73585354762c2031b68d75737ffd24" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system.</source>
          <target state="translated">这定义了同时具有 &lt;code&gt;kv_server&lt;/code&gt; 和 &lt;code&gt;kv&lt;/code&gt; 应用程序的名为 &lt;code&gt;foo&lt;/code&gt; 的发行版。它们的模式设置为 &lt;code&gt;:permanent&lt;/code&gt; ，这意味着，如果这些应用程序崩溃，则整个节点将终止。这是合理的，因为这些应用程序对我们的系统至关重要。</target>
        </trans-unit>
        <trans-unit id="cdbd4eae22bceef6692b374955bde22d9b7d01d6" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system. With the configuration in place, let&amp;rsquo;s give another try at assembling the release:</source>
          <target state="translated">这定义了同时具有 &lt;code&gt;kv_server&lt;/code&gt; 和 &lt;code&gt;kv&lt;/code&gt; 应用程序的名为 &lt;code&gt;foo&lt;/code&gt; 的发行版。它们的模式设置为 &lt;code&gt;:permanent&lt;/code&gt; ，这意味着，如果这些应用程序崩溃，则整个节点将终止。这是合理的，因为这些应用程序对我们的系统至关重要。完成配置后，让我们再次尝试组装发行版：</target>
        </trans-unit>
        <trans-unit id="c0b2e0d9fe52f84cc809886b734e22953d615efa" translate="yes" xml:space="preserve">
          <source>That ensures that if the task completes after the &lt;code&gt;timeout&lt;/code&gt; but before &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; has been called, you will still get the result, since &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; is designed to handle this case and return the result.</source>
          <target state="translated">这样可以确保，如果任务在 &lt;code&gt;timeout&lt;/code&gt; 但在调用&lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt;之前完成，则您仍将获得结果，因为&lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt;旨在处理这种情况并返回结果。</target>
        </trans-unit>
        <trans-unit id="d1fc0fd9268067ed50e8dff689947fe93beb5673" translate="yes" xml:space="preserve">
          <source>That happens because the &lt;code&gt;IO&lt;/code&gt; module actually works with processes (see &lt;a href=&quot;processes&quot;&gt;chapter 11&lt;/a&gt;). Given a file is a process, when you write to a file that has been closed, you are actually sending a message to a process which has been terminated:</source>
          <target state="translated">之所以会发生这种情况，是因为 &lt;code&gt;IO&lt;/code&gt; 模块实际上与进程配合使用（请参见&lt;a href=&quot;processes&quot;&gt;第11章&lt;/a&gt;）。给定一个文件是一个进程，当您写入已关闭的文件时，实际上是在向已终止的进程发送消息：</target>
        </trans-unit>
        <trans-unit id="897c7bf39cdf3d75952cff1b5ff6f99e7827d8f9" translate="yes" xml:space="preserve">
          <source>That is, if the node can be part of a distributed system.</source>
          <target state="translated">也就是说,如果节点可以成为分布式系统的一部分。</target>
        </trans-unit>
        <trans-unit id="8e363ec1e2d5f0647070623c22f89c8707555da9" translate="yes" xml:space="preserve">
          <source>That is, if the number of bits in &lt;code&gt;bitstring&lt;/code&gt; is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</source>
          <target state="translated">也就是说，如果位 &lt;code&gt;bitstring&lt;/code&gt; 的位数不能被8整除，则所得的字节数将被四舍五入（多余）。此操作在固定时间内进行。</target>
        </trans-unit>
        <trans-unit id="21fbb88b6f851991624fb5b17096150fe0715845" translate="yes" xml:space="preserve">
          <source>That said, there are still cases where using macros and modules to build domain-specific languages is useful. Since we have explored data structures and function definitions in the Getting Started guide, this chapter will explore how to use macros and module attributes to tackle more complex DSLs.</source>
          <target state="translated">尽管如此,在一些情况下,使用宏和模块来构建特定领域的语言仍然是有用的。由于我们已经在入门指南中探讨了数据结构和函数定义,本章将探讨如何使用宏和模块属性来处理更复杂的DSL。</target>
        </trans-unit>
        <trans-unit id="814b47f77dfc5a37096b4b03955d625f97a0e859" translate="yes" xml:space="preserve">
          <source>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example:</source>
          <target state="translated">也就是说,我们需要将上面的别名节点扩展为一个原子,这样我们就可以检索它的长度。扩展节点并不直接,因为我们还需要扩展调用者别名。比如说</target>
        </trans-unit>
        <trans-unit id="4d3f07f40965deb2a6bdc254e2fe7db4fac694fb" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because an umbrella project gives us plenty of options when deploying the software. We can:</source>
          <target state="translated">这是因为总括项目为我们在部署软件时提供了很多选择。我们可以：</target>
        </trans-unit>
        <trans-unit id="11e8efbea29607bc7f881559616858502e41b031" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because we were expecting data from &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; but the client closed the connection. We need to handle such cases better in future revisions of our server.</source>
          <target state="translated">那是因为我们期望来自 &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 的数据，但是客户端关闭了连接。我们需要在服务器的未来版本中更好地处理此类情况。</target>
        </trans-unit>
        <trans-unit id="4c56715445461f557ef98a6e96f4646be8d6243e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s enough for our tests to pass but there is a resource leakage in our application. When a bucket terminates, the supervisor will start a new bucket in its place. After all, that&amp;rsquo;s the role of the supervisor!</source>
          <target state="translated">这足以让我们的测试通过，但是我们的应用程序中存在资源泄漏。当存储桶终止时，主管将在其位置启动一个新存储桶。毕竟，这就是主管的角色！</target>
        </trans-unit>
        <trans-unit id="b7a0f3e3c150c923165c6e2a99dd197a0a28b7af" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s happening because the release &lt;code&gt;foo&lt;/code&gt; is already listening on port &lt;code&gt;4040&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; is trying to do the same! One option could be to move the &lt;code&gt;:port&lt;/code&gt; configuration to the application environment, like we did for the routing table. But let&amp;rsquo;s try something else. Let&amp;rsquo;s make it so the &lt;code&gt;bar&lt;/code&gt; release contains only the &lt;code&gt;:kv&lt;/code&gt; application. So it works as a storage but it won&amp;rsquo;t have a front-end. Change the &lt;code&gt;:bar&lt;/code&gt; information to this:</source>
          <target state="translated">发生这种情况是因为版本 &lt;code&gt;foo&lt;/code&gt; 已经在端口 &lt;code&gt;4040&lt;/code&gt; 上侦听，而 &lt;code&gt;bar&lt;/code&gt; 试图这样做！一种选择是将 &lt;code&gt;:port&lt;/code&gt; 配置移动到应用程序环境，就像我们对路由表所做的那样。但是，让我们尝试其他事情。让我们开始 &lt;code&gt;bar&lt;/code&gt; 发布仅包含 &lt;code&gt;:kv&lt;/code&gt; 应用程序。因此，它可以用作存储设备，但没有前端。将 &lt;code&gt;:bar&lt;/code&gt; 信息更改为此：</target>
        </trans-unit>
        <trans-unit id="728db93af19ad8ae8e28827f7df6fa0ee95b6c1b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it for the client API. On the server side, we can implement a variety of callbacks to guarantee the server initialization, termination, and handling of requests. Those callbacks are optional and for now, we have only implemented the ones we care about. Let&amp;rsquo;s recap.</source>
          <target state="translated">客户端API就是这样。在服务器端，我们可以实现各种回调，以确保服务器初始化，终止和处理请求。这些回调是可选的，目前，我们仅实现了我们关心的回调。让我们回顾一下。</target>
        </trans-unit>
        <trans-unit id="a3de339a8a8126c8176ac9eab07a22576517e36b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not what we wanted, since the value of the &lt;code&gt;number&lt;/code&gt; variable has not been injected and &lt;code&gt;number&lt;/code&gt; has been quoted in the expression. In order to inject the &lt;em&gt;value&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; variable, &lt;code&gt;unquote&lt;/code&gt; has to be used inside the quoted representation:</source>
          <target state="translated">这不是我们想要的，因为尚未输入 &lt;code&gt;number&lt;/code&gt; 变量的值，并且表达式中已引用了 &lt;code&gt;number&lt;/code&gt; 。为了注入 &lt;code&gt;number&lt;/code&gt; 变量的&lt;em&gt;值&lt;/em&gt;，必须在带引号的表示形式内使用 &lt;code&gt;unquote&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dcf68842185af09e3a0f9fe32163648242f47543" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what macros are all about. They are about receiving quoted expressions and transforming them into something else. In fact, &lt;code&gt;unless/2&lt;/code&gt; in Elixir is implemented as a macro:</source>
          <target state="translated">这就是宏的全部内容。它们是关于接收带引号的表达式并将其转换为其他表达式。实际上， &lt;code&gt;unless/2&lt;/code&gt; Elixir中的/ 2被实现为宏：</target>
        </trans-unit>
        <trans-unit id="23bd0d6f40de4627ff508337339ea27a545beab3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s when &lt;code&gt;unquote_splicing&lt;/code&gt; becomes handy:</source>
          <target state="translated">那是当 &lt;code&gt;unquote_splicing&lt;/code&gt; 变得方便时：</target>
        </trans-unit>
        <trans-unit id="21e361b399ff70e0ade5d247fbe5325383f22c2c" translate="yes" xml:space="preserve">
          <source>That's because by reading the application in the module body and storing it in a module attribute, we are effectively reading the configuration at compile-time, which may become an issue when configuring the system later.</source>
          <target state="translated">这是因为我们在模块体中读取应用程序,并将其存储在模块属性中,实际上是在编译时读取配置,这可能成为以后配置系统时的一个问题。</target>
        </trans-unit>
        <trans-unit id="525c877e46b0705b116260fb28719a829fe1a18e" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">这就是我们早先说过的流是可组合的，惰性枚举的意思。请注意，我们可以多次调用&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt;，以有效地组成流并使它们保持惰性。仅当您从&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块调用函数时才执行计算。</target>
        </trans-unit>
        <trans-unit id="dd53bd72aff61e4af823bbda7c24cb88da5c37ab" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Notice we could call &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">这就是我们早先说过的流是可组合的，惰性枚举的意思。注意，我们可以多次调用&lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt;，以有效地组成流并使它们保持懒惰。仅当您从&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块调用函数时才执行计算。</target>
        </trans-unit>
        <trans-unit id="09a6d160f8b301e17d705ee43757bf265bccdb38" translate="yes" xml:space="preserve">
          <source>The &quot;Current Era&quot; or the &quot;Common Era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;当前时代&amp;rdquo;或开始在一年中&amp;ldquo;共同的时代&amp;rdquo;（CE） &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a59d1e1634f57e0cf851ffcf7499aa4351a17212" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to a deprecated &quot;module.function/arity&quot; is made. This operation does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">file:line &quot;表示调用废弃的 &quot;module.function/arity &quot;的文件和行。这个操作不显示被废弃的本地调用(对同一模块中被废弃的函数或宏的调用),也不显示对Elixir本身被废弃的功能的调用。</target>
        </trans-unit>
        <trans-unit id="826934dab44a7a099fc8b2a86a3c62e533cc4b2e" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to an unknown &quot;module.function/arity&quot; is made.</source>
          <target state="translated">file:line &quot;代表对未知的 &quot;module.function/arity &quot;进行调用的文件和行。</target>
        </trans-unit>
        <trans-unit id="f23646193825ac71d9878bc225694b7560e701b8" translate="yes" xml:space="preserve">
          <source>The --stale option</source>
          <target state="translated">陈旧选项</target>
        </trans-unit>
        <trans-unit id="0c20b0f5fe22af74b9f5bd9023dad3c12944c0fd" translate="yes" xml:space="preserve">
          <source>The .iex.exs file</source>
          <target state="translated">.iex.exs文件</target>
        </trans-unit>
        <trans-unit id="f8308d6c331d75737fe1ed60777039be95e5626b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">在&lt;a href=&quot;#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;操作者也可以在模式匹配（和保护子句）中使用，只要该左参数是文字二进制：</target>
        </trans-unit>
        <trans-unit id="2522f291657c90a8970a25fc0f5c55b3b111e28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">在&lt;a href=&quot;#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;操作者也可以在模式匹配（和保护子句）中使用，只要该左参数是文字二进制：</target>
        </trans-unit>
        <trans-unit id="3ea0da9cdd3dfdfb8c5593853f9e341b5464f742" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#--/2&quot;&gt;&lt;code&gt;--/2&lt;/code&gt;&lt;/a&gt; operator is right associative, meaning:</source>
          <target state="translated">在&lt;a href=&quot;#--/2&quot;&gt; &lt;code&gt;--/2&lt;/code&gt; &lt;/a&gt;运算符是右结合的，意思是：</target>
        </trans-unit>
        <trans-unit id="ae4a9ae0930f3e9d2c507d033d48dd4bf27477e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/2&quot;&gt;&lt;code&gt;add/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/2&quot;&gt;&lt;code&gt;diff/2&lt;/code&gt;&lt;/a&gt; functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):</source>
          <target state="translated">所述&lt;a href=&quot;#add/2&quot;&gt; &lt;code&gt;add/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#diff/2&quot;&gt; &lt;code&gt;diff/2&lt;/code&gt; &lt;/a&gt;的功能可以被用于计算日期或检索时刻之间的天数。例如，如果有兴趣计算从Unix时代（1970-01-01）起的天数：</target>
        </trans-unit>
        <trans-unit id="9ee4b27e73fcd2815c54fe669288c51019f1a3b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/3&quot;&gt;&lt;code&gt;add/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/3&quot;&gt;&lt;code&gt;diff/3&lt;/code&gt;&lt;/a&gt; functions can be used for computing with date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00):</source>
          <target state="translated">所述&lt;a href=&quot;#add/3&quot;&gt; &lt;code&gt;add/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#diff/3&quot;&gt; &lt;code&gt;diff/3&lt;/code&gt; &lt;/a&gt;的功能可以被用于与日期时间的计算或检索的时刻之间的秒数。例如，如果有兴趣计算从Unix纪元（1970-01-01 00:00:00）起的秒数：</target>
        </trans-unit>
        <trans-unit id="a3dad105e7857da173ae25be4e7158181735facf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function returns an atom indicating the status of the compilation, and optionally can also return a list of &quot;diagnostics&quot; such as warnings or compilation errors. Doing this enables code editors to display issues inline without having to analyze the command-line output.</source>
          <target state="translated">该&lt;a href=&quot;#c:run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数返回一个指示原子编译的状态，并且可选地还可以返回&amp;ldquo;诊断&amp;rdquo;，例如警告或编译错误的列表。这样做使代码编辑器可以内联显示问题，而不必分析命令行输出。</target>
        </trans-unit>
        <trans-unit id="43daa6aefdc5d7ab59c882f8c756868ab5825ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback has to spawn and link a supervisor and return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor, and &lt;code&gt;state&lt;/code&gt; is an optional application state. &lt;code&gt;args&lt;/code&gt; is the second element of the tuple given to the &lt;code&gt;:mod&lt;/code&gt; option.</source>
          <target state="translated">的&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调具有产卵和链接主管和返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 或 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是主管的PID，并且 &lt;code&gt;state&lt;/code&gt; 是一个可选的应用程序状态。 &lt;code&gt;args&lt;/code&gt; 是赋予 &lt;code&gt;:mod&lt;/code&gt; 选项的元组的第二个元素。</target>
        </trans-unit>
        <trans-unit id="ed55773b14c9f49b1e67866369426e97f1e28202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; callback of the given &lt;code&gt;server&lt;/code&gt; will be invoked before exiting. This function returns &lt;code&gt;:ok&lt;/code&gt; if the server terminates with the given reason; if it terminates with another reason, the call exits.</source>
          <target state="translated">退出前，将调用给定 &lt;code&gt;server&lt;/code&gt; 的&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;回调。如果服务器由于给定的原因终止，则此函数返回 &lt;code&gt;:ok&lt;/code&gt; ；如果由于其他原因终止，则呼叫退出。</target>
        </trans-unit>
        <trans-unit id="e5479aff7c9902d4559e5268eb0059ef6a88b9eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module defines a behaviour for dynamically accessing keys of any type in a data structure via the &lt;code&gt;data[key]&lt;/code&gt; syntax.</source>
          <target state="translated">所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块定义用于经由在数据结构中动态地访问任何类型的密钥的行为 &lt;code&gt;data[key]&lt;/code&gt; 的语法。</target>
        </trans-unit>
        <trans-unit id="22076bf07a81ed27164e331c5cdde4703e5883c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module provides a basic server implementation that allows state to be retrieved and updated via a simple API.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;模块提供了一个基本的服务器实现，允许状态，通过一个简单的API来检索和更新。</target>
        </trans-unit>
        <trans-unit id="ab7d336fe7d0f927a59616b237afeff91face2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;模块被设计为填充由留下的间隙&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议。&lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt;可以看作是&lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt;的反义词。如果&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的函数要取出值，那么&lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt;就是将这些值收集到结构中。</target>
        </trans-unit>
        <trans-unit id="b8288b2458a158037407e3018394c02df95a408e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;模块被设计为填充由留下的间隙&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议。&lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt;可以看作是&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt;的反义词。如果&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的函数是要取出值，那么&lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt;是将这些值收集到结构中。</target>
        </trans-unit>
        <trans-unit id="ba60445997acad418c74ca5920c2ffa31f99771e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">v1.9中引入了Elixir中的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;模块，以替代&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt;，该模块特定于Mix，已弃用。</target>
        </trans-unit>
        <trans-unit id="abf8114bea9b602a6fa5cde26a4f28f20fe6f936" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is disabled by configuration but might be enabled later.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;由配置来禁用，但可能在以后启用。</target>
        </trans-unit>
        <trans-unit id="6bff3abe60e151fca7d023800c126e733ac84e99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. This is especially useful for fields containing private information.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议可以得出，从结构隐藏某些领域，所以他们不会在日志中，检查和类似的显示出来。这对于包含私人信息的字段特别有用。</target>
        </trans-unit>
        <trans-unit id="8080f21d315b84058f54169b0d0e5acda5fedb17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol converts an Elixir data structure into an algebra document.</source>
          <target state="translated">的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议转换的药剂数据结构转换为一个文件代数。</target>
        </trans-unit>
        <trans-unit id="9574ae7fd608f87be01cc34283e1b30a27e28472" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt; module consists solely of macros that can be invoked anywhere in Elixir code without the use of the &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; &lt;/a&gt;模块仅由能在任何地方花好月圆代码调用不使用的宏 &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; 字首。这是可能的，因为它们都已经以与&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块中的函数和宏相同的方式自动导入了。</target>
        </trans-unit>
        <trans-unit id="9b2d0f65323751f2d634dcefd3c1350838c93ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;List.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a charlist (only if applicable).</source>
          <target state="translated">所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;List.Chars&lt;/code&gt; &lt;/a&gt;协议负责的结构转换成charlist（仅如果适用）。</target>
        </trans-unit>
        <trans-unit id="38d20b80dced22a569e8ce8dd2e2cb76ca007f43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level can be changed via &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;水平可以通过改变&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49b1a8808d4938037f08f4bb6036b797cb46526f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a binary (only if applicable).</source>
          <target state="translated">所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议负责的结构变换成二进制（仅如果适用）。</target>
        </trans-unit>
        <trans-unit id="3a7cc4ed1dd3a53a3c1622be5d60a8754eb496ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module also provides functions that work with time, returning different times kept by the system with support for different time units.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;模块还提供了功能随着时间的工作，返回不同的时间保持对体系内进行不同时间单位的支持。</target>
        </trans-unit>
        <trans-unit id="cb4a8417128c99dd0f8e923027d6accff8aed84b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module provides functions that interact directly with the VM or the host system.</source>
          <target state="translated">该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt;模块提供的功能互相作用直接与VM或主机系统。</target>
        </trans-unit>
        <trans-unit id="12062fd16ee7106907717a179dc3f0336ff014a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">的&lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt;功能有时与混淆&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt;，因为表现得与两个相同的上述例子。当要转义的值存储在变量中时，可以最好地说明关键区别。</target>
        </trans-unit>
        <trans-unit id="809a6d9b2839f1f30bd03fe2ee9a26d931f04222" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">的&lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt;功能有时与混淆&lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt;，因为表现得与两个相同的上述例子。当要转义的值存储在变量中时，可以最好地说明关键区别。</target>
        </trans-unit>
        <trans-unit id="9c2c3fda2409ed0d9077f83013708c3d236d2331" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt; operator (as well as &lt;code&gt;not in&lt;/code&gt;) can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</source>
          <target state="translated">的&lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;操作者（以及 &lt;code&gt;not in&lt;/code&gt; ）可在防护件子句中使用，只要该右手侧的范围或列表。在这种情况下，Elixir会将运算符扩展为有效的保护表达式。例如：</target>
        </trans-unit>
        <trans-unit id="12e9561355b5b7e730bdce33c0452a589a9f44d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warning&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">该&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt;宏发在被提供的消息 &lt;code&gt;:info&lt;/code&gt; 级别。请注意，仅在记录消息时才会评估赋予&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;的参数。例如，如果Logger级别设置为 &lt;code&gt;:warning&lt;/code&gt; ，则 &lt;code&gt;:info&lt;/code&gt; 消息将永远不会被记录，因此上面给出的参数甚至不会被执行。</target>
        </trans-unit>
        <trans-unit id="64530a6b669b9204e5a94bb0898670f111e23370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;函数接收要检查的实体随后检查选项，由结构表示&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;完成代数文档的构建。</target>
        </trans-unit>
        <trans-unit id="1987eac8908bd887fd45fd0aa17e5d5cf4eae6f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;函数接收要检查的实体随后检查选项，由结构表示&lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;完成代数文档的构建。</target>
        </trans-unit>
        <trans-unit id="134dffce704618fe41bc1a6ff89c996a1a5a5795" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; function is an alternative to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; which stops parsing as soon as it finds a value that is not a switch nor a value for a previous switch.</source>
          <target state="translated">所述&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;的功能是一种替代&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;其中便会立即停止解析，因为它找到一个值，该值是不是一个开关，也不针对先前开关的值。</target>
        </trans-unit>
        <trans-unit id="697f7c6714240908cebb2f84042a4676fb351582" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#receive/1&quot;&gt;&lt;code&gt;receive/1&lt;/code&gt;&lt;/a&gt; special form handles variables exactly as the &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt; special macro. For more information, check the docs for &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;#receive/1&quot;&gt; &lt;code&gt;receive/1&lt;/code&gt; &lt;/a&gt;特殊形式的手柄变量完全一样的&lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt;特殊宏。有关更多信息，请检查文档&lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0a73aff6dd1644a4fec2f0cc2e5b4cbf67e226d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all arguments passed to the command line.</source>
          <target state="translated">该&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;功能将得到的传递到命令行的所有参数列表。</target>
        </trans-unit>
        <trans-unit id="d0035717d441177cdcf48958cde9b6d4cb1dceef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all command line arguments passed, according to the user's terminal.</source>
          <target state="translated">该&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数将接收的通过了所有的命令行参数的列表，根据用户的终端。</target>
        </trans-unit>
        <trans-unit id="659e7f5a2f80c4b590db43cd2313e4b28833eba7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入的&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt;函数调用此协议。</target>
        </trans-unit>
        <trans-unit id="1acbbf7700e430d5e8a317ed727437d8f72605c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入的&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt;函数调用此协议。</target>
        </trans-unit>
        <trans-unit id="e73d8ea623f499f0cd55a3dd0c9f7d97f06db4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入的&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;函数调用此协议。字符串插值还会在其参数中调用&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;。例如， &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; 与 &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9a742b2d1a9b66bf0c1dce63c60e9a1472deab1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入的&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;函数调用此协议。字符串插值还会在其参数中调用&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;。例如， &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; 与 &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99cfcb046ece84f36691d25008fe9a0f03a6c335" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;access#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">该&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块还附带了许多方便的存取功能，如 &lt;code&gt;all&lt;/code&gt; 上述定义的匿名函数。请参阅&lt;a href=&quot;access#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;access#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt;和其他示例。</target>
        </trans-unit>
        <trans-unit id="bf10aa8724a5861c9b7609f06466ac0092733d78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">所述&lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;功能使用这一协议来插入可枚举到收集：</target>
        </trans-unit>
        <trans-unit id="fa114b12b62761d046798dab8cfd3d0e25686da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">所述&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议是有用的取值从集合中。为了支持各种值，&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议提供的功能无法保持不变。例如，将地图传递给&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;总是返回一个列表。</target>
        </trans-unit>
        <trans-unit id="c6e919949e1cc4c7055aecf80d424e6c7c8e1be6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exunit.assertions&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">所述&lt;a href=&quot;exunit.assertions&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; &lt;/a&gt;模块包含一组宏，以产生具有适当的错误消息的断言。</target>
        </trans-unit>
        <trans-unit id="e06ff54ee1b695829bf1293f395bfa9eaf00995b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt;&lt;code&gt;queue&lt;/code&gt; is a data structure&lt;/a&gt; that implements (double-ended) FIFO (first-in first-out) queues efficiently:</source>
          <target state="translated">该&lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt; &lt;code&gt;queue&lt;/code&gt; 是一种数据结构&lt;/a&gt;，它实现（双端）FIFO（先入先出）有效地队列：</target>
        </trans-unit>
        <trans-unit id="07ed121626ed7e8f632f13e54f94021e4c3eade3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块还附带了许多方便的存取功能，如 &lt;code&gt;all&lt;/code&gt; 上述定义的匿名函数。请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt;和其他示例。</target>
        </trans-unit>
        <trans-unit id="bdd1437c3341d1c07273b3f627a96d773e38e418" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt;, which we&amp;rsquo;re going to see in the next chapter, already provides many conveniences for working with lists. For instance, the examples above could be written as:</source>
          <target state="translated">我们将在下一章中看到的&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 模块&lt;/a&gt;已经为使用列表提供了许多便利。例如，以上示例可以写为：</target>
        </trans-unit>
        <trans-unit id="61a11f1e7c47a4cc245aed3807805f29443ecca4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">所述&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;功能使用这一协议来插入可枚举到收集：</target>
        </trans-unit>
        <trans-unit id="2f7b5a0e03b34766993d4d199617c0cbd0ae5332" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">所述&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议是有用的取值从集合中。为了支持各种值，&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议提供的功能无法保持不变。例如，将地图传递给&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;总是返回一个列表。</target>
        </trans-unit>
        <trans-unit id="a8c7834fd0c261cc1b5f7ce8f49f4c14a50c74c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; module contains functions that allow us to open files as IO devices. By default, files are opened in binary mode, which requires developers to use the specific &lt;code&gt;IO.binread/2&lt;/code&gt; and &lt;code&gt;IO.binwrite/2&lt;/code&gt; functions from the &lt;code&gt;IO&lt;/code&gt; module:</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;模块包含的功能，使我们能够打开文件作为IO设备。默认情况下，文件以二进制模式打开，这要求开发人员使用 &lt;code&gt;IO&lt;/code&gt; 模块中的特定 &lt;code&gt;IO.binread/2&lt;/code&gt; 和 &lt;code&gt;IO.binwrite/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="f10e5258e9f652f477ba9a6f2a826f10009c524a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module is the main mechanism in Elixir for reading and writing to standard input/output (&lt;code&gt;:stdio&lt;/code&gt;), standard error (&lt;code&gt;:stderr&lt;/code&gt;), files, and other IO devices. Usage of the module is pretty straightforward:</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块是在药剂用于读取和写入标准的输入/输出的主机构（ &lt;code&gt;:stdio&lt;/code&gt; ），标准误差（ &lt;code&gt;:stderr&lt;/code&gt; ），文件和其它IO设备。该模块的用法非常简单：</target>
        </trans-unit>
        <trans-unit id="cedaefb5f61468b8c215642cc99c539ddbc0a94c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块提供流，即都是&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;，这里是使用推导的upcase回声服务器：</target>
        </trans-unit>
        <trans-unit id="e868f828529603da9f63a81284af34a853bef03f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above it is concatenating the string &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt;, the document returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt;, and the final string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;. We prefix the module name &lt;code&gt;#&lt;/code&gt; to denote the inspect presentation is not actually valid Elixir syntax.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt;功能来自&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;它代数文件串接在一起。在上面的示例中，它是将字符串 &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt; ，&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt;返回的文档以及最后的字符串 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 。我们在模块名称 &lt;code&gt;#&lt;/code&gt; 前面加上前缀，以表示检查呈现实际上不是有效的Elixir语法。</target>
        </trans-unit>
        <trans-unit id="ae641337e01b9f93059a36e1a3ba275b039ee2b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议可以得出，从结构隐藏某些领域，所以他们不会在日志中，检查和类似的显示出来。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议文档的&amp;ldquo;派生&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1a28216d6e4672680d6eab32ae15b9eaaeac9554" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;%NaiveDateTime{}&lt;/a&gt; struct contains fields from both &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt;. You can create one using the &lt;code&gt;~N&lt;/code&gt; sigil:</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;％NaiveDateTime {}&lt;/a&gt;结构包含两个字段 &lt;code&gt;Date&lt;/code&gt; 和 &lt;code&gt;Time&lt;/code&gt; 。您可以使用创建一个 &lt;code&gt;~N&lt;/code&gt; 印记：</target>
        </trans-unit>
        <trans-unit id="0707ff13aefb15f3954d547b10f3f7c1336b24c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;String module&lt;/a&gt; contains a bunch of functions that operate on strings as defined in the Unicode standard:</source>
          <target state="translated">的&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;字符串模块&lt;/a&gt;包含一组上作为Unicode标准定义的字符串操作的功能：</target>
        </trans-unit>
        <trans-unit id="d8cf6fffff5672b5280f7c52df7e56e3e88d0bc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块设计，可以处理给定的顺序监督员启动时开始大多是静态的孩子。一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;开始，没有子女。而是通过&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;按需启动子级。当动态主管终止时，所有子项都将同时关闭，而不能保证订购。</target>
        </trans-unit>
        <trans-unit id="3698c4ae0d236660076a5f1da19f774b16936015" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;模块使开发人员能够动态地创建多个监督任务。</target>
        </trans-unit>
        <trans-unit id="bc49e09c4c997793290301e758bea0470f3d8f68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;%Time{}&lt;/a&gt; struct contains the fields &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, and &lt;code&gt;calendar&lt;/code&gt;. You can create one using the &lt;code&gt;~T&lt;/code&gt; sigil:</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;％时间{}&lt;/a&gt;结构包含字段 &lt;code&gt;hour&lt;/code&gt; ， &lt;code&gt;minute&lt;/code&gt; ， &lt;code&gt;second&lt;/code&gt; ， &lt;code&gt;microsecond&lt;/code&gt; ，和 &lt;code&gt;calendar&lt;/code&gt; 。您可以使用创建一个 &lt;code&gt;~T&lt;/code&gt; 印记：</target>
        </trans-unit>
        <trans-unit id="4e2e3efd9b70a9c902779bfbca4902214d293def" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">所述&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; &lt;/a&gt;模块包含一组宏，以产生具有适当的错误消息的断言。</target>
        </trans-unit>
        <trans-unit id="67af9d3d80d8598be47bff2ebf254dbbb32a0636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; command also allows the &lt;code&gt;--sup&lt;/code&gt; option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt;命令还允许 &lt;code&gt;--sup&lt;/code&gt; 选项脚手架与监督树的应用程序开箱即用。稍后我们将在讨论编写库时讨论的常见反模式之一时讨论监督树。</target>
        </trans-unit>
        <trans-unit id="08414f62e4bbf9fd4d3ea08bc5b82b4c8e08abc1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">该&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议可以得出，从结构隐藏某些领域，所以他们不会在日志中，检查和类似的显示出来。有关更多信息，请参见&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议文档的&amp;ldquo;派生&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="40361add3dfacd3a82f9de048a333c39b479ae30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect.algebra#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above, it is concatenating the string &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; (all strings are valid algebra documents that keep their formatting when pretty printed), the document returned by &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; and the other string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;inspect.algebra#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt;功能来自&lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;它代数文件串接在一起。在上面的示例中，它串联了字符串 &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; （所有字符串都是有效的代数文档，当漂亮地打印时将保留其格式），&lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt;返回的文档以及其他字符串 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e499fed5d9e082220ab4665ee83930202fbc216" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">在&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块提供流，即都是&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;，这里是使用推导的upcase回声服务器：</target>
        </trans-unit>
        <trans-unit id="ef991dbc6590a70e7dc7792c1502faa5b82544ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;logger#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warn&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">该&lt;a href=&quot;logger#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt;宏发在被提供的消息 &lt;code&gt;:info&lt;/code&gt; 级别。请注意，仅在记录消息时才会评估为&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;给出的参数。例如，如果Logger级别设置为 &lt;code&gt;:warn&lt;/code&gt; ，则 &lt;code&gt;:info&lt;/code&gt; 消息将永远不会被记录，因此上面给出的参数甚至不会被执行。</target>
        </trans-unit>
        <trans-unit id="3fb892be769329b47a3a72fea685384027a625eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">该&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块设计，可以处理给定的顺序监督员启动时开始大多是静态的孩子。一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;开始，没有子女。而是通过&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;按需启动子级。当动态主管终止时，所有子项都将同时关闭，而不能保证订购。</target>
        </trans-unit>
        <trans-unit id="26a12a273dc85b3ddb0a7cf7190ec7cccb61c0d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">该&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;模块使开发人员能够动态地创建多个监督任务。</target>
        </trans-unit>
        <trans-unit id="9f3bcdc6b0dacd5812de01049f85ba71ec9d986e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;1&lt;/code&gt; represents the first argument passed into the function. &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; above is exactly the same as &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt;. The syntax above is useful for short function definitions.</source>
          <target state="translated">的 &lt;code&gt;&amp;amp;1&lt;/code&gt; 代表传递到函数中的第一个参数。 &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; 与 &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt; 完全相同。上面的语法对于简短的函数定义很有用。</target>
        </trans-unit>
        <trans-unit id="462dea57799a704e8bdaa1d60d5f41548cf0ff70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used with more complex expressions:</source>
          <target state="translated">在 &lt;code&gt;&amp;amp;&lt;/code&gt; 运营商可以用更复杂的表达式中使用：</target>
        </trans-unit>
        <trans-unit id="8324a31beed435619f352d82babacf78e2ffed56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--source&lt;/code&gt; and &lt;code&gt;--sink&lt;/code&gt; options are particularly useful when trying to understand how the modules in a particular file interact with the whole system. You can combine those options with &lt;code&gt;--label&lt;/code&gt; and &lt;code&gt;--only-nodes&lt;/code&gt; to get all files that exhibit a certain property, for example:</source>
          <target state="translated">该 &lt;code&gt;--source&lt;/code&gt; 和 &lt;code&gt;--sink&lt;/code&gt; 试图了解在整个系统中的特定文件如何交互模块选项时特别有用。您可以将这些选项与 &lt;code&gt;--label&lt;/code&gt; 和 &lt;code&gt;--only-nodes&lt;/code&gt; 结合使用，以获取具有特定属性的所有文件，例如：</target>
        </trans-unit>
        <trans-unit id="da8c5a69e634407470f64de131f93cd85b1c1054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only the test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;--stale&lt;/code&gt; 命令行选项尝试只运行测试文件，因为我们是把这个任务与上次已经改变了参考模块 &lt;code&gt;--stale&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27914fb6ca74f78b539d08d503dae1d70d9876c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only those test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;--stale&lt;/code&gt; 命令行选项尝试运行只有那些测试文件，因为我们是把这个任务与上次已经改变了参考模块 &lt;code&gt;--stale&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df6e7ebae80eb329ea0918689120d554cb37f2c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; option is extremely useful for software iteration, allowing you to run only the relevant tests as you perform changes to the codebase.</source>
          <target state="translated">该 &lt;code&gt;--stale&lt;/code&gt; 选项是软件迭代非常有用，可以让你进行更改代码库，你只运行相关的测试。</target>
        </trans-unit>
        <trans-unit id="08ab3c233377a6ec13838eb8f093fb564ec02061" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. If you run the tests multiple times you may see this intermittent failure:</source>
          <target state="translated">当测试陷入僵局或存在竞争条件时，-- &lt;code&gt;--trace&lt;/code&gt; 选项很有用，因为它同步运行所有测试（ &lt;code&gt;async: true&lt;/code&gt; 无效），并显示有关每个测试的详细信息。如果您多次运行测试，则可能会看到此间歇性故障：</target>
        </trans-unit>
        <trans-unit id="70c59bbd77397d77a76b99b62c09d5b35df96a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. You may see one or two intermittent failures:</source>
          <target state="translated">当测试陷入僵局或存在竞争条件时，-- &lt;code&gt;--trace&lt;/code&gt; 选项很有用，因为它同步运行所有测试（ &lt;code&gt;async: true&lt;/code&gt; 无效）并显示有关每个测试的详细信息。您可能会看到一两个间歇性故障：</target>
        </trans-unit>
        <trans-unit id="bac163fa8c2566f186b54fd07de5c6d65f93af5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ascii&lt;/code&gt; mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</source>
          <target state="translated">的 &lt;code&gt;:ascii&lt;/code&gt; 模式忽略Unicode字符，并提供了更高性能的实现时，你知道该字符串只包含ASCII字符：</target>
        </trans-unit>
        <trans-unit id="05564ea628704e49dd4cc09651f569d44c1a82ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:crypto&lt;/code&gt; module is not part of the Erlang standard library, but is included with the Erlang distribution. This means you must list &lt;code&gt;:crypto&lt;/code&gt; in your project&amp;rsquo;s applications list whenever you use it. To do this, edit your &lt;code&gt;mix.exs&lt;/code&gt; file to include:</source>
          <target state="translated">的 &lt;code&gt;:crypto&lt;/code&gt; 模块不是二郎神标准库的一部分，但包含在Erlang分布。这意味着只要使用它，您就必须在项目的应用程序列表中列出 &lt;code&gt;:crypto&lt;/code&gt; 。为此，请编辑您的 &lt;code&gt;mix.exs&lt;/code&gt; 文件以包括：</target>
        </trans-unit>
        <trans-unit id="add3cf115e3a7915716bd93a5b79e1744ef2d173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:fd&lt;/code&gt; name option allows developers to access &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; file descriptors used by the Erlang VM. You would use those only if you are reimplementing core part of the Runtime System, such as the &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:shell&lt;/code&gt; processes.</source>
          <target state="translated">的 &lt;code&gt;:fd&lt;/code&gt; 名称选项允许开发者访问 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 由二郎山VM使用的文件描述符。仅在重新实现运行系统的核心部分（例如 &lt;code&gt;:user&lt;/code&gt; 和 &lt;code&gt;:shell&lt;/code&gt; 进程）时，才使用它们。</target>
        </trans-unit>
        <trans-unit id="3f6ac7a8b41e26b0d52e88d330fed22cf2cc2f20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; and &lt;code&gt;:uniq&lt;/code&gt; options</source>
          <target state="translated">的 &lt;code&gt;:into&lt;/code&gt; 和 &lt;code&gt;:uniq&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="0211bc3942dfba08cb46ef94332394518116ea6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; option</source>
          <target state="translated">的 &lt;code&gt;:into&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="a3988e2dcd8f368dd88c8ea1b7ec2bcd3100e56a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:label&lt;/code&gt; option is especially useful with pipelines:</source>
          <target state="translated">在 &lt;code&gt;:label&lt;/code&gt; 选项特别有用与管道：</target>
        </trans-unit>
        <trans-unit id="d03df649244dc7c63287f31c15a54de9bf6e2182" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mod&lt;/code&gt; option specifies the &amp;ldquo;application callback module&amp;rdquo;, followed by the arguments to be passed on application start. The application callback module can be any module that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;Application&lt;/a&gt; behaviour.</source>
          <target state="translated">的 &lt;code&gt;:mod&lt;/code&gt; 选项指定&amp;ldquo;应用回调模块&amp;rdquo;，随后的参数在应用程序启动通过。应用程序回调模块可以是实现&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;应用程序&lt;/a&gt;行为的任何模块。</target>
        </trans-unit>
        <trans-unit id="ebc92fad8b6ff75a2a9c584dbe63fcee1353d021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">也可以使用 &lt;code&gt;:name&lt;/code&gt; 选项来注册管理员名称，支持的值在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="869c20a77b331e475dc6550865b679c81c154f2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">也可以使用 &lt;code&gt;:name&lt;/code&gt; 选项来注册管理员名称，支持的值在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="9dd616361d3877df539a2d092f8aadb9d1c83008" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">的 &lt;code&gt;:name&lt;/code&gt; 选项也可以用来注册一个主管的名字。支持的值在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="2ccfdad6d1a6ed0b138742630a980b7e627021ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">的 &lt;code&gt;:name&lt;/code&gt; 选项也可以用来注册一个主管的名字。支持的值在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分下进行了描述。</target>
        </trans-unit>
        <trans-unit id="0be059e0f52bc117f0d9ac535f0ebaba535ffdbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option is used for registration as described in the module documentation.</source>
          <target state="translated">的 &lt;code&gt;:name&lt;/code&gt; 为模块文档中所述选项用于注册。</target>
        </trans-unit>
        <trans-unit id="9ae6a790ebfb15d6c60e22c6003dc079f27e1350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:persistent&lt;/code&gt; option can be set to &lt;code&gt;true&lt;/code&gt; when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">的 &lt;code&gt;:persistent&lt;/code&gt; 选项可以设置为 &lt;code&gt;true&lt;/code&gt; 时，有必要使用此功能设置不会因负载的应用程序资源文件中定义的那些被覆盖的保证参数。这意味着持久值将在应用程序加载后以及重新加载应用程序时保留。</target>
        </trans-unit>
        <trans-unit id="f0d1fdc494208ae6f6f718ee89ecd443e0ecaf7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reduce&lt;/code&gt; option</source>
          <target state="translated">的 &lt;code&gt;:reduce&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="fb3b286cd086eae72642832fb5a362f5110c1af4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:restart&lt;/code&gt; option controls what the supervisor should consider to be a successful termination or not. If the termination is successful, the supervisor won't restart the child. If the child process crashed, the supervisor will start a new one.</source>
          <target state="translated">的 &lt;code&gt;:restart&lt;/code&gt; 主管应该考虑哪些选项控制是成功的终止与否。如果终止成功，主管将不会重新启动子级。如果子进程崩溃，主管将启动一个新进程。</target>
        </trans-unit>
        <trans-unit id="21c211e6097ddfd5bc4a9bb4945fe2497ef06a6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, &lt;code&gt;:microsecond&lt;/code&gt; and &lt;code&gt;:nanosecond&lt;/code&gt; time units controls the return value of the functions that accept a time unit.</source>
          <target state="translated">的 &lt;code&gt;:second&lt;/code&gt; ， &lt;code&gt;:millisecond&lt;/code&gt; ， &lt;code&gt;:microsecond&lt;/code&gt; 和 &lt;code&gt;:nanosecond&lt;/code&gt; 时间单位控制的接受时间单位的功能的返回值。</target>
        </trans-unit>
        <trans-unit id="2027010005a9400e00a3f5e7626e15299c8de0f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:secret_key&lt;/code&gt; key under &lt;code&gt;:my_app&lt;/code&gt; will be computed on the host machine, whenever the release is built. Setting the &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; right before starting your release will have no effect.</source>
          <target state="translated">每当构建发行版时，就会在主机上计算 &lt;code&gt;:my_app&lt;/code&gt; 下的 &lt;code&gt;:secret_key&lt;/code&gt; 密钥。 &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; 开始发布之前设置MY_APP_SECRET_KEY无效。</target>
        </trans-unit>
        <trans-unit id="1fc77c6e40a992f998c561f03446c6642ec346ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:spawn&lt;/code&gt; tuple receives a binary that is going to be executed as a full invocation. For example, we can use it to invoke &quot;echo hello&quot; directly:</source>
          <target state="translated">的 &lt;code&gt;:spawn&lt;/code&gt; 元组接收即将作为一个完整的调用要执行的二进制文件。例如，我们可以使用它直接调用&amp;ldquo; echo hello&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="7b93bb4d3ff18560e52b37ae6c18a308889c8bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atom_encoder&lt;/code&gt; function</source>
          <target state="translated">的 &lt;code&gt;:static_atom_encoder&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="1e63d1877fcfa7f1cccde5219f1c0beb12c1d581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atoms_encoder&lt;/code&gt; function</source>
          <target state="translated">的 &lt;code&gt;:static_atoms_encoder&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="a4c229bf7cb4e00904018bc0adfca73eff22ebc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:steps&lt;/code&gt; option must be a list and it must always include the atom &lt;code&gt;:assemble&lt;/code&gt;, which does most of the release assembling. You can pass anonymous functions before and after the &lt;code&gt;:assemble&lt;/code&gt; to customize your release assembling pipeline. Those anonymous functions will receive a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct and must return the same or an updated &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct. It is also possible to build a tarball of the release by passing the &lt;code&gt;:tar&lt;/code&gt; step anywhere after &lt;code&gt;:assemble&lt;/code&gt;. If the release &lt;code&gt;:path&lt;/code&gt; is not configured, the tarball is created in &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; Otherwise it is created inside the configured &lt;code&gt;:path&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;:steps&lt;/code&gt; 选项必须是一个列表，并且必须始终包括原子 &lt;code&gt;:assemble&lt;/code&gt; ，这完成大部分释放组装。您可以在 &lt;code&gt;:assemble&lt;/code&gt; 之前和之后传递匿名函数，以自定义发布组装管道。这些匿名函数将接收&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt;结构，并且必须返回相同或更新的&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt;结构。也可以在 &lt;code&gt;:assemble&lt;/code&gt; 之后的任何地方通过 &lt;code&gt;:tar&lt;/code&gt; 步骤来构建发行版的压缩包。如果未配置release &lt;code&gt;:path&lt;/code&gt; ，则在 &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; 中创建压缩包。否则，它将在配置的 &lt;code&gt;:path&lt;/code&gt; 中创建。</target>
        </trans-unit>
        <trans-unit id="7852e9b0f6e5ea07cd2dd1ac64030694b4b9d2d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; is a required option and the currently supported value is &lt;code&gt;:one_for_one&lt;/code&gt;. The remaining options can be found in the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">的 &lt;code&gt;:strategy&lt;/code&gt; 是必需的选项，目前支持的值是 &lt;code&gt;:one_for_one&lt;/code&gt; 。其余选项可在&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;文档中找到。</target>
        </trans-unit>
        <trans-unit id="3ecf2c76d0e93dbfb5af69dd0e723a8fce1f3ba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">的 &lt;code&gt;:strategy&lt;/code&gt; 选项是必需的，并且默认最多3个重新启动的被允许在5秒内。检查&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块以获取有关可用策略的详细说明。</target>
        </trans-unit>
        <trans-unit id="39fdbe497bf489a09ea386b4627370ef6bf6b5e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">的 &lt;code&gt;:strategy&lt;/code&gt; 选项是必需的，并且默认最多3个重新启动的被允许在5秒内。检查&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块以获取有关可用策略的详细说明。</target>
        </trans-unit>
        <trans-unit id="4318a8c81e458ee0b9cf77340dadbaf79a290499" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">的 &lt;code&gt;:strategy&lt;/code&gt; 选项是必需的，并且默认最多3个重新启动的被允许在5秒内。检查&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块以获取有关可用策略的详细说明。</target>
        </trans-unit>
        <trans-unit id="6fd3d939dbec7e219780c6a3622d4fe572215853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_coverage&lt;/code&gt; configuration accepts the following options:</source>
          <target state="translated">的 &lt;code&gt;:test_coverage&lt;/code&gt; 配置接受以下选项：</target>
        </trans-unit>
        <trans-unit id="ad9818925ace018f87e1927334e33ca1a365e0b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;em&gt;not&lt;/em&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">的 &lt;code&gt;:test_type&lt;/code&gt; 标签由ExUnit自动设置，但&lt;em&gt;不&lt;/em&gt;保留。用户可以根据需要定制此标签。</target>
        </trans-unit>
        <trans-unit id="34f5e1a838ff9cda2c11258cd3b2a863cbdf176f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;strong&gt;not&lt;/strong&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">的 &lt;code&gt;:test_type&lt;/code&gt; 标签由ExUnit自动设置，但&lt;strong&gt;不&lt;/strong&gt;保留。用户可以根据需要定制此标签。</target>
        </trans-unit>
        <trans-unit id="9ea129091dfbd99c2a530d95ef2783ebbf81e5ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:tracers&lt;/code&gt; compiler option can be combined with the &lt;code&gt;:parser_options&lt;/code&gt; compiler option to enrich the metadata of the traced events above.</source>
          <target state="translated">的 &lt;code&gt;:tracers&lt;/code&gt; 编译器选项可以与组合 &lt;code&gt;:parser_options&lt;/code&gt; 编译器选项来充实上述跟踪的事件的元数据。</target>
        </trans-unit>
        <trans-unit id="0bb936c2d2f36ac2f8066e21c586a6fb2a08b1b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@&lt;/code&gt; macro compiles to a call to this function. For example, the following code:</source>
          <target state="translated">该 &lt;code&gt;@&lt;/code&gt; 宏编译到这个函数的调用。例如，以下代码：</target>
        </trans-unit>
        <trans-unit id="4db7ff3247782ab9520366b88d96d14d1712fe6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@optional_callbacks&lt;/code&gt; attributes are used to create a &lt;code&gt;behaviour_info/1&lt;/code&gt; function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module.</source>
          <target state="translated">的 &lt;code&gt;@callback&lt;/code&gt; 和 &lt;code&gt;@optional_callbacks&lt;/code&gt; 属性用于创建 &lt;code&gt;behaviour_info/1&lt;/code&gt; 的定义模块上可用的功能。此函数可用于检索该模块定义的回调和可选回调。</target>
        </trans-unit>
        <trans-unit id="5131f63d4a847e5310d4b0da9f690cbf2653c391" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@compile&lt;/code&gt; attribute accepts different options that are used by both Elixir and Erlang compilers. Some of the common use cases are documented below:</source>
          <target state="translated">所述 &lt;code&gt;@compile&lt;/code&gt; 属性接受由两个药剂和Erlang编译器使用不同的选择。下面记录了一些常见用例：</target>
        </trans-unit>
        <trans-unit id="9c96b72a2b5229c84ff37173dda7b65a784fe244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; annotation immediately preceding &lt;code&gt;use Supervisor&lt;/code&gt; will be attached to the generated &lt;code&gt;child_spec/1&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 之前的 &lt;code&gt;@doc&lt;/code&gt; 批注将附加到生成的 &lt;code&gt;child_spec/1&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c2548a73a793d075044328d72e23f487f2153196" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@moduledoc&lt;/code&gt; attribute is used to add documentation to the module. &lt;code&gt;@doc&lt;/code&gt; is used before a function to provide documentation for it. Besides the attributes above, &lt;code&gt;@typedoc&lt;/code&gt; can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to &lt;code&gt;@doc&lt;/code&gt; and friends.</source>
          <target state="translated">该 &lt;code&gt;@moduledoc&lt;/code&gt; 属性用于文档添加到模块。在功能提供文档之前使用 &lt;code&gt;@doc&lt;/code&gt; 。除了上述属性外， &lt;code&gt;@typedoc&lt;/code&gt; 还可以用于将文档附加到定义为typespec一部分的类型上。通过将关键字列表传递给 &lt;code&gt;@doc&lt;/code&gt; 和朋友，Elixir还允许将元数据附加到文档中。</target>
        </trans-unit>
        <trans-unit id="5c4c9561309d3048192c645c1b53867cd58046c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@spec&lt;/code&gt; above expresses that all types allowed to implement the given protocol are valid argument types for the given function.</source>
          <target state="translated">上面的 &lt;code&gt;@spec&lt;/code&gt; 表示允许实现给定协议的所有类型都是给定函数的有效参数类型。</target>
        </trans-unit>
        <trans-unit id="4ecf8bb424c804cabf2a64179dad99d91c08aa50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@type&lt;/code&gt;, &lt;code&gt;@typep&lt;/code&gt;, and &lt;code&gt;@opaque&lt;/code&gt; module attributes can be used to define new types:</source>
          <target state="translated">的 &lt;code&gt;@type&lt;/code&gt; ， &lt;code&gt;@typep&lt;/code&gt; 和 &lt;code&gt;@opaque&lt;/code&gt; 模块属性可以用于定义新类型：</target>
        </trans-unit>
        <trans-unit id="525e602ced98f13bd5ecaf2f8ae5f13ce9d11d61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; attribute, similar to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; attributes, is used to document custom types.</source>
          <target state="translated">的 &lt;code&gt;@typedoc&lt;/code&gt; 属性，类似于 &lt;code&gt;@doc&lt;/code&gt; 和 &lt;code&gt;@moduledoc&lt;/code&gt; 属性，用于文件的自定义类型。</target>
        </trans-unit>
        <trans-unit id="923172e1b194c31095f6b50cc3fcf7cd6864f7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; directive, similarly to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; directives, is used to document custom types.</source>
          <target state="translated">该 &lt;code&gt;@typedoc&lt;/code&gt; 指令，类似于 &lt;code&gt;@doc&lt;/code&gt; 和 &lt;code&gt;@moduledoc&lt;/code&gt; 指令，用于文件自定义类型。</target>
        </trans-unit>
        <trans-unit id="a562fb60ef30731bd3203cf4bbff217d46bc1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as a second argument any function that receives one argument and returns a value:</source>
          <target state="translated">所述 &lt;code&gt;Agent.update/3&lt;/code&gt; 函数接受作为第二个参数，其接收一个参数，并返回值的任何函数：</target>
        </trans-unit>
        <trans-unit id="a63341783e3511427fe146f8a19ffd92af29382f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as second argument any function that receives one argument and returns a value:</source>
          <target state="translated">所述 &lt;code&gt;Agent.update/3&lt;/code&gt; 函数接受作为第二个参数，其接收一个参数，并返回值的任何函数：</target>
        </trans-unit>
        <trans-unit id="7a655503d2990c75edcb4c8b8a481ab364d1c5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config&lt;/code&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">Elixir中的 &lt;code&gt;Config&lt;/code&gt; 模块是在v1.9中引入的，以替代&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt;，它是Mix特有的，已被弃用。</target>
        </trans-unit>
        <trans-unit id="e27fe58053aba859d0bb7d011fc28980f6e9c181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Enum&lt;/code&gt; module provides a huge range of functions to transform, sort, group, filter and retrieve items from enumerables. It is one of the modules developers use frequently in their Elixir code.</source>
          <target state="translated">该 &lt;code&gt;Enum&lt;/code&gt; 模块提供了巨大的函数来变换，排序，分组过滤器和检索可枚举项范围。它是开发人员在其Elixir代码中经常使用的模块之一。</target>
        </trans-unit>
        <trans-unit id="1d4fbc9808f8e26c00c234d6fa1459002dc186de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;File&lt;/code&gt; module</source>
          <target state="translated">该 &lt;code&gt;File&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="e840334dc33e37be12e55cfa6bc3b7e8c169342a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO&lt;/code&gt; module</source>
          <target state="translated">在 &lt;code&gt;IO&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="ef38704061a34457ddb379b41a2b80be49207a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Inspect&lt;/code&gt; protocol is the protocol used to transform any data structure into a readable textual representation. This is what tools like IEx use to print results:</source>
          <target state="translated">的 &lt;code&gt;Inspect&lt;/code&gt; 协议是用于任何数据结构转换成一个可读文本表示的协议。这就是IEx等工具用来打印结果的方式：</target>
        </trans-unit>
        <trans-unit id="867c539e4d21456c5aa36b2d220867f9a7212a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;KV.RouterTest&lt;/code&gt; truly has to be distributed, as its purpose is to test the distribution. However, the test in &lt;code&gt;KVServerTest&lt;/code&gt; was only made distributed because we had a hardcoded distributed routing table, which we couldn&amp;rsquo;t configure, but now we can!</source>
          <target state="translated">该 &lt;code&gt;KV.RouterTest&lt;/code&gt; 真正有分布，其目的是测试的分布。但是， &lt;code&gt;KVServerTest&lt;/code&gt; 中的测试只是进行分布式的，因为我们有一个硬编码的分布式路由表，我们无法配置它，但是现在我们可以了！</target>
        </trans-unit>
        <trans-unit id="98cbbae17162ecee1b3987ff4642880f4c337dca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyApp&lt;/code&gt; module given to &lt;code&gt;:mod&lt;/code&gt; needs to implement the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; behaviour. This can be done by putting &lt;code&gt;use Application&lt;/code&gt; in that module and implementing the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback, for example:</source>
          <target state="translated">赋予 &lt;code&gt;:mod&lt;/code&gt; 的 &lt;code&gt;MyApp&lt;/code&gt; 模块需要实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;行为。这可以通过在该模块中 &lt;code&gt;use Application&lt;/code&gt; 并实现&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调来完成，例如：</target>
        </trans-unit>
        <trans-unit id="eb345c09eb20de824e9541a17d7bf17e012b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; module</source>
          <target state="translated">该 &lt;code&gt;Path&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="c334edecfba6073bd7010af2e40dba91546f5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol can now be implemented for &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;Size&lt;/code&gt; 的协议现在可以为实现 &lt;code&gt;Any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e306d6fedad75e62089879bf19da4f3ec37aa79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol expects a function called &lt;code&gt;size&lt;/code&gt; that receives one argument (the data structure we want to know the size of) to be implemented. We can now implement this protocol for the data structures that would have a compliant implementation:</source>
          <target state="translated">该 &lt;code&gt;Size&lt;/code&gt; 协议需要一个函数调用 &lt;code&gt;size&lt;/code&gt; 接收一个参数来实现（我们想知道的大小的数据结构）。现在，我们可以为具有兼容实现的数据结构实现此协议：</target>
        </trans-unit>
        <trans-unit id="db5fefc34081f3a8d848c3114be6230d0555c05c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression:</source>
          <target state="translated">的 &lt;code&gt;User switch command&lt;/code&gt; 还可以用于当评价者在一个无限循环卡住或终止现有的会话，例如，当你被卡住打字的表达式：</target>
        </trans-unit>
        <trans-unit id="7f41e81f3757a1435933e38bc5bfe28881ade0a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; menu also allows developers to connect to remote shells using the &lt;code&gt;r&lt;/code&gt; command. A topic which we will discuss next.</source>
          <target state="translated">的 &lt;code&gt;User switch command&lt;/code&gt; 菜单还允许开发者连接到使用远程壳 &lt;code&gt;r&lt;/code&gt; 命令。接下来我们将讨论一个主题。</target>
        </trans-unit>
        <trans-unit id="57c1d154dd951f8282bee6bdc6065d02cb12023d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[head | tail]&lt;/code&gt; format is not only used on pattern matching but also for prepending items to a list:</source>
          <target state="translated">在 &lt;code&gt;[head | tail]&lt;/code&gt; 格式不仅用于模式匹配，还用于在列表前添加项目：</target>
        </trans-unit>
        <trans-unit id="fd1f98818191e0504c9112dc757cd520cf41584f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause can be specified even if there are no match clauses. The timeout value given to &lt;code&gt;after&lt;/code&gt; can be any expression evaluating to one of the allowed values:</source>
          <target state="translated">在 &lt;code&gt;after&lt;/code&gt; 条款即使没有match子句指定。 &lt;code&gt;after&lt;/code&gt; 给出的超时值可以是任何计算为允许值之一的表达式：</target>
        </trans-unit>
        <trans-unit id="d4dc8c4ed1d9e88f4741236f5ec92ee315c9d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause will be executed regardless of whether or not the tried block succeeds. Note, however, that if a linked process exits, this process will exit and the &lt;code&gt;after&lt;/code&gt; clause will not get run. Thus &lt;code&gt;after&lt;/code&gt; provides only a soft guarantee. Luckily, files in Elixir are also linked to the current processes and therefore they will always get closed if the current process crashes, independent of the &lt;code&gt;after&lt;/code&gt; clause. You will find the same to be true for other resources like ETS tables, sockets, ports and more.</source>
          <target state="translated">在 &lt;code&gt;after&lt;/code&gt; 子句将不管尝试块是否成功执行。但是请注意，如果退出链接的进程，则该进程将退出，并且 &lt;code&gt;after&lt;/code&gt; 子句将不会运行。因此 &lt;code&gt;after&lt;/code&gt; 仅提供了软保证。幸运的是，Elixir中的文件也链接到当前进程，因此，如果当前进程崩溃，它们将始终关闭，而与 &lt;code&gt;after&lt;/code&gt; 子句无关。对于其他资源（例如ETS表，套接字，端口等），您将发现同样的情况。</target>
        </trans-unit>
        <trans-unit id="522546706684271ab3f2efbb350890fbe1239f1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assigns&lt;/code&gt; extension is useful when the number of variables required by the template is not specified at compilation time.</source>
          <target state="translated">该 &lt;code&gt;assigns&lt;/code&gt; 时，在编译时没有指定由模板所需的变量数扩展是非常有用的。</target>
        </trans-unit>
        <trans-unit id="20b542c507c9f404606e6129f6dd5795d8b21d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a keyword list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">该 &lt;code&gt;binding&lt;/code&gt; 参数是一个变量绑定关键字列表。该 &lt;code&gt;opts&lt;/code&gt; 参数是环境选择的关键字列表。</target>
        </trans-unit>
        <trans-unit id="f9ca71e42e6855918a8f26e42f0cc7edcc80187e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">该 &lt;code&gt;binding&lt;/code&gt; 参数是一个变量绑定列表。该 &lt;code&gt;opts&lt;/code&gt; 参数是环境选择的关键字列表。</target>
        </trans-unit>
        <trans-unit id="43af9d9f02afe40e3a624713286d4df36015f946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports &lt;code&gt;:error&lt;/code&gt; alongside &lt;code&gt;:exit&lt;/code&gt; and &lt;code&gt;:throw&lt;/code&gt; as in Erlang, although this is commonly avoided in favor of &lt;code&gt;raise&lt;/code&gt;/&lt;code&gt;rescue&lt;/code&gt; control mechanisms. One reason for this is that when catching &lt;code&gt;:error&lt;/code&gt;, the error is not automatically transformed into an Elixir error:</source>
          <target state="translated">该 &lt;code&gt;catch&lt;/code&gt; 条款还支持 &lt;code&gt;:error&lt;/code&gt; 旁边 &lt;code&gt;:exit&lt;/code&gt; 和 &lt;code&gt;:throw&lt;/code&gt; 在二郎，尽管这通常有利于避免 &lt;code&gt;raise&lt;/code&gt; / &lt;code&gt;rescue&lt;/code&gt; 控制机制。原因之一是在捕获 &lt;code&gt;:error&lt;/code&gt; 时，该错误不会自动转换为Elixir错误：</target>
        </trans-unit>
        <trans-unit id="efeea9a7b42fc8c994bd1aa663c47cac8fa65f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports catching exits and errors. To do that, it allows matching on both the &lt;em&gt;kind&lt;/em&gt; of the caught value as well as the value itself:</source>
          <target state="translated">该 &lt;code&gt;catch&lt;/code&gt; 条款还支持捕捉退出和错误。为此，它允许匹配所捕获值的&lt;em&gt;种类&lt;/em&gt;以及值本身：</target>
        </trans-unit>
        <trans-unit id="24330da6829bfcedd43d719e9d8c6b8cc77a9453" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values, exits, and errors.</source>
          <target state="translated">该 &lt;code&gt;catch&lt;/code&gt; 子句可以用来捕获抛出值，退出和错误。</target>
        </trans-unit>
        <trans-unit id="8d2397a8238f753aef5def5de423d0f7288e2079" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;child_spec/1&lt;/code&gt; function returns the child specification which describes how to start the process, if the process is a worker or a supervisor, if the process is temporary, transient or permanent and so on. The &lt;code&gt;child_spec/1&lt;/code&gt; function is automatically defined when we &lt;code&gt;use Agent&lt;/code&gt;, &lt;code&gt;use GenServer&lt;/code&gt;, &lt;code&gt;use Supervisor&lt;/code&gt;, etc. Let&amp;rsquo;s give it a try in the terminal with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;child_spec/1&lt;/code&gt; 函数返回描述了如何启动这一进程，如果该进程是工人或主管，如果该进程是暂时的，暂时或永久的，因此对孩子的规范。该 &lt;code&gt;child_spec/1&lt;/code&gt; ，当我们功能将被自动定义 &lt;code&gt;use Agent&lt;/code&gt; ， &lt;code&gt;use GenServer&lt;/code&gt; ， &lt;code&gt;use Supervisor&lt;/code&gt; 等让我们给它的终端有一个尝试 &lt;code&gt;iex -S mix&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5076e4aa7f98418aab62c50ce92daa399ad148af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime&lt;/code&gt; is expected to be using the ISO calendar with a year greater than or equal to 0.</source>
          <target state="translated">该 &lt;code&gt;datetime&lt;/code&gt; 预计将使用与上年大于或等于0的ISO日历。</target>
        </trans-unit>
        <trans-unit id="a7470ce899e96bb2d28a9c1301a9927e4e0d7efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;device&lt;/code&gt; 是由字节或线的给定数目的迭代，如果由线 &lt;code&gt;:line&lt;/code&gt; 给出。或者，如果给出 &lt;code&gt;:all&lt;/code&gt; ，则返回整个 &lt;code&gt;device&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18926bc10cd79bf34225eb9fdce31365b1c6d418" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. This reads from the IO device as a raw binary.</source>
          <target state="translated">该 &lt;code&gt;device&lt;/code&gt; 是由字节或线的给定数目的迭代，如果由线 &lt;code&gt;:line&lt;/code&gt; 给出。这将从IO设备读取为原始二进制文件。</target>
        </trans-unit>
        <trans-unit id="d123d0b725ad2bf46d13d4f89ecd59664f74da3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given.</source>
          <target state="translated">该 &lt;code&gt;device&lt;/code&gt; 是由字符或线的给定数目的迭代，如果由线 &lt;code&gt;:line&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="8d73a8d9622fd3342e8e37363bb8e4678e91ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">该 &lt;code&gt;device&lt;/code&gt; 是由字符或线的给定数目的迭代，如果由线 &lt;code&gt;:line&lt;/code&gt; 给出。或者，如果给出 &lt;code&gt;:all&lt;/code&gt; ，则返回整个 &lt;code&gt;device&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd6d16ba352ae3e2cd0c595b6f985cf5e9830dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do:&lt;/code&gt; and &lt;code&gt;else:&lt;/code&gt; pairs form a keyword list! In fact, the call above is equivalent to:</source>
          <target state="translated">该 &lt;code&gt;do:&lt;/code&gt; 和 &lt;code&gt;else:&lt;/code&gt; 对形成一个关键字列表！实际上，上面的调用等效于：</target>
        </trans-unit>
        <trans-unit id="814c3b44f539cbabd4a18b1a20149ed63266fd5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doctest&lt;/code&gt; macro loops through all functions and macros defined in &lt;code&gt;MyModule&lt;/code&gt;, parsing their documentation in search of code examples.</source>
          <target state="translated">该 &lt;code&gt;doctest&lt;/code&gt; 过的所有功能和宏宏循环中定义 &lt;code&gt;MyModule&lt;/code&gt; 中，解析其文档中搜索的代码示例。</target>
        </trans-unit>
        <trans-unit id="c8fc7f9dce0c33872417dd46af42c25ac3d59fce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; is used to set environment variables. In there, you can set vars such as &lt;code&gt;RELEASE_NODE&lt;/code&gt;, &lt;code&gt;RELEASE_COOKIE&lt;/code&gt;, and &lt;code&gt;RELEASE_TMP&lt;/code&gt; to customize your node name, cookie and tmp directory respectively. Whenever &lt;code&gt;env.sh&lt;/code&gt; or &lt;code&gt;env.bat&lt;/code&gt; is invoked, the variables &lt;code&gt;RELEASE_ROOT&lt;/code&gt;, &lt;code&gt;RELEASE_NAME&lt;/code&gt;, &lt;code&gt;RELEASE_VSN&lt;/code&gt;, and &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; have already been set, so you can rely on them. See the section on environment variables for more information.</source>
          <target state="translated">该 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 文件来设置环境变量。您可以在其中设置 &lt;code&gt;RELEASE_NODE&lt;/code&gt; ， &lt;code&gt;RELEASE_COOKIE&lt;/code&gt; 和 &lt;code&gt;RELEASE_TMP&lt;/code&gt; 之类的var ，以分别自定义节点名称，cookie和tmp目录。每当调用 &lt;code&gt;env.sh&lt;/code&gt; 或 &lt;code&gt;env.bat&lt;/code&gt; 时，都已经设置了变量 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; ， &lt;code&gt;RELEASE_NAME&lt;/code&gt; ， &lt;code&gt;RELEASE_VSN&lt;/code&gt; 和 &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; ，因此您可以依靠它们。有关更多信息，请参见环境变量部分。</target>
        </trans-unit>
        <trans-unit id="d34a58294096caa28e71e9a15e38240b2916397f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; command starts its own instance of the VM but without starting any of the applications in the release and without starting distribution. For example, if you need to do some prep work before running the actual system, like migrating your database, &lt;code&gt;eval&lt;/code&gt; can be a good fit. Just keep in mind any application you may use during eval has to be explicitly loaded and/or started.</source>
          <target state="translated">该 &lt;code&gt;eval&lt;/code&gt; 命令启动它自己的虚拟机，但没有任何开始在发布的应用程序和不启动分配实例。例如，如果您需要在运行实际系统之前做一些准备工作，例如迁移数据库，那么 &lt;code&gt;eval&lt;/code&gt; 可能很合适。请记住，必须在eval期间显式加载和/或启动您可能使用的任何应用程序。</target>
        </trans-unit>
        <trans-unit id="d7d3bd404eb61a5ace38bb205d91cc9fe9dacd66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; argument is usually a keyword list with field names as atom keys and default values as corresponding values. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;fields&lt;/code&gt; 参数通常是一个关键字列表与字段名称为原子键和默认值作为相应的值。&lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;还支持原子列表作为其参数：在这种情况下，列表中的原子将用作结构的字段名称，并且它们都默认为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f8139dc2ac79685ca13901ec7c7e0bf0f70fcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;container&lt;/code&gt;) and must return a two-element tuple &lt;code&gt;{get_value, update_value}&lt;/code&gt;: the &quot;get&quot; value &lt;code&gt;get_value&lt;/code&gt; (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; (&lt;code&gt;update_value&lt;/code&gt;). &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value should be removed from the container and returned.</source>
          <target state="translated">的 &lt;code&gt;fun&lt;/code&gt; 参数接收的值 &lt;code&gt;key&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; 如果 &lt;code&gt;key&lt;/code&gt; 不存在 &lt;code&gt;container&lt;/code&gt; ），并且必须返回一个两元素的元组 &lt;code&gt;{get_value, update_value}&lt;/code&gt; ：&amp;ldquo;获取&amp;rdquo;值 &lt;code&gt;get_value&lt;/code&gt; （检索到的值，可以在之前被操作返回值）和要存储在 &lt;code&gt;key&lt;/code&gt; （ &lt;code&gt;update_value&lt;/code&gt; ）下的新值。 &lt;code&gt;fun&lt;/code&gt; 也可能返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值应该从容器中删除并返回。</target>
        </trans-unit>
        <trans-unit id="ab82e984fadbbf0154d9f589974323854d91ddd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return one of the following values:</source>
          <target state="translated">的 &lt;code&gt;fun&lt;/code&gt; 参数接收的值 &lt;code&gt;key&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; 如果 &lt;code&gt;key&lt;/code&gt; 是不存在的），并且必须返回下列值之一：</target>
        </trans-unit>
        <trans-unit id="15ae90181c3399df6f57363e86986a58cdd69c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inspect/1&lt;/code&gt; function is used to convert a data structure&amp;rsquo;s internal representation into a string, typically for printing. Notice that when the &lt;code&gt;receive&lt;/code&gt; block gets executed the sender process we have spawned may already be dead, as its only instruction was to send a message.</source>
          <target state="translated">所述 &lt;code&gt;inspect/1&lt;/code&gt; 功能用于数据结构的内部表示转换成一个字符串，典型地用于印刷。请注意，当执行 &lt;code&gt;receive&lt;/code&gt; 块时，我们产生的发送者进程可能已经死了，因为它的唯一指令是发送消息。</target>
        </trans-unit>
        <trans-unit id="409be34f87b611c8cf8263c5eb6c08385aeb1ddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;install&lt;/code&gt; command must be executed as an administrator.</source>
          <target state="translated">在 &lt;code&gt;install&lt;/code&gt; 命令必须以管理员身份来执行。</target>
        </trans-unit>
        <trans-unit id="b4ef8eb0a2e7ca9a57a606a0bc63171348ce16a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated and &lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;all protocols were consolidated as described in the Getting Started guide&lt;/a&gt;. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;lib/kv.ex&lt;/code&gt; 文件编译，应用程序清单名为 &lt;code&gt;kv.app&lt;/code&gt; 生成并&lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;作为入门指南中描述的被合并的所有协议&lt;/a&gt;。使用 &lt;code&gt;mix.exs&lt;/code&gt; 文件中定义的选项，所有编译工件都放在 &lt;code&gt;_build&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="afab5577848b6315338da48841f3a29c305f64dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;lib/kv.ex&lt;/code&gt; 文件编译，清单名为应用 &lt;code&gt;kv.app&lt;/code&gt; 生成。使用 &lt;code&gt;mix.exs&lt;/code&gt; 文件中定义的选项，所有编译工件都放在 &lt;code&gt;_build&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="fb93b5ae3cb838786493785c00bd4b6f99477ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line_or_bytes&lt;/code&gt; argument configures how the file is read when streaming, by &lt;code&gt;:line&lt;/code&gt; (default) or by a given number of bytes.</source>
          <target state="translated">该 &lt;code&gt;line_or_bytes&lt;/code&gt; 论点提供配置如何流时，通过读取文件 &lt;code&gt;:line&lt;/code&gt; （默认）或字节的给定数。</target>
        </trans-unit>
        <trans-unit id="fe606eea5a853797263dc491beb562e8cbcc73c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logger&lt;/code&gt; application ships as part of Elixir. We stated that our application needs it by specifying it in the &lt;code&gt;:extra_applications&lt;/code&gt; list in &lt;code&gt;mix.exs&lt;/code&gt;. See the &lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;official docs&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;logger&lt;/code&gt; 应用程序使用的药剂的一部分。我们通过在 &lt;code&gt;mix.exs&lt;/code&gt; 的 &lt;code&gt;:extra_applications&lt;/code&gt; 列表中指定它来声明我们的应用程序需要它。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;官方文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54af23949bca7ed78e1b2333920d90c038af7ad6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mix test&lt;/code&gt; command also allows us to dynamically include and exclude tags. For example, we can run &lt;code&gt;$ mix test --include distributed&lt;/code&gt; to run distributed tests regardless of the value set in &lt;code&gt;test/test_helper.exs&lt;/code&gt;. We could also pass &lt;code&gt;--exclude&lt;/code&gt; to exclude a particular tag from the command line. Finally, &lt;code&gt;--only&lt;/code&gt; can be used to run only tests with a particular tag:</source>
          <target state="translated">该 &lt;code&gt;mix test&lt;/code&gt; 命令也允许我们动态地包括和排除标记。例如，无论 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 中设置的值如何，我们都可以运行 &lt;code&gt;$ mix test --include distributed&lt;/code&gt; 运行分布式测试。我们还可以传递 &lt;code&gt;--exclude&lt;/code&gt; 来从命令行中排除特定标签。最后，-- &lt;code&gt;--only&lt;/code&gt; 仅可用于运行带有特定标记的测试：</target>
        </trans-unit>
        <trans-unit id="75c3e7f0c2115829278fc15321400f8791e52369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mod&lt;/code&gt; key of an application resource file configures an application callback module and start argument:</source>
          <target state="translated">应用程序资源文件的 &lt;code&gt;mod&lt;/code&gt; 键配置应用程序回调模块和start参数：</target>
        </trans-unit>
        <trans-unit id="9164f612584725a4293d48491d9ba4d200ea917a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;也支持此函数接收的 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cefbaf0f99d8706ada7dd49301877753ff097956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;也支持此函数接收的 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64284a2724bf8bf1be42ef3f1c05bbea72ce9fee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is not received.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 参数必须是一个匹配模式。如果未收到消息匹配 &lt;code&gt;pattern&lt;/code&gt; ， &lt;code&gt;failure_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="306d8664f10996ce7979609652732704d345ac55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is received.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 参数必须是一个匹配模式。如果接收到消息匹配 &lt;code&gt;pattern&lt;/code&gt; ， &lt;code&gt;failure_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0b8cb821a5d5214e8e6bc4e51c9c7ff6f736aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was not received.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 参数必须是一个匹配模式。如果未收到消息匹配 &lt;code&gt;pattern&lt;/code&gt; ， &lt;code&gt;failure_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05af0549cba6832bb035eed4973d7149b45f6ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was received.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 参数必须是一个匹配模式。如果接收到消息匹配 &lt;code&gt;pattern&lt;/code&gt; ， &lt;code&gt;failure_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df3b9d4931bcfe8e3dcb9ad739101300cbf08327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a list of strings, a regular expression, or a compiled pattern.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 可以是字符串，字符串列表，正则表达式或已编译模式。</target>
        </trans-unit>
        <trans-unit id="9712132d8ecb090f4be0f4f06a8c889cede54cae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a regular expression, or a compiled pattern.</source>
          <target state="translated">该 &lt;code&gt;pattern&lt;/code&gt; 可以是字符串，正则表达式或编译模式。</target>
        </trans-unit>
        <trans-unit id="f1e822b0c23d86ef4a2e7320c3e2f68f5b6a5886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_line/1&lt;/code&gt; implementation receives data from the socket using &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; and &lt;code&gt;write_line/2&lt;/code&gt; writes to the socket using &lt;code&gt;:gen_tcp.send/2&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;read_line/1&lt;/code&gt; 执行从使用该套接字接收数据 &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 和 &lt;code&gt;write_line/2&lt;/code&gt; 写入使用套接字 &lt;code&gt;:gen_tcp.send/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4738ad60c532661639b80291c79bbfd95de51f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replacement&lt;/code&gt; may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata.</source>
          <target state="translated">所述 &lt;code&gt;replacement&lt;/code&gt; 可以是字符串或接收匹配的模式，并且不能返回替换为字符串或iodata的功能。</target>
        </trans-unit>
        <trans-unit id="9c0458fa683a21c30d6bb8dd696e33377e0fc149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rescue&lt;/code&gt; clause is used to handle exceptions while the &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values and exits. The &lt;code&gt;else&lt;/code&gt; clause can be used to control flow based on the result of the expression. &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; clauses work based on pattern matching (similar to the &lt;code&gt;case&lt;/code&gt; special form).</source>
          <target state="translated">该 &lt;code&gt;rescue&lt;/code&gt; 条款来处理异常，而 &lt;code&gt;catch&lt;/code&gt; 子句可以用来捕获抛出值并退出。的 &lt;code&gt;else&lt;/code&gt; 条款可以基于表达式的结果被用于控制流。 &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;rescue&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 子句基于模式匹配（类似于 &lt;code&gt;case&lt;/code&gt; 特殊形式）工作。</target>
        </trans-unit>
        <trans-unit id="8d1df58d3bea703fd1bbf8c012df285de49b968d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup_all&lt;/code&gt; callbacks are invoked only once per module, before any test is run. All &lt;code&gt;setup&lt;/code&gt; callbacks are run before each test. No callback is run if the test case has no tests or all tests have been filtered out.</source>
          <target state="translated">在运行任何测试之前，每个模块仅调用一次 &lt;code&gt;setup_all&lt;/code&gt; 回调。所有 &lt;code&gt;setup&lt;/code&gt; 回调均在每次测试之前运行。如果测试用例没有测试或所有测试都被过滤掉，则不运行回调。</target>
        </trans-unit>
        <trans-unit id="bd0f9431cca0c37985b6fe072752b25bee336f01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns &lt;code&gt;:ok&lt;/code&gt; if retrieving the &lt;code&gt;size&lt;/code&gt; of the &lt;code&gt;enumerable&lt;/code&gt; is cheap, fast and takes constant time. Otherwise the simplest of operations, such as &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt;, will become too expensive.</source>
          <target state="translated">在 &lt;code&gt;size&lt;/code&gt; 这个函数返回值用于边界检查，因此它是非常重要的，这个函数只返回 &lt;code&gt;:ok&lt;/code&gt; ，如果检索 &lt;code&gt;size&lt;/code&gt; 的的 &lt;code&gt;enumerable&lt;/code&gt; 便宜，速度快，需要一定的时间。否则，最简单的操作（例如 &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt; 将变得过于昂贵。</target>
        </trans-unit>
        <trans-unit id="c3101c570b674a9ec75b76ebada532649060afec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spec&lt;/code&gt; consists of a list of three part tuples, in the shape of &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;spec&lt;/code&gt; 包括三个部分的元组列表，在形状 &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="135f720ae9d7a6885e26e8bce732a1ea91412353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; position is a number &lt;code&gt;&amp;gt;= 0&lt;/code&gt; and guaranteed to exist in the &lt;code&gt;enumerable&lt;/code&gt;. The length is a number &lt;code&gt;&amp;gt;= 1&lt;/code&gt; in a way that &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt;, where &lt;code&gt;count&lt;/code&gt; is the maximum amount of elements in the enumerable.</source>
          <target state="translated">的 &lt;code&gt;start&lt;/code&gt; 位置是编号 &lt;code&gt;&amp;gt;= 0&lt;/code&gt; ，并保证在存在 &lt;code&gt;enumerable&lt;/code&gt; 。长度是 &lt;code&gt;&amp;gt;= 1&lt;/code&gt; 的数字，以 &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt; 的方式表示，其中 &lt;code&gt;count&lt;/code&gt; 是可枚举元素的最大数量。</target>
        </trans-unit>
        <trans-unit id="e168d9178d44f7f46283a9cdf56615be6a7637ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_link/1&lt;/code&gt; (or a custom) is then called for each child process. The &lt;code&gt;start_link/1&lt;/code&gt; function must return &lt;code&gt;{:ok, pid}&lt;/code&gt; where &lt;code&gt;pid&lt;/code&gt; is the process identifier of a new process that is linked to the supervisor. The child process usually starts its work by executing the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback. Generally speaking, the &lt;code&gt;init&lt;/code&gt; callback is where we initialize and configure the child process.</source>
          <target state="translated">所述 &lt;code&gt;start_link/1&lt;/code&gt; 然后（或自定义）被调用用于每个子进程。所述 &lt;code&gt;start_link/1&lt;/code&gt; 函数必须返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 其中 &lt;code&gt;pid&lt;/code&gt; 是链接到管理新的进程的进程标识符。子进程通常通过执行&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调开始其工作。一般来说， &lt;code&gt;init&lt;/code&gt; 回调是我们初始化和配置子进程的地方。</target>
        </trans-unit>
        <trans-unit id="a8a0cec068e183c964ba134c5b70d885df25681c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_supervised!&lt;/code&gt; function was injected into our test module by &lt;code&gt;use ExUnit.Case&lt;/code&gt;. It does the job of starting the &lt;code&gt;KV.Registry&lt;/code&gt; process, by calling its &lt;code&gt;start_link/1&lt;/code&gt; function. The advantage of using &lt;code&gt;start_supervised!&lt;/code&gt; is that ExUnit will guarantee that the registry process will be shutdown &lt;strong&gt;before&lt;/strong&gt; the next test starts. In other words, it helps guarantee that the state of one test is not going to interfere with the next one in case they depend on shared resources.</source>
          <target state="translated">该 &lt;code&gt;start_supervised!&lt;/code&gt; 通过 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 将函数注入到我们的测试模块中。它通过调用其 &lt;code&gt;start_link/1&lt;/code&gt; 函数来启动 &lt;code&gt;KV.Registry&lt;/code&gt; 进程。使用 &lt;code&gt;start_supervised!&lt;/code&gt; 的优势！是ExUnit将保证在下一次测试开始&lt;strong&gt;之前&lt;/strong&gt;关闭注册表进程。换句话说，它可以确保一个测试的状态不会干扰下一个测试的状态，以防它们依赖共享资源。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4592fb7e0957a1fc52071c848d5e17c99c69385" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;starting_on&lt;/code&gt; represents the starting day of the week. All calendars must support at least the &lt;code&gt;:default&lt;/code&gt; value. They may also support other values representing their days of the week.</source>
          <target state="translated">该 &lt;code&gt;starting_on&lt;/code&gt; 表示一周开始的第一天。所有日历必须至少支持 &lt;code&gt;:default&lt;/code&gt; 值。他们可能还支持代表他们一周中的几天的其他值。</target>
        </trans-unit>
        <trans-unit id="7c3b0210439efc565cc631c8fa0e308643197cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; type</source>
          <target state="translated">的 &lt;code&gt;string()&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="61ebcef3a8537f672d50ed7bff3d6db73d860578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">的 &lt;code&gt;struct&lt;/code&gt; 参数可以是一个原子（其定义 &lt;code&gt;defstruct&lt;/code&gt; ）或 &lt;code&gt;struct&lt;/code&gt; 本身。第二个参数是在枚举期间发出两元素元组（键值对）的任何&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38386201665d1e0b386055fc8c5fb1dd196e0581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">的 &lt;code&gt;struct&lt;/code&gt; 参数可以是一个原子（其定义 &lt;code&gt;defstruct&lt;/code&gt; ）或 &lt;code&gt;struct&lt;/code&gt; 本身。第二个参数是在&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中发出两个元素的元组（键值对）的任何Enumerable。</target>
        </trans-unit>
        <trans-unit id="3ca4af46f233ac35dc3b79485d62ec51b88145af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subject&lt;/code&gt; is always a string.</source>
          <target state="translated">该 &lt;code&gt;subject&lt;/code&gt; 始终是一个字符串。</target>
        </trans-unit>
        <trans-unit id="bae6804f43f42b63c5528bcc2381471d0d39bad4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">该 &lt;code&gt;supervisor&lt;/code&gt; 必须在定义的参考&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;。该任务仍将链接到调用方，有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt;，而对于未链接的变体，请参见&lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08337e923feb72c49328d32727f3434709f1f848" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;supervisor&lt;/code&gt; 必须在定义的参考&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;。该任务将不会链接到调用者，请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="fa2ecf30353c15851b99330eab13deee5216e86a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">该 &lt;code&gt;supervisor&lt;/code&gt; 必须在定义的参考&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;。该任务仍将链接到调用方，有关更多信息，请参见&lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt;，而对于非链接的变体，请参见&lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="549a87864f7a5407aab555d12f030b23c5278a92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;supervisor&lt;/code&gt; 必须在定义的参考&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;。该任务不会链接到调用者，请参阅&lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="bc1957bc0923712dab3fe287b0e8df3bec3ec39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; macro</source>
          <target state="translated">该 &lt;code&gt;test&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="6bf883ffd229719baaf3e026049bc07e3e3fdc26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument passed to &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; is usually &lt;code&gt;:normal&lt;/code&gt; unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation.</source>
          <target state="translated">传递给&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;type&lt;/code&gt; 参数通常是 &lt;code&gt;:normal&lt;/code&gt; ,除非在配置了应用程序接管和故障转移的分布式设置中。分布式应用程序超出了本文档的范围。</target>
        </trans-unit>
        <trans-unit id="69149411f0751c47ab43a2cb8ee2352867ce8c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument specifies the type of the application:</source>
          <target state="translated">所述 &lt;code&gt;type&lt;/code&gt; 参数指定的应用程序的类型：</target>
        </trans-unit>
        <trans-unit id="f6663df984e95662866d3ab67e965809a6b673af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update_in/2&lt;/code&gt; macro is similar but allows us to pass a function that controls how the value changes. For example, let&amp;rsquo;s remove &amp;ldquo;Clojure&amp;rdquo; from Mary&amp;rsquo;s list of languages:</source>
          <target state="translated">该 &lt;code&gt;update_in/2&lt;/code&gt; 宏类似，但允许我们传递一个函数，如何控制值的变化。例如，让我们从玛丽的语言列表中删除&amp;ldquo; Clojure&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="8f6feff517dde91abd98ddcc94fc5f8ee947ce68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; macro is frequently used as an extension point. This means that, when you &lt;code&gt;use&lt;/code&gt; a module &lt;code&gt;FooBar&lt;/code&gt;, you allow that module to inject &lt;em&gt;any&lt;/em&gt; code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.</source>
          <target state="translated">在 &lt;code&gt;use&lt;/code&gt; 宏经常用作扩展点。这意味着，当您 &lt;code&gt;use&lt;/code&gt; 模块 &lt;code&gt;FooBar&lt;/code&gt; 时，允许该模块在当前模块中注入&lt;em&gt;任何&lt;/em&gt;代码，例如导入自身或其他模块，定义新功能，设置模块状态等。</target>
        </trans-unit>
        <trans-unit id="443668287cbb8f84b2664ce3f01400a9552185b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; types are for Unicode code points. They can also be applied to literal strings and charlists:</source>
          <target state="translated">在 &lt;code&gt;utf8&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 类型是Unicode代码点。它们也可以应用于文字字符串和字符列表：</target>
        </trans-unit>
        <trans-unit id="d593cc256ac243970966e445b59ce382b3d1c4ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vm.args&lt;/code&gt; file may contain any of the VM flags accepted by the &lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt;&lt;code&gt;erl&lt;/code&gt; command&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;vm.args&lt;/code&gt; 文件可以包含任何被接受的VM标志的&lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt; &lt;code&gt;erl&lt;/code&gt; 命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="766b25b711b24bf14734bf86264816b50201e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xref&lt;/code&gt; task expects a mode as first argument:</source>
          <target state="translated">在 &lt;code&gt;xref&lt;/code&gt; 任务需要的模式作为第一个参数：</target>
        </trans-unit>
        <trans-unit id="848f828061a57fea28024ac6791811ddcc578da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{module, function}&lt;/code&gt; will be invoked with four arguments:</source>
          <target state="translated">该 &lt;code&gt;{module, function}&lt;/code&gt; 将有四个参数调用：</target>
        </trans-unit>
        <trans-unit id="6bb6f7b835bb4273bfb73268cdb830e1eaa1b0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</source>
          <target state="translated">当需要执行一系列类似于管道的操作时， &lt;code&gt;|&amp;gt;&lt;/code&gt; 运算符最有用：</target>
        </trans-unit>
        <trans-unit id="e7c15f5a444d0eb501f58185ab4ff6cc148686d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; symbol used in the snippet above is the &lt;strong&gt;pipe operator&lt;/strong&gt;: it takes the output from the expression on its left side and passes it as the first argument to the function call on its right side. It&amp;rsquo;s similar to the Unix &lt;code&gt;|&lt;/code&gt; operator. Its purpose is to highlight the data being transformed by a series of functions. To see how it can make the code cleaner, have a look at the example above rewritten without using the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator:</source>
          <target state="translated">上面的代码段中的 &lt;code&gt;|&amp;gt;&lt;/code&gt; 符号是&lt;strong&gt;管道运算符&lt;/strong&gt;：它从表达式左侧的输出中获取输出，并将其作为第一个参数传递给右侧的函数调用。它类似于Unix &lt;code&gt;|&lt;/code&gt; 操作员。其目的是突出显示由一系列功能转换的数据。要查看它如何使代码更整洁，请看一下上面重写的示例，而没有使用 &lt;code&gt;|&amp;gt;&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="de83fadff1ba2a72273182089ea2a050990085bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~c&lt;/code&gt; sigil is useful for generating char lists that contain single quotes:</source>
          <target state="translated">在 &lt;code&gt;~c&lt;/code&gt; 印记是用于生成包含单引号字符的列表非常有用：</target>
        </trans-unit>
        <trans-unit id="281b4a2fc5fd64a2cedf95577018a34d44729cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~s&lt;/code&gt; sigil is used to generate strings, like double quotes are. The &lt;code&gt;~s&lt;/code&gt; sigil is useful when a string contains double quotes:</source>
          <target state="translated">在 &lt;code&gt;~s&lt;/code&gt; 印记被用来生成字符串，如双引号。在 &lt;code&gt;~s&lt;/code&gt; ，当一个字符串包含双引号印记是有用的：</target>
        </trans-unit>
        <trans-unit id="1b5ce296d52d56b387e6952a8ac2c01f7f747b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil also accepts the &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; modifiers (for char lists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:</source>
          <target state="translated">所述 &lt;code&gt;~w&lt;/code&gt; 印记还接受 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 调节剂（炭列表，字符串和原子，分别地），其指定生成的列表的元素的数据类型：</target>
        </trans-unit>
        <trans-unit id="9578a70bcff0146fc766139c2fb2691deada995b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil is used to generate lists of words (&lt;em&gt;words&lt;/em&gt; are just regular strings). Inside the &lt;code&gt;~w&lt;/code&gt; sigil, words are separated by whitespace.</source>
          <target state="translated">在 &lt;code&gt;~w&lt;/code&gt; 印记被用来生成一大堆单词（&lt;em&gt;字&lt;/em&gt;都只是普通的字符串）。内部 &lt;code&gt;~w&lt;/code&gt; 印记，单词由空格隔开。</target>
        </trans-unit>
        <trans-unit id="57c0bcba93565ebcb726bbcf9fe5e3a854d68664" translate="yes" xml:space="preserve">
          <source>The AST for a pipeline (a sequence of applications of &lt;code&gt;|&amp;gt;&lt;/code&gt;) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most &lt;code&gt;:|&amp;gt;&lt;/code&gt; (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</source>
          <target state="translated">管道的AST（ &lt;code&gt;|&amp;gt;&lt;/code&gt; 的一系列应用程序）类似于二进制运算符或函数应用程序的AST类别：顶级表达式是最右边的 &lt;code&gt;:|&amp;gt;&lt;/code&gt; （这是最后一个表达式）。执行），其左侧和右侧是其参数：</target>
        </trans-unit>
        <trans-unit id="22673f1e15930ac4a2bce8fc889928e4bf1f922d" translate="yes" xml:space="preserve">
          <source>The BREAK menu</source>
          <target state="translated">BREAK菜单</target>
        </trans-unit>
        <trans-unit id="98504b06eb756100aa8d0fe1b8a5bed8131e1638" translate="yes" xml:space="preserve">
          <source>The Client API</source>
          <target state="translated">客户端API</target>
        </trans-unit>
        <trans-unit id="de89441db4562cab93bdfbf9ab1875a33c2df7e4" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Date结构包含年，月，日和日历字段。新的日期可以与建&lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~D&lt;/code&gt; （见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="087349ac5d28e5bd9b6d72d6f50436cef7a3d724" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Date结构包含年，月，日和日历字段。新的日期可以与建&lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~D&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="60739ce280ae99907b36b37adf6ef92a05aaedd6" translate="yes" xml:space="preserve">
          <source>The Elixir AST</source>
          <target state="translated">酏剂AST</target>
        </trans-unit>
        <trans-unit id="b354da44a5ccc03b14d8e9e9f977406245074d69" translate="yes" xml:space="preserve">
          <source>The Elixir guides are also available in EPUB format:</source>
          <target state="translated">Elixir指南也有EPUB格式。</target>
        </trans-unit>
        <trans-unit id="3b3b88c39f2093f79b409f882370622044ce70ae" translate="yes" xml:space="preserve">
          <source>The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the &lt;code&gt;bin_opt_info&lt;/code&gt; compiler option:</source>
          <target state="translated">Erlang编译器可以在二进制创建和匹配方面提供许多优化。要查看优化输出，请设置 &lt;code&gt;bin_opt_info&lt;/code&gt; 编译器选项：</target>
        </trans-unit>
        <trans-unit id="7953816f5ef9843a5ed4589ec36cf1a54fdf799d" translate="yes" xml:space="preserve">
          <source>The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.</source>
          <target state="translated">GenServer行为抽象了常见的客户端-服务器交互。开发者只需要实现他们感兴趣的回调和功能。</target>
        </trans-unit>
        <trans-unit id="3d66e19aeb4f8b03c43c83bf06d0a7f010db09c4" translate="yes" xml:space="preserve">
          <source>The GenServer name</source>
          <target state="translated">GenServer名称</target>
        </trans-unit>
        <trans-unit id="4c83968c19110a694ab1613224a8a36aaf6e3f41" translate="yes" xml:space="preserve">
          <source>The IEx.Server.</source>
          <target state="translated">IEx.Server。</target>
        </trans-unit>
        <trans-unit id="06223706895cabbf123c8e779883d2c10704e930" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras:</source>
          <target state="translated">ISO日历有两个时代。</target>
        </trans-unit>
        <trans-unit id="abfb693f46640a1c9464403f477ffc2622e7b611" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the &quot;current era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt; and is defined as era &lt;code&gt;1&lt;/code&gt;. And &quot;before the current era&quot; (BCE) for those years less than &lt;code&gt;1&lt;/code&gt;, defined as era &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">ISO日历具有两个时代：从第 &lt;code&gt;1&lt;/code&gt; 年开始并定义为第 &lt;code&gt;1&lt;/code&gt; 年的&amp;ldquo;当前时代&amp;rdquo;（CE）。并且&amp;ldquo;当下时代之前&amp;rdquo;（BCE）的年份少于 &lt;code&gt;1&lt;/code&gt; ，定义为时代 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25aef49825211907484d43e756114a0b1fa27f36" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the current era which starts in year 1 and is defined as era &quot;1&quot;. And a second era for those years less than 1 defined as era &quot;0&quot;.</source>
          <target state="translated">国际标准化组织的日历有两个时代:当前时代从第1年开始,定义为 &quot;1 &quot;时代。第二个时代是指小于1的年份,定义为 &quot;0 &quot;时代。</target>
        </trans-unit>
        <trans-unit id="1a856fcbbb476ea67477f19a707dbe002ca4c6dc" translate="yes" xml:space="preserve">
          <source>The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the &quot;did you mean?&quot; functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the &lt;a href=&quot;#jaro_distance/2&quot;&gt;&lt;code&gt;jaro_distance/2&lt;/code&gt;&lt;/a&gt; score.</source>
          <target state="translated">Jaro距离度量标准是为最短字符串（例如人名）而设计的。Elixir本身使用此功能来提供&amp;ldquo;您的意思是？&amp;rdquo;。功能。例如，当您在模块中调用函数并且函数名称中有错字时，我们会尝试根据&lt;a href=&quot;#jaro_distance/2&quot;&gt; &lt;code&gt;jaro_distance/2&lt;/code&gt; &lt;/a&gt;分数建议最相似的可用函数名称（如果有）。</target>
        </trans-unit>
        <trans-unit id="2243840442a8f32a34eed8592db54cfe259c03b6" translate="yes" xml:space="preserve">
          <source>The Mix build tool automates most of the application management tasks. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mix构建工具可自动执行大多数应用程序管理任务。例如，在测试运行之前，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;自动启动您的应用程序依赖关系以及应用程序本身。 &lt;code&gt;mix run --no-halt&lt;/code&gt; 引导您当前的项目，可用于启动长时间运行的系统。请参阅&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37173c596301d8be8275b8b1f500a183f87ab7fa" translate="yes" xml:space="preserve">
          <source>The Mix build tool can also be used to start your applications. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mix构建工具还可用于启动您的应用程序。例如，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;会在测试运行之前自动启动您的应用程序依赖关系以及应用程序本身。 &lt;code&gt;mix run --no-halt&lt;/code&gt; 引导您当前的项目，可用于启动长时间运行的系统。请参阅&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1904da080bbb46fb65f0901cdd39a58e1d853d" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation, computed via &lt;code&gt;mix xref warnings&lt;/code&gt;.</source>
          <target state="translated">Mix编译器自动查找对不赞成使用的模块的调用，并在编译期间发出通过 &lt;code&gt;mix xref warnings&lt;/code&gt; 计算的警告。</target>
        </trans-unit>
        <trans-unit id="3d196736edd538da5aa685ff060f4fbf30705946" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation.</source>
          <target state="translated">Mix编译器在编译过程中会自动查找对废弃模块的调用并发出警告。</target>
        </trans-unit>
        <trans-unit id="34452d9cfe86755e31b4602a825598bf680a2294" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields</source>
          <target state="translated">Mix.Release结构有以下只读字段。</target>
        </trans-unit>
        <trans-unit id="39b03d254e8865b80217130278011a49c00a226d" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields:</source>
          <target state="translated">Mix.Release结构有以下只读字段。</target>
        </trans-unit>
        <trans-unit id="9dfe2774b7ab63b2ea9316075f485e26e6770c05" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">NaiveDateTime结构包含年，月，日，小时，分钟，秒，微秒和日历字段。新幼稚日期时间可以与建立&lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~N&lt;/code&gt; （见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="be1eb0ffc63d3de62778534778d3195fa7ba19b5" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">NaiveDateTime结构包含年，月，日，小时，分钟，秒，微秒和日历字段。新幼稚日期时间可以与建立&lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~N&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="68ea22c150e9e8bf3b5e486f34ccdf3da6885051" translate="yes" xml:space="preserve">
          <source>The Plug library also allows developers to define their own plugs which can be run in a web server:</source>
          <target state="translated">插件库还允许开发人员定义自己的插件,这些插件可以在web服务器中运行。</target>
        </trans-unit>
        <trans-unit id="a12ef86cf46c7d5f545c70ee0f3e00bac2b5a15b" translate="yes" xml:space="preserve">
          <source>The Supervisor name</source>
          <target state="translated">监事姓名</target>
        </trans-unit>
        <trans-unit id="ec4b01d7b2161ab93486a9f17a632dd403411fb3" translate="yes" xml:space="preserve">
          <source>The Task struct.</source>
          <target state="translated">任务结构。</target>
        </trans-unit>
        <trans-unit id="5c4c62b39d79d7cb27a5185a0a6601bdd97a3708" translate="yes" xml:space="preserve">
          <source>The Task type.</source>
          <target state="translated">任务类型:</target>
        </trans-unit>
        <trans-unit id="9e011d9f109b1de717a6e789ef4d48fa0c5bf500" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">时间结构包含小时，分钟，秒和微秒的字段。新时间可以与建立&lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~T&lt;/code&gt; （见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="3b4c615274399f80e52f24988cf891d5bac9928c" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">时间结构包含小时，分钟，秒和微秒的字段。新时间可以与建立&lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt;的功能或使用 &lt;code&gt;~T&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt;）印记：</target>
        </trans-unit>
        <trans-unit id="8474ee41c99d01d2c859c45e3ba20cf759140dae" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected.</source>
          <target state="translated">UTF-8编码是自同步的。这意味着,如果遇到畸形数据(即根据编码定义不可能的数据),只需要拒绝一个码点。</target>
        </trans-unit>
        <trans-unit id="af4cd337ec1852f0dfb035c5a67522bde05e43a9" translate="yes" xml:space="preserve">
          <source>The Unicode standard assigns code points to many of the characters we know. For example, the letter &lt;code&gt;a&lt;/code&gt; has code point &lt;code&gt;97&lt;/code&gt; while the letter &lt;code&gt;ł&lt;/code&gt; has code point &lt;code&gt;322&lt;/code&gt;. When writing the string &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; to disk, we need to convert this sequence of characters to bytes. If we adopted a rule that said one byte represents one code point, we wouldn&amp;rsquo;t be able to write &lt;code&gt;&quot;hełło&quot;&lt;/code&gt;, because it uses the code point &lt;code&gt;322&lt;/code&gt; for &lt;code&gt;ł&lt;/code&gt;, and one byte can only represent a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. But of course, given you can actually read &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; on your screen, it must be represented &lt;em&gt;somehow&lt;/em&gt;. That&amp;rsquo;s where encodings come in.</source>
          <target state="translated">Unicode标准将代码点分配给我们知道的许多字符。例如，字母 &lt;code&gt;a&lt;/code&gt; 具有代码点 &lt;code&gt;97&lt;/code&gt; ,而字母 &lt;code&gt;ł&lt;/code&gt; 具有代码点 &lt;code&gt;322&lt;/code&gt; 。将字符串 &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; 写入磁盘时，我们需要将此字符序列转换为字节。如果我们采用一个规则，说一个字节代表一个代码点，那么我们将无法编写 &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; ，因为它使用代码点 &lt;code&gt;322&lt;/code&gt; 表示 &lt;code&gt;ł&lt;/code&gt; ，而一个字节只能代表 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;255&lt;/code&gt; 之间的数字。但是，当然，鉴于您实际上可以在屏幕上阅读 &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; ，因此必须以&lt;em&gt;不知何故&lt;/em&gt;。那就是编码的来源。</target>
        </trans-unit>
        <trans-unit id="2f4916c41c92d9991c4b1a3b6471eb39a20e54f2" translate="yes" xml:space="preserve">
          <source>The User switch command</source>
          <target state="translated">用户切换命令</target>
        </trans-unit>
        <trans-unit id="1a567b978fcdc4da963f5cc140173eaaff0ae789" translate="yes" xml:space="preserve">
          <source>The above example shows the difference; the &lt;code&gt;String&lt;/code&gt; module returns Unicode codepoints, while &lt;code&gt;:binary&lt;/code&gt; deals with raw data bytes.</source>
          <target state="translated">上面的示例显示了区别；的 &lt;code&gt;String&lt;/code&gt; 模块返回Unicode代码点，而 &lt;code&gt;:binary&lt;/code&gt; 原始数据字节的交易。</target>
        </trans-unit>
        <trans-unit id="3a294edc39ba298dd2fbf7c3e29c2a6c5831e0fe" translate="yes" xml:space="preserve">
          <source>The above is treated the same as &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; by the parser.</source>
          <target state="translated">解析器将上述内容与 &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="06bc5ff1abf3cc124d1fca8a735f66352777e819" translate="yes" xml:space="preserve">
          <source>The above will open another Graphical User Interface that provides many panes to fully understand and navigate the runtime and your project:</source>
          <target state="translated">上面将打开另一个图形用户界面,它提供了许多窗格来充分理解和浏览运行时和你的项目。</target>
        </trans-unit>
        <trans-unit id="d9d727dddfefcfe94e321842e4a52a5241d4e51c" translate="yes" xml:space="preserve">
          <source>The accepted formats are:</source>
          <target state="translated">接受的格式是:</target>
        </trans-unit>
        <trans-unit id="4124955158531615905cdb11c74372fed2efecdc" translate="yes" xml:space="preserve">
          <source>The accepted options are:</source>
          <target state="translated">接受的备选方案是:</target>
        </trans-unit>
        <trans-unit id="7021d5fb676b9152eef63709fd1b96c4dc35ca14" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">访问语法也可以与&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; &lt;/a&gt;宏一起使用，以允许在嵌套数据结构中设置值：</target>
        </trans-unit>
        <trans-unit id="aca7adeb72bb259b777f4c2b15cd9a4f9b4ff5ce" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;kernel#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">访问语法也可以与&lt;a href=&quot;kernel#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; &lt;/a&gt;宏一起使用，以允许在嵌套数据结构中设置值：</target>
        </trans-unit>
        <trans-unit id="243c0eadcb33ec262a94b0246c4ece1f117a3666" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;access#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">访问语法表示为对&lt;a href=&quot;access#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; &lt;/a&gt;的调用：</target>
        </trans-unit>
        <trans-unit id="3c19d0ebf16010f6efd63fa157dd829c700b0b58" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">访问语法表示为对&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; &lt;/a&gt;的调用：</target>
        </trans-unit>
        <trans-unit id="4b8d2c8f5f09f671794f31f1f907968a5ca06aff" translate="yes" xml:space="preserve">
          <source>The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes.</source>
          <target state="translated">累加器只有在转换开始时才会被计算。它还允许给出一个After函数,当流停止或完成时调用。</target>
        </trans-unit>
        <trans-unit id="231cb19852aaf99a578b488de350325c3dbaf7df" translate="yes" xml:space="preserve">
          <source>The accumulator value for each step.</source>
          <target state="translated">每一步的累加器值。</target>
        </trans-unit>
        <trans-unit id="e04f1a61804f76a146e2c529d3dfa319227959a4" translate="yes" xml:space="preserve">
          <source>The actual line is especially formatted in bold.</source>
          <target state="translated">实际行文特别是格式化的黑体字。</target>
        </trans-unit>
        <trans-unit id="3f1f1fb598d7730a9ff70812d543d26b95408bb0" translate="yes" xml:space="preserve">
          <source>The advantage of starting a process under the test supervisor is that it is guaranteed to exit before the next test starts. Therefore, you don't need to remove the process at the end of your tests via &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt;. You only need to use &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; if you want to remove a process from the supervision tree in the middle of a test, as simply shutting down the process would cause it to be restarted according to its &lt;code&gt;:restart&lt;/code&gt; value.</source>
          <target state="translated">在测试主管下启动流程的优势在于，可以确保在下一个测试开始之前退出该流程。因此，您无需在测试结束时通过&lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt;删除该过程。如果要在测试过程中从监视树中删除某个进程，则只需要使用&lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt;，因为简单地关闭该进程将导致其根据 &lt;code&gt;:restart&lt;/code&gt; 值重新启动。</target>
        </trans-unit>
        <trans-unit id="f25d9730409ef1dfe6f5e984f31be4fd99cffcf1" translate="yes" xml:space="preserve">
          <source>The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key &lt;code&gt;:full_name&lt;/code&gt; in the &lt;code&gt;User&lt;/code&gt; struct:</source>
          <target state="translated">结构的优点是它们可以验证给定键是否为已定义结构的一部分。下面的例子将失败，因为没有钥匙 &lt;code&gt;:full_name&lt;/code&gt; 在 &lt;code&gt;User&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="83ac1b567e220f667e9d9d2c2f19a5c7705de064" translate="yes" xml:space="preserve">
          <source>The agent name</source>
          <target state="translated">代理商名称</target>
        </trans-unit>
        <trans-unit id="850cde34796934da35ab95f25d166c013161b0f7" translate="yes" xml:space="preserve">
          <source>The agent reference</source>
          <target state="translated">代理商参考</target>
        </trans-unit>
        <trans-unit id="79d99d2d3b7f3ac280b26b43a51cc435cf66db5f" translate="yes" xml:space="preserve">
          <source>The agent state</source>
          <target state="translated">代理人状态</target>
        </trans-unit>
        <trans-unit id="04287ba52642f4b2e9805d3cbb6242221ac4131b" translate="yes" xml:space="preserve">
          <source>The agent's state will be added to the given list of arguments (&lt;code&gt;[%{}]&lt;/code&gt;) as the first argument.</source>
          <target state="translated">代理的状态将作为第一个参数添加到给定的参数列表（ &lt;code&gt;[%{}]&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="8beb83ba7f5ecd3254d30e564e0d6fb8a2d460e5" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;An O(ND) Difference Algorithm and Its Variations&quot; paper by E. Myers.</source>
          <target state="translated">在E.Myers的 &quot;An O(ND)Difference Algorithm and Its Variations &quot;论文中概述了该算法。</target>
        </trans-unit>
        <trans-unit id="3e134324067f32fab468c28c29405fca71811700" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;String Matching with Metric Trees Using an Approximate Distance&quot; paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella.</source>
          <target state="translated">该算法在Ilaria Bartolini、Paolo Ciaccia和Marco Patella撰写的 &quot;使用近似距离与度量树进行字符串匹配 &quot;论文中进行了概述。</target>
        </trans-unit>
        <trans-unit id="e4b130944005218b61f70b8dda4acb83f5f8b422" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29, Unicode Text Segmentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode标准附件＃29&amp;ldquo; Unicode文本分段&amp;rdquo;中&lt;/a&gt;概述了该算法。</target>
        </trans-unit>
        <trans-unit id="f9558fd66aceb0ac12811fbd079f3478d2d6d0b6" translate="yes" xml:space="preserve">
          <source>The allowed modes:</source>
          <target state="translated">允许的模式:</target>
        </trans-unit>
        <trans-unit id="22b1bedb9b0e24d713b2164c5c95fdaf0f81ef84" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;flag&lt;/code&gt; are only a subset of those allowed in &lt;a href=&quot;#flag/2&quot;&gt;&lt;code&gt;flag/2&lt;/code&gt;&lt;/a&gt;, namely &lt;code&gt;:save_calls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flag&lt;/code&gt; 的允许值只是&lt;a href=&quot;#flag/2&quot;&gt; &lt;code&gt;flag/2&lt;/code&gt; &lt;/a&gt;允许的值的子集，即 &lt;code&gt;:save_calls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1284e6a8b509aaab6853404ad966b4c6d0d9c11" translate="yes" xml:space="preserve">
          <source>The amount of functionality in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules can be daunting at first, but you will get familiar with them case by case. In particular, focus on the &lt;code&gt;Enum&lt;/code&gt; module first and only move to &lt;code&gt;Stream&lt;/code&gt; for the particular scenarios where laziness is required, to either deal with slow resources or large, possibly infinite, collections.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块中的功能之初可能让人望而生畏，但是您将视情况逐一熟悉它们。特别是，首先要关注 &lt;code&gt;Enum&lt;/code&gt; 模块，并且仅在需要懒惰的特定情况下才转向 &lt;code&gt;Stream&lt;/code&gt; ，以处理缓慢的资源或大型（可能无限）的集合。</target>
        </trans-unit>
        <trans-unit id="7e8600e30f0a326a12149028f15ee8e6ad16cef8" translate="yes" xml:space="preserve">
          <source>The anonymous function receives 0 arguments, and may return any value.</source>
          <target state="translated">匿名函数接收0个参数,可以返回任何值。</target>
        </trans-unit>
        <trans-unit id="3860a6ee964a29eb95c7ca816e5e5490427978d6" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以以&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 返回答案。</target>
        </trans-unit>
        <trans-unit id="35961a2d2bc407917b83fe316a44657eb3d70dde" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first time value is earlier than the second, a negative number is returned.</source>
          <target state="translated">可以以&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 返回答案。如果第一个时间值早于第二个时间值，则返回负数。</target>
        </trans-unit>
        <trans-unit id="273c2352c55239386071c9f97857464d5b54d531" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以以&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 返回答案。</target>
        </trans-unit>
        <trans-unit id="0c851ccba3a0c5e2913af28fbba1bc5059650f30" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first unit is smaller than the second, a negative number is returned.</source>
          <target state="translated">可以以&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 返回答案。如果第一个单位小于第二个单位，则返回负数。</target>
        </trans-unit>
        <trans-unit id="11872c1546ad5d8d77e3dd6dcf24fe80bdc32569" translate="yes" xml:space="preserve">
          <source>The application callback</source>
          <target state="translated">应用程序回调</target>
        </trans-unit>
        <trans-unit id="498cebd5386c08940274d180a46313b584299218" translate="yes" xml:space="preserve">
          <source>The application callback module</source>
          <target state="translated">应用程序回调模块</target>
        </trans-unit>
        <trans-unit id="ce357182db7e39e7d54f85ac0fa8ea1bfe43cdcd" translate="yes" xml:space="preserve">
          <source>The application environment</source>
          <target state="translated">应用环境</target>
        </trans-unit>
        <trans-unit id="40917bb5c729fef80a4c140a2928d1f7a14bf4d7" translate="yes" xml:space="preserve">
          <source>The application environment can be overridden via the &lt;code&gt;-config&lt;/code&gt; option of &lt;code&gt;erl&lt;/code&gt;, as well as command-line options, as we are going to see below.</source>
          <target state="translated">可以通过 &lt;code&gt;erl&lt;/code&gt; 的 &lt;code&gt;-config&lt;/code&gt; 选项以及命令行选项来覆盖应用程序环境，如下所示。</target>
        </trans-unit>
        <trans-unit id="37789b75dd5f623e649e47a61f598fab65dfa7b6" translate="yes" xml:space="preserve">
          <source>The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree.</source>
          <target state="translated">应用环境应该只保留给真正的全局性配置,例如,用于控制你的应用启动过程及其监督树。</target>
        </trans-unit>
        <trans-unit id="280a9a5faaec5ff9e8215df748115db28ebee1a0" translate="yes" xml:space="preserve">
          <source>The application is located by analyzing the spec of all loaded applications. Returns &lt;code&gt;nil&lt;/code&gt; if the module is not listed in any application spec.</source>
          <target state="translated">通过分析所有已加载应用程序的规范来找到该应用程序。如果模块未在任何应用程序规范中列出，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc8d61b7265354046282efa86c0154278c621f25" translate="yes" xml:space="preserve">
          <source>The application life cycle</source>
          <target state="translated">应用寿命周期</target>
        </trans-unit>
        <trans-unit id="cc4a58ee1265d5c1fe9173d32bf0ac223249dd85" translate="yes" xml:space="preserve">
          <source>The application lifecycle</source>
          <target state="translated">应用程序的生命周期</target>
        </trans-unit>
        <trans-unit id="143141b825e19c759eb1a18e855e24abed92b957" translate="yes" xml:space="preserve">
          <source>The application resource file</source>
          <target state="translated">应用资源文件</target>
        </trans-unit>
        <trans-unit id="e3563cd3d1dfc3ea0fa27f37030c6816eb2657f5" translate="yes" xml:space="preserve">
          <source>The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:</source>
          <target state="translated">该应用程序作为一个分布式键值存储工作。我们将把键值对组织成桶,并把这些桶分布在多个节点上。我们还将建立一个简单的客户端,让我们可以连接到任何一个节点,并发送请求,如:。</target>
        </trans-unit>
        <trans-unit id="27642ed423e2fa876dc5149e7e9fb4418a0af850" translate="yes" xml:space="preserve">
          <source>The archive will be created in the current directory (which is expected to be the project root), unless an argument &lt;code&gt;-o&lt;/code&gt; is provided with the file name.</source>
          <target state="translated">除非在文件名中提供参数 &lt;code&gt;-o&lt;/code&gt; ，否则将在当前目录（应该是项目根目录）中创建归档文件。</target>
        </trans-unit>
        <trans-unit id="d0f3ead845310ee387fe5a545e6953c55ffb1629" translate="yes" xml:space="preserve">
          <source>The argument can also be a compiled pattern:</source>
          <target state="translated">参数也可以是一个编译的模式。</target>
        </trans-unit>
        <trans-unit id="591637cab81491d8824a1f871aa68b8d413473f1" translate="yes" xml:space="preserve">
          <source>The argument can be either a variable unquoted or in standard tuple form &lt;code&gt;{name, meta, context}&lt;/code&gt;.</source>
          <target state="translated">参数可以是未加引号的变量，也可以是标准元组形式的 &lt;code&gt;{name, meta, context}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="001d538e8d0cdf963d20a8cda73ecd32223786da" translate="yes" xml:space="preserve">
          <source>The arguments passed to the callbacks are related to the state optionally returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, and are documented in the section about the callback module above.</source>
          <target state="translated">传递给回调的参数与&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;可选返回的状态有关，并记录在上面有关回调模块的部分中。</target>
        </trans-unit>
        <trans-unit id="2a881ae7cb35da41cfdaee7b5069205d1b09ab08" translate="yes" xml:space="preserve">
          <source>The atom encoder is not called for &lt;em&gt;all&lt;/em&gt; atoms that are present in the AST. It won't be invoked for the following atoms:</source>
          <target state="translated">不会为AST中存在的&lt;em&gt;所有&lt;/em&gt;原子调用原子编码器。不会为以下原子调用它：</target>
        </trans-unit>
        <trans-unit id="ca8797b60e8c99dfe84eeca54f5b5a5a65568918" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;.</source>
          <target state="translated">属性值将通过 &lt;code&gt;context.registered&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="f1aacd6450630dafa0ac3016ebf55acec692c62f" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@describetag&lt;/code&gt;.</source>
          <target state="translated">属性值将通过 &lt;code&gt;context.registered&lt;/code&gt; 可用。在每个&lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; 之后&lt;/a&gt;类似于 &lt;code&gt;@describetag&lt;/code&gt; 清除注册值。</target>
        </trans-unit>
        <trans-unit id="f388a223145d9f2cd324e6f166a8ccfc6a8b5209" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">属性值将通过 &lt;code&gt;context.registered&lt;/code&gt; 可用。在每次&lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt;类似于 &lt;code&gt;@tag&lt;/code&gt; 一样清除注册值。</target>
        </trans-unit>
        <trans-unit id="b41ad89c98d422fd2e978f100782ecfe3f1da362" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;exunit.case#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">属性值将通过 &lt;code&gt;context.registered&lt;/code&gt; 可用。在每个&lt;a href=&quot;exunit.case#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt;之后都会清除注册值，类似于 &lt;code&gt;@tag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fadbc924b0cd6b0ad53d9ab7f75eafe50d08633" translate="yes" xml:space="preserve">
          <source>The available backends by default are:</source>
          <target state="translated">默认可用的后端有:</target>
        </trans-unit>
        <trans-unit id="6cce71e8c20ef741ad606617e045711680af943f" translate="yes" xml:space="preserve">
          <source>The available color options are:</source>
          <target state="translated">可供选择的颜色有:</target>
        </trans-unit>
        <trans-unit id="6310c4c55c85283101be1a934d0a00206b4f631d" translate="yes" xml:space="preserve">
          <source>The backend needs to be started and running in order to be configured at runtime.</source>
          <target state="translated">后台需要启动并运行,才能在运行时进行配置。</target>
        </trans-unit>
        <trans-unit id="96a787facf19135fb4b200f8b487060672819be8" translate="yes" xml:space="preserve">
          <source>The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different.</source>
          <target state="translated">包距的目的是为了有效地逼近两根弦之间的距离,以快速排除基本不同的弦。</target>
        </trans-unit>
        <trans-unit id="b0aa33c6e6c19292365b6836f590a40f470ae9e8" translate="yes" xml:space="preserve">
          <source>The base needs to be between &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;36&lt;/code&gt;.</source>
          <target state="translated">基数必须在 &lt;code&gt;2&lt;/code&gt; 到 &lt;code&gt;36&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="338ca5e9a146228c6591ce27e258c309b41537d7" translate="yes" xml:space="preserve">
          <source>The basic mechanism for spawning new processes is the auto-imported &lt;code&gt;spawn/1&lt;/code&gt; function:</source>
          <target state="translated">产生新进程的基本机制是自动导入的 &lt;code&gt;spawn/1&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="4e7559ee61af701da957bbebc32b89de3be4e12f" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#ceil/2&quot;&gt;&lt;code&gt;ceil/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">&lt;a href=&quot;#ceil/2&quot;&gt; &lt;code&gt;ceil/2&lt;/code&gt; &lt;/a&gt;对于浮点的行为可能令人惊讶。例如：</target>
        </trans-unit>
        <trans-unit id="d56bb8e1dfaa2c0603350dcc324ff5c454da55f1" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">浮子的&lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt;行为可能令人惊讶。例如：</target>
        </trans-unit>
        <trans-unit id="038842fad2e4b3a86e4d5b65bf16dcbffaa55807" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">浮点数的&lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt;行为可能令人惊讶。例如：</target>
        </trans-unit>
        <trans-unit id="c79b8f7e64e352a09f016328372f8c34533b468e" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">子句中任何表达式的行为与外部相同。例如， &lt;code&gt;=&lt;/code&gt; 将引发&lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt;而不是返回不匹配的值：</target>
        </trans-unit>
        <trans-unit id="850b8800d7a40702a94f4c6f350b76c00c714c91" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">子句中任何表达式的行为与外部相同。例如， &lt;code&gt;=&lt;/code&gt; 将引发&lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt;而不是返回不匹配的值：</target>
        </trans-unit>
        <trans-unit id="2c2089b4c70310731d109bdd4cb28eac8386c5ba" translate="yes" xml:space="preserve">
          <source>The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter.</source>
          <target state="translated">以上行为不作保证。我们可能会在将来删除或添加新的规则。记录这些规则的目的是为了让人们更好地了解对格式化器的期望。</target>
        </trans-unit>
        <trans-unit id="1b5532ea236231522d81c8ef60d96c8157a31b23" translate="yes" xml:space="preserve">
          <source>The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents.</source>
          <target state="translated">最好的解决方案是在使用分布式代理时,简单地使用显式模块、函数和参数API。</target>
        </trans-unit>
        <trans-unit id="230a7e78c26b7490aaeba0ccd0ad9d4d649d4144" translate="yes" xml:space="preserve">
          <source>The best way to get started with your first project is by calling &lt;code&gt;mix new my_project&lt;/code&gt; from the command line.</source>
          <target state="translated">开始第一个项目的最佳方法是从命令行调用 &lt;code&gt;mix new my_project&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0bbf418b1f38a55ccb7dde48f0990ed9ed4760a" translate="yes" xml:space="preserve">
          <source>The binary module</source>
          <target state="translated">二进制模块</target>
        </trans-unit>
        <trans-unit id="95ca58a2bc8511627f8365c4bfe2246bdcfdaed5" translate="yes" xml:space="preserve">
          <source>The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</source>
          <target state="translated">绑定键通常是原子,但它们可能是在不同上下文中定义的变量的元组。</target>
        </trans-unit>
        <trans-unit id="0b507e4caeeefa4e12188b817548237116e75e51" translate="yes" xml:space="preserve">
          <source>The booleans &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are also atoms:</source>
          <target state="translated">布尔值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 也是原子：</target>
        </trans-unit>
        <trans-unit id="922dc50f7cf9b7578080aaeb54c1d2a1b40ac190" translate="yes" xml:space="preserve">
          <source>The boot script uses the RELEASE_LIB environment variable, which must be accordingly set with &lt;code&gt;--boot-var&lt;/code&gt; and point to the release lib dir.</source>
          <target state="translated">引导脚本使用RELEASE_LIB环境变量，必须使用 &lt;code&gt;--boot-var&lt;/code&gt; 对其进行相应设置，并指向发行版lib dir。</target>
        </trans-unit>
        <trans-unit id="173c29727301f1e8ee220ab1adbc4da76be15175" translate="yes" xml:space="preserve">
          <source>The bucket supervisor</source>
          <target state="translated">桶长</target>
        </trans-unit>
        <trans-unit id="28ca52bc03d0c7c44e235ef531de8f5ba2e83b87" translate="yes" xml:space="preserve">
          <source>The building block of Elixir's AST is a call, such as:</source>
          <target state="translated">Elixir的AST的构件是一个调用,如。</target>
        </trans-unit>
        <trans-unit id="461328f5549d78a8b5fdedc116f07cd5036d784a" translate="yes" xml:space="preserve">
          <source>The building block of an Elixir program is a tuple with three elements. For example, the function call &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; is represented internally as:</source>
          <target state="translated">Elixir程序的基本组成部分是具有三个元素的元组。例如，函数调用 &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; 在内部表示为：</target>
        </trans-unit>
        <trans-unit id="75d9d0a9c9a355ba2103db23084500c77872bd8e" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">内置&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt;类型是根据&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt;定义的。IO列表与IO数据相同，但它不允许在顶层使用二进制文件（但列表本身仍允许使用二进制文件）。</target>
        </trans-unit>
        <trans-unit id="bb521e80a89a4c39c427f904962402bd53b9f9e8" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">内置&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt;类型是根据&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt;定义的。IO列表与IO数据相同，但它不允许在顶层使用二进制文件（但列表本身仍允许使用二进制文件）。</target>
        </trans-unit>
        <trans-unit id="fa702ce8bbd071f4798263a3cd547b0d108c54b2" translate="yes" xml:space="preserve">
          <source>The built-in Elixir String module handles binaries that are UTF-8 encoded. &lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;The binary module&lt;/a&gt; is useful when you are dealing with binary data that is not necessarily UTF-8 encoded.</source>
          <target state="translated">内置的Elixir String模块处理UTF-8编码的二进制文件。当您处理不一定是UTF-8编码的二进制数据时&lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;，二进制模块&lt;/a&gt;很有用。</target>
        </trans-unit>
        <trans-unit id="9912c6244d1c63cb84c34b3a68b26e804aecd085" translate="yes" xml:space="preserve">
          <source>The built-in calendar does not support leap seconds.</source>
          <target state="translated">内置日历不支持闰秒。</target>
        </trans-unit>
        <trans-unit id="eac291bdda8b39cdd07415652c800893620c2cab" translate="yes" xml:space="preserve">
          <source>The calendar era.</source>
          <target state="translated">日历时代。</target>
        </trans-unit>
        <trans-unit id="c53205e7065bb3ce87323206c4d4e303fc4d8e79" translate="yes" xml:space="preserve">
          <source>The callback is invoked after the compiler runs and it receives a tuple with current status and the list of diagnostic. It must return the updated status and diagnostics.</source>
          <target state="translated">该回调在编译器运行后被调用,它收到一个包含当前状态和诊断程序列表的元组。它必须返回更新后的状态和诊断程序。</target>
        </trans-unit>
        <trans-unit id="b5d5a7fc225ff3dc99ea235a243bb670a176a9d8" translate="yes" xml:space="preserve">
          <source>The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</source>
          <target state="translated">调用进程会进入一个等待状态,在这个状态下,它的内存分配已经尽可能地减少了,如果这个进程预计在不久的将来不会收到任何消息,那么这个状态就很有用。</target>
        </trans-unit>
        <trans-unit id="2b5b064f8261c2b03a774df6e6ae6dcd0d5c8140" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">属性的典型示例说明模块实现了OTP行为，例如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f0b8dfb4a5a810c9b8c195f76200b64770caff21" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">属性的规范示例说明了模块实现了OTP行为，例如&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="88868f6d5562a67e7ddaf9b29fc243c12f68bba4" translate="yes" xml:space="preserve">
          <source>The capture operator</source>
          <target state="translated">捕获操作员</target>
        </trans-unit>
        <trans-unit id="1347b7b88b5541d0e12b97a6af43a979bc085407" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:</source>
          <target state="translated">捕获操作符也可以用来捕获本地函数,包括私有函数,以及通过省略模块名称来捕获导入的函数。</target>
        </trans-unit>
        <trans-unit id="75226e8489147d2da09b1c8fddde984e1d062fca" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to create anonymous functions that expect at least one argument:</source>
          <target state="translated">捕获操作符也可以用来创建一个至少有一个参数的匿名函数。</target>
        </trans-unit>
        <trans-unit id="9ef5fce1b72abda5249ca40d94c6bba5adc71084" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to partially apply functions, where &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt; and so on can be used as value placeholders. For example:</source>
          <target state="translated">捕获运算符还可以用于部分应用函数，其中 &lt;code&gt;&amp;amp;1&lt;/code&gt; ， &lt;code&gt;&amp;amp;2&lt;/code&gt; 等可以用作值占位符。例如：</target>
        </trans-unit>
        <trans-unit id="ed78fb3f56be122fa668d8b4473c09f744fcc1e2" translate="yes" xml:space="preserve">
          <source>The capture operator is most commonly used to capture a function with given name and arity from a module:</source>
          <target state="translated">捕获操作符最常用于从一个模块中捕获一个给定名称和奇数的函数。</target>
        </trans-unit>
        <trans-unit id="daa5b67ac4266d64104c7c678fbebf39b612b043" translate="yes" xml:space="preserve">
          <source>The changes we have performed above have broken our tests because the registry requires the &lt;code&gt;:name&lt;/code&gt; option when starting up. Furthermore, some registry operations such as &lt;code&gt;lookup/2&lt;/code&gt; require the name to be given as an argument, instead of a PID, so we can do the ETS table lookup. Let&amp;rsquo;s change the setup function in &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; to fix both issues:</source>
          <target state="translated">我们上面所做的更改破坏了我们的测试，因为注册表在启动时需要使用 &lt;code&gt;:name&lt;/code&gt; 选项。此外，某些注册表操作（例如 &lt;code&gt;lookup/2&lt;/code&gt; )要求将名称作为参数而不是PID给出，因此我们可以进行ETS表查找。让我们更改 &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; 中的设置功能以解决这两个问题：</target>
        </trans-unit>
        <trans-unit id="a0d4f7e1122a8b55f665626ee09ac09a98518fc5" translate="yes" xml:space="preserve">
          <source>The child specification contains 6 keys. The first two are required, and the remaining ones are optional:</source>
          <target state="translated">子规范包含6个键。前两个是必须的,其余的是可选的。</target>
        </trans-unit>
        <trans-unit id="7160687e53597f9f0ad549c50eef17c501e4af5e" translate="yes" xml:space="preserve">
          <source>The child specification describes how the supervisor starts, shuts down, and restarts child processes.</source>
          <target state="translated">子规范描述了主管如何启动、关闭和重启子进程。</target>
        </trans-unit>
        <trans-unit id="950e3568a25b27f2811958eb0aa95e081e11f40c" translate="yes" xml:space="preserve">
          <source>The child specification is a map containing up to 6 elements. The first two keys in the following list are required, and the remaining ones are optional:</source>
          <target state="translated">子项规范是一个最多包含6个元素的地图。以下列表中的前两个键是必需的,其余键是可选的。</target>
        </trans-unit>
        <trans-unit id="42da62bf1cce6040df7eca9209cf8b54396ada67" translate="yes" xml:space="preserve">
          <source>The child specification must exist and the corresponding child process must not be running.</source>
          <target state="translated">子规范必须存在,且相应的子进程不得运行。</target>
        </trans-unit>
        <trans-unit id="313526f010da8f629d585c9d88474ee1e8f4898f" translate="yes" xml:space="preserve">
          <source>The children is a list of modules, two-element tuples with module and arguments or a map with the child specification. A strategy is required to be provided through the &lt;code&gt;:strategy&lt;/code&gt; option. See &quot;start_link/2, init/2, and strategies&quot; for examples and other options.</source>
          <target state="translated">子代是模块列表，带有模块和参数的二元组或带有子代规范的映射。需要通过 &lt;code&gt;:strategy&lt;/code&gt; 选项提供策略。有关示例和其他选项，请参见&amp;ldquo; start_link / 2，init / 2和策略&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53b9ca94898155cae15db3cc7ef654f0bd4da634" translate="yes" xml:space="preserve">
          <source>The choice between &lt;code&gt;:do&lt;/code&gt; keyword and &lt;code&gt;do/end&lt;/code&gt; blocks is left to the user</source>
          <target state="translated">&lt;code&gt;:do&lt;/code&gt; 关键字和 &lt;code&gt;do/end&lt;/code&gt; 块之间的选择留给用户</target>
        </trans-unit>
        <trans-unit id="7b1b61c1ee1c04db8df86f79837449227f41eae5" translate="yes" xml:space="preserve">
          <source>The choice between parens and no parens is a matter of preference.</source>
          <target state="translated">在有朋与无朋之间的选择,是一个偏好的问题。</target>
        </trans-unit>
        <trans-unit id="a3a0a29c159eb1228d94714c1b6b06e0b32d7a74" translate="yes" xml:space="preserve">
          <source>The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces:</source>
          <target state="translated">选择parens和不选择parens也会影响缩进。当一个带parens的函数调用不适合放在同一行时,formatter会在parens周围引入一个新行,并用两个空格缩进参数。</target>
        </trans-unit>
        <trans-unit id="23594e68f8f770603c0ad519dc9b20dde3e76ac3" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. A more complete introduction to guards is available &lt;a href=&quot;guards&quot;&gt;in the Guards page&lt;/a&gt;.</source>
          <target state="translated">仅当用户的年龄大于或等于16岁时，才会调用上面的子句。有关&amp;ldquo;警卫队&amp;rdquo;的详细介绍，请&lt;a href=&quot;guards&quot;&gt;参见&amp;ldquo;警卫队&amp;rdquo;页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba6a994f50b6302be9c679389659a12c3a4b68fd" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. The whole guard is true if all guard expressions will evaluate to &lt;code&gt;true&lt;/code&gt;. A more complete introduction to guards is available &lt;a href=&quot;patterns-and-guards&quot;&gt;in the &quot;Patterns and Guards&quot; page&lt;/a&gt;.</source>
          <target state="translated">仅当用户的年龄大于或等于16时，才会调用上述子句。Guards还支持使用 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 联接多个条件。如果所有防护表达式都将评估为true，则整个防护为 &lt;code&gt;true&lt;/code&gt; 。关于卫兵的更完整介绍，请&lt;a href=&quot;patterns-and-guards&quot;&gt;参见&amp;ldquo;模式和卫兵&amp;rdquo;页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c255b3390bdbf75961fab635ba6b005f6d757746" translate="yes" xml:space="preserve">
          <source>The client sends the given &lt;code&gt;request&lt;/code&gt; to the server and waits until a reply arrives or a timeout occurs. &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; will be called on the server to handle the request.</source>
          <target state="translated">客户端将给定的 &lt;code&gt;request&lt;/code&gt; 到服务器，并等待答复到达或发生超时。将在服务器上调用&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;来处理请求。</target>
        </trans-unit>
        <trans-unit id="d9950721b47bf760ca7644941dac9e25516ba4de" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.01 is 0.0099999997</source>
          <target state="translated">与0.01最接近的可表示数是0.0099999997。</target>
        </trans-unit>
        <trans-unit id="94f439e6735d38fbe26e845fc67b04161ed13286" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.1 is 0.1000000014</source>
          <target state="translated">与0.1最接近的可表示数是0.1000000014。</target>
        </trans-unit>
        <trans-unit id="a2e208db8b2d737003cfa026657e7817cb56f94b" translate="yes" xml:space="preserve">
          <source>The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions:</source>
          <target state="translated">上面的代码有很长的行,运行formatter并不能解决这个问题。事实上,formatter可能会让你有复杂的表达式变得更加明显。</target>
        </trans-unit>
        <trans-unit id="8971296bf8b5fe352cb67c40d256dea059794cfe" translate="yes" xml:space="preserve">
          <source>The code above says we are only bringing in the functions from &lt;code&gt;MyLib&lt;/code&gt; so we can invoke &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; directly without the &lt;code&gt;MyLib.&lt;/code&gt; prefix. Even more important, &lt;code&gt;import MyLib&lt;/code&gt; says that we have an option to not &lt;code&gt;import MyLib&lt;/code&gt; at all as we can simply invoke the function as &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt;.</source>
          <target state="translated">上面的代码说我们只是从 &lt;code&gt;MyLib&lt;/code&gt; 中引入函数，因此我们可以直接调用 &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; 而不使用 &lt;code&gt;MyLib.&lt;/code&gt; 字首。更重要的是， &lt;code&gt;import MyLib&lt;/code&gt; 表示我们可以选择根本不 &lt;code&gt;import MyLib&lt;/code&gt; ，因为我们可以简单地将函数调用为 &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09481c86dbd26d18c6fe8e729156a7702b288946" translate="yes" xml:space="preserve">
          <source>The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line.</source>
          <target state="translated">上面的代码会被formatter保持每行一个关键词的输入。为了避免这种情况,只要把所有的东西压成一行就可以了。</target>
        </trans-unit>
        <trans-unit id="5a5a8b1aa48591121657910360da4599001ef7e7" translate="yes" xml:space="preserve">
          <source>The code above will fail because the &lt;code&gt;=&lt;/code&gt; operator always fails when the sides do not match and &lt;a href=&quot;#refute/2&quot;&gt;&lt;code&gt;refute/2&lt;/code&gt;&lt;/a&gt; does not change it.</source>
          <target state="translated">上面的代码将失败，因为当边不匹配且&lt;a href=&quot;#refute/2&quot;&gt; &lt;code&gt;refute/2&lt;/code&gt; &lt;/a&gt;不会更改它时， &lt;code&gt;=&lt;/code&gt; 运算符始终会失败。</target>
        </trans-unit>
        <trans-unit id="d1a28899a290431210335f780f9a3a344e1bdaa4" translate="yes" xml:space="preserve">
          <source>The code above will work but issue a warning: &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt;. The macro is overriding the original value and the original value is never used.</source>
          <target state="translated">上面的代码可以运行，但是会发出警告： &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt; 。宏将覆盖原始值，并且从不使用原始值。</target>
        </trans-unit>
        <trans-unit id="269d3d7086c8d03fa3a689c409e633046b40f522" translate="yes" xml:space="preserve">
          <source>The code above would have the same flaw: if we link the &lt;code&gt;serve(client)&lt;/code&gt; task to the acceptor, a crash when serving a request would bring the acceptor, and consequently all other connections, down.</source>
          <target state="translated">上面的代码将具有相同的缺陷：如果我们将 &lt;code&gt;serve(client)&lt;/code&gt; 任务链接到接受器，则在处理请求时发生崩溃将使接受器以及所有其他连接中断。</target>
        </trans-unit>
        <trans-unit id="382718e17e13c129c8263cdafc53473338fb082d" translate="yes" xml:space="preserve">
          <source>The code in the loaded &lt;code&gt;.iex.exs&lt;/code&gt; file is evaluated in the shell's context. For instance, any modules that are loaded or variables that are bound in the &lt;code&gt;.iex.exs&lt;/code&gt; file will be available in the shell after it has booted.</source>
          <target state="translated">在外壳的上下文中评估加载的 &lt;code&gt;.iex.exs&lt;/code&gt; 文件中的代码。例如，引导后，将在外壳中提供已加载的任何模块或 &lt;code&gt;.iex.exs&lt;/code&gt; 文件中绑定的变量。</target>
        </trans-unit>
        <trans-unit id="89723bc3e0f1ff8256d889a81362651a037ba774" translate="yes" xml:space="preserve">
          <source>The code is now more readable, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, &lt;code&gt;@impl true&lt;/code&gt; automatically marks the function as &lt;code&gt;@doc false&lt;/code&gt;, disabling documentation unless &lt;code&gt;@doc&lt;/code&gt; is explicitly set.</source>
          <target state="translated">该代码现在更具可读性，因为现在清楚哪些函数是API的一部分，哪些是回调实现。为了加强这个想法， &lt;code&gt;@impl true&lt;/code&gt; 将功能自动标记为 &lt;code&gt;@doc false&lt;/code&gt; ，除非明确设置了@doc，否则 &lt;code&gt;@doc&lt;/code&gt; 禁用文档。</target>
        </trans-unit>
        <trans-unit id="27bd571c88e679120d69355a8855de7b06b30a1a" translate="yes" xml:space="preserve">
          <source>The collection types are compared using the following rules:</source>
          <target state="translated">收集类型使用以下规则进行比较。</target>
        </trans-unit>
        <trans-unit id="8c5b2a728faaf0d704086c8a732474d34b64c7d1" translate="yes" xml:space="preserve">
          <source>The comma should be followed by a space.</source>
          <target state="translated">逗号后面应加一个空格。</target>
        </trans-unit>
        <trans-unit id="139636692335607d6eb4460b93391d027f1c3267" translate="yes" xml:space="preserve">
          <source>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</source>
          <target state="translated">上面的命令失败了,因为我们已经切换了shell。由于shell之间是相互隔离的,所以你不能从另一个shell访问在一个shell中定义的变量。</target>
        </trans-unit>
        <trans-unit id="000af91ba82011c87383cf8f5a08713fe7fef900" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;:error&lt;/code&gt;</source>
          <target state="translated">上面的命令返回 &lt;code&gt;:error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93e8c4e8d6a9562251088181806121ea8983b620" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;{:ok, bucket}&lt;/code&gt;</source>
          <target state="translated">上面的命令返回 &lt;code&gt;{:ok, bucket}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="919db13977d98a781eec05aba6aea3150c8048e9" translate="yes" xml:space="preserve">
          <source>The command above will start a new shell and connect to it. Create a new variable called &lt;code&gt;hello&lt;/code&gt; and assign some value to it:</source>
          <target state="translated">上面的命令将启动一个新的shell并连接到它。创建一个名为 &lt;code&gt;hello&lt;/code&gt; 的新变量，并为其分配一些值：</target>
        </trans-unit>
        <trans-unit id="604e09637e094315eab98b85fbd210082725e389" translate="yes" xml:space="preserve">
          <source>The command name will correspond to the portion of the module name following &lt;code&gt;Mix.Tasks.&lt;/code&gt;. For example, a module name of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt;&lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt;&lt;/a&gt; corresponds to a task name of &lt;code&gt;deps.clean&lt;/code&gt;.</source>
          <target state="translated">命令名称将与 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 之后的模块名称部分相对应。。例如，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt; &lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt; &lt;/a&gt;的模块名称与deps.clean的任务名称相对 &lt;code&gt;deps.clean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ecae1fb9875a4247d5f5ea9609a8cfd1c1df1d2" translate="yes" xml:space="preserve">
          <source>The community has also created its own tools, often to aid in production, other times in development:</source>
          <target state="translated">社区也创建了自己的工具,经常是为了辅助生产,其他时候是为了开发。</target>
        </trans-unit>
        <trans-unit id="efb56379060db8ad190cf0cb0689ca498a14c785" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">元素之间的比较必须使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f587be913201bd350f5a6a58f7e5d2545a34fce" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">元素之间的比较必须使用&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86fab95de2a0427fca68934f781f6fe06670a789" translate="yes" xml:space="preserve">
          <source>The compilation can be customized by passing a &lt;code&gt;compile&lt;/code&gt; option in the dependency:</source>
          <target state="translated">可以通过在依赖项中传递 &lt;code&gt;compile&lt;/code&gt; 选项来自定义编译：</target>
        </trans-unit>
        <trans-unit id="b72ead9d1380c933dae651b694aba918748f04d3" translate="yes" xml:space="preserve">
          <source>The compilation will fail because &lt;code&gt;My.Module&lt;/code&gt; when quoted is not an atom, but a syntax tree as follows:</source>
          <target state="translated">编译将失败，因为 &lt;code&gt;My.Module&lt;/code&gt; 引号的My.Module不是原子，而是语法树，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd0d32bee722121f8e488a947a395b8badae67cf" translate="yes" xml:space="preserve">
          <source>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</source>
          <target state="translated">编译后的模式在重复进行相同的匹配时非常有用。但请注意,编译后的模式不能存储在模块属性中,因为模式是在运行时生成的,在编译时无法存活。</target>
        </trans-unit>
        <trans-unit id="2c261a06d80c478e0111d6983a7ae911378fd70b" translate="yes" xml:space="preserve">
          <source>The compiler is telling us that invoking the &lt;code&gt;join&lt;/code&gt; function with two arguments will always choose the first definition of &lt;code&gt;join&lt;/code&gt; whereas the second one will only be invoked when three arguments are passed:</source>
          <target state="translated">编译器告诉我们，使用两个参数调用 &lt;code&gt;join&lt;/code&gt; 函数将始终选择 &lt;code&gt;join&lt;/code&gt; 的第一个定义，而仅当传递三个参数时才调用第二个定义：</target>
        </trans-unit>
        <trans-unit id="4a5b9456e8b2526749824cf107036fdea5219003" translate="yes" xml:space="preserve">
          <source>The compiler translates this into multiple functions with different arities, here &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; and &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt;, that represent cases when arguments for parameters with default values are passed or not passed.</source>
          <target state="translated">编译器将此转换为具有不同变量的多个函数，此处为 &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; 和 &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt; ，它们表示传递或不传递具有默认值的参数的情况。</target>
        </trans-unit>
        <trans-unit id="fbf77ba7c519d57f697a772e3efbb085cc5c852a" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">编译器利用临时模块来编译代码。例如， &lt;code&gt;elixir_compiler_1&lt;/code&gt; ， &lt;code&gt;elixir_compiler_2&lt;/code&gt; 等。如果编译后的代码存储对匿名函数或类似函数的引用，则Elixir编译器可能无法回收这些模块，从而在内存中保留了不必要的代码量，并最终导致诸如 &lt;code&gt;elixir_compiler_12345&lt;/code&gt; 之类的模块。</target>
        </trans-unit>
        <trans-unit id="25ad36289d9fc32f9ce285a83c0db949e85318f5" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, etc. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">编译器利用临时模块来编译代码。例如 &lt;code&gt;elixir_compiler_1&lt;/code&gt; ， &lt;code&gt;elixir_compiler_2&lt;/code&gt; 等。如果编译后的代码存储对匿名函数或类似函数的引用，则Elixir编译器可能无法回收这些模块，从而在内存中保留了不必要的代码量，最终导致诸如 &lt;code&gt;elixir_compiler_12345&lt;/code&gt; 之类的模块。</target>
        </trans-unit>
        <trans-unit id="4e326f0b1277ff195521c682d15083f035944526" translate="yes" xml:space="preserve">
          <source>The compiler will infer this argument as &lt;code&gt;map&lt;/code&gt;. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:</source>
          <target state="translated">编译器会将这个参数推断为 &lt;code&gt;map&lt;/code&gt; 。有时，推断将不是最佳的，特别是如果函数包含多个子句且参数每次都匹配不同值时。您可以通过在实现之前的任何时候仅声明函数头来为文档指定适当的名称：</target>
        </trans-unit>
        <trans-unit id="68165d5af4e0c7518ce750565d2875d5f1b99f6f" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, e.g. &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">&lt;code&gt;a ++ b&lt;/code&gt; 的复杂度与 &lt;code&gt;length(a)&lt;/code&gt; 成正比，因此避免重复附加到任意长度的 &lt;code&gt;list ++ [element]&lt;/code&gt; ，例如list ++ [element]。相反，请考虑通过 &lt;code&gt;[element | rest]&lt;/code&gt; ，然后反转。</target>
        </trans-unit>
        <trans-unit id="51b97324d416e9860c0329e32ca5a0050e8a20b3" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, for example, &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">&lt;code&gt;a ++ b&lt;/code&gt; 的复杂度与 &lt;code&gt;length(a)&lt;/code&gt; 成正比，因此请避免重复附加到任意长度的 &lt;code&gt;list ++ [element]&lt;/code&gt; ，例如list ++ [element]。而是考虑通过 &lt;code&gt;[element | rest]&lt;/code&gt; ，然后反转。</target>
        </trans-unit>
        <trans-unit id="ce5190846b0b9ce88bde5e1fb9838155c0302562" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a -- b&lt;/code&gt; is proportional to &lt;code&gt;length(a) * length(b)&lt;/code&gt;, meaning that it will be very slow if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are long lists. In such cases, consider converting each list to a &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; and using &lt;a href=&quot;mapset#difference/2&quot;&gt;&lt;code&gt;MapSet.difference/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a -- b&lt;/code&gt; 的复杂度与 &lt;code&gt;length(a) * length(b)&lt;/code&gt; 成正比，这意味着如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是长列表，它将非常慢。在这种情况下，请考虑将每个列表转换为&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;并使用&lt;a href=&quot;mapset#difference/2&quot;&gt; &lt;code&gt;MapSet.difference/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84ce76ba55c26126100351cef4100465580a3f63" translate="yes" xml:space="preserve">
          <source>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with &lt;a href=&quot;#stat/1&quot;&gt;&lt;code&gt;stat/1&lt;/code&gt;&lt;/a&gt; will most probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">压缩选项必须与读取或写入结合使用，但不能同时结合使用。请注意，使用&lt;a href=&quot;#stat/1&quot;&gt; &lt;code&gt;stat/1&lt;/code&gt; &lt;/a&gt;获得的文件大小很可能与可从压缩文件读取的字节数不匹配。</target>
        </trans-unit>
        <trans-unit id="6d2bc42beb1d07a11bffabca4e75ecee65b8f3cc" translate="yes" xml:space="preserve">
          <source>The concurrency can be increased or decreased using the &lt;code&gt;:max_concurrency&lt;/code&gt; option. For example, if the tasks are IO heavy, the value can be increased:</source>
          <target state="translated">可以使用 &lt;code&gt;:max_concurrency&lt;/code&gt; 选项增加或减少并发性。例如，如果任务是IO繁重的任务，则可以增加该值：</target>
        </trans-unit>
        <trans-unit id="2dcb06049bb00d9d82db3a23393505f88e85183b" translate="yes" xml:space="preserve">
          <source>The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them.</source>
          <target state="translated">配置会被合并在一起,在冲突的情况下,第二个配置的值比第一个配置的值优先。如果两个值都设置为关键字列表,则将它们深度合并。</target>
        </trans-unit>
        <trans-unit id="8bfd0598c3186c98ed3b75f81d353f661a54c9d0" translate="yes" xml:space="preserve">
          <source>The console backend allows you to customize the format of your log messages with the &lt;code&gt;:format&lt;/code&gt; option.</source>
          <target state="translated">控制台后端允许您使用 &lt;code&gt;:format&lt;/code&gt; 选项来自定义日志消息的格式。</target>
        </trans-unit>
        <trans-unit id="7235027880d78a2aea2ca7dc4debaca1a57f60b0" translate="yes" xml:space="preserve">
          <source>The console backend logs messages by printing them to the console. It supports the following options:</source>
          <target state="translated">控制台后台通过打印消息到控制台来记录消息。它支持以下选项:</target>
        </trans-unit>
        <trans-unit id="b55d6ec1cda71844493902f9fd51af5232de80cd" translate="yes" xml:space="preserve">
          <source>The contents are compared to avoid asking the user to override if the contents did not change. Returns false if the file exists and the content is the same or the user forbade to override it. Returns true otherwise.</source>
          <target state="translated">对内容进行比较,以避免在内容没有改变的情况下要求用户覆盖。如果文件存在且内容相同或用户禁止覆盖,则返回false。否则返回true。</target>
        </trans-unit>
        <trans-unit id="8de6b43b33ab75286e101ec804e217bdf4636eeb" translate="yes" xml:space="preserve">
          <source>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</source>
          <target state="translated">上下文用于将回调的信息传递给测试。为了将信息从测试传递给回调,ExUnit提供了标签。</target>
        </trans-unit>
        <trans-unit id="0ac124f60dd5f0bf6457e5116fc9264ff455388d" translate="yes" xml:space="preserve">
          <source>The context returned by &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt; will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself. For instance, the &lt;code&gt;conn&lt;/code&gt; from the previous example can be accessed as:</source>
          <target state="translated">&lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; &lt;/a&gt;返回的上下文将在所有后续的 &lt;code&gt;setup_all&lt;/code&gt; ， &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 本身中可用。例如，上例中的 &lt;code&gt;conn&lt;/code&gt; 可以通过以下方式访问：</target>
        </trans-unit>
        <trans-unit id="df9b547258c058ce1d60f5a04eb16b39a7714b90" translate="yes" xml:space="preserve">
          <source>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</source>
          <target state="translated">延续是当枚举被暂停时作为结果返回的闭包。当调用时,它期待一个新的累加器,并返回结果。</target>
        </trans-unit>
        <trans-unit id="95e2451a8bd06ec3ff7404ffc596006e9814e181" translate="yes" xml:space="preserve">
          <source>The correct way to write the refutation above is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">编写上述反驳的正确方法是使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="471e051b1dfc7605a0864374979ff909fdd918ff" translate="yes" xml:space="preserve">
          <source>The corresponding child process must not be running; use &lt;a href=&quot;#terminate_child/2&quot;&gt;&lt;code&gt;terminate_child/2&lt;/code&gt;&lt;/a&gt; to terminate it if it's running.</source>
          <target state="translated">相应的子进程一定不能运行；如果正在运行，请使用&lt;a href=&quot;#terminate_child/2&quot;&gt; &lt;code&gt;terminate_child/2&lt;/code&gt; &lt;/a&gt;终止它。</target>
        </trans-unit>
        <trans-unit id="25f2832dc850f5e3ce868623e448ed6173ae8a76" translate="yes" xml:space="preserve">
          <source>The crypto module</source>
          <target state="translated">加密模块</target>
        </trans-unit>
        <trans-unit id="6c25b4183ffb2089e8226e185f14e599e79dc998" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以随时通过&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;访问当前环境。在宏内部，可以通过&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;访问调用者环境。</target>
        </trans-unit>
        <trans-unit id="9ecd090fb1dcdddfdde8d184412bdb4ef34572bf" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以随时通过&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;访问当前环境。在宏内部，可以通过&lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;访问调用者环境。</target>
        </trans-unit>
        <trans-unit id="f3e60a2c1efd523ca96fe66ffa2af8ecfa3ad2af" translate="yes" xml:space="preserve">
          <source>The current working directory is set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the &lt;code&gt;:cd&lt;/code&gt; option of &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前工作目录是为BEAM全局设置的。如果多个进程同时更改当前工作目录，则可能导致争用情况。要在给定目录中运行外部命令而不更改全局当前工作目录，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;:cd&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="11ca9436cf4382b007a36385f24017c6fe9ea438" translate="yes" xml:space="preserve">
          <source>The daemon will write all of its standard output to the &quot;tmp/log/&quot; directory in the release root. You can watch the log file by doing &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; or similar. Once files get too large, the index suffix will be incremented. A developer can also attach to the standard input of the daemon by invoking &quot;to_erl tmp/pipe/&quot; from the release root. However, note that attaching to the system should be done with extreme care, since the usual commands for exiting an Elixir system, such as hitting Ctrl+C twice or Ctrl+\, will actually shut down the daemon. Therefore, using &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; should be preferred, even in daemon mode.</source>
          <target state="translated">守护程序会将其所有标准输出写入发布根目录中的&amp;ldquo; tmp / log /&amp;rdquo;目录。您可以通过执行 &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; 或类似方法来查看日志文件。一旦文件太大，索引后缀将增加。开发人员还可以通过从发行版根目录调用&amp;ldquo; to_erl tmp / pipe /&amp;rdquo;来附加到守护程序的标准输入。但是，请注意，连接到系统时应格外小心，因为退出Elixir系统的常用命令（例如，两次按Ctrl + C或Ctrl + \）将实际上关闭守护程序。因此，即使在守护程序模式下，也应该首选使用 &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8cd8e8b468d03cac9b2aec5728511f109cbd6ae" translate="yes" xml:space="preserve">
          <source>The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.</source>
          <target state="translated">您正在实现的协议的数据结构必须是协议中定义的所有函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="b2d538224a6564739f222b37335408e88b676276" translate="yes" xml:space="preserve">
          <source>The date and time fields in the struct can be accessed directly:</source>
          <target state="translated">可以直接访问结构中的日期和时间字段。</target>
        </trans-unit>
        <trans-unit id="efa23e38a0ca17fbedb614ea88023f4b1e8f6b6f" translate="yes" xml:space="preserve">
          <source>The datetime can be any of the Calendar types (&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use &lt;code&gt;%Y&lt;/code&gt; to format the year, the datetime must have the &lt;code&gt;:year&lt;/code&gt; field. Therefore, if you pass a &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, or a map without the &lt;code&gt;:year&lt;/code&gt; field to a format that expects &lt;code&gt;%Y&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">datetime可以是任何Calendar类型（&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;）或任何映射，只要它们包含格式化所需的所有相关字段即可。例如，如果使用 &lt;code&gt;%Y&lt;/code&gt; 格式化年份，则datetime必须具有 &lt;code&gt;:year&lt;/code&gt; 字段。因此，如果将&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;或不带 &lt;code&gt;:year&lt;/code&gt; 字段的地图传递给期望 &lt;code&gt;%Y&lt;/code&gt; 的格式，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="104ca7733bdc0fce19ec1a42bd6f6c3a9728b295" translate="yes" xml:space="preserve">
          <source>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</source>
          <target state="translated">天数按格里高利日计算。返回的日期与输入的日历相同。</target>
        </trans-unit>
        <trans-unit id="81de1658f9b930a338fa7d15b3cd46a31f6ce081" translate="yes" xml:space="preserve">
          <source>The default engine used by EEx.</source>
          <target state="translated">EEx使用的默认引擎。</target>
        </trans-unit>
        <trans-unit id="5c2506b585933bcf9d63b9d589d2095db52d7f38" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">默认节点是本地节点&lt;a href=&quot;#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;node&lt;/code&gt; 是本地节点，该函数还将所有其他未知节点的cookie设置为 &lt;code&gt;cookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1841b4dcd409156ad003b434d7d06485770c7448" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;node#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">默认节点是本地节点&lt;a href=&quot;node#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;node&lt;/code&gt; 是本地节点，该函数还将所有其他未知节点的cookie设置为 &lt;code&gt;cookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7448078e00a12f44bc6d6a512061a6e8e76068" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds.</source>
          <target state="translated">默认输出包含从所有匹配函数中收集的数据。标题后的第一行包含部分结果的总和,以及列出的所有函数调用的平均时间。下面的几行包含函数调用,然后是函数被调用的次数,然后是调用所用时间的百分比,然后是该函数的总时间(以微秒为单位),最后是每次调用的平均时间(以微秒为单位)。</target>
        </trans-unit>
        <trans-unit id="ea39ed70f4785b6c480b790dacca9bfe36cb2b1f" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;code&gt;&amp;lt;--&lt;/code&gt; symbol is meant to help visualize where a new module call count begins.</source>
          <target state="translated">默认输出包含从所有匹配函数收集的数据。左列构成每个模块，其总调用计数跟踪显示在右侧。每个模块的计数均按以下功能区分。在 &lt;code&gt;&amp;lt;--&lt;/code&gt; 一个新的模块调用计数开始的地方符号是为了帮助可视化。</target>
        </trans-unit>
        <trans-unit id="819e6f3391fb45f7ce5241a6dd1d1431dc481702" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning:</source>
          <target state="translated">默认输出包含从所有剖析过程收集的数据。所有时间都是挂钟毫秒。这些列具有以下含义。</target>
        </trans-unit>
        <trans-unit id="27a16bfaa2e09572a48e318dc8d0f73e02fd7ff6" translate="yes" xml:space="preserve">
          <source>The default value will not be passed through the update function.</source>
          <target state="translated">默认值不会通过更新函数传递。</target>
        </trans-unit>
        <trans-unit id="380321e8388d234e55ec92513260d8b22df6e305" translate="yes" xml:space="preserve">
          <source>The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:</source>
          <target state="translated">上面的定义在这个特殊的例子中是行不通的,因为它会试图用一个空列表的初始值来启动计数器。然而,在你自己的代理中,这可能是一个可行的选择。一个常见的方法是使用关键字列表,因为这将允许设置初始值并给计数器进程命名,例如。</target>
        </trans-unit>
        <trans-unit id="14e3a7f1b4ff430ef2347af078514bfcd6aac53f" translate="yes" xml:space="preserve">
          <source>The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">依赖项的版本应按照语义版本控制进行格式化，并且必须按照&amp;ldquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;模块中的定义指定要求。</target>
        </trans-unit>
        <trans-unit id="0199850bb5adebc71f4018576818506ad556f1cc" translate="yes" xml:space="preserve">
          <source>The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">设备将被创建并发送到给定的功能。函数返回时，设备将关闭。最终结果将是带有 &lt;code&gt;:ok&lt;/code&gt; 的元组和函数的结果。</target>
        </trans-unit>
        <trans-unit id="92c1c70614d3e16189eb567106d0cd377288e598" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; is that the latter is more strict when comparing integers and floats:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 之间的区别在于，在比较整数和浮点数时，后者更加严格：</target>
        </trans-unit>
        <trans-unit id="bce9ae6a81650ed69afbfa89ac267aa5dbf3c9da" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">两种方法之间的区别在于，基于模块的管理器使您可以直接控制管理器的初始化方式。我们没有通过自动初始化的子代列表来调用&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt;，而是通过在其&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调中调用&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; 来&lt;/a&gt;手动初始化子代。</target>
        </trans-unit>
        <trans-unit id="7b165d79002d46e097dd675e283b2c25db64a858" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">两种方法之间的区别在于，基于模块的管理器使您可以直接控制管理器的初始化方式。我们没有通过自动初始化的子代列表调用&lt;a href=&quot;supervisor#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt;，而是通过在其&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调中调用&lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; 来&lt;/a&gt;手动初始化子代。</target>
        </trans-unit>
        <trans-unit id="3b5eb7b6faff508891acf9d2eb056d03565a244c" translate="yes" xml:space="preserve">
          <source>The difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.</source>
          <target state="translated">不同的是,匿名函数要求目标节点与调用者的代码版本完全相同。使用模块、函数和参数更稳健,因为你只需要在给定的模块中找到一个具有匹配的arity的函数。</target>
        </trans-unit>
        <trans-unit id="42de26ff16cbc728a59ab8e0d11febc5d9712289" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">区别在于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;期望子规范在调用&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;的那一刻出现，并且不再在init回调上。如果初始化时有任何初始参数，例如 &lt;code&gt;[initial_arg]&lt;/code&gt; ，则可以在&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;:extra_arguments&lt;/code&gt; 标志中给出。</target>
        </trans-unit>
        <trans-unit id="5358501133f2ba56bf1b306cdd649fc8fee2e62a" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">区别在于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;期望子规范在调用&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;的那一刻出现，并且不再位于init回调上。如果初始化时有任何初始参数，例如 &lt;code&gt;[initial_arg]&lt;/code&gt; ，则可以在&lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;:extra_arguments&lt;/code&gt; 标志中给出。</target>
        </trans-unit>
        <trans-unit id="53c4296a8b739f59bee25619f4e6585ba6646d78" translate="yes" xml:space="preserve">
          <source>The digraph module</source>
          <target state="translated">图形模块</target>
        </trans-unit>
        <trans-unit id="d3687778e68f2e38fa3eb29706a7417475b459a2" translate="yes" xml:space="preserve">
          <source>The document starts flat (without breaks) until a group is found.</source>
          <target state="translated">文件开始时是平铺直叙的(没有间断),直到找到一个组。</target>
        </trans-unit>
        <trans-unit id="2ad969954076e16dcc1ff7f0c2aba06e5e46ee7f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) in Elixir can be used for remote calls:</source>
          <target state="translated">Elixir中的点（ &lt;code&gt;.&lt;/code&gt; ）可用于远程呼叫：</target>
        </trans-unit>
        <trans-unit id="555f5e20b9d1a7a0564cfc99c5aa3c497147b302" translate="yes" xml:space="preserve">
          <source>The dot may be used to invoke anonymous functions too:</source>
          <target state="translated">点也可以用来调用匿名函数。</target>
        </trans-unit>
        <trans-unit id="6bfa76913b9787750a0bfa227b60b3c7658a646a" translate="yes" xml:space="preserve">
          <source>The downside of this approach is that the doctest result is not really what users would see in the terminal.</source>
          <target state="translated">这种方法的缺点是,doctest的结果并不是用户在终端上真正看到的。</target>
        </trans-unit>
        <trans-unit id="2b457ad21100bb14e953ebf6025ecbe3add69796" translate="yes" xml:space="preserve">
          <source>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</source>
          <target state="translated">返回的两个列表中的元素与原始枚举中的元素的相对顺序相同(如果这样的枚举是有序的,像一个列表)。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="46fd29816806a299fb407c730c9ba36ba20c158f" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. It is required to return either &lt;code&gt;{:ok, term}&lt;/code&gt;, where term is an atom. It is possible to return something else than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">编码器功能应该从给定的字符串创建一个原子。需要返回 &lt;code&gt;{:ok, term}&lt;/code&gt; ，其中term是一个原子。可以返回原子以外的其他东西，但是，在这种情况下，AST不再&amp;ldquo;有效&amp;rdquo;，因为它不能用于编译或评估Elixir代码。一个用例是，如果您想在面向用户的情况下使用Elixir解析器，但又不想用尽原子表。</target>
        </trans-unit>
        <trans-unit id="865f48d17fe14cd4996952b1bd0f45d973a938ce" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return &lt;code&gt;{:ok, term}&lt;/code&gt;, where &lt;code&gt;term&lt;/code&gt; is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">编码器功能应该从给定的字符串创建一个原子。为了产生有效的AST，需要返回 &lt;code&gt;{:ok, term}&lt;/code&gt; ，其中 &lt;code&gt;term&lt;/code&gt; 是一个原子。可以返回原子以外的其他东西，但是，在这种情况下，AST不再&amp;ldquo;有效&amp;rdquo;，因为它不能用于编译或评估Elixir代码。一个用例是，如果您想在面向用户的情况下使用Elixir解析器，但又不想用尽原子表。</target>
        </trans-unit>
        <trans-unit id="7abcd054d6c0c3b0676a107d280986f037e15ba1" translate="yes" xml:space="preserve">
          <source>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt;.</source>
          <target state="translated">编码器功能将接收原子名称（作为二进制文件）和带有当前文件，行和列的关键字列表。它必须返回 &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d93739e1f908805f248fbd3ca05efb8a31a93ffb" translate="yes" xml:space="preserve">
          <source>The environment</source>
          <target state="translated">环境问题</target>
        </trans-unit>
        <trans-unit id="b1059c7023600cf66d37436e09b5b8c7e27f7d77" translate="yes" xml:space="preserve">
          <source>The environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the &lt;code&gt;:prod&lt;/code&gt; environment.</source>
          <target state="translated">该环境仅适用于当前项目。正如我们将在以后的章节中看到的，默认情况下，添加到项目中的所有依赖项都将在 &lt;code&gt;:prod&lt;/code&gt; 环境中运行。</target>
        </trans-unit>
        <trans-unit id="569fc959f1dad768558df72d1e65bcb68e016b15" translate="yes" xml:space="preserve">
          <source>The environment can be changed via the command line by setting the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable, for example:</source>
          <target state="translated">可以通过设置 &lt;code&gt;MIX_ENV&lt;/code&gt; 环境变量，通过命令行来更改环境，例如：</target>
        </trans-unit>
        <trans-unit id="514025daae02cae2313ca1d48fbcc882bf070826" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; &lt;/a&gt;读取环境。</target>
        </trans-unit>
        <trans-unit id="cfd48ae86d7fb6e0cc9118fb73487346d9610f87" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;mix#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;mix#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; &lt;/a&gt;读取环境。</target>
        </trans-unit>
        <trans-unit id="79b786be3813b81bda2dd7613367e75b678039b6" translate="yes" xml:space="preserve">
          <source>The environment is available after loading the application, which is a process explained later:</source>
          <target state="translated">加载应用后就可以使用环境了,这个过程后面会解释。</target>
        </trans-unit>
        <trans-unit id="97a5f35bc8e443b15b7816310584c96da8ae8afe" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;exunit.test&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exunit.testmodule&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exunit.test&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;exunit.testmodule&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;返回的错误状态</target>
        </trans-unit>
        <trans-unit id="1dd062c870a86dc73f9a75e2843a53a9fc3ffd4b" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;返回的错误状态</target>
        </trans-unit>
        <trans-unit id="67a7d2b9fd9ee22fe670aa85c88c37eecda3144b" translate="yes" xml:space="preserve">
          <source>The exact chunks that are kept are not documented and may change in future versions.</source>
          <target state="translated">保留的具体分块没有记录,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="fd79581f4945ce7000f24bd77d80edb09d58223a" translate="yes" xml:space="preserve">
          <source>The example above broadcasted the message &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="translated">上面的示例将消息 &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; 到在&amp;ldquo; topic&amp;rdquo;（或我们迄今为止称为&amp;ldquo; key&amp;rdquo;） &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 下注册的所有进程。</target>
        </trans-unit>
        <trans-unit id="85cebbc730e74ea1586122c70e3648ace6b606a3" translate="yes" xml:space="preserve">
          <source>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with &lt;code&gt;100_000&lt;/code&gt; items. Then we keep all odd elements from the list, generating a new list, now with &lt;code&gt;50_000&lt;/code&gt; items, and then we sum all entries.</source>
          <target state="translated">上面的示例具有一系列操作。我们从一个范围开始，然后将范围中的每个元素乘以3。现在，第一个操作将创建并返回一个包含 &lt;code&gt;100_000&lt;/code&gt; 个项目的列表。然后，我们保留列表中的所有奇数元素，生成一个新列表，现在具有 &lt;code&gt;50_000&lt;/code&gt; 个项目，然后对所有条目求和。</target>
        </trans-unit>
        <trans-unit id="d7a86a0bce3d2d4979cfe2b252cb1ba44bf3ffc0" translate="yes" xml:space="preserve">
          <source>The example above is the same as calling &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt;.</source>
          <target state="translated">上面的示例与调用 &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34a98e7e58a5ad26483cead8675329ffdc04e919" translate="yes" xml:space="preserve">
          <source>The example above rescues the runtime error and returns the error itself which is then printed in the &lt;code&gt;iex&lt;/code&gt; session.</source>
          <target state="translated">上面的示例挽救了运行时错误，并返回错误本身，然后将其打印在 &lt;code&gt;iex&lt;/code&gt; 会话中。</target>
        </trans-unit>
        <trans-unit id="a1acf2309aa592e7d6d6148eb2c43c7439baf836" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred strategy for customizing exception messages.</source>
          <target state="translated">上面的例子显示了自定义异常消息的首选策略。</target>
        </trans-unit>
        <trans-unit id="7c4ee977260f8fcae5e39eaa8c9f47beb473c79e" translate="yes" xml:space="preserve">
          <source>The example above will define two modules: &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt;. The second can be accessed as &lt;code&gt;Bar&lt;/code&gt; inside &lt;code&gt;Foo&lt;/code&gt; as long as they are in the same lexical scope. The code above is exactly the same as:</source>
          <target state="translated">上面的示例将定义两个模块： &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Foo.Bar&lt;/code&gt; 。第二个可以作为访问 &lt;code&gt;Bar&lt;/code&gt; 内 &lt;code&gt;Foo&lt;/code&gt; ，只要它们是在同一个词汇范围。上面的代码与以下代码完全相同：</target>
        </trans-unit>
        <trans-unit id="8af5b80536d2c072fd5d6366536aa5700dca7b65" translate="yes" xml:space="preserve">
          <source>The example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.</source>
          <target state="translated">上面的例子将获取你所选文件的前10行。这意味着流对于处理大文件甚至是网络资源等慢速资源是非常有用的。</target>
        </trans-unit>
        <trans-unit id="696bcc0172521f253466c2cb561bc8d6cc698268" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 与右边列表中的第一个值匹配时，以上示例才有效。否则，它将引发&lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt;（就像 &lt;code&gt;=&lt;/code&gt; 运算符一样）。</target>
        </trans-unit>
        <trans-unit id="b5335acb8d877ec62b7cb06ce91a567ae1709575" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 与右边列表中的第一个值匹配时，以上示例才有效。否则，它将引发&lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt;（就像 &lt;code&gt;=&lt;/code&gt; 运算符一样）。</target>
        </trans-unit>
        <trans-unit id="6b460f75ed7a246aed0999b0840cd9a86244be18" translate="yes" xml:space="preserve">
          <source>The example above will print:</source>
          <target state="translated">上面的例子就可以打印了。</target>
        </trans-unit>
        <trans-unit id="fb87f61c9de07aa0c29854b1fe6c1165c0f17fed" translate="yes" xml:space="preserve">
          <source>The example above will run all tests that have the external option set to &lt;code&gt;true&lt;/code&gt;. It is also possible to include all examples that have a given tag, regardless of its value:</source>
          <target state="translated">上面的示例将运行所有将外部选项设置为 &lt;code&gt;true&lt;/code&gt; 的测试。也可以包括所有具有给定标签的示例，无论其值如何：</target>
        </trans-unit>
        <trans-unit id="a35cc3928c93cd1525534e5aae37a525e3a1f63a" translate="yes" xml:space="preserve">
          <source>The example below prints the available compilers and then the list of dependencies.</source>
          <target state="translated">下面的例子打印了可用的编译器,然后是依赖列表。</target>
        </trans-unit>
        <trans-unit id="fd542bcb5f7a7bfb0b02572bb9041c4454ce88bf" translate="yes" xml:space="preserve">
          <source>The examples below use the &lt;code&gt;:exrop&lt;/code&gt; pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then &lt;code&gt;:exsss&lt;/code&gt; is the default algorithm. If you are using &lt;code&gt;:exsplus&lt;/code&gt;, then please update, as this algorithm is deprecated since Erlang/OTP 20.</source>
          <target state="translated">下面的示例使用 &lt;code&gt;:exrop&lt;/code&gt; 伪随机算法，因为它是Erlang / OTP 20中的默认算法，但是，如果您使用的是Erlang / OTP 22或更高版本，则 &lt;code&gt;:exsss&lt;/code&gt; 是默认算法。如果使用 &lt;code&gt;:exsplus&lt;/code&gt; ，请更新，因为从Erlang / OTP 20开始不推荐使用此算法。</target>
        </trans-unit>
        <trans-unit id="977b62dac31ac2298799e3e82efadb76ace792aa" translate="yes" xml:space="preserve">
          <source>The examples below will use &lt;code&gt;break!&lt;/code&gt;, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name &lt;code&gt;IEx.break!&lt;/code&gt;.</source>
          <target state="translated">以下示例将使用 &lt;code&gt;break!&lt;/code&gt; ，假设您是直接从IEx Shell中设置断点。但是，您可以使用完全限定的名称 &lt;code&gt;IEx.break!&lt;/code&gt; 在任何地方设置中断！。</target>
        </trans-unit>
        <trans-unit id="598b6c321009ab41147aeda0cc432613c93bc6ff" translate="yes" xml:space="preserve">
          <source>The exception type</source>
          <target state="translated">异常类型</target>
        </trans-unit>
        <trans-unit id="96d166dd9433a91274c33b5c64faa14557b71d73" translate="yes" xml:space="preserve">
          <source>The expected result should start at the next line after the &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and it is terminated either by a newline.</source>
          <target state="translated">预期结果应从 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 或 &lt;code&gt;...&amp;gt;&lt;/code&gt; 行之后的下一行开始，并以换行符终止。</target>
        </trans-unit>
        <trans-unit id="ef1dcbe751c0f9e41d4eb9dc12ae9aa4ff81e740" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</source>
          <target state="translated">这个函数使用了Erlang的术语排序,这意味着比较是结构性的,而不是语义性的。例如</target>
        </trans-unit>
        <trans-unit id="9d619b509d29dcc70d09a1c1eedfade7f7d69f11" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">该函数使用Erlang术语排序的事实意味着比较是结构化的而不是语义化的。因此，如果要比较结构，大多数结构都提供&amp;ldquo;比较&amp;rdquo;功能，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;，该函数接收两个结构并返回 &lt;code&gt;:lt&lt;/code&gt; （小于） &lt;code&gt;:eq&lt;/code&gt; （等于）和 &lt;code&gt;:gt&lt;/code&gt; （比...更棒）。如果将模块作为排序功能传递，Elixir将自动使用该模块的 &lt;code&gt;compare/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a8e9535a979f24690a83f0d69ec866c95c5b87d9" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;enum#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">通过发出使用警告可以有效地弃用该功能。这也称为硬弃用。为了弃用某个功能，建议的替代方案必须至少存在三个次要版本。例如，在Elixir v1.1中，不赞成使用 &lt;code&gt;Enum.uniq/2&lt;/code&gt; ,而推荐使用&lt;a href=&quot;enum#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt;。这意味着过时警告只能由Elixir v1.4或更高版本发出。</target>
        </trans-unit>
        <trans-unit id="767e9fa4f6cbd49737c9ee934e26b4707f937c6f" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">通过发出使用警告可以有效地弃用该功能。这也称为硬弃用。为了弃用某个功能，建议的替代方案必须至少存在三个次要版本。例如，在Elixir v1.1中对 &lt;code&gt;Enum.uniq/2&lt;/code&gt; 进行了软弃用，以支持&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt;。这意味着仅Elixir v1.4或更高版本会发出弃用警告。</target>
        </trans-unit>
        <trans-unit id="77826c76ea0072ad69d2f391c353d094902019fd" translate="yes" xml:space="preserve">
          <source>The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.</source>
          <target state="translated">该功能被删除。这只能发生在主要的版本中。这意味着Elixir v1.x中的废弃功能只能由Elixir v2.x删除。</target>
        </trans-unit>
        <trans-unit id="64f27bcc28943bbd06806f078df1fb5cd0c4fa41" translate="yes" xml:space="preserve">
          <source>The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.</source>
          <target state="translated">这个特性是软弃用的,这意味着CHANGELOG和文档都必须将该特性列为弃用,但运行代码时却不会发出有效的警告。这意味着CHANGELOG和文档都必须将该特性列为过时的特性,但运行代码时不会发出有效的警告。没有要求对一个特性进行软废弃。</target>
        </trans-unit>
        <trans-unit id="aaf695dceb54489cced53f84555aabadc2f0e697" translate="yes" xml:space="preserve">
          <source>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">如果文件不存在，则创建该文件。如果存在，则先前的内容将被覆盖。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="d594748254e0bf9d6de08774efbf46885ccdc846" translate="yes" xml:space="preserve">
          <source>The file is created if it doesn't exist. Requires datetime in UTC (as returned by &lt;code&gt;:erlang.universaltime()&lt;/code&gt;) or an integer representing the POSIX timestamp (as returned by &lt;code&gt;System.os_time(:second)&lt;/code&gt;).</source>
          <target state="translated">如果文件不存在，则会创建该文件。需要UTC中的日期时间（由 &lt;code&gt;:erlang.universaltime()&lt;/code&gt; 返回）或代表POSIX时间戳的整数（由 &lt;code&gt;System.os_time(:second)&lt;/code&gt; 返回）。</target>
        </trans-unit>
        <trans-unit id="16e6a8d0dd5fc8fad11975b4cd8380cee1d272d3" translate="yes" xml:space="preserve">
          <source>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</source>
          <target state="translated">打开文件,作为参数给函数,函数返回后自动关闭,不管执行函数时是否有错误。</target>
        </trans-unit>
        <trans-unit id="7da78c24b03af92a331655b22affad9970828441" translate="yes" xml:space="preserve">
          <source>The file will be compiled in memory and executed, printing &amp;ldquo;3&amp;rdquo; as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</source>
          <target state="translated">该文件将在内存中编译并执行，结果打印为&amp;ldquo; 3&amp;rdquo;。不会创建任何字节码文件。在以下示例中，我们建议您将代码写入脚本文件并执行，如上所示。</target>
        </trans-unit>
        <trans-unit id="163b392b3771b3d68e4cabd76e12f649d752ed1d" translate="yes" xml:space="preserve">
          <source>The final code for the application built in this guide is in &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;this repository&lt;/a&gt; and can be used as a reference.</source>
          <target state="translated">本指南中构建的应用程序的最终代码位于&lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;此存储库中&lt;/a&gt;，可以用作参考。</target>
        </trans-unit>
        <trans-unit id="849e4d016851d364ddd912997469160b512c2434" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">最终的模块名称将为 &lt;code&gt;MyHelpers.Module&lt;/code&gt; 而不是 &lt;code&gt;My.Module&lt;/code&gt; 。使用&lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; 时&lt;/a&gt;，会考虑此类别名。本地和远程宏也得到了扩展。我们可以重写上面的宏以将此函数用作：</target>
        </trans-unit>
        <trans-unit id="eeed0a9446d454784748ae3c92f5f970ae5e8749" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;macro#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">最终的模块名称将为 &lt;code&gt;MyHelpers.Module&lt;/code&gt; 而不是 &lt;code&gt;My.Module&lt;/code&gt; 。使用&lt;a href=&quot;macro#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; 时&lt;/a&gt;，将考虑此类别名。本地和远程宏也得到了扩展。我们可以重写上面的宏以将此函数用作：</target>
        </trans-unit>
        <trans-unit id="c94b7aa6c8d6098097b882564487315e75f42062" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; is a list of child specifications as defined in the &quot;child_spec/1&quot; section above.</source>
          <target state="translated">给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;提供的第一个参数是上面&amp;ldquo; child_spec / 1&amp;rdquo;部分中定义的子级规范列表。</target>
        </trans-unit>
        <trans-unit id="13a0df9187b50523011cbb4505688a72e2b67377" translate="yes" xml:space="preserve">
          <source>The first argument is the application name. The second argument &lt;code&gt;key_or_path&lt;/code&gt; is either an atom key or a path to traverse in search of the configuration, starting with an atom key.</source>
          <target state="translated">第一个参数是应用程序名称。第二个参数 &lt;code&gt;key_or_path&lt;/code&gt; 是原子键，或者是从原子键开始搜索配置时要遍历的路径。</target>
        </trans-unit>
        <trans-unit id="3bd0d4cfc55b69d9253066edc78349e5a5f0a43e" translate="yes" xml:space="preserve">
          <source>The first clause above will only match when &lt;code&gt;x&lt;/code&gt; is positive.</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 为正数时，上面的第一个子句才匹配。</target>
        </trans-unit>
        <trans-unit id="eb035f0f30f88032dbb2e6101c25284087903853" translate="yes" xml:space="preserve">
          <source>The first clause has a guard which says &amp;ldquo;use this definition if and only if &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;1&lt;/code&gt;&amp;rdquo;. Since this is not the case, Elixir proceeds to the next clause&amp;rsquo;s definition.</source>
          <target state="translated">第一个子句有一个保护语，它表示&amp;ldquo;仅当 &lt;code&gt;n&lt;/code&gt; 小于或等于 &lt;code&gt;1&lt;/code&gt; 时使用此定义&amp;rdquo;。由于不是这种情况，因此Elixir进入下一个子句的定义。</target>
        </trans-unit>
        <trans-unit id="89e50c2ad64d1cb084a88caace5a204ed21c004f" translate="yes" xml:space="preserve">
          <source>The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.</source>
          <target state="translated">第一列是该功能被硬性废弃的版本。第二栏简要描述了被废弃的功能,第三栏解释了替换的功能以及替换的版本。</target>
        </trans-unit>
        <trans-unit id="090b48aa7b27ba7aabd1d7a17461511059a79e62" translate="yes" xml:space="preserve">
          <source>The first element is always dropped, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为0 ，否则始终删除第一个元素。</target>
        </trans-unit>
        <trans-unit id="f10968f84672fced5f1e4ec8ec8d8d3398ac17ef" translate="yes" xml:space="preserve">
          <source>The first element is always included, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为0 ，否则始终包含第一个元素。</target>
        </trans-unit>
        <trans-unit id="d62944a019ad040d05e692b397bd4389633cb416" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function, unless &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，否则始终将第一个元素传递给给定的函数。</target>
        </trans-unit>
        <trans-unit id="6d3d07fd30dfdee5089f7add816955448e8a7e62" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function.</source>
          <target state="translated">第一个元素总是传递给给定的函数。</target>
        </trans-unit>
        <trans-unit id="a20362c2ee76acf3525cfe072360096fe727a0f9" translate="yes" xml:space="preserve">
          <source>The first element is an atom or another tuple in the same representation;</source>
          <target state="translated">第一个元素是原子或同一表示方式的另一个元组。</target>
        </trans-unit>
        <trans-unit id="de5cd0ed2836b580d20a53b60b89fdbc3744b2af" translate="yes" xml:space="preserve">
          <source>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list.</source>
          <target state="translated">第一个元素是函数名,第二个是包含元数据的关键字列表,第三个是参数列表。</target>
        </trans-unit>
        <trans-unit id="8b93358d99cbfe2c9b65df07674bef6d363d42e0" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;enumerable&lt;/code&gt; is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the &lt;code&gt;enumerable&lt;/code&gt; is done, the last accumulator is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 的第一个元素用作累加器的初始值。然后，使用下一个元素和累加器调用该函数。该函数返回的结果将用作下一次迭代的累加器。当 &lt;code&gt;enumerable&lt;/code&gt; 完成，则返回上一个累加器。</target>
        </trans-unit>
        <trans-unit id="ff5ed72f8d68d33e831fb03d181cb08f9312e39a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple is always an atom or another tuple in the same representation.</source>
          <target state="translated">元组的第一个元素总是一个原子或同一表示中的另一个元组。</target>
        </trans-unit>
        <trans-unit id="3622c3705870af3b02b55f90fe91c49c65360502" translate="yes" xml:space="preserve">
          <source>The first element of these tuples is known as the &lt;em&gt;key&lt;/em&gt;, and it must be an atom. The second element, known as the &lt;em&gt;value&lt;/em&gt;, can be any term.</source>
          <target state="translated">这些元组的第一个元素称为&lt;em&gt;key&lt;/em&gt;，它必须是一个原子。第二个元素称为&lt;em&gt;value&lt;/em&gt;，可以是任何术语。</target>
        </trans-unit>
        <trans-unit id="753965fc9c8c958c1adc18030905ea9a9fce1c71" translate="yes" xml:space="preserve">
          <source>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling &lt;code&gt;do_something_expensive(state)&lt;/code&gt; outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.</source>
          <target state="translated">第一个功能阻止代理。第二个功能将所有状态复制到客户端，然后在客户端中执行操作。要考虑的一个方面是，数据是否足够大以至少在开始时需要在服务器中进行处理，还是足够小以廉价地发送到客户端。另一个因素是是否需要原子处理数据：获取状态并在代理外部调用 &lt;code&gt;do_something_expensive(state)&lt;/code&gt; 意味着可以同时更新代理的状态。这在更新的情况下尤其重要，因为如果多个客户端试图将同一状态更新为不同的值，则在客户端而不是服务器中计算新状态会导致争用情况。</target>
        </trans-unit>
        <trans-unit id="3a8bdc0ad5ea0cf6a739758090fdb5a2d0573fc4" translate="yes" xml:space="preserve">
          <source>The first function is &lt;code&gt;start_link/1&lt;/code&gt;, which starts a new GenServer passing a list of options. &lt;code&gt;start_link/1&lt;/code&gt; calls out to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;, which takes three arguments:</source>
          <target state="translated">第一个功能是 &lt;code&gt;start_link/1&lt;/code&gt; ，它启动一个新的GenServer并传递选项列表。 &lt;code&gt;start_link/1&lt;/code&gt; 调出 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; ，它带有三个参数：</target>
        </trans-unit>
        <trans-unit id="6da90265feaa08cdbd5c291c792941296efaf6fb" translate="yes" xml:space="preserve">
          <source>The first is the &lt;code&gt;init/1&lt;/code&gt; callback, that receives the second argument given to &lt;code&gt;GenServer.start_link/3&lt;/code&gt; and returns &lt;code&gt;{:ok, state}&lt;/code&gt;, where state is a new map. We can already notice how the &lt;code&gt;GenServer&lt;/code&gt; API makes the client/server segregation more apparent. &lt;code&gt;start_link/3&lt;/code&gt; happens in the client, while &lt;code&gt;init/1&lt;/code&gt; is the respective callback that runs on the server.</source>
          <target state="translated">第一个是 &lt;code&gt;init/1&lt;/code&gt; 回调，它接收给 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; 的第二个参数，并返回 &lt;code&gt;{:ok, state}&lt;/code&gt; ，其中state是一个新映射。我们已经注意到 &lt;code&gt;GenServer&lt;/code&gt; API 如何使客户端/服务器隔离更加明显。 &lt;code&gt;start_link/3&lt;/code&gt; 在客户端中发生，而 &lt;code&gt;init/1&lt;/code&gt; 是在服务器上运行的相应回调。</target>
        </trans-unit>
        <trans-unit id="6abd6bfc1ce31ae2f7f3cf73ef51afa902c3df53" translate="yes" xml:space="preserve">
          <source>The first is to rely on the fact that doctest can compare internal structures as long as they are at the root. So one could write:</source>
          <target state="translated">首先是依靠doctest只要在根部就可以比较内部结构。所以可以写。</target>
        </trans-unit>
        <trans-unit id="56525212a2d836e7b2e6c9fc3d438debd74b1ce4" translate="yes" xml:space="preserve">
          <source>The first occurrence of each element is kept.</source>
          <target state="translated">每个元素的第一次出现都会被保留。</target>
        </trans-unit>
        <trans-unit id="6fdbbd4ad4f56c5f2d4b83c9b51836d3c3baff1c" translate="yes" xml:space="preserve">
          <source>The first one is related to operator precedence. For example, the following expression:</source>
          <target state="translated">第一个是与运算符优先性有关。例如,下面的表达式。</target>
        </trans-unit>
        <trans-unit id="eb6432ba2d593bb02b187beac0081aecf4153a10" translate="yes" xml:space="preserve">
          <source>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</source>
          <target state="translated">首先是代码是真正的评估而不是编译。这意味着在shell中做的任何基准测试都会有倾斜的结果。所以千万不要在shell中运行任何profiling或基准。</target>
        </trans-unit>
        <trans-unit id="9aa7af0b736df8170b447c11a0b1486409c8447e" translate="yes" xml:space="preserve">
          <source>The first one is with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; which we can use instead of &lt;code&gt;IO.inspect binding()&lt;/code&gt;:</source>
          <target state="translated">第一个是使用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，我们可以使用它代替 &lt;code&gt;IO.inspect binding()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cece2699937857700a6e57ae7a8e2fdab1620e09" translate="yes" xml:space="preserve">
          <source>The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is &lt;code&gt;{key, pid, value}&lt;/code&gt;. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt;.</source>
          <target state="translated">第一部分，匹配模式，必须是一个与存储在注册表中的数据结构（ &lt;code&gt;{key, pid, value}&lt;/code&gt; 匹配的元组。原子 &lt;code&gt;:_&lt;/code&gt; 可用于忽略给定的值或元组元素，而原子 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 可用于将部分模式临时分配给变量，以进行后续比较。可以像 &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33bf9cc2d09af8093ef73164f4425101ddcff356" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented.</source>
          <target state="translated">第一行(总)是所有函数调用的总和。在最后一行中,列出了被考虑进行剖析的匹配函数的数量。</target>
        </trans-unit>
        <trans-unit id="c85192b0b88529b2ffa5c7dc5ed794fb80bfa927" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code.</source>
          <target state="translated">第一行(Total)是所有剖析进程中执行的所有函数的总和。对于给定的输出,我们总共有200279次函数调用,运行代码的时间大约为2秒。</target>
        </trans-unit>
        <trans-unit id="7cd60f6007c291382d0b163734079218de4d7d65" translate="yes" xml:space="preserve">
          <source>The first step in our implementation is to call &lt;code&gt;use Agent&lt;/code&gt;.</source>
          <target state="translated">我们实现的第一步是调用 &lt;code&gt;use Agent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="868cc4dcae35b14912938b182f9884b2f9e36c22" translate="yes" xml:space="preserve">
          <source>The first step is to tell our application definition (i.e. our &lt;code&gt;.app&lt;/code&gt; file) which module is going to implement the application callback. Let&amp;rsquo;s do so by opening &lt;code&gt;mix.exs&lt;/code&gt; and changing &lt;code&gt;def application&lt;/code&gt; to the following:</source>
          <target state="translated">第一步是告诉我们的应用程序定义（即我们的 &lt;code&gt;.app&lt;/code&gt; 文件），哪个模块将实现应用程序回调。通过打开 &lt;code&gt;mix.exs&lt;/code&gt; 并将 &lt;code&gt;def application&lt;/code&gt; 更改为以下内容来进行操作：</target>
        </trans-unit>
        <trans-unit id="b1db7f18a01e941b219c679437813ff0c63b86ff" translate="yes" xml:space="preserve">
          <source>The first step to do so is to add a &lt;code&gt;:mod&lt;/code&gt; key to the &lt;code&gt;application/0&lt;/code&gt; definition in your &lt;code&gt;mix.exs&lt;/code&gt; file. It expects a tuple, with the application callback module and start argument (commonly an empty list):</source>
          <target state="translated">第一步是将 &lt;code&gt;:mod&lt;/code&gt; 键添加到 &lt;code&gt;mix.exs&lt;/code&gt; 文件中的 &lt;code&gt;application/0&lt;/code&gt; 定义。它需要一个元组，并带有应用程序回调模块和start参数（通常是一个空列表）：</target>
        </trans-unit>
        <trans-unit id="08b35c8002543aef4eef62b9715905dd1c3e096e" translate="yes" xml:space="preserve">
          <source>The first test invokes &lt;code&gt;Kernel.node/0&lt;/code&gt;, which returns the name of the current node, based on the bucket names &amp;ldquo;hello&amp;rdquo; and &amp;ldquo;world&amp;rdquo;. According to our routing table so far, we should get &lt;code&gt;foo@computer-name&lt;/code&gt; and &lt;code&gt;bar@computer-name&lt;/code&gt; as responses, respectively.</source>
          <target state="translated">第一个测试调用 &lt;code&gt;Kernel.node/0&lt;/code&gt; ，它根据存储桶名称&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; world&amp;rdquo;返回当前节点的名称。根据到目前为止的路由表，我们应该分别获得 &lt;code&gt;foo@computer-name&lt;/code&gt; 和 &lt;code&gt;bar@computer-name&lt;/code&gt; 作为响应。</target>
        </trans-unit>
        <trans-unit id="aac5f450f7a22287bfbd1ca580bfb413b84283d5" translate="yes" xml:space="preserve">
          <source>The first time this task is run with &lt;code&gt;--stale&lt;/code&gt;, all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with &lt;code&gt;--stale&lt;/code&gt;. A test file is also marked &quot;stale&quot; if it has been changed since the last run with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">第一次使用 &lt;code&gt;--stale&lt;/code&gt; 运行此任务时，将运行所有测试并生成清单。在随后的运行中，如果自上次运行以来用 &lt;code&gt;--stale&lt;/code&gt; 修改了测试文件引用的模块（以及这些模块递归引用的模块），则该文件将被标记为&amp;ldquo;陈旧&amp;rdquo; 。如果自从上次运行 &lt;code&gt;--stale&lt;/code&gt; 以来已对其进行了更改，则测试文件也将标记为&amp;ldquo; stale&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="295fb12141f4c89eb596a5dac17f4949547acbec" translate="yes" xml:space="preserve">
          <source>The following attributes are part of typespecs and are also built-in in Elixir:</source>
          <target state="translated">以下属性是typepecs的一部分,也是Elixir内置的。</target>
        </trans-unit>
        <trans-unit id="7ddb17433dfdb141914290560e8f56274113cff7" translate="yes" xml:space="preserve">
          <source>The following behaviour applies if &lt;code&gt;reason&lt;/code&gt; is any term except &lt;code&gt;:normal&lt;/code&gt; or &lt;code&gt;:kill&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是除 &lt;code&gt;:normal&lt;/code&gt; 或 &lt;code&gt;:kill&lt;/code&gt; 以外的任何术语，则以下行为适用：</target>
        </trans-unit>
        <trans-unit id="7cc6a385de289ddbe867800f5a4d45eaf506d87a" translate="yes" xml:space="preserve">
          <source>The following code is clearer:</source>
          <target state="translated">下面的代码更清晰。</target>
        </trans-unit>
        <trans-unit id="bd520f433c3d9627651ec8f3c46e49f2f0b40321" translate="yes" xml:space="preserve">
          <source>The following commands are supported by &lt;code&gt;bin/RELEASE_NAME&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; 支持以下命令：</target>
        </trans-unit>
        <trans-unit id="ab6fa07c7c4a4b08ed5ab5840982521232d9dc60" translate="yes" xml:space="preserve">
          <source>The following configuration applies to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;'s wrapper around Erlang's logging functionalities. All the configurations below must be set before the &lt;code&gt;:logger&lt;/code&gt; application starts.</source>
          <target state="translated">以下配置适用于围绕Erlang的日志记录功能的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;的包装器。 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前，必须先设置以下所有配置。</target>
        </trans-unit>
        <trans-unit id="2b59ddac9c85343e9c0315f555148e29de15b834" translate="yes" xml:space="preserve">
          <source>The following configuration must be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">在 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前，必须通过配置文件（例如 &lt;code&gt;config/config.exs&lt;/code&gt; ）设置以下配置。</target>
        </trans-unit>
        <trans-unit id="7468ef5075d9f1bb00ad4478b84201c0051a39d2" translate="yes" xml:space="preserve">
          <source>The following configurations apply only for Erlang/OTP 20 and earlier:</source>
          <target state="translated">以下配置仅适用于Erlang/OTP 20及以前的版本。</target>
        </trans-unit>
        <trans-unit id="5bee2fb68242ae2a980fb37c51c72ff07363e60a" translate="yes" xml:space="preserve">
          <source>The following contents are expanded:</source>
          <target state="translated">以下内容为展开。</target>
        </trans-unit>
        <trans-unit id="184db633c0e9a1d1d50d51efc796a68bbb36b312" translate="yes" xml:space="preserve">
          <source>The following document has 10 bytes and therefore it does not format to width 9 without breaks:</source>
          <target state="translated">下面的文档有10个字节,因此它的格式不符合宽度9,没有分格。</target>
        </trans-unit>
        <trans-unit id="de1fd9b941b49b602c0ebc3107ff23bc87d50045" translate="yes" xml:space="preserve">
          <source>The following escape codes can be used in strings and char lists:</source>
          <target state="translated">下列转义码可以用于字符串和字符列表中。</target>
        </trans-unit>
        <trans-unit id="7c26c5de3e4e7cd245868d8c611a09003ff421aa" translate="yes" xml:space="preserve">
          <source>The following events are possible:</source>
          <target state="translated">可以开展以下活动:</target>
        </trans-unit>
        <trans-unit id="d46d9ba3da9322ecdf037e20b892895d0db04656" translate="yes" xml:space="preserve">
          <source>The following fields are available:</source>
          <target state="translated">以下是可用的领域:</target>
        </trans-unit>
        <trans-unit id="7293829d505cc3a0054aa1a59ac73bad4f509dae" translate="yes" xml:space="preserve">
          <source>The following fields are deprecated and must not be accessed or relied on:</source>
          <target state="translated">以下字段已被废弃,不得访问或依赖。</target>
        </trans-unit>
        <trans-unit id="8e9526796f05e114fb24325e062cf85e1db31da0" translate="yes" xml:space="preserve">
          <source>The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly:</source>
          <target state="translated">以下字段是Elixir的宏扩展机制的私有字段,不得直接访问。</target>
        </trans-unit>
        <trans-unit id="30c2e9695ce3105ad651330d3b52e46b3a324658" translate="yes" xml:space="preserve">
          <source>The following fields are public:</source>
          <target state="translated">以下领域是公开的。</target>
        </trans-unit>
        <trans-unit id="4144d492a1a8552ba49119bd2fcd0fd26179f7b6" translate="yes" xml:space="preserve">
          <source>The following fields may be modified as long as they keep their defined types:</source>
          <target state="translated">以下字段只要保持其定义的类型,就可以修改。</target>
        </trans-unit>
        <trans-unit id="ecaaab8e8eae9b4df4d22551bafa8feaa1ec9420" translate="yes" xml:space="preserve">
          <source>The following fields pertain to variable handling and must not be accessed or relied on. To get a list of all variables, see &lt;a href=&quot;#vars/1&quot;&gt;&lt;code&gt;vars/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">以下字段与变量处理有关，并且不能被访问或依赖。要获取所有变量的列表，请参见&lt;a href=&quot;#vars/1&quot;&gt; &lt;code&gt;vars/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e8fcb5815c5a0952c38de454edd61e7d1f142d6d" translate="yes" xml:space="preserve">
          <source>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</source>
          <target state="translated">以下是Elixir能够解析的所有运算符的列表,按优先级从高到低排序,同时还列出了它们的关联性。</target>
        </trans-unit>
        <trans-unit id="9104e819567333a6da0e8ce2dab5b947458c30fd" translate="yes" xml:space="preserve">
          <source>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</source>
          <target state="translated">下表列出了Elixir能够解析的所有运算符,但默认情况下没有使用。</target>
        </trans-unit>
        <trans-unit id="0ba751c3adfd8a7fc2856a1dbf3e62fbc4ec76f2" translate="yes" xml:space="preserve">
          <source>The following keys are optional:</source>
          <target state="translated">以下是可选的键:</target>
        </trans-unit>
        <trans-unit id="7b884b576e7fc0feccc202abb8a4a3d2fbce2d97" translate="yes" xml:space="preserve">
          <source>The following keys are returned:</source>
          <target state="translated">返回以下键:</target>
        </trans-unit>
        <trans-unit id="bf2cdc4ebfa3f4a0590ef2625ba82e196ae8c2a8" translate="yes" xml:space="preserve">
          <source>The following literals are also supported in typespecs:</source>
          <target state="translated">typepecs中还支持以下字元。</target>
        </trans-unit>
        <trans-unit id="b914b4fb7bd70067053e9e95983328f16ab1fd00" translate="yes" xml:space="preserve">
          <source>The following macros are generated:</source>
          <target state="translated">生成以下宏:</target>
        </trans-unit>
        <trans-unit id="8b11c8558e4b5ede506774a8ccaf530f1714eee7" translate="yes" xml:space="preserve">
          <source>The following metadata keys are enabled by &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt;&lt;code&gt;Code.string_to_quoted/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">以下元数据键由&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt; &lt;code&gt;Code.string_to_quoted/2&lt;/code&gt; &lt;/a&gt;启用：</target>
        </trans-unit>
        <trans-unit id="73eaa1cbb3b18d9fd1ab6f109e8770b921b255f4" translate="yes" xml:space="preserve">
          <source>The following metadata keys are private:</source>
          <target state="translated">以下元数据键是私有的。</target>
        </trans-unit>
        <trans-unit id="a19a723fcc38df91c7efce744ef29817327ec398" translate="yes" xml:space="preserve">
          <source>The following metadata keys are public:</source>
          <target state="translated">下列元数据键是公开的:</target>
        </trans-unit>
        <trans-unit id="d3a2d7253e70d0b7ab68844ea930f5d415637299" translate="yes" xml:space="preserve">
          <source>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</source>
          <target state="translated">以下模块建立在进程之上,提供并发、容错等功能。</target>
        </trans-unit>
        <trans-unit id="b4f887b33e0c44ae6b51e81b5ab7bc56ab3d3fc4" translate="yes" xml:space="preserve">
          <source>The following modules handle Elixir built-in data types:</source>
          <target state="translated">以下模块处理Elixir内置数据类型。</target>
        </trans-unit>
        <trans-unit id="16b7215fb9d992fc605683d883c23ca3932275a5" translate="yes" xml:space="preserve">
          <source>The following names are reserved and cannot be assigned to processes nor ports:</source>
          <target state="translated">以下名称是保留的,不能分配给进程或端口。</target>
        </trans-unit>
        <trans-unit id="5b3878c8ab3dccd7e89f167b65de39bd2f92844f" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">导入时，&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块使用以下运算符：&lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="178f615607801ccb48b704fc1947669dd0349eaf" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">导入时，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块使用以下运算符：&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="77f3895c41618839ee5e26a20028be3be4ec2b1d" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">必须在您的 &lt;code&gt;mix.exs&lt;/code&gt; 中的 &lt;code&gt;:escript&lt;/code&gt; 键下指定以下选项：</target>
        </trans-unit>
        <trans-unit id="cf3f75fb4a0fa1361326143ff900caf814328a06" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under the &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">必须在您的 &lt;code&gt;mix.exs&lt;/code&gt; 中的 &lt;code&gt;:escript&lt;/code&gt; 键下指定以下选项：</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">接受以下选项:</target>
        </trans-unit>
        <trans-unit id="3ab6a9f1a0bbaef19cacfbc5c31136467bf2e22d" translate="yes" xml:space="preserve">
          <source>The following options are supported:</source>
          <target state="translated">支持以下选项:</target>
        </trans-unit>
        <trans-unit id="5d2ba16817e078ffdf67dfcad431c49900869b20" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your &lt;code&gt;mix.exs&lt;/code&gt; on each release definition:</source>
          <target state="translated">可以在每个版本定义的 &lt;code&gt;mix.exs&lt;/code&gt; 内部设置以下选项：</target>
        </trans-unit>
        <trans-unit id="3e0b1eaa4142d08cf206798562baf46888ee1a50" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your releases key in your &lt;code&gt;mix.exs&lt;/code&gt; to control how config providers work:</source>
          <target state="translated">可以在 &lt;code&gt;mix.exs&lt;/code&gt; 的发布密钥中设置以下选项，以控制配置提供程序的工作方式：</target>
        </trans-unit>
        <trans-unit id="a63388a7d9c69cb081c0bd25c0b348227ea8b98e" translate="yes" xml:space="preserve">
          <source>The following restart values are supported in the &lt;code&gt;:restart&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; 选项支持以下重启值：</target>
        </trans-unit>
        <trans-unit id="e3bfac8b769dcde18c31230db7c8155e1610b73f" translate="yes" xml:space="preserve">
          <source>The following sets up a breakpoint on &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">下面在&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt;上设置一个断点：</target>
        </trans-unit>
        <trans-unit id="af7f88d381759e98fbd8a59a2974fdc1427bfa5a" translate="yes" xml:space="preserve">
          <source>The following shutdown values are supported in the &lt;code&gt;:shutdown&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 选项支持以下关闭值：</target>
        </trans-unit>
        <trans-unit id="62c95490240e6721731c2a4166fbf474d701eaa5" translate="yes" xml:space="preserve">
          <source>The following switches take one argument:</source>
          <target state="translated">以下开关只需要一个参数。</target>
        </trans-unit>
        <trans-unit id="09182b59468032ac91eb3e19cfac73cd63919777" translate="yes" xml:space="preserve">
          <source>The following switches types take no arguments:</source>
          <target state="translated">以下开关类型不接受参数。</target>
        </trans-unit>
        <trans-unit id="656560aa5a4b69ea097162499366d646d82b57a2" translate="yes" xml:space="preserve">
          <source>The following tags are set automatically by ExUnit and are therefore reserved:</source>
          <target state="translated">以下标签由ExUnit自动设置,因此保留。</target>
        </trans-unit>
        <trans-unit id="5fc9716a622a264a8eff71eefa013048286d3378" translate="yes" xml:space="preserve">
          <source>The following tags customize how tests behave:</source>
          <target state="translated">以下标签可以自定义测试的行为方式。</target>
        </trans-unit>
        <trans-unit id="f3f1a1a3a62e3160fd586f6ee95d4fab3af95423" translate="yes" xml:space="preserve">
          <source>The following tasks are automatically reenabled: &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.do&quot;&gt;&lt;code&gt;mix do&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt;&lt;code&gt;mix loadconfig&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;mix profile.cprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt;&lt;code&gt;mix profile.eprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将自动重新启用以下任务：&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.do&quot;&gt; &lt;code&gt;mix do&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.loadconfig&quot;&gt; &lt;code&gt;mix loadconfig&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;mix profile.cprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt; &lt;code&gt;mix profile.eprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;mix profile.fprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94b02fa4807601cf95b13d7bfacf63de52daec08" translate="yes" xml:space="preserve">
          <source>The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.</source>
          <target state="translated">除了上述的基本类型和文字类型外,Elixir还提供了以下类型作为快捷方式。</target>
        </trans-unit>
        <trans-unit id="23128f3afb79fe9776e7ccf884ae9b5f280de2c5" translate="yes" xml:space="preserve">
          <source>The following values in the prompt string will be replaced appropriately:</source>
          <target state="translated">提示字符串中的以下值将被适当替换。</target>
        </trans-unit>
        <trans-unit id="55cd405f97f23c4fe92ae34e5fe7acfcdc9373f0" translate="yes" xml:space="preserve">
          <source>The following variables can be set before you invoke the release or inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt;:</source>
          <target state="translated">在调用发行版之前或在 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 内部可以设置以下变量：</target>
        </trans-unit>
        <trans-unit id="bd9e27e386ddec7a2956d45d1104ee9dcf8cf427" translate="yes" xml:space="preserve">
          <source>The following will answer with &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; to the prompt &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt;:</source>
          <target state="translated">下面将以 &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; 回答提示 &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d10907c83024affa6f13fdf8900f10947fef49e4" translate="yes" xml:space="preserve">
          <source>The format, metadata and colors can be configured with &lt;code&gt;:format&lt;/code&gt;, &lt;code&gt;:metadata&lt;/code&gt; and &lt;code&gt;:colors&lt;/code&gt; respectively. These three options defaults to the &lt;code&gt;:console&lt;/code&gt; backend configuration parameters.</source>
          <target state="translated">格式，元数据和颜色可以分别用 &lt;code&gt;:format&lt;/code&gt; ， &lt;code&gt;:metadata&lt;/code&gt; 和 &lt;code&gt;:colors&lt;/code&gt; 配置。这三个选项默认为 &lt;code&gt;:console&lt;/code&gt; 后端配置参数。</target>
        </trans-unit>
        <trans-unit id="dc2e84198cf648d67efe0dc56f0a0d3f7a6c41f5" translate="yes" xml:space="preserve">
          <source>The formatter also extracts all trailing comments to their previous line. For example, the code below</source>
          <target state="translated">格式化器还将所有的尾部注释提取到它们的前一行。例如,下面的代码</target>
        </trans-unit>
        <trans-unit id="f2dbb773aae103d1ac648bef9a245406adea93a6" translate="yes" xml:space="preserve">
          <source>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</source>
          <target state="translated">格式化器处理代码注释的方式也保证了在注释的开头(#)和下一个字符之间总是添加一个空格。</target>
        </trans-unit>
        <trans-unit id="174a1bba642104242141e782016509d0a3307dd9" translate="yes" xml:space="preserve">
          <source>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</source>
          <target state="translated">格式化器试图在单行上尽可能地适应,并在不能适应时尽可能地引入换行符。</target>
        </trans-unit>
        <trans-unit id="db2d1c69ac2af0675a9fbaa3dbf3bb62be0f48e5" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, etc. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">格式化程序不硬编码名称。格式化程序不会表现出特殊的行为，因为一个函数名为 &lt;code&gt;defmodule&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; 等。该原理反映了Elixir的目标，即成为一种可扩展的语言，开发人员可以在其中使用新的结构来扩展该语言，就像它们是该语言的一部分一样。如果绝对有必要根据名称更改行为，则此行​​为应该是可配置的，例如 &lt;code&gt;:locals_without_parens&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="4b2df21441dc79dd9bd7c2eac32664e6ea35e2a4" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">格式化程序不硬编码名称。格式化程序的行为不会特殊，因为函数名为 &lt;code&gt;defmodule&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; 或类似名称。该原则反映了Elixir成为可扩展语言的目标，开发人员可以在其中以新的结构扩展该语言，就像它们是该语言的一部分一样。如果绝对有必要根据名称更改行为，则此行​​为应该是可配置的，例如 &lt;code&gt;:locals_without_parens&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="03003fdc11feaf71c728ace4a4e8175ee7b4844f" translate="yes" xml:space="preserve">
          <source>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</source>
          <target state="translated">格式化器接收一个代表Elixir代码的字符串,并根据预先定义的规则返回代表格式化代码的碘数据。</target>
        </trans-unit>
        <trans-unit id="72e5baea79c2662552fd592f7668202474a199d4" translate="yes" xml:space="preserve">
          <source>The formatter respects the input format in some cases. Those are listed below:</source>
          <target state="translated">格式化器在某些情况下会尊重输入格式。下面列出了这些情况。</target>
        </trans-unit>
        <trans-unit id="73147abbfb07a1782272353b129dfe6ae2759140" translate="yes" xml:space="preserve">
          <source>The formatter was designed under three principles.</source>
          <target state="translated">该表格是根据三个原则设计的。</target>
        </trans-unit>
        <trans-unit id="d253cdad860fbe489673fba372b661892f2a2b1a" translate="yes" xml:space="preserve">
          <source>The formatter will also receive the following events but they are deprecated and should be ignored:</source>
          <target state="translated">格式化器还将收到以下事件,但它们已被废弃,应予以忽略。</target>
        </trans-unit>
        <trans-unit id="16faacc4637c873b1a6d5ef2df7c790ea5ae523a" translate="yes" xml:space="preserve">
          <source>The formatter will read a &lt;code&gt;.formatter.exs&lt;/code&gt; file in the current directory for formatter configuration. Evaluating this file should return a keyword list.</source>
          <target state="translated">格式化程序将读取当前目录中的 &lt;code&gt;.formatter.exs&lt;/code&gt; 文件以进行格式化程序配置。评估此文件应返回关键字列表。</target>
        </trans-unit>
        <trans-unit id="54861fc5081e64334a71df9d50b523e9ef441995" translate="yes" xml:space="preserve">
          <source>The formatter wraps the algebra document representing the map in &lt;a href=&quot;#next_break_fits/1&quot;&gt;&lt;code&gt;next_break_fits/1&lt;/code&gt;&lt;/a&gt; so the code is formatted as:</source>
          <target state="translated">格式化程序将代表地图的代数文档包装在&lt;a href=&quot;#next_break_fits/1&quot;&gt; &lt;code&gt;next_break_fits/1&lt;/code&gt; 中,&lt;/a&gt;因此代码的格式为：</target>
        </trans-unit>
        <trans-unit id="1b530c8de3f53b8e27706291f76c2c2287eac72b" translate="yes" xml:space="preserve">
          <source>The formatting syntax for strftime is a sequence of characters in the following format:</source>
          <target state="translated">strftime的格式化语法是以下格式的字符序列。</target>
        </trans-unit>
        <trans-unit id="95bd7646a64eb0576fcb230b316aeb1624812ca3" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Mix的基础是一个项目。可以通过在模块中使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;来定义项目，通常将其放置在名为 &lt;code&gt;mix.exs&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="619bfcd8852612a615d36e293bdf93e9442a2fd9" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;mix.project&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Mix的基础是一个项目。可以通过在模块中使用&lt;a href=&quot;mix.project&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;来定义项目，通常将其放置在名为 &lt;code&gt;mix.exs&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="7b28558869b4d11a344cb1f239f09303f041a1a0" translate="yes" xml:space="preserve">
          <source>The full ExUnit configuration is passed as the argument to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback when the formatters are started. If you need to do runtime configuration of a formatter, you can add any configuration needed by using &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt;&lt;code&gt;ExUnit.start/1&lt;/code&gt;&lt;/a&gt;, and this will then be included in the options passed to the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">启动格式化程序时，&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt;完整的ExUnit配置作为参数传递给GenServer.init / 1回调。如果需要对格式化程序进行运行时配置，则可以使用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt; &lt;code&gt;ExUnit.start/1&lt;/code&gt; &lt;/a&gt;添加所需的任何配置，然后将其包含在传递给&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt;回调的选项中。</target>
        </trans-unit>
        <trans-unit id="27f8279b8cd5628c38c64722e539ac026a11da8b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="translated">函数&lt;a href=&quot;#put_env/3&quot;&gt; &lt;code&gt;put_env/3&lt;/code&gt; &lt;/a&gt;允许动态配置应用程序环境，但是根据经验，每个应用程序都应对自己的环境负责。请不要使用该模块中的功能直接访问或修改其他应用程序的环境。</target>
        </trans-unit>
        <trans-unit id="44dd7e8c0883ba7364643058445d069f16c2e43c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#struct!/2&quot;&gt;&lt;code&gt;struct!/2&lt;/code&gt;&lt;/a&gt; emulates the compile time behaviour of structs. This means that:</source>
          <target state="translated">函数&lt;a href=&quot;#struct!/2&quot;&gt; &lt;code&gt;struct!/2&lt;/code&gt; &lt;/a&gt;模拟结构的编译时行为。这意味着：</target>
        </trans-unit>
        <trans-unit id="8e0639c36ddd40dd4d3c1545de8b7ff6af66a1a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。该函数必须返回一个包含两个元素的元组，第一个是要返回的值（即&amp;ldquo; get&amp;rdquo;值），第二个是代理的新状态。</target>
        </trans-unit>
        <trans-unit id="216982854731717320607d5aa3e2c69ffa39cfa0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The result of the function invocation is returned from this function.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。从该函数返回函数调用的结果。</target>
        </trans-unit>
        <trans-unit id="fc7b0ec15b4d375100169c807030b178d76cb224" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The return value of &lt;code&gt;fun&lt;/code&gt; becomes the new state of the agent.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。 &lt;code&gt;fun&lt;/code&gt; 的返回值成为代理的新状态。</target>
        </trans-unit>
        <trans-unit id="cad7f93891da662dbbaf24dfbad6e47a904e9038" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term which is used to determine if two elements are duplicates.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 函数将每个元素映射到一个术语，该术语用于确定两个元素是否重复。</target>
        </trans-unit>
        <trans-unit id="2063958f17451467d712f93ea552d845434a5f7b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term. Two elements are considered duplicates if the return value of &lt;code&gt;fun&lt;/code&gt; is equal for both of them.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 函数将每个元素映射到一个术语。如果 &lt;code&gt;fun&lt;/code&gt; 的返回值相等，则两个元素都视为重复。</target>
        </trans-unit>
        <trans-unit id="786bdba792da55f0fb2aae425ae917dfa7672afd" translate="yes" xml:space="preserve">
          <source>The function must receive the exit status code as an argument.</source>
          <target state="translated">该函数必须接收退出状态码作为参数。</target>
        </trans-unit>
        <trans-unit id="a56026b8a6cb0f0aeff01c85c9ee7342a99db076" translate="yes" xml:space="preserve">
          <source>The function must return:</source>
          <target state="translated">该函数必须返回。</target>
        </trans-unit>
        <trans-unit id="78c45238f9f6bc55b2be81844c73ef2dab477691" translate="yes" xml:space="preserve">
          <source>The function receives the arguments and passes them to &lt;code&gt;if&lt;/code&gt;. However, as we learned in the &lt;a href=&quot;quote-and-unquote&quot;&gt;previous chapter&lt;/a&gt;, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</source>
          <target state="translated">该函数接收参数并将其传递给 &lt;code&gt;if&lt;/code&gt; 。但是，正如我们在&lt;a href=&quot;quote-and-unquote&quot;&gt;上一章&lt;/a&gt;中学到的那样，宏将接收带引号的表达式，将它们注入引号中，最后返回另一个带引号的表达式。</target>
        </trans-unit>
        <trans-unit id="970e1abe8c2a97edfeb1747215a9aaebefbaf05f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;:ok&lt;/code&gt; in case of success. Otherwise, it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果成功，该函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。否则，它返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42211e9c17fc840b6d18e986bbdd31d79b28999c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; in case of success, &lt;code&gt;files_and_directories&lt;/code&gt; lists all files and directories copied in no specific order. It returns &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，该函数将返回 &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; ， &lt;code&gt;files_and_directories&lt;/code&gt; 列出所有未按特定顺序复制的文件和目录。否则返回 &lt;code&gt;{:error, reason, file}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b12965a38c8943a04c360761ab1a75653a316455" translate="yes" xml:space="preserve">
          <source>The function should return a non empty list where the amount of elements is equal to &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">函数应该返回一个非空列表，其中元素的数量等于 &lt;code&gt;length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="370959ce1313e0ee1574bb7b4f639ad8e764cdd3" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;fun&lt;/code&gt;, receives two arguments: the first one is the element, and the second one is the accumulator. &lt;code&gt;fun&lt;/code&gt; must return a tuple with two elements in the form of &lt;code&gt;{result, accumulator}&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 接收两个参数：第一个是元素，第二个是累加器。 &lt;code&gt;fun&lt;/code&gt; 必须以 &lt;code&gt;{result, accumulator}&lt;/code&gt; 的形式返回具有两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="b5956f11dd1602a7d0b839eecd3ea612fa5aace7" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#nest/2&quot;&gt;&lt;code&gt;nest/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#space/2&quot;&gt;&lt;code&gt;space/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#line/2&quot;&gt;&lt;code&gt;line/2&lt;/code&gt;&lt;/a&gt; help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like &lt;a href=&quot;#glue/3&quot;&gt;&lt;code&gt;glue/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#group/1&quot;&gt;&lt;code&gt;group/1&lt;/code&gt;&lt;/a&gt;. A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it:</source>
          <target state="translated">函数&lt;a href=&quot;#nest/2&quot;&gt; &lt;code&gt;nest/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#space/2&quot;&gt; &lt;code&gt;space/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#line/2&quot;&gt; &lt;code&gt;line/2&lt;/code&gt; 可以&lt;/a&gt;帮助您将文档放在一起成为一个刚性结构。但是，当使用诸如&lt;a href=&quot;#glue/3&quot;&gt; &lt;code&gt;glue/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#group/1&quot;&gt; &lt;code&gt;group/1&lt;/code&gt; &lt;/a&gt;类的功能时，文档代数变得很有趣。胶水在两个文档之间插入一个中断。组表示必须适合当前行的文档，否则，中断将显示为新行。让我们将两个文档粘合在一起，然后将其分组，然后进行渲染：</target>
        </trans-unit>
        <trans-unit id="c253790d407e18b7d5f0c9bb8af92800693543dd" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; can be applied too, especially when ordering is required.</source>
          <target state="translated">订购时，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;的功能不保证任何属性。但是，由于关键字列表只是一个列表，因此也可以应用&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; 中&lt;/a&gt;定义的所有操作，尤其是在需要排序时。</target>
        </trans-unit>
        <trans-unit id="fc395b4f1565e86a3f414d5f43f358ea3ab4b968" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;File&lt;/code&gt; also allow lists to be given as arguments. Not only that, they also allow a mixed list of lists, integers, and binaries to be given:</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 和 &lt;code&gt;File&lt;/code&gt; 中的功能还允许将列表作为参数给出。不仅如此，它们还允许提供列表，整数和二进制文件的混合列表：</target>
        </trans-unit>
        <trans-unit id="c24702aeda4cc39358f5c9073ad6385b684128ba" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;ets&lt;/code&gt; module will modify the state of the table as a side-effect.</source>
          <target state="translated">&lt;code&gt;ets&lt;/code&gt; 模块中的功能将修改表的状态，从而产生副作用。</target>
        </trans-unit>
        <trans-unit id="645c924b3f04d5643fc9c0295858b7ef02f4fe7d" translate="yes" xml:space="preserve">
          <source>The functions in the Enum module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the &lt;code&gt;List.insert_at/3&lt;/code&gt; function from &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;the &lt;code&gt;List&lt;/code&gt; module&lt;/a&gt;, as it would make little sense to insert a value into, for example, a range.</source>
          <target state="translated">顾名思义，Enum模块中的功能仅限于枚举数据结构中的值。对于特定的操作，例如插入和更新特定的元素，可能需要访问特定于数据类型的模块。例如，如果要在列表中的给定位置插入元素，则应使用&lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&amp;ldquo; &lt;/a&gt; &lt;code&gt;List&lt;/code&gt; 模块中的 &lt;code&gt;List.insert_at/3&lt;/code&gt; 函数，因为将值插入例如范围内几乎没有意义。 。</target>
        </trans-unit>
        <trans-unit id="77cce334a46132ba295a248960c6d018c960a8aa" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 11.0.0.</source>
          <target state="translated">该模块的功能根据Unicode标准11.0.0版本执行。</target>
        </trans-unit>
        <trans-unit id="2539a9cd4324f66b525de87feede6af27bf5479d" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 12.1.0.</source>
          <target state="translated">该模块的功能根据Unicode标准12.1.0版本执行。</target>
        </trans-unit>
        <trans-unit id="435e788eab1bd17ae90e69f5f7810182e093e4b6" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">该模块中的功能已被弃用，不适用于Elixir v1.5中引入的基于模块的子规范。请改为查看&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="173416c87fd5ec34f77cd8d34322b0332ac7cfcb" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">该模块中的功能已被弃用，并且无法与Elixir v1.5中引入的基于模块的子规范一起使用。请改为查看&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="55c1606f7340829fac4bdeef11ed0e160ebd64a6" translate="yes" xml:space="preserve">
          <source>The functions in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">本模块中的函数有两种口味:命名或运算符。例如:</target>
        </trans-unit>
        <trans-unit id="96e74349f320a8c58dc1c59108496ee930024bf1" translate="yes" xml:space="preserve">
          <source>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</source>
          <target state="translated">本模块中的函数可以接收一个chardata作为参数(即一个字符串或字符列表/字符串),并将始终返回一个字符串(以UTF-8编码)。</target>
        </trans-unit>
        <trans-unit id="b429b5ce2f9a2392aff46c5515cf68d49d6d6adf" translate="yes" xml:space="preserve">
          <source>The functions in this module support chardata, so giving a list will treat it as a single entity:</source>
          <target state="translated">本模块中的函数支持chardata,所以给出一个列表会将其视为一个单一实体。</target>
        </trans-unit>
        <trans-unit id="255d1a73d20d6ce6127802c33ec8ce540df5e39c" translate="yes" xml:space="preserve">
          <source>The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:</source>
          <target state="translated">本模块中从元组中添加和删除元素的函数在实践中很少使用,因为它们通常意味着元组被当作集合使用。要对一个元组进行追加,最好是用模式匹配从旧元组中提取元素,然后创建一个新的元组。</target>
        </trans-unit>
        <trans-unit id="33b30755a342f20f218b83071cf71f52c8757557" translate="yes" xml:space="preserve">
          <source>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as &lt;a href=&quot;#keys/1&quot;&gt;&lt;code&gt;keys/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values/1&quot;&gt;&lt;code&gt;values/1&lt;/code&gt;&lt;/a&gt;, run in linear time because they need to get to every element in the map.</source>
          <target state="translated">该模块中需要在对数时间内查找特定键的功能。这意味着查找键所花费的时间随着地图的增长而增长，但并不与地图的大小成正比。与在列表中查找元素相比，它的性能更好，因为列表具有线性时间复杂度。一些功能（例如&lt;a href=&quot;#keys/1&quot;&gt; &lt;code&gt;keys/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#values/1&quot;&gt; &lt;code&gt;values/1&lt;/code&gt; )&lt;/a&gt;在线性时间内运行，因为它们需要访问映射中的每个元素。</target>
        </trans-unit>
        <trans-unit id="74f82d17a516dfeabf8954e130f2901c86439fbe" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">该模块中的功能以线性时间工作。这意味着执行操作所需的时间以与可枚举的长度相同的速率增长。这在诸如&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; 的&lt;/a&gt;操作中是预期的。毕竟，如果我们要遍历列表中的每个元素，则列表越长，我们需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="9f0853ffd0b6dd95f29653e4a1c1ad06e52385c2" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">该模块中的功能以线性时间工作。这意味着执行操作所需的时间以与可枚举的长度相同的速度增长。这在诸如&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; 之类的&lt;/a&gt;操作中是预期的。毕竟，如果我们要遍历列表中的每个元素，则列表越长，我们需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="3463cc17b842a1d5960bd8ec694214b314a84bdc" translate="yes" xml:space="preserve">
          <source>The functions listed under &lt;code&gt;:locals_without_parens&lt;/code&gt; in the &lt;code&gt;:export&lt;/code&gt; option of a dependency can be imported in a project by listing that dependency in the &lt;code&gt;:import_deps&lt;/code&gt; option of the formatter configuration file of the project.</source>
          <target state="translated">可以通过在项目的格式化程序配置文件的 &lt;code&gt;:import_deps&lt;/code&gt; 选项中列出依赖项，将依赖项的 &lt;code&gt;:export&lt;/code&gt; 选项中 &lt;code&gt;:locals_without_parens&lt;/code&gt; 下列出的功能导入项目中。</target>
        </trans-unit>
        <trans-unit id="2b5e518a4ce1d29fa0de0a02c9ab38609211f7bc" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">这个模块的工作职能&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构以及包含相同的字段的任何结构&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构，如&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="709dd48512a8ffdaa9639efcdf5626b90390736d" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此模块上的函数可与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构以及包含与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构相同字段的任何结构一起使用，例如&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;calendar#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ff0d30d9202c4c6b14208fdf831e03638322939" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此模块上的函数可与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构以及包含与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构相同字段的任何结构一起使用，例如&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd7fe8f3288c5b63dba38948e86e695e4e2b2557" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此模块上的函数与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构以及任何包含与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构相同字段的结构一起使用，例如&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;calendar#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="003b5d0dd560d869b45725f5251941da4e2978b9" translate="yes" xml:space="preserve">
          <source>The general Elixir identifier rule is specified as:</source>
          <target state="translated">Elixir标识符的一般规则规定如下:</target>
        </trans-unit>
        <trans-unit id="279b2d1d6d51ad298e11acb6402db1bbf4467c85" translate="yes" xml:space="preserve">
          <source>The generated files are similar to the ones we first generated for &lt;code&gt;kv&lt;/code&gt;, with a few differences. Let&amp;rsquo;s open up &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">生成的文件与我们最初为 &lt;code&gt;kv&lt;/code&gt; 生成的文件相似，但有一些区别。让我们打开 &lt;code&gt;mix.exs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe11b786cb48918f9b05dccc30b89f3c9d182f54" translate="yes" xml:space="preserve">
          <source>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</source>
          <target state="translated">生成的宏也可以用来对记录进行模式匹配,并在匹配过程中绑定变量。</target>
        </trans-unit>
        <trans-unit id="50f5c0fcf4c39bd1e0e3ce49d94a449eccf8a5ee" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;datetime_string&lt;/code&gt; must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised.</source>
          <target state="translated">给定的 &lt;code&gt;datetime_string&lt;/code&gt; 必须包含&amp;ldquo; Z&amp;rdquo;或&amp;ldquo; 00:00&amp;rdquo;偏移量（将其标记为UTC），否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="5945d8ce9d0ed7b935712680470e46feacdd1644" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;fun&lt;/code&gt; is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</source>
          <target state="translated">对于AST中的每个节点，将使用两个参数调用给定的 &lt;code&gt;fun&lt;/code&gt; ：正在打印的节点的AST和该节点的字符串表示形式。此函数的返回值用作该AST节点的最终字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="a83da51956cb3348840e43e856af798fc100e9ea" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing configuration for the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">给定的 &lt;code&gt;opts&lt;/code&gt; 合并到给定 &lt;code&gt;root_key&lt;/code&gt; 的现有配置中。冲突键被 &lt;code&gt;opts&lt;/code&gt; 中指定的键覆盖。例如，下面的应用程序配置</target>
        </trans-unit>
        <trans-unit id="b05f234517d759a8cb3f7b2d59dc801482a98965" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing values for &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">给定的 &lt;code&gt;opts&lt;/code&gt; 合并到给定的 &lt;code&gt;root_key&lt;/code&gt; 中 &lt;code&gt;key&lt;/code&gt; 的现有值中。冲突键被 &lt;code&gt;opts&lt;/code&gt; 中指定的键覆盖。例如，下面的应用程序配置</target>
        </trans-unit>
        <trans-unit id="02ef5a607d49adbb7866b57f819df6b77fdbb345" translate="yes" xml:space="preserve">
          <source>The given config should not:</source>
          <target state="translated">给定的配置不应。</target>
        </trans-unit>
        <trans-unit id="44e635edac5e4e08e828b82a2eaab3164491a4b7" translate="yes" xml:space="preserve">
          <source>The given datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的日期时间的精度已经低于给定的精度,则不变返回。</target>
        </trans-unit>
        <trans-unit id="77d42dd0c470aae641d549b4c74c46ab9659c1be" translate="yes" xml:space="preserve">
          <source>The given dependencies and the projects they depend on will be unlocked and updated to the latest version according to their version requirements.</source>
          <target state="translated">给定的依赖关系和它们所依赖的项目将根据它们的版本要求被解锁并更新到最新版本。</target>
        </trans-unit>
        <trans-unit id="6d2a43a0c7f321f6321fd1b9eb5b43b059a8e70b" translate="yes" xml:space="preserve">
          <source>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的天真日期时间的精度已经低于给定的精度,则不变返回。</target>
        </trans-unit>
        <trans-unit id="ee23443246e5491d80625e07cdf87fe6cfe649c9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">给定的选项可以是与表示赋予相同的正则表达式的选项中的字符的二进制 &lt;code&gt;~r&lt;/code&gt; （见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt;）印记，或选项的列表，由Erlang的预期 &lt;code&gt;:re&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="c8ff7c40025099fed2b47a6ca6bd7d1bee58abb9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">给定的选项可以是与表示赋予相同的正则表达式的选项中的字符的二进制 &lt;code&gt;~r&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt;）印记，或选项的列表，由Erlang的预期 &lt;code&gt;:re&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="a877d88a9ed060a658c7f85f772f951264b25f7d" translate="yes" xml:space="preserve">
          <source>The given string may contain a timezone offset but it is ignored.</source>
          <target state="translated">给定的字符串可能包含时区偏移,但会被忽略。</target>
        </trans-unit>
        <trans-unit id="8ee391432291b1d23474c64748cd369ce3de6c17" translate="yes" xml:space="preserve">
          <source>The given time is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的时间已经比给定的精度低,则不变返回。</target>
        </trans-unit>
        <trans-unit id="595ea9127c2b29264915dada8a0a74f247f402db" translate="yes" xml:space="preserve">
          <source>The goal in this chapter is to build a module named &lt;code&gt;TestCase&lt;/code&gt; that allows us to write the following:</source>
          <target state="translated">本章的目标是构建一个名为 &lt;code&gt;TestCase&lt;/code&gt; 的模块，该模块使我们可以编写以下内容：</target>
        </trans-unit>
        <trans-unit id="005035c0ac9ba5b2d03b96ccf393ae5ff11ffe11" translate="yes" xml:space="preserve">
          <source>The goal of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的目标是为开发人员抽象&amp;ldquo;接收&amp;rdquo;循环，自动处理系统消息，支持代码更改，同步调用等。因此，永远不要在GenServer回调中调用自己的&amp;ldquo;接收&amp;rdquo;，因为这样做会导致GenServer行为异常。</target>
        </trans-unit>
        <trans-unit id="1a6d568374392c51e27178f8aac8e2da82bbf64d" translate="yes" xml:space="preserve">
          <source>The good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project&amp;rsquo;s &lt;code&gt;apps/&lt;/code&gt; directory. In the worst case scenario, you can discard the umbrella project and all related configuration (&lt;code&gt;build_path&lt;/code&gt;, &lt;code&gt;config_path&lt;/code&gt;, &lt;code&gt;deps_path&lt;/code&gt; and &lt;code&gt;lockfile&lt;/code&gt;) and still leverage the &amp;ldquo;mono-repo&amp;rdquo; pattern by keeping all applications together in the same repository. Each application will have its own dependencies and configuration. Dependencies between those applications can still be explicitly listed by using the &lt;code&gt;:path&lt;/code&gt; option (in contrast to &lt;code&gt;:git&lt;/code&gt;).</source>
          <target state="translated">好消息是，将伞分解很容易，因为您只需要将应用程序移到伞项目的 &lt;code&gt;apps/&lt;/code&gt; 目录之外。在最坏的情况下，你可以放弃伞项目和所有相关配置（ &lt;code&gt;build_path&lt;/code&gt; ， &lt;code&gt;config_path&lt;/code&gt; ， &lt;code&gt;deps_path&lt;/code&gt; 和 &lt;code&gt;lockfile&lt;/code&gt; ），并且仍然在同一个版本库保存所有的应用程序一起充分利用&amp;ldquo;单回购&amp;rdquo;的格局。每个应用程序将具有自己的依赖性和配置。仍然可以使用 &lt;code&gt;:path&lt;/code&gt; 选项显式列出这些应用程序之间的依赖关系（与 &lt;code&gt;:git&lt;/code&gt; 相反）。</target>
        </trans-unit>
        <trans-unit id="78ffff4bce308419c28073fad905a3416ef9e300" translate="yes" xml:space="preserve">
          <source>The good news is that developers can use third-party implementations of both Elixir backends and Erlang handlers.</source>
          <target state="translated">好消息是,开发者可以使用Elixir后端和Erlang处理程序的第三方实现。</target>
        </trans-unit>
        <trans-unit id="18abb99c49c0cd9f625ee8db0e020cadbbd4d636" translate="yes" xml:space="preserve">
          <source>The greatest common divisor (GCD) of &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; is the largest positive integer that divides both &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; without leaving a remainder.</source>
          <target state="translated">的最大公约数（GCD） &lt;code&gt;integer1&lt;/code&gt; 和 &lt;code&gt;integer2&lt;/code&gt; 是最大的正整数整除 &lt;code&gt;integer1&lt;/code&gt; 和 &lt;code&gt;integer2&lt;/code&gt; ，不留余数。</target>
        </trans-unit>
        <trans-unit id="04a15f34a10083efdd1b4c7fb23d6409a2799f7b" translate="yes" xml:space="preserve">
          <source>The group mode can also be set to &lt;code&gt;:inherit&lt;/code&gt;, which means it automatically breaks if the parent group has broken too.</source>
          <target state="translated">组模式也可以设置为 &lt;code&gt;:inherit&lt;/code&gt; ，这意味着如果父组也断开，它会自动断开。</target>
        </trans-unit>
        <trans-unit id="a353728570ac2d4d82e8f0ff930144d1e562cb6a" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, and others) won't be available by the time the handler function is invoked.</source>
          <target state="translated">处理程序总是在与其注册的进程不同的进程中执行。因此,在调用处理程序函数时,由调用进程管理的任何资源(ETS表、打开的文件和其他)都将不可用。</target>
        </trans-unit>
        <trans-unit id="abae706b2e9875a2d4fe24ac37232c3285b58047" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won't be available by the time the handler function is invoked.</source>
          <target state="translated">处理程序总是在与其注册的进程不同的进程中执行。因此,在调用处理函数时,由调用进程管理的任何资源(ETS表、打开的文件等)都将不可用。</target>
        </trans-unit>
        <trans-unit id="91dc0be92537f81da316aa8d3834b6a0c2b63c02" translate="yes" xml:space="preserve">
          <source>The head element of aliases can be any term that must expand to an atom at compilation time.</source>
          <target state="translated">别名的头部元素可以是任何必须在编译时扩展为原子的术语。</target>
        </trans-unit>
        <trans-unit id="d895e647576b7caa588974823adee16cc261b47d" translate="yes" xml:space="preserve">
          <source>The hex representation will also help you look up information about a code point, e.g. &lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt; has a data sheet all about the lower case &lt;code&gt;a&lt;/code&gt;, a.k.a. code point 97.</source>
          <target state="translated">十六进制表示形式还可以帮助您查找有关代码点的信息，例如&lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt;的数据表都包含小写字母 &lt;code&gt;a&lt;/code&gt; （也称为代码点97）。</target>
        </trans-unit>
        <trans-unit id="b5f5e37ee6e6bb7829dd572b3c957edcc2f9784b" translate="yes" xml:space="preserve">
          <source>The implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a &lt;code&gt;PID&lt;/code&gt; or an &lt;code&gt;Integer&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">上面的实现可以说是不合理的。例如，说 &lt;code&gt;PID&lt;/code&gt; 或 &lt;code&gt;Integer&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; 毫无意义。</target>
        </trans-unit>
        <trans-unit id="1a82e7d1f4f1afb4f634e8bc16b67baab165570d" translate="yes" xml:space="preserve">
          <source>The implementation is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;reservoir sampling&lt;/a&gt; algorithm. It assumes that the sample being returned can fit into memory; the input &lt;code&gt;enumerable&lt;/code&gt; doesn't have to, as it is traversed just once.</source>
          <target state="translated">该实现基于&lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;储层采样&lt;/a&gt;算法。假设返回的样本可以放入内存； &lt;code&gt;enumerable&lt;/code&gt; 输入不必遍历，因为它只需遍历一次。</target>
        </trans-unit>
        <trans-unit id="8b8d2b9e0c9b1879d05717152c53da40bcc3437b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; is based on the Strictly Pretty paper by &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines).</source>
          <target state="translated">实施&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;是基于严格的漂亮的纸&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt;它建立在以前的漂亮印花算法顶部，而是针对严格的语言，如药剂。本文的核心思想是使用显式文档组，这些文档组呈现为平面（以空格分隔）或以中断（以换行符分隔）。</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">这个回调的实现应该调用 &lt;code&gt;fun&lt;/code&gt; 与下的价值 &lt;code&gt;key&lt;/code&gt; 在通过结构 &lt;code&gt;data&lt;/code&gt; ，或 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 是不存在的。此函数必须返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 或 &lt;code&gt;:pop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="791ef5c45db6655a2b8e0d52e101cc594625c78d" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">初始后端是通过 &lt;code&gt;:backends&lt;/code&gt; 配置加载的，该配置必须在 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前进行设置。</target>
        </trans-unit>
        <trans-unit id="26abb8f8f9a767e820200e7bf8e998799e79b893" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started. Backends can also be added dynamically through &lt;a href=&quot;#add_backend/2&quot;&gt;&lt;code&gt;add_backend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">初始后端是通过 &lt;code&gt;:backends&lt;/code&gt; 配置加载的，该配置必须在 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前进行设置。后端也可以通过&lt;a href=&quot;#add_backend/2&quot;&gt; &lt;code&gt;add_backend/2&lt;/code&gt; &lt;/a&gt;动态添加。</target>
        </trans-unit>
        <trans-unit id="e5d99b4bc070e331607e6d5df8659a98abe40c48" translate="yes" xml:space="preserve">
          <source>The initial value of the accumulator is &lt;code&gt;acc&lt;/code&gt;. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</source>
          <target state="translated">累加器的初始值为 &lt;code&gt;acc&lt;/code&gt; 。使用累加器为可枚举的每个元素调用该函数。函数返回的结果用作下一次迭代的累加器。该函数返回最后一个累加器。</target>
        </trans-unit>
        <trans-unit id="a3d8510abacaf7b1519659fdcdb00b6e366da892" translate="yes" xml:space="preserve">
          <source>The initialization arguments, in this case the atom &lt;code&gt;:ok&lt;/code&gt;</source>
          <target state="translated">初始化参数，在这种情况下，原子为 &lt;code&gt;:ok&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3041c0950b326f4d917de04b2c7baea534d3ad6" translate="yes" xml:space="preserve">
          <source>The inputs of a macro</source>
          <target state="translated">宏观的投入</target>
        </trans-unit>
        <trans-unit id="90073db7fde62d3d91fecce3e1a99c3827dbc4cc" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">整数可以根据&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;以不同单位给出，并且将在内部将其转换为微秒。</target>
        </trans-unit>
        <trans-unit id="36e6d864c0e22df1c9a628ca13539c3c770887d4" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally. Up to 253402300799 seconds is supported.</source>
          <target state="translated">整数可以根据&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;以不同单位给出，并且将在内部将其转换为微秒。最多支持253402300799秒。</target>
        </trans-unit>
        <trans-unit id="c1ddbc45c619f8049cea4c440a4edb65fecbed96" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">整数可以根据&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;以不同单位给出，并且将在内部将其转换为微秒。</target>
        </trans-unit>
        <trans-unit id="c5f1e2568ac6af5c9527d828828602700a4893a4" translate="yes" xml:space="preserve">
          <source>The interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside &lt;code&gt;apps&lt;/code&gt; with a single command. However, even though they are all listed together inside &lt;code&gt;apps&lt;/code&gt;, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.</source>
          <target state="translated">这种方法的有趣的是，混合有许多便利与这样的项目，如编译和测试中的所有应用程序的能力工作 &lt;code&gt;apps&lt;/code&gt; 使用一个命令。但是，即使它们都在 &lt;code&gt;apps&lt;/code&gt; 一起列出，它们仍然彼此分离，因此您可以根据需要隔离地构建，测试和部署每个应用程序。</target>
        </trans-unit>
        <trans-unit id="ccef43e698ff7f77a039db9e5b5b3d002b852b8a" translate="yes" xml:space="preserve">
          <source>The internal date format that is used when converting between calendars.</source>
          <target state="translated">日历之间转换时使用的内部日期格式。</target>
        </trans-unit>
        <trans-unit id="5490fd4bbe326611a1d9b742e7e1f91649638437" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</source>
          <target state="translated">内部表示是不透明的,不能转换为外部术语格式,然后再转换回来,而不会失去其属性(意味着它不能被发送到另一个节点上的进程,仍然是一个有效的编译match_spec,也不能存储在磁盘上)。</target>
        </trans-unit>
        <trans-unit id="6c115b27adcc796af14ec5adb8e1c50e34b4b2ef" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque.</source>
          <target state="translated">内部表示是不透明的。</target>
        </trans-unit>
        <trans-unit id="7334ee5b04d77d686d637a0f70cc9375ca49af7d" translate="yes" xml:space="preserve">
          <source>The internal time format is used when converting between calendars.</source>
          <target state="translated">日历之间转换时使用内部时间格式。</target>
        </trans-unit>
        <trans-unit id="1c746eb548e21139e2d2543ac649c03aeac54f5a" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;env&lt;/code&gt; of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application &lt;em&gt;environment&lt;/em&gt;. Note that this environment is unrelated to the operating system environment.</source>
          <target state="translated">应用程序资源文件的键 &lt;code&gt;env&lt;/code&gt; 具有将原子映射到项的元组列表，其内容称为应用程序&lt;em&gt;环境&lt;/em&gt;。请注意，此环境与操作系统环境无关。</target>
        </trans-unit>
        <trans-unit id="3409677dd18b558166751c16ef637b64275c9b00" translate="yes" xml:space="preserve">
          <source>The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys.</source>
          <target state="translated">地图中的键类型是允许重叠的,如果重叠,最左边的键优先。如果一个地图值包含的键不在允许的地图键中,则不属于这种类型。</target>
        </trans-unit>
        <trans-unit id="32d41944ca5b336f1b48c86344355078fd3da940" translate="yes" xml:space="preserve">
          <source>The keyword list used with &lt;code&gt;defstruct&lt;/code&gt; defines what fields the struct will have along with their default values.</source>
          <target state="translated">与 &lt;code&gt;defstruct&lt;/code&gt; 一起使用的关键字列表定义了该结构将具有哪些字段及其默认值。</target>
        </trans-unit>
        <trans-unit id="e67b4b10fb8bead468c4a33dc123a05fee573455" translate="yes" xml:space="preserve">
          <source>The kind (&lt;code&gt;:def&lt;/code&gt; or &lt;code&gt;:defp&lt;/code&gt;) must be given, the function name, its arguments and the compilation options.</source>
          <target state="translated">必须给出种类（ &lt;code&gt;:def&lt;/code&gt; 或 &lt;code&gt;:defp&lt;/code&gt; ），函数名称，其参数和编译选项。</target>
        </trans-unit>
        <trans-unit id="4db3abef2e6392ab0276950699e4f4e0f758b4c0" translate="yes" xml:space="preserve">
          <source>The kind handled by formatting functions</source>
          <target state="translated">由格式化函数处理的类型</target>
        </trans-unit>
        <trans-unit id="35b01fa192b09fbd575c96a38ea9c12c69135b18" translate="yes" xml:space="preserve">
          <source>The last step is to change the registry to use the dynamic supervisor:</source>
          <target state="translated">最后一步是更改注册表,使用动态主管。</target>
        </trans-unit>
        <trans-unit id="ec09c363bc1673984c9ef7c8fd26b487f2e86ec0" translate="yes" xml:space="preserve">
          <source>The last step is to implement &lt;code&gt;KVServer.Command.run/1&lt;/code&gt;, to run the parsed commands against the &lt;code&gt;:kv&lt;/code&gt; application. Its implementation is shown below:</source>
          <target state="translated">最后一步是实现 &lt;code&gt;KVServer.Command.run/1&lt;/code&gt; ，以对 &lt;code&gt;:kv&lt;/code&gt; 应用程序运行已解析的命令。其实现如下所示：</target>
        </trans-unit>
        <trans-unit id="a7d6dc59f16f27e400e615ab808e1ed8fe0b3a57" translate="yes" xml:space="preserve">
          <source>The last step is to replace all &lt;code&gt;Mix.env()&lt;/code&gt; calls by &lt;code&gt;config_env()&lt;/code&gt;.</source>
          <target state="translated">最后一步是将所有 &lt;code&gt;Mix.env()&lt;/code&gt; 调用替换为 &lt;code&gt;config_env()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1505f07b9a5dea491d06c3282407488da838a326" translate="yes" xml:space="preserve">
          <source>The last syntax convenience are &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks. &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example:</source>
          <target state="translated">最后一个语法方便是 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块。 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块等效于关键字，它是函数调用的最后一个参数，其中块内容用括号括起来。例如：</target>
        </trans-unit>
        <trans-unit id="bc0ec7829a3c5fbbae5ba7d71fb20b1484d4bd86" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.</source>
          <target state="translated">左至右箭头（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）的表示方式与运算符类似，不同之处在于它们始终是列表的一部分，其左侧表示参数列表，而右侧则是表达式。</target>
        </trans-unit>
        <trans-unit id="a6289423275f2a3ff2ff61d789c2121d3f39f1f8" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The &lt;code&gt;-&amp;gt;&lt;/code&gt; may appear one or more times between one of the following terminators: &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;. When &lt;code&gt;-&amp;gt;&lt;/code&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.</source>
          <target state="translated">左右箭头（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）用于建立左右之间的关系，通常称为子句。左侧可以有零个，一个或多个自变量；右侧为零，一个或多个用换行符分隔的表达式。的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 可能会出现以下的终止子的一个之间的一个或更多次： &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 或 &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; 。当使用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 时，这些终止符之间仅允许其他子句。混合子句和正则表达式是无效的语法。</target>
        </trans-unit>
        <trans-unit id="62dfa2cc28c3ba61b288f1d13e4cdc1ed0d38af0" translate="yes" xml:space="preserve">
          <source>The left-hand side supports any expression you would use on the left-hand side of a match:</source>
          <target state="translated">左侧支持任何你会在匹配的左侧使用的表达方式。</target>
        </trans-unit>
        <trans-unit id="452a67adaa49211fbae18840ab0e8f40710191cd" translate="yes" xml:space="preserve">
          <source>The length of the match is equal to the &lt;code&gt;unit&lt;/code&gt; (a number of bits) times the &lt;code&gt;size&lt;/code&gt; (the number of repeated segments of length &lt;code&gt;unit&lt;/code&gt;).</source>
          <target state="translated">匹配的长度等于 &lt;code&gt;unit&lt;/code&gt; （位数）乘以 &lt;code&gt;size&lt;/code&gt; （长度 &lt;code&gt;unit&lt;/code&gt; 的重复段数）。</target>
        </trans-unit>
        <trans-unit id="9b58150e587a8ab776f8c034fd8c13d895af6209" translate="yes" xml:space="preserve">
          <source>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below).</source>
          <target state="translated">并发水平和允许任务运行的时间可以通过选项来控制(见下面 &quot;选项 &quot;部分)。</target>
        </trans-unit>
        <trans-unit id="0f521fe02fee98ba137b8a2f629c9607b50efc70" translate="yes" xml:space="preserve">
          <source>The limit in the given &lt;code&gt;inspect_opts&lt;/code&gt; is respected and when reached this function stops processing and outputs &lt;code&gt;&quot;...&quot;&lt;/code&gt; instead.</source>
          <target state="translated">遵守给定 &lt;code&gt;inspect_opts&lt;/code&gt; 中的限制，当达到此功能时，该函数将停止处理并输出 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1945f9bf3a795845e8993a19f7a9dfe86f17eea" translate="yes" xml:space="preserve">
          <source>The line above makes &lt;code&gt;:kv&lt;/code&gt; available as a dependency inside &lt;code&gt;:kv_server&lt;/code&gt; and automatically starts the &lt;code&gt;:kv&lt;/code&gt; application before the server starts.</source>
          <target state="translated">上面的 &lt;code&gt;:kv_server&lt;/code&gt; &lt;code&gt;:kv&lt;/code&gt; 可以作为：kv_server内部的依赖项使用，并在服务器启动之前自动启动 &lt;code&gt;:kv&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="6f3150330fa7863de05e8e4f528741a7ca7bb476" translate="yes" xml:space="preserve">
          <source>The line where the module is defined and its file &lt;strong&gt;must&lt;/strong&gt; be passed as options.</source>
          <target state="translated">定义模块的行及其文件&lt;strong&gt;必须&lt;/strong&gt;作为选项传递。</target>
        </trans-unit>
        <trans-unit id="65e5d401ccb2b8279fcac802ea4250628d92a6f3" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;entries&lt;/code&gt; is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked.</source>
          <target state="translated">列表 &lt;code&gt;entries&lt;/code&gt; 是两个元素的元组的一个非空的列表，其中所述第一元件是所述PID和第二元件是关联到PID的值。如果没有给定键的条目，则永远不会调用该回调。</target>
        </trans-unit>
        <trans-unit id="d8d60e505b52f11e3ed1a46b8da9d55ffe759f2d" translate="yes" xml:space="preserve">
          <source>The list of callers of the current process can be retrieved from the Process dictionary with &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt;. This will return either &lt;code&gt;nil&lt;/code&gt; or a list &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; with at least one entry Where &lt;code&gt;pid_n&lt;/code&gt; is the PID that called the current process, &lt;code&gt;pid2&lt;/code&gt; called &lt;code&gt;pid_n&lt;/code&gt;, and &lt;code&gt;pid2&lt;/code&gt; was called by &lt;code&gt;pid1&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt; 从Process字典中检索当前进程的调用者列表。这将返回 &lt;code&gt;nil&lt;/code&gt; 或列表 &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; 哪里有至少一个条目 &lt;code&gt;pid_n&lt;/code&gt; 是调用当前过程中，PID &lt;code&gt;pid2&lt;/code&gt; 称为 &lt;code&gt;pid_n&lt;/code&gt; 和 &lt;code&gt;pid2&lt;/code&gt; 被称为 &lt;code&gt;pid1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2470ea39e6ace181c558514355d2df667d90f1fa" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">文档列表从&amp;ldquo;右侧&amp;rdquo;折叠；在这一点上，此函数类似于&lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt;，不同之处在于它不希望使用初始累加器，而是将 &lt;code&gt;docs&lt;/code&gt; 的最后一个元素用作初始累加器。</target>
        </trans-unit>
        <trans-unit id="6ed6bd036ce9220742f24381556f3269068288d9" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;list#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">文档列表是&amp;ldquo;从右&amp;rdquo;折叠的；在这一点上，此函数类似于&lt;a href=&quot;list#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt;，不同之处在于它不希望使用初始累加器，而是将 &lt;code&gt;docs&lt;/code&gt; 的最后一个元素用作初始累加器。</target>
        </trans-unit>
        <trans-unit id="55a959d98d885f3a529aa834328d65182098caeb" translate="yes" xml:space="preserve">
          <source>The local copy is stored in your &lt;code&gt;MIX_HOME&lt;/code&gt; (defaults to &lt;code&gt;~/.mix&lt;/code&gt;). This version of Rebar will be used as required by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt;&lt;code&gt;mix deps.compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本地副本存储在您的 &lt;code&gt;MIX_HOME&lt;/code&gt; 中（默认为 &lt;code&gt;~/.mix&lt;/code&gt; ）。此版本的Rebar将根据&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt; &lt;code&gt;mix deps.compile&lt;/code&gt; 的&lt;/a&gt;要求使用。</target>
        </trans-unit>
        <trans-unit id="6c160860031d2eb83a58036161c7480f1f6e09fc" translate="yes" xml:space="preserve">
          <source>The lock is sent via &lt;code&gt;opts[:lock]&lt;/code&gt; but it may not always be available. In such cases, if the SCM requires a lock, it must return &lt;code&gt;:mismatch&lt;/code&gt;, otherwise simply &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">锁定是通过 &lt;code&gt;opts[:lock]&lt;/code&gt; 发送的，但可能并不总是可用。在这种情况下，如果SCM需要锁定，则它必须返回 &lt;code&gt;:mismatch&lt;/code&gt; ，否则简单地 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bae6744658312a20896e781b3c9940470c438e50" translate="yes" xml:space="preserve">
          <source>The low-level API for prying sessions and setting up breakpoints.</source>
          <target state="translated">用于窥探会话和设置断点的低级API。</target>
        </trans-unit>
        <trans-unit id="b1a2ec347d3bbd914ac71de3130a3ca5d8e9ba73" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~d&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~d&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期信号没有用。</target>
        </trans-unit>
        <trans-unit id="243770f815841be461d24f785d91a84dc8f25160" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~n&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~n&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="61c4050f1d545dfb95cf8194b35027ab14a85e08" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~t&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~t&lt;/code&gt; 变体不存在，因为插值和转义字符对于时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="32388371298b5aa74ba2be98958ecd5080c981d1" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~u&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~u&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="94a5c210052abe863a1fe8f7104b55665bd29e19" translate="yes" xml:space="preserve">
          <source>The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See &lt;a href=&quot;#t:input/0&quot;&gt;&lt;code&gt;input/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#t:output/0&quot;&gt;&lt;code&gt;output/0&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">宏接收作为参数给出的代码的表示形式，而函数接收作为参数给出的代码的结果。宏必须返回代码表示的超集。有关更多信息，请参见&lt;a href=&quot;#t:input/0&quot;&gt; &lt;code&gt;input/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#t:output/0&quot;&gt; &lt;code&gt;output/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ef1cd736ece10b4c740827fd1cda368fe6a8305" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#notice/2&quot;&gt;&lt;code&gt;notice/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warning/2&quot;&gt;&lt;code&gt;warning/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#critical/2&quot;&gt;&lt;code&gt;critical/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#alert/2&quot;&gt;&lt;code&gt;alert/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#emergency/2&quot;&gt;&lt;code&gt;emergency/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">宏&lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#notice/2&quot;&gt; &lt;code&gt;notice/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#warning/2&quot;&gt; &lt;code&gt;warning/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#critical/2&quot;&gt; &lt;code&gt;critical/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#alert/2&quot;&gt; &lt;code&gt;alert/2&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;#emergency/2&quot;&gt; &lt;code&gt;emergency/2&lt;/code&gt; &lt;/a&gt;优于这个宏，因为它们可以自动消除呼叫&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;完全在如果需要，请进行编译（请参见&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;模块的文档）。</target>
        </trans-unit>
        <trans-unit id="8467f6194459766a9d70ef8dad6012fd6200c681" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn/2&quot;&gt;&lt;code&gt;warn/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">宏&lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#warn/2&quot;&gt; &lt;code&gt;warn/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt;优于此宏，因为如果需要，它们可以在编译时自动完全消除对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;的调用（请参阅&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;模块的文档）。</target>
        </trans-unit>
        <trans-unit id="824174ce5b570e4d9805c05f1124ce5c26a319b1" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defrecordp/3&quot;&gt;&lt;code&gt;defrecordp/3&lt;/code&gt;&lt;/a&gt; can be used to create records while &lt;a href=&quot;#extract/2&quot;&gt;&lt;code&gt;extract/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extract_all/1&quot;&gt;&lt;code&gt;extract_all/1&lt;/code&gt;&lt;/a&gt; can be used to extract records from Erlang files.</source>
          <target state="translated">宏&lt;a href=&quot;#defrecord/3&quot;&gt; &lt;code&gt;defrecord/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#defrecordp/3&quot;&gt; &lt;code&gt;defrecordp/3&lt;/code&gt; &lt;/a&gt;可用于创建记录，而&lt;a href=&quot;#extract/2&quot;&gt; &lt;code&gt;extract/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extract_all/1&quot;&gt; &lt;code&gt;extract_all/1&lt;/code&gt; &lt;/a&gt;可用于从Erlang文件中提取记录。</target>
        </trans-unit>
        <trans-unit id="dd1487033e0043998b4a55854f41e5aff164999a" translate="yes" xml:space="preserve">
          <source>The macros in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">本模块中的宏有两种口味:命名或运算符。例如</target>
        </trans-unit>
        <trans-unit id="9f2bf18c746e61e235b955af779aaf9aaea45f54" translate="yes" xml:space="preserve">
          <source>The main entry point to compile source files.</source>
          <target state="translated">编译源文件的主要入口。</target>
        </trans-unit>
        <trans-unit id="38f9dca5177d03726cc73b1076b1d78de398e382" translate="yes" xml:space="preserve">
          <source>The main function in this module is &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;, which parses a list of command line options and arguments into a keyword list:</source>
          <target state="translated">该模块的主要功能是&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;，它将命令行选项和参数列表解析为关键字列表：</target>
        </trans-unit>
        <trans-unit id="a06fbfa6c4b60070753ff93ddfbef19aade6baec" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">大多数功能都需要chardata。如果提供了其他类型，函数将通过&lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议将这些类型转换为字符串（如typespecs中所示）。有关chardata的更多信息，请参见下面的&amp;ldquo; IO数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="852a05b0450dc656348efc6729f9e523cd593860" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">大多数功能都需要chardata。如果提供了其他类型，函数将通过&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议将这些类型转换为字符串（如typespecs中所示）。有关chardata的更多信息，请参见下面的&amp;ldquo; IO数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="99c734179f1102a008e516a50860fb644aef0bb8" translate="yes" xml:space="preserve">
          <source>The majority of the functions in the &lt;code&gt;File&lt;/code&gt; module expect paths as arguments. Most commonly, those paths will be regular binaries. The &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; module provides facilities for working with such paths:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 模块中的大多数功能都将路径作为参数。最常见的是，这些路径将是常规二进制文件。该&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;模块提供了用于与这样的路径工作：</target>
        </trans-unit>
        <trans-unit id="14d50e0537a311e097eac9e5b800ff509846d646" translate="yes" xml:space="preserve">
          <source>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like &lt;a href=&quot;#wildcard/2&quot;&gt;&lt;code&gt;wildcard/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块中的大多数功能都不会与文件系统交互，除了一些需要它的功能（例如&lt;a href=&quot;#wildcard/2&quot;&gt; &lt;code&gt;wildcard/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;expand/1&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="53cb17dd3de6e34ca6338dd415345dba7ba819e3" translate="yes" xml:space="preserve">
          <source>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with &lt;code&gt;spawn_link/1&lt;/code&gt;, let&amp;rsquo;s see what happens when a process started with &lt;code&gt;spawn/1&lt;/code&gt; fails:</source>
          <target state="translated">大多数情况下，我们在Elixir中生成进程，我们将它们生成为链接进程。在显示带有 &lt;code&gt;spawn_link/1&lt;/code&gt; 的示例之前，让我们看看以 &lt;code&gt;spawn/1&lt;/code&gt; 开始的进程失败时会发生什么：</target>
        </trans-unit>
        <trans-unit id="dffb7c1527c61bbb5104fbd6ca60eac0e55a8d98" translate="yes" xml:space="preserve">
          <source>The map above defines a child with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">上述定义地图的小孩 &lt;code&gt;:id&lt;/code&gt; 的 &lt;code&gt;Stack&lt;/code&gt; 由调用启动 &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10d66e531d4200425ddeb9a59e3170249b7e1aed" translate="yes" xml:space="preserve">
          <source>The map above defines a supervisor with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">上面定义地图与上级 &lt;code&gt;:id&lt;/code&gt; 的 &lt;code&gt;Stack&lt;/code&gt; ，其通过调用启动 &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb3eb4a71679f85fc1f23e76313b0ee7d67d6ad" translate="yes" xml:space="preserve">
          <source>The map contains the following keys:</source>
          <target state="translated">该地图包含以下内容:</target>
        </trans-unit>
        <trans-unit id="89c1e1079a87250a9082cabf85f0e2b686337098" translate="yes" xml:space="preserve">
          <source>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</source>
          <target state="translated">该映射必须是一个函数。该函数接收一个整数,代表它要取消cape的字符的代码点。下面是Elixir实现的默认映射函数。</target>
        </trans-unit>
        <trans-unit id="23154a42b58e45ef674deb33492b4a7b042bd7a7" translate="yes" xml:space="preserve">
          <source>The mapping between code and data (the underlying AST) is what allows Elixir to implement &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.</source>
          <target state="translated">代码和数据之间的映射（底层的AST）使Elixir能够在Elixir自身中实现 &lt;code&gt;defmodule&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; 和其他。Elixir使想要将语言扩展到新域的开发人员可以使用该构造来构建该语言。</target>
        </trans-unit>
        <trans-unit id="a6991efb82e0a459b03a5b7c2a6877fbcec33018" translate="yes" xml:space="preserve">
          <source>The marker is what follows exactly after &lt;code&gt;&amp;lt;%&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; has an empty marker, but &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; has &lt;code&gt;&quot;=&quot;&lt;/code&gt; as marker. The allowed markers so far are:</source>
          <target state="translated">标记紧跟在 &lt;code&gt;&amp;lt;%&lt;/code&gt; 之后。例如， &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; 有一个空的标记物，但 &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; 有 &lt;code&gt;&quot;=&quot;&lt;/code&gt; 作为标记物。到目前为止允许的标记是：</target>
        </trans-unit>
        <trans-unit id="cbb00df7fd3fe762840c451309786ffe89ed55ff" translate="yes" xml:space="preserve">
          <source>The match operator</source>
          <target state="translated">匹配运算符</target>
        </trans-unit>
        <trans-unit id="f8693773fd6ff53ba9de6646d15390dd067bbab4" translate="yes" xml:space="preserve">
          <source>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</source>
          <target state="translated">匹配操作符不仅用于对简单的值进行匹配,而且对于重构更复杂的数据类型也很有用。例如,我们可以对元组进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="a9ee80ea2fa936cf7002a1188db1c8b023133c11" translate="yes" xml:space="preserve">
          <source>The math module</source>
          <target state="translated">数学模块</target>
        </trans-unit>
        <trans-unit id="a810ba47e0afb01caa643d3b27868322a40ed5d7" translate="yes" xml:space="preserve">
          <source>The maximum atom size is of 255 Unicode code points.</source>
          <target state="translated">最大原子大小为255个Unicode码点。</target>
        </trans-unit>
        <trans-unit id="da10e2a3fe264c784b7e0fdd60cc0177cfc3d0fb" translate="yes" xml:space="preserve">
          <source>The message is formatted and displayed in the same format as used by Elixir's CLI.</source>
          <target state="translated">该消息的格式和显示方式与Elixir的CLI使用的格式相同。</target>
        </trans-unit>
        <trans-unit id="ae60ef8d035658452d72bdc4024fef29dc953c1c" translate="yes" xml:space="preserve">
          <source>The message is not sent immediately. Therefore, &lt;code&gt;dest&lt;/code&gt; can receive other messages in-between even when &lt;code&gt;time&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">该消息不会立即发送。因此，即使 &lt;code&gt;time&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;dest&lt;/code&gt; 也可以在其间接收其他消息。</target>
        </trans-unit>
        <trans-unit id="1852e95a6b1b63c415d7d9c305bc3d2ad89962d3" translate="yes" xml:space="preserve">
          <source>The messages supported by ports and their counterpart function APIs are listed below:</source>
          <target state="translated">下面列出了 port 所支持的消息及其对应的函数 API。</target>
        </trans-unit>
        <trans-unit id="01f467e93a20e666a1a71239d36e1b21c0c18df1" translate="yes" xml:space="preserve">
          <source>The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the &lt;code&gt;:line&lt;/code&gt; annotation, while the AST emitted by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt; will only have the &lt;code&gt;:line&lt;/code&gt; annotation if the &lt;code&gt;:line&lt;/code&gt; option is provided.</source>
          <target state="translated">Elixir AST中的元数据是值的关键字列表。可以使用任何密钥，并且编译器的不同部分可以使用不同的密钥。例如，宏收到的AST将始终包含 &lt;code&gt;:line&lt;/code&gt; 注释，而如果提供了 &lt;code&gt;:line&lt;/code&gt; 选项，则&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt;发出的AST仅具有 &lt;code&gt;:line&lt;/code&gt; 注释。</target>
        </trans-unit>
        <trans-unit id="d94502ad54e0168b2a0dd7bb477e4117c14a5e51" translate="yes" xml:space="preserve">
          <source>The minimum example of a &lt;code&gt;test_helper.exs&lt;/code&gt; file would be:</source>
          <target state="translated">&lt;code&gt;test_helper.exs&lt;/code&gt; 文件的最小示例为：</target>
        </trans-unit>
        <trans-unit id="36e330d350d67652867a9b1fa816fde5c72c65e0" translate="yes" xml:space="preserve">
          <source>The modifiers available when creating a Regex are:</source>
          <target state="translated">创建Regex时可用的修饰符有:?</target>
        </trans-unit>
        <trans-unit id="554bd8892a2a2f959aaf3286fab34f7cb4eab543" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块还包含少量的&lt;a href=&quot;bitwise#guards&quot;&gt;Erlang按位操作作为保护&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6202288899e34ec4c71c794b46b5bcdf21e2a59" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块还包含少量的&lt;a href=&quot;bitwise#guards&quot;&gt;Erlang按位操作作为保护&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6173752a29eeb047f2dfafc51f6c1560f53e16b" translate="yes" xml:space="preserve">
          <source>The module containing the custom sigil must be imported before the sigil syntax can be used.</source>
          <target state="translated">在使用sigil语法之前,必须导入包含自定义sigil的模块。</target>
        </trans-unit>
        <trans-unit id="11a697026fe35980b1003f6f8535e1c516332e63" translate="yes" xml:space="preserve">
          <source>The module documentation above contains documentation and examples for the supported &lt;code&gt;name&lt;/code&gt; values, summarized below:</source>
          <target state="translated">上面的模块文档包含受支持的 &lt;code&gt;name&lt;/code&gt; 值的文档和示例，摘要如下：</target>
        </trans-unit>
        <trans-unit id="6052f32cd5500caeb9f54ee4b03cfe6002f80902" translate="yes" xml:space="preserve">
          <source>The module where the server callbacks are implemented, in this case &lt;code&gt;__MODULE__&lt;/code&gt; (meaning the current module)</source>
          <target state="translated">实现服务器回调的模块，在本例中为 &lt;code&gt;__MODULE__&lt;/code&gt; （表示当前模块）</target>
        </trans-unit>
        <trans-unit id="5d69468bc82e2cdb38bbc6e03284931c1987f717" translate="yes" xml:space="preserve">
          <source>The modules &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt;&lt;code&gt;ets&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt;&lt;code&gt;dets&lt;/code&gt;&lt;/a&gt; handle storage of large data structures in memory or on disk respectively.</source>
          <target state="translated">模块&lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt; &lt;code&gt;ets&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt; &lt;code&gt;dets&lt;/code&gt; 分别&lt;/a&gt;处理大型数据结构在内存或磁盘上的存储。</target>
        </trans-unit>
        <trans-unit id="aad5655a8df039c1d174539db815749409e4e0c7" translate="yes" xml:space="preserve">
          <source>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</source>
          <target state="translated">文件中定义的模块不会被删除,调用这个函数只是将它们从列表中删除,允许它们再次被需要。</target>
        </trans-unit>
        <trans-unit id="ea2b347a7bc6a5535356bac28ba3f2b363ebc47b" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">最常见的Erlang错误将转换为Elixir对应的错误。那些不是的将转换为更通用的&lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a0e8b772b81f68e7e9d79ec05dc5213643ac8a48" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">最常见的Erlang错误将转换为Elixir对应的错误。那些不是的将转换为更通用的&lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cdce2f67135b244ca8a17c4bfd6e3995d0cb745a" translate="yes" xml:space="preserve">
          <source>The most common sigil in Elixir is &lt;code&gt;~r&lt;/code&gt;, which is used to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;:</source>
          <target state="translated">药剂中最常见的印记是 &lt;code&gt;~r&lt;/code&gt; ，这是用来创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;正则表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5a6e4e1aba3cc5896f4b550cdd6a497deff0ddb9" translate="yes" xml:space="preserve">
          <source>The most common tasks are &lt;code&gt;mix deps.get&lt;/code&gt; and &lt;code&gt;mix deps.update&lt;/code&gt;. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing &lt;code&gt;mix help deps&lt;/code&gt;, and in the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;documentation for the Mix.Tasks.Deps module&lt;/a&gt;.</source>
          <target state="translated">最常见的任务是 &lt;code&gt;mix deps.get&lt;/code&gt; 和 &lt;code&gt;mix deps.update&lt;/code&gt; 。一旦获取，依赖项将自动为您编译。您可以通过键入 &lt;code&gt;mix help deps&lt;/code&gt; 以及在&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;Mix.Tasks.Deps模块&lt;/a&gt;的文档中了解有关deps的更多信息。</target>
        </trans-unit>
        <trans-unit id="6b9cc7f30985b20ae7924700825d31d820820e24" translate="yes" xml:space="preserve">
          <source>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</source>
          <target state="translated">heredoc符号最常见的使用情况是在编写文档时。例如,在文档中写转义字符很快就会变得容易出错,因为需要对一些字符进行双重转义。</target>
        </trans-unit>
        <trans-unit id="9a837abf2f926d7bd68d291aea16431f4ec63587" translate="yes" xml:space="preserve">
          <source>The most common use of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; is to define application configuration so that &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt; and other &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; functions can be used to retrieve or further change them.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt;的最常见用途是定义应用程序配置，以便可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; &lt;/a&gt;和其他&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;功能来检索或进一步更改它们。</target>
        </trans-unit>
        <trans-unit id="b3b38c4c7bf2ec83c1026ecdaac1402a38fdf641" translate="yes" xml:space="preserve">
          <source>The most common way to raise an exception is via &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">引发异常的最常见方法是通过&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="db6ae63cdeae86d32f305032ae11a7867f19ace7" translate="yes" xml:space="preserve">
          <source>The most commonly used keys are:</source>
          <target state="translated">最常用的钥匙是:</target>
        </trans-unit>
        <trans-unit id="ec63aea88c70e103879cfde37537cf2e076faa36" translate="yes" xml:space="preserve">
          <source>The name of the generated macros will be &lt;code&gt;name&lt;/code&gt; (which has to be an atom). &lt;code&gt;tag&lt;/code&gt; is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if &lt;code&gt;nil&lt;/code&gt;), it's the same as &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;kv&lt;/code&gt; is a keyword list of &lt;code&gt;name: default_value&lt;/code&gt; fields for the new record.</source>
          <target state="translated">生成的宏的名称将为 &lt;code&gt;name&lt;/code&gt; （必须是一个原子）。 &lt;code&gt;tag&lt;/code&gt; 也是一个原子，用作记录的&amp;ldquo;标签&amp;rdquo;（即记录元组的第一个元素）；默认情况下（如果为 &lt;code&gt;nil&lt;/code&gt; ），它与 &lt;code&gt;name&lt;/code&gt; 相同。 &lt;code&gt;kv&lt;/code&gt; 是 &lt;code&gt;name: default_value&lt;/code&gt; 的关键字列表：新记录的default_value字段。</target>
        </trans-unit>
        <trans-unit id="c90ebcf1b0655ac03fd3dd0d53f96acb011b2609" translate="yes" xml:space="preserve">
          <source>The name of the service is &lt;code&gt;demo_demo&lt;/code&gt; because the name is built by concatenating the node name with the release name. Since Elixir automatically uses the same name for both, the service will be referenced as &lt;code&gt;demo_demo&lt;/code&gt;.</source>
          <target state="translated">该服务的名称为 &lt;code&gt;demo_demo&lt;/code&gt; ,因为该名称是通过将节点名称与发行名称连接而构建的。由于Elixir会自动为两者使用相同的名称，因此该服务将被引用为 &lt;code&gt;demo_demo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090750250669854ad5f2a1b18b4694400b5de691" translate="yes" xml:space="preserve">
          <source>The named sequences are represented by atoms.</source>
          <target state="translated">命名的序列由原子表示。</target>
        </trans-unit>
        <trans-unit id="84dca7c82c4adab78e96e4275650ccd595bf63f7" translate="yes" xml:space="preserve">
          <source>The need for monitoring</source>
          <target state="translated">监测的必要性</target>
        </trans-unit>
        <trans-unit id="11f3fb45a34842b8d6e2b1b6e9657cdd42649db8" translate="yes" xml:space="preserve">
          <source>The new child specs outlined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; (v1.5)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;（v1.5）中概述的新子级规格</target>
        </trans-unit>
        <trans-unit id="5d5693a336fde96fc9f4a9263d265529c9d65820" translate="yes" xml:space="preserve">
          <source>The next two functions, &lt;code&gt;lookup/2&lt;/code&gt; and &lt;code&gt;create/2&lt;/code&gt;, are responsible for sending these requests to the server. In this case, we have used &lt;code&gt;{:lookup, name}&lt;/code&gt; and &lt;code&gt;{:create, name}&lt;/code&gt; respectively. Requests are often specified as tuples, like this, in order to provide more than one &amp;ldquo;argument&amp;rdquo; in that first argument slot. It&amp;rsquo;s common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to &lt;code&gt;handle_call/3&lt;/code&gt; or &lt;code&gt;handle_cast/2&lt;/code&gt;.</source>
          <target state="translated">接下来的两个函数 &lt;code&gt;lookup/2&lt;/code&gt; 和 &lt;code&gt;create/2&lt;/code&gt; 负责将这些请求发送到服务器。在这种情况下，我们分别使用了 &lt;code&gt;{:lookup, name}&lt;/code&gt; 和 &lt;code&gt;{:create, name}&lt;/code&gt; 。这样，请求通常被指定为元组，以便在第一个参数槽中提供多个&amp;ldquo;参数&amp;rdquo;。通常，将请求的操作指定为元组的第一个元素，并在其余元素中指定该操作的参数。请注意，请求必须与 &lt;code&gt;handle_call/3&lt;/code&gt; 或 &lt;code&gt;handle_cast/2&lt;/code&gt; 的第一个参数匹配。</target>
        </trans-unit>
        <trans-unit id="987bf5fe1a29a589006df7a1c4246dedd1188aa8" translate="yes" xml:space="preserve">
          <source>The node list defaults to a list of all connected nodes.</source>
          <target state="translated">节点列表默认为所有连接节点的列表。</target>
        </trans-unit>
        <trans-unit id="1e4f23ef668efde946b979656f1273bb8fc04978" translate="yes" xml:space="preserve">
          <source>The notation to represent the union of types is the pipe &lt;code&gt;|&lt;/code&gt;. For example, the typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; creates a type &lt;code&gt;type&lt;/code&gt; that can be either an &lt;code&gt;atom&lt;/code&gt;, a &lt;code&gt;pid&lt;/code&gt;, or a &lt;code&gt;tuple&lt;/code&gt;. This is usually called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt; in other languages</source>
          <target state="translated">表示类型的并集的符号是管道 &lt;code&gt;|&lt;/code&gt; 。例如，typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; ::: atom（）| pid（）| tuple（）创建一个类型 &lt;code&gt;type&lt;/code&gt; ，该类型类型可以是 &lt;code&gt;atom&lt;/code&gt; ， &lt;code&gt;pid&lt;/code&gt; 或 &lt;code&gt;tuple&lt;/code&gt; 。通常在其他语言中称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;求和类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ab75e9fdd50914ae4096566ba3ee4815b968a2a" translate="yes" xml:space="preserve">
          <source>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</source>
          <target state="translated">每个匿名函数子句中的参数数量需要相同,否则会出现错误。</target>
        </trans-unit>
        <trans-unit id="58646d5d2a31b22e08348e0987be6fb1b1552f1b" translate="yes" xml:space="preserve">
          <source>The offset is capped to the length of the string. Returns a tuple with two elements.</source>
          <target state="translated">偏移量以字符串的长度为上限。返回一个包含两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="fc47b2c77b07a194ec3fbe01564888859692ecf9" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;之间的唯一区别是，在比较整数和浮点数时，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;是严格的：</target>
        </trans-unit>
        <trans-unit id="7ac751725399e216969e58864613bb897ae9753a" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;之间的唯一区别是，在比较整数和浮点数时，&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;是严格的：</target>
        </trans-unit>
        <trans-unit id="42fcb26dc86b08d995f11bae71b9989f2f7b728a" translate="yes" xml:space="preserve">
          <source>The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.</source>
          <target state="translated">上述兼容性保证的唯一例外是实验性功能,这些功能将被明确标记为实验性功能,在其稳定之前不提供任何兼容性保证。</target>
        </trans-unit>
        <trans-unit id="7f057536218de2bcb4eee9345b4ec9df6b4b0d58" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is that &lt;code&gt;:skip&lt;/code&gt; is found in the &lt;code&gt;include&lt;/code&gt; filter, &lt;code&gt;:ok&lt;/code&gt; is returned regardless of whether the test was excluded or not.</source>
          <target state="translated">唯一的例外是 &lt;code&gt;:skip&lt;/code&gt; 在 &lt;code&gt;include&lt;/code&gt; 过滤器中找到，无论是否排除测试，均返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b80c752c5e1cd83678df53e132bab989245bf95" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">唯一需要实现的功能是进行转换的&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3738a03df0b0292cd0fc541a62dccb969b8d4008" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt;, which does the conversion.</source>
          <target state="translated">唯一需要实现的功能是&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;，它可以进行转换。</target>
        </trans-unit>
        <trans-unit id="9818a90770672e6306fec6ad6c84e3f7b8114355" translate="yes" xml:space="preserve">
          <source>The only function that must be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">唯一必须实现的功能是进行转换的&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ade81e07849e4708797e256e50ea8daa5d7c1c81" translate="yes" xml:space="preserve">
          <source>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &lt;code&gt;&amp;amp;1&lt;/code&gt;, and that block expressions are not supported:</source>
          <target state="translated">创建匿名函数时的唯一限制是必须存在至少一个占位符，即它必须至少包含 &lt;code&gt;&amp;amp;1&lt;/code&gt; ，并且不支持块表达式：</target>
        </trans-unit>
        <trans-unit id="5bde5d825d53af6907621f0cb4672e1213049a4a" translate="yes" xml:space="preserve">
          <source>The operation is Unicode unsafe.</source>
          <target state="translated">该操作为Unicode不安全。</target>
        </trans-unit>
        <trans-unit id="820323122693cc928f8711400bb7374b1eb73417" translate="yes" xml:space="preserve">
          <source>The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">在二进制浮点数上进行操作,不进行十进制的转换。</target>
        </trans-unit>
        <trans-unit id="215bce352413475dfa0bf14c5c4c4836769feeb5" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Elixir使用的运算符（例如 &lt;code&gt;+&lt;/code&gt; ）可以由任何模块定义，并且可以代替Elixir定义的运算符使用，前提是它们不是专门从&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的（默认情况下随处导入）。例如：</target>
        </trans-unit>
        <trans-unit id="54a4338b50a933ea4de60119e3d7bc1ba6605f93" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Elixir使用的运算符（例如 &lt;code&gt;+&lt;/code&gt; ）可以由任何模块定义，并且可以代替Elixir定义的运算符使用，前提是它们不是专门从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的（默认情况下随处导入）。例如：</target>
        </trans-unit>
        <trans-unit id="d083ec82ad103a49d0f2c21f621e7d904b855c2f" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">将字符串转换为带引号的形式的&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;是Macro.to_string / 2，它将带引号的形式转换为字符串/二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="35424357ca8ff1662dd08fa3f02518cdf95e9618" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">将字符串转换为带引号的形式的&lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;是Macro.to_string / 2，它将带引号的形式转换为字符串/二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="648996e2b78ff86fed25658983c86c1ca75fe83d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if deprecated calls exist.</source>
          <target state="translated">如果存在弃用的调用，则选项 &lt;code&gt;--abort-if-any&lt;/code&gt; 可用于使命令失败。</target>
        </trans-unit>
        <trans-unit id="719eb9d884931feb59017fec9c07b6c8395fab97" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if unreachable calls exist.</source>
          <target state="translated">如果存在无法到达的调用，则选项 &lt;code&gt;--abort-if-any&lt;/code&gt; 可用于使命令失败。</target>
        </trans-unit>
        <trans-unit id="098132f317e5ef6b4049ca986c6beb4394ebb00e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; can be used with &lt;code&gt;@derive&lt;/code&gt; to specify which fields should and should not appear in the algebra document:</source>
          <target state="translated">&lt;code&gt;:only&lt;/code&gt; 和 &lt;code&gt;:except&lt;/code&gt; 选项可以与 &lt;code&gt;@derive&lt;/code&gt; 一起使用，以指定哪些字段应该出现在代数文档中，哪些字段不应出现在代数文档中：</target>
        </trans-unit>
        <trans-unit id="1ca038b4953a725a1168758bdb05bf6957d97558" translate="yes" xml:space="preserve">
          <source>The options above have different properties. Both &lt;code&gt;:rpc&lt;/code&gt; and using a GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.</source>
          <target state="translated">上面的选项具有不同的属性。这两个 &lt;code&gt;:rpc&lt;/code&gt; 和使用GenServer将序列的一台服务器上的请求，而任务是有效的远程节点上异步运行，唯一的序列化点是由主管进行产卵。</target>
        </trans-unit>
        <trans-unit id="ec569bf070d46fd1797683900e4e0d1b42dd476e" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">这些选项还可以用于注册主管名称。支持的值在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="dbbff1ba0f3f44314e39e2577a433b4751e9e390" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">这些选项还可以用于注册主管名称。支持的值在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分下进行了描述。</target>
        </trans-unit>
        <trans-unit id="b29b1695f7e1a72d94e875780fae402a43a9edf2" translate="yes" xml:space="preserve">
          <source>The options given in the child specification are documented in &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">子规范中给出的选项记录在&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29149d2185c124051b475d7edf03c7125bd21d1c" translate="yes" xml:space="preserve">
          <source>The options not available are:</source>
          <target state="translated">不可用的选项有:</target>
        </trans-unit>
        <trans-unit id="4550dfac2891c5670508cc8032dc4a8ebcd0b681" translate="yes" xml:space="preserve">
          <source>The order they are returned is guaranteed to be sorted for proper dependency resolution. For example, if A depends on B, then B will listed before A.</source>
          <target state="translated">它们被返回的顺序保证了正确的依赖性解析的排序。例如,如果A依赖于B,那么B将列在A之前。</target>
        </trans-unit>
        <trans-unit id="df79e73939e2f96120d0bd91e6ec1e8015418fd3" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;List&lt;/code&gt; can still be accessed within &lt;code&gt;Stats&lt;/code&gt; by the fully-qualified name &lt;code&gt;Elixir.List&lt;/code&gt;.</source>
          <target state="translated">仍然可以在 &lt;code&gt;Stats&lt;/code&gt; 中使用完全限定的名称 &lt;code&gt;Elixir.List&lt;/code&gt; 来访问原始 &lt;code&gt;List&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce9ed5ea2ea656edc685034fbbcbc4be784892bd" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">通过提供 &lt;code&gt;:label&lt;/code&gt; 选项，可以轻松地将输出与其他&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用区分开来，从而用标签装饰输出。标签将在检查 &lt;code&gt;item&lt;/code&gt; 之前打印。</target>
        </trans-unit>
        <trans-unit id="e1668a9a07e94faf6e48dc573decf8c9122af382" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">通过提供 &lt;code&gt;:label&lt;/code&gt; 选项可以轻松地将输出与其他&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用区分开，从而可以用标签修饰输出。标签将在检查 &lt;code&gt;item&lt;/code&gt; 之前打印。</target>
        </trans-unit>
        <trans-unit id="f95d4e3d274d4d273eca22868ba00ceeec8b577f" translate="yes" xml:space="preserve">
          <source>The output of a macro</source>
          <target state="translated">宏的输出</target>
        </trans-unit>
        <trans-unit id="a8fcd6a77b8cc147c47e87ab2b38b5ca8be3e761" translate="yes" xml:space="preserve">
          <source>The path for local archives or escripts.</source>
          <target state="translated">本地档案或电子稿的路径。</target>
        </trans-unit>
        <trans-unit id="abd015aedaea96a1467039e45829bb4bd7fad58c" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，将使用&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果该路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="e20a72d38a5ba46e84750b746640ae5729db0fc4" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在删除该路径之前，会先使用&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果路径不存在，则此函数返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e11342758ba07f1f86c835e6c8736ad536d0d920" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，先使用&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果该路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="313b3334ac8a23ead5e2d1a7fbc216efaabeea04" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，将使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果此路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="6d4310f7386df1164fbd8636a1690c05bd665337" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在删除该路径之前，先使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果路径不存在，则此函数返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="838b6d73e0a2709d4a72a878f5b42de538ac3faf" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，先使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果此路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="e091aa0884c675c72ffb53e03abf27a7e2087b1e" translate="yes" xml:space="preserve">
          <source>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</source>
          <target state="translated">路径可以是一个charlist或一个字符串。在内部,它们是作为 charlists 工作的,所以以 list 的形式传递它们可以避免额外的转换。</target>
        </trans-unit>
        <trans-unit id="668bfdcbbc88064352f1db03b861c85f89d02114" translate="yes" xml:space="preserve">
          <source>The pattern can be a module name, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; to count all calls to that module, a call without arity, such as &lt;code&gt;String.split&lt;/code&gt;, to count all calls to that function regardless of arity, or a call with arity, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt;, to count all calls to that exact module, function and arity.</source>
          <target state="translated">该模式可以是一个模块名称，例如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;来计数对该模块的所有调用，一个无Arity的调用（例如 &lt;code&gt;String.split&lt;/code&gt; )，以计算对该函数的所有调用，而与Arity无关，或者具有Arity的调用（例如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt;，以计算对该确切模块，函数和Arity的所有调用。</target>
        </trans-unit>
        <trans-unit id="e6382a5f5628ad82e683e23e1297c423e36e37f3" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matched patterns:</source>
          <target state="translated">模式也可以是一个字符串列表,替换也可以是一个接收匹配模式的函数。</target>
        </trans-unit>
        <trans-unit id="d3b17b28d01efecd387f4a558aef5d36e3e123e9" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matches:</source>
          <target state="translated">模式也可以是一个字符串列表,替换也可以是一个接收匹配的函数。</target>
        </trans-unit>
        <trans-unit id="5c2c0506c6452af899d4d254cc14a3c00d8d753c" translate="yes" xml:space="preserve">
          <source>The pattern of keeping multiple applications in the same repository is known as &amp;ldquo;mono-repo&amp;rdquo;. Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.</source>
          <target state="translated">将多个应用程序保留在同一存储库中的模式称为&amp;ldquo; mono-repo&amp;rdquo;。伞项目通过提供方便的方式来一次编译，测试和运行多个应用程序，从而最大化了这种模式。</target>
        </trans-unit>
        <trans-unit id="b5336f2e10af99a0ddce0df1dbcc6953c1b3edca" translate="yes" xml:space="preserve">
          <source>The pin operator</source>
          <target state="translated">销操作者</target>
        </trans-unit>
        <trans-unit id="8a16097e3345670b784d58d96c0daf29bd6b6363" translate="yes" xml:space="preserve">
          <source>The pipe operator</source>
          <target state="translated">管道操作员</target>
        </trans-unit>
        <trans-unit id="38ac69a732c3ec695582cbd0d48d9b6cb576dd15" translate="yes" xml:space="preserve">
          <source>The port can be opened through four main mechanisms.</source>
          <target state="translated">该端口可以通过四种主要机制打开。</target>
        </trans-unit>
        <trans-unit id="16f2f4882ba1e010d9493752e86925be5a3100f2" translate="yes" xml:space="preserve">
          <source>The power of Elixir&amp;rsquo;s extensibility comes when protocols and structs are used together.</source>
          <target state="translated">当协议和结构体一起使用时，Elixir的可扩展性就会到来。</target>
        </trans-unit>
        <trans-unit id="4539c5e2ab058d8719dac59fa3bb2dc3b38cff89" translate="yes" xml:space="preserve">
          <source>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</source>
          <target state="translated">精度表示将微秒表示为外部格式时必须使用的数字。如果精度为0,表示必须跳过微秒。</target>
        </trans-unit>
        <trans-unit id="7b62847898ead6d12d866064984b0e4967caa7b6" translate="yes" xml:space="preserve">
          <source>The previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many &lt;code&gt;case&lt;/code&gt; calls.</source>
          <target state="translated">先前的实现使用了流水线，使逻辑易于理解。但是，由于我们现在需要处理不同的错误代码，因此我们的服务器逻辑嵌套在许多 &lt;code&gt;case&lt;/code&gt; 调用中。</target>
        </trans-unit>
        <trans-unit id="199cc5f932aae17375561fec949a9c5a51d6d815" translate="yes" xml:space="preserve">
          <source>The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with.</source>
          <target state="translated">上述代码的问题是,如果用户提供了无效的输入,错误将在库的深处被提出,这使得用户感到困惑。此外,当你不在边界处验证值时,你的库的内部永远不能完全确定他们在处理哪种值。</target>
        </trans-unit>
        <trans-unit id="523d730771dc4a286c57cbc053f5c708e3c1f6ea" translate="yes" xml:space="preserve">
          <source>The process is terminated, if there's one. The child specification is kept unless the child is temporary.</source>
          <target state="translated">进程被终止,如果有的话。除非子程序是临时性的,否则子程序规格会被保留。</target>
        </trans-unit>
        <trans-unit id="b431d95d4131709473d087764c74e5d0bd63926d" translate="yes" xml:space="preserve">
          <source>The process of taking a list and &lt;em&gt;reducing&lt;/em&gt; it down to one value is known as a &lt;em&gt;reduce algorithm&lt;/em&gt; and is central to functional programming.</source>
          <target state="translated">服用的列表，并且处理&lt;em&gt;减少&lt;/em&gt;它下降到一个值被称为一个&lt;em&gt;减少算法&lt;/em&gt;，而且是中心功能的编程。</target>
        </trans-unit>
        <trans-unit id="2fe675ae074650fc0dd2cca82261ebbd5e4a0afa" translate="yes" xml:space="preserve">
          <source>The process that sends the message does not block on &lt;code&gt;send/2&lt;/code&gt;, it puts the message in the recipient&amp;rsquo;s mailbox and continues. In particular, a process can send messages to itself.</source>
          <target state="translated">发送消息的过程不会在 &lt;code&gt;send/2&lt;/code&gt; 上阻塞，它会将消息放入收件人的邮箱中并继续。特别是，进程可以向自身发送消息。</target>
        </trans-unit>
        <trans-unit id="f279aa503c0e9c1a8851aaff4d4667435775ccbe" translate="yes" xml:space="preserve">
          <source>The project name is given in the &lt;code&gt;snake_case&lt;/code&gt; convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the &lt;a href=&quot;naming-conventions&quot;&gt;Naming Conventions&lt;/a&gt; document for more information.</source>
          <target state="translated">项目名称以 &lt;code&gt;snake_case&lt;/code&gt; 约定给出，其中所有字母均为小写，单词之间用下划线分隔。这与Elixir中的变量，函数名称和原子使用的约定相同。有关更多信息，请参见&lt;a href=&quot;naming-conventions&quot;&gt;命名约定&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="ee55aee8e2dfe77fe02c53dba2352810a3c64b0a" translate="yes" xml:space="preserve">
          <source>The protocol definition would look like this:</source>
          <target state="translated">协议的定义是这样的。</target>
        </trans-unit>
        <trans-unit id="bc915ce7d8df69961e91346b51ae1b4406aeabbb" translate="yes" xml:space="preserve">
          <source>The queue module</source>
          <target state="translated">尾部模块</target>
        </trans-unit>
        <trans-unit id="0af8f5620b697ca5fb92373212c500e4cb31990a" translate="yes" xml:space="preserve">
          <source>The rand module</source>
          <target state="translated">兰德模块</target>
        </trans-unit>
        <trans-unit id="ff54517df928691d964fdb5317bf18da5a260890" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此行为的基本原理是更好地支持Erlang库，该库可能以charlists而不是Elixir字符串的形式返回文本。在Erlang中，字符列表是处理字符串的默认方式，而在Elixir中则是二进制文件。此类功能的一个示例是&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="231da92c7cb81a49b248aa20d7528608e5de9c35" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is &lt;a href=&quot;application#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此行为的基本原理是更好地支持Erlang库，该库可能以charlists而不是Elixir字符串的形式返回文本。此类函数的一个示例是&lt;a href=&quot;application#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="22c7e6cba80de4bce6770359917648b6c44cab9b" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">与结构混合使用时，协议的真正好处就在于。例如，Elixir附带了许多实现为结构的数据类型，例如&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;。我们也可以为这些类型实现 &lt;code&gt;Size&lt;/code&gt; 协议：</target>
        </trans-unit>
        <trans-unit id="bd093bcc0572d7db8f0249b943686c7ab44cd28f" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">与结构混合使用时，协议的真正好处就在于。例如，Elixir附带许多实现为结构的数据类型，例如&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;。我们也可以为这些类型实现 &lt;code&gt;Size&lt;/code&gt; 协议：</target>
        </trans-unit>
        <trans-unit id="dd7d714c1aa6b48b1d5593fcc16114d85e6a86ca" translate="yes" xml:space="preserve">
          <source>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like &lt;code&gt;~r(^https?://)&lt;/code&gt; reads arguably better than &lt;code&gt;~r/^https?:\/\//&lt;/code&gt;. Similarly, if the regular expression has forward slashes and capturing groups (that use &lt;code&gt;()&lt;/code&gt;), you may then choose double quotes instead of parentheses.</source>
          <target state="translated">支持不同定界符的原因是提供了一种无需转义定界符即可编写文字的方法。例如，带有正斜杠的正则表达式，例如〜r &lt;code&gt;~r(^https?://)&lt;/code&gt; 读起来肯定比 &lt;code&gt;~r/^https?:\/\//&lt;/code&gt; 。同样，如果正则表达式具有正斜杠和捕获组（使用 &lt;code&gt;()&lt;/code&gt; ），则可以选择双引号而不是括号。</target>
        </trans-unit>
        <trans-unit id="2ebf61cf3ca7649d4a079542dcbdefccc549e8d6" translate="yes" xml:space="preserve">
          <source>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</source>
          <target state="translated">之所以会出现这些失误,是因为在教学上,我们犯了两个错误。</target>
        </trans-unit>
        <trans-unit id="c08560839cd14ff160f58cb4ece9a90b113b6018" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don&amp;rsquo;t need to worry about different data types in order to sort. The overall sorting order is defined below:</source>
          <target state="translated">我们可以比较不同数据类型的原因是实用主义。排序算法无需担心不同的数据类型即可进行排序。总体排序顺序如下：</target>
        </trans-unit>
        <trans-unit id="96b6eb1d3d1c2f52c89893113a0264a48486f7f0" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</source>
          <target state="translated">我们可以比较不同数据类型的原因是实用主义。排序算法不需要担心不同数据类型的排序问题。作为参考,整体的排序顺序定义如下。</target>
        </trans-unit>
        <trans-unit id="5bf8002bbf671d6262f86dd4db1f940a5c99c6ee" translate="yes" xml:space="preserve">
          <source>The reason we don't provide hot code upgrades is because they are very complicated to perform in practice, as they require careful coding of your processes and applications as well as extensive testing. Given most teams can use other techniques that are language agnostic to upgrade their systems, such as Blue/Green deployments, Canary deployments, Rolling deployments, and others, hot upgrades are rarely a viable option. Let's understand why.</source>
          <target state="translated">我们不提供热代码升级的原因是,它们在实践中执行起来非常复杂,因为它们需要对您的流程和应用程序进行仔细的编码以及广泛的测试。鉴于大多数团队可以使用其他与语言无关的技术来升级他们的系统,如Blue/Green部署、Canary部署、Rolling部署等,热升级很少是一个可行的选择。我们来了解一下原因。</target>
        </trans-unit>
        <trans-unit id="9745fde52cc90f68fc3769f51bdd3839a79e7909" translate="yes" xml:space="preserve">
          <source>The reason why defining the &lt;code&gt;__using__&lt;/code&gt; macro above should be avoided is because when a developer writes:</source>
          <target state="translated">应该避免定义上面的 &lt;code&gt;__using__&lt;/code&gt; 宏的原因是，当开发人员编写时：</target>
        </trans-unit>
        <trans-unit id="6ec6b8d401a0e57e5eec7caca955764b74ee728d" translate="yes" xml:space="preserve">
          <source>The reducer function.</source>
          <target state="translated">减速器功能。</target>
        </trans-unit>
        <trans-unit id="fe9b615b4b2367b7daee50e253cbdf23dba26c40" translate="yes" xml:space="preserve">
          <source>The registry can be used for different purposes, such as name lookups (using the &lt;code&gt;:via&lt;/code&gt; option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.</source>
          <target state="translated">注册表可用于不同目的，例如名称查找（使用 &lt;code&gt;:via&lt;/code&gt; 选项），存储属性，自定义调度规则或pubsub实现。我们在下面探索其中一些用例。</target>
        </trans-unit>
        <trans-unit id="830561c69ec1b44d20b1476b8ca91dcfe652b847" translate="yes" xml:space="preserve">
          <source>The registry creates the bucket and updates the cache table</source>
          <target state="translated">注册表创建桶并更新缓存表。</target>
        </trans-unit>
        <trans-unit id="1e02149d4dfcef116ac8ae8bc7c958f58a3e9c0d" translate="yes" xml:space="preserve">
          <source>The registry identifier</source>
          <target state="translated">登记处的标识符</target>
        </trans-unit>
        <trans-unit id="6c262eba9d17501af95e8d89e43d93764b4ff9c4" translate="yes" xml:space="preserve">
          <source>The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries.</source>
          <target state="translated">注册表还可以透明地进行分区,这为在具有数千或数百万条目的高并发环境中运行注册表提供了更多可扩展的行为。</target>
        </trans-unit>
        <trans-unit id="6dcaa3fc50cf9fd5531a012d77c058d5085b7bd8" translate="yes" xml:space="preserve">
          <source>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to &lt;em&gt;monitor&lt;/em&gt; each bucket. Because our &lt;em&gt;registry&lt;/em&gt; needs to be able to receive and handle ad-hoc messages from the system, the &lt;code&gt;Agent&lt;/code&gt; API is not enough.</source>
          <target state="translated">注册表需要保证它始终是最新的。例如，如果存储桶进程之一由于错误而崩溃，则注册表必须注意此更改，并避免提供过时的条目。在Elixir中，我们说注册表需要&lt;em&gt;监视&lt;/em&gt;每个存储桶。因为我们的&lt;em&gt;注册表&lt;/em&gt;需要能够接收和处理来自系统的临时消息，所以 &lt;code&gt;Agent&lt;/code&gt; API不够。</target>
        </trans-unit>
        <trans-unit id="4a058f690e57a3aca65e5ad6c344df9d0e9611d7" translate="yes" xml:space="preserve">
          <source>The registry requires the following keys:</source>
          <target state="translated">注册表需要下列键:</target>
        </trans-unit>
        <trans-unit id="66187ff2a57d2c76b021b6e86b887377c3911cc5" translate="yes" xml:space="preserve">
          <source>The remaining fields are private and should not be accessed.</source>
          <target state="translated">其余的字段都是私人的,不应该被访问。</target>
        </trans-unit>
        <trans-unit id="1f0abbf815761f3e816424020ca8e718d8880a26" translate="yes" xml:space="preserve">
          <source>The remaining options can be specified to further customize the escript:</source>
          <target state="translated">其余选项可以指定,以进一步定制escript。</target>
        </trans-unit>
        <trans-unit id="7b880036afa4f762da2230a6fa814b25c0b9e585" translate="yes" xml:space="preserve">
          <source>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the capture. In case &lt;code&gt;\0&lt;/code&gt; is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use &lt;code&gt;\\N&lt;/code&gt; and &lt;code&gt;\\g{N}&lt;/code&gt;.</source>
          <target state="translated">替换可以是字符串或函数。该字符串用作每个匹配项的替换，它允许通过 &lt;code&gt;\N&lt;/code&gt; 或 &lt;code&gt;\g{N}&lt;/code&gt; 访问特定的捕获，其中 &lt;code&gt;N&lt;/code&gt; 是捕获。如果使用 &lt;code&gt;\0&lt;/code&gt; ，则会插入整个匹配项。请注意，在正则表达式中，需要转义反斜杠，因此在实践中，您将需要使用 &lt;code&gt;\\N&lt;/code&gt; 和 &lt;code&gt;\\g{N}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12dcacc64e49f2ca797e3a42d48c6b95c4c021d" translate="yes" xml:space="preserve">
          <source>The reply sent by the task will be in the format &lt;code&gt;{ref, result}&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the monitor reference held by the task struct and &lt;code&gt;result&lt;/code&gt; is the return value of the task function.</source>
          <target state="translated">任务发送的回复将采用 &lt;code&gt;{ref, result}&lt;/code&gt; 格式，其中 &lt;code&gt;ref&lt;/code&gt; 是任务struct所拥有的监视器引用，而 &lt;code&gt;result&lt;/code&gt; 是任务函数的返回值。</target>
        </trans-unit>
        <trans-unit id="fbae3095fe06d4c7dbe53db6c416f757e85aa9e2" translate="yes" xml:space="preserve">
          <source>The requirement operand after the &lt;code&gt;~&amp;gt;&lt;/code&gt; is allowed to omit the patch version, allowing us to express &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; or &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt;, something that wouldn't be allowed when using the common comparison operators.</source>
          <target state="translated">允许 &lt;code&gt;~&amp;gt;&lt;/code&gt; 之后的需求操作数省略补丁版本，从而使我们可以表达 &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; 或 &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt; ，这是使用通用比较运算符时所不允许的。</target>
        </trans-unit>
        <trans-unit id="48c107c58db2b694200d1ee8f97e6cacd70556ad" translate="yes" xml:space="preserve">
          <source>The requirements for this guide are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">本指南的要求是（请参阅 &lt;code&gt;elixir -v&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="510fb68883c75cfa0f5726ad2958e2b2d1f8df13" translate="yes" xml:space="preserve">
          <source>The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more.</source>
          <target state="translated">本文档的其余部分将涵盖如何指定儿童进程,如何启动和停止它们,不同的监督策略等。</target>
        </trans-unit>
        <trans-unit id="34f71128fc5223e069e44135ef71e787278b7b2a" translate="yes" xml:space="preserve">
          <source>The result depends on the given options. In particular, if &lt;code&gt;:monitor&lt;/code&gt; is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</source>
          <target state="translated">结果取决于给定的选项。特别是，如果 &lt;code&gt;:monitor&lt;/code&gt; 作为选项提供，它将返回一个包含PID和监视参考的元组，否则仅返回生成的过程PID。</target>
        </trans-unit>
        <trans-unit id="8c0864a3fd323ad326bf0ff0a4ae750f6f28b62b" translate="yes" xml:space="preserve">
          <source>The result is a map where each key is given by &lt;code&gt;key_fun&lt;/code&gt; and each value is a list of elements given by &lt;code&gt;value_fun&lt;/code&gt;. The order of elements within each list is preserved from the &lt;code&gt;enumerable&lt;/code&gt;. However, like all maps, the resulting map is unordered.</source>
          <target state="translated">结果是一个映射，其中每个键都由 &lt;code&gt;key_fun&lt;/code&gt; 给定，每个值都是 &lt;code&gt;value_fun&lt;/code&gt; 给定的元素列表。每个列表中元素的顺序保留在 &lt;code&gt;enumerable&lt;/code&gt; 。但是，像所有地图一样，生成的地图是无序的。</target>
        </trans-unit>
        <trans-unit id="8c937afc93e905039ed962f46e31ce761b0b7910" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the code point and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">结果是一个带代码点和字符串其余部分的元组，如果字符串到达​​末尾则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b054d17c2daa0de49da800a95e641450c215bba5" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the grapheme and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the String reached its end.</source>
          <target state="translated">结果是带有字素和字符串其余部分的元组，如果字符串到达​​末尾则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf56030549a526b9bf11fca22b129025175f9e01" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">结果是一个元组，具有下一个字形大小和字符串的其余部分，或者 &lt;code&gt;nil&lt;/code&gt; （如果字符串到达​​其末尾）。</target>
        </trans-unit>
        <trans-unit id="49e5bd89a099593fc1d84560689945a8bdf9718a" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size in bytes and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">结果是一个元组，具有下一个字形大小（以字节为单位），并且字符串的其余部分 &lt;code&gt;nil&lt;/code&gt; ，以防万一字符串到达​​其末尾。</target>
        </trans-unit>
        <trans-unit id="69c824c2f4dd9e92c63e7c43b613daec936f10e9" translate="yes" xml:space="preserve">
          <source>The result is always a float. Use &lt;a href=&quot;#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rem/2&quot;&gt;&lt;code&gt;rem/2&lt;/code&gt;&lt;/a&gt; if you want an integer division or the remainder.</source>
          <target state="translated">结果始终是浮点数。如果要整数除法或余数，请使用&lt;a href=&quot;#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rem/2&quot;&gt; &lt;code&gt;rem/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e60b28a7c2d9f237889da5d63ad55cd56db26e5f" translate="yes" xml:space="preserve">
          <source>The result is returned in the &lt;code&gt;:native&lt;/code&gt; time unit.</source>
          <target state="translated">结果以 &lt;code&gt;:native&lt;/code&gt; 时间单位返回。</target>
        </trans-unit>
        <trans-unit id="7e378125d134cee06b90778b774e2ca53b3a689f" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (e.g., obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">其结果是在给定的时间单位返回 &lt;code&gt;unit&lt;/code&gt; 。返回的偏移量添加到Erlang单调时间（例如，通过&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt;获得），从而得出与该单调时间相对应的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="bd31606d8c7fb963c24880e97f324e4acb8d8f68" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (for instance, one obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">其结果是在给定的时间单位返回 &lt;code&gt;unit&lt;/code&gt; 。返回的偏移量加上Erlang单调时间（例如，使用&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt;获得的偏移量），得出的Erlang系统时间对应于该单调时间。</target>
        </trans-unit>
        <trans-unit id="ad2bb7bf504a7a31fc692bc22a46a7f6c26558df" translate="yes" xml:space="preserve">
          <source>The result is rounded via the floor function.</source>
          <target state="translated">结果通过底限函数取整。</target>
        </trans-unit>
        <trans-unit id="7c9d24e7e55d00cf51e7d7ac4365534956cf6af0" translate="yes" xml:space="preserve">
          <source>The result of the reduce operation.</source>
          <target state="translated">减少操作的结果。</target>
        </trans-unit>
        <trans-unit id="5c33a08ba308a53a6a04ff3b3a415b2906539c81" translate="yes" xml:space="preserve">
          <source>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">这个函数的结果是用来检查两个日历是否在一天中的同一时间翻转。如果没有,我们只能在它们之间转换日期和时间。如果是,这意味着我们也可以在它们之间转换日期和天真的日期时间。</target>
        </trans-unit>
        <trans-unit id="deee6a8e2cf3a1dc01e05f85abd7a333a49b9743" translate="yes" xml:space="preserve">
          <source>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</source>
          <target state="translated">当参数是一个 list 时,返回的结果是满足 list 元素反结的节点列表。</target>
        </trans-unit>
        <trans-unit id="de9d80b1ab304736a1d1cf097b00ab6920ddf496" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;fun&lt;/code&gt; is expected to be</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 的返回值预计为</target>
        </trans-unit>
        <trans-unit id="ac8a9c64fdd4a29692e13a9877d1bb2d850a96ef" translate="yes" xml:space="preserve">
          <source>The return value is considered to be found when the result is truthy (neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">当结果为true（既不为 &lt;code&gt;nil&lt;/code&gt; 也不为 &lt;code&gt;false&lt;/code&gt; ）时，则认为已找到返回值。</target>
        </trans-unit>
        <trans-unit id="c789d5090be5fd4830e5650f8cf224329bb3d092" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; or any of the &lt;code&gt;handle_*&lt;/code&gt; callbacks may include a timeout value in milliseconds; if not, &lt;code&gt;:infinity&lt;/code&gt; is assumed. The timeout can be used to detect a lull in incoming messages.</source>
          <target state="translated">&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;或任何 &lt;code&gt;handle_*&lt;/code&gt; 回调的返回值都可以包含超时值（以毫秒为单位）。如果不是，则假定 &lt;code&gt;:infinity&lt;/code&gt; 。超时可用于检测传入消息的停顿。</target>
        </trans-unit>
        <trans-unit id="637f2543c6c71a469bb5665295bb80f1c21c7816" translate="yes" xml:space="preserve">
          <source>The return value of this function is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此函数的返回值始终为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee9968a076604f4bf8eb65e4e57dfeed366595f" translate="yes" xml:space="preserve">
          <source>The return value of this function is the value that was previously stored under &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; in case no value was stored under it.</source>
          <target state="translated">这个函数的返回值是以前下存储的值 &lt;code&gt;key&lt;/code&gt; ，或 &lt;code&gt;nil&lt;/code&gt; 的情况下，没有值存储在它之下。</target>
        </trans-unit>
        <trans-unit id="8981b39a20d60bae9e3cc6f4a790fa30d54a0258" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; will have &lt;code&gt;UTC&lt;/code&gt; timezone, if you want other timezone, please use &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;将具有 &lt;code&gt;UTC&lt;/code&gt; 时区，如果需要其他时区，请使用&lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30cb91bc5640b8dc4f60b9f7ca0aa50c81c4fc01" translate="yes" xml:space="preserve">
          <source>The returned datetime must be in UTC. The original &lt;code&gt;utc_offset&lt;/code&gt; it was written in must be returned in the result.</source>
          <target state="translated">返回的日期时间必须采用UTC。必须将原始的 &lt;code&gt;utc_offset&lt;/code&gt; 写入结果中。</target>
        </trans-unit>
        <trans-unit id="68256b5cc686943a73a48ce0ec84d14bdbd6db53" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">返回的函数通常作为访问器传递给&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt;和朋友。</target>
        </trans-unit>
        <trans-unit id="f600704ad2a1d265216e1874920599247dcd864b" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">返回的函数通常作为访问器传递给&lt;a href=&quot;kernel#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt;和朋友。</target>
        </trans-unit>
        <trans-unit id="feb14c2276580a5fb93fd8afe56dfe5ef725b402" translate="yes" xml:space="preserve">
          <source>The returned function raises if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则返回的函数将引发。</target>
        </trans-unit>
        <trans-unit id="f18363f66f41ea776d213b7a358943fee2fbf810" translate="yes" xml:space="preserve">
          <source>The returned function receives a term and a command and injects the term into the collectable on every &lt;code&gt;{:cont, term}&lt;/code&gt; command.</source>
          <target state="translated">返回的函数接收一个术语和一个命令，并在每个 &lt;code&gt;{:cont, term}&lt;/code&gt; 命令上将其注入到collectable中。</target>
        </trans-unit>
        <trans-unit id="03b6bd0a789c54c65fa616d4c3d05a787c9fac95" translate="yes" xml:space="preserve">
          <source>The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys:</source>
          <target state="translated">如果键不存在,返回的函数使用默认值。这可以用来指定默认值和安全地遍历丢失的键。</target>
        </trans-unit>
        <trans-unit id="17eadcc2531c98be75b3d36e9d02f1db40badbf9" translate="yes" xml:space="preserve">
          <source>The returned information is a two-element tuple in the shape of &lt;code&gt;{info, value}&lt;/code&gt;.</source>
          <target state="translated">返回的信息是一个 &lt;code&gt;{info, value}&lt;/code&gt; 形式的两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="40619e10ae25c330063c65535cf867c78a0305e7" translate="yes" xml:space="preserve">
          <source>The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:</source>
          <target state="translated">所有类型的函数(本地和外部)的返回键(以及相应的可能值)如下:</target>
        </trans-unit>
        <trans-unit id="8ee75b4eeb81fcc96ebfd98173bc87ddff369546" translate="yes" xml:space="preserve">
          <source>The returned path will be expanded.</source>
          <target state="translated">返回的路径将被展开。</target>
        </trans-unit>
        <trans-unit id="4d71c99a8e09f63bf55427e1e561d5818b8e3777" translate="yes" xml:space="preserve">
          <source>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</source>
          <target state="translated">返回的引用将在大约2^82次调用后重新出现,因此对于实际目的来说,它是唯一的。</target>
        </trans-unit>
        <trans-unit id="6710b3a068da95fe2b8593d7add9ec761b0835bc" translate="yes" xml:space="preserve">
          <source>The returned value is a map containing name-value pairs. Variable names and their values are strings.</source>
          <target state="translated">返回的值是一个包含名-值对的映射。变量名称及其值是字符串。</target>
        </trans-unit>
        <trans-unit id="b373635bb9902337ad9e10b973bd7b4caeea100c" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是一个由 &lt;code&gt;fun&lt;/code&gt; 返回的&amp;ldquo; get&amp;rdquo;值的元组，以及在 &lt;code&gt;key&lt;/code&gt; 下具有更新后值的新关键字列表。</target>
        </trans-unit>
        <trans-unit id="b42137d3006c00e4b619eab71021a2f058571bc2" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回值是一个由 &lt;code&gt;fun&lt;/code&gt; 返回的&amp;ldquo; get&amp;rdquo;值的元组，以及一个在 &lt;code&gt;key&lt;/code&gt; 下具有更新值的新映射。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
