<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="cd76b0391fb1a7a64c931e4a4dc1d98639420e28" translate="yes" xml:space="preserve">
          <source>Types and their syntax</source>
          <target state="translated">类型及其语法</target>
        </trans-unit>
        <trans-unit id="0bc4703b28f4924a9c44bceee00bf1363064b5ea" translate="yes" xml:space="preserve">
          <source>Types can be defined for tuples with the &lt;code&gt;record/2&lt;/code&gt; macro (only available in typespecs). This macro will expand to a tuple as seen in the example below:</source>
          <target state="translated">可以使用 &lt;code&gt;record/2&lt;/code&gt; 宏为元组定义类型（仅在typespec中可用）。如下例所示，该宏将扩展为元组：</target>
        </trans-unit>
        <trans-unit id="aa2e6017cafdcec12ffadda705782bbfa3365007" translate="yes" xml:space="preserve">
          <source>Types can be parameterized by defining variables as parameters; these variables can then be used to define the type.</source>
          <target state="translated">类型可以通过定义变量作为参数进行参数化;然后这些变量可以用来定义类型。</target>
        </trans-unit>
        <trans-unit id="9642fee222699c21f35d30c296f0220d194b3b26" translate="yes" xml:space="preserve">
          <source>Typespec attributes</source>
          <target state="translated">Typespec属性</target>
        </trans-unit>
        <trans-unit id="ec4586f03bdf53faaacd4a0a1f5bfd0f6c72e82a" translate="yes" xml:space="preserve">
          <source>Typespecs</source>
          <target state="translated">Typespecs</target>
        </trans-unit>
        <trans-unit id="12ee67883b50a8a9b8616d935b79570fd90fb391" translate="yes" xml:space="preserve">
          <source>Typespecs and behaviours</source>
          <target state="translated">类型规格和行为</target>
        </trans-unit>
        <trans-unit id="426efe2f128e5103f26a5651730adbe39dfe3a7f" translate="yes" xml:space="preserve">
          <source>Typespecs are not only useful to developers as additional documentation. The Erlang tool &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;Dialyzer&lt;/a&gt;, for example, uses typespecs in order to perform static analysis of code. That&amp;rsquo;s why, in the &lt;code&gt;QuietCalculator&lt;/code&gt; example, we wrote a spec for the &lt;code&gt;make_quiet/1&lt;/code&gt; function even though it was defined as a private function.</source>
          <target state="translated">Typespecs作为附加文档不仅对开发人员有用。Erlang的工具&lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;透析器&lt;/a&gt;，例如，使用typespecs为了执行的代码的静态分析。这就是为什么在 &lt;code&gt;QuietCalculator&lt;/code&gt; 示例中，我们为 &lt;code&gt;make_quiet/1&lt;/code&gt; 函数编写了一个规范，即使它被定义为私有函数也是如此。</target>
        </trans-unit>
        <trans-unit id="27a01a6204a37c38992dd52cc20fa3db2b61cbf1" translate="yes" xml:space="preserve">
          <source>Typical error reasons are the same as in &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#read/1&quot;&gt;&lt;code&gt;read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#write/3&quot;&gt;&lt;code&gt;write/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">典型的错误原因与&lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#read/1&quot;&gt; &lt;code&gt;read/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#write/3&quot;&gt; &lt;code&gt;write/3&lt;/code&gt; 相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">典型的错误原因有:</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">典型的错误原因。</target>
        </trans-unit>
        <trans-unit id="29820537aaefd464fe53b0df62deac28df35005d" translate="yes" xml:space="preserve">
          <source>Typically called after formatting when the data cannot be printed.</source>
          <target state="translated">当数据不能被打印时,通常在格式化后调用。</target>
        </trans-unit>
        <trans-unit id="2ebdb0dbd819b614930942168eaeeb854d37cbf9" translate="yes" xml:space="preserve">
          <source>Typically developers do not use the &lt;code&gt;spawn&lt;/code&gt; functions, instead they use abstractions such as &lt;a href=&quot;task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, built on top of &lt;code&gt;spawn&lt;/code&gt;, that spawns processes with more conveniences in terms of introspection and debugging.</source>
          <target state="translated">通常，开发商不使用 &lt;code&gt;spawn&lt;/code&gt; 的功能，而不是他们使用抽象，例如&lt;a href=&quot;task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;，建立在上面 &lt;code&gt;spawn&lt;/code&gt; ，与自省和调试方面更加便利产卵过程。</target>
        </trans-unit>
        <trans-unit id="a41048f60fc8036bd19784fff24807617c9ba6f2" translate="yes" xml:space="preserve">
          <source>Typically, stable releases are pushed to Hex. If you want to depend on an external dependency still in development, Mix is able to manage Git dependencies too:</source>
          <target state="translated">通常情况下,稳定的发布版本会被推送到Hex上。如果你想依赖还在开发中的外部依赖,Mix也能管理Git依赖。</target>
        </trans-unit>
        <trans-unit id="e81c0c3d0d9554aaaa890589c591cb2c6de83b83" translate="yes" xml:space="preserve">
          <source>Typically, this is used when a process started from a certain shell should have a group leader other than &lt;code&gt;:init&lt;/code&gt;.</source>
          <target state="translated">通常，当从某个外壳启动的进程应具有除 &lt;code&gt;:init&lt;/code&gt; 以外的组长时，将使用此选项。</target>
        </trans-unit>
        <trans-unit id="19526e6dfc6064b512194499eae8afdcd81dca35" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;a href=&quot;#async_nolink/3&quot;&gt;&lt;code&gt;async_nolink/3&lt;/code&gt;&lt;/a&gt; when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is meant to run a single task and track its status:</source>
          <target state="translated">通常，在合理预期任务可能会失败并且您不希望它中断调用者的情况下，请使用&lt;a href=&quot;#async_nolink/3&quot;&gt; &lt;code&gt;async_nolink/3&lt;/code&gt; &lt;/a&gt;。让我们看一个示例，其中&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;旨在运行单个任务并跟踪其状态：</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="40d44fb77280648f021d454874b73243b9965e08" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode</source>
          <target state="translated">UTF-8和Unicode</target>
        </trans-unit>
        <trans-unit id="93fa3107e0f78c4c5bf63b64e4e03caae13e12dc" translate="yes" xml:space="preserve">
          <source>UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, and &lt;code&gt;o&lt;/code&gt;, but two bytes to represent &lt;code&gt;ł&lt;/code&gt;. In Elixir, you can get a character&amp;rsquo;s code point by using &lt;code&gt;?&lt;/code&gt;:</source>
          <target state="translated">UTF-8需要一个字节来表示字符 &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;o&lt;/code&gt; ，但是需要两个字节来表示 &lt;code&gt;ł&lt;/code&gt; 。在Elixir中，您可以使用 &lt;code&gt;?&lt;/code&gt; 获得字符的代码点。：</target>
        </trans-unit>
        <trans-unit id="4ba0eecf4f2b37abbf01f86b85c444b51d79130b" translate="yes" xml:space="preserve">
          <source>Umbrella applications can also be used as a stepping stone for eventually extracting an application from your codebase. For example, imagine a web application that has to send &amp;ldquo;push notifications&amp;rdquo; to its users. The whole &amp;ldquo;push notifications system&amp;rdquo; can be developed as a separate application in the umbrella, with its own supervision tree and APIs. If you ever run into a situation where another project needs the push notifications system, the system can be moved to a private repository or a Hex package.</source>
          <target state="translated">伞形应用程序也可用作最终从代码库中提取应用程序的垫脚石。例如，假设一个Web应用程序必须向其用户发送&amp;ldquo;推送通知&amp;rdquo;。整个&amp;ldquo;推送通知系统&amp;rdquo;可以作为单独的应用程序开发，并具有自己的监督树和API。如果遇到其他项目需要推送通知系统的情况，则可以将该系统移至专用存储库或十六进制包。</target>
        </trans-unit>
        <trans-unit id="851ed712aa0571dbe2c6f112b44c8797ec7c4c5e" translate="yes" xml:space="preserve">
          <source>Umbrella projects</source>
          <target state="translated">伞形项目</target>
        </trans-unit>
        <trans-unit id="43c968179421920425ac688f848988a9c56a1013" translate="yes" xml:space="preserve">
          <source>Umbrella projects are a convenience to help you organize and manage multiple applications. While it provides a degree of separation between applications, those applications are not fully decoupled, as they share the same configuration and the same dependencies.</source>
          <target state="translated">伞形项目是一种方便,可以帮助你组织和管理多个应用程序。虽然它提供了应用程序之间一定程度的分离,但这些应用程序并没有完全解耦,因为它们共享相同的配置和相同的依赖关系。</target>
        </trans-unit>
        <trans-unit id="7d6b777bb78f858357184c0cf5af750b3f2ffa24" translate="yes" xml:space="preserve">
          <source>Unary</source>
          <target state="translated">Unary</target>
        </trans-unit>
        <trans-unit id="de5d06c8499ec2b6ae1a8811f2fac4af788e75b6" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError</source>
          <target state="translated">UndefinedFunctionError</target>
        </trans-unit>
        <trans-unit id="305519a8e77b6e01d180181d201634eba9423ae4" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UndefinedFunctionError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="47bcfae4a535fdd5dc3c9474709313c0c05cda2a" translate="yes" xml:space="preserve">
          <source>Underline: none.</source>
          <target state="translated">下划线:无。</target>
        </trans-unit>
        <trans-unit id="74cc1e1026bd71e93c70958a6c844e8826bbbfcc" translate="yes" xml:space="preserve">
          <source>Underline: single.</source>
          <target state="translated">下划线:单。</target>
        </trans-unit>
        <trans-unit id="f97b844a47d0ddc9c28ad5334d4b5c8bebe7ba04" translate="yes" xml:space="preserve">
          <source>Underneath a struct is just a map with a &lt;code&gt;:__struct__&lt;/code&gt; key pointing to the &lt;code&gt;User&lt;/code&gt; module:</source>
          <target state="translated">在结构下面只是一个带有 &lt;code&gt;:__struct__&lt;/code&gt; 键指向 &lt;code&gt;User&lt;/code&gt; 模块的映射：</target>
        </trans-unit>
        <trans-unit id="8ecb7df30047a87c4fc859f515326bcb1df1fdc5" translate="yes" xml:space="preserve">
          <source>Underscore (&lt;code&gt;_foo&lt;/code&gt;)</source>
          <target state="translated">下划线（ &lt;code&gt;_foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="860a89de764183b070c833d2c56a715407fdf5ae" translate="yes" xml:space="preserve">
          <source>Underscore functions</source>
          <target state="translated">下划线功能</target>
        </trans-unit>
        <trans-unit id="07214c1f037134f45b6afd6fb6be34b85a19cbdd" translate="yes" xml:space="preserve">
          <source>Understanding Aliases</source>
          <target state="translated">了解别名</target>
        </trans-unit>
        <trans-unit id="cf49459d86609fbaea12c1c990c331d67fab00b7" translate="yes" xml:space="preserve">
          <source>Understanding applications</source>
          <target state="translated">了解应用</target>
        </trans-unit>
        <trans-unit id="7e6e7909c64b19402a59c9e41bf6f2ead8be7854" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars according to the map given.</source>
          <target state="translated">根据给定的地图解开给定的字符。</target>
        </trans-unit>
        <trans-unit id="17a4b21d25e341e163b3fc9fec0b7c0beae4ac5a" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars.</source>
          <target state="translated">Unescapes the given chars.</target>
        </trans-unit>
        <trans-unit id="4f4713c47fdabdbf578d4a71eec889931003b842" translate="yes" xml:space="preserve">
          <source>Unfortunately, similar to &lt;code&gt;IO.inspect/2&lt;/code&gt;, &lt;code&gt;IEx.pry/0&lt;/code&gt; also requires us to change the code we intend to debug. Luckily IEx also provides a &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt;&lt;code&gt;break!/2&lt;/code&gt;&lt;/a&gt; function which allows you set and manage breakpoints on any Elixir code without modifying its source:</source>
          <target state="translated">不幸的是，类似于 &lt;code&gt;IO.inspect/2&lt;/code&gt; ， &lt;code&gt;IEx.pry/0&lt;/code&gt; 还要求我们更改要调试的代码。幸运的是，IEx还提供了&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt; &lt;code&gt;break!/2&lt;/code&gt; &lt;/a&gt;函数，使您可以在任何Elixir代码上设置和管理断点，而无需修改其源代码：</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="c9219d4bebf3a43b3cb39fddf36fce444eec5523" translate="yes" xml:space="preserve">
          <source>Unicode Syntax</source>
          <target state="translated">统一码语法</target>
        </trans-unit>
        <trans-unit id="9230bbe0897bd3834d6a401ee2097bdf85ecad8d" translate="yes" xml:space="preserve">
          <source>Unicode atoms in Elixir follow the identifier rule above with the following modifications:</source>
          <target state="translated">Elixir中的Unicode原子遵循上述标识符规则,但做了如下修改。</target>
        </trans-unit>
        <trans-unit id="c1cd0bc55280570ee38ec7b425e9a53867a918b8" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError</source>
          <target state="translated">UnicodeConversionError</target>
        </trans-unit>
        <trans-unit id="17431ce3c7303d531227e8a58c83d5667bb2fc09" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UnicodeConversionError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d24756b8871b9d0b4227e2aeadf94c161941dedb" translate="yes" xml:space="preserve">
          <source>Unit and Size</source>
          <target state="translated">单位和尺寸</target>
        </trans-unit>
        <trans-unit id="7476fffdc753c76439401e20c5fa467d3860aa0e" translate="yes" xml:space="preserve">
          <source>Unit testing framework for Elixir.</source>
          <target state="translated">Elixir的单元测试框架。</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="cfbf337783a51f862d0cc59c306e1cd8f3532bc3" translate="yes" xml:space="preserve">
          <source>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</source>
          <target state="translated">Unix时间总是以UTC为单位,因此DateTime将以UTC返回。</target>
        </trans-unit>
        <trans-unit id="37ac014f65a6115890eb6cc91e8f2865ac295f23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;expand/2&lt;/code&gt;&lt;/a&gt;, no attempt is made to resolve &lt;code&gt;..&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;expand/2&lt;/code&gt; &lt;/a&gt;不同，没有尝试解决 &lt;code&gt;..&lt;/code&gt; ， &lt;code&gt;.&lt;/code&gt; 或 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e18509c97a5b05619653ea5f9061749ced83e99e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;assert_received&lt;/code&gt;, it has a default &lt;code&gt;timeout&lt;/code&gt; of 100 milliseconds.</source>
          <target state="translated">与 &lt;code&gt;assert_received&lt;/code&gt; 不同，它的默认 &lt;code&gt;timeout&lt;/code&gt; 为100毫秒。</target>
        </trans-unit>
        <trans-unit id="2436badc9eff92032ec9ac619271277eb100f7c7" translate="yes" xml:space="preserve">
          <source>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与Erlang不同，此类属性默认情况下不会存储在模块中，因为在Elixir中很常见的是使用自定义属性来存储在编译时可用的临时数据。可以使用&lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将自定义属性配置为更接近Erlang 。</target>
        </trans-unit>
        <trans-unit id="b56b7c857aa7ffa6e7b36170f0491a230a7cf9f0" translate="yes" xml:space="preserve">
          <source>Unlike other hooks, &lt;code&gt;@on_definition&lt;/code&gt; will only invoke functions and never macros. This is to avoid &lt;code&gt;@on_definition&lt;/code&gt; callbacks from redefining functions that have just been defined in favor of more explicit approaches.</source>
          <target state="translated">与其他钩子不同， &lt;code&gt;@on_definition&lt;/code&gt; 将仅调用函数，而不会调用宏。这是为了避免 &lt;code&gt;@on_definition&lt;/code&gt; 回调重新定义刚刚定义的函数，以支持更明确的方法。</target>
        </trans-unit>
        <trans-unit id="94507a67a9f296aef298df58dcc28d14f54c548d" translate="yes" xml:space="preserve">
          <source>Unlike pattern matching via &lt;code&gt;=&lt;/code&gt;, if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error.</source>
          <target state="translated">与通过 &lt;code&gt;=&lt;/code&gt; 进行模式匹配不同，如果左右列表的大小不匹配，则解构只是停止而不是引发错误。</target>
        </trans-unit>
        <trans-unit id="d9890160c4982970542ec14738f7c0e637cd08c2" translate="yes" xml:space="preserve">
          <source>Unlinking the task process started with &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies.</source>
          <target state="translated">取消链接以 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 开始的任务过程。如果您取消流程链接并且该任务不属于任何主管，则可以悬空任务，以防父母死亡。</target>
        </trans-unit>
        <trans-unit id="11bf0305dcee4e7f1f93ac8f6d2c882005c71769" translate="yes" xml:space="preserve">
          <source>Unlinks and shuts down the task, and then checks for a reply.</source>
          <target state="translated">解除链接并关闭任务,然后检查是否有回复。</target>
        </trans-unit>
        <trans-unit id="e12be5ddb337ed9c6e7cda41d5621c3350bb29f0" translate="yes" xml:space="preserve">
          <source>Unloads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">卸载给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a00f27d2826c92443fcf4fb80f0a03b5f251cb2" translate="yes" xml:space="preserve">
          <source>Unquoted atoms start with a colon (&lt;code&gt;:&lt;/code&gt;) which must be immediately followed by an underscore or a Unicode letter. The atom may continue using a sequence of Unicode letters, numbers, underscores, and &lt;code&gt;@&lt;/code&gt;. Atoms may end in &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification. Valid unquoted atoms are: &lt;code&gt;:ok&lt;/code&gt;, &lt;code&gt;:ISO8601&lt;/code&gt;, and &lt;code&gt;:integer?&lt;/code&gt;.</source>
          <target state="translated">无引号原子开始冒号（ &lt;code&gt;:&lt;/code&gt; ），其必须立即后跟下划线或一个Unicode字母。原子可以继续使用Unicode字母，数字，下划线和 &lt;code&gt;@&lt;/code&gt; 的序列。原子可能以 &lt;code&gt;!&lt;/code&gt; 还是 &lt;code&gt;?&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。有效的不带引号的原子是：： &lt;code&gt;:ok&lt;/code&gt; ， &lt;code&gt;:ISO8601&lt;/code&gt; 和 &lt;code&gt;:integer?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dac4c6b4443202cc8583016a137c1afc9253dd0" translate="yes" xml:space="preserve">
          <source>Unquotes the given expression inside a quoted expression.</source>
          <target state="translated">在一个被引用的表达式中解除对给定表达式的引用。</target>
        </trans-unit>
        <trans-unit id="51a3755b8963981e97be12c3f11d259db2190b9a" translate="yes" xml:space="preserve">
          <source>Unquotes the given list expanding its arguments.</source>
          <target state="translated">解除给定列表的引号,扩展其参数。</target>
        </trans-unit>
        <trans-unit id="08053b86ce7b78d018827349dcd3d261a98511fd" translate="yes" xml:space="preserve">
          <source>Unquoting</source>
          <target state="translated">Unquoting</target>
        </trans-unit>
        <trans-unit id="3494d6cc701ad4351f6f7781151b09d2bb134df7" translate="yes" xml:space="preserve">
          <source>Unquoting is very useful when working with macros. When writing macros, developers are able to receive code chunks and inject them inside other code chunks, which can be used to transform code or write code that generates code during compilation.</source>
          <target state="translated">在使用宏的时候,取消引号是非常有用的。在编写宏时,开发人员能够接收代码块,并将其注入到其他代码块内,可以用来转换代码或编写代码,在编译过程中生成代码。</target>
        </trans-unit>
        <trans-unit id="70957cdc250ef56f1d10dffbca7af3e59a0b3d13" translate="yes" xml:space="preserve">
          <source>Unregister entries for a given key matching a pattern.</source>
          <target state="translated">取消注册与模式匹配的给定键的条目。</target>
        </trans-unit>
        <trans-unit id="e900939218e97f5edc5de0f78b18c10f6778936f" translate="yes" xml:space="preserve">
          <source>Unregisters all entries for the given &lt;code&gt;key&lt;/code&gt; associated to the current process in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">注销与 &lt;code&gt;registry&lt;/code&gt; 的当前进程相关联的给定 &lt;code&gt;key&lt;/code&gt; 所有条目。</target>
        </trans-unit>
        <trans-unit id="872098875ed11d68f92691129750cd5f8910e31e" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">用给定的功能更新 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd67c840db661b5ff35c7988f0c313e081b6c4a7" translate="yes" xml:space="preserve">
          <source>Updates a key in a nested structure.</source>
          <target state="translated">更新嵌套结构中的键。</target>
        </trans-unit>
        <trans-unit id="913040a7783b16d3a66109d11466e1f3715b2f23" translate="yes" xml:space="preserve">
          <source>Updates a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">通过给定 &lt;code&gt;path&lt;/code&gt; 更新嵌套结构。</target>
        </trans-unit>
        <trans-unit id="a6ff992d51a35ca8eeaea3b46d7a9f9c7a1d02bf" translate="yes" xml:space="preserve">
          <source>Updates modification time (mtime) and access time (atime) of the given file.</source>
          <target state="translated">更新给定文件的修改时间(mtime)和访问时间(atime)。</target>
        </trans-unit>
        <trans-unit id="97ba8cd55c834ecfd3ee8f8cbce9327196d85da6" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;keywords&lt;/code&gt; with the given function.</source>
          <target state="translated">更新 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;keywords&lt;/code&gt; 与给定功能。</target>
        </trans-unit>
        <trans-unit id="b837a72c944278925f970add9604780f7fe0b85f" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; with the given function.</source>
          <target state="translated">更新 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; 给定功能。</target>
        </trans-unit>
        <trans-unit id="37bc2bc502a7c11dcf205d8472d9e975015a6ad3" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">用给定的功能更新 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40277704761ae2f8a4bc8d33a1fd26a3d503725b" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数更新代理状态。</target>
        </trans-unit>
        <trans-unit id="f8a3623b94bb3839740129bc6596f649a9a9ecf0" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given function.</source>
          <target state="translated">通过给定的函数更新代理状态。</target>
        </trans-unit>
        <trans-unit id="416682303e7f5a28e1fe42385084449506b18f32" translate="yes" xml:space="preserve">
          <source>Updates the value for &lt;code&gt;key&lt;/code&gt; for the current process in the unique &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">更新的价值 &lt;code&gt;key&lt;/code&gt; 在独特的当前进程 &lt;code&gt;registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">用途将是:</target>
        </trans-unit>
        <trans-unit id="ad0ecf3efc2fafd77bbedf42c03404f90e27c42f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#defines?/3&quot;&gt;&lt;code&gt;defines?/3&lt;/code&gt;&lt;/a&gt; to assert for a specific type.</source>
          <target state="translated">使用&lt;a href=&quot;#defines?/3&quot;&gt; &lt;code&gt;defines?/3&lt;/code&gt; &lt;/a&gt;声明特定类型。</target>
        </trans-unit>
        <trans-unit id="787801e07ca737f4cd69bf93e70004cb3e751db3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#query_decoder/1&quot;&gt;&lt;code&gt;query_decoder/1&lt;/code&gt;&lt;/a&gt; if you want to iterate over each value manually.</source>
          <target state="translated">如果要手动遍历每个值，请使用&lt;a href=&quot;#query_decoder/1&quot;&gt; &lt;code&gt;query_decoder/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3797a8276a8bc54fb5a97169a1b9a858a6ddd368" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#write/2&quot;&gt;&lt;code&gt;write/2&lt;/code&gt;&lt;/a&gt; for devices with encoding.</source>
          <target state="translated">将&lt;a href=&quot;#write/2&quot;&gt; &lt;code&gt;write/2&lt;/code&gt; &lt;/a&gt;用于具有编码的设备。</target>
        </trans-unit>
        <trans-unit id="1b36f40ce27bbfefdab4f321df212af5d062ba4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; to traverse over the arguments (v1.0)</source>
          <target state="translated">使用&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;遍历参数（v1.0）</target>
        </trans-unit>
        <trans-unit id="e5cf1dfe97340fea8a70dd96826ef4351d80ad46" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt;&lt;code&gt;:binary.replace/4&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">使用&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt; &lt;code&gt;:binary.replace/4&lt;/code&gt; &lt;/a&gt;（v1.0）</target>
        </trans-unit>
        <trans-unit id="b4a9dd9a756931a4a385ac5c2dd7ee781d1b07f9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#pad_leading/3&quot;&gt;&lt;code&gt;String.pad_leading/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#pad_trailing/3&quot;&gt;&lt;code&gt;String.pad_trailing/3&lt;/code&gt;&lt;/a&gt; with a binary padding (v1.3)</source>
          <target state="translated">结合使用&lt;a href=&quot;string#pad_leading/3&quot;&gt; &lt;code&gt;String.pad_leading/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string#pad_trailing/3&quot;&gt; &lt;code&gt;String.pad_trailing/3&lt;/code&gt; &lt;/a&gt;和二进制填充（v1.3）</target>
        </trans-unit>
        <trans-unit id="20040427069949a8d4027129b310722c2c30b8ff" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#trim_leading/2&quot;&gt;&lt;code&gt;String.trim_leading/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#trim_trailing/2&quot;&gt;&lt;code&gt;String.trim_trailing/2&lt;/code&gt;&lt;/a&gt; with a binary as second argument (v1.3)</source>
          <target state="translated">将&lt;a href=&quot;string#trim_leading/2&quot;&gt; &lt;code&gt;String.trim_leading/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string#trim_trailing/2&quot;&gt; &lt;code&gt;String.trim_trailing/2&lt;/code&gt; &lt;/a&gt;与二进制文件一起用作第二个参数（v1.3）</target>
        </trans-unit>
        <trans-unit id="c58ca1ae3a377183620422c237e986e4c5bfdee5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;%&lt;/code&gt; (&lt;code&gt;&amp;lt;%=&lt;/code&gt; is allowed only on start expressions) (v1.0)</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;%&lt;/code&gt; （仅在开始表达式上允许 &lt;code&gt;&amp;lt;%=&lt;/code&gt; ）（v1.0）</target>
        </trans-unit>
        <trans-unit id="ee94c06bb86bdaca513c3a62f49490454be42e9c" translate="yes" xml:space="preserve">
          <source>Use a map (v1.0)</source>
          <target state="translated">使用地图 (v1.0)</target>
        </trans-unit>
        <trans-unit id="4d74b43fbed5164c7d0cf7a52539703c48335b7c" translate="yes" xml:space="preserve">
          <source>Use an expression or explicitly return &lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">使用表达式或显式返回 &lt;code&gt;nil&lt;/code&gt; （v1.0）</target>
        </trans-unit>
        <trans-unit id="695acd02888c70a7bd24e240078a062e8cefd82c" translate="yes" xml:space="preserve">
          <source>Use cases for IO data</source>
          <target state="translated">IO数据的使用案例</target>
        </trans-unit>
        <trans-unit id="17ecf402c8b50a984590bda594e338082a23c4c0" translate="yes" xml:space="preserve">
          <source>Use direct message matching (v1.0)</source>
          <target state="translated">使用直接信息匹配(v1.0)</target>
        </trans-unit>
        <trans-unit id="7d7bc258dd57ccdb77c4d94fa239755b4e4dbe79" translate="yes" xml:space="preserve">
          <source>Use parentheses (v1.0)</source>
          <target state="translated">使用括号(v1.0)</target>
        </trans-unit>
        <trans-unit id="d1a132274b1eb6b7319062ced70e808cf7c404ca" translate="yes" xml:space="preserve">
          <source>Use processes only to model runtime properties, never for code organization. And even when you think something could be done in parallel with processes, often it is best to let the callers of your library decide how to parallelize, rather than impose a certain execution flow in users of your code.</source>
          <target state="translated">只用进程来模拟运行时的属性,千万不要用来组织代码。而且即使你认为有些事情可以用进程来并行完成,很多时候最好让你的库的调用者来决定如何并行,而不是把某种执行流程强加给你代码的使用者。</target>
        </trans-unit>
        <trans-unit id="72ac53e8279e1fbc4a4e474748dc78b85a97986e" translate="yes" xml:space="preserve">
          <source>Use public functions (v1.0)</source>
          <target state="translated">使用公共函数(v1.0)</target>
        </trans-unit>
        <trans-unit id="e7e9e97b63195c13fec074e748d6a1b624c2147f" translate="yes" xml:space="preserve">
          <source>Use single-letter aliases (v1.0)</source>
          <target state="translated">使用单字母别名(v1.0)</target>
        </trans-unit>
        <trans-unit id="5d5567686d3e6ae0d4956f84da54e7d67f04b834" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:since&lt;/code&gt; key in the documentation metadata to annotate whenever new functions or modules are added to your API.</source>
          <target state="translated">每当将新功能或模块添加到API时，请使用文档元数据中的 &lt;code&gt;:since&lt;/code&gt; 键进行注释。</target>
        </trans-unit>
        <trans-unit id="2fb9026bf683fe97be9805f8d4ee8da3a7030195" translate="yes" xml:space="preserve">
          <source>Use the pin operator &lt;code&gt;^&lt;/code&gt; when you want to pattern match against an existing variable&amp;rsquo;s value rather than rebinding the variable:</source>
          <target state="translated">当您想对现有变量的值进行模式匹配而不是重新绑定变量时，请使用pin运算符 &lt;code&gt;^&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d62760f6801ea132b87f52fc490f15e5c30ebb87" translate="yes" xml:space="preserve">
          <source>Use this only for debugging information.</source>
          <target state="translated">仅用于调试信息。</target>
        </trans-unit>
        <trans-unit id="654833a705a392b91db5fb486d867850f6f6d4da" translate="yes" xml:space="preserve">
          <source>Used by helpers and it has a default maximum cap of 80 chars.</source>
          <target state="translated">由助手使用,它的默认上限为80个字符。</target>
        </trans-unit>
        <trans-unit id="6f19f4b56cd4eb0479f604b05000a49967ca0779" translate="yes" xml:space="preserve">
          <source>Used by types and bitstrings to specify types.</source>
          <target state="translated">被类型和位串用来指定类型。</target>
        </trans-unit>
        <trans-unit id="27f134f77aed07ba771f04e70c26fcde14c293be" translate="yes" xml:space="preserve">
          <source>Used to combine matching clauses.</source>
          <target state="translated">用来组合匹配的分句。</target>
        </trans-unit>
        <trans-unit id="d3e14268db3616058b87c0710752c8757db571c3" translate="yes" xml:space="preserve">
          <source>Useful for adding side effects (like printing) to a stream.</source>
          <target state="translated">对在流中添加副作用(如打印)很有用。</target>
        </trans-unit>
        <trans-unit id="b4a25e416b54812cf786abc2853d57e8a5a5d837" translate="yes" xml:space="preserve">
          <source>Useful in umbrella applications to execute a command on each child app:</source>
          <target state="translated">在伞形应用程序中很有用,可以在每个子应用程序上执行一条命令。</target>
        </trans-unit>
        <trans-unit id="ccd0085c486cb23718479523b31aac167b10d224" translate="yes" xml:space="preserve">
          <source>Useful when dependencies need to be reloaded due to change of global state.</source>
          <target state="translated">当由于全局状态的改变而需要重新加载依赖关系时非常有用。</target>
        </trans-unit>
        <trans-unit id="52dd4a7101ad34727c991e5c7418caedb4c5ab1e" translate="yes" xml:space="preserve">
          <source>User home directory, exception on error.</source>
          <target state="translated">用户主目录,出错时异常。</target>
        </trans-unit>
        <trans-unit id="3b425e136b2a26688fb41476a54559087648780b" translate="yes" xml:space="preserve">
          <source>User home directory.</source>
          <target state="translated">用户主目录。</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">用户定义类型</target>
        </trans-unit>
        <trans-unit id="9718cbc91389f0a24d01843793c6b8f5bef22b1f" translate="yes" xml:space="preserve">
          <source>Users can read the documentation for public Mix tasks by running &lt;code&gt;mix help my_task&lt;/code&gt;. The documentation that will be shown is the &lt;code&gt;@moduledoc&lt;/code&gt; of the task's module.</source>
          <target state="translated">用户可以通过运行 &lt;code&gt;mix help my_task&lt;/code&gt; 阅读公共Mix任务的文档。将显示的文档是任务模块的 &lt;code&gt;@moduledoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30bca3fe935d22a9fb82d1874f535be3bcc5d54b" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数，这将在后面的部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="7504c890d2e677e3b9b91ddd28b0a2c13353b513" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数。如果键是一个函数，它将按照&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 中的&lt;/a&gt;指定进行调用。</target>
        </trans-unit>
        <trans-unit id="cb5ab22fadbe3ddb46c966e8ef4864a52c44d738" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; protocol to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;协议根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数。如果键是一个函数，它将按照&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 中的&lt;/a&gt;指定进行调用。</target>
        </trans-unit>
        <trans-unit id="ef97952dc7c1cf9b1acf2d4929c04b260422cc0c" translate="yes" xml:space="preserve">
          <source>Uses the given module in the current context.</source>
          <target state="translated">在当前上下文中使用给定的模块。</target>
        </trans-unit>
        <trans-unit id="90cad9ec714dc9a102448582d410c612025f4e51" translate="yes" xml:space="preserve">
          <source>Uses the merge sort algorithm.</source>
          <target state="translated">使用合并排序算法。</target>
        </trans-unit>
        <trans-unit id="3c2765b9061b4136a3838afbdd48ae286d5f9dd1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@impl&lt;/code&gt;, the example above can be rewritten as:</source>
          <target state="translated">使用 &lt;code&gt;@impl&lt;/code&gt; ，以上示例可以重写为：</target>
        </trans-unit>
        <trans-unit id="505fcdfd3ea4cc7dcdc28d67a1ee3972f771caf7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try/catch&lt;/code&gt; is already uncommon and using it to catch exits is even rarer.</source>
          <target state="translated">使用 &lt;code&gt;try/catch&lt;/code&gt; 已经很不常见了，使用它捕获出口更为罕见。</target>
        </trans-unit>
        <trans-unit id="1030762105f9522e1c1851b1267235d4d19bc022" translate="yes" xml:space="preserve">
          <source>Using Erlang's term ordering means that comparisons are structural and not semantic. For example, when comparing dates:</source>
          <target state="translated">使用Erlang的术语排序意味着比较是结构性的而不是语义性的。例如,在比较日期时。</target>
        </trans-unit>
        <trans-unit id="fe7cefcf1eabae7a686eac5a7a7290642e6eed61" translate="yes" xml:space="preserve">
          <source>Using Git repositories for internal dependencies is somewhat discouraged in Elixir. Remember that the runtime and the Elixir ecosystem already provide the concept of applications. As such, we expect you to frequently break your code into applications that can be organized logically, even within a single project.</source>
          <target state="translated">在Elixir中,在内部依赖中使用Git仓库是有些不鼓励的。请记住,运行时和Elixir生态系统已经提供了应用程序的概念。因此,我们希望你能经常将你的代码分解成可以按逻辑组织的应用程序,即使在一个项目中也是如此。</target>
        </trans-unit>
        <trans-unit id="a2b78ec8cd8152714b3f5e9e262cc3fe32d34dd9" translate="yes" xml:space="preserve">
          <source>Using Processes and message passing</source>
          <target state="translated">使用进程和消息传递</target>
        </trans-unit>
        <trans-unit id="f3be89c545324883fd2361bb0486819210d9bb4f" translate="yes" xml:space="preserve">
          <source>Using a custom &lt;code&gt;sorter&lt;/code&gt; to override the order:</source>
          <target state="translated">使用自定义 &lt;code&gt;sorter&lt;/code&gt; 覆盖顺序：</target>
        </trans-unit>
        <trans-unit id="bb2948a181ade01696e41af07bcf194a3237ab62" translate="yes" xml:space="preserve">
          <source>Using as a PubSub</source>
          <target state="translated">作为PubSub使用</target>
        </trans-unit>
        <trans-unit id="12a48c5cdb39b5b708956e82103eb5aa1b37d5cf" translate="yes" xml:space="preserve">
          <source>Using as a dispatcher</source>
          <target state="translated">作为调度员使用</target>
        </trans-unit>
        <trans-unit id="f68543ebad20919d4a9ab1b9e02fe49a33c14a13" translate="yes" xml:space="preserve">
          <source>Using epochs</source>
          <target state="translated">使用纪元</target>
        </trans-unit>
        <trans-unit id="22e72db3d5ad4dc09f439de5ffe89609c4f63667" translate="yes" xml:space="preserve">
          <source>Using functions from the &lt;code&gt;Path&lt;/code&gt; module as opposed to directly manipulating strings is preferred since the &lt;code&gt;Path&lt;/code&gt; module takes care of different operating systems transparently. Finally, keep in mind that Elixir will automatically convert slashes (&lt;code&gt;/&lt;/code&gt;) into backslashes (&lt;code&gt;\&lt;/code&gt;) on Windows when performing file operations.</source>
          <target state="translated">与直接操作字符串相反，首选使用 &lt;code&gt;Path&lt;/code&gt; 模块的功能，因为 &lt;code&gt;Path&lt;/code&gt; 模块透明地处理不同的操作系统。最后，请记住，在执行文件操作时，Elixir将在Windows上自动将斜杠（ &lt;code&gt;/&lt;/code&gt; ）转换为反斜杠（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6c5b3431f7bcd8e9adc5193d5b75b53a5ae56b11" translate="yes" xml:space="preserve">
          <source>Using in &lt;code&gt;:via&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;:via&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22a7cc210dd530426a5dcf89d908dcdbccf3b54a" translate="yes" xml:space="preserve">
          <source>Using processes to maintain state and name registration are very common patterns in Elixir applications. However, most of the time, we won&amp;rsquo;t implement those patterns manually as above, but by using one of the many abstractions that ship with Elixir. For example, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;agents&lt;/a&gt;, which are simple abstractions around state:</source>
          <target state="translated">使用进程维护状态和名称注册是Elixir应用程序中非常常见的模式。但是，大多数时候，我们不会像上面那样手动实现这些模式，而是使用Elixir附带的许多抽象之一。例如，Elixir提供了&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;agent&lt;/a&gt;，它们是围绕状态的简单抽象：</target>
        </trans-unit>
        <trans-unit id="fac68a7bbcec534d20e0f270b590c693f791a8ba" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@deprecated&lt;/code&gt; attribute will also be reflected in the documentation of the given function and macro. You can choose between the &lt;code&gt;@deprecated&lt;/code&gt; attribute and the documentation metadata to provide hard-deprecations (with warnings) and soft-deprecations (without warnings):</source>
          <target state="translated">使用 &lt;code&gt;@deprecated&lt;/code&gt; 属性还将反映在给定函数和宏的文档中。您可以在 &lt;code&gt;@deprecated&lt;/code&gt; 属性和文档元数据之间进行选择，以提供硬性弃用（带警告）和软性弃用（不带警告）：</target>
        </trans-unit>
        <trans-unit id="c1fce9d06d100207ae94000178568e1e1523c465" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;unescape_map/1&lt;/code&gt; function defined above is easy:</source>
          <target state="translated">使用上面定义的 &lt;code&gt;unescape_map/1&lt;/code&gt; 函数很容易：</target>
        </trans-unit>
        <trans-unit id="40f616c11b4612a788125178e432987022e94f9d" translate="yes" xml:space="preserve">
          <source>Using the default &lt;code&gt;sorter&lt;/code&gt; of &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用默认的 &lt;code&gt;sorter&lt;/code&gt; 的&lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9b47c1568d847c096ed268fe421b3ffdf9291333" translate="yes" xml:space="preserve">
          <source>Utilities for managing code compilation, code evaluation, and code loading.</source>
          <target state="translated">用于管理代码编译、代码评估和代码加载的实用程序。</target>
        </trans-unit>
        <trans-unit id="a950d92c88a80326e3959073d9319dfdfe26f796" translate="yes" xml:space="preserve">
          <source>Utilities for working with URIs.</source>
          <target state="translated">用于处理URI的工具。</target>
        </trans-unit>
        <trans-unit id="494e5398b739ace80c2800a4e5b3cd1fb68001cf" translate="yes" xml:space="preserve">
          <source>VM</source>
          <target state="translated">VM</target>
        </trans-unit>
        <trans-unit id="8cf63ad1e33ecf97ed7ba0e44ba1e1045768875c" translate="yes" xml:space="preserve">
          <source>Valid modifiers include only lower and upper case letters. Other characters will cause a syntax error.</source>
          <target state="translated">有效的修饰符只包括小写和大写字母。其他字符将导致语法错误。</target>
        </trans-unit>
        <trans-unit id="f81794f0623c259f7f2ad2720c7f65c25241d820" translate="yes" xml:space="preserve">
          <source>Valid values for each color are in the range 0 to 5.</source>
          <target state="translated">每种颜色的有效值范围是0到5。</target>
        </trans-unit>
        <trans-unit id="9698cacbd5e3f89a0ab00436a91a3e87284fda79" translate="yes" xml:space="preserve">
          <source>Validates a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">验证&lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c51cf0a76585d587a0e8f7ab8de82724cd0922db" translate="yes" xml:space="preserve">
          <source>Validates the given expressions are valid quoted expressions.</source>
          <target state="translated">验证给定的表达式是有效的引用表达式。</target>
        </trans-unit>
        <trans-unit id="56dcc0a7cf262d906a67fb0acd7bd55c0b2e0af5" translate="yes" xml:space="preserve">
          <source>Values from duplicated keys will be kept in the final list of values.</source>
          <target state="translated">重复键的值将被保留在最终的值列表中。</target>
        </trans-unit>
        <trans-unit id="bba231ebda20b5f8062f3252ca8b56868e380a9d" translate="yes" xml:space="preserve">
          <source>Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="translated">在理解体内部的变量分配,无论是在生成器、过滤器还是在块内部,都不会反映在理解体外部。</target>
        </trans-unit>
        <trans-unit id="e5736ef93b4766ccd4b090695de9a9e5b75725fd" translate="yes" xml:space="preserve">
          <source>Variable handling</source>
          <target state="translated">变量处理</target>
        </trans-unit>
        <trans-unit id="450790da2dc2629bcbedb648bf0b42931c1a1217" translate="yes" xml:space="preserve">
          <source>Variable hygiene only works because Elixir annotates variables with their context. For example, a variable &lt;code&gt;x&lt;/code&gt; defined on line 3 of a module would be represented as:</source>
          <target state="translated">变量卫生只能起作用，因为Elixir会在变量上下文中进行注释。例如，在模块的第3行上定义的变量 &lt;code&gt;x&lt;/code&gt; 将表示为：</target>
        </trans-unit>
        <trans-unit id="30198f1a7238ad824590316fe0e8bd0df65d9b66" translate="yes" xml:space="preserve">
          <source>Variable used as function call</source>
          <target state="translated">作为函数调用的变量</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="5e4d050cb107c1747d66ebd4856ad64e856a1514" translate="yes" xml:space="preserve">
          <source>Variables are also represented using a tuple with three elements and a combination of lists and atoms, for example:</source>
          <target state="translated">变量也是用一个有三个元素的元组和列表与原子的组合来表示,例如。</target>
        </trans-unit>
        <trans-unit id="dbf2df89d142b0d3f0bb4ede8494e41c32054358" translate="yes" xml:space="preserve">
          <source>Variables are also represented using such triplets, except the last element is an atom, instead of a list:</source>
          <target state="translated">变量也是用这样的三联体来表示的,只是最后一个元素是一个原子,而不是一个列表。</target>
        </trans-unit>
        <trans-unit id="821703b844c6893a9bb58339226baa5472d41772" translate="yes" xml:space="preserve">
          <source>Variables can be used as map keys both when writing map literals as well as when matching:</source>
          <target state="translated">变量既可以作为地图键,也可以在编写地图文字以及匹配时使用。</target>
        </trans-unit>
        <trans-unit id="c802a7c60e2c76d0ce217547c00e75a3c7aacf06" translate="yes" xml:space="preserve">
          <source>Variables can be used when accessing, matching and adding map keys:</source>
          <target state="translated">在访问、匹配和添加地图键时可以使用变量。</target>
        </trans-unit>
        <trans-unit id="13c207e2d8552cc70a71488f6d006d724e518bd1" translate="yes" xml:space="preserve">
          <source>Variables in Elixir can be rebound:</source>
          <target state="translated">Elixir中的变量可以被反弹。</target>
        </trans-unit>
        <trans-unit id="03f0dd9e948cecac2dbcd988468c7f84c456ce0c" translate="yes" xml:space="preserve">
          <source>Variables in Elixir follow the identifier rule above with the following modifications:</source>
          <target state="translated">Elixir中的变量遵循上述标识符规则,但做了如下修改:</target>
        </trans-unit>
        <trans-unit id="675ba153ea525eb5962f8f25ca7142dc7421326e" translate="yes" xml:space="preserve">
          <source>Variables in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The variable may continue using a sequence of Unicode letters, numbers, and underscores. Variables may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">Elixir中的变量必须以下划线或非大写或标题大写的Unicode字母开头。变量可以继续使用Unicode字母，数字和下划线序列。变量可能以 &lt;code&gt;?&lt;/code&gt; 结尾 或 &lt;code&gt;!&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd88ce79cfea5a7985679e0418a24642e1946f2" translate="yes" xml:space="preserve">
          <source>Variables or any other type need to be explicitly tagged:</source>
          <target state="translated">变量或任何其他类型的变量都需要被明确标记。</target>
        </trans-unit>
        <trans-unit id="5c2492b6a76ece25c58f79dc3eb9560f7ab3f3bd" translate="yes" xml:space="preserve">
          <source>Variables scope</source>
          <target state="translated">变量范围</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="510f1df1a49656fd05d3a78cf65888ae976833ed" translate="yes" xml:space="preserve">
          <source>Version.InvalidRequirementError</source>
          <target state="translated">Version.InvalidRequirementError</target>
        </trans-unit>
        <trans-unit id="c1cb221f57e0ae6178e63ebeacc218b568ec650a" translate="yes" xml:space="preserve">
          <source>Version.InvalidRequirementError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Version.InvalidRequirementError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="29ca4a1db06262caa534068d5c946fa89fb538d9" translate="yes" xml:space="preserve">
          <source>Version.InvalidVersionError</source>
          <target state="translated">Version.InvalidVersionError</target>
        </trans-unit>
        <trans-unit id="eb7df9419f38796278f39dfdaee577c9920aef3b" translate="yes" xml:space="preserve">
          <source>Version.InvalidVersionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Version.InvalidVersionError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3351c5e4b78f9eb0bf0baa4b6d8dbc60869bd683" translate="yes" xml:space="preserve">
          <source>Version.Requirement</source>
          <target state="translated">Version.Requirement</target>
        </trans-unit>
        <trans-unit id="a239107ef28f6efe13d8ea83e502da9aa8c43fbb" translate="yes" xml:space="preserve">
          <source>Versions</source>
          <target state="translated">Versions</target>
        </trans-unit>
        <trans-unit id="f48ecdf1f6a9aea6cf19d13223fd11b1599d68d1" translate="yes" xml:space="preserve">
          <source>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</source>
          <target state="translated">警告:由于Erlang时间元组只包含时/分/秒,因此可能会出现精度损失。</target>
        </trans-unit>
        <trans-unit id="47b4c1e035784f01be0c69fafea30a9b2026429f" translate="yes" xml:space="preserve">
          <source>WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second.</source>
          <target state="translated">警告:由于Erlang时间元组只存储时/分/秒,可能会出现精度损失。</target>
        </trans-unit>
        <trans-unit id="060adc0fad39ca7580c07efaaf61a03475bd729c" translate="yes" xml:space="preserve">
          <source>WARNING: the ISO 8601 datetime format does not contain the time zone nor its abbreviation, which means information is lost when converting to such format.</source>
          <target state="translated">警告:ISO 8601日期时间格式不包含时区,也不包含其缩写,这意味着在转换为这种格式时,信息会丢失。</target>
        </trans-unit>
        <trans-unit id="24b52f7221e506611f983c6a66637b0bdf0a5453" translate="yes" xml:space="preserve">
          <source>Waits for a client connection on that port and accepts it</source>
          <target state="translated">在该端口上等待一个客户端连接并接受它。</target>
        </trans-unit>
        <trans-unit id="833264ed2628e3e150d1f6d81b595fc4081a194c" translate="yes" xml:space="preserve">
          <source>Warning! Don&amp;rsquo;t use ETS as a cache prematurely! Log and analyze your application performance and identify which parts are bottlenecks, so you know &lt;em&gt;whether&lt;/em&gt; you should cache, and &lt;em&gt;what&lt;/em&gt; you should cache. This chapter is merely an example of how ETS can be used, once you&amp;rsquo;ve determined the need.</source>
          <target state="translated">警告！不要过早使用ETS作为缓存！记录并分析您的应用程序性能，并确定哪些部分是瓶颈，因此您知道&lt;em&gt;是否&lt;/em&gt;应该缓存以及应该缓存&lt;em&gt;什么&lt;/em&gt;。一旦确定需要，本章仅是如何使用ETS的示例。</target>
        </trans-unit>
        <trans-unit id="07f53218e24f6029b7697c005c09fa2c9c7e2c57" translate="yes" xml:space="preserve">
          <source>Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, &lt;code&gt;string&lt;/code&gt; should not be an untrusted value, such as input received from a socket or during a web request. Consider using &lt;a href=&quot;#to_existing_atom/1&quot;&gt;&lt;code&gt;to_existing_atom/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">警告：此函数动态创建原子，并且原子不会被垃圾收集。因此， &lt;code&gt;string&lt;/code&gt; 不应是不受信任的值，例如从套接字接收到的输入或在Web请求期间输入的值。考虑改用&lt;a href=&quot;#to_existing_atom/1&quot;&gt; &lt;code&gt;to_existing_atom/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="8e1b8a938069f35be56d21075b02fc665bff349c" translate="yes" xml:space="preserve">
          <source>We access the information from the table with &lt;code&gt;KV.Registry.lookup(registry, &quot;shopping&quot;)&lt;/code&gt;</source>
          <target state="translated">我们使用 &lt;code&gt;KV.Registry.lookup(registry, &quot;shopping&quot;)&lt;/code&gt; 从表中访问信息</target>
        </trans-unit>
        <trans-unit id="4f270e7fa98f78d4a91d2d34f3dca8d0d25b2584" translate="yes" xml:space="preserve">
          <source>We also provide a tool called &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc&lt;/a&gt; which is used to generate HTML pages from the documentation.</source>
          <target state="translated">我们还提供了一个名为&lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc&lt;/a&gt;的工具，该工具用于从文档中生成HTML页面。</target>
        </trans-unit>
        <trans-unit id="84b7b3a77090dc51964f720a1d3f403f3053b57d" translate="yes" xml:space="preserve">
          <source>We are getting closer and closer to a fully working system. The supervisor automatically starts the registry. But how can we automatically start the supervisor whenever our system starts? To answer this question, let&amp;rsquo;s talk about applications.</source>
          <target state="translated">我们越来越接近一个完整的系统。主管自动启动注册表。但是，只要系统启动，我们如何自动启动主管？为了回答这个问题，让我们谈谈应用程序。</target>
        </trans-unit>
        <trans-unit id="89c4c33a1573de4b7284293b79f2c35805f70a32" translate="yes" xml:space="preserve">
          <source>We are going to explore them in detail now. Keep in mind the first three are called directives because they have &lt;strong&gt;lexical scope&lt;/strong&gt;, while &lt;code&gt;use&lt;/code&gt; is a common extension point that allows the used module to inject code.</source>
          <target state="translated">我们现在将详细探讨它们。请记住，前三个被称为指令，因为它们具有&lt;strong&gt;词法范围&lt;/strong&gt;，而 &lt;code&gt;use&lt;/code&gt; 是一个公共的扩展点，允许使用的模块插入代码。</target>
        </trans-unit>
        <trans-unit id="17fbf4999e7fd76ebfa56780dc2c430a141756ed" translate="yes" xml:space="preserve">
          <source>We are going to solve this issue by defining a new supervisor that will spawn and supervise all buckets. Opposite to the previous Supervisor we defined, the children are not known upfront, but they are rather started dynamically. For those situations, we use a &lt;code&gt;DynamicSupervisor&lt;/code&gt;. The &lt;code&gt;DynamicSupervisor&lt;/code&gt; does not expect a list of children during initialization; instead each child is started manually via &lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt;.</source>
          <target state="translated">我们将通过定义新的主管来解决此问题，该主管将生成并监督所有存储桶。与我们定义的上一个主管相反，这些子对象不是预先知道的，而是动态地启动的。对于这些情况，我们使用 &lt;code&gt;DynamicSupervisor&lt;/code&gt; 。该 &lt;code&gt;DynamicSupervisor&lt;/code&gt; 不希望在初始化过程中儿童的名单; 而是通过 &lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; 手动启动每个子级。</target>
        </trans-unit>
        <trans-unit id="66a257f39ae99fcce5fd4e7c7939a0f0b9b6d28e" translate="yes" xml:space="preserve">
          <source>We are going to start our server by calling &lt;code&gt;KVServer.accept(4040)&lt;/code&gt;, where 4040 is the port. The first step in &lt;code&gt;accept/1&lt;/code&gt; is to listen to the port until the socket becomes available and then call &lt;code&gt;loop_acceptor/1&lt;/code&gt;. &lt;code&gt;loop_acceptor/1&lt;/code&gt; is a loop accepting client connections. For each accepted connection, we call &lt;code&gt;serve/1&lt;/code&gt;.</source>
          <target state="translated">我们将通过调用 &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; 来启动服务器，其中4040是端口。 &lt;code&gt;accept/1&lt;/code&gt; 的第一步是侦听端口，直到套接字可用为止，然后调用 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 。 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 是一个接受客户端连接的循环。对于每个接受的连接，我们称为 &lt;code&gt;serve/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0a3473b399e71a57b7cad0d489cc6c99996e2a2" translate="yes" xml:space="preserve">
          <source>We are going to work on this &lt;code&gt;kv&lt;/code&gt; project, making modifications and trying out the latest changes from an &lt;code&gt;iex&lt;/code&gt; session. While you may start a new session whenever there are changes to the project source code, you can also recompile the project from within &lt;code&gt;iex&lt;/code&gt; with the &lt;code&gt;recompile&lt;/code&gt; helper, like this:</source>
          <target state="translated">我们将致力于这个 &lt;code&gt;kv&lt;/code&gt; 项目，进行修改并尝试通过 &lt;code&gt;iex&lt;/code&gt; 会话进行最新更改。尽管只要项目源代码发生更改就可以开始新的会话，但是您也可以使用 &lt;code&gt;recompile&lt;/code&gt; 助手从 &lt;code&gt;iex&lt;/code&gt; 内部重新编译项目，如下所示：</target>
        </trans-unit>
        <trans-unit id="f3a2c31c893ab68348fa6a83fab20fa8c4610d92" translate="yes" xml:space="preserve">
          <source>We are keeping a map inside the agent to store our keys and values. Getting and putting values on the map is done with the Agent API and the capture operator &lt;code&gt;&amp;amp;&lt;/code&gt;, introduced in &lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;the Getting Started guide&lt;/a&gt;.</source>
          <target state="translated">我们在代理内部保留了一个映射，以存储我们的键和值。使用&lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;入门指南中&lt;/a&gt;介绍的Agent API和捕获运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 在地图上获取和放置值。</target>
        </trans-unit>
        <trans-unit id="3de39a939a256c76bb5f3d5c434c42494e313045" translate="yes" xml:space="preserve">
          <source>We are prematurely optimizing (by adding this cache layer)</source>
          <target state="translated">我们过早地进行了优化(通过增加这个缓存层)。</target>
        </trans-unit>
        <trans-unit id="98e709b53693eead12625653dd1b14be1a41bdec" translate="yes" xml:space="preserve">
          <source>We are starting a linked Task directly from the acceptor process. But we&amp;rsquo;ve already made this mistake once. Do you remember?</source>
          <target state="translated">我们直接从接受者流程开始链接的任务。但是我们已经犯过一次这个错误。你还记得吗？</target>
        </trans-unit>
        <trans-unit id="11591e8c4eb0268773c80edde093ba6561e1358d" translate="yes" xml:space="preserve">
          <source>We are using &lt;code&gt;cast/2&lt;/code&gt; (while we should be using &lt;code&gt;call/3&lt;/code&gt;)</source>
          <target state="translated">我们正在使用 &lt;code&gt;cast/2&lt;/code&gt; （而我们应该在使用 &lt;code&gt;call/3&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b8cfde5c1ad8b2b1ce9d64a075749f12ac0d7836" translate="yes" xml:space="preserve">
          <source>We call them &quot;naive&quot; because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid.</source>
          <target state="translated">我们称它们为 &quot;天真&quot;,因为这种日期时间的表示方式没有时区。这意味着,即使日期时间是有效的,但在世界上的某些地区,它可能并不实际存在。</target>
        </trans-unit>
        <trans-unit id="a77b42bf0e1456fa472a99d5e18bf8b1349fa19d" translate="yes" xml:space="preserve">
          <source>We can access the documentation for the &lt;code&gt;~r&lt;/code&gt; sigil via &lt;code&gt;sigil_r&lt;/code&gt;:</source>
          <target state="translated">我们可以为访问文档 &lt;code&gt;~r&lt;/code&gt; 通过印记 &lt;code&gt;sigil_r&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe8009d0ba377613a52d009d93bebf653b3a471c" translate="yes" xml:space="preserve">
          <source>We can actually verify that this is the case by using &lt;code&gt;Macro.expand_once/2&lt;/code&gt;:</source>
          <target state="translated">我们实际上可以通过使用 &lt;code&gt;Macro.expand_once/2&lt;/code&gt; 验证这种情况：</target>
        </trans-unit>
        <trans-unit id="c030c328d3a9c056d8ccb727197b640a951b23a6" translate="yes" xml:space="preserve">
          <source>We can already try out our first umbrella child. We could run tests inside the &lt;code&gt;apps/kv_server&lt;/code&gt; directory, but that wouldn&amp;rsquo;t be much fun. Instead, go to the root of the umbrella project and run &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">我们已经可以尝试第一个带伞的孩子。我们可以在 &lt;code&gt;apps/kv_server&lt;/code&gt; 目录中运行测试，但这不会很有趣。相反，请转到总括项目的根目录并运行 &lt;code&gt;mix test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="76d915b11584eef7d90761bc6964ee3dcfd9b998" translate="yes" xml:space="preserve">
          <source>We can also alias multiple modules in one line:</source>
          <target state="translated">我们也可以在一行中对多个模块进行别名。</target>
        </trans-unit>
        <trans-unit id="6f04c4524f84c94effef9fb5bcec2b882f65312b" translate="yes" xml:space="preserve">
          <source>We can also get the number of bytes in a string:</source>
          <target state="translated">我们也可以得到一个字符串的字节数。</target>
        </trans-unit>
        <trans-unit id="d32d36279a4b620d4bed74fa6c37d65e7a66a517" translate="yes" xml:space="preserve">
          <source>We can also pattern match on binaries / bitstrings:</source>
          <target state="translated">我们也可以对二进制文件/位串进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="fed95b4dfe3e8f19721e9decd83125589f497411" translate="yes" xml:space="preserve">
          <source>We can also provide our own sigils by implementing functions that follow the &lt;code&gt;sigil_{identifier}&lt;/code&gt; pattern. For example, let&amp;rsquo;s implement the &lt;code&gt;~i&lt;/code&gt; sigil that returns an integer (with the optional &lt;code&gt;n&lt;/code&gt; modifier to make it negative):</source>
          <target state="translated">我们还可以通过实现遵循 &lt;code&gt;sigil_{identifier}&lt;/code&gt; 模式的功能来提供自己的信号。例如，让我们实现了 &lt;code&gt;~i&lt;/code&gt; 印记，返回一个整数（使用可选的 &lt;code&gt;n&lt;/code&gt; 修改，使其负）：</target>
        </trans-unit>
        <trans-unit id="aed02b605b4c892e4f538fc64a641140a8f4dd48" translate="yes" xml:space="preserve">
          <source>We can also use the dot for creating aliases:</source>
          <target state="translated">我们也可以使用点来创建别名。</target>
        </trans-unit>
        <trans-unit id="a26b7df9d8ed21cbfae4c86a3137802a26607e08" translate="yes" xml:space="preserve">
          <source>We can also use this syntax to access documentation. The Elixir shell defines the &lt;code&gt;h&lt;/code&gt; function, which you can use to access documentation for any function. For example, typing &lt;code&gt;h round/1&lt;/code&gt; is going to print the documentation for the &lt;code&gt;round/1&lt;/code&gt; function:</source>
          <target state="translated">我们还可以使用此语法来访问文档。Elixir外壳程序定义了 &lt;code&gt;h&lt;/code&gt; 函数，您可以使用该函数访问任何函数的文档。例如，键入 &lt;code&gt;h round/1&lt;/code&gt; 将打印 &lt;code&gt;round/1&lt;/code&gt; 函数的文档：</target>
        </trans-unit>
        <trans-unit id="206f0c2db045ed8078217482f771ce08024e2d1b" translate="yes" xml:space="preserve">
          <source>We can also use unquote to generate a remote call in a quoted expression:</source>
          <target state="translated">我们也可以使用unquote在引用的表达式中生成一个远程调用。</target>
        </trans-unit>
        <trans-unit id="f2dbdd4832136ee40e6106da4ff237e5086b3f62" translate="yes" xml:space="preserve">
          <source>We can check the truthiness of a value by using the &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt; function twice.</source>
          <target state="translated">我们可以通过两次使用&lt;a href=&quot;#!/1&quot;&gt; &lt;code&gt;!/1&lt;/code&gt; &lt;/a&gt;函数来检查值的真实性。</target>
        </trans-unit>
        <trans-unit id="34ceb39491adfef2435637a7c059b77e2fcd5969" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;Parser&lt;/code&gt; behaviour:</source>
          <target state="translated">我们可以创建一个 &lt;code&gt;Parser&lt;/code&gt; 行为：</target>
        </trans-unit>
        <trans-unit id="0dd1c8c6a5914f109c4f354f46226b3d028c2e02" translate="yes" xml:space="preserve">
          <source>We can define any function and macro we want, including ones that override the built-in definitions provided by Elixir. The only exceptions are Elixir special forms which are not implemented in Elixir and therefore cannot be overridden, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary&quot;&gt;the full list of special forms is available in &lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们可以定义所需的任何函数和宏，包括覆盖Elixir提供的内置定义的函数和宏。唯一的例外是Elixir特殊格式，这些特殊格式未在Elixir中实现，因此不能被覆盖，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary&quot;&gt;特殊格式的完整列表在 &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; 中&lt;/a&gt;可用。</target>
        </trans-unit>
        <trans-unit id="093b9c9eb6d6b0fc66fe2a2daaa50a1cbe7322b6" translate="yes" xml:space="preserve">
          <source>We can do this by passing the &lt;code&gt;restart: :temporary&lt;/code&gt; option to &lt;code&gt;use Agent&lt;/code&gt; in &lt;code&gt;KV.Bucket&lt;/code&gt;:</source>
          <target state="translated">我们可以通过传递 &lt;code&gt;restart: :temporary&lt;/code&gt; 选项以在 &lt;code&gt;KV.Bucket&lt;/code&gt; 中 &lt;code&gt;use Agent&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="5948b90ba1129ec3a47a102cda2b8444a180dc8b" translate="yes" xml:space="preserve">
          <source>We can find the generated &lt;code&gt;.app&lt;/code&gt; file at &lt;code&gt;_build/dev/lib/kv/ebin/kv.app&lt;/code&gt;. Let&amp;rsquo;s have a look at its contents:</source>
          <target state="translated">我们可以在 &lt;code&gt;_build/dev/lib/kv/ebin/kv.app&lt;/code&gt; 中找到生成的 &lt;code&gt;.app&lt;/code&gt; 文件。让我们看一下它的内容：</target>
        </trans-unit>
        <trans-unit id="5bd02c81ba6eb5d62769c970196b9d789da3e8cf" translate="yes" xml:space="preserve">
          <source>We can invoke it as:</source>
          <target state="translated">我们可以将其调用为:</target>
        </trans-unit>
        <trans-unit id="9fa7890904dbff07dec603c4fd23ae8212249d12" translate="yes" xml:space="preserve">
          <source>We can invoke this macro as:</source>
          <target state="translated">我们可以调用这个宏作为。</target>
        </trans-unit>
        <trans-unit id="ec221b458cd8f8df534326a6eca8a80f9017bf12" translate="yes" xml:space="preserve">
          <source>We can now create &lt;code&gt;User&lt;/code&gt; structs by using a syntax similar to the one used to create maps (if you have defined the struct in a separate file, you can compile the file inside IEx before proceeding by running &lt;code&gt;c &quot;file.exs&quot;&lt;/code&gt;; be aware you may get an error saying &lt;code&gt;the struct was not yet defined&lt;/code&gt; if you try the below example in a file directly due to when definitions are resolved):</source>
          <target state="translated">现在，我们可以使用类似于创建映射的语法来创建 &lt;code&gt;User&lt;/code&gt; 结构（如果已在单独的文件中定义了结构，则可以在运行 &lt;code&gt;c &quot;file.exs&quot;&lt;/code&gt; 之前在IEx内编译该文件；请注意如果您直接在文件中尝试以下示例（由于解析定义的时间），则可能会收到一条错误消息，指出 &lt;code&gt;the struct was not yet defined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb349bfbe30f9cb04e70d0822597f66eda9e1501" translate="yes" xml:space="preserve">
          <source>We can now start a supervisor that will start and supervise our stack process. The first step is to define a list of &lt;strong&gt;child specifications&lt;/strong&gt; that control how each child behaves. Each child specification is a map, as shown below:</source>
          <target state="translated">现在，我们可以启动一个主管，该主管将启动并监督我们的堆栈过程。第一步是定义一个&lt;strong&gt;子规范&lt;/strong&gt;列表，以控制每个子&lt;strong&gt;规范的&lt;/strong&gt;行为。每个子规范都是一个映射，如下所示：</target>
        </trans-unit>
        <trans-unit id="2fff4b558e6b43bd26688c108539ad96241d60df" translate="yes" xml:space="preserve">
          <source>We can partially apply a remote function with placeholder:</source>
          <target state="translated">我们可以部分应用远程功能与占位符。</target>
        </trans-unit>
        <trans-unit id="e1dae55a2ef436168dca26e3a357bb8de790b475" translate="yes" xml:space="preserve">
          <source>We can pass an option to Mix to ask it to not start our application. Let&amp;rsquo;s give it a try by running &lt;code&gt;iex -S mix run --no-start&lt;/code&gt;:</source>
          <target state="translated">我们可以将选项传递给Mix，以要求它不启动我们的应用程序。让我们通过运行 &lt;code&gt;iex -S mix run --no-start&lt;/code&gt; 来尝试一下：</target>
        </trans-unit>
        <trans-unit id="77f7b587fa11d773ef7ba586a16daa37340be0d6" translate="yes" xml:space="preserve">
          <source>We can pattern match on lists:</source>
          <target state="translated">我们可以在列表上进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="f0a478e4d3f780a89dec1acd670b16ecab0fe6d8" translate="yes" xml:space="preserve">
          <source>We can retrieve the AST for any Elixir expression by calling &lt;code&gt;quote&lt;/code&gt;:</source>
          <target state="translated">我们可以通过调用 &lt;code&gt;quote&lt;/code&gt; 来检索任何Elixir表达式的AST ：</target>
        </trans-unit>
        <trans-unit id="ea6ae36afce917a366f60cadc38a2b7778dc8273" translate="yes" xml:space="preserve">
          <source>We can retrieve the PID of the current process by calling &lt;code&gt;self/0&lt;/code&gt;:</source>
          <target state="translated">我们可以通过调用 &lt;code&gt;self/0&lt;/code&gt; 来检索当前进程的PID ：</target>
        </trans-unit>
        <trans-unit id="dda1d7d70c978bad3827eb4aef2e0f741f24b16d" translate="yes" xml:space="preserve">
          <source>We can see that &lt;code&gt;x&lt;/code&gt; did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.</source>
          <target state="translated">我们可以看到 &lt;code&gt;x&lt;/code&gt; 并没有泄漏到用户上下文中。发生这种情况是因为Elixir宏很卫生，我们将在下一节中详细讨论这个主题。</target>
        </trans-unit>
        <trans-unit id="9d7f07c4321edb95b40558ce4ce3f34ee1157e2e" translate="yes" xml:space="preserve">
          <source>We can send and receive messages from the pid returned by &lt;code&gt;Node.spawn_link/2&lt;/code&gt; as usual. Let&amp;rsquo;s try a quick ping-pong example:</source>
          <target state="translated">我们可以照常从 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 返回的pid发送和接收消息。让我们尝试一个快速的乒乓球示例：</target>
        </trans-unit>
        <trans-unit id="be65a398bab9afdd4c9279424e0b66beb2383362" translate="yes" xml:space="preserve">
          <source>We can send messages to a process with &lt;code&gt;send/2&lt;/code&gt; and receive them with &lt;code&gt;receive/1&lt;/code&gt;:</source>
          <target state="translated">我们可以使用 &lt;code&gt;send/2&lt;/code&gt; 将消息发送到进程，并使用 &lt;code&gt;receive/1&lt;/code&gt; 接收消息：</target>
        </trans-unit>
        <trans-unit id="89a292fe34f0517fb76add473e5f90e9445c0866" translate="yes" xml:space="preserve">
          <source>We can solve this by explicitly tagging it as &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">我们可以通过将其显式标记为 &lt;code&gt;binary&lt;/code&gt; 来解决此问题：</target>
        </trans-unit>
        <trans-unit id="a43133c591cffe7eae441ae9df0f625b8acc625f" translate="yes" xml:space="preserve">
          <source>We can stop our &lt;code&gt;:kv&lt;/code&gt; application as well as the &lt;code&gt;:logger&lt;/code&gt; application, which is started by default with Elixir:</source>
          <target state="translated">我们可以停止 &lt;code&gt;:kv&lt;/code&gt; 应用程序以及 &lt;code&gt;:logger&lt;/code&gt; 应用程序，该应用程序默认情况下由Elixir启动：</target>
        </trans-unit>
        <trans-unit id="94ea1a9c3bcbf4640e6d211c9cd39b949fc95272" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;:label&lt;/code&gt; option to decorate the output:</source>
          <target state="translated">我们可以使用 &lt;code&gt;:label&lt;/code&gt; 选项来装饰输出：</target>
        </trans-unit>
        <trans-unit id="5eb1cad49fe0b7cf31002d0cb30f5452a668d30e" translate="yes" xml:space="preserve">
          <source>We changed the callback from &lt;code&gt;handle_cast/2&lt;/code&gt; to &lt;code&gt;handle_call/3&lt;/code&gt; and changed it to reply with the pid of the created bucket. Generally speaking, Elixir developers prefer to use &lt;code&gt;call/2&lt;/code&gt; instead of &lt;code&gt;cast/2&lt;/code&gt; as it also provides back-pressure - you block until you get a reply. Using &lt;code&gt;cast/2&lt;/code&gt; when not necessary can also be considered a premature optimization.</source>
          <target state="translated">我们将回调从 &lt;code&gt;handle_cast/2&lt;/code&gt; 更改为 &lt;code&gt;handle_call/3&lt;/code&gt; ，并将其更改为使用创建的存储桶的pid进行回复。一般来说，Elixir开发人员更喜欢使用 &lt;code&gt;call/2&lt;/code&gt; 而不是 &lt;code&gt;cast/2&lt;/code&gt; ，因为它还提供背压-您阻塞直到得到答复。不必要时使用 &lt;code&gt;cast/2&lt;/code&gt; 也可以认为是过早的优化。</target>
        </trans-unit>
        <trans-unit id="e425300cff93bee7fcafcf5a279ba603882b1684" translate="yes" xml:space="preserve">
          <source>We could fix this by defining our own module that calls &lt;code&gt;use Task, restart: :permanent&lt;/code&gt; and invokes a &lt;code&gt;start_link&lt;/code&gt; function responsible for restarting the task, quite similar to &lt;code&gt;Agent&lt;/code&gt; and &lt;code&gt;GenServer&lt;/code&gt;. However, let&amp;rsquo;s take a different approach here. When integrating with someone else&amp;rsquo;s library, we won&amp;rsquo;t be able to change how their agents, tasks, and servers are defined. Instead, we need to be able to customize their child specification dynamically. This can be done by using &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;, a function that we happen to know from previous chapters. Let&amp;rsquo;s rewrite &lt;code&gt;start/2&lt;/code&gt; in &lt;code&gt;KVServer.Application&lt;/code&gt; once more:</source>
          <target state="translated">我们可以通过定义自己的模块来解决此问题，该模块 &lt;code&gt;use Task, restart: :permanent&lt;/code&gt; 调用，restart：：permanent并调用一个 &lt;code&gt;start_link&lt;/code&gt; 函数，该函数负责重启任务，这与 &lt;code&gt;Agent&lt;/code&gt; 和 &lt;code&gt;GenServer&lt;/code&gt; 非常相似。但是，让我们在这里采取另一种方法。与其他人的库集成时，我们将无法更改其代理，任务和服务器的定义方式。相反，我们需要能够动态自定义其子规范。这可以通过使用 &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 来完成，这是我们在前几章中偶然发现的函数。让我们再次在 &lt;code&gt;KVServer.Application&lt;/code&gt; 中重写 &lt;code&gt;start/2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a3910a0d1de4ef411ffef6142801a0b82108c33c" translate="yes" xml:space="preserve">
          <source>We could have a server running on the other node and send requests to that node via the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; API. For example, you can call a server on a remote node by using &lt;code&gt;GenServer.call({name, node}, arg)&lt;/code&gt; or passing the remote process PID as the first argument</source>
          <target state="translated">我们可以在另一个节点上运行服务器，然后通过&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; API 将请求发送到该节点。例如，可以通过使用 &lt;code&gt;GenServer.call({name, node}, arg)&lt;/code&gt; 或将远程进程PID作为第一个参数来调用远程节点上的服务器。</target>
        </trans-unit>
        <trans-unit id="534697b7ae5a1dc93cf9129d4470c64b61320dc1" translate="yes" xml:space="preserve">
          <source>We could use &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;tasks&lt;/a&gt;, which we have learned about in &lt;a href=&quot;task-and-gen-tcp&quot;&gt;a previous chapter&lt;/a&gt;, as they can be spawned on both local and remote nodes</source>
          <target state="translated">我们可以使用在&lt;a href=&quot;task-and-gen-tcp&quot;&gt;上一章&lt;/a&gt;中学到的&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;任务&lt;/a&gt;，因为它们可以在本地和远程节点上生成</target>
        </trans-unit>
        <trans-unit id="e4f1434d1a6494bb12e865205684d1adb1d41c51" translate="yes" xml:space="preserve">
          <source>We could use Erlang&amp;rsquo;s &lt;a href=&quot;http://www.erlang.org/doc/man/rpc.html&quot;&gt;:rpc&lt;/a&gt; module to execute functions on a remote node. Inside the &lt;code&gt;bar@computer-name&lt;/code&gt; shell above, you can call &lt;code&gt;:rpc.call(:&quot;foo@computer-name&quot;, Hello, :world, [])&lt;/code&gt; and it will print &amp;ldquo;hello world&amp;rdquo;</source>
          <target state="translated">我们可以使用Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/rpc.html&quot;&gt;：rpc&lt;/a&gt;模块在远程节点上执行功能。在上面的 &lt;code&gt;bar@computer-name&lt;/code&gt; 外壳程序内，您可以调用 &lt;code&gt;:rpc.call(:&quot;foo@computer-name&quot;, Hello, :world, [])&lt;/code&gt; ，它会显示&amp;ldquo; hello world&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4c0e6a10a3b1333bef19dabada44221a30ffa0b9" translate="yes" xml:space="preserve">
          <source>We covered processes in the Getting Started guide.</source>
          <target state="translated">我们在入门指南中介绍了流程。</target>
        </trans-unit>
        <trans-unit id="c9f9a5502e96501c802a665d9324eab87d03f3ad" translate="yes" xml:space="preserve">
          <source>We define them in this module. Some of these forms are lexical (like &lt;a href=&quot;#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;, etc.). The macros &lt;a href=&quot;#%257B%257D/1&quot;&gt;&lt;code&gt;{}/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; are also special forms used to define tuple and binary data structures respectively.</source>
          <target state="translated">我们在此模块中定义它们。这些形式中有些是词汇形式的（例如&lt;a href=&quot;#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt;等）。宏&lt;a href=&quot;#%257B%257D/1&quot;&gt; &lt;code&gt;{}/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt;也是分别用于定义元组和二进制数据结构的特殊形式。</target>
        </trans-unit>
        <trans-unit id="53a13c26ec46afac43b4d43287c04fe12385a3eb" translate="yes" xml:space="preserve">
          <source>We defined &lt;code&gt;print_multiple_times/2&lt;/code&gt; so that, no matter what number is passed as the second argument, it either triggers our first definition (known as a &lt;em&gt;base case&lt;/em&gt;) or it triggers our second definition, which will ensure that we get exactly one step closer to our base case.</source>
          <target state="translated">我们定义了 &lt;code&gt;print_multiple_times/2&lt;/code&gt; ,以便无论将什么数字作为第二个参数传递，它都会触发我们的第一个定义（称为&lt;em&gt;基本情况&lt;/em&gt;）或触发我们的第二个定义，这将确保我们距离目标仅一步之遥我们的基本情况。</target>
        </trans-unit>
        <trans-unit id="cd0565f2965aa875bf029148dfb2639986d33cde" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t implement the &lt;code&gt;Size&lt;/code&gt; protocol for lists as there is no &amp;ldquo;size&amp;rdquo; information pre-computed for lists, and the length of a list has to be computed (with &lt;code&gt;length/1&lt;/code&gt;).</source>
          <target state="translated">我们没有为列表实现 &lt;code&gt;Size&lt;/code&gt; 协议，因为没有为列表预先计算&amp;ldquo;大小&amp;rdquo;信息，并且必须计算列表的长度（使用 &lt;code&gt;length/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96557d39ec2ff50c51270cf7b396c7169836eae9" translate="yes" xml:space="preserve">
          <source>We explore the Observer in the context of an actual project &lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;in the Dynamic Supervisor chapter of the Mix &amp;amp; OTP guide&lt;/a&gt;.</source>
          <target state="translated">我们&lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;在Mix＆OTP指南的Dynamic Supervisor章节中&lt;/a&gt;以实际项目为背景探索Observer 。</target>
        </trans-unit>
        <trans-unit id="48a05447e0ce5a3dabef9e3188cfc11688196b7e" translate="yes" xml:space="preserve">
          <source>We fixed the issue for the registry by using a simple one for one supervisor. We are going to use the same tactic here, except that this pattern is so common with tasks that &lt;code&gt;Task&lt;/code&gt; already comes with a solution: a simple one for one supervisor that starts temporary tasks as part of our supervision tree.</source>
          <target state="translated">我们通过一个简单的一对一主管解决了注册表的问题。我们将在此处使用相同的策略，除了这种模式在任务中如此常见以至于 &lt;code&gt;Task&lt;/code&gt; 已经提供了一种解决方案：一个简单的针对一位主管的方案，作为我们的监督树的一部分启动临时任务。</target>
        </trans-unit>
        <trans-unit id="9caab9660f6fe9cab22fc23d72b11c01e22a7a4f" translate="yes" xml:space="preserve">
          <source>We get a list that follows the pipeline directly: first the &lt;code&gt;100&lt;/code&gt;, then the &lt;code&gt;div(5)&lt;/code&gt; (more precisely, its AST), then &lt;code&gt;div(2)&lt;/code&gt;. The &lt;code&gt;0&lt;/code&gt; as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; means that the previous element (&lt;code&gt;100&lt;/code&gt;) will be inserted as the 0th (first) argument to the &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; function, so that the AST for that function will become &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; (&lt;code&gt;div(100, 5)&lt;/code&gt;).</source>
          <target state="translated">我们得到一个直接跟随管道的列表：首先是 &lt;code&gt;100&lt;/code&gt; ，然后是 &lt;code&gt;div(5)&lt;/code&gt; （更确切地说是其AST），然后是 &lt;code&gt;div(2)&lt;/code&gt; 。在 &lt;code&gt;0&lt;/code&gt; 作为元组的第二个元素是在当前的功能的应用程序内的流水线中的前一个元素的位置： &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; 意味着先前的元件（ &lt;code&gt;100&lt;/code&gt; ）将作为&lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt;函数的第0（第一个）参数插入，因此该函数的AST将变为 &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; （ &lt;code&gt;div(100, 5)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0e9b09948eb0624f11716a9cef62d3abdf92490" translate="yes" xml:space="preserve">
          <source>We go into more details about aliases in the &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt; special form documentation.</source>
          <target state="translated">我们将在&lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt;特殊格式文档中详细介绍有关别名的信息。</target>
        </trans-unit>
        <trans-unit id="26ed9d733aecb476410b063737c91f243a2791ec" translate="yes" xml:space="preserve">
          <source>We had originally sketched this chapter to come much earlier in the getting started guide. However, we noticed the IO system provides a great opportunity to shed some light on some philosophies and curiosities of Elixir and the</source>
          <target state="translated">我们原本打算在入门指南中更早地勾画出这一章的内容。然而,我们注意到IO系统提供了一个很好的机会来阐明Elixir的一些哲学和奇特之处,并在此基础上提出了一些建议。</target>
        </trans-unit>
        <trans-unit id="abb6a95977675490c38034de2d568b04ea2c84a8" translate="yes" xml:space="preserve">
          <source>We have a &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;Learning&lt;/a&gt; section that suggests books, screencasts, and other resources for learning Elixir and exploring the ecosystem. There are also plenty of Elixir resources out there, like conference talks, open source projects, and other learning material produced by the community.</source>
          <target state="translated">我们有一个&amp;ldquo; &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;学习&amp;rdquo;&lt;/a&gt;部分，为学习Elixir和探索生态系统提供建议书，截屏视频和其他资源。还有大量的Elixir资源，例如会议演讲，开源项目以及社区制作的其他学习材料。</target>
        </trans-unit>
        <trans-unit id="b4c0db93e8af0bc00e24de6f1cf4f54858eab97d" translate="yes" xml:space="preserve">
          <source>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</source>
          <target state="translated">我们有一个关键字的用户列表,其中每个值都是一个包含姓名、年龄和每个用户喜欢的编程语言列表的地图。如果我们想访问john的年龄,我们可以写。</target>
        </trans-unit>
        <trans-unit id="ceb63ee60b61c142c76846224ff6bca160c2c492" translate="yes" xml:space="preserve">
          <source>We have added a new &lt;code&gt;:env&lt;/code&gt; key to the application. It returns the application default environment, which has an entry of key &lt;code&gt;:routing_table&lt;/code&gt; and value of an empty list. It makes sense for the application environment to ship with an empty table, as the specific routing table depends on the testing/deployment structure.</source>
          <target state="translated">我们在应用程序中添加了新的 &lt;code&gt;:env&lt;/code&gt; 密钥。它返回应用程序默认环境，该环境具有键 &lt;code&gt;:routing_table&lt;/code&gt; 的条目和一个空列表的值。对于应用程序环境来说，附带一个空表是有意义的，因为特定的路由表取决于测试/部署结构。</target>
        </trans-unit>
        <trans-unit id="6faaf48e5eb0045eb584e188528f01304e4bbcaf" translate="yes" xml:space="preserve">
          <source>We have already explored &lt;code&gt;config/config.exs&lt;/code&gt;. Now let&amp;rsquo;s talk about &lt;code&gt;rel/env.sh.eex&lt;/code&gt; and then &lt;code&gt;config/releases.exs&lt;/code&gt; before we end this chapter.</source>
          <target state="translated">我们已经探索了 &lt;code&gt;config/config.exs&lt;/code&gt; 。现在，在结束本章之前，我们先讨论 &lt;code&gt;rel/env.sh.eex&lt;/code&gt; ，然后再讨论 &lt;code&gt;config/releases.exs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d7a2eb3f07da32d273a9a9415d60c537251a582" translate="yes" xml:space="preserve">
          <source>We have already learned that Elixir provides double-quoted strings and single-quoted char lists. However, this only covers the surface of structures that have textual representation in the language. Atoms, for example, are mostly created via the &lt;code&gt;:atom&lt;/code&gt; representation.</source>
          <target state="translated">我们已经了解到Elixir提供了双引号字符串和单引号字符列表。但是，这仅覆盖具有该语言的文本表示形式的结构的表面。例如，原子大多是通过 &lt;code&gt;:atom&lt;/code&gt; 表示形式创建的。</target>
        </trans-unit>
        <trans-unit id="55fb07eb508a149a0659b431a989bcd41e036fb6" translate="yes" xml:space="preserve">
          <source>We have also discussed a handful of syntax conveniences provided by Elixir. Those conveniences are what allow us to write</source>
          <target state="translated">我们还讨论了Elixir提供的一些语法便利。这些便利条件使我们能够写出</target>
        </trans-unit>
        <trans-unit id="47ccfa66abec2276c0b7aea39fff20a82601b8d0" translate="yes" xml:space="preserve">
          <source>We have been working inside an application this entire time. Every time we changed a file and ran &lt;code&gt;mix compile&lt;/code&gt;, we could see a &lt;code&gt;Generated kv app&lt;/code&gt; message in the compilation output.</source>
          <target state="translated">整个过程中，我们一直在开发应用程序。每次我们更改文件并运行 &lt;code&gt;mix compile&lt;/code&gt; 时，在编译输出中都会看到一条 &lt;code&gt;Generated kv app&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="396ab1bb827baf3dc86bc047bdb1971b5cf3514a" translate="yes" xml:space="preserve">
          <source>We have first defined a setup callback with the help of the &lt;code&gt;setup/1&lt;/code&gt; macro. The &lt;code&gt;setup/1&lt;/code&gt; macro defines a callback that is run before every test, in the same process as the test itself.</source>
          <target state="translated">我们首先借助 &lt;code&gt;setup/1&lt;/code&gt; 宏定义了一个设置回调。该 &lt;code&gt;setup/1&lt;/code&gt; 宏定义了每个测试之前运行，在相同的工艺测试本身的回调。</target>
        </trans-unit>
        <trans-unit id="2e606875ff28c66f71d4da69c2e95037af1ac13f" translate="yes" xml:space="preserve">
          <source>We have just scratched the surface of what the Erlang VM has to offer, for example:</source>
          <target state="translated">例如,我们只是对Erlang虚拟机所提供的服务进行了简单的介绍。</target>
        </trans-unit>
        <trans-unit id="15f26f69ec0440b784420ca2d8178fe6d168ad64" translate="yes" xml:space="preserve">
          <source>We have learned about agents, generic servers, and supervisors. They are all meant to work with multiple messages or manage state. But what do we use when we only need to execute some task and that is it?</source>
          <target state="translated">我们已经了解了代理、通用服务器和主管。它们都是为了处理多个消息或管理状态。但是当我们只需要执行一些任务就可以了的时候,我们用什么呢?</target>
        </trans-unit>
        <trans-unit id="4509fc7814603728df2ad623d4a1467453b70745" translate="yes" xml:space="preserve">
          <source>We have now successfully defined our supervisor which is automatically started (and stopped) as part of our application lifecycle.</source>
          <target state="translated">我们现在已经成功地定义了我们的主管,它作为我们应用程序生命周期的一部分被自动启动(和停止)。</target>
        </trans-unit>
        <trans-unit id="14bb9ad8c190c5b506299dbc844613b7db04c78f" translate="yes" xml:space="preserve">
          <source>We have previously learned about links in the &lt;a href=&quot;../processes&quot;&gt;Process chapter&lt;/a&gt;. Now, with the registry complete, you may be wondering: when should we use monitors and when should we use links?</source>
          <target state="translated">我们先前在&amp;ldquo; &lt;a href=&quot;../processes&quot;&gt;处理&amp;rdquo;一章中&lt;/a&gt;了解了链接。现在，完成注册表后，您可能会想知道：我们什么时候应该使用监视器，什么时候应该使用链接？</target>
        </trans-unit>
        <trans-unit id="24edfa5902db50de9858abd9fd5d24f337e28c2e" translate="yes" xml:space="preserve">
          <source>We have used the &lt;code&gt;=&lt;/code&gt; operator a couple times to assign variables in Elixir:</source>
          <target state="translated">我们多次使用 &lt;code&gt;=&lt;/code&gt; 运算符在Elixir中分配变量：</target>
        </trans-unit>
        <trans-unit id="6f4f1a86e1887aa923d4b1e6c0eb9cb96b8624f4" translate="yes" xml:space="preserve">
          <source>We have written a guide that covers how to build an Elixir application, with its own supervision tree, configuration, tests, and more. The application works as a distributed key-value store where we organize key-value pairs into buckets and distribute those buckets across multiple nodes:</source>
          <target state="translated">我们写了一份指南,涵盖了如何构建Elixir应用,有自己的监督树、配置、测试等。该应用以分布式键值存储的方式工作,我们将键值对组织成桶,并将这些桶分布在多个节点上。</target>
        </trans-unit>
        <trans-unit id="2161ef9aca87ca65355a4bfdacd38ac5d5a332ef" translate="yes" xml:space="preserve">
          <source>We have written extensive documentation on releases, so &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;please check the official docs for more information&lt;/a&gt;. For now, we will continue exploring some of the features outlined above.</source>
          <target state="translated">我们已经针对发行版编写了广泛的文档，因此&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;请查看官方文档以获取更多信息&lt;/a&gt;。目前，我们将继续探索上述一些功能。</target>
        </trans-unit>
        <trans-unit id="ac7652b3d4ad00e46453485a36d0a78622bc002f" translate="yes" xml:space="preserve">
          <source>We haven&amp;rsquo;t talked about state so far in this guide. If you are building an application that requires state, for example, to keep your application configuration, or you need to parse a file and keep it in memory, where would you store it?</source>
          <target state="translated">到目前为止，我们尚未在本指南中讨论状态。例如，如果要构建需要状态的应用程序以保留应用程序配置，或者需要解析文件并将其保存在内存中，则将文件存储在哪里？</target>
        </trans-unit>
        <trans-unit id="3cfb66e1e45957f5152798168f2eef8b31f8d6a5" translate="yes" xml:space="preserve">
          <source>We hope this section shines some light on how Elixir supports meta-programming and how module attributes play an important role when doing so.</source>
          <target state="translated">我们希望本节能让大家了解Elixir是如何支持元编程的,以及模块属性在元编程时的重要作用。</target>
        </trans-unit>
        <trans-unit id="ca020b3dd04bced732b9a88d32d9d8b560a99be0" translate="yes" xml:space="preserve">
          <source>We invoke &lt;code&gt;KV.Registry.create(registry, &quot;shopping&quot;)&lt;/code&gt;</source>
          <target state="translated">我们调用 &lt;code&gt;KV.Registry.create(registry, &quot;shopping&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c6e2f5ac3f7b1e14e21331e0191301fcc7de6cb" translate="yes" xml:space="preserve">
          <source>We invoke &lt;code&gt;sum_list&lt;/code&gt; with the list &lt;code&gt;[1, 2, 3]&lt;/code&gt; and the initial value &lt;code&gt;0&lt;/code&gt; as arguments. We will try each clause until we find one that matches according to the pattern matching rules. In this case, the list &lt;code&gt;[1, 2, 3]&lt;/code&gt; matches against &lt;code&gt;[head | tail]&lt;/code&gt; which binds &lt;code&gt;head&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; to &lt;code&gt;[2, 3]&lt;/code&gt;; &lt;code&gt;accumulator&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">我们使用列表 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 和初始值 &lt;code&gt;0&lt;/code&gt; 作为参数调用 &lt;code&gt;sum_list&lt;/code&gt; 。我们将尝试每个子句，直到找到根据模式匹配规则匹配的子句为止。在这种情况下，列表 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 与 &lt;code&gt;[head | tail]&lt;/code&gt; tail [尾部]将 &lt;code&gt;head&lt;/code&gt; 绑定到 &lt;code&gt;1&lt;/code&gt; ，将 &lt;code&gt;tail&lt;/code&gt; 绑定到 &lt;code&gt;[2, 3]&lt;/code&gt; ； &lt;code&gt;accumulator&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caa4d8b87080c8f65cf48ef405dc69b67880c9f6" translate="yes" xml:space="preserve">
          <source>We need a way to configure the application environment. That&amp;rsquo;s when we use configuration files.</source>
          <target state="translated">我们需要一种配置应用程序环境的方法。那就是我们使用配置文件的时候。</target>
        </trans-unit>
        <trans-unit id="21270ac8203266757e479f248d45aea726769f54" translate="yes" xml:space="preserve">
          <source>We now need to modify &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; to contain the umbrella entries we have seen in &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt;. Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and add to the &lt;code&gt;project/0&lt;/code&gt; function:</source>
          <target state="translated">现在，我们需要修改 &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; ,以包含我们在 &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; 中看到的总括条目。打开 &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; 并添加到 &lt;code&gt;project/0&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="0dfaef79b3bc9bce4f06cff718fb2cc10713dc31" translate="yes" xml:space="preserve">
          <source>We recommend that developers include examples in their documentation, often under their own &lt;code&gt;## Examples&lt;/code&gt; heading. To ensure examples do not get out of date, Elixir's test framework (ExUnit) provides a feature called doctests that allows developers to test the examples in their documentation. Doctests work by parsing out code samples starting with &lt;code&gt;iex&amp;gt;&lt;/code&gt; from the documentation. You can read more about it at &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt;&lt;code&gt;ExUnit.DocTest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们建议开发人员在自己的 &lt;code&gt;## Examples&lt;/code&gt; 标题下通常将示例包含在其文档中。为了确保示例不会过时，Elixir的测试框架（ExUnit）提供了一个称为doctests的功能，该功能允许开发人员在其文档中测试示例。Doctests通过解析文档中以 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 开头的代码样本来工作。您可以在&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt; &lt;code&gt;ExUnit.DocTest&lt;/code&gt; 上&lt;/a&gt;阅读有关它的更多信息。</target>
        </trans-unit>
        <trans-unit id="087bb5b14c43d71b4effe4bdb7e80e24f491682e" translate="yes" xml:space="preserve">
          <source>We recommend using this feature with care, especially library authors. Deprecating code always pushes the burden towards library users. We also recommend for deprecated functionality to be maintained for long periods of time, even after deprecation, giving developers plenty of time to update (except for cases where keeping the deprecated API is undesired, such as in the presence of security issues).</source>
          <target state="translated">我们建议谨慎使用这个功能,尤其是库作者。废弃代码总是把负担推给库用户。我们也建议对被废弃的功能进行长时间的维护,即使在废弃之后,也要给开发者足够的时间进行更新(除非在不希望保留被废弃的API的情况下,比如存在安全问题)。</target>
        </trans-unit>
        <trans-unit id="0bbc774ddec41a7d4c86b05aa27b1e75ab2f1cd6" translate="yes" xml:space="preserve">
          <source>We say the functions in the &lt;code&gt;Enum&lt;/code&gt; module are polymorphic because they can work with diverse data types. In particular, the functions in the &lt;code&gt;Enum&lt;/code&gt; module can work with any data type that implements &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;the &lt;code&gt;Enumerable&lt;/code&gt; protocol&lt;/a&gt;. We are going to discuss Protocols in a later chapter; for now we are going to move on to a specific kind of enumerable called a stream.</source>
          <target state="translated">我们说 &lt;code&gt;Enum&lt;/code&gt; 模块中的函数是多态的，因为它们可以处理多种数据类型。特别是，在功能 &lt;code&gt;Enum&lt;/code&gt; 模块可以与任何数据类型实现工作&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;的 &lt;code&gt;Enumerable&lt;/code&gt; 协议&lt;/a&gt;。我们将在下一章讨论协议。现在，我们将继续研究一种称为流的特定类型的可枚举对象。</target>
        </trans-unit>
        <trans-unit id="3cb3b686e4a2ae3801a38f4de17970115ff08932" translate="yes" xml:space="preserve">
          <source>We start our &lt;code&gt;Stack&lt;/code&gt; by calling &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;, passing the module with the server implementation and its initial argument (a list representing the stack containing the element &lt;code&gt;:hello&lt;/code&gt;). We can primarily interact with the server by sending two types of messages. &lt;strong&gt;call&lt;/strong&gt; messages expect a reply from the server (and are therefore synchronous) while &lt;strong&gt;cast&lt;/strong&gt; messages do not.</source>
          <target state="translated">我们通过调用&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; 来&lt;/a&gt;启动 &lt;code&gt;Stack&lt;/code&gt; ，将模块与服务器实现及其初始参数（表示包含元素 &lt;code&gt;:hello&lt;/code&gt; 的堆栈的列表）一起传递给模块。我们可以主要通过发送两种类型的消息来与服务器进行交互。&lt;strong&gt;呼叫&lt;/strong&gt;消息期望来自服务器的答复（因此是同步的），而&lt;strong&gt;强制&lt;/strong&gt;消息则不会。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe0723f5169f8ebd3cc159b9dc24e024e26706" translate="yes" xml:space="preserve">
          <source>We started an agent with an initial state of an empty list. We updated the agent&amp;rsquo;s state, adding our new item to the head of the list. The second argument of &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#update/3&quot;&gt;&lt;code&gt;Agent.update/3&lt;/code&gt;&lt;/a&gt; is a function that takes the agent&amp;rsquo;s current state as input and returns its desired new state. Finally, we retrieved the whole list. The second argument of &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt;&lt;code&gt;Agent.get/3&lt;/code&gt;&lt;/a&gt; is a function that takes the state as input and returns the value that &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt;&lt;code&gt;Agent.get/3&lt;/code&gt;&lt;/a&gt; itself will return. Once we are done with the agent, we can call &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#stop/3&quot;&gt;&lt;code&gt;Agent.stop/3&lt;/code&gt;&lt;/a&gt; to terminate the agent process.</source>
          <target state="translated">我们以初始状态为空列表启动了一个代理。我们更新了代理的状态，将新项目添加到列表的开头。&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#update/3&quot;&gt; &lt;code&gt;Agent.update/3&lt;/code&gt; &lt;/a&gt;的第二个参数是一个函数，该函数将代理的当前状态作为输入并返回其所需的新状态。最后，我们检索了整个列表。&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt; &lt;code&gt;Agent.get/3&lt;/code&gt; &lt;/a&gt;的第二个参数是一个将状态作为输入并返回&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt; &lt;code&gt;Agent.get/3&lt;/code&gt; &lt;/a&gt;本身将返回的值的函数。处理完代理后，我们可以调用&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#stop/3&quot;&gt; &lt;code&gt;Agent.stop/3&lt;/code&gt; &lt;/a&gt;终止代理进程。</target>
        </trans-unit>
        <trans-unit id="f6533bed650e28deb96da306d0ae21f387c7b715" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;Application.fetch_env!/2&lt;/code&gt; to read the entry for &lt;code&gt;:routing_table&lt;/code&gt; in &lt;code&gt;:kv&lt;/code&gt;&amp;rsquo;s environment. You can find more information and other functions to manipulate the app environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;Application module&lt;/a&gt;.</source>
          <target state="translated">我们使用 &lt;code&gt;Application.fetch_env!/2&lt;/code&gt; 读为入门 &lt;code&gt;:routing_table&lt;/code&gt; 在 &lt;code&gt;:kv&lt;/code&gt; 的环境。您可以在&amp;ldquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;应用程序&amp;rdquo;模块中&lt;/a&gt;找到更多信息和其他功能来操纵应用程序环境。</target>
        </trans-unit>
        <trans-unit id="29bdab7cfe0856e731211b24f42d38f56fc4cbfb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;import&lt;/code&gt; whenever we want to easily access functions or macros from other modules without using the fully-qualified name. For instance, if we want to use the &lt;code&gt;duplicate/2&lt;/code&gt; function from the &lt;code&gt;List&lt;/code&gt; module several times, we can import it:</source>
          <target state="translated">每当我们想轻松地从其他模块访问函数或宏而无需使用标准名称时，我们都会使用 &lt;code&gt;import&lt;/code&gt; 。例如，如果我们想多次使用 &lt;code&gt;List&lt;/code&gt; 模块中的 &lt;code&gt;duplicate/2&lt;/code&gt; 函数，可以将其导入：</target>
        </trans-unit>
        <trans-unit id="1c85e6a1770769aa75641d4a9816aeb703d170de" translate="yes" xml:space="preserve">
          <source>We will explore most of these abstractions in this guide. Keep in mind that they are all implemented on top of processes using the basic features provided by the</source>
          <target state="translated">我们将在本指南中探讨这些抽象的大部分。请记住,它们都是在流程之上实现的,使用的是由</target>
        </trans-unit>
        <trans-unit id="655e75f17c147831957b0f1ca8d40311ebda7698" translate="yes" xml:space="preserve">
          <source>We will explore the valid switches and operation modes of option parser below.</source>
          <target state="translated">下面我们就来探讨一下期权解析器的有效开关和操作模式。</target>
        </trans-unit>
        <trans-unit id="77cd8cf79452e8ce8626f2aa6a0bdf3ee709792b" translate="yes" xml:space="preserve">
          <source>We will explore those functionalities in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;, for now it is enough to remember to use &lt;code&gt;Task&lt;/code&gt; to get better error reports.</source>
          <target state="translated">我们将在&lt;strong&gt;&lt;em&gt;Mix and OTP指南中&lt;/em&gt;&lt;/strong&gt;探索这些功能，现在记住使用 &lt;code&gt;Task&lt;/code&gt; 获得更好的错误报告就足够了。</target>
        </trans-unit>
        <trans-unit id="2744540fd7a20a87da7f1caa4830e0d61e9163cc" translate="yes" xml:space="preserve">
          <source>We will learn those details as we move forward on this guide. If you would rather peek ahead, check the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; docs.</source>
          <target state="translated">随着本指南的发展，我们将学习这些细节。如果您想先睹为快，请查看&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="7e6401949917ccd9b1dc37503a9619e2473c15e8" translate="yes" xml:space="preserve">
          <source>We will leave it up to you to further explore what Observer provides. Note you can double click any process in the supervision tree to retrieve more information about it, as well as right-click a process to send &amp;ldquo;a kill signal&amp;rdquo;, a perfect way to emulate failures and see if your supervisor reacts as expected.</source>
          <target state="translated">我们将取决于您，以进一步探索Observer提供的内容。请注意，您可以双击监督树中的任何进程以检索有关它的更多信息，也可以右键单击一个进程以发送&amp;ldquo;终止信号&amp;rdquo;，这是模拟故障并查看主管是否按预期做出反应的理想方式。</target>
        </trans-unit>
        <trans-unit id="0d6c2ae825cac9f0996d30218558edf03d9af98b" translate="yes" xml:space="preserve">
          <source>We will start our TCP server by first implementing an echo server. It will send a response with the text it received in the request. We will slowly improve our server until it is supervised and ready to handle multiple connections.</source>
          <target state="translated">我们将通过首先实现一个echo服务器来启动我们的TCP服务器。它将发送一个响应与它在请求中收到的文本。我们将慢慢改进我们的服务器,直到它被监督并准备好处理多个连接。</target>
        </trans-unit>
        <trans-unit id="fac2f5448b956d8da6564df88e205c307d9c5cdf" translate="yes" xml:space="preserve">
          <source>We will use a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; to create a registry process that can monitor the bucket processes. GenServer provides industrial strength functionality for building servers in both Elixir and</source>
          <target state="translated">我们将使用&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt;创建一个注册表进程，该进程可以监视存储桶进程。GenServer为在Elixir和Elixir中构建服务器提供了强大的功能。</target>
        </trans-unit>
        <trans-unit id="e79c1e292f9f25087d286b398c91b461d6dcecd5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll now start a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; process with name &lt;code&gt;KVServer.TaskSupervisor&lt;/code&gt;. Remember, since the acceptor task depends on this supervisor, the supervisor must be started first.</source>
          <target state="translated">现在，我们将启动名称为 &lt;code&gt;KVServer.TaskSupervisor&lt;/code&gt; 的&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;进程。请记住，由于接受者任务取决于此主管，因此必须首先启动主管。</target>
        </trans-unit>
        <trans-unit id="ed0bddf403cdfbbcbd68216aea7a440098df2a8b" translate="yes" xml:space="preserve">
          <source>Welcome to Interactive Elixir. You are currently seeing the documentation for the module &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; which provides many helpers to make Elixir's shell more joyful to work with.</source>
          <target state="translated">欢迎来到互动灵丹妙药。当前，您正在查看&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块的文档，该文档提供了许多帮助程序，以使Elixir的Shell使用起来更加愉悦。</target>
        </trans-unit>
        <trans-unit id="e52e5e6cd50ef4de30d8a4fafbbfab41180cc200" translate="yes" xml:space="preserve">
          <source>Welcome!</source>
          <target state="translated">Welcome!</target>
        </trans-unit>
        <trans-unit id="1799caf9108a397466713ff5adb66927a4ad613e" translate="yes" xml:space="preserve">
          <source>What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">每个程序员都应该知道的浮点算术知识</target>
        </trans-unit>
        <trans-unit id="10f3a323d59ed1bc1fd18a9f06ddd91ca9d23324" translate="yes" xml:space="preserve">
          <source>What happens if we intentionally crash the registry started by the supervisor? Let&amp;rsquo;s do so by sending it a bad input on &lt;code&gt;call&lt;/code&gt;:</source>
          <target state="translated">如果我们故意破坏由主管启动的注册表，会发生什么情况？让我们通过在 &lt;code&gt;call&lt;/code&gt; 向它发送错误的输入来做到这一点：</target>
        </trans-unit>
        <trans-unit id="b4b3256dbcacb22b4f6f01d2dfc0f210fb7bb580" translate="yes" xml:space="preserve">
          <source>What if we instead want to double all of the values in our list?</source>
          <target state="translated">如果我们想把列表中的所有值都翻倍呢?</target>
        </trans-unit>
        <trans-unit id="109be0146bc5ad53b41b5fd51afbc9a73fd08edc" translate="yes" xml:space="preserve">
          <source>What is happening in our tests is that there is a delay in between an operation and the time we can observe this change in the ETS table. Here is what we were expecting to happen:</source>
          <target state="translated">在我们的测试中,发生的情况是,在操作和我们可以观察到ETS表中的变化之间有一个延迟。这就是我们所期待的情况。</target>
        </trans-unit>
        <trans-unit id="3e0d544d961c62170b13c4585da0fcb18fc3b9d1" translate="yes" xml:space="preserve">
          <source>What is the difference between lists and tuples?</source>
          <target state="translated">列表和元组的区别是什么?</target>
        </trans-unit>
        <trans-unit id="7aa70b85a229c070639a64a641a35f6f1bc6adf0" translate="yes" xml:space="preserve">
          <source>What makes &lt;code&gt;IO.inspect(item, opts \\ [])&lt;/code&gt; really useful in debugging is that it returns the &lt;code&gt;item&lt;/code&gt; argument passed to it without affecting the behavior of the original code. Let&amp;rsquo;s see an example.</source>
          <target state="translated">使得 &lt;code&gt;IO.inspect(item, opts \\ [])&lt;/code&gt; 在调试中真正有用的原因是，它返回了传递给它的 &lt;code&gt;item&lt;/code&gt; 参数而不影响原始代码的行为。让我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="f36299b12fc4f2e628757870a035b1b926aeb78d" translate="yes" xml:space="preserve">
          <source>What makes this project different from the previous one is the &lt;code&gt;apps_path: &quot;apps&quot;&lt;/code&gt; entry in the project definition. This means this project will act as an umbrella. Such projects do not have source files nor tests, although they can have their own dependencies. Each child application must be defined inside the &lt;code&gt;apps&lt;/code&gt; directory.</source>
          <target state="translated">使该项目与上一个项目不同的是项目定义中的 &lt;code&gt;apps_path: &quot;apps&quot;&lt;/code&gt; 条目。这意味着该项目将起到保护伞的作用。尽管此类项目可以具有自己的依赖性，但它们没有源文件或测试。必须在 &lt;code&gt;apps&lt;/code&gt; 目录中定义每个子应用程序。</target>
        </trans-unit>
        <trans-unit id="b82b16926c1c401c50c5de43260d7d6bfd15f1dd" translate="yes" xml:space="preserve">
          <source>When (not) to use a GenServer</source>
          <target state="translated">何时(不)使用GenServer</target>
        </trans-unit>
        <trans-unit id="31fa4a4dcc6a8a3b88863b4f81efd1e668262ac2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--callers&lt;/code&gt; option is specified, you'll see expanded function entries:</source>
          <target state="translated">当指定 &lt;code&gt;--callers&lt;/code&gt; 选项时，您将看到扩展的函数条目：</target>
        </trans-unit>
        <trans-unit id="a913347a3c3c1ca9dc541c0a9cdbc7194c7830d0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--matching&lt;/code&gt; option is specified, call count tracing will be started only for the functions matching the given pattern:</source>
          <target state="translated">当指定 &lt;code&gt;--matching&lt;/code&gt; 选项时，将仅对与给定模式匹配的函数启动调用计数跟踪：</target>
        </trans-unit>
        <trans-unit id="8cf2de6f867864816f104de4c60eca50d53d89da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;.&lt;/code&gt; is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):</source>
          <target state="translated">什么时候 &lt;code&gt;.&lt;/code&gt; 如果使用，引用的表达式可以采用两种不同的形式。当右侧以小写字母（或下划线）开头时：</target>
        </trans-unit>
        <trans-unit id="b4028a2b288952e3e42b96883be10dac26bd36b0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_binaries&lt;/code&gt; all binaries will be printed in bit syntax.</source>
          <target state="translated">当 &lt;code&gt;:as_binaries&lt;/code&gt; 时,所有二进制文件都将以位语法打印。</target>
        </trans-unit>
        <trans-unit id="1cc116635ec80ef3ca62f754c296f6eef7bdca49" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_lists&lt;/code&gt; all lists will be printed as lists.</source>
          <target state="translated">当 &lt;code&gt;:as_lists&lt;/code&gt; 时,所有列表将被打印为列表。</target>
        </trans-unit>
        <trans-unit id="15ecc670260c21fbdb9e392dbf128e78e186fc91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is less than or equal to the length of &lt;code&gt;string&lt;/code&gt;, given &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">当 &lt;code&gt;count&lt;/code&gt; 小于或等于 &lt;code&gt;string&lt;/code&gt; 的长度时，返回给定的 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4bdfc3290cc111eb68b82c9dd61f9600de60e9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fun&lt;/code&gt; is an anonymous function (that is, the type is &lt;code&gt;:local&lt;/code&gt;), the following additional keys are returned:</source>
          <target state="translated">当 &lt;code&gt;fun&lt;/code&gt; 是一个匿名函数（即类型为 &lt;code&gt;:local&lt;/code&gt; ）时，将返回以下附加键：</target>
        </trans-unit>
        <trans-unit id="223d25fb9e9e50ec86e6ed90ff88e7fffae68789" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key&lt;/code&gt; exists in the given structure &lt;code&gt;data&lt;/code&gt;, the implementation should return a &lt;code&gt;{value, new_data}&lt;/code&gt; tuple where &lt;code&gt;value&lt;/code&gt; is the value that was under &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;key&lt;/code&gt; 在给定结构中存在 &lt;code&gt;data&lt;/code&gt; ，实施应返回 &lt;code&gt;{value, new_data}&lt;/code&gt; 这里的元组 &lt;code&gt;value&lt;/code&gt; 是下得值 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;new_data&lt;/code&gt; 是 &lt;code&gt;term&lt;/code&gt; 不用 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a92494a01e974bc8479461c1fc150f473313415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key&lt;/code&gt; is not present in the given structure, a tuple &lt;code&gt;{value, data}&lt;/code&gt; should be returned, where &lt;code&gt;value&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">如果给定结构中不存在 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;{value, data}&lt;/code&gt; 则应返回元组{value，data}，其中 &lt;code&gt;value&lt;/code&gt; 是实现定义的。</target>
        </trans-unit>
        <trans-unit id="cae3aec565b8ce2ce0cbf8d86303e42f595da844" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;print_multiple_times/2&lt;/code&gt; is initially called in the example above, the argument &lt;code&gt;n&lt;/code&gt; is equal to &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中最初调用 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 时，参数 &lt;code&gt;n&lt;/code&gt; 等于 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9eb4663dc0fbb999edc597d05f93217c9f5e912" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;some_fun/3&lt;/code&gt; is invoked with &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, &lt;code&gt;:baz&lt;/code&gt; it prints:</source>
          <target state="translated">当使用 &lt;code&gt;:foo&lt;/code&gt; ， &lt;code&gt;&quot;bar&quot;&lt;/code&gt; ， &lt;code&gt;:baz&lt;/code&gt; 调用 &lt;code&gt;some_fun/3&lt;/code&gt; 时，它将输出：</target>
        </trans-unit>
        <trans-unit id="881e0ddf18fdf0b8e18f1c5c2fb76ebfa4a0d4e8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;static_atom_encoder: &amp;amp;my_encoder/2&lt;/code&gt; is passed as an argument, &lt;code&gt;my_encoder/2&lt;/code&gt; is called every time the tokenizer needs to create a &quot;static&quot; atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists.</source>
          <target state="translated">当将 &lt;code&gt;static_atom_encoder: &amp;amp;my_encoder/2&lt;/code&gt; 作为参数传递时，每次令牌化程序需要创建&amp;ldquo;静态&amp;rdquo;原子时都会调用 &lt;code&gt;my_encoder/2&lt;/code&gt; 。静态原子是AST中的原子，用作别名，远程调用，本地调用，变量名，常规原子和关键字列表。</target>
        </trans-unit>
        <trans-unit id="ad5e2fdb3a60f0efd80fd38f40be2eb7879f4b9b" translate="yes" xml:space="preserve">
          <source>When Elixir sees a list of printable ASCII numbers, Elixir will print that as a charlist (literally a list of characters). Charlists are quite common when interfacing with existing Erlang code. Whenever you see a value in IEx and you are not quite sure what it is, you can use the &lt;code&gt;i/1&lt;/code&gt; to retrieve information about it:</source>
          <target state="translated">当Elixir看到可打印的ASCII数字列表时，Elixir会将其打印为字符列表（字面上为字符列表）。与现有的Erlang代码交互时，字符列表非常普遍。每当您在IEx中看到一个值并且不确定它是什么时，都可以使用 &lt;code&gt;i/1&lt;/code&gt; 来检索有关它的信息：</target>
        </trans-unit>
        <trans-unit id="35c4063a6051dde1c696255275b6a41a4aaaebdd" translate="yes" xml:space="preserve">
          <source>When a URI is given without a port, the value returned by &lt;a href=&quot;uri#default_port/1&quot;&gt;&lt;code&gt;URI.default_port/1&lt;/code&gt;&lt;/a&gt; for the URI's scheme is used for the &lt;code&gt;:port&lt;/code&gt; field.</source>
          <target state="translated">如果给定的URI没有端口，则&lt;a href=&quot;uri#default_port/1&quot;&gt; &lt;code&gt;URI.default_port/1&lt;/code&gt; &lt;/a&gt;为URI的方案返回的值将用于 &lt;code&gt;:port&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="25987424f80060bb3d956efb681cc86c02e031c9" translate="yes" xml:space="preserve">
          <source>When a breakpoint is reached, IEx will ask if you want to &lt;code&gt;pry&lt;/code&gt; the given function and arity. In other words, this works similar to &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt;, aliases and imports from the source code won't be available in the shell.</source>
          <target state="translated">当达到断点时，IEX将询问您是否要 &lt;code&gt;pry&lt;/code&gt; 给定的功能和参数。换句话说，这与&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;相似，因为正在运行的进程成为IEx命令的评估者，并暂时更改为具有自定义组长。但是，与&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;不同，Shell中将不提供别名和源代码的导入。</target>
        </trans-unit>
        <trans-unit id="b38ca287d116ffb71518505762e2c7d09b9bd2e7" translate="yes" xml:space="preserve">
          <source>When a long action is performed on the server, all other requests to that particular server will wait until the action is done, which may cause some clients to timeout.</source>
          <target state="translated">当在服务器上执行长动作时,所有其他对该特定服务器的请求都会等待,直到动作完成,这可能会导致一些客户端超时。</target>
        </trans-unit>
        <trans-unit id="bcbf680c558a41d6d6a75e4381c38c76088bbeeb" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process, the message is stored in the process mailbox. The &lt;code&gt;receive/1&lt;/code&gt; block goes through the current process mailbox searching for a message that matches any of the given patterns. &lt;code&gt;receive/1&lt;/code&gt; supports guards and many clauses, such as &lt;code&gt;case/2&lt;/code&gt;.</source>
          <target state="translated">当消息发送到流程时，该消息存储在流程邮箱中。的 &lt;code&gt;receive/1&lt;/code&gt; 块经过当前进程信箱检索该匹配任何给定的图案的信息。 &lt;code&gt;receive/1&lt;/code&gt; 支持警卫和许多条款，例如 &lt;code&gt;case/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa7709fb20a64125217b49eacd2e41e461864cc" translate="yes" xml:space="preserve">
          <source>When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, the code is evaluated and therefore cannot access private functions of the module being pried. Module functions still need to be accessed via &lt;code&gt;Mod.fun(args)&lt;/code&gt;.</source>
          <target state="translated">撬动进程时，所有代码都在IEx内运行，并且可以访问原始代码中的所有导入和别名。但是，代码已被评估，因此无法访问被撬模块的私有功能。仍然需要通过 &lt;code&gt;Mod.fun(args)&lt;/code&gt; 访问模块功能。</target>
        </trans-unit>
        <trans-unit id="a1dd320c95795f465d521db42ced2d81854df04f" translate="yes" xml:space="preserve">
          <source>When a process reaches its end, by default it exits with reason &lt;code&gt;:normal&lt;/code&gt;. You can also call &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; explicitly if you want to terminate a process but not signal any failure:</source>
          <target state="translated">进程结束时，默认情况下会退出，原因为 &lt;code&gt;:normal&lt;/code&gt; 。如果要终止进程但不表示任何故障，也可以显式调用&lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6b82ee1a7b204267871ba58bdb550d5e578f2684" translate="yes" xml:space="preserve">
          <source>When a supervisor shuts down, it terminates all children in the opposite order they are listed. The termination happens by sending a shutdown exit signal, via &lt;code&gt;Process.exit(child_pid, :shutdown)&lt;/code&gt;, to the child process and then awaiting for a time interval for the child process to terminate. This interval defaults to 5000 milliseconds. If the child process does not terminate in this interval, the supervisor abruptly terminates the child with reason &lt;code&gt;:kill&lt;/code&gt;. The shutdown time can be configured in the child specification which is fully detailed in the next section.</source>
          <target state="translated">当主管关闭时，它将按照列出的相反顺序终止所有子级。通过 &lt;code&gt;Process.exit(child_pid, :shutdown)&lt;/code&gt; 向子进程发送关闭退出信号，然后等待子进程终止的时间间隔来终止。此间隔默认为5000毫秒。如果子进程未在此时间间隔内终止，则主管会由于 &lt;code&gt;:kill&lt;/code&gt; 突然终止该子进程。可以在子规范中配置关闭时间，该规范将在下一部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="8faaac6c2f8c18a01b5af430b45f4916b3dd825c" translate="yes" xml:space="preserve">
          <source>When adding 3 seconds just before &quot;spring forward&quot; we go from 1:59:59 to 3:00:02</source>
          <target state="translated">当在 &quot;向前冲 &quot;前增加3秒时,我们从1:59:59到3:00:02。</target>
        </trans-unit>
        <trans-unit id="c9f12bb1a577b215300a6befb2319f871a5526b1" translate="yes" xml:space="preserve">
          <source>When all the keys in a map are atoms, you can use the keyword syntax for convenience:</source>
          <target state="translated">当一个图中的所有键都是原子时,为了方便,可以使用关键字语法。</target>
        </trans-unit>
        <trans-unit id="b71088ccdefe00157ef914366e7da0f66c676805" translate="yes" xml:space="preserve">
          <source>When an application is loaded, the environment specified in its resource file is merged with any overrides from config files passed to &lt;code&gt;erl&lt;/code&gt; via the &lt;code&gt;-config&lt;/code&gt; option. It is worth highlighting that releases pass &lt;code&gt;sys.config&lt;/code&gt; this way. The resulting environment can still be overridden again via specific &lt;code&gt;-Application&lt;/code&gt; options passed to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">加载应用程序时，其资源文件中指定的环境将与通过 &lt;code&gt;-config&lt;/code&gt; 选项传递给 &lt;code&gt;erl&lt;/code&gt; 的配置文件中的所有替代合并。值得强调的是，这种方式通过 &lt;code&gt;sys.config&lt;/code&gt; 发布。仍然可以通过传递给 &lt;code&gt;erl&lt;/code&gt; 的特定 &lt;code&gt;-Application&lt;/code&gt; 选项再次覆盖生成的环境。</target>
        </trans-unit>
        <trans-unit id="c1202c2e0c188151503ef65ce91c2cf42d3152ad" translate="yes" xml:space="preserve">
          <source>When an application is shutting down, its &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value of &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; is ignored.</source>
          <target state="translated">当应用程序关闭时，运行树停止监视树后，将调用其&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;回调。此回调允许应用程序执行任何最终清理。该参数是&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;返回的状态（如果存在），否则为 &lt;code&gt;[]&lt;/code&gt; 。&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;的返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="f6ef5e0c1b03cd4c7d5dd1940a8d6051debba964" translate="yes" xml:space="preserve">
          <source>When an application is started, the runtime loads it if it hasn't been loaded yet (in the technical sense described above). Then, it checks if the dependencies listed in the &lt;code&gt;applications&lt;/code&gt; key of the resource file are already started. Having at least one dependency not started is an error condition, but when you start an application with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, Mix takes care of starting all the dependencies for you, so in practice you don't need to worry about it unless you are starting applications manually with the API provided by this module.</source>
          <target state="translated">启动应用程序时，运行时将加载尚未加载的应用程序（按照上述技术意义）。然后，它检查资源文件的 &lt;code&gt;applications&lt;/code&gt; 密钥中列出的依赖项是否已经启动。至少有一个依赖项未启动是一种错误情况，但是当您使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;启动应用程序时，Mix会为您启动所有依赖项，因此在实践中，除非您要启动应用程序，否则不必担心手动使用此模块提供的API。</target>
        </trans-unit>
        <trans-unit id="fed10b03a998f194c91e2991e17c7adc90beb397" translate="yes" xml:space="preserve">
          <source>When an empty string is provided as a &lt;code&gt;pattern&lt;/code&gt;, the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as &lt;code&gt;replacement&lt;/code&gt; the &lt;code&gt;subject&lt;/code&gt; will be returned:</source>
          <target state="translated">当提供一个空字符串作为 &lt;code&gt;pattern&lt;/code&gt; ，该函数会将其视为每个字形之间的隐式空字符串，并且该字符串将被散布。如果提供了空字符串作为 &lt;code&gt;replacement&lt;/code&gt; ，则将返回 &lt;code&gt;subject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e3a4594b4c87d19792becad51fa21e48de73592" translate="yes" xml:space="preserve">
          <source>When asking questions, remember these two tips:</source>
          <target state="translated">在提问时,请记住这两个技巧。</target>
        </trans-unit>
        <trans-unit id="e6520e68609a37a9a4335763dc27bb15395388e4" translate="yes" xml:space="preserve">
          <source>When building a struct, Elixir will automatically guarantee all keys belongs to the struct:</source>
          <target state="translated">在构建结构时,Elixir会自动保证所有键都属于该结构。</target>
        </trans-unit>
        <trans-unit id="43f8256ec2ba3b57ef9f039c36ae97440305cfe0" translate="yes" xml:space="preserve">
          <source>When called with no arguments, tells whether the current project is an umbrella project.</source>
          <target state="translated">在没有参数的情况下调用时,告知当前项目是否为伞形项目。</target>
        </trans-unit>
        <trans-unit id="5fe5b19f3e345b7e40bafcd757d6f4638d7ad19e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Macro.expand_once/2&lt;/code&gt; earlier in this chapter, we used the special form &lt;code&gt;__ENV__&lt;/code&gt;.</source>
          <target state="translated">在本章前面的调用 &lt;code&gt;Macro.expand_once/2&lt;/code&gt; 时，我们使用了特殊形式 &lt;code&gt;__ENV__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81fce718e207dc57d7fe018b46a9c9813e132dc2" translate="yes" xml:space="preserve">
          <source>When calling a command, it's possible to pass command line options to modify what the command does. In this documentation, those are called &quot;switches&quot;, in other situations they may be called &quot;flags&quot; or simply &quot;options&quot;. A switch can be given a value, also called an &quot;argument&quot;.</source>
          <target state="translated">当调用一个命令时,可以通过命令行选项来修改命令的功能。在本文档中,这些选项被称为 &quot;开关&quot;,在其他情况下,它们可能被称为 &quot;标志 &quot;或简单的 &quot;选项&quot;。一个开关可以被赋予一个值,也称为 &quot;参数&quot;。</target>
        </trans-unit>
        <trans-unit id="15bf0eb73b6deae14192c9599225bae5f5bf74a1" translate="yes" xml:space="preserve">
          <source>When calling:</source>
          <target state="translated">当打电话。</target>
        </trans-unit>
        <trans-unit id="ea3e44e3db057976b426aba831c82df6ff3b11a8" translate="yes" xml:space="preserve">
          <source>When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.</source>
          <target state="translated">当比较两个不同类型的数字（一个数字是整数或浮点数）时，除非使用的比较运算符是&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;kernel#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt;，否则始终会转换为精度更高的类型。浮点数将被认为比整数更精确，除非该浮点数分别大于/小于+/- 9007199254740990992.0，此时浮点数的所有有效数字均位于小数点的左侧。存在此行为，以便大量比较仍然具有传递性。</target>
        </trans-unit>
        <trans-unit id="abb8f461ed01787b27277cdcd5e984ed7200e3d4" translate="yes" xml:space="preserve">
          <source>When compiling one file, there is no need to wrap it in a list:</source>
          <target state="translated">在编译一个文件时,不需要用列表来包装。</target>
        </trans-unit>
        <trans-unit id="dc320684f550c604f452ea80038eb7dce8a3df81" translate="yes" xml:space="preserve">
          <source>When counting the elements in a data structure, Elixir also abides by a simple rule: the function is named &lt;code&gt;size&lt;/code&gt; if the operation is in constant time (i.e. the value is pre-calculated) or &lt;code&gt;length&lt;/code&gt; if the operation is linear (i.e. calculating the length gets slower as the input grows). As a mnemonic, both &amp;ldquo;length&amp;rdquo; and &amp;ldquo;linear&amp;rdquo; start with &amp;ldquo;l&amp;rdquo;.</source>
          <target state="translated">当在一个数据结构中计数元件，药剂也仍住由一个简单的规则：该函数称为 &lt;code&gt;size&lt;/code&gt; 如果操作是在恒定时间（即，数值预先计算）或 &lt;code&gt;length&lt;/code&gt; 如果操作是线性的（即计算长度随着输入的增长而变慢）。作为助记符，&amp;ldquo;长度&amp;rdquo;和&amp;ldquo;线性&amp;rdquo;都以&amp;ldquo; l&amp;rdquo;开头。</target>
        </trans-unit>
        <trans-unit id="f6b6a0a6dde37d782de3ccaeae069e37c2979ec4" translate="yes" xml:space="preserve">
          <source>When creating an ETS table, two arguments are required: the table name and a set of options. From the available options, we passed the table type and its access rules. We have chosen the &lt;code&gt;:set&lt;/code&gt; type, which means that keys cannot be duplicated. We&amp;rsquo;ve also set the table&amp;rsquo;s access to &lt;code&gt;:protected&lt;/code&gt;, meaning only the process that created the table can write to it, but all processes can read from it. Those are actually the default values, so we will skip them from now on.</source>
          <target state="translated">创建ETS表时，需要两个参数：表名和一组选项。从可用选项中，我们传递了表类型及其访问规则。我们选择了 &lt;code&gt;:set&lt;/code&gt; 类型，这意味着键不能重复。我们还将表的访问权限设置为 &lt;code&gt;:protected&lt;/code&gt; ，这意味着只有创建表的进程才能向其写入，但所有进程都可以从中读取。这些实际上是默认值，因此从现在开始我们将跳过它们。</target>
        </trans-unit>
        <trans-unit id="33336d2f652ba1a581611b2ab795107a9818b6fc" translate="yes" xml:space="preserve">
          <source>When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example:</source>
          <target state="translated">当定义一个带有缺省参数以及多个显式声明子句的函数时,你必须写一个声明缺省参数的函数头。例如</target>
        </trans-unit>
        <trans-unit id="940944a0657e8af86b9ecfb3e0f5ccfcf23d2d7b" translate="yes" xml:space="preserve">
          <source>When defining an attribute, do not leave a line break between the attribute name and its value.</source>
          <target state="translated">在定义属性时,不要在属性名和属性值之间留下换行符。</target>
        </trans-unit>
        <trans-unit id="9c14e3bb37cd09a5f29b97fbe1d2849da51a757a" translate="yes" xml:space="preserve">
          <source>When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example:</source>
          <target state="translated">当通过宏定义函数时,开发人员可以选择是否从调用者或引号内报告运行时错误。我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="59c4a9527901fd3285b6261e17bbd7072524dcb8" translate="yes" xml:space="preserve">
          <source>When deriving, Elixir will implement the &lt;code&gt;Size&lt;/code&gt; protocol for &lt;code&gt;OtherUser&lt;/code&gt; based on the implementation provided for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">派生时，Elixir将基于为 &lt;code&gt;Any&lt;/code&gt; 提供的实现为 &lt;code&gt;OtherUser&lt;/code&gt; 实现 &lt;code&gt;Size&lt;/code&gt; 协议。</target>
        </trans-unit>
        <trans-unit id="faacdf06edb7c58723e21b75966b5a1b4848e52f" translate="yes" xml:space="preserve">
          <source>When disabled, it behaves as usual and it will ignore any further &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; instruction.</source>
          <target state="translated">禁用后，它将照常运行，并且将忽略任何其他&lt;a href=&quot;#next_break_fits/2&quot;&gt; &lt;code&gt;next_break_fits/2&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="df8c82e750351f095aeb40cc4f1edb723ac71be5" translate="yes" xml:space="preserve">
          <source>When discussing module attributes in earlier chapters, we mentioned how they can be used as temporary storage. That&amp;rsquo;s exactly the property we will apply in this section.</source>
          <target state="translated">在前面的章节中讨论模块属性时，我们提到了如何将它们用作临时存储。这正是我们将在本节中应用的属性。</target>
        </trans-unit>
        <trans-unit id="c15d7561c822ee6973742c8650d791962bc9201f" translate="yes" xml:space="preserve">
          <source>When documenting a function, argument names are inferred by the compiler. For example:</source>
          <target state="translated">当记录一个函数时,参数名是由编译器推断的。例如:</target>
        </trans-unit>
        <trans-unit id="578a9a5990bc02bf442dcb9647e96d1e0deec47f" translate="yes" xml:space="preserve">
          <source>When given a module name, it finds its BEAM code and reads the docs from it.</source>
          <target state="translated">当给定一个模块名称时,它就会找到它的BEAM代码,并从中读取docs。</target>
        </trans-unit>
        <trans-unit id="fef5c83aff7999db3d06dac86bd9f0184effdcaa" translate="yes" xml:space="preserve">
          <source>When given a path to a &lt;code&gt;.beam&lt;/code&gt; file, it will load the docs directly from that file.</source>
          <target state="translated">当指定 &lt;code&gt;.beam&lt;/code&gt; 文件的路径时，它将直接从该文件加载文档。</target>
        </trans-unit>
        <trans-unit id="39fc62509ca6e8c4e6300100effd1de2d15c28d7" translate="yes" xml:space="preserve">
          <source>When going through this getting started guide, it is common to have questions; after all, that is part of the learning process! There are many places maintained by the community where you can ask questions, here are some of them:</source>
          <target state="translated">当经历这个入门指南时,有问题是很正常的,毕竟,这是学习过程的一部分。在社区维护的许多地方,你可以提出问题,以下是其中的一些。</target>
        </trans-unit>
        <trans-unit id="d74bd70d54c9a0f941a337c706cfb743de945220" translate="yes" xml:space="preserve">
          <source>When implementing a protocol for a struct, the &lt;code&gt;:for&lt;/code&gt; option can be omitted if the &lt;code&gt;defimpl&lt;/code&gt; call is inside the module that defines the struct:</source>
          <target state="translated">为结构体实现协议时，如果 &lt;code&gt;defimpl&lt;/code&gt; 调用位于定义结构体的模块内部，则可以忽略 &lt;code&gt;:for&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="f9b91bfc2c95c3c008e57c050ff6b2e440fc4814" translate="yes" xml:space="preserve">
          <source>When invoked like this:</source>
          <target state="translated">当调用这样的。</target>
        </trans-unit>
        <trans-unit id="9ea6ac5c2582bc339cde7241b58f3b81346c4c24" translate="yes" xml:space="preserve">
          <source>When invoked with no options, &lt;code&gt;use Bitwise&lt;/code&gt; is equivalent to &lt;code&gt;import Bitwise&lt;/code&gt;.</source>
          <target state="translated">不带任何选项调用时， &lt;code&gt;use Bitwise&lt;/code&gt; 等效于 &lt;code&gt;import Bitwise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6479c4e04d60a2979f5fdc435c3db7673d78eb7c" translate="yes" xml:space="preserve">
          <source>When invoked, &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; halts the compilation of the caller until the module given to &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</source>
          <target state="translated">调用时，&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;停止调用程序的编译，直到为&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;提供的模块可用或当前项目的所有文件都已编译。如果编译完成且模块不可用，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="060c4e9baf5bbf6d685865db22ba844114868707" translate="yes" xml:space="preserve">
          <source>When invoking &lt;code&gt;Adder.add(1, 2)&lt;/code&gt;, you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above:</source>
          <target state="translated">调用 &lt;code&gt;Adder.add(1, 2)&lt;/code&gt; ，您会在shell中收到一条消息，撬动给定的环境。通过允许它，shell将被重置，并且您可以从上面访问所有变量和词法范围：</target>
        </trans-unit>
        <trans-unit id="7c9d5f385e194f5b34e40a73b8a3fada81a0e11a" translate="yes" xml:space="preserve">
          <source>When just a module is provided, the function is assumed to be &lt;code&gt;__on_definition__/6&lt;/code&gt;.</source>
          <target state="translated">仅提供模块时，该函数假定为 &lt;code&gt;__on_definition__/6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09bb8abc825d51b9e7d13312b08810361ca96b5f" translate="yes" xml:space="preserve">
          <source>When just a module is provided, the function/macro is assumed to be &lt;code&gt;__before_compile__/1&lt;/code&gt;.</source>
          <target state="translated">如果仅提供模块，则假定函数/宏为 &lt;code&gt;__before_compile__/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad041e4ced692624cb8e72a2915dff6522835e48" translate="yes" xml:space="preserve">
          <source>When no match is found, an empty list is returned and the update function is never called</source>
          <target state="translated">当没有找到匹配项时,将返回一个空列表,并且永远不会调用更新函数。</target>
        </trans-unit>
        <trans-unit id="668ead62f46a113515691eea47cd9cf416c22eb2" translate="yes" xml:space="preserve">
          <source>When no type is specified, the default is &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">如果未指定类型，则默认值为 &lt;code&gt;integer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3588217aa9bf0907adc5bc95772d644058750365" translate="yes" xml:space="preserve">
          <source>When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:</source>
          <target state="translated">当其中一个键是函数时,就会调用该函数。在下面的例子中,我们使用一个函数来获取和递增一个列表中的所有年龄。</target>
        </trans-unit>
        <trans-unit id="5dac029eee48d3ec58bc7974618e8728bcdcde33" translate="yes" xml:space="preserve">
          <source>When only the module name is given, it is equivalent to &lt;code&gt;{Stack, []}&lt;/code&gt;. By replacing the map specification by &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; or &lt;code&gt;Stack&lt;/code&gt;, we keep the child specification encapsulated in the &lt;code&gt;Stack&lt;/code&gt; module, using the default implementation defined by &lt;code&gt;use GenServer&lt;/code&gt;. We can now share our &lt;code&gt;Stack&lt;/code&gt; worker with other developers and they can add it directly to their supervision tree without worrying about the low-level details of the worker.</source>
          <target state="translated">仅给出模块名称时，它等效于 &lt;code&gt;{Stack, []}&lt;/code&gt; 。通过用 &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; 或 &lt;code&gt;Stack&lt;/code&gt; 替换映射规范，我们 &lt;code&gt;use GenServer&lt;/code&gt; 定义的默认实现将子规范封装在 &lt;code&gt;Stack&lt;/code&gt; 模块中。现在，我们可以与其他开发人员共享我们的 &lt;code&gt;Stack&lt;/code&gt; worker，他们可以将其直接添加到他们的监督树中，而不必担心该worker的底层细节。</target>
        </trans-unit>
        <trans-unit id="766a963e79023140bf5452d976b11e3c509c178b" translate="yes" xml:space="preserve">
          <source>When parsing, it is common to list switches and their expected types:</source>
          <target state="translated">在解析时,通常会列出开关及其预期类型。</target>
        </trans-unit>
        <trans-unit id="36ba4e5102dee4d1f96eef0a95a3e5d29407d173" translate="yes" xml:space="preserve">
          <source>When possible, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; is going to use coloring for formatting guides. The formatting can be customized by configuring the Mix application either inside your project (in &lt;code&gt;config/config.exs&lt;/code&gt;) or by using the local config (in &lt;code&gt;~/.mix/config.exs&lt;/code&gt;).</source>
          <target state="translated">如果可能，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt;将使用颜色作为格式指南。可以通过在项目内部（在 &lt;code&gt;config/config.exs&lt;/code&gt; 中）配置Mix应用程序或通过使用本地配置（在 &lt;code&gt;~/.mix/config.exs&lt;/code&gt; ）配置自定义格式。</target>
        </trans-unit>
        <trans-unit id="39b3c58586f7e038e77e8a708b922775161fc839" translate="yes" xml:space="preserve">
          <source>When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via:</source>
          <target state="translated">打印文档时,IEx会将Markdown文档也转换为ANSI。可以通过以下方式配置颜色。</target>
        </trans-unit>
        <trans-unit id="7c863b8baf992c9eeaa45fd095854ed9c7455c95" translate="yes" xml:space="preserve">
          <source>When quoting more complex expressions, we can see that the code is represented in such tuples, which are often nested inside each other in a structure resembling a tree. Many languages would call such representations an Abstract Syntax Tree (AST). Elixir calls them quoted expressions:</source>
          <target state="translated">当引用比较复杂的表达式时,我们可以看到代码是用这样的图元组来表示的,这些图元组通常在类似树的结构中互相嵌套。很多语言会把这样的表示方式称为抽象语法树(AST)。Elixir称它们为引号表达式。</target>
        </trans-unit>
        <trans-unit id="c4d26099302c23e48a1daa30a35aa4a09ff99a4d" translate="yes" xml:space="preserve">
          <source>When registering an attribute, two options can be given:</source>
          <target state="translated">注册属性时,可以给出两个选项。</target>
        </trans-unit>
        <trans-unit id="152f951b5158b67a3861b2b73b9a954063842f97" translate="yes" xml:space="preserve">
          <source>When replying from another process the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should exit if the other process exits without replying as the caller will be blocking awaiting a reply.</source>
          <target state="translated">当从另一个进程回复时，如果另一个进程退出而没有回复，则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;应该退出，因为调用者将阻塞等待回复。</target>
        </trans-unit>
        <trans-unit id="cc7fe0445fd913951bee3f58c7983b860e7114ee" translate="yes" xml:space="preserve">
          <source>When representing code points in bytes, we need to encode them somehow. Elixir chose the UTF-8 encoding as its main and default encoding. When we say a string is a UTF-8 encoded binary, we mean a string is a bunch of bytes organized in a way to represent certain code points, as specified by the UTF-8 encoding.</source>
          <target state="translated">当用字节表示码点时,我们需要以某种方式对它们进行编码。Elixir选择了UTF-8编码作为其主要和默认的编码。当我们说一个字符串是UTF-8编码的二进制时,我们的意思是一个字符串是由一堆字节组织起来的,按照UTF-8编码规定的方式来表示某些码点。</target>
        </trans-unit>
        <trans-unit id="8ba73e420e82fea09e21f152498ecd62bd2084ae" translate="yes" xml:space="preserve">
          <source>When setting up Pry inside a code defined by macros, such as:</source>
          <target state="translated">当在宏定义的代码内设置Pry时,如。</target>
        </trans-unit>
        <trans-unit id="5399bba4547032d1977ec734b465b9404b2e7555" translate="yes" xml:space="preserve">
          <source>When starting a supervisor, we pass a list of child specifications. Those specifications are maps that tell how the supervisor should start, stop and restart each of its children:</source>
          <target state="translated">当启动一个监督器时,我们会传递一个子规范的列表。这些规格是告诉监督者应该如何启动、停止和重新启动其每个子程序的映射。</target>
        </trans-unit>
        <trans-unit id="1afde91db5c18401a3ba6a5f7263520825af971b" translate="yes" xml:space="preserve">
          <source>When starting processes during your tests, we should always prefer to use &lt;code&gt;start_supervised!&lt;/code&gt;. We recommend you to change the &lt;code&gt;setup&lt;/code&gt; block in &lt;code&gt;bucket_test.exs&lt;/code&gt; to use &lt;code&gt;start_supervised!&lt;/code&gt; too.</source>
          <target state="translated">在测试过程中启动进程时，我们应该始终喜欢使用 &lt;code&gt;start_supervised!&lt;/code&gt; 。我们建议您将 &lt;code&gt;bucket_test.exs&lt;/code&gt; 中的 &lt;code&gt;setup&lt;/code&gt; 块更改为使用 &lt;code&gt;start_supervised!&lt;/code&gt; 太。</target>
        </trans-unit>
        <trans-unit id="da73f42a24fcc99f2f1dc5fa7376c2637e2c1445" translate="yes" xml:space="preserve">
          <source>When starting, IEx looks for a local &lt;code&gt;.iex.exs&lt;/code&gt; file (located in the current working directory), then a global one (located at &lt;code&gt;~/.iex.exs&lt;/code&gt;) and loads the first one it finds (if any). The code in the loaded &lt;code&gt;.iex.exs&lt;/code&gt; file is evaluated in the shell's context. So, for instance, any modules that are loaded or variables that are bound in the &lt;code&gt;.iex.exs&lt;/code&gt; file will be available in the shell after it has booted.</source>
          <target state="translated">启动时， &lt;code&gt;.iex.exs&lt;/code&gt; 先查找一个本地.iex.exs文件（位于当前工作目录中），然后是一个全局文件（位于 &lt;code&gt;~/.iex.exs&lt;/code&gt; ）并加载找到的第一个文件（如果有）。在外壳的上下文中评估已加载的 &lt;code&gt;.iex.exs&lt;/code&gt; 文件中的代码。因此，例如，任何已加载的模块或 &lt;code&gt;.iex.exs&lt;/code&gt; 文件中绑定的变量在启动后将在外壳中可用。</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">停止时,应用程序仍在加载。</target>
        </trans-unit>
        <trans-unit id="44fc4934aad1c4836563f8ccabbe822e5d3c33b8" translate="yes" xml:space="preserve">
          <source>When streamed, each task will emit &lt;code&gt;{:ok, value}&lt;/code&gt; upon successful completion or &lt;code&gt;{:exit, reason}&lt;/code&gt; if the caller is trapping exits. The order of results depends on the value of the &lt;code&gt;:ordered&lt;/code&gt; option.</source>
          <target state="translated">流式传输时，每个任务将在成功完成时发出 &lt;code&gt;{:ok, value}&lt;/code&gt; &lt;code&gt;{:exit, reason}&lt;/code&gt; 如果调用者正在捕获退出则将发出{：exit，reason}。结果的顺序取决于 &lt;code&gt;:ordered&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="e967fe555e7491d14ab10c0651fa2c10f01bf7c1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:allow_pre&lt;/code&gt; option is set &lt;code&gt;false&lt;/code&gt; in &lt;a href=&quot;version#match?/3&quot;&gt;&lt;code&gt;Version.match?/3&lt;/code&gt;&lt;/a&gt;, the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex &lt;code&gt;:allow_pre&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;. See the table below for examples.</source>
          <target state="translated">在&lt;a href=&quot;version#match?/3&quot;&gt; &lt;code&gt;Version.match?/3&lt;/code&gt; &lt;/a&gt;中将 &lt;code&gt;:allow_pre&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; 时，除非操作数是预发行版本，否则该要求将不与预发行版本匹配。默认设置是始终允许预发布，但请注意，在Hex中 &lt;code&gt;:allow_pre&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。有关示例，请参见下表。</target>
        </trans-unit>
        <trans-unit id="e79f5cbe356a7cdfd1f05e8dc80bced38e7f448e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:reduce&lt;/code&gt; key is given, its value is used as the initial accumulator and the &lt;code&gt;do&lt;/code&gt; block must be changed to use &lt;code&gt;-&amp;gt;&lt;/code&gt; clauses, where the left side of &lt;code&gt;-&amp;gt;&lt;/code&gt; receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned.</source>
          <target state="translated">当 &lt;code&gt;:reduce&lt;/code&gt; 键给出，其值被用作初始蓄能器和 &lt;code&gt;do&lt;/code&gt; 块必须改变，以利用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 条款，其中的左侧 &lt;code&gt;-&amp;gt;&lt;/code&gt; 接收在右边的前一次迭代的累积值和表达端必须返回新的累加器值。一旦没有更多元素，则返回最终的累加值。如果根本没有任何元素，则返回初始累加器值。</target>
        </trans-unit>
        <trans-unit id="f46f7e3c553c02ae7fead96311a793a3ad633924" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:switches&lt;/code&gt; option is given, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt; will attempt to parse unknown switches:</source>
          <target state="translated">当给出 &lt;code&gt;:switches&lt;/code&gt; 选项时，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt;将尝试解析未知的开关：</target>
        </trans-unit>
        <trans-unit id="55710b0d4d5aaa7e5939c1b4abb2051161b46e72" translate="yes" xml:space="preserve">
          <source>When the code is executed, it will ask you for permission to be introspected.</source>
          <target state="translated">当代码被执行时,它会询问你是否允许被反省。</target>
        </trans-unit>
        <trans-unit id="82d07e6f76ba2457b4bdb703973a237fe29a00b6" translate="yes" xml:space="preserve">
          <source>When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned. First the one that happens first, then the one that happens after.</source>
          <target state="translated">当日期时间不明确时--例如在从夏季到冬季的转换过程中--将返回两个可能的有效日期时间。首先是先发生的那个,然后是后发生的那个。</target>
        </trans-unit>
        <trans-unit id="f9d4126199b613c96db5fb36b204b9cc8e74af41" translate="yes" xml:space="preserve">
          <source>When the default &lt;code&gt;:infer&lt;/code&gt;, the binary will be printed as a string if it is printable, otherwise in bit syntax. See &lt;a href=&quot;string#printable?/1&quot;&gt;&lt;code&gt;String.printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a string is printable.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;:infer&lt;/code&gt; ，则二进制文件将以字符串形式打印（如果可以打印的话），否则将以位语法显示。请参阅&lt;a href=&quot;string#printable?/1&quot;&gt; &lt;code&gt;String.printable?/1&lt;/code&gt; &lt;/a&gt;了解何时可打印字符串。</target>
        </trans-unit>
        <trans-unit id="c612d63a8c1c933d7e8881534968752ca12fe8ad" translate="yes" xml:space="preserve">
          <source>When the default &lt;code&gt;:infer&lt;/code&gt;, the list will be printed as a charlist if it is printable, otherwise as list. See &lt;a href=&quot;list#ascii_printable?/1&quot;&gt;&lt;code&gt;List.ascii_printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a charlist is printable.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;:infer&lt;/code&gt; ，则列表可以打印为字符列表（如果可以打印），否则为列表。请参阅&lt;a href=&quot;list#ascii_printable?/1&quot;&gt; &lt;code&gt;List.ascii_printable?/1&lt;/code&gt; &lt;/a&gt;以了解何时可以打印字符列表。</target>
        </trans-unit>
        <trans-unit id="63da4232661d88a7f868999ff25b659010b2900b" translate="yes" xml:space="preserve">
          <source>When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation:</source>
          <target state="translated">当用点来调用匿名函数时,只有一个操作数,但还是用后缀符号来写。</target>
        </trans-unit>
        <trans-unit id="813d1cf0e1831ccf812556df6497fde20b090d3e" translate="yes" xml:space="preserve">
          <source>When the head element of aliases is the atom &lt;code&gt;:Elixir&lt;/code&gt;, no expansion happens.</source>
          <target state="translated">当别名的首部元素是原子 &lt;code&gt;:Elixir&lt;/code&gt; 时，不会发生扩展。</target>
        </trans-unit>
        <trans-unit id="f0ef8773abae5ce961ca6ed9da9a8a5ea8e088bb" translate="yes" xml:space="preserve">
          <source>When the index is out of bounds, &lt;code&gt;nil&lt;/code&gt; is returned and the update function is never called:</source>
          <target state="translated">当索引超出范围时，将返回 &lt;code&gt;nil&lt;/code&gt; ，并且永远不会调用update函数：</target>
        </trans-unit>
        <trans-unit id="5f5f70104ffa9c3038871840751c7a53ef2fbfc2" translate="yes" xml:space="preserve">
          <source>When the key in a key-value pair is an atom, the &lt;code&gt;key: value&lt;/code&gt; shorthand syntax can be used (as in many other special forms), provided key-value pairs are put at the end:</source>
          <target state="translated">当键值对中的键是原子时，只要将键值对放在末尾，就可以使用 &lt;code&gt;key: value&lt;/code&gt; 简写语法（和许多其他特殊形式一样）：</target>
        </trans-unit>
        <trans-unit id="92c67571369cee66bfcb870b4d12b5e27452cada" translate="yes" xml:space="preserve">
          <source>When the list is empty, it will match the final clause which returns the final result of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">当列表为空时，它将匹配final子句，该子句返回最终结果 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5b4de75025c76c7c3c9aeb02b7ac4bb35649ea3" translate="yes" xml:space="preserve">
          <source>When the pattern is a regular expression, one can give &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt; in the &lt;code&gt;replacement&lt;/code&gt; string to access a specific capture in the regular expression:</source>
          <target state="translated">当模式为正则表达式时，可以在 &lt;code&gt;replacement&lt;/code&gt; 字符串中使用 &lt;code&gt;\N&lt;/code&gt; 或 &lt;code&gt;\g{N}&lt;/code&gt; 来访问正则表达式中的特定捕获：</target>
        </trans-unit>
        <trans-unit id="b7076cba8ae612bc5e423136274345c6b60737f6" translate="yes" xml:space="preserve">
          <source>When the pattern used is a regular expression, the string is split using &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果使用的模式是正则表达式，则使用&lt;a href=&quot;regex#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt;拆分字符串。</target>
        </trans-unit>
        <trans-unit id="2bcb0dcaed7090610e887c1da375fc63e59c4ed5" translate="yes" xml:space="preserve">
          <source>When the provided &lt;code&gt;datetime&lt;/code&gt; is ambiguous a tuple with &lt;code&gt;:ambiguous&lt;/code&gt; and two possible periods. The periods in the list are sorted with the first element being the one that begins first.</source>
          <target state="translated">当提供的 &lt;code&gt;datetime&lt;/code&gt; 时间不明确时，一个元组将具有 &lt;code&gt;:ambiguous&lt;/code&gt; 和两个可能的句点。列表中的句点以第一个元素为最开始的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="1fe6365d1946f947546f751bcb7719dfb32d0adb" translate="yes" xml:space="preserve">
          <source>When the provided &lt;code&gt;datetime&lt;/code&gt; is in a gap - for instance during the &quot;spring forward&quot; when going from winter time to summer time, a tuple with &lt;code&gt;:gap&lt;/code&gt; and two periods with limits are returned in a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime with a limit for when the period ends (wall time). The second nested two-tuple is the period just after the gap and a datetime (wall time) for when the period begins just after the gap.</source>
          <target state="translated">当提供的 &lt;code&gt;datetime&lt;/code&gt; 时间有间隔时（例如，从冬季到夏季，在&amp;ldquo;春季前进&amp;rdquo; 期间），则在嵌套的元组中返回带 &lt;code&gt;:gap&lt;/code&gt; 的元组和两个带限制的句点。第一个嵌套的二元组是间隔之前的时间段，以及天真的日期时间，该时间段具有结束时间的限制（墙上时间）。第二个嵌套的二元组是间隔之后的时间段和间隔之后开始的时间的日期时间（墙上时间）。</target>
        </trans-unit>
        <trans-unit id="16bf87a94f168db6511f12fcea262e81e29d5db5" translate="yes" xml:space="preserve">
          <source>When the replacement is a function, the function may have arity N where each argument maps to a capture, with the first argument being the whole match. If the function expects more arguments than captures found, the remaining arguments will receive &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">当替换是一个函数时，该函数可能具有Arity N，其中每个参数都映射到捕获，第一个参数是整个匹配项。如果函数期望的参数多于找到的捕获，则其余的参数将收到 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d53459d48259932870dbd718ef131fa6f3ed113" translate="yes" xml:space="preserve">
          <source>When the result is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;timer_ref&lt;/code&gt; could not be found. This can be either because the timer expired, because it has already been canceled, or because &lt;code&gt;timer_ref&lt;/code&gt; never corresponded to a timer.</source>
          <target state="translated">当结果为 &lt;code&gt;false&lt;/code&gt; 时，找不到与 &lt;code&gt;timer_ref&lt;/code&gt; 对应的计时器。这可能是因为计时器已过期，已被取消，或者是因为 &lt;code&gt;timer_ref&lt;/code&gt; 从未对应于计时器。</target>
        </trans-unit>
        <trans-unit id="deb5988708af4ca0fcbf0783c8851fe13e767117" translate="yes" xml:space="preserve">
          <source>When the result is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;timer_ref&lt;/code&gt; could not be found. This can happen either because the timer expired, because it has already been canceled, or because &lt;code&gt;timer_ref&lt;/code&gt; never corresponded to a timer.</source>
          <target state="translated">当结果为 &lt;code&gt;false&lt;/code&gt; 时，找不到与 &lt;code&gt;timer_ref&lt;/code&gt; 对应的计时器。这可能是由于计时器已过期，已被取消或由于 &lt;code&gt;timer_ref&lt;/code&gt; 从未对应于计时器而发生的。</target>
        </trans-unit>
        <trans-unit id="eb5c37eb9c975eba0eed810f4d26cf67ddbb9330" translate="yes" xml:space="preserve">
          <source>When the result is an integer, it represents the time in milliseconds left until the timer will expire.</source>
          <target state="translated">当结果为整数时,它表示距离定时器过期所剩的时间(毫秒)。</target>
        </trans-unit>
        <trans-unit id="ef76de8d282a8dcdcfd2491f1293a65f2b819189" translate="yes" xml:space="preserve">
          <source>When the result is an integer, it represents the time in milliseconds left until the timer would have expired.</source>
          <target state="translated">当结果为整数时,它表示距离定时器过期所剩的时间(毫秒)。</target>
        </trans-unit>
        <trans-unit id="1566d52e1acb479a0372d677819f4198f3d5870e" translate="yes" xml:space="preserve">
          <source>When the right side is an alias (i.e. starts with uppercase), we get instead:</source>
          <target state="translated">当右边是别名时(即以大写字母开头),我们得到的是。</target>
        </trans-unit>
        <trans-unit id="ee4bde23a133e54a751c0692953befb4cdb97b52" translate="yes" xml:space="preserve">
          <source>When the supervisor starts, it traverses all child specifications and then starts each child in the order they are defined. This is done by calling the function defined under the &lt;code&gt;:start&lt;/code&gt; key in the child specification and typically defaults to &lt;code&gt;start_link/1&lt;/code&gt;.</source>
          <target state="translated">主管启动时，它将遍历所有子级规范，然后按照定义的顺序启动每个子级。这可以通过调用子规范中 &lt;code&gt;:start&lt;/code&gt; 键下定义的函数来完成，通常默认为 &lt;code&gt;start_link/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="817e44489d4b19557f85e9b1054b8dfb286e7d81" translate="yes" xml:space="preserve">
          <source>When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap.</source>
          <target state="translated">当墙上的时间有空隙时--例如在春天,时钟向前转动时--空隙前的最新有效日期时间和空隙后的第一个有效日期时间。</target>
        </trans-unit>
        <trans-unit id="89a704e085523c022c1474f3a583587729c0f099" translate="yes" xml:space="preserve">
          <source>When there is a need to &amp;ldquo;print&amp;rdquo; a more complex data structure, one can use the &lt;code&gt;inspect&lt;/code&gt; function, based on the &lt;code&gt;Inspect&lt;/code&gt; protocol:</source>
          <target state="translated">当需要&amp;ldquo;打印&amp;rdquo;更复杂的数据结构时，可以使用基于 &lt;code&gt;Inspect&lt;/code&gt; 协议的 &lt;code&gt;inspect&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="f6bf9502e79fba8ed757c65a9e4d357939c0a70a" translate="yes" xml:space="preserve">
          <source>When this task runs, it will check if the source code has been modified. If it has changed, &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; will be run to check remote dispatches. You can force checking regardless of modification time by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">运行此任务时，它将检查源代码是否已被修改。如果已更改，则将运行&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;以检查远程调度。您可以通过 &lt;code&gt;--force&lt;/code&gt; 选项来强制执行检查，而不考虑修改时间。</target>
        </trans-unit>
        <trans-unit id="62fb7e7f6c7c81758b59e89afd8071bd6483f45b" translate="yes" xml:space="preserve">
          <source>When this task runs, it will check the modification time of every file, and if it has changed, the file will be compiled. Files will be compiled in the same source directory with a .erl extension. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">运行此任务时，它将检查每个文件的修改时间，如果已更改，则将编译该文件。文件将在相同的源目录中以.erl扩展名进行编译。您可以通过传递 &lt;code&gt;--force&lt;/code&gt; 选项来强制编译，而不考虑修改时间。</target>
        </trans-unit>
        <trans-unit id="a07869d83b2ef9bc609cce62a844eb6447e810ed" translate="yes" xml:space="preserve">
          <source>When this task runs, it will first check the modification times of all files to be compiled and if they haven't been changed since the last compilation, it will not compile them. If any of them have changed, it compiles everything.</source>
          <target state="translated">当这个任务运行时,它将首先检查所有要编译的文件的修改时间,如果它们自上次编译后没有改变,它将不编译它们。如果其中任何一个文件发生了变化,它就会编译所有的文件。</target>
        </trans-unit>
        <trans-unit id="a9276e8b40c6df87535bcdb85fb17cf65c3e220e" translate="yes" xml:space="preserve">
          <source>When true, the &lt;code&gt;:start_permanent&lt;/code&gt; option starts your application in permanent mode, which means the Erlang VM will crash if your application&amp;rsquo;s supervision tree shuts down. Notice we don&amp;rsquo;t want this behaviour in dev and test because it is useful to keep the VM instance running in those environments for troubleshooting purposes.</source>
          <target state="translated">如果为true， &lt;code&gt;:start_permanent&lt;/code&gt; 选项将以永久模式启动应用程序，这意味着如果应用程序的监视树关闭，则Erlang VM将崩溃。请注意，我们不希望在开发和测试中出现此行为，因为将VM实例保持在这些环境中运行以进行故障排除很有用。</target>
        </trans-unit>
        <trans-unit id="4f9a1ee40840757a2da20f98dce9c92498f29f26" translate="yes" xml:space="preserve">
          <source>When two processes are linked, each one receives exit signals from the other (see also &lt;a href=&quot;#exit/2&quot;&gt;&lt;code&gt;exit/2&lt;/code&gt;&lt;/a&gt;). Let's assume &lt;code&gt;pid1&lt;/code&gt; and &lt;code&gt;pid2&lt;/code&gt; are linked. If &lt;code&gt;pid2&lt;/code&gt; exits with a reason other than &lt;code&gt;:normal&lt;/code&gt; (which is also the exit reason used when a process finishes its job) and &lt;code&gt;pid1&lt;/code&gt; is not trapping exits (see &lt;a href=&quot;#flag/2&quot;&gt;&lt;code&gt;flag/2&lt;/code&gt;&lt;/a&gt;), then &lt;code&gt;pid1&lt;/code&gt; will exit with the same reason as &lt;code&gt;pid2&lt;/code&gt; and in turn emit an exit signal to all its other linked processes. The behaviour when &lt;code&gt;pid1&lt;/code&gt; is trapping exits is described in &lt;a href=&quot;#exit/2&quot;&gt;&lt;code&gt;exit/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当两个进程链接在一起时，每个进程都从另一个进程接收退出信号（另请参见&lt;a href=&quot;#exit/2&quot;&gt; &lt;code&gt;exit/2&lt;/code&gt; &lt;/a&gt;）。假设 &lt;code&gt;pid1&lt;/code&gt; 和 &lt;code&gt;pid2&lt;/code&gt; 是链接的。如果 &lt;code&gt;pid2&lt;/code&gt; 退出的原因不是 &lt;code&gt;:normal&lt;/code&gt; （这也是进程完成其工作时使用的退出原因），并且 &lt;code&gt;pid1&lt;/code&gt; 没有捕获退出（请参见&lt;a href=&quot;#flag/2&quot;&gt; &lt;code&gt;flag/2&lt;/code&gt; &lt;/a&gt;），则 &lt;code&gt;pid1&lt;/code&gt; 退出的原因与 &lt;code&gt;pid2&lt;/code&gt; 和in向所有其他链接进程发出退出信号。在 &lt;code&gt;pid1&lt;/code&gt; &lt;a href=&quot;#exit/2&quot;&gt; &lt;code&gt;exit/2&lt;/code&gt; &lt;/a&gt;描述了pid1捕获出口时的行为。</target>
        </trans-unit>
        <trans-unit id="6dba6643714479395ecdc7d925db56d3c380711c" translate="yes" xml:space="preserve">
          <source>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</source>
          <target state="translated">当在引号内使用时,标志着给定的别名不应该被卫生化。这意味着当宏展开时,别名将被展开。</target>
        </trans-unit>
        <trans-unit id="4d695de6a4e80464b19dd42d8515878b64fc9241" translate="yes" xml:space="preserve">
          <source>When used inside quoting, marks that the given variable should not be hygienized.</source>
          <target state="translated">当在引号内使用时,标志着给定的变量不应该被卫生化。</target>
        </trans-unit>
        <trans-unit id="3c4b1b7c86346563bb3b33da3cb8c7c9d963d7d2" translate="yes" xml:space="preserve">
          <source>When used, it accepts the following options:</source>
          <target state="translated">使用时,它接受以下选项:</target>
        </trans-unit>
        <trans-unit id="11eb21eebbb18164e016f1c4fa392ee88b44b563" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;:spawn_executable&lt;/code&gt;, the list of arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option as done above. For the full list of options, see the documentation for the Erlang function &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;:spawn_executable&lt;/code&gt; 时，可以通过 &lt;code&gt;:args&lt;/code&gt; 选项传递参数列表，如上所述。有关选项的完整列表，请参见Erlang函数的文档&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt; &lt;code&gt;:erlang.open_port/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0532ce4ac8a5c6ad2c52a2b5f9b566e548e2dcfa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;location: :keep&lt;/code&gt; and invalid arguments are given to &lt;code&gt;Sample.add/2&lt;/code&gt;, the stacktrace information will point to the file and line inside the quote. Without &lt;code&gt;location: :keep&lt;/code&gt;, the error is reported to where &lt;code&gt;defadd&lt;/code&gt; was invoked. &lt;code&gt;location: :keep&lt;/code&gt; affects only definitions inside the quote.</source>
          <target state="translated">当使用 &lt;code&gt;location: :keep&lt;/code&gt; 和无效参数给 &lt;code&gt;Sample.add/2&lt;/code&gt; 时，stacktrace信息将指向文件和引号内的行。如果没有 &lt;code&gt;location: :keep&lt;/code&gt; ，则将错误报告到调用 &lt;code&gt;defadd&lt;/code&gt; 的位置。 &lt;code&gt;location: :keep&lt;/code&gt; 仅影响引号内的定义。</target>
        </trans-unit>
        <trans-unit id="e32b79e90bc5213e96ed814396349030773cd138" translate="yes" xml:space="preserve">
          <source>When using Mix, you can run all tests in a describe block by name:</source>
          <target state="translated">当使用Mix时,你可以按名称运行描述块中的所有测试。</target>
        </trans-unit>
        <trans-unit id="16d7eda521d9dd1f3f49ae777c0c270bd44b3016" translate="yes" xml:space="preserve">
          <source>When using default values, one must be careful to avoid overlapping function definitions. Consider the following example:</source>
          <target state="translated">使用默认值时,必须注意避免函数定义的重叠。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="d6654b695e9969cbc5da309dbf219f84c2b28aa9" translate="yes" xml:space="preserve">
          <source>When using ranges:</source>
          <target state="translated">使用范围时。</target>
        </trans-unit>
        <trans-unit id="f4e0ef31ee1ee252959b73eca8437281378616ce" translate="yes" xml:space="preserve">
          <source>When using the update syntax (&lt;code&gt;|&lt;/code&gt;), the</source>
          <target state="translated">使用更新语法（ &lt;code&gt;|&lt;/code&gt; ）时，</target>
        </trans-unit>
        <trans-unit id="bb7e8b90b84bd9cda137c3810fbc290000ca2f96" translate="yes" xml:space="preserve">
          <source>When using umbrella applications, it is important to have a clear boundary between them. Our upcoming &lt;code&gt;kv_server&lt;/code&gt; must only access public APIs defined in &lt;code&gt;kv&lt;/code&gt;. Think of your umbrella apps as any other dependency or even Elixir itself: you can only access what is public and documented. Reaching into private functionality in your dependencies is a poor practice that will eventually cause your code to break when a new version is up.</source>
          <target state="translated">使用伞形应用程序时，重要的是要在它们之间有明确的界限。我们即将发布的 &lt;code&gt;kv_server&lt;/code&gt; 必须仅访问 &lt;code&gt;kv&lt;/code&gt; 中定义的公共API 。将伞应用程序视为任何其他依赖项，或者甚至将其视为Elixir本身：您只能访问公开和记录的内容。在依赖项中使用私有功能是一种不好的做法，最终会导致您的代码在新版本启动时中断。</target>
        </trans-unit>
        <trans-unit id="2c98c890488f972198844594710fa00dc3ba20fe" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;use Application&lt;/code&gt;, we may define a couple functions, similar to when we used &lt;code&gt;Supervisor&lt;/code&gt; or &lt;code&gt;GenServer&lt;/code&gt;. This time we only had to define a &lt;code&gt;start/2&lt;/code&gt; function. The &lt;code&gt;Application&lt;/code&gt; behaviour also has a &lt;code&gt;stop/1&lt;/code&gt; callback, but it is rarely used in practice, you can check the documentation for more information.</source>
          <target state="translated">当我们 &lt;code&gt;use Application&lt;/code&gt; ，我们可以定义一对夫妇的功能，类似于当我们用 &lt;code&gt;Supervisor&lt;/code&gt; 或 &lt;code&gt;GenServer&lt;/code&gt; 。这次我们只需要定义一个 &lt;code&gt;start/2&lt;/code&gt; 函数。该 &lt;code&gt;Application&lt;/code&gt; 的行为也有一个 &lt;code&gt;stop/1&lt;/code&gt; 的回调，但在实际中很少使用，可以检查文档的详细信息。</target>
        </trans-unit>
        <trans-unit id="5b7058116f53f35239e2356beda55ec8034d3117" translate="yes" xml:space="preserve">
          <source>When we added &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; as a child of &lt;code&gt;KV.Supervisor&lt;/code&gt;, we began to have supervisors that supervise other supervisors, forming so-called &amp;ldquo;supervision trees&amp;rdquo;.</source>
          <target state="translated">当我们将 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 添加为KV.Supervisor的子 &lt;code&gt;KV.Supervisor&lt;/code&gt; ，我们开始有了可以监督其他主管的主管，形成了所谓的&amp;ldquo;监督树&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="db2b543292422d67aa65cb035608589347e4a67a" translate="yes" xml:space="preserve">
          <source>When we call:</source>
          <target state="translated">当我们打电话。</target>
        </trans-unit>
        <trans-unit id="c84904df1425d5dd9decb2d480d2165f3ad3805e" translate="yes" xml:space="preserve">
          <source>When we discussed maps, we showed how we can access and update the fields of a map. The same techniques (and the same syntax) apply to structs as well:</source>
          <target state="translated">当我们讨论地图时,我们展示了如何访问和更新地图的字段。同样的技术(和同样的语法)也适用于结构。</target>
        </trans-unit>
        <trans-unit id="3ffe287a4ee207e44ff584189d143d006b07e2c8" translate="yes" xml:space="preserve">
          <source>When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original &lt;code&gt;.beam&lt;/code&gt; file in disk, probably the one where the first definition of the module came from, does not change at all.</source>
          <target state="translated">当我们在IEx中重新加载模块时，我们将重新编译模块源代码，从而更新其在内存中的内容。磁盘中的原始 &lt;code&gt;.beam&lt;/code&gt; 文件（可能是该模块的第一个定义所来自的文件）根本没有改变。</target>
        </trans-unit>
        <trans-unit id="b1b7e04a25c2e9cd8adc060ab8f333c0cb576192" translate="yes" xml:space="preserve">
          <source>When we say &amp;ldquo;project&amp;rdquo; you should think about Mix. Mix is the tool that manages your project. It knows how to compile your project, test your project and more. It also knows how to compile and start the application relevant to your project.</source>
          <target state="translated">当我们说&amp;ldquo;项目&amp;rdquo;时，您应该考虑Mix。Mix是管理项目的工具。它知道如何编译项目，测试项目等等。它还知道如何编译和启动与项目相关的应用程序。</target>
        </trans-unit>
        <trans-unit id="3988e99c0afba10ffddaaa653e055af9c86b1e3c" translate="yes" xml:space="preserve">
          <source>When we talk about applications, we talk about</source>
          <target state="translated">当我们谈论应用时,我们谈论的是</target>
        </trans-unit>
        <trans-unit id="a55806641c97dbdd5be2b9424fe4617aa3a3d6ed" translate="yes" xml:space="preserve">
          <source>When working on actual projects, the build tool called &lt;code&gt;mix&lt;/code&gt; will be responsible for compiling and setting up the proper paths for you. For learning purposes, Elixir also supports a scripted mode which is more flexible and does not generate any compiled artifacts.</source>
          <target state="translated">在实际项目中工作时，称为 &lt;code&gt;mix&lt;/code&gt; 的构建工具将负责为您编译和设置正确的路径。出于学习目的，Elixir还支持一种脚本化模式，该模式更加灵活并且不会生成任何已编译的工件。</target>
        </trans-unit>
        <trans-unit id="4555a713f8f0c47c0fda29090ee90e21d1fb8b9c" translate="yes" xml:space="preserve">
          <source>When working with Elixir projects, using the Mix build tool, you may see the output as follows:</source>
          <target state="translated">当使用Mix构建工具处理Elixir项目时,你可能会看到如下的输出。</target>
        </trans-unit>
        <trans-unit id="4a7946a9fc0373dce56fd29a1a8c3afde30edd76" translate="yes" xml:space="preserve">
          <source>When writing documentation:</source>
          <target state="translated">编写文件时。</target>
        </trans-unit>
        <trans-unit id="7edece0006beadc23495370d9f59344caf5ee8ed" translate="yes" xml:space="preserve">
          <source>When written in multiline form and pasted into IEx this valid expression produces a syntax error:</source>
          <target state="translated">当以多行形式编写并粘贴到 IEx 中时,这个有效表达式会产生语法错误。</target>
        </trans-unit>
        <trans-unit id="4f88c1b7710727be1867ef5ea07ba0b0d812f06b" translate="yes" xml:space="preserve">
          <source>When you absolutely have to use a macro, make sure that a macro is not the only way the user can interface with your library and keep the amount of code generated by a macro to a minimum. For example, the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module provides &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#debug/2&quot;&gt;&lt;code&gt;Logger.debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; and friends as macros that are capable of extracting environment information, but a low-level mechanism for logging is still available with &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您绝对必须使用宏时，请确保宏不是​​用户与您的库进行交互的唯一方式，并且将由宏生成的代码量减至最少。例如，&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;模块提供&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#debug/2&quot;&gt; &lt;code&gt;Logger.debug/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt;和朋友，其能够提取环境信息的宏，但低电平机构用于记录仍然可用与&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1638480636a28cbc011e903bfbe6652cd3090fd" translate="yes" xml:space="preserve">
          <source>When you install Elixir, besides getting the &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;elixirc&lt;/code&gt; and &lt;code&gt;iex&lt;/code&gt; executables, you also get an executable Elixir script named &lt;code&gt;mix&lt;/code&gt;.</source>
          <target state="translated">安装Elixir时，除了获得 &lt;code&gt;elixir&lt;/code&gt; ， &lt;code&gt;elixirc&lt;/code&gt; 和 &lt;code&gt;iex&lt;/code&gt; 可执行文件外，您还将获得名为 &lt;code&gt;mix&lt;/code&gt; 的可执行Elixir脚本。</target>
        </trans-unit>
        <trans-unit id="51445e6109f96044711e17778f35ac063ea05da9" translate="yes" xml:space="preserve">
          <source>When you install Elixir, you will have three new executables: &lt;code&gt;iex&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;elixirc&lt;/code&gt;. If you compiled Elixir from source or are using a packaged version, you can find these inside the &lt;code&gt;bin&lt;/code&gt; directory.</source>
          <target state="translated">安装Elixir时，将具有三个新的可执行文件： &lt;code&gt;iex&lt;/code&gt; ， &lt;code&gt;elixir&lt;/code&gt; 和 &lt;code&gt;elixirc&lt;/code&gt; 。如果您从源代码编译Elixir或使用打包版本，则可以在 &lt;code&gt;bin&lt;/code&gt; 目录中找到它们。</target>
        </trans-unit>
        <trans-unit id="64869216e949cc8b1e4b90b19a8879d36be5ed8e" translate="yes" xml:space="preserve">
          <source>When you invoke a function in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, the first argument is usually a collection that must implement this protocol. For example, the expression:</source>
          <target state="translated">在&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中调用函数时，第一个参数通常是必须实现此协议的集合。例如，表达式：</target>
        </trans-unit>
        <trans-unit id="fdc24bbab3bae3af51622412701d86913a237da3" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;iex -S mix&lt;/code&gt;, it is equivalent to running &lt;code&gt;iex -S mix run&lt;/code&gt;. So whenever you need to pass more options to Mix when starting IEx, it&amp;rsquo;s a matter of typing &lt;code&gt;iex -S mix run&lt;/code&gt; and then passing any options the &lt;code&gt;run&lt;/code&gt; command accepts. You can find more information by running &lt;code&gt;mix help run&lt;/code&gt; in your shell.</source>
          <target state="translated">运行 &lt;code&gt;iex -S mix&lt;/code&gt; 运行时，等效于运行 &lt;code&gt;iex -S mix run&lt;/code&gt; 运行。因此，每当需要在启动IEx时将更多选项传递给Mix时，只需键入 &lt;code&gt;iex -S mix run&lt;/code&gt; ，然后传递 &lt;code&gt;run&lt;/code&gt; 命令接受的所有选项即可。您可以通过在shell中运行 &lt;code&gt;mix help run&lt;/code&gt; 来找到更多信息。</target>
        </trans-unit>
        <trans-unit id="d6917ee6422f5bcc16f5dc4c157fbd880bb1f29c" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;length&lt;/code&gt;, the operation runs in linear time (&quot;O(n) time&quot;) because the entire data structure has to be traversed.</source>
          <target state="translated">当您看到 &lt;code&gt;length&lt;/code&gt; 时，该操作将以线性时间（&amp;ldquo; O（n）时间&amp;rdquo;）运行，因为必须遍历整个数据结构。</target>
        </trans-unit>
        <trans-unit id="f1098aafc109071152ed8dbff4d163fca52f7b5c" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;size&lt;/code&gt; in a function name, it means the operation runs in constant time (also written as &quot;O(1) time&quot;) because the size is stored alongside the data structure.</source>
          <target state="translated">当您在函数名称中看到 &lt;code&gt;size&lt;/code&gt; 时，这意味着该操作将以恒定的时间（也称为&amp;ldquo; O（1）时间&amp;rdquo;）运行，因为该大小与数据结构一起存储。</target>
        </trans-unit>
        <trans-unit id="32066dced8bf4260f74494c122dd24f5d3dcc107" translate="yes" xml:space="preserve">
          <source>When you start the debugger, a Graphical User Interface will open in your machine. We call &lt;code&gt;:int.ni(Example)&lt;/code&gt; to prepare our module for debugging and then add a breakpoint to line 3 with &lt;code&gt;:int.break(Example, 3)&lt;/code&gt;. After we call our function, we can see our process with break status in the debugger:</source>
          <target state="translated">启动调试器时，计算机上将打开图形用户界面。我们调用 &lt;code&gt;:int.ni(Example)&lt;/code&gt; 准备我们的模块以进行调试，然后使用 &lt;code&gt;:int.break(Example, 3)&lt;/code&gt; 在第3行添加一个断点。调用函数后，我们可以在调试器中看到带有中断状态的进程：</target>
        </trans-unit>
        <trans-unit id="d0343678ea7a046b13fb51d1726454724348b519" translate="yes" xml:space="preserve">
          <source>Whenever an expression iterator sees a &lt;code&gt;:.&lt;/code&gt; as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.</source>
          <target state="translated">每当表达式迭代器看到 &lt;code&gt;:.&lt;/code&gt; 作为元组键，可以确定它代表一个调用，并且列表中的第二个参数是一个原子。</target>
        </trans-unit>
        <trans-unit id="a39390368c995ec3d4e4d59a6dd560fa4603c1d1" translate="yes" xml:space="preserve">
          <source>Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, Mix automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;. But can we customize what happens when our application starts? As a matter of fact, we can! To do so, we define an application callback.</source>
          <target state="translated">每当我们调用 &lt;code&gt;iex -S mix&lt;/code&gt; 时，Mix都会通过调用 &lt;code&gt;Application.start(:kv)&lt;/code&gt; 自动启动我们的应用程序。但是，我们可以自定义应用程序启动时会发生什么吗？事实上，我们可以！为此，我们定义了一个应用程序回调。</target>
        </trans-unit>
        <trans-unit id="46426dcf93a27179d19a66c1a5ce7b3db0ca84b2" translate="yes" xml:space="preserve">
          <source>Whenever you need a key-value store, maps are the &amp;ldquo;go to&amp;rdquo; data structure in Elixir. A map is created using the &lt;code&gt;%{}&lt;/code&gt; syntax:</source>
          <target state="translated">每当您需要键值存储时，映射就是Elixir中的&amp;ldquo;转到&amp;rdquo;数据结构。使用 &lt;code&gt;%{}&lt;/code&gt; 语法创建地图：</target>
        </trans-unit>
        <trans-unit id="4a4aa4923bd36be72dbe6f53c5381b13f315dd6a" translate="yes" xml:space="preserve">
          <source>Whenever you start a new process, Elixir annotates the parent of that process through the &lt;code&gt;$ancestors&lt;/code&gt; key in the process dictionary. This is often used to track the hierarchy inside a supervision tree.</source>
          <target state="translated">每当您启动新流程时，Elixir都会通过流程字典中的 &lt;code&gt;$ancestors&lt;/code&gt; 键注释该流程的父级。这通常用于跟踪监管树内的层次结构。</target>
        </trans-unit>
        <trans-unit id="367c170da441f4a9f1911cc978e43bc196c54b25" translate="yes" xml:space="preserve">
          <source>Where &quot;remsh&quot; means &quot;remote shell&quot;. In general, Elixir supports:</source>
          <target state="translated">其中 &quot;remsh &quot;是指 &quot;远程shell&quot;。一般来说,Elixir支持:</target>
        </trans-unit>
        <trans-unit id="a611ce6f5741ed9a3522b8e9c3227865053830c5" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;amp;clean_extra/1&lt;/code&gt; would be a function in your &lt;code&gt;mix.exs&lt;/code&gt; with extra cleanup logic.</source>
          <target state="translated">其中， &lt;code&gt;&amp;amp;clean_extra/1&lt;/code&gt; 将是具有额外清除逻辑的 &lt;code&gt;mix.exs&lt;/code&gt; 中的函数。</target>
        </trans-unit>
        <trans-unit id="cbce7e222b32979ca5deb65f6d63d9c44de3c563" translate="yes" xml:space="preserve">
          <source>Where guards can be used</source>
          <target state="translated">可以使用防护罩的地方</target>
        </trans-unit>
        <trans-unit id="0320ac9cef49bf6819f7f5ea05026898ca882a24" translate="yes" xml:space="preserve">
          <source>Where to go next</source>
          <target state="translated">下一步去哪里</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="e24583f0fef7d30e388aaa6bc96a6e3a7f4ff25e" translate="yes" xml:space="preserve">
          <source>Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behaviour, and that's why one of the first things you need to keep in mind when it comes to macros is to &lt;strong&gt;not unquote the same value more than once&lt;/strong&gt;.</source>
          <target state="translated">它两次调用该函数，解释了为什么我们两次获得打印值！在大多数情况下，这实际上是出乎意料的行为，这就是为什么在涉及宏时需要记住的第一件事之一就是&lt;strong&gt;不要多次取消对相同值的引用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="610c7400d727b3d0294243a02c10a7e75f931042" translate="yes" xml:space="preserve">
          <source>Which is equivalent to:</source>
          <target state="translated">这就相当于:</target>
        </trans-unit>
        <trans-unit id="ee6f87c8bf9b769a438c8d350f11dd19efcc7631" translate="yes" xml:space="preserve">
          <source>Which is not the expected result. For this, we use &lt;code&gt;unquote&lt;/code&gt;:</source>
          <target state="translated">这不是预期的结果。为此，我们使用 &lt;code&gt;unquote&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9a1cee54eca00c3fd762b45316feb118ef6e1149" translate="yes" xml:space="preserve">
          <source>Which is similar to:</source>
          <target state="translated">这与。</target>
        </trans-unit>
        <trans-unit id="e7611a003e06cd6cbd9a976440d116ba106999f7" translate="yes" xml:space="preserve">
          <source>Which means we store the following relationships:</source>
          <target state="translated">这意味着我们存储了以下关系。</target>
        </trans-unit>
        <trans-unit id="865f281221c86013dcb74eebdc4c8949d79babac" translate="yes" xml:space="preserve">
          <source>Which technique is best between deriving and falling back to any depends on the use case but, given Elixir developers prefer explicit over implicit, you may see many libraries pushing towards the &lt;code&gt;@derive&lt;/code&gt; approach.</source>
          <target state="translated">在派生和退回任何方法之间最好的方法取决于用例，但是，鉴于Elixir开发人员更喜欢显式方法而不是隐式方法，您可能会看到许多库都在向 &lt;code&gt;@derive&lt;/code&gt; 方法推进。</target>
        </trans-unit>
        <trans-unit id="cbd5368b4b8756e1f8174c9b573f020295a6bdf8" translate="yes" xml:space="preserve">
          <source>Which would then return:</source>
          <target state="translated">哪会再回来。</target>
        </trans-unit>
        <trans-unit id="f2107dde537e90ae147db95c27b028e84ef989ac" translate="yes" xml:space="preserve">
          <source>Which, as we have seen above, is the same as:</source>
          <target state="translated">这一点,我们在上面已经看到,与。</target>
        </trans-unit>
        <trans-unit id="f101833a43dae895e5bf1409c2a111fb485239ce" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; accepts binaries as documents, those are counted by binary size. On the other hand, &lt;code&gt;string&lt;/code&gt; documents are measured in terms of graphemes towards the document size.</source>
          <target state="translated">尽管&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;接受二进制文件作为文档，但这些文件是按二进制大小进行计数的。另一方面， &lt;code&gt;string&lt;/code&gt; 文档是根据字素朝向文档大小进行测量的。</target>
        </trans-unit>
        <trans-unit id="b70763808f360802ddcc8101a8762434700f5098" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compile_file/2&quot;&gt;&lt;code&gt;compile_file/2&lt;/code&gt;&lt;/a&gt; return the loaded modules and their bytecode, &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt; simply evaluates the file contents and returns the evaluation result and its bindings (exactly the same return value as &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">当&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#compile_file/2&quot;&gt; &lt;code&gt;compile_file/2&lt;/code&gt; &lt;/a&gt;返回加载的模块及其字节码时，&lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt;只是评估文件内容并返回评估结果及其绑定（与&lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt;完全相同的返回值）。</target>
        </trans-unit>
        <trans-unit id="69f666585bc38ea0ba4d6c87139b5a142a30dbda" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;IO.inspect/2&lt;/code&gt; is static, Elixir&amp;rsquo;s interactive shell provides more dynamic ways to interact with debugged code.</source>
          <target state="translated">尽管 &lt;code&gt;IO.inspect/2&lt;/code&gt; 是静态的，但Elixir的交互式外壳提供了更多与调试代码进行交互的动态方式。</target>
        </trans-unit>
        <trans-unit id="7e891083b7d17b20f59e0508fe476751a1ce5918" translate="yes" xml:space="preserve">
          <source>While Elixir often adds compatibility to new Erlang/OTP versions on released branches, such as support for Erlang/OTP 20 in v1.4.5, those releases usually contain the minimum changes for Elixir to run without errors. Only the next minor release, in this case v1.5.0, does effectively leverage the new features provided by the latest Erlang/OTP release.</source>
          <target state="translated">虽然Elixir经常在发布的分支上增加对新的Erlang/OTP版本的兼容性,例如在v1.4.5中对Erlang/OTP 20的支持,但这些版本通常包含了Elixir无错误运行所需的最小改动。只有下一个次要版本(在本例中为v1.5.0)才会有效地利用最新的Erlang/OTP版本提供的新特性。</target>
        </trans-unit>
        <trans-unit id="eff1c985b3cb7364d839bf596145ef8ecd3f8919" translate="yes" xml:space="preserve">
          <source>While Elixir provides a lot of useful built-in types, it&amp;rsquo;s convenient to define custom types when appropriate. This can be done when defining modules through the &lt;code&gt;@type&lt;/code&gt; directive.</source>
          <target state="translated">虽然Elixir提供了许多有用的内置类型，但在适当时定义自定义类型很方便。通过 &lt;code&gt;@type&lt;/code&gt; 指令定义模块时可以完成此操作。</target>
        </trans-unit>
        <trans-unit id="f39197ea7ae756757201361ad80eae1acf823b98" translate="yes" xml:space="preserve">
          <source>While in the shell, you may find the helper &lt;code&gt;flush/0&lt;/code&gt; quite useful. It flushes and prints all the messages in the mailbox.</source>
          <target state="translated">在shell中时，您可能会发现helper &lt;code&gt;flush/0&lt;/code&gt; 非常有用。它刷新并打印邮箱中的所有消息。</target>
        </trans-unit>
        <trans-unit id="948ac309c3d49e3090e9e6268ff5be5c675c1703" translate="yes" xml:space="preserve">
          <source>While it's possible to create custom guards with macros, it's recommended to define them using &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; which perform additional compile-time checks.</source>
          <target state="translated">尽管可以使用宏创建自定义防护，但建议使用 &lt;code&gt;defguard&lt;/code&gt; 和 &lt;code&gt;defguardp&lt;/code&gt; 定义它们，以执行附加的编译时检查。</target>
        </trans-unit>
        <trans-unit id="e7e0433a97bbf2cdfd8497fc775fd566e71fc6d7" translate="yes" xml:space="preserve">
          <source>While it's possible to define unused operators (such as &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;) and to &quot;override&quot; predefined operators (such as &lt;code&gt;+&lt;/code&gt;), the Elixir community generally discourages this. Custom-defined operators can be really hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.</source>
          <target state="translated">虽然可以定义未使用的运算符（例如 &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; ）并&amp;ldquo;覆盖&amp;rdquo;预定义的运算符（例如 &lt;code&gt;+&lt;/code&gt; ），但Elixir社区通常不鼓励这样做。由于自定义运算符没有像函数那样的描述性名称，因此很难理解甚至难以理解。也就是说，某些特定情况或自定义域特定语言（DSL）可以证明这些做法是合理的。</target>
        </trans-unit>
        <trans-unit id="c1664df92c33ce10f9a7ba24fd21afbe69d81240" translate="yes" xml:space="preserve">
          <source>While most UNIX command line tools will exit once its communication channels are closed, not all command line applications will do so. While we encourage graceful termination by detecting if stdin/stdout has been closed, we do not always have control over how third-party software terminates. In those cases, you can wrap the application in a script that checks for stdin. Here is such script in Bash:</source>
          <target state="translated">虽然大多数UNIX命令行工具会在通信通道关闭后退出,但并非所有命令行应用程序都会这样做。虽然我们鼓励通过检测stdin/stdout是否被关闭来实现优雅的终止,但我们并不总是能够控制第三方软件的终止方式。在这种情况下,你可以用一个检查stdin的脚本来包装应用程序。下面是这样一个Bash脚本。</target>
        </trans-unit>
        <trans-unit id="c24b8592b76f97129134ab89ec36ef2cec5eef0d" translate="yes" xml:space="preserve">
          <source>While one could also simply pass the &lt;code&gt;Counter&lt;/code&gt; as a child to the supervisor, such as:</source>
          <target state="translated">虽然也可以简单地将 &lt;code&gt;Counter&lt;/code&gt; 作为孩子带给主管，例如：</target>
        </trans-unit>
        <trans-unit id="36362758dcc4b69a05743ba01ffd490227415dec" translate="yes" xml:space="preserve">
          <source>While other languages would require us to catch/handle exceptions, in Elixir we are actually fine with letting processes fail because we expect supervisors to properly restart our systems. &amp;ldquo;Failing fast&amp;rdquo; is a common philosophy when writing Elixir software!</source>
          <target state="translated">虽然其他语言会要求我们捕获/处理异常，但在Elixir中，让进程失败实际上是可以的，因为我们希望管理员可以正确地重新启动系统。编写Elixir软件时，&amp;ldquo;快速失败&amp;rdquo;是一种普遍的哲学！</target>
        </trans-unit>
        <trans-unit id="c9106e7acb9d2328494ccc8d8a5df4f1acd5cc0a" translate="yes" xml:space="preserve">
          <source>While our application will have many buckets, it will only have a single registry. Therefore, whenever we start the registry, we want to give it a unique name so we can reach out to it from anywhere. We do so by passing a &lt;code&gt;:name&lt;/code&gt; option to &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;.</source>
          <target state="translated">虽然我们的应用程序将有很多存储桶，但它只有一个注册表。因此，无论何时启动注册表，我们都想给它一个唯一的名称，以便我们可以从任何地方访问它。 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 我们将 &lt;code&gt;:name&lt;/code&gt; 选项传递给KV.Registry.start_link / 1。</target>
        </trans-unit>
        <trans-unit id="d03d6f908abf2f49bad588eb8e92749e481618fa" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:into&lt;/code&gt; option allows us to customize the comprehension behaviour to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough.</source>
          <target state="translated">尽管 &lt;code&gt;:into&lt;/code&gt; 选项使我们可以针对给定的数据类型自定义理解行为，例如将所有值放入映射或二进制文件内，但这并不总是足够的。</target>
        </trans-unit>
        <trans-unit id="6345023f6486581ef0b981a5089ae13410fe1184" translate="yes" xml:space="preserve">
          <source>While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive.</source>
          <target state="translated">虽然上面的方法很直接,但它的缺点是至少要遍历两次数据。如果你希望用长字符串作为输入,这可能会相当昂贵。</target>
        </trans-unit>
        <trans-unit id="840e583e1f6163396e5057152a0935787393ec16" translate="yes" xml:space="preserve">
          <source>While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line:</source>
          <target state="translated">虽然上面的代码是完全有效的,但你可能更喜欢在函数体中匹配结构变量,以便将定义保持在单行。</target>
        </trans-unit>
        <trans-unit id="594620887d3476dbc120a3dcf5aefda1302d7ecc" translate="yes" xml:space="preserve">
          <source>While the process executes, the user will no longer have control of the shell. If you would rather start a new shell, use &lt;a href=&quot;#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">在执行过程时，用户将不再具有对Shell的控制权。如果您想启动一个新的shell，请改用&lt;a href=&quot;#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6df62c1d796ef891e72a49f10459138b633ef075" translate="yes" xml:space="preserve">
          <source>While there are situations where &lt;code&gt;use SomeModule&lt;/code&gt; is necessary, &lt;code&gt;use&lt;/code&gt; should be skipped when all it does is to &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;alias&lt;/code&gt; other modules. In a nutshell, &lt;code&gt;alias&lt;/code&gt; should be preferred, as it is simpler and clearer than &lt;code&gt;import&lt;/code&gt;, while &lt;code&gt;import&lt;/code&gt; is simpler and clearer than &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">在某些情况下，有必要 &lt;code&gt;use SomeModule&lt;/code&gt; 时，如果它仅用于 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;alias&lt;/code&gt; 其他模块，则应跳过 &lt;code&gt;use&lt;/code&gt; 。简而言之，应该首选 &lt;code&gt;alias&lt;/code&gt; ，因为别名比 &lt;code&gt;import&lt;/code&gt; 更简单，更清晰，而 &lt;code&gt;import&lt;/code&gt; 比 &lt;code&gt;use&lt;/code&gt; 更简单，更清晰。</target>
        </trans-unit>
        <trans-unit id="d97357490e634679e794ba42b3a549cc212d1dc8" translate="yes" xml:space="preserve">
          <source>While this is much better (we don't traverse &lt;code&gt;full&lt;/code&gt; twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; as there is no chance we will slice in the middle of a code point made of more than one byte:</source>
          <target state="translated">虽然这是好多了（我们不经过 &lt;code&gt;full&lt;/code&gt; 的两倍），它可能仍有待提高。在这种情况下，由于我们要从字符串中提取子字符串，因此可以使用&lt;a href=&quot;kernel#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; ,&lt;/a&gt;因为我们没有机会在由多个字节组成的代码点中间进行切片：</target>
        </trans-unit>
        <trans-unit id="75f74a8391ce99585979dcb3ea3da1ba4ddd33bc" translate="yes" xml:space="preserve">
          <source>While this module provides low-level conveniences to work with processes, developers typically use abstractions such as &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.</source>
          <target state="translated">尽管此模块为处理流程提供了低级的便利，但是开发人员通常使用诸如&lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 之类的&lt;/a&gt;抽象来构建系统，并使用此模块来收集信息，捕获出口，链接和监视。</target>
        </trans-unit>
        <trans-unit id="a071dda30d6568da003d94170f89a1641edfdf91" translate="yes" xml:space="preserve">
          <source>Why Collectable?</source>
          <target state="translated">为什么要收藏?</target>
        </trans-unit>
        <trans-unit id="f270b96c3543da962579aa2699fc04cd9390a45e" translate="yes" xml:space="preserve">
          <source>Why guards</source>
          <target state="translated">为什么警卫</target>
        </trans-unit>
        <trans-unit id="ac2b2f0f6634fb63d223d0af7e5a4015de1afa2d" translate="yes" xml:space="preserve">
          <source>Why releases?</source>
          <target state="translated">为什么要释放?</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">将输出。</target>
        </trans-unit>
        <trans-unit id="4a6579723b59ea9ec64425d88abb4286c7dc38a8" translate="yes" xml:space="preserve">
          <source>Will print error messages as:</source>
          <target state="translated">将错误信息打印为:</target>
        </trans-unit>
        <trans-unit id="2c2d1ea901f0c8101ac1fb5fa6dc20b9daa197c0" translate="yes" xml:space="preserve">
          <source>Will print:</source>
          <target state="translated">会打印。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="1a372a68c5c6b9fd1a5e4e4c5bcb2c19d9a03783" translate="yes" xml:space="preserve">
          <source>Wiring it all up</source>
          <target state="translated">把它全部接好</target>
        </trans-unit>
        <trans-unit id="eaa42b7f9ff6889d59bad6d54129d3f6d5da9e0a" translate="yes" xml:space="preserve">
          <source>With a map:</source>
          <target state="translated">有地图。</target>
        </trans-unit>
        <trans-unit id="a142feb38b538cb226883f4345967e240846e8bf" translate="yes" xml:space="preserve">
          <source>With binaries, strings, and charlists out of the way, it is time to talk about key-value data structures.</source>
          <target state="translated">说完了二进制、字符串和charlists,该说说键值数据结构了。</target>
        </trans-unit>
        <trans-unit id="59fd9c1ee5c1fccc62b073ebeed75c6eddbbabca" translate="yes" xml:space="preserve">
          <source>With doctests at hand, it is your turn to make tests pass! Once you&amp;rsquo;re ready, you can compare your work with our solution below:</source>
          <target state="translated">有了doctest，现在轮到您通过测试了！准备就绪后，您可以将您的工作与以下解决方案进行比较：</target>
        </trans-unit>
        <trans-unit id="b38a50a17602e3ae1b8ccc46a98a4df1a0b23f69" translate="yes" xml:space="preserve">
          <source>With duplicated keys:</source>
          <target state="translated">有重复的钥匙。</target>
        </trans-unit>
        <trans-unit id="1c9488c5cddccfc0e6d1f32c489b748da64fc121" translate="yes" xml:space="preserve">
          <source>With our umbrella project up and running, it is time to start writing our server.</source>
          <target state="translated">随着我们的保护伞项目的建立和运行,是时候开始编写我们的服务器了。</target>
        </trans-unit>
        <trans-unit id="bba0c8a7b1ce199c741a002ee4243a9062d9953c" translate="yes" xml:space="preserve">
          <source>With releases, we were able to &amp;ldquo;cut different slices&amp;rdquo; of our project and prepared them to run in production, all packaged into a single directory.</source>
          <target state="translated">使用发行版，我们能够&amp;ldquo;切割项目&amp;rdquo;的不同部分，并准备将它们投入生产，所有这些都打包在一个目录中。</target>
        </trans-unit>
        <trans-unit id="bf24bbb528b37b8d16045a9f34a9f10b8ac013e4" translate="yes" xml:space="preserve">
          <source>With the functions in this module, we can concatenate different elements together and render them:</source>
          <target state="translated">通过这个模块中的函数,我们可以将不同的元素连接在一起并进行渲染。</target>
        </trans-unit>
        <trans-unit id="6df754d5302c1520a37db5161561c19578b70a47" translate="yes" xml:space="preserve">
          <source>With the routing table integrated, we have made a lot of progress in building our distributed key-value store but, up to this point, the routing table is still hard-coded. In the next chapter, we will learn how to make the routing table configurable and how to package our application for production.</source>
          <target state="translated">在集成了路由表之后,我们在构建分布式键值存储方面取得了很大的进展,但是,到目前为止,路由表仍然是硬编码的。在下一章,我们将学习如何使路由表可配置,以及如何将我们的应用打包生产。</target>
        </trans-unit>
        <trans-unit id="88aff34e4e29570c42b886cfc99dae57378c1a87" translate="yes" xml:space="preserve">
          <source>With the test properly tagged, we can now check if the node is alive on the network and, if not, we can exclude all distributed tests. Open up &lt;code&gt;test/test_helper.exs&lt;/code&gt; inside the &lt;code&gt;:kv&lt;/code&gt; application and add the following:</source>
          <target state="translated">正确标记了测试之后，我们现在可以检查该节点在网络上是否处于活动状态，如果没有，则可以排除所有分布式测试。在 &lt;code&gt;:kv&lt;/code&gt; 应用程序中打开 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 并添加以下内容：</target>
        </trans-unit>
        <trans-unit id="03febbe4cffd47fca872e3ab15ba7ecbf3f2a521" translate="yes" xml:space="preserve">
          <source>With this change, we are saying that we want to run &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; as a task. We are hardcoding the port for now but this could be changed in a few ways, for example, by reading the port out of the system environment when starting the application:</source>
          <target state="translated">进行此更改后，我们说要作为任务运行 &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; 。我们现在正在对端口进行硬编码，但是可以通过几种方式进行更改，例如，通过在启动应用程序时从系统环境中读取端口：</target>
        </trans-unit>
        <trans-unit id="b2d8587ac4dfb38f02ee844e25af23cb384021e5" translate="yes" xml:space="preserve">
          <source>With this in place, the supervisor will now start &lt;code&gt;KV.Registry&lt;/code&gt; by calling &lt;code&gt;KV.Registry.start_link(name: KV.Registry)&lt;/code&gt;.</source>
          <target state="translated">通过此操作，主管现在将通过调用 &lt;code&gt;KV.Registry.start_link(name: KV.Registry)&lt;/code&gt; 启动 &lt;code&gt;KV.Registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cfddebea7643fbc375079abeb732751424fdccb" translate="yes" xml:space="preserve">
          <source>With this knowledge in hand, let&amp;rsquo;s finally write the routing code.</source>
          <target state="translated">掌握了这些知识之后，让我们最后编写路由代码。</target>
        </trans-unit>
        <trans-unit id="e176657aed44574ca37e82fff8791f0963853823" translate="yes" xml:space="preserve">
          <source>With this simple integration test, we start to see why integration tests may be slow. Not only this test cannot run asynchronously, it also requires the expensive setup of stopping and starting the &lt;code&gt;:kv&lt;/code&gt; application. In fact, your test suite may even fail and run into timeouts. If that&amp;rsquo;s the case, you can tweak the &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; call to pass a third argument, which is the timeout in milliseconds. In the next chapter we will learn about application configuration, which we could use to make the timeout configurable, if desired.</source>
          <target state="translated">通过这个简单的集成测试，我们开始了解为什么集成测试可能很慢。此测试不仅不能异步运行，而且还需要昂贵的设置来停止和启动 &lt;code&gt;:kv&lt;/code&gt; 应用程序。实际上，您的测试套件甚至可能失败并超时。在这种情况下，您可以调整 &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; 调用以传递第三个参数，该超时值以毫秒为单位。在下一章中，我们将学习有关应用程序配置的信息，如果需要的话，我们可以使用它来配置超时。</target>
        </trans-unit>
        <trans-unit id="69a061adaee410870f0db0130a4863eb959d29cc" translate="yes" xml:space="preserve">
          <source>With this, we have covered the main modules that Elixir provides for dealing with IO and interacting with the file system. In the next sections, we will discuss some advanced topics regarding IO. Those sections are not necessary in order to write Elixir code, so feel free to skip them, but they do provide a nice overview of how the IO system is implemented in the</source>
          <target state="translated">至此,我们已经介绍了Elixir提供的处理IO和与文件系统交互的主要模块。在接下来的章节中,我们将讨论一些有关IO的高级主题。这些章节对于编写Elixir代码来说并不是必需的,所以可以随意跳过,但它们确实提供了一个很好的概述,说明IO系统是如何在Elixir中实现的。</target>
        </trans-unit>
        <trans-unit id="590e5438c7cb8d996880074ea694c0f4ce03cc86" translate="yes" xml:space="preserve">
          <source>With this, we have finished our tour of Elixir modules. The last topic to cover is module attributes.</source>
          <target state="translated">至此,我们结束了对Elixir模块的参观。最后一个要讲的话题是模块属性。</target>
        </trans-unit>
        <trans-unit id="3977e5e25611957119fe9bd8093c06ae07247ece" translate="yes" xml:space="preserve">
          <source>With those lessons, we finish our introduction to macros. The next chapter is a brief discussion on DSLs that shows how we can mix macros and module attributes to annotate and extend modules and functions.</source>
          <target state="translated">通过这些课程,我们完成了对宏的介绍。下一章是关于DSL的简要讨论,展示了我们如何混合宏和模块属性来注释和扩展模块和函数。</target>
        </trans-unit>
        <trans-unit id="576386a4049c3f84e1e70ca63dc3a0583fd7ca02" translate="yes" xml:space="preserve">
          <source>WithClauseError</source>
          <target state="translated">WithClauseError</target>
        </trans-unit>
        <trans-unit id="531e8754d718662134036e0ed426d7e0605ed031" translate="yes" xml:space="preserve">
          <source>WithClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">WithClauseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ab0793176b49657e8d03d5f783b19379b3db349f" translate="yes" xml:space="preserve">
          <source>Without new lines, as seen below, ExUnit compiles it into a single doctest:</source>
          <target state="translated">没有新的行,如下图所示,ExUnit将其编译成一个doctest。</target>
        </trans-unit>
        <trans-unit id="11e35fb66328b6ede55b6b84c9357bd2414375bb" translate="yes" xml:space="preserve">
          <source>Word lists</source>
          <target state="translated">词表</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="translated">处理文件</target>
        </trans-unit>
        <trans-unit id="43c75eba4a76554736c3f35f9a22bf7076b21a6a" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#raise/1&quot;&gt;&lt;code&gt;raise/1&lt;/code&gt;&lt;/a&gt; but does not generate a new stacktrace.</source>
          <target state="translated">类似于&lt;a href=&quot;#raise/1&quot;&gt; &lt;code&gt;raise/1&lt;/code&gt; ,&lt;/a&gt;但不会生成新的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="134b6740811c97cd32f9b686cca4b898a98707e8" translate="yes" xml:space="preserve">
          <source>Works the same as &lt;a href=&quot;#async_stream/5&quot;&gt;&lt;code&gt;async_stream/5&lt;/code&gt;&lt;/a&gt; but with an anonymous function instead of a module-function-arguments tuple. &lt;code&gt;fun&lt;/code&gt; must be a one-arity anonymous function.</source>
          <target state="translated">与&lt;a href=&quot;#async_stream/5&quot;&gt; &lt;code&gt;async_stream/5&lt;/code&gt; &lt;/a&gt;相同，但具有匿名功能，而不是模块功能参数元组。 &lt;code&gt;fun&lt;/code&gt; 必须是单人匿名功能。</target>
        </trans-unit>
        <trans-unit id="e01cc30af27c867806feacb956d20799166447ec" translate="yes" xml:space="preserve">
          <source>Would be parsed as:</source>
          <target state="translated">将被解析为:</target>
        </trans-unit>
        <trans-unit id="ed68f33e0edd83622fdda96f013734e64b3797b8" translate="yes" xml:space="preserve">
          <source>Wrapping a keyword in quotes does not make it a string. Keywords are always atoms. If you use quotes when all characters are a valid part of a keyword without quotes, Elixir will warn.</source>
          <target state="translated">用引号包裹关键字并不意味着它就是一个字符串。关键词始终是原子。如果你在所有字符都是一个没有引号的关键字的有效部分时使用了引号,Elixir会发出警告。</target>
        </trans-unit>
        <trans-unit id="fc3aaaad1d5351a716bcfec3590a0c7aadfe5609" translate="yes" xml:space="preserve">
          <source>Wrapping the function name in single- or double-quotes is always a remote call. Therefore &lt;code&gt;Kernel.&quot;Foo&quot;&lt;/code&gt; will attempt to call the function &quot;Foo&quot; and not return the alias &lt;code&gt;Kernel.Foo&lt;/code&gt;. This is done by design as module names are more strict than function names.</source>
          <target state="translated">用单引号或双引号引起来的函数名称始终是一个远程调用。因此， &lt;code&gt;Kernel.&quot;Foo&quot;&lt;/code&gt; 将尝试调用函数&amp;ldquo; Foo&amp;rdquo;，而不返回别名 &lt;code&gt;Kernel.Foo&lt;/code&gt; 。这是通过设计完成的，因为模块名称比功能名称更严格。</target>
        </trans-unit>
        <trans-unit id="8dc389376346ac2c6054e49b93415804e45c3f9d" translate="yes" xml:space="preserve">
          <source>Wraps &lt;code&gt;collection&lt;/code&gt; in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; according to limit and contents.</source>
          <target state="translated">根据限制和内容在 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 包装 &lt;code&gt;collection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fd191283e143c09014d6b10f8babd586c4dd3ff" translate="yes" xml:space="preserve">
          <source>Wraps &lt;code&gt;term&lt;/code&gt; in a list if this is not list.</source>
          <target state="translated">如果不是列表，则将 &lt;code&gt;term&lt;/code&gt; 包装在列表中。</target>
        </trans-unit>
        <trans-unit id="871135f343b118a2e6897770ba0d353314ad4e26" translate="yes" xml:space="preserve">
          <source>Writable temporary directory, exception on error.</source>
          <target state="translated">可写临时目录,出错时异常。</target>
        </trans-unit>
        <trans-unit id="6d280821129e62362ceba6c4bff9e07a7b456feb" translate="yes" xml:space="preserve">
          <source>Writable temporary directory.</source>
          <target state="translated">可写的临时目录。</target>
        </trans-unit>
        <trans-unit id="6ffa32df712de6eb75f6b3eb5860d11f7743bc16" translate="yes" xml:space="preserve">
          <source>Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the &lt;a href=&quot;writing-documentation&quot;&gt;Writing Documentation&lt;/a&gt; guide for more information. Projects like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc&lt;/a&gt; can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports &quot;extra pages&quot;, like this one that you are reading. Such pages augment the documentation with tutorials, guides and references.</source>
          <target state="translated">编写文档。Elixir社区以将文档视为一流公民并让文档易于访问而感到自豪。图书馆通过提供完整的API文档以及其模块，类型和功能的示例来为现状做出贡献。有关更多信息，请参见&lt;a href=&quot;writing-documentation&quot;&gt;编写文档&lt;/a&gt;指南。诸如&lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc之类的&lt;/a&gt;项目可用于从文档生成HTML和EPUB文档。ExDoc还支持&amp;ldquo;额外页面&amp;rdquo;，例如您正在阅读的页面。这些页面增加了教程，指南和参考资料。</target>
        </trans-unit>
        <trans-unit id="c20c5c2676125559a686b163df005602f1f79cf9" translate="yes" xml:space="preserve">
          <source>Write macros responsibly</source>
          <target state="translated">负责任地编写宏</target>
        </trans-unit>
        <trans-unit id="c8a2eb88e34c563062857a754892c9fa2cee5ed9" translate="yes" xml:space="preserve">
          <source>Write tests. Elixir ships with a test-framework named &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;ExUnit&lt;/a&gt;. The project generated by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; includes sample tests and doctests.</source>
          <target state="translated">编写测试。Elixir附带了一个名为&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;ExUnit&lt;/a&gt;的测试框架。&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt;生成的项目包括样本测试和doctest。</target>
        </trans-unit>
        <trans-unit id="1feeacf656b90f330a6a489cf3b74d6b58d07ce7" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;chardata&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;chardata&lt;/code&gt; 写入给定的 &lt;code&gt;device&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b82357a7578553502291944537b9069cacc23ce" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;content&lt;/code&gt; to the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;content&lt;/code&gt; 写入文件 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b687301a3673e72e85385f60b8d3a4d244ea746" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;iodata&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;iodata&lt;/code&gt; 写入给定的 &lt;code&gt;device&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81c5649f21bfd5ad6a72c260c31465c5717dd093" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;item&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;, similar to &lt;a href=&quot;#write/2&quot;&gt;&lt;code&gt;write/2&lt;/code&gt;&lt;/a&gt;, but adds a newline at the end.</source>
          <target state="translated">将 &lt;code&gt;item&lt;/code&gt; 写入给定 &lt;code&gt;device&lt;/code&gt; ，类似于&lt;a href=&quot;#write/2&quot;&gt; &lt;code&gt;write/2&lt;/code&gt; &lt;/a&gt;，但在末尾添加换行符。</target>
        </trans-unit>
        <trans-unit id="91a0ede6abab1883ab37182f1281431e30f439b6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;message&lt;/code&gt; to stderr, along with the current stacktrace.</source>
          <target state="translated">将 &lt;code&gt;message&lt;/code&gt; 和当前的堆栈跟踪信息写入stderr。</target>
        </trans-unit>
        <trans-unit id="60b2773edfcfce0e6d9dca670d285a3e07d07034" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;message&lt;/code&gt; to stderr, along with the given &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;message&lt;/code&gt; 和给定的 &lt;code&gt;stacktrace&lt;/code&gt; 一起写到 stderr 。</target>
        </trans-unit>
        <trans-unit id="50ad9498b3d796e6083dcc801c9d470dfff4c6ff" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;a href=&quot;file.stat&quot;&gt;&lt;code&gt;File.Stat&lt;/code&gt;&lt;/a&gt; back to the file system at the given path. Returns &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">将给定的&lt;a href=&quot;file.stat&quot;&gt; &lt;code&gt;File.Stat&lt;/code&gt; &lt;/a&gt;写回到给定路径的文件系统。返回 &lt;code&gt;:ok&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dabb8334b6cbbc19635a160f00032f11eeb9962" translate="yes" xml:space="preserve">
          <source>Writing</source>
          <target state="translated">Writing</target>
        </trans-unit>
        <trans-unit id="131fd1dd1ce5d6ec0f6aa2acdfdd8f920515c873" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;@tag :distributed&lt;/code&gt; is equivalent to writing &lt;code&gt;@tag distributed: true&lt;/code&gt;.</source>
          <target state="translated">编写 &lt;code&gt;@tag :distributed&lt;/code&gt; 等效于编写 &lt;code&gt;@tag distributed: true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="469b1f8873498de485e6c8f565f8f7d313eb6b92" translate="yes" xml:space="preserve">
          <source>Writing Documentation</source>
          <target state="translated">撰写文件</target>
        </trans-unit>
        <trans-unit id="24d7c2c2e5b00b0086937c4765f3d3f34430d546" translate="yes" xml:space="preserve">
          <source>Writing code is only the first of many steps to publish a package. We strongly recommend developers to:</source>
          <target state="translated">编写代码只是发布一个包的许多步骤中的第一步。我们强烈建议开发者:</target>
        </trans-unit>
        <trans-unit id="f2f71f28a31e334663ab5d64232830d65131bffb" translate="yes" xml:space="preserve">
          <source>Writing the &lt;code&gt;empty_map?/1&lt;/code&gt; function by only using pattern matching would not be possible (as pattern matching on &lt;code&gt;%{}&lt;/code&gt; would match &lt;em&gt;every&lt;/em&gt; map, not empty maps).</source>
          <target state="translated">仅通过使用模式匹配来编写 &lt;code&gt;empty_map?/1&lt;/code&gt; 函数是不可能的（因为 &lt;code&gt;%{}&lt;/code&gt; 上的模式匹配将匹配&lt;em&gt;每个&lt;/em&gt;映射，而不是空映射）。</target>
        </trans-unit>
        <trans-unit id="0364f97e903a76eb2748323472186e449617cb88" translate="yes" xml:space="preserve">
          <source>Xref modes</source>
          <target state="translated">Xref模式</target>
        </trans-unit>
        <trans-unit id="ce0bf305bc11db00a7123b9e6e1e0d7aa8dcb7d2" translate="yes" xml:space="preserve">
          <source>Yes, it works! However, does it &lt;em&gt;scale&lt;/em&gt;?</source>
          <target state="translated">是的，它有效！但是，它可&lt;em&gt;扩展&lt;/em&gt;吗？</target>
        </trans-unit>
        <trans-unit id="5a20bc5d9e7b5ec9dd50e5b0a20cf3e3f7fd4d3a" translate="yes" xml:space="preserve">
          <source>Yields to multiple tasks in the given time interval.</source>
          <target state="translated">在给定的时间间隔内,对多个任务进行屈服。</target>
        </trans-unit>
        <trans-unit id="7494d61e6543878f2b2566cc12d19e025bd840c8" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;http://blog.plataformatec.com.br/2016/05/tracing-and-observing-your-remote-node/&quot;&gt;use Observer to introspect a remote node&lt;/a&gt;. This is one of the debugging techniques &lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;the Phoenix framework used to achieve 2 million connections on a single machine&lt;/a&gt;.</source>
          <target state="translated">您还可以&lt;a href=&quot;http://blog.plataformatec.com.br/2016/05/tracing-and-observing-your-remote-node/&quot;&gt;使用Observer自检远程节点&lt;/a&gt;。这是&lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;Phoenix框架用来在一台计算机上实现200万个连接&lt;/a&gt;的调试技术之一。</target>
        </trans-unit>
        <trans-unit id="06983d8881008548f22731727c340afa53a46d0f" translate="yes" xml:space="preserve">
          <source>You can also assign the struct name to &lt;code&gt;_&lt;/code&gt; when you want to check if something is a struct but you are not interested in its name:</source>
          <target state="translated">当您要检查某物是否为结构但您对其名称不感兴趣时​​，也可以将结构名称分配给 &lt;code&gt;_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5ffdb4ed015fd808bfdd98a224b2a3a3cb234c70" translate="yes" xml:space="preserve">
          <source>You can also configure the syntax colors, however, as desired:</source>
          <target state="translated">不过,你也可以根据需要配置语法颜色。</target>
        </trans-unit>
        <trans-unit id="8098b82db0ff3e423ec9c8c9b67f0b8a0bd2b3cb" translate="yes" xml:space="preserve">
          <source>You can also define your own errors by creating a module and using the &lt;code&gt;defexception&lt;/code&gt; construct inside it; this way, you&amp;rsquo;ll create an error with the same name as the module it&amp;rsquo;s defined in. The most common case is to define a custom exception with a message field:</source>
          <target state="translated">您还可以通过创建一个模块并在其中使用 &lt;code&gt;defexception&lt;/code&gt; 构造来定义自己的错误。这样，您将创建一个与其定义的模块同名的错误。最常见的情况是使用消息字段定义一个自定义异常：</target>
        </trans-unit>
        <trans-unit id="b68e78499f2ea8db0e4afcb826dd2b0504211510" translate="yes" xml:space="preserve">
          <source>You can also enforce that certain keys have to be specified when creating the struct:</source>
          <target state="translated">你也可以强制要求在创建结构体时必须指定某些键。</target>
        </trans-unit>
        <trans-unit id="ce48ddf574efae9070be2275a470d1348ca3f552" translate="yes" xml:space="preserve">
          <source>You can also force function calls and keywords to be rendered on multiple lines by having each entry on its own line:</source>
          <target state="translated">您也可以通过将每个条目放在自己的行上,强制将函数调用和关键字呈现在多行上。</target>
        </trans-unit>
        <trans-unit id="f16e22554498a2f7d0cb0cce82e36cf97adf0692" translate="yes" xml:space="preserve">
          <source>You can also match against specific patterns:</source>
          <target state="translated">你也可以根据特定的模式进行匹配。</target>
        </trans-unit>
        <trans-unit id="a9329b9f92977c7892d7c88a42d5d26ed7aa5b4a" translate="yes" xml:space="preserve">
          <source>You can also name your arguments in a typespec using &lt;code&gt;arg_name :: arg_type&lt;/code&gt; syntax. This is particularly useful in documentation as a way to differentiate multiple arguments of the same type (or multiple elements of the same type in a type definition):</source>
          <target state="translated">您还可以使用 &lt;code&gt;arg_name :: arg_type&lt;/code&gt; 语法在typespec中命名参数。这在文档中特别有用，因为它可以区分相同类型的多个参数（或类型定义中相同类型的多个元素）：</target>
        </trans-unit>
        <trans-unit id="e510e5383d56a207bdf88bf2eafaec7eb9db321b" translate="yes" xml:space="preserve">
          <source>You can also specify that certain dependencies are available only for certain environments:</source>
          <target state="translated">您也可以指定某些依赖关系只在特定环境下可用。</target>
        </trans-unit>
        <trans-unit id="e79de485968329efd72c9b8d75bcf174d86956a3" translate="yes" xml:space="preserve">
          <source>You can also start it by calling &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">您也可以通过直接调用&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;来启动它：</target>
        </trans-unit>
        <trans-unit id="7b83780f98299cbc7765deca3b62980471aa7250" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;is_integer/1&lt;/code&gt;, &lt;code&gt;is_float/1&lt;/code&gt; or &lt;code&gt;is_number/1&lt;/code&gt; to check, respectively, if an argument is an integer, a float, or either.</source>
          <target state="translated">您还可以分别使用 &lt;code&gt;is_integer/1&lt;/code&gt; ， &lt;code&gt;is_float/1&lt;/code&gt; 或 &lt;code&gt;is_number/1&lt;/code&gt; 来检查参数是整数，浮点数还是两者之一。</target>
        </trans-unit>
        <trans-unit id="0109469a00b4fd678c9dc3cf7143a92673581f33" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#i/1&quot;&gt;&lt;code&gt;i/1&lt;/code&gt;&lt;/a&gt; function to introspect any value you have in the shell:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;#i/1&quot;&gt; &lt;code&gt;i/1&lt;/code&gt; &lt;/a&gt;函数内省外壳中的任何值：</target>
        </trans-unit>
        <trans-unit id="6997e7247a3fc6a894b0d9b9dc9be42e6fc758f9" translate="yes" xml:space="preserve">
          <source>You can also use the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt; to split a string in its individual characters, each one as a string of length 1:</source>
          <target state="translated">还可以使用的功能中&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;的 &lt;code&gt;String&lt;/code&gt; 模块&lt;/a&gt;分割在其个别字符的字符串，每一个为长度为1的字符串：</target>
        </trans-unit>
        <trans-unit id="d3c998732a481638fd2db1b4a1bcc03793a148fa" translate="yes" xml:space="preserve">
          <source>You can create a new Elixir library by running the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">您可以通过运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt;命令来创建新的Elixir库：</target>
        </trans-unit>
        <trans-unit id="8d6434c5b2ade057524f84d6758bcde70ebb6f7a" translate="yes" xml:space="preserve">
          <source>You can define a structure combining both fields with explicit default values, and implicit &lt;code&gt;nil&lt;/code&gt; values. In this case you must first specify the fields which implicitly default to nil:</source>
          <target state="translated">您可以定义一个结构，将两个字段与显式默认值和隐式 &lt;code&gt;nil&lt;/code&gt; 值组合在一起。在这种情况下，您必须首先指定隐式默认为nil的字段：</target>
        </trans-unit>
        <trans-unit id="d347c6fc0550ca70dfcc1c45aed881edcb92d810" translate="yes" xml:space="preserve">
          <source>You can find the built-in list of guards &lt;a href=&quot;kernel#guards&quot;&gt;in the &lt;code&gt;Kernel&lt;/code&gt; module&lt;/a&gt;. Here is an overview:</source>
          <target state="translated">您可以&lt;a href=&quot;kernel#guards&quot;&gt;在&amp;ldquo; &lt;code&gt;Kernel&lt;/code&gt; 模块中&lt;/a&gt;找到内置防护的列表。这里是一个概述：</target>
        </trans-unit>
        <trans-unit id="4fe77b5370ddcf03d4ba471d1546f4c568f7d01e" translate="yes" xml:space="preserve">
          <source>You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example:</source>
          <target state="translated">您可以通过在开头的括号后添加一个新行,在结尾的括号行前添加一个新行,来强制列表、元组、位串、地图、结构和函数调用每行有一个条目。例如</target>
        </trans-unit>
        <trans-unit id="30fb8fde1f35561abc0c830c8f5133db917a5581" translate="yes" xml:space="preserve">
          <source>You can get a list of all compilers by running:</source>
          <target state="translated">你可以通过运行以下程序获得所有编译器的列表。</target>
        </trans-unit>
        <trans-unit id="a832effd334a13f97e09ed1afd1f5e319784c368" translate="yes" xml:space="preserve">
          <source>You can get further information about a particular task by invoking &lt;code&gt;mix help TASK&lt;/code&gt;.</source>
          <target state="translated">您可以通过调用 &lt;code&gt;mix help TASK&lt;/code&gt; 来获取有关特定任务的更多信息。</target>
        </trans-unit>
        <trans-unit id="e8f264e42957665b5c8e06ba39323b8ce45a1614" translate="yes" xml:space="preserve">
          <source>You can get the representation of any expression by using the &lt;code&gt;quote&lt;/code&gt; macro:</source>
          <target state="translated">您可以使用 &lt;code&gt;quote&lt;/code&gt; 宏获取任何表达式的表示形式：</target>
        </trans-unit>
        <trans-unit id="d21c63a1447fa0e26ff6a7b9be32848ffe669a41" translate="yes" xml:space="preserve">
          <source>You can however access the underlying error by invoking the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; implementation directly. For example, to test &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.MapSet.html&quot;&gt;&lt;code&gt;Inspect.MapSet&lt;/code&gt;&lt;/a&gt; above, you can invoke it as:</source>
          <target state="translated">但是，您可以通过直接调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;实现来访问基础错误。例如，要测试上面的&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.MapSet.html&quot;&gt; &lt;code&gt;Inspect.MapSet&lt;/code&gt; &lt;/a&gt;，可以将其调用为：</target>
        </trans-unit>
        <trans-unit id="7cc7d6571340f5c6c12c483154daae59b9c53bd0" translate="yes" xml:space="preserve">
          <source>You can invoke the &lt;code&gt;round&lt;/code&gt; function to get the closest integer to a given float, or the &lt;code&gt;trunc&lt;/code&gt; function to get the integer part of a float.</source>
          <target state="translated">您可以调用 &lt;code&gt;round&lt;/code&gt; 函数以获取最接近给定浮点数的整数，也可以调用 &lt;code&gt;trunc&lt;/code&gt; 函数获取浮点数的整数部分。</target>
        </trans-unit>
        <trans-unit id="d8f4877ea531cc6ecd46b4a4e1b0aec877f1d54f" translate="yes" xml:space="preserve">
          <source>You can learn more about protocols and implementations in the &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">您可以在&amp;ldquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt;模块中了解有关协议和实现的更多信息。</target>
        </trans-unit>
        <trans-unit id="3de3b4d6f1962ebd8513cf681799409cbcd4ca12" translate="yes" xml:space="preserve">
          <source>You can learn more about the code formatter by checking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;the format task documentation&lt;/a&gt; or by reading &lt;a href=&quot;https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/&quot;&gt;the release announcement for Elixir v1.6&lt;/a&gt;, the first version to include the formatter.</source>
          <target state="translated">您可以通过查看&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;格式任务文档&lt;/a&gt;或阅读&lt;a href=&quot;https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/&quot;&gt;Elixir v1.6&lt;/a&gt;的发行说明（包含该格式器的第一个版本）来了解有关代码格式器的更多信息。</target>
        </trans-unit>
        <trans-unit id="e68e6bb95841d8a40192a9512d9dd906cf05c679" translate="yes" xml:space="preserve">
          <source>You can learn more about the generation of application resource files in the documentation of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.App&lt;/code&gt;&lt;/a&gt;, available as well by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt;&lt;code&gt;mix help compile.app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.App&lt;/code&gt; &lt;/a&gt;文档中了解有关生成应用程序资源文件的更多信息，该文档也可以通过运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt; &lt;code&gt;mix help compile.app&lt;/code&gt; 获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="858e0cb58aec939699966ea77b8a16af5dbe3b1c" translate="yes" xml:space="preserve">
          <source>You can leverage &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; in two steps. The first step is to replace &lt;code&gt;use Mix.Config&lt;/code&gt; at the top of your config files by &lt;code&gt;import Config&lt;/code&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;而不是Mix.Config。第一步是用 &lt;code&gt;import Config&lt;/code&gt; 替换配置文件顶部的 &lt;code&gt;use Mix.Config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="481fc9f7ce3fe55a20ec7b55bee6cc479cc4c920" translate="yes" xml:space="preserve">
          <source>You can limit which apps the cmd runs in by passing the app names before the cmd using --app:</source>
          <target state="translated">你可以通过在cmd前使用--app传递应用程序名称来限制cmd运行的应用程序。</target>
        </trans-unit>
        <trans-unit id="061aef6ce80569a69cf92b6fcba5ab2892dd7d26" translate="yes" xml:space="preserve">
          <source>You can opt into this behaviour for individual tests by tagging them with &lt;code&gt;:capture_log&lt;/code&gt; or enable log capture for all tests in the ExUnit configuration:</source>
          <target state="translated">您可以使用 &lt;code&gt;:capture_log&lt;/code&gt; 标记各个测试的行为，或者为ExUnit配置中的所有测试启用日志捕获：</target>
        </trans-unit>
        <trans-unit id="9caab4aa325a00ee9cd1d2ba0be959240ba0340c" translate="yes" xml:space="preserve">
          <source>You can print a string using the &lt;code&gt;IO.puts/1&lt;/code&gt; function from the &lt;code&gt;IO&lt;/code&gt; module:</source>
          <target state="translated">您可以使用 &lt;code&gt;IO&lt;/code&gt; 模块中的 &lt;code&gt;IO.puts/1&lt;/code&gt; 函数来打印字符串：</target>
        </trans-unit>
        <trans-unit id="238dc90b91f8829ebbb626aecab76e8b80b505c8" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt; in our documentation&lt;/a&gt;.</source>
          <target state="translated">你可以阅读更多关于&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; 我们的文档中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5cc3e518c581def9b6af3b0a0aee431cfb36ec7" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt; module&lt;/a&gt;. Documentation for &lt;code&gt;Macro.escape/1&lt;/code&gt; and other functions related to quoted expressions can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;&lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">你可以阅读更多关于 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;unquote&lt;/code&gt; 的在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; 模块&lt;/a&gt;。可以在&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt;模块中找到 &lt;code&gt;Macro.escape/1&lt;/code&gt; 的文档以及与引用表达式有关的其他函数。</target>
        </trans-unit>
        <trans-unit id="4c44d26110447a0ef14d1b0f03e310d296868469" translate="yes" xml:space="preserve">
          <source>You can read more about ExUnit cases in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt; module documentation&lt;/a&gt; and more about callbacks in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt; docs&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; 模块文档中&lt;/a&gt;阅读有关ExUnit案例的更多信息，并在&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; docs&lt;/a&gt;中阅读有关回调的更多信息。</target>
        </trans-unit>
        <trans-unit id="7a98f56e08fd31d3296a30c5e18504c38b9716ba" translate="yes" xml:space="preserve">
          <source>You can read more about filters, tags and the default tags in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; 模块文档中&lt;/a&gt;阅读有关过滤器，标签和默认标签的更多信息。</target>
        </trans-unit>
        <trans-unit id="74775aa5a943cf5bb41ef494fec5bf544f913cbb" translate="yes" xml:space="preserve">
          <source>You can read more about formatting in &lt;a href=&quot;logger.formatter&quot;&gt;&lt;code&gt;Logger.Formatter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;logger.formatter&quot;&gt; &lt;code&gt;Logger.Formatter&lt;/code&gt; 中&lt;/a&gt;阅读有关格式化的更多信息。</target>
        </trans-unit>
        <trans-unit id="de940e7c82802a489662bba3bb1b738febb539ca" translate="yes" xml:space="preserve">
          <source>You can run &lt;a href=&quot;mix.tasks.deps&quot;&gt;&lt;code&gt;mix help deps&lt;/code&gt;&lt;/a&gt; to learn more about dependencies in Mix.</source>
          <target state="translated">您可以运行&lt;a href=&quot;mix.tasks.deps&quot;&gt; &lt;code&gt;mix help deps&lt;/code&gt; &lt;/a&gt;以了解有关Mix中依赖项的更多信息。</target>
        </trans-unit>
        <trans-unit id="54f450206bafe3c72254cb929d8344e838346665" translate="yes" xml:space="preserve">
          <source>You can see a handful more options used by the Erlang compiler in the documentation for the &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html&quot;&gt;&lt;code&gt;:compile&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://www.erlang.org/doc/man/compile.html&quot;&gt; &lt;code&gt;:compile&lt;/code&gt; 模块&lt;/a&gt;的文档中看到Erlang编译器使用的其他更多选项。</target>
        </trans-unit>
        <trans-unit id="f508b38185d8637e812e75bab67d06d9f5d4394e" translate="yes" xml:space="preserve">
          <source>You can see now the prompt is slightly different and shows the node name followed by the computer name:</source>
          <target state="translated">你可以看到现在的提示略有不同,显示的是节点名称,后面是计算机名称。</target>
        </trans-unit>
        <trans-unit id="516c3c5987d4ecaa8ab4cebbdb6cd4f7180d78fb" translate="yes" xml:space="preserve">
          <source>You can see that variables are also represented with a tuple, except the third element is an atom expressing the variable context.</source>
          <target state="translated">你可以看到,变量也是用元组来表示的,只不过第三个元素是表达变量上下文的原子。</target>
        </trans-unit>
        <trans-unit id="5b9ccc7485aeb7ac27c89593fed8959b0d8ad55d" translate="yes" xml:space="preserve">
          <source>You can see that, instead of containing bytes, a charlist contains the code points of the characters between single-quotes (note that by default IEx will only output code points if any of the integers is outside the ASCII range). So while double-quotes represent a string (i.e. a binary), single-quotes represent a charlist (i.e. a list).</source>
          <target state="translated">您可以看到,charlist不包含字节,而是包含单引号之间的字符的代码点(注意,默认情况下,只有当任何一个整数超出ASCII范围时,IEx才会输出代码点)。因此,双引号代表一个字符串(即二进制),而单引号代表一个charlist(即列表)。</target>
        </trans-unit>
        <trans-unit id="13da5bbf18b54b654e2e2ccc5a518a213ea62e25" translate="yes" xml:space="preserve">
          <source>You can see them being used in constructs such as &lt;code&gt;receive&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, and others.</source>
          <target state="translated">您可以看到它们在诸如 &lt;code&gt;receive&lt;/code&gt; ， &lt;code&gt;try&lt;/code&gt; 和其他结构中使用。</target>
        </trans-unit>
        <trans-unit id="b61367dd10530be9cc81fb749aaf5a8d7be61c43" translate="yes" xml:space="preserve">
          <source>You can start those processes under test in isolation by running:</source>
          <target state="translated">你可以通过运行来单独启动这些被测进程。</target>
        </trans-unit>
        <trans-unit id="fe09547257318c7e6f5e7852a60743468f3db318" translate="yes" xml:space="preserve">
          <source>You can take a look at the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;Module&lt;/a&gt; for a complete list of supported attributes. Elixir also uses attributes to define &lt;a href=&quot;typespecs-and-behaviours&quot;&gt;typespecs&lt;/a&gt;.</source>
          <target state="translated">您可以查看有关&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;模块&lt;/a&gt;的文档，以获取受支持属性的完整列表。Elixir还使用属性定义&lt;a href=&quot;typespecs-and-behaviours&quot;&gt;typespec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5003329b8d5825870febaa77dc5a05d8ad92d9da" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; functions/macros without the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; prefix anywhere in Elixir code as all its functions and macros are automatically imported. For example, in IEx:</source>
          <target state="translated">您可以在Elixir代码中的任何位置使用不带&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;前缀的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;函数/宏，因为它的所有函数和宏都会自动导入。例如，在IEx中：</target>
        </trans-unit>
        <trans-unit id="1ff3e87a6c2c47d0723f98be606445ee66b4e9e3" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#format_error-1&quot;&gt;&lt;code&gt;:file.format_error/1&lt;/code&gt;&lt;/a&gt; to get a descriptive string of the error.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#format_error-1&quot;&gt; &lt;code&gt;:file.format_error/1&lt;/code&gt; &lt;/a&gt;来获取错误的描述性字符串。</target>
        </trans-unit>
        <trans-unit id="32805d53bcb25de0e45ff1ee652110cf06844e50" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; function to invoke the documentation for any Elixir module or function:</source>
          <target state="translated">您可以使用&lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt;函数来调用任何Elixir模块或函数的文档：</target>
        </trans-unit>
        <trans-unit id="685a0519371e51dd4e80c5cc3a472b10156fef57" translate="yes" xml:space="preserve">
          <source>You cannot even access variables defined in the same module unless you explicitly give it a context:</source>
          <target state="translated">你甚至不能访问在同一模块中定义的变量,除非你明确地给它一个上下文。</target>
        </trans-unit>
        <trans-unit id="2da60de011e5217c03ae75beeb07c81666f07da1" translate="yes" xml:space="preserve">
          <source>You could also replace the whole &lt;code&gt;apply&lt;/code&gt; system by explicitly sending messages. That's the example we will see next.</source>
          <target state="translated">您也可以通过显式发送消息来替换整个 &lt;code&gt;apply&lt;/code&gt; 系统。这就是我们接下来将要看到的示例。</target>
        </trans-unit>
        <trans-unit id="52a81fdf1e26dc6a237fff7de279d410074015e7" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t actually need to memorize this ordering; it&amp;rsquo;s enough to know that this ordering exists.</source>
          <target state="translated">您实际上不需要记住此顺序。知道这个排序就足够了。</target>
        </trans-unit>
        <trans-unit id="eb49dae3e3f9d8636fe6649b7031d1a74f3182eb" translate="yes" xml:space="preserve">
          <source>You may also have noticed that we have added &lt;code&gt;@impl true&lt;/code&gt; before each callback. The &lt;code&gt;@impl true&lt;/code&gt; informs the compiler that our intention for the subsequent function definition is to define a callback. If by any chance we make a mistake in the function name or in the number of arguments, like we define a &lt;code&gt;handle_call/2&lt;/code&gt;, the compiler would warn us there isn&amp;rsquo;t any &lt;code&gt;handle_call/2&lt;/code&gt; to define, and would give us the complete list of known callbacks for the &lt;code&gt;GenServer&lt;/code&gt; module.</source>
          <target state="translated">您可能还注意到，我们在每个回调之前添加了 &lt;code&gt;@impl true&lt;/code&gt; 。该 &lt;code&gt;@impl true&lt;/code&gt; 告知编译器，我们对后续的函数定义的意图是定义一个回调。如果碰巧我们在函数名称或参数数量上犯了错误（如定义 &lt;code&gt;handle_call/2&lt;/code&gt; )，则编译器会警告我们没有任何 &lt;code&gt;handle_call/2&lt;/code&gt; 可以定义，并将提供完整列表 &lt;code&gt;GenServer&lt;/code&gt; 模块的已知回调的集合。</target>
        </trans-unit>
        <trans-unit id="d63d3165b51c6e5c0937ccdd6ef968772a3b4610" translate="yes" xml:space="preserve">
          <source>You may have noticed that &lt;code&gt;File.open/2&lt;/code&gt; returns a tuple like &lt;code&gt;{:ok, pid}&lt;/code&gt;:</source>
          <target state="translated">您可能已经注意到 &lt;code&gt;File.open/2&lt;/code&gt; 返回一个类似 &lt;code&gt;{:ok, pid}&lt;/code&gt; 的元组：</target>
        </trans-unit>
        <trans-unit id="24a9922677998390b346e99672a32ed06b220ac3" translate="yes" xml:space="preserve">
          <source>You may invoke:</source>
          <target state="translated">你可以调用。</target>
        </trans-unit>
        <trans-unit id="8f218d2faa7fa7209c123d6beeb4745cb90126c6" translate="yes" xml:space="preserve">
          <source>You may pass either &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or a specific behaviour to &lt;code&gt;@impl&lt;/code&gt;.</source>
          <target state="translated">您可以将 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 或特定行为传递给 &lt;code&gt;@impl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35dfa5204eed8291195bbefec2b4dd5c6994b4a3" translate="yes" xml:space="preserve">
          <source>You may set &lt;code&gt;:format&lt;/code&gt; to either a string or a &lt;code&gt;{module, function}&lt;/code&gt; tuple if you wish to provide your own format function. Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">如果希望提供自己的格式函数 &lt;code&gt;{module, function}&lt;/code&gt; 可以将 &lt;code&gt;:format&lt;/code&gt; 设置为字符串或{module，function}元组。这是如何在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:console&lt;/code&gt; 后端的示例：</target>
        </trans-unit>
        <trans-unit id="3fbd8242e1f12076d2e6de9e662957c3435d74b0" translate="yes" xml:space="preserve">
          <source>You may then call &lt;code&gt;make_custom_env()&lt;/code&gt; to get a struct with the desired imports and aliases included.</source>
          <target state="translated">然后，您可以调用 &lt;code&gt;make_custom_env()&lt;/code&gt; 以获取包含所需导入和别名的结构。</target>
        </trans-unit>
        <trans-unit id="69322d3d7e21dcf45f38c1a4256ea28e664abc0f" translate="yes" xml:space="preserve">
          <source>You might have noticed we have a function head, &lt;code&gt;def run(command)&lt;/code&gt;, without a body. In the &lt;a href=&quot;../modules-and-functions#default-arguments&quot;&gt;Modules and Functions&lt;/a&gt; chapter, we learned that a bodiless function can be used to declare default arguments for a multi-clause function. Here is another use case where we use a function without a body to document what the arguments are.</source>
          <target state="translated">您可能已经注意到我们有一个函数头 &lt;code&gt;def run(command)&lt;/code&gt; ，没有主体。在&amp;ldquo; &lt;a href=&quot;../modules-and-functions#default-arguments&quot;&gt;模块和功能&amp;rdquo;&lt;/a&gt;一章中，我们了解到无身体功能可用于声明多子句功能的默认参数。这是另一个用例，其中我们使用没有主体的函数来记录参数是什么。</target>
        </trans-unit>
        <trans-unit id="60eed846530023fb8679ef23800ef12ddb7e3daa" translate="yes" xml:space="preserve">
          <source>You might notice that we added a line, &lt;code&gt;:ok = :gen_tcp.controlling_process(client, pid)&lt;/code&gt;. This makes the child process the &amp;ldquo;controlling process&amp;rdquo; of the &lt;code&gt;client&lt;/code&gt; socket. If we didn&amp;rsquo;t do this, the acceptor would bring down all the clients if it crashed because sockets would be tied to the process that accepted them (which is the default behaviour).</source>
          <target state="translated">您可能会注意到，我们添加了一行 &lt;code&gt;:ok = :gen_tcp.controlling_process(client, pid)&lt;/code&gt; 。这使子进程成为 &lt;code&gt;client&lt;/code&gt; 套接字的&amp;ldquo;控制进程&amp;rdquo; 。如果我们不这样做，则当套接字崩溃时，接受者将关闭所有客户端，因为套接字将与接受它们的进程绑定在一起（这是默认行为）。</target>
        </trans-unit>
        <trans-unit id="5f976962c87540d5ec1bd399d5ea623fcbba3044" translate="yes" xml:space="preserve">
          <source>You must create a &lt;code&gt;test_helper.exs&lt;/code&gt; file inside the &lt;code&gt;test&lt;/code&gt; directory and put the code common to all tests there.</source>
          <target state="translated">您必须在 &lt;code&gt;test&lt;/code&gt; 目录中创建一个 &lt;code&gt;test_helper.exs&lt;/code&gt; 文件，并将所有测试共用的代码放在该目录中。</target>
        </trans-unit>
        <trans-unit id="669380c70bf6f138e0bf5ec04ed501d1a6411fc5" translate="yes" xml:space="preserve">
          <source>You should avoid spawning processes outside of a supervision tree, especially long-running ones. Instead, processes must be started inside supervision trees. This guarantees developers have full control over the initialization, restarts, and shutdown of the system.</source>
          <target state="translated">你应该避免在监督树之外产生进程,尤其是长期运行的进程。相反,必须在监督树内启动进程。这样可以保证开发人员对系统的初始化、重启和关闭有完全的控制权。</target>
        </trans-unit>
        <trans-unit id="dcb046535f15726d2bf09809f210124fab9764fd" translate="yes" xml:space="preserve">
          <source>You should avoid using exceptions for control-flow. For example, instead of:</source>
          <target state="translated">你应该避免在控制流中使用异常。例如,不要使用:</target>
        </trans-unit>
        <trans-unit id="99f4ca1715b9c9721c3aedc65af08dc10eb9ec5f" translate="yes" xml:space="preserve">
          <source>You should avoid using the application environment (see &lt;a href=&quot;application#get_env/2&quot;&gt;&lt;code&gt;Application.get_env/2&lt;/code&gt;&lt;/a&gt;) as the configuration mechanism for libraries. The application environment is &lt;strong&gt;global&lt;/strong&gt; which means it becomes impossible for two dependencies to use your library in two different ways.</source>
          <target state="translated">您应该避免使用应用程序环境（请参阅&lt;a href=&quot;application#get_env/2&quot;&gt; &lt;code&gt;Application.get_env/2&lt;/code&gt; &lt;/a&gt;）作为库的配置机制。应用程序环境是&lt;strong&gt;全局的&lt;/strong&gt;，这意味着两个依赖项无法以两种不同的方式使用您的库。</target>
        </trans-unit>
        <trans-unit id="e4d1794f1b4805dfe6a3920546c5ae7ca73f34f1" translate="yes" xml:space="preserve">
          <source>You should be aware that the code being profiled is running in an anonymous function which is invoked by &lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt;&lt;code&gt;:eprof&lt;/code&gt; module&lt;/a&gt;. Thus, you'll see some additional entries in your profile output. It is also important to notice that the profiler is stopped as soon as the code has finished running, and this may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend.</source>
          <target state="translated">您应该知道，正在分析的代码正在由&lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt; &lt;code&gt;:eprof&lt;/code&gt; 模块&lt;/a&gt;调用的匿名函数中运行。因此，您将在个人资料输出中看到一些其他条目。还需要注意的是，一旦代码运行完毕，分析器便会立即停止，这可能需要特别注意：运行长时间运行的计算的同步代码以及没有适当的MFA跟踪模式或过滤器的分析器可能会导致结果集难以理解。</target>
        </trans-unit>
        <trans-unit id="f609ba9cab33c27584866ee1bafabe1ab8cda2b0" translate="yes" xml:space="preserve">
          <source>You should be aware that the code being profiled is running in an anonymous function which is invoked by &lt;a href=&quot;http://wwww.erlang.org/doc/man/fprof.html&quot;&gt;&lt;code&gt;:fprof&lt;/code&gt; module&lt;/a&gt;. Thus, you'll see some additional entries in your profile output, such as &lt;code&gt;:fprof&lt;/code&gt; calls, an anonymous function with high ACC time, or an &lt;code&gt;:undefined&lt;/code&gt; function which represents the outer caller (non-profiled code which started the profiler).</source>
          <target state="translated">您应该知道，正在分析的代码正在由&lt;a href=&quot;http://wwww.erlang.org/doc/man/fprof.html&quot;&gt; &lt;code&gt;:fprof&lt;/code&gt; 模块&lt;/a&gt;调用的匿名函数中运行。因此，您将在配置文件输出中看到一些其他条目，例如 &lt;code&gt;:fprof&lt;/code&gt; 调用，具有较高ACC时间的匿名函数或代表外部调用方的 &lt;code&gt;:undefined&lt;/code&gt; 函数（启动配置文件程序的非配置文件代码）。</target>
        </trans-unit>
        <trans-unit id="ad57c7d6217a5b8532de6553070103bc648ebde2" translate="yes" xml:space="preserve">
          <source>You should be aware the profiler is stopped as soon as the code has finished running. This may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend.</source>
          <target state="translated">你应该知道,一旦代码运行完毕,剖析器就会停止。这可能需要特别注意,当:运行异步代码,因为在剖析器停止之前调用的函数调用将不被计算在内;运行同步代码,因为长期运行的计算和剖析器没有适当的MFA跟踪模式或过滤器,可能会导致难以理解的结果集。</target>
        </trans-unit>
        <trans-unit id="5a84f5d4c0ef0af3172b0ed86583719c4894487a" translate="yes" xml:space="preserve">
          <source>You should expect a slowdown in your code execution using this tool since &lt;code&gt;:eprof&lt;/code&gt; has some performance impact on the execution, but the impact is considerably lower than &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt;&lt;/a&gt;. If you have a large system try to profile a limited scenario or focus on the main modules or processes. Another alternative is to use &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt;&lt;/a&gt; that uses &lt;code&gt;:cprof&lt;/code&gt; and has a low performance degradation effect.</source>
          <target state="translated">您应该期望使用此工具的代码执行速度变慢，因为 &lt;code&gt;:eprof&lt;/code&gt; 会对执行产生一些性能影响，但其影响要比&lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt; &lt;/a&gt;低得多。如果您的系统很大，请尝试剖析有限的情况，或集中精力处理主要模块或流程。另一种选择是使用&lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt; &lt;/a&gt;，它使用 &lt;code&gt;:cprof&lt;/code&gt; 并降低性能。</target>
        </trans-unit>
        <trans-unit id="34f48ddf9f458a8c4cff93dc3dbe5cb1b93bf9ff" translate="yes" xml:space="preserve">
          <source>You will also notice that functions in the &lt;code&gt;File&lt;/code&gt; module have two variants: one &amp;ldquo;regular&amp;rdquo; variant and another variant with a trailing bang (&lt;code&gt;!&lt;/code&gt;). For example, when we read the &lt;code&gt;&quot;hello&quot;&lt;/code&gt; file in the example above, we use &lt;code&gt;File.read/1&lt;/code&gt;. Alternatively, we can use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="translated">您还将注意到，&amp;ldquo; &lt;code&gt;File&lt;/code&gt; 模块中的函数具有两个变体：一个是&amp;ldquo;常规&amp;rdquo;变体，另一个是带有后缀（ &lt;code&gt;!&lt;/code&gt; ）的变体。例如，当我们在上面的示例中读取 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 文件时，我们使用 &lt;code&gt;File.read/1&lt;/code&gt; 。另外，我们可以使用 &lt;code&gt;File.read!/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7edda58a5288041fd2626f2fde4de673f8651019" translate="yes" xml:space="preserve">
          <source>You will notice that when you add a dependency to your project, Mix generates a &lt;code&gt;mix.lock&lt;/code&gt; file that guarantees &lt;em&gt;repeatable builds&lt;/em&gt;. The lock file must be checked in to your version control system, to guarantee that everyone who uses the project will use the same dependency versions as you.</source>
          <target state="translated">您会注意到，当您向项目添加依赖项时，Mix会生成一个 &lt;code&gt;mix.lock&lt;/code&gt; 文件，该文件保证&lt;em&gt;可重复的构建&lt;/em&gt;。锁定文件必须签入您的版本控制系统，以确保使用该项目的每个人都将使用与您相同的依赖版本。</target>
        </trans-unit>
        <trans-unit id="b214ce47f7eaecf345ea9e4479eb2daf88835923" translate="yes" xml:space="preserve">
          <source>You will see that Elixir has excellent support for working with strings. It also supports many of the Unicode operations. In fact, Elixir passes all the tests showcased in the article &lt;a href=&quot;http://mortoray.com/2013/11/27/the-string-type-is-broken/&quot;&gt;&amp;ldquo;The string type is broken&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">您将看到Elixir对使用字符串提供了出色的支持。它还支持许多Unicode操作。实际上，Elixir通过了&lt;a href=&quot;http://mortoray.com/2013/11/27/the-string-type-is-broken/&quot;&gt;&amp;ldquo;字符串类型已损坏&amp;rdquo;一&lt;/a&gt;文中展示的所有测试。</target>
        </trans-unit>
        <trans-unit id="c4525454674902061c1b514520438225ac3d52ac" translate="yes" xml:space="preserve">
          <source>You'll find the resource file of an application in its &lt;code&gt;ebin&lt;/code&gt; directory, it is generated automatically by Mix. Some of its keys are taken from the keyword lists returned by the &lt;code&gt;project/0&lt;/code&gt; and &lt;code&gt;application/0&lt;/code&gt; functions defined in &lt;code&gt;mix.exs&lt;/code&gt;, and others are generated by Mix itself.</source>
          <target state="translated">您可以在其 &lt;code&gt;ebin&lt;/code&gt; 目录中找到应用程序的资源文件，该文件由Mix自动生成。它的某些键来自 &lt;code&gt;mix.exs&lt;/code&gt; &lt;code&gt;application/0&lt;/code&gt; exs中定义的 &lt;code&gt;project/0&lt;/code&gt; 和application / 0函数返回的关键字列表，而其他键则由Mix本身生成。</target>
        </trans-unit>
        <trans-unit id="559feb6095bf182138a3b4c5b0a6869996e9a835" translate="yes" xml:space="preserve">
          <source>Zero will be returned if there is no match.</source>
          <target state="translated">如果没有匹配,将返回零。</target>
        </trans-unit>
        <trans-unit id="c360b69284a084ed6128fa35ae5d3cddcf4691ea" translate="yes" xml:space="preserve">
          <source>Zero-based index.</source>
          <target state="translated">零基指数。</target>
        </trans-unit>
        <trans-unit id="6d19682a026c8ec1f09fb5b205c665ace8d5d0c7" translate="yes" xml:space="preserve">
          <source>Zero-based index. It can also be a negative integer.</source>
          <target state="translated">零基指数。它也可以是一个负整数。</target>
        </trans-unit>
        <trans-unit id="df158a1ec3201042f65f02afbe3a3b4bd006197a" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</source>
          <target state="translated">将对应的元素从有限的枚举集合中压缩成一个tuple的列表。</target>
        </trans-unit>
        <trans-unit id="203223b26b6c7accee671d6510311309ff17979c" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from a finite collection of enumerables into one stream of tuples.</source>
          <target state="translated">将对应的元素从有限的枚举集合中压缩成一个tuple流。</target>
        </trans-unit>
        <trans-unit id="1bfed92a39ee32d59521a708ff76ea497610a38e" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from each list in &lt;code&gt;list_of_lists&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;list_of_lists&lt;/code&gt; 中的每个列表中压缩相应的元素。</target>
        </trans-unit>
        <trans-unit id="58c3b6f7176ddf31ce9148ac85055319257ca058" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from two enumerables into one list of tuples.</source>
          <target state="translated">将对应的元素从两个枚举表压缩成一个tuple的列表。</target>
        </trans-unit>
        <trans-unit id="00cfd06487588a4d7f31aa3a150980d65bfaf2a5" translate="yes" xml:space="preserve">
          <source>Zips two collections together, lazily.</source>
          <target state="translated">将两个收藏品打包在一起,懒洋洋的。</target>
        </trans-unit>
        <trans-unit id="cafe76887cacaaf65275657b20e4009913b348cf" translate="yes" xml:space="preserve">
          <source>Zombie operating system processes</source>
          <target state="translated">僵尸操作系统进程</target>
        </trans-unit>
        <trans-unit id="08d3a96fcb659e45499ff8800c5d9b02c9f5d5e7" translate="yes" xml:space="preserve">
          <source>^var</source>
          <target state="translated">^var</target>
        </trans-unit>
        <trans-unit id="bc01569116f2ab15fb902409110b8bc5b1e1e9a2" translate="yes" xml:space="preserve">
          <source>^var (1)</source>
          <target state="translated">^ var（1）</target>
        </trans-unit>
        <trans-unit id="2b0e4da7ba7de811226d1e589a3dafed1082da59" translate="yes" xml:space="preserve">
          <source>__CALLER__</source>
          <target state="translated">__CALLER__</target>
        </trans-unit>
        <trans-unit id="116009782b4ac4aee2d8dab11c4809c0d1ebc198" translate="yes" xml:space="preserve">
          <source>__CALLER__ (0)</source>
          <target state="translated">__CAL____（0）</target>
        </trans-unit>
        <trans-unit id="afab0a49c7ceabfb338074dd17afd32d320d2e0d" translate="yes" xml:space="preserve">
          <source>__DIR__</source>
          <target state="translated">__DIR__</target>
        </trans-unit>
        <trans-unit id="36bb03bc0427bf8b9a1d4912ffe0e708394c8a39" translate="yes" xml:space="preserve">
          <source>__DIR__ (0)</source>
          <target state="translated">__DIR__（0）</target>
        </trans-unit>
        <trans-unit id="601f6fc23ca3b0743af374a4f01070f856dd4d9a" translate="yes" xml:space="preserve">
          <source>__ENV__</source>
          <target state="translated">__ENV__</target>
        </trans-unit>
        <trans-unit id="274ff6b31ca455977fc2c254e3c7d72a43d77f11" translate="yes" xml:space="preserve">
          <source>__ENV__ (0)</source>
          <target state="translated">__ENV__（0）</target>
        </trans-unit>
        <trans-unit id="44ad279c068c2aa891024b5e4789d6fce3bd4e30" translate="yes" xml:space="preserve">
          <source>__MODULE__</source>
          <target state="translated">__MODULE__</target>
        </trans-unit>
        <trans-unit id="45b51d1650bc2981392ec672584bee3b0eef19e7" translate="yes" xml:space="preserve">
          <source>__MODULE__ (0)</source>
          <target state="translated">__模数__（0）</target>
        </trans-unit>
        <trans-unit id="383f765afc4b9be6d9d65d8985319fbba95d2941" translate="yes" xml:space="preserve">
          <source>__STACKTRACE__</source>
          <target state="translated">__STACKTRACE__</target>
        </trans-unit>
        <trans-unit id="40c4d357e42e18738498abc91cfbbec623bc3eac" translate="yes" xml:space="preserve">
          <source>__STACKTRACE__ (0)</source>
          <target state="translated">__堆栈跟踪__（0）</target>
        </trans-unit>
        <trans-unit id="95e7ff9d820f043fac6714bf8356efca3f731112" translate="yes" xml:space="preserve">
          <source>__aliases__ (1)</source>
          <target state="translated">__别名__（1）</target>
        </trans-unit>
        <trans-unit id="5e428e427d7dec6ffb090cc57d4f99596428bae0" translate="yes" xml:space="preserve">
          <source>__aliases__(args)</source>
          <target state="translated">__aliases__(args)</target>
        </trans-unit>
        <trans-unit id="76c3fbd0730868e8619f79de60aaa56c4fbca3d2" translate="yes" xml:space="preserve">
          <source>__block__ (1)</source>
          <target state="translated">__方块__（1）</target>
        </trans-unit>
        <trans-unit id="4ffd2236068356332d96bfb12ed86d69f24f74bb" translate="yes" xml:space="preserve">
          <source>__block__(args)</source>
          <target state="translated">__block__(args)</target>
        </trans-unit>
        <trans-unit id="9f16c3bbe5a985017500773431cb279065841a3d" translate="yes" xml:space="preserve">
          <source>__info__(atom)</source>
          <target state="translated">__info__(atom)</target>
        </trans-unit>
        <trans-unit id="cb133a7b058382216c0e2f8756ec4a8097f54303" translate="yes" xml:space="preserve">
          <source>a PID</source>
          <target state="translated">秤盘</target>
        </trans-unit>
        <trans-unit id="ec7d2b2573d9de6e326c02b1e8c59634c9a23261" translate="yes" xml:space="preserve">
          <source>a binary representing an absolute path</source>
          <target state="translated">二进制</target>
        </trans-unit>
        <trans-unit id="734fb2da92d407682a9cc47d5b108d6cbe1433cf" translate="yes" xml:space="preserve">
          <source>a function to be invoked next</source>
          <target state="translated">下次调用的函数</target>
        </trans-unit>
        <trans-unit id="502fbd56e3b0c3cf11d02b7416e5d6f9c2626390" translate="yes" xml:space="preserve">
          <source>a list containing one of these three elements</source>
          <target state="translated">含有这三个元素之一的列表</target>
        </trans-unit>
        <trans-unit id="a64ce55469e56477808a6b690f545aaa12838299" translate="yes" xml:space="preserve">
          <source>a map representing the child specification itself - as outlined in the &quot;Child specification&quot; section</source>
          <target state="translated">表示子规范本身的地图--如 &quot;子规范 &quot;一节中所概述。</target>
        </trans-unit>
        <trans-unit id="c80d6f05f1a8caa07ef67ce20b0b0ca7b91eed6f" translate="yes" xml:space="preserve">
          <source>a module - such as &lt;code&gt;Stack&lt;/code&gt;. In this case, &lt;code&gt;Stack.child_spec([])&lt;/code&gt; is called to retrieve the child specification</source>
          <target state="translated">模块-例如 &lt;code&gt;Stack&lt;/code&gt; 。在这种情况下， &lt;code&gt;Stack.child_spec([])&lt;/code&gt; 以检索子规范</target>
        </trans-unit>
        <trans-unit id="134dad47c3dd67035406cb3ed8da25b57e066edc" translate="yes" xml:space="preserve">
          <source>a non-negative integer - the amount of time in milliseconds that the supervisor tells the child process to terminate by calling &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt;</source>
          <target state="translated">一个非负整数-主管通过调用 &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; 告诉子进程终止，然后等待返回退出信号的时间（以毫秒为单位）。如果在指定时间内未收到退出信号，则使用 &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt; 无条件终止子进程。</target>
        </trans-unit>
        <trans-unit id="9b8d6899963c6b1849b03232cb4f4e71a7207c1f" translate="yes" xml:space="preserve">
          <source>a timeout value, where the supervisor will send the exit signal &lt;code&gt;:shutdown&lt;/code&gt; and the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will have the duration of the timeout to terminate. If after duration of this timeout the process is still alive, it will be killed immediately.</source>
          <target state="translated">一个超时值，主管将发送退出信号 &lt;code&gt;:shutdown&lt;/code&gt; ，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;将具有超时持续时间。如果在此超时时间过后该进程仍然存在，它将立即被杀死。</target>
        </trans-unit>
        <trans-unit id="a0ea0ba4868724242e4956219cba8cb1ef8b4172" translate="yes" xml:space="preserve">
          <source>a tuple with a module as first element and the start argument as second - such as &lt;code&gt;{Stack, [:hello]}&lt;/code&gt;. In this case, &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; is called to retrieve the child specification</source>
          <target state="translated">一个以模块为第一个元素，起始参数为第二个的元组-例如 &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; 。在这种情况下， &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; 来检索子规范</target>
        </trans-unit>
        <trans-unit id="362f1ac8a4ed3101c7e767a7343bf779218f1d02" translate="yes" xml:space="preserve">
          <source>a tuple {:system, system_var, path} where the config is the concatenation of the &lt;code&gt;system_var&lt;/code&gt; with the given &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">一个元组{：system，system_var，path}，其中config是 &lt;code&gt;system_var&lt;/code&gt; 与给定 &lt;code&gt;path&lt;/code&gt; 的串联</target>
        </trans-unit>
        <trans-unit id="cab7deed2a3742f86c582b0dc8a38ef1106ff9b9" translate="yes" xml:space="preserve">
          <source>a two-element tuple &lt;code&gt;{get_value, new_value}&lt;/code&gt;. In this case, &lt;code&gt;get_value&lt;/code&gt; is the retrieved value which can possibly be operated on before being returned. &lt;code&gt;new_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">两个元素的元组 &lt;code&gt;{get_value, new_value}&lt;/code&gt; 。在这种情况下， &lt;code&gt;get_value&lt;/code&gt; 是检索到的值，可以在返回之前对其进行操作。 &lt;code&gt;new_value&lt;/code&gt; 是要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值。</target>
        </trans-unit>
        <trans-unit id="58540f6d62cd4713c9c1081d83394b907bf916df" translate="yes" xml:space="preserve">
          <source>a value is falsy when it is either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;</source>
          <target state="translated">当值为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 时，值是虚假的</target>
        </trans-unit>
        <trans-unit id="9cd309a5b122a644c7bfb6656f3eb61d1daa78c0" translate="yes" xml:space="preserve">
          <source>a value is truthy when it is neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;</source>
          <target state="translated">当值既不为 &lt;code&gt;false&lt;/code&gt; 也不 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03132489ebc918b7753fd8abac08ea39dc94a398" translate="yes" xml:space="preserve">
          <source>abcast(nodes \\ [node() | Node.list()], name, request)</source>
          <target state="translated">abcast(nodes \ [node()| Node.list()],name,request)</target>
        </trans-unit>
        <trans-unit id="63de8499bacfd70eba507c04a94405770d9c8712" translate="yes" xml:space="preserve">
          <source>abs (1)</source>
          <target state="translated">腹肌(1)</target>
        </trans-unit>
        <trans-unit id="b4bb0fca1626c2cba561f5b8c066cfc4958f2109" translate="yes" xml:space="preserve">
          <source>abs(number)</source>
          <target state="translated">abs(number)</target>
        </trans-unit>
        <trans-unit id="275fce92cc74afd24db101d22aaf3bebb46dff2c" translate="yes" xml:space="preserve">
          <source>absname(path)</source>
          <target state="translated">absname(path)</target>
        </trans-unit>
        <trans-unit id="1158fd681568fcd2eb9afc7aacf1c8457c01fe01" translate="yes" xml:space="preserve">
          <source>absname(path, relative_to)</source>
          <target state="translated">absname(path,relative_to)</target>
        </trans-unit>
        <trans-unit id="a9834cc26df9e591aaf3b9059861c87920267760" translate="yes" xml:space="preserve">
          <source>acc()</source>
          <target state="translated">acc()</target>
        </trans-unit>
        <trans-unit id="5cd4dffbe947a0a27ee38504e04afa01f57c5840" translate="yes" xml:space="preserve">
          <source>access_fun(data, get_value)</source>
          <target state="translated">access_fun(data,get_value)</target>
        </trans-unit>
        <trans-unit id="37e4298f00e4b04a039f9767597f041ed4bb77b9" translate="yes" xml:space="preserve">
          <source>add(date, days)</source>
          <target state="translated">添加(日期,天数)</target>
        </trans-unit>
        <trans-unit id="cad1078dcdee7f8d74060d5de76a291438a58175" translate="yes" xml:space="preserve">
          <source>add(datetime, amount_to_add, unit \\ :second, time_zone_database \\ Calendar.get_time_zone_database())</source>
          <target state="translated">add(datetime,amount_to_add,unit \ :second,time_zone_database \ Calendar.get_time_zone_database())</target>
        </trans-unit>
        <trans-unit id="f8ecfb9e15c4c321a10bcf89505371175f5cbc61" translate="yes" xml:space="preserve">
          <source>add(naive_datetime, amount_to_add, unit \\ :second)</source>
          <target state="translated">add(naive_datetime,amount_to_add,unit \ :second)</target>
        </trans-unit>
        <trans-unit id="ddd8b500ea07a334e0aedae3451af17825441423" translate="yes" xml:space="preserve">
          <source>add(time, number, unit \\ :second)</source>
          <target state="translated">add(time,number,unit :second)</target>
        </trans-unit>
        <trans-unit id="8fbfd79ef8a165fdca563144367a381ee91b3ed9" translate="yes" xml:space="preserve">
          <source>add_backend(backend, opts \\ [])</source>
          <target state="translated">add_backend(backend,opts \ [\])</target>
        </trans-unit>
        <trans-unit id="3241fd5e2fc24f5764a7e7f80ccd3b03b9017f7d" translate="yes" xml:space="preserve">
          <source>add_translator(translator)</source>
          <target state="translated">add_translator(translator)</target>
        </trans-unit>
        <trans-unit id="ebbe7ff0122ba78922baf34fee6cd329ce239feb" translate="yes" xml:space="preserve">
          <source>after_spawn()</source>
          <target state="translated">after_spawn()</target>
        </trans-unit>
        <trans-unit id="37aa41bf7a8f9c353386d2e070f77fe39891ca05" translate="yes" xml:space="preserve">
          <source>after_spawn(fun)</source>
          <target state="translated">after_spawn(fun)</target>
        </trans-unit>
        <trans-unit id="fc71d9fb4fd6ade47fc3030c4b6c3bcf588c5c94" translate="yes" xml:space="preserve">
          <source>after_suite(function)</source>
          <target state="translated">after_suite(function)</target>
        </trans-unit>
        <trans-unit id="ff38ff39073554eaf31d825e65d45b40089354f7" translate="yes" xml:space="preserve">
          <source>agent()</source>
          <target state="translated">agent()</target>
        </trans-unit>
        <trans-unit id="cdb6fdbe91faa53a7c573c80b7c18108c73c0480" translate="yes" xml:space="preserve">
          <source>alias</source>
          <target state="translated">alias</target>
        </trans-unit>
        <trans-unit id="5cc4610153b63e761e50055d6f3406a292d36d24" translate="yes" xml:space="preserve">
          <source>alias (2)</source>
          <target state="translated">别名 (2)</target>
        </trans-unit>
        <trans-unit id="6c0f0e22f862a3f8150ad4251e1111003f9e0e0c" translate="yes" xml:space="preserve">
          <source>alias! (1)</source>
          <target state="translated">别名 (1)</target>
        </trans-unit>
        <trans-unit id="eb8fae47b62a763edb0b639bc40712c6a38f111f" translate="yes" xml:space="preserve">
          <source>alias!(alias)</source>
          <target state="translated">alias!(alias)</target>
        </trans-unit>
        <trans-unit id="a8b5798a733a4fa8b3ccbccbcfcd78d9a10d36f6" translate="yes" xml:space="preserve">
          <source>alias(module, opts)</source>
          <target state="translated">别名(模块,选项)</target>
        </trans-unit>
        <trans-unit id="0faa5faaa456de937e347a6133ce03ef41eae84c" translate="yes" xml:space="preserve">
          <source>alias, require, and import</source>
          <target state="translated">别名、要求和导入</target>
        </trans-unit>
        <trans-unit id="1f945f3e60b949b53afbdc3b404472e659917a92" translate="yes" xml:space="preserve">
          <source>alias?(task)</source>
          <target state="translated">alias?(task)</target>
        </trans-unit>
        <trans-unit id="fab9d011a9c66d8d4da688adc4b2c7d7ec3885b4" translate="yes" xml:space="preserve">
          <source>aliases()</source>
          <target state="translated">aliases()</target>
        </trans-unit>
        <trans-unit id="dbbf7995a790b99eae045a30b54348abfd4809e9" translate="yes" xml:space="preserve">
          <source>alive?()</source>
          <target state="translated">alive?()</target>
        </trans-unit>
        <trans-unit id="b5ff5e5840a9cf81b029ed8d3e96cc03abc9f13e" translate="yes" xml:space="preserve">
          <source>alive?(pid)</source>
          <target state="translated">alive?(pid)</target>
        </trans-unit>
        <trans-unit id="37a2eb0945387d30fb64cb5fe24823e361f0921b" translate="yes" xml:space="preserve">
          <source>all()</source>
          <target state="translated">all()</target>
        </trans-unit>
        <trans-unit id="39179de0b113f2ca95b427e4a53ccb0b209a7ff3" translate="yes" xml:space="preserve">
          <source>all?(enumerable, fun \\ fn x -&amp;gt; x end)</source>
          <target state="translated">全部？（可枚举，有趣\\ fn x-&amp;gt; x end）</target>
        </trans-unit>
        <trans-unit id="93a055419ae32c75e105336b93742551d4fda292" translate="yes" xml:space="preserve">
          <source>all_modules()</source>
          <target state="translated">all_modules()</target>
        </trans-unit>
        <trans-unit id="ac77d52be4d42a98c15771a338e4226ec89f6e05" translate="yes" xml:space="preserve">
          <source>allows I/O messages to be routed between different nodes running Distributed Erlang or even exchange files to perform read/write operations across nodes.</source>
          <target state="translated">允许I/O消息在运行分布式Erlang的不同节点之间进行路由,甚至可以交换文件,跨节点进行读写操作。</target>
        </trans-unit>
        <trans-unit id="9af63204b35727b98209702287f461a07397dfd9" translate="yes" xml:space="preserve">
          <source>alnum - Letters and digits</source>
          <target state="translated">alnum-字母和数字</target>
        </trans-unit>
        <trans-unit id="7e5694e774d6739e2b00961f10b8ece1cca403e5" translate="yes" xml:space="preserve">
          <source>alpha - Letters</source>
          <target state="translated">阿尔法-字母</target>
        </trans-unit>
        <trans-unit id="0946daf5267d99207384f84b7d292e1e9e17cad0" translate="yes" xml:space="preserve">
          <source>an atom - the GenServer is registered locally with the given name using &lt;a href=&quot;process#register/2&quot;&gt;&lt;code&gt;Process.register/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">原子-GenServer使用&lt;a href=&quot;process#register/2&quot;&gt; &lt;code&gt;Process.register/2&lt;/code&gt; &lt;/a&gt;以给定名称在本地注册。</target>
        </trans-unit>
        <trans-unit id="496287211e92533c4e83f2030cb5ab193e3c0cfc" translate="yes" xml:space="preserve">
          <source>an atom if the server is locally registered</source>
          <target state="translated">如果服务器在本地注册,则是一个原子</target>
        </trans-unit>
        <trans-unit id="131777738477ba63d177d41cf489fc34bb166d23" translate="yes" xml:space="preserve">
          <source>and (2)</source>
          <target state="translated">和(2)</target>
        </trans-unit>
        <trans-unit id="1d0661ad9f7cc4fe3c1410d2fbf9527ce0a6d2c3" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;&amp;lt;Continue&amp;gt;&lt;/code&gt; uses the same categories as the spec but restricts them to the NFC form (see R6):</source>
          <target state="translated">和 &lt;code&gt;&amp;lt;Continue&amp;gt;&lt;/code&gt; 使用与规范相同的类别，但将它们限制为NFC形式（请参阅R6）：</target>
        </trans-unit>
        <trans-unit id="5ebbc3bb0112607475023e59440002eed1b931b0" translate="yes" xml:space="preserve">
          <source>and Elixir will properly interpolate values.</source>
          <target state="translated">和Elixir将正确地插值。</target>
        </trans-unit>
        <trans-unit id="adf717a037ab7af9bc9bacbd3b34170933270e02" translate="yes" xml:space="preserve">
          <source>and be out of the range &lt;code&gt;0xD800..0xDFFF&lt;/code&gt; (&lt;code&gt;55_296..57_343&lt;/code&gt;), which is reserved in Unicode for UTF-16 surrogate pairs.</source>
          <target state="translated">并超出 &lt;code&gt;0xD800..0xDFFF&lt;/code&gt; （ &lt;code&gt;55_296..57_343&lt;/code&gt; ）的范围，该范围在Unicode中为UTF-16代理对保留。</target>
        </trans-unit>
        <trans-unit id="416ef67e71d26bc8e2cc631b1ae5b57b302d0d56" translate="yes" xml:space="preserve">
          <source>and in this one</source>
          <target state="translated">而在这个</target>
        </trans-unit>
        <trans-unit id="71b18172343bdb8b2660d75e53835253043852f1" translate="yes" xml:space="preserve">
          <source>and it depends on previous chapters in this guide. For more information, &lt;a href=&quot;introduction-to-mix&quot;&gt;read the introduction guide&lt;/a&gt; or check out the chapter index in the sidebar.</source>
          <target state="translated">并且取决于本指南的前几章。有关更多信息，请&lt;a href=&quot;introduction-to-mix&quot;&gt;阅读介绍指南&lt;/a&gt;或查看侧栏中的章节索引。</target>
        </trans-unit>
        <trans-unit id="7554dcd8106373b0fd9319e03515dd9d1ce9f49e" translate="yes" xml:space="preserve">
          <source>and only from Elixir v1.2 are they capable of holding millions of keys efficiently. Therefore, if you are working with previous Elixir versions (v1.0 or v1.1) and you need to support at least hundreds of keys, you may consider using &lt;a href=&quot;https://hexdocs.pm/elixir/HashDict.html&quot;&gt;the &lt;code&gt;HashDict&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">仅从Elixir v1.2起，它们才能够有效地保存数百万个密钥。因此，如果您正在使用以前版本的药剂（V1.0或V1.1）工作，你需要至少几百个键的支持，您可以考虑使用&lt;a href=&quot;https://hexdocs.pm/elixir/HashDict.html&quot;&gt;的 &lt;code&gt;HashDict&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23e76f170a2eec0baa07dd75bc86236006356315" translate="yes" xml:space="preserve">
          <source>and other curiosities.</source>
          <target state="translated">和其他奇珍异宝。</target>
        </trans-unit>
        <trans-unit id="88d6b2f25f6107df46423a22c504ff1f6d070ffb" translate="yes" xml:space="preserve">
          <source>and the generated application resource file is going to have it included.</source>
          <target state="translated">而生成的应用程序资源文件将包含它。</target>
        </trans-unit>
        <trans-unit id="98f1d1d3c723d0bdc3fe73d908452997c2f3f2b2" translate="yes" xml:space="preserve">
          <source>and then defining a &lt;code&gt;my_app/application.ex&lt;/code&gt; file with the following template:</source>
          <target state="translated">然后使用以下模板定义 &lt;code&gt;my_app/application.ex&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="142f05ea46227e8a90a3d5dca1f7a01d291d3eeb" translate="yes" xml:space="preserve">
          <source>and then you can use &lt;code&gt;Counter&lt;/code&gt;, &lt;code&gt;{Counter, name: :my_counter}&lt;/code&gt; or even &lt;code&gt;{Counter, initial_value: 0, name: :my_counter}&lt;/code&gt; as a child specification.</source>
          <target state="translated">然后您可以使用 &lt;code&gt;Counter&lt;/code&gt; ， &lt;code&gt;{Counter, name: :my_counter}&lt;/code&gt; 或什至 &lt;code&gt;{Counter, initial_value: 0, name: :my_counter}&lt;/code&gt; 作为子规范。</target>
        </trans-unit>
        <trans-unit id="478c17c32f1bc3336788616eaad90d7da7f5fbd4" translate="yes" xml:space="preserve">
          <source>and then:</source>
          <target state="translated">然后:</target>
        </trans-unit>
        <trans-unit id="685629935c929e5f82705c8f9ff9de20984e688d" translate="yes" xml:space="preserve">
          <source>anonymous functions (&lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/a&gt;s):</source>
          <target state="translated">匿名函数（&lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt; &lt;code&gt;fn&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="70119b4f69236b27bdb7be512c74762ccd02429c" translate="yes" xml:space="preserve">
          <source>ansicode()</source>
          <target state="translated">ansicode()</target>
        </trans-unit>
        <trans-unit id="321063ba0f7d36a07cbde2dcfb75bcf14e7fdeee" translate="yes" xml:space="preserve">
          <source>ansidata()</source>
          <target state="translated">ansidata()</target>
        </trans-unit>
        <trans-unit id="20133b0aad87c7e344e5c1b69ed2d95aa539d46f" translate="yes" xml:space="preserve">
          <source>ansilist()</source>
          <target state="translated">ansilist()</target>
        </trans-unit>
        <trans-unit id="ffb7124e173aac9be0b5dc9e9143b3d7c16b5adb" translate="yes" xml:space="preserve">
          <source>any integer &amp;gt;= 0 - the amount of time in milliseconds that the supervisor will wait for its children to terminate after emitting a &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; signal. If the child process is not trapping exits, the initial &lt;code&gt;:shutdown&lt;/code&gt; signal will terminate the child process immediately. If the child process is trapping exits, it has the given amount of time to terminate. If it doesn't terminate within the specified time, the child process is unconditionally terminated by the supervisor via &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt;.</source>
          <target state="translated">任何大于等于0的整数-主管在发出 &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; 信号后，等待其子项终止的时间（以毫秒为单位）。如果子进程未捕获退出，则初始 &lt;code&gt;:shutdown&lt;/code&gt; 信号将立即终止子进程。如果子进程正在捕获出口，则它具有给定的终止时间。如果未在指定时间内终止，则主管将通过 &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt; 无条件终止子进程。</target>
        </trans-unit>
        <trans-unit id="d3add7802830a2ed653c15ee887ce11205bfaf20" translate="yes" xml:space="preserve">
          <source>any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they're trapping exits</source>
          <target state="translated">任何其他术语--在这种情况下,退出将被记录下来,在瞬态模式下会有重启,链接的进程以同样的理由退出,除非它们是陷阱退出</target>
        </trans-unit>
        <trans-unit id="95de94b41d93e056d6d220532526c89ac6a67f71" translate="yes" xml:space="preserve">
          <source>any?(enumerable, fun \\ fn x -&amp;gt; x end)</source>
          <target state="translated">有吗？（可枚举，有趣\\ fn x-&amp;gt; x end）</target>
        </trans-unit>
        <trans-unit id="c8f9c188d78117e2a9e04c394de85091eb503226" translate="yes" xml:space="preserve">
          <source>any_container()</source>
          <target state="translated">any_container()</target>
        </trans-unit>
        <trans-unit id="eec1a38f7cc6cb9de70c40db411860fd9abae024" translate="yes" xml:space="preserve">
          <source>app is an atom</source>
          <target state="translated">应用是一个原子</target>
        </trans-unit>
        <trans-unit id="c83f1f5829ef91e20b92b78798a2c99b3393b74b" translate="yes" xml:space="preserve">
          <source>app()</source>
          <target state="translated">app()</target>
        </trans-unit>
        <trans-unit id="0172ce912b50113a477b0e455740f304b7eea4ee" translate="yes" xml:space="preserve">
          <source>app_dir(app)</source>
          <target state="translated">app_dir(app)</target>
        </trans-unit>
        <trans-unit id="19c796508dd45f1c1e4e466da19f5b77298e0763" translate="yes" xml:space="preserve">
          <source>app_dir(app, path)</source>
          <target state="translated">app_dir(app,path)</target>
        </trans-unit>
        <trans-unit id="9b2802cea7bd42f1fcb26ef84f823d14668e7861" translate="yes" xml:space="preserve">
          <source>app_path(config \\ config())</source>
          <target state="translated">app_path(config \ config())</target>
        </trans-unit>
        <trans-unit id="351ef5db651a2723ebf39a98522567b002c71d00" translate="yes" xml:space="preserve">
          <source>append(tuple, value)</source>
          <target state="translated">附加(元组,值)</target>
        </trans-unit>
        <trans-unit id="3b576e39d37e223620720715f18830f4bf25cfa7" translate="yes" xml:space="preserve">
          <source>append_path(path)</source>
          <target state="translated">append_path(path)</target>
        </trans-unit>
        <trans-unit id="de44800be3da4c5ae013680a4d6af1051f14b05d" translate="yes" xml:space="preserve">
          <source>application_key()</source>
          <target state="translated">application_key()</target>
        </trans-unit>
        <trans-unit id="2c4cc2df189b226e99afec198faaea9c8bacefdf" translate="yes" xml:space="preserve">
          <source>apply (2)</source>
          <target state="translated">适用(2)</target>
        </trans-unit>
        <trans-unit id="5615a998e3b8b79aa485fda118694eade5689ca0" translate="yes" xml:space="preserve">
          <source>apply (3)</source>
          <target state="translated">适用(3)</target>
        </trans-unit>
        <trans-unit id="1c292ff23209404c48e206dced70e337f9649050" translate="yes" xml:space="preserve">
          <source>apply(fun, args)</source>
          <target state="translated">应用(fun,args)</target>
        </trans-unit>
        <trans-unit id="74580a850266eb2226c2e0b6d896e2f6d5f6826b" translate="yes" xml:space="preserve">
          <source>apply(module, function_name, args)</source>
          <target state="translated">apply(module,function_name,args)</target>
        </trans-unit>
        <trans-unit id="5174ecf486063648d222f223b1195abf8c33a5b7" translate="yes" xml:space="preserve">
          <source>apps_paths(config \\ config())</source>
          <target state="translated">apps_paths(config \ config())</target>
        </trans-unit>
        <trans-unit id="528238dd031e3950071d8f842568c18643095636" translate="yes" xml:space="preserve">
          <source>are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter.</source>
          <target state="translated">被认为是等价的(嵌套与大部分用户格式化一起被丢弃)。在这种情况下,代码格式化器将始终按照后者进行格式化。</target>
        </trans-unit>
        <trans-unit id="986c3f6a6bea3f83bc4b2411f4940435940d3b52" translate="yes" xml:space="preserve">
          <source>arguments do not need to be escaped or quoted for shell safety</source>
          <target state="translated">为了外壳安全,参数不需要转义或引号。</target>
        </trans-unit>
        <trans-unit id="89e29e7cee01719de72906bdd3d4fbdb5be8b870" translate="yes" xml:space="preserve">
          <source>argv()</source>
          <target state="translated">argv()</target>
        </trans-unit>
        <trans-unit id="2a43e669413bad9c7a43cf276187f748ca58f246" translate="yes" xml:space="preserve">
          <source>argv(args)</source>
          <target state="translated">argv(args)</target>
        </trans-unit>
        <trans-unit id="79024a8401b2b8c396f988fb810ff0532f91eb9c" translate="yes" xml:space="preserve">
          <source>arithmetic unary and binary operators (&lt;a href=&quot;kernel#+/1&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#-/1&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#+/2&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#-/2&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#*/2&quot;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#//2&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">算术一元和二进制运算符（&lt;a href=&quot;kernel#+/1&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#-/1&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#+/2&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#-/2&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#*/2&quot;&gt; &lt;code&gt;*&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#//2&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="95257280b57ef4faff560cbaa0800e101d3c11b4" translate="yes" xml:space="preserve">
          <source>as a last resort, the current working directory</source>
          <target state="translated">作为最后的手段,当前工作目录</target>
        </trans-unit>
        <trans-unit id="ac68ccf28ae7e12cede55b97d51ef7d14aa7d630" translate="yes" xml:space="preserve">
          <source>as, in case of an error, &lt;code&gt;File.read/1&lt;/code&gt; will return &lt;code&gt;{:error, reason}&lt;/code&gt; and the pattern matching will fail. You will still get the desired result (a raised error), but the message will be about the pattern which doesn&amp;rsquo;t match (thus being cryptic in respect to what the error actually is about).</source>
          <target state="translated">因为如果发生错误， &lt;code&gt;File.read/1&lt;/code&gt; 将返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 并且模式匹配将失败。您仍将获得所需的结果（引发错误），但消息将显示不匹配的模式（因此对于错误的实质是神秘的）。</target>
        </trans-unit>
        <trans-unit id="18a1ee2b34ca9c4a1fa8225b0b75c12be5fbb9a3" translate="yes" xml:space="preserve">
          <source>ascii - Character codes 0-127</source>
          <target state="translated">ascii-字符编码0-127</target>
        </trans-unit>
        <trans-unit id="74f18c1e2a01a57019fe79463f0a25da9ac0e5bd" translate="yes" xml:space="preserve">
          <source>ascii_printable?(list, limit \\ :infinity)</source>
          <target state="translated">ascii_printable?(list,limit :infinity)</target>
        </trans-unit>
        <trans-unit id="10c643ecc7e0f982a932fb0bea65d12d5287287b" translate="yes" xml:space="preserve">
          <source>assert(assertion)</source>
          <target state="translated">assert(assertion)</target>
        </trans-unit>
        <trans-unit id="89e19f9af27aa7c7669a80939500245f8dcf0e16" translate="yes" xml:space="preserve">
          <source>assert(value, message)</source>
          <target state="translated">assert(value,message)</target>
        </trans-unit>
        <trans-unit id="860e867b9917efbcb8354cf902e62854e02a0b28" translate="yes" xml:space="preserve">
          <source>assert_impl!(protocol, base)</source>
          <target state="translated">assert_impl!(protocol,base)</target>
        </trans-unit>
        <trans-unit id="d63fbdddec239c5bb5588153e2a2b48598a7c639" translate="yes" xml:space="preserve">
          <source>assert_in_delta(value1, value2, delta, message \\ nil)</source>
          <target state="translated">assert_in_delta(value1,value2,delta,message ndil)</target>
        </trans-unit>
        <trans-unit id="f7fe0bb36981410620b40b362a87649e0515f878" translate="yes" xml:space="preserve">
          <source>assert_protocol!(module)</source>
          <target state="translated">assert_protocol!(module)</target>
        </trans-unit>
        <trans-unit id="9e15373b6a8595ae650733bfb0e4f98933ffa371" translate="yes" xml:space="preserve">
          <source>assert_raise(exception, function)</source>
          <target state="translated">assert_raise(exception,function)</target>
        </trans-unit>
        <trans-unit id="70f686bff8d88db9e0393e0c657dda87aeec8b59" translate="yes" xml:space="preserve">
          <source>assert_raise(exception, message, function)</source>
          <target state="translated">assert_raise(exception,message,function)</target>
        </trans-unit>
        <trans-unit id="efad9e6cb866dbe2d328bdc1b1b0875a045f6632" translate="yes" xml:space="preserve">
          <source>assert_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\ nil)</source>
          <target state="translated">assert_receive(pattern,timeout \ Application.fetch_env!(:ex_unit,:assert_receive_timeout),failure_message \ nil)</target>
        </trans-unit>
        <trans-unit id="6d612077d393bab96c575feb95121035be357414" translate="yes" xml:space="preserve">
          <source>assert_received(pattern, failure_message \\ nil)</source>
          <target state="translated">assert_received(pattern,failure_message №nil)</target>
        </trans-unit>
        <trans-unit id="67bbf25898432cbcf651834e6b82fcb163d31316" translate="yes" xml:space="preserve">
          <source>async (1)</source>
          <target state="translated">异步 (1)</target>
        </trans-unit>
        <trans-unit id="39bef3890cabe2f7913073bb5a5d985159fc9508" translate="yes" xml:space="preserve">
          <source>async and await</source>
          <target state="translated">异步和等待</target>
        </trans-unit>
        <trans-unit id="ba0642bd07de1e47a5422933f5c84b2c61e67a64" translate="yes" xml:space="preserve">
          <source>async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation.</source>
          <target state="translated">async任务将调用者和生成的进程联系在一起,这意味着如果调用者崩溃,任务也会崩溃,反之亦然。这意味着,如果调用者崩溃,任务也会崩溃,反之亦然。这是故意的:如果用来接收结果的进程不再存在,那么完成计算就没有意义。</target>
        </trans-unit>
        <trans-unit id="3a1f114d26725f770a8d4a464e1b0b509f09efdd" translate="yes" xml:space="preserve">
          <source>async(fun)</source>
          <target state="translated">async(fun)</target>
        </trans-unit>
        <trans-unit id="b14f5a3ba085e9b047044838e3238e71f042980e" translate="yes" xml:space="preserve">
          <source>async(module, function_name, args)</source>
          <target state="translated">async(module,function_name,args)</target>
        </trans-unit>
        <trans-unit id="644a7c96c9dda0b61175fcadd25ad5a2d8e57a99" translate="yes" xml:space="preserve">
          <source>async(supervisor, fun, options \\ [])</source>
          <target state="translated">async(supervisor,fun,options \ [])</target>
        </trans-unit>
        <trans-unit id="16eb8d415870b59d9a0cbf04b3ae5e3064a9d91a" translate="yes" xml:space="preserve">
          <source>async(supervisor, module, fun, args, options \\ [])</source>
          <target state="translated">async(supervisor,module,fun,args,options \ [])</target>
        </trans-unit>
        <trans-unit id="6c49f1d590dc630e8a7e644e6326dcfbba229928" translate="yes" xml:space="preserve">
          <source>async/await</source>
          <target state="translated">async/await</target>
        </trans-unit>
        <trans-unit id="6ded9b71c03e31e3335a220d12ea3decd27795ad" translate="yes" xml:space="preserve">
          <source>async_nolink(supervisor, fun, options \\ [])</source>
          <target state="translated">async_nolink(supervisor,fun,options \ [])</target>
        </trans-unit>
        <trans-unit id="5afd38dae84f83eb3b40407823f41867e8ae805f" translate="yes" xml:space="preserve">
          <source>async_nolink(supervisor, module, fun, args, options \\ [])</source>
          <target state="translated">async_nolink(supervisor,module,fun,args,options \ [])</target>
        </trans-unit>
        <trans-unit id="2f5130f8e94b55df9c539856cfedaf60b50c1c6a" translate="yes" xml:space="preserve">
          <source>async_stream(enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream(enumerable,fun,options \ [])</target>
        </trans-unit>
        <trans-unit id="6dff84790a691c5d99359ee6110cfa62264d22a4" translate="yes" xml:space="preserve">
          <source>async_stream(enumerable, module, function_name, args, options \\ [])</source>
          <target state="translated">async_stream(enumerable,module,function_name,args,options \ [])</target>
        </trans-unit>
        <trans-unit id="d6abe4ed4639f30d24556dd4a0636c6853a73c61" translate="yes" xml:space="preserve">
          <source>async_stream(supervisor, enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream(supervisor,enumerable,fun,options \ [])</target>
        </trans-unit>
        <trans-unit id="1e4df82d00aafae592ea5db9b625f8d3a3370713" translate="yes" xml:space="preserve">
          <source>async_stream(supervisor, enumerable, module, function, args, options \\ [])</source>
          <target state="translated">async_stream(supervisor,enumerable,module,function,args,options \ [])</target>
        </trans-unit>
        <trans-unit id="e6770803ae75b3d74fe4816bda7f7a7878642ed7" translate="yes" xml:space="preserve">
          <source>async_stream_nolink(supervisor, enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream_nolink(supervisor,enumerable,fun,options \ [])</target>
        </trans-unit>
        <trans-unit id="099585fc354d29712529a12df14a7f56439d0975" translate="yes" xml:space="preserve">
          <source>async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</source>
          <target state="translated">async_stream_nolink(supervisor,enumerable,module,function,args,options \ [])</target>
        </trans-unit>
        <trans-unit id="bf99c9094d6c44fe17f2b0edfc99564c384277a8" translate="yes" xml:space="preserve">
          <source>at(enumerable, index, default \\ nil)</source>
          <target state="translated">at(enumerable,index,default \ nil)</target>
        </trans-unit>
        <trans-unit id="35774d217491acb444648d4d8aa5dc599e6cf8ac" translate="yes" xml:space="preserve">
          <source>at(index)</source>
          <target state="translated">at(index)</target>
        </trans-unit>
        <trans-unit id="211c902c31671d0d69de0333dc6af625b8c09a4a" translate="yes" xml:space="preserve">
          <source>at(string, position)</source>
          <target state="translated">at(string,position)</target>
        </trans-unit>
        <trans-unit id="5b6c1250ee522b774f28773b006af9d68577716a" translate="yes" xml:space="preserve">
          <source>at_exit(fun)</source>
          <target state="translated">at_exit(fun)</target>
        </trans-unit>
        <trans-unit id="af97844af6122f4c0ef7841a6b4ab699109913de" translate="yes" xml:space="preserve">
          <source>atoms - such as &lt;code&gt;:foo&lt;/code&gt;</source>
          <target state="translated">原子-如 &lt;code&gt;:foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbfb09c8eb2bfe559864c2afdb7974e99f9daec5" translate="yes" xml:space="preserve">
          <source>atoms containing interpolation (&lt;code&gt;:&quot;#{1 + 1} is two&quot;&lt;/code&gt;), as these atoms are constructed at runtime.</source>
          <target state="translated">包含插值的原子（ &lt;code&gt;:&quot;#{1 + 1} is two&quot;&lt;/code&gt; ），因为这些原子是在运行时构造的。</target>
        </trans-unit>
        <trans-unit id="c668bbd97902c35149e9703edfac74cda21fa48f" translate="yes" xml:space="preserve">
          <source>available_compiler_options()</source>
          <target state="translated">available_compiler_options()</target>
        </trans-unit>
        <trans-unit id="e0981f3198429f4044bfc1486fe7ae63a66f1090" translate="yes" xml:space="preserve">
          <source>await(task, timeout \\ 5000)</source>
          <target state="translated">await(task,timeout \5000)</target>
        </trans-unit>
        <trans-unit id="0cd00c30b019ba6ecfdabddaa2f4a56b546dde96" translate="yes" xml:space="preserve">
          <source>b(term)</source>
          <target state="translated">b(term)</target>
        </trans-unit>
        <trans-unit id="95e538affb9563d8a246471c2d822f6605fa9f9a" translate="yes" xml:space="preserve">
          <source>backend()</source>
          <target state="translated">backend()</target>
        </trans-unit>
        <trans-unit id="f395b7176e4e6c22a72c7354b91fe4f3c90e5bf3" translate="yes" xml:space="preserve">
          <source>bag_distance(string1, string2)</source>
          <target state="translated">bag_distance(string1,string2)</target>
        </trans-unit>
        <trans-unit id="65a3bb5b7fcec69eefa8a1df1aabbde9925d3db2" translate="yes" xml:space="preserve">
          <source>band(left, right)</source>
          <target state="translated">带(左、右)</target>
        </trans-unit>
        <trans-unit id="b626e95c9a950f9c3e9d14c4b36ee2333a1f9d6f" translate="yes" xml:space="preserve">
          <source>bare_log(level, chardata_or_fun, metadata \\ [])</source>
          <target state="translated">bare_log(level,chardata_or_fun,metadata \ [])</target>
        </trans-unit>
        <trans-unit id="fb644a6b04b7b3bf241d7acf3a194cbe9ac88c6d" translate="yes" xml:space="preserve">
          <source>basename(path)</source>
          <target state="translated">basename(path)</target>
        </trans-unit>
        <trans-unit id="d1b1d07bdf062e516810f3b9a5acb8ae84899cba" translate="yes" xml:space="preserve">
          <source>basename(path, extension)</source>
          <target state="translated">basename(path,extension)</target>
        </trans-unit>
        <trans-unit id="e365b24437ffe1b6ca5c1e482c3b340b99ca0f89" translate="yes" xml:space="preserve">
          <source>basic language primitives, such as arithmetic operators, spawning of processes, data type handling, etc.</source>
          <target state="translated">基本的语言基元,如算术运算符、进程的生成、数据类型处理等。</target>
        </trans-unit>
        <trans-unit id="257074bfad4f890ba2be69198a08555a8b68a240" translate="yes" xml:space="preserve">
          <source>be within the range &lt;code&gt;0..0x10FFFF&lt;/code&gt; (&lt;code&gt;0..1_114_111&lt;/code&gt;);</source>
          <target state="translated">处于 &lt;code&gt;0..0x10FFFF&lt;/code&gt; （ &lt;code&gt;0..1_114_111&lt;/code&gt; ）范围内；</target>
        </trans-unit>
        <trans-unit id="61945a024d3ad31bc97b4c4146a493ba6965aaff" translate="yes" xml:space="preserve">
          <source>binary_part (3)</source>
          <target state="translated">二进制部分 (3)</target>
        </trans-unit>
        <trans-unit id="3f0fe199d299de392ea64a31ca3f12d433002fb5" translate="yes" xml:space="preserve">
          <source>binary_part(binary, start, length)</source>
          <target state="translated">binary_part(binary,start,length)</target>
        </trans-unit>
        <trans-unit id="be55a3267db4409f034493415797db14292fd1c3" translate="yes" xml:space="preserve">
          <source>binding (1)</source>
          <target state="translated">约束力 (1)</target>
        </trans-unit>
        <trans-unit id="ddb8ed4423f573770a2ab96f9aa5237c643b668e" translate="yes" xml:space="preserve">
          <source>binding(context \\ nil)</source>
          <target state="translated">binding(context \ nil)</target>
        </trans-unit>
        <trans-unit id="a2c53f1bbe25d58eae391d9f98327f3756ec5f19" translate="yes" xml:space="preserve">
          <source>binread(device \\ :stdio, line_or_chars)</source>
          <target state="translated">binread(device \ :stdio,line_or_chars)</target>
        </trans-unit>
        <trans-unit id="3770d2369f69a250c90abd2d17e302aa32774f58" translate="yes" xml:space="preserve">
          <source>binstream(device, line_or_bytes)</source>
          <target state="translated">binstream(device,line_or_bytes)</target>
        </trans-unit>
        <trans-unit id="cf21ab6ef6f6a1dc37c2bd554365dd95b9009565" translate="yes" xml:space="preserve">
          <source>binwrite(device \\ :stdio, iodata)</source>
          <target state="translated">binwrite(device \ :stdio,iodata)</target>
        </trans-unit>
        <trans-unit id="506697def21c57073a87a2ce3681f1c117381614" translate="yes" xml:space="preserve">
          <source>bit_size (1)</source>
          <target state="translated">bit_size (1)</target>
        </trans-unit>
        <trans-unit id="399dc342625b72f3c79a77636b1f6a9e8df981c5" translate="yes" xml:space="preserve">
          <source>bit_size(bitstring)</source>
          <target state="translated">bit_size(bitstring)</target>
        </trans-unit>
        <trans-unit id="bc4218e8336dca1e4bc683da88053d8cc252fcd1" translate="yes" xml:space="preserve">
          <source>black()</source>
          <target state="translated">black()</target>
        </trans-unit>
        <trans-unit id="22f91081b2fc08e1b706c14fd06f5fe49b205d51" translate="yes" xml:space="preserve">
          <source>black_background()</source>
          <target state="translated">black_background()</target>
        </trans-unit>
        <trans-unit id="1a49af7a4bbad040aaf5dce728ad2542d89f9b1e" translate="yes" xml:space="preserve">
          <source>blame(kind, error, stacktrace)</source>
          <target state="translated">责备(kind,error,stacktrace)</target>
        </trans-unit>
        <trans-unit id="edf4584177e9a79f5d425d4594a659bec1cc30dd" translate="yes" xml:space="preserve">
          <source>blame(t, stacktrace)</source>
          <target state="translated">责备(t,stacktrace)</target>
        </trans-unit>
        <trans-unit id="5094e5cc5ec1839a56d830ac198bf301f64b3e0c" translate="yes" xml:space="preserve">
          <source>blame_mfa(module, function, args)</source>
          <target state="translated">blame_mfa(module,function,args)</target>
        </trans-unit>
        <trans-unit id="cfebdf29b405f0ee7f4bf2f1c41fc7a8113058e6" translate="yes" xml:space="preserve">
          <source>blank - Space or tab only</source>
          <target state="translated">空白--只有空格或制表符</target>
        </trans-unit>
        <trans-unit id="408c177bae9d4727cd6f1daf2d926adbff67a5d5" translate="yes" xml:space="preserve">
          <source>blink_off()</source>
          <target state="translated">blink_off()</target>
        </trans-unit>
        <trans-unit id="db1ee76d307eab2e31f726ec884808f99a379b6b" translate="yes" xml:space="preserve">
          <source>blink_rapid()</source>
          <target state="translated">blink_rapid()</target>
        </trans-unit>
        <trans-unit id="20ae1db39f56eaf21a4311706905d4d48b969338" translate="yes" xml:space="preserve">
          <source>blink_slow()</source>
          <target state="translated">blink_slow()</target>
        </trans-unit>
        <trans-unit id="5cbbabeea6cd89e740f4fc04c12080d75eb788a6" translate="yes" xml:space="preserve">
          <source>blue()</source>
          <target state="translated">blue()</target>
        </trans-unit>
        <trans-unit id="d0d904edb1e8432e4d4569b8a4a440d3d42de84c" translate="yes" xml:space="preserve">
          <source>blue_background()</source>
          <target state="translated">blue_background()</target>
        </trans-unit>
        <trans-unit id="bce6c1eaf6b9cc0363d6fbe35526dd7395dd9ebf" translate="yes" xml:space="preserve">
          <source>bnot(expr)</source>
          <target state="translated">bnot(expr)</target>
        </trans-unit>
        <trans-unit id="75453e75a84ed7fb955577a4f8826dc89812816d" translate="yes" xml:space="preserve">
          <source>body()</source>
          <target state="translated">body()</target>
        </trans-unit>
        <trans-unit id="6b558f5e575d32f5db340e51a80be898e0c6903b" translate="yes" xml:space="preserve">
          <source>bor(left, right)</source>
          <target state="translated">bor(左、右)</target>
        </trans-unit>
        <trans-unit id="c9ec3865e390b027fae9d08e39e51a720bcdea73" translate="yes" xml:space="preserve">
          <source>break!(ast, stops \\ 1)</source>
          <target state="translated">(stat,stops/1)</target>
        </trans-unit>
        <trans-unit id="3105037b87100ee55a10455e35df32ef2f6ec6e2" translate="yes" xml:space="preserve">
          <source>break!(module, function, arity, stops \\ 1)</source>
          <target state="translated">break!(module,function,arity,stops ⑴)</target>
        </trans-unit>
        <trans-unit id="b161e4f7384e3c463d8ee3978b04065bf8310004" translate="yes" xml:space="preserve">
          <source>break(string \\ &quot; &quot;)</source>
          <target state="translated">break(string \ &quot;&quot; )</target>
        </trans-unit>
        <trans-unit id="969279661e12e7b53ad9773dae663e52ad3b02ff" translate="yes" xml:space="preserve">
          <source>breaks()</source>
          <target state="translated">breaks()</target>
        </trans-unit>
        <trans-unit id="af82e225252a073224a7c3f01edc22ba4186008f" translate="yes" xml:space="preserve">
          <source>bright()</source>
          <target state="translated">bright()</target>
        </trans-unit>
        <trans-unit id="8e5305b81a2bbb73a86dfa45df50bed29256eec1" translate="yes" xml:space="preserve">
          <source>bsl(left, right)</source>
          <target state="translated">bsl(左,右)</target>
        </trans-unit>
        <trans-unit id="e7c1b9ba1598634ac4edacaa6ca137c0d320f08c" translate="yes" xml:space="preserve">
          <source>bsr(left, right)</source>
          <target state="translated">bsr(左、右)</target>
        </trans-unit>
        <trans-unit id="8d0cf0327a36ac9e1f165d048984f61313aee81d" translate="yes" xml:space="preserve">
          <source>build()</source>
          <target state="translated">build()</target>
        </trans-unit>
        <trans-unit id="c7f20f10b9ebee5ce04a9c27a00c97be570b0d03" translate="yes" xml:space="preserve">
          <source>build_info()</source>
          <target state="translated">build_info()</target>
        </trans-unit>
        <trans-unit id="9550344570851db07d3e0819a8a3a0b3753b135d" translate="yes" xml:space="preserve">
          <source>build_path(config \\ config())</source>
          <target state="translated">build_path(config \ config())</target>
        </trans-unit>
        <trans-unit id="1b0451766a01a45d61cb81b0b5af3db4ff3621de" translate="yes" xml:space="preserve">
          <source>build_structure(config \\ config(), opts \\ [])</source>
          <target state="translated">build_structure(config \ config(),opts \ [])</target>
        </trans-unit>
        <trans-unit id="b5651891e94bcacea868412954d9cff44695f679" translate="yes" xml:space="preserve">
          <source>bxor(left, right)</source>
          <target state="translated">bxor(左,右)</target>
        </trans-unit>
        <trans-unit id="adbf128371d04f04e5778c12471cfccf93681b9b" translate="yes" xml:space="preserve">
          <source>by hitting &lt;code&gt;Ctrl+C&lt;/code&gt;, &lt;code&gt;Ctrl+C&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;Ctrl+C&lt;/code&gt; ， &lt;code&gt;Ctrl+C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e753f9c66c97edb4c4f26740cf8b1cb9e4365f1a" translate="yes" xml:space="preserve">
          <source>by hitting &lt;code&gt;Ctrl+\&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;Ctrl+\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea6b8e8b0ef7ba0453b4449f57eb25dfb303cc1d" translate="yes" xml:space="preserve">
          <source>by the following:</source>
          <target state="translated">以下列方式:</target>
        </trans-unit>
        <trans-unit id="7dd154f82b1fda04325f982dbdf38279aabe16c3" translate="yes" xml:space="preserve">
          <source>byte_size (1)</source>
          <target state="translated">字节大小 (1)</target>
        </trans-unit>
        <trans-unit id="4ff214729194657479037e5bca3207e9de11aa49" translate="yes" xml:space="preserve">
          <source>byte_size(bitstring)</source>
          <target state="translated">byte_size(bitstring)</target>
        </trans-unit>
        <trans-unit id="d16ceab0e45bec5a295e9952cc9a7d3cb7c03a9c" translate="yes" xml:space="preserve">
          <source>c(files, path \\ :in_memory)</source>
          <target state="translated">c(files,path \ in_memory)</target>
        </trans-unit>
        <trans-unit id="74234dcbd77bc7384b43232d09af56bb094382fe" translate="yes" xml:space="preserve">
          <source>calendar()</source>
          <target state="translated">calendar()</target>
        </trans-unit>
        <trans-unit id="888ee07121f2bfae0d4740685ae66af7e46e23ff" translate="yes" xml:space="preserve">
          <source>call(server, request, timeout \\ 5000)</source>
          <target state="translated">call(server,request,timeout 5000)</target>
        </trans-unit>
        <trans-unit id="63fdb8eeae5c54fc9ca6cdb74b6d83c85ae4493b" translate="yes" xml:space="preserve">
          <source>callers CALLEE</source>
          <target state="translated">呼叫者CALLEE</target>
        </trans-unit>
        <trans-unit id="c9d0d80d9a596c430e090c08563db16444dfbd52" translate="yes" xml:space="preserve">
          <source>calls &lt;a href=&quot;kernel#exit/1&quot;&gt;&lt;code&gt;Kernel.exit/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">调用&lt;a href=&quot;kernel#exit/1&quot;&gt; &lt;code&gt;Kernel.exit/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c668678f2ada7a0c68fc26b247e3f58c7ce70525" translate="yes" xml:space="preserve">
          <source>calls that have do/end blocks</source>
          <target state="translated">有do/end块的调用</target>
        </trans-unit>
        <trans-unit id="c755b037d46e6f1cb1f9ea7b8822144a3b8c931a" translate="yes" xml:space="preserve">
          <source>calls(opts \\ [])</source>
          <target state="translated">呼叫(opts \ [])</target>
        </trans-unit>
        <trans-unit id="ae98dadd984dd004bfabe5d8be6399524dc058b5" translate="yes" xml:space="preserve">
          <source>camelize(string)</source>
          <target state="translated">camelize(string)</target>
        </trans-unit>
        <trans-unit id="6a4a4f9af0c6d015686e71d41036a174ea8b4a89" translate="yes" xml:space="preserve">
          <source>can be alternatively written as:</source>
          <target state="translated">也可以写成:</target>
        </trans-unit>
        <trans-unit id="d8d74056d7dacfa0c5dbcc37f601364fbfc28a48" translate="yes" xml:space="preserve">
          <source>cancel_timer(timer_ref, options \\ [])</source>
          <target state="translated">cancel_timer(timer_ref,options 〔〕)</target>
        </trans-unit>
        <trans-unit id="c59a32c3ae74a29ed8f4825a8a23158c800ce201" translate="yes" xml:space="preserve">
          <source>capitalize(string, mode \\ :default)</source>
          <target state="translated">capitalize(string,mode :default)</target>
        </trans-unit>
        <trans-unit id="7801c477ed10d080a485a531ee939485640872e0" translate="yes" xml:space="preserve">
          <source>capture(module, function_name, arity)</source>
          <target state="translated">capture(module,function_name,arity)</target>
        </trans-unit>
        <trans-unit id="1c9491c87f2e11558e6519f43fbdfb13d5f75757" translate="yes" xml:space="preserve">
          <source>case (2)</source>
          <target state="translated">案例(2)</target>
        </trans-unit>
        <trans-unit id="81a6fde4212c2c4e7a6bd1dd35f4d99c1756341f" translate="yes" xml:space="preserve">
          <source>case(condition, clauses)</source>
          <target state="translated">条件</target>
        </trans-unit>
        <trans-unit id="276f41646d5e418a498785c796cbe58630038ac8" translate="yes" xml:space="preserve">
          <source>case, cond, and if</source>
          <target state="translated">情况、条件和如果</target>
        </trans-unit>
        <trans-unit id="548c74de3d80b7e38f71e4cd34ee4e6ccd1b0975" translate="yes" xml:space="preserve">
          <source>cast(agent, fun)</source>
          <target state="translated">投放(代理,乐趣)</target>
        </trans-unit>
        <trans-unit id="24e0d639ff0592f02425109ef44097ef5ac141c5" translate="yes" xml:space="preserve">
          <source>cast(agent, module, fun, args)</source>
          <target state="translated">cast(agent,module,fun,args)</target>
        </trans-unit>
        <trans-unit id="bb33c244d99388a4c4d4a6278437e929a37371e3" translate="yes" xml:space="preserve">
          <source>cast(server, request)</source>
          <target state="translated">cast(server,request)</target>
        </trans-unit>
        <trans-unit id="f03277fe202fe2b7ce8cfac6175d162d96f1c404" translate="yes" xml:space="preserve">
          <source>catch_error(expression)</source>
          <target state="translated">catch_error(expression)</target>
        </trans-unit>
        <trans-unit id="22357d5fea4ccbbe014225cf943cdbb904fa71e8" translate="yes" xml:space="preserve">
          <source>catch_exit(expression)</source>
          <target state="translated">catch_exit(expression)</target>
        </trans-unit>
        <trans-unit id="36c5ff014418577832a7f43d20d83f9df1b48315" translate="yes" xml:space="preserve">
          <source>catch_throw(expression)</source>
          <target state="translated">catch_throw(expression)</target>
        </trans-unit>
        <trans-unit id="eef8012abcece720e4d07c62d863a2d2175734b4" translate="yes" xml:space="preserve">
          <source>cd!(path)</source>
          <target state="translated">cd!(path)</target>
        </trans-unit>
        <trans-unit id="81c9dce342a6d8a1492ec615839db369a51b0f94" translate="yes" xml:space="preserve">
          <source>cd!(path, function)</source>
          <target state="translated">cd!(path,function)</target>
        </trans-unit>
        <trans-unit id="1dd216ecc62e3003f0dbc326881c8241acad3876" translate="yes" xml:space="preserve">
          <source>cd(directory)</source>
          <target state="translated">cd(directory)</target>
        </trans-unit>
        <trans-unit id="9d057759cbf39721ee3cc79b1c6bd1b4d46e4d3a" translate="yes" xml:space="preserve">
          <source>cd(path)</source>
          <target state="translated">cd(path)</target>
        </trans-unit>
        <trans-unit id="3dd9424e14dc92cab3a7059628ae05c63ea935c6" translate="yes" xml:space="preserve">
          <source>ceil (1)</source>
          <target state="translated">上限 (1)</target>
        </trans-unit>
        <trans-unit id="c0266349867fff0e975607d4351fa76a2942152b" translate="yes" xml:space="preserve">
          <source>ceil(number)</source>
          <target state="translated">ceil(number)</target>
        </trans-unit>
        <trans-unit id="898c69d5af7d06ea5554d05f8aa17ffe33956d77" translate="yes" xml:space="preserve">
          <source>ceil(number, precision \\ 0)</source>
          <target state="translated">ceil(number,precision \0)</target>
        </trans-unit>
        <trans-unit id="41250883c82e9cc4d38b14c0497792d0bcd5fb86" translate="yes" xml:space="preserve">
          <source>char_reserved?(character)</source>
          <target state="translated">char_reserved?(character)</target>
        </trans-unit>
        <trans-unit id="9a45ce6e3ba50ddf22610392b0c8e5f2ae6ecb16" translate="yes" xml:space="preserve">
          <source>char_unescaped?(character)</source>
          <target state="translated">char_unescaped?(character)</target>
        </trans-unit>
        <trans-unit id="f4e470362d53d791e6a6ac43d42e4b890af1b9bc" translate="yes" xml:space="preserve">
          <source>char_unreserved?(character)</source>
          <target state="translated">char_unreserved?(character)</target>
        </trans-unit>
        <trans-unit id="89f42ab843e9ae20f26ffaaf05bb7634df10168f" translate="yes" xml:space="preserve">
          <source>characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus &lt;code&gt;Other_ID_Start&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points</source>
          <target state="translated">从大写字母，小写字母，首字母大写字母，字母修饰，其他字母，字母数字，再加上Unicode通用类别衍生字符 &lt;code&gt;Other_ID_Start&lt;/code&gt; ，减去 &lt;code&gt;Pattern_Syntax&lt;/code&gt; 和 &lt;code&gt;Pattern_White_Space&lt;/code&gt; 码点</target>
        </trans-unit>
        <trans-unit id="8fc8134273725d4bc7abcdcfcd708ce5008d636d" translate="yes" xml:space="preserve">
          <source>chardata()</source>
          <target state="translated">chardata()</target>
        </trans-unit>
        <trans-unit id="997cc3a24dc9b7c66b31c3ba3f6d3b7f6a5bd2b6" translate="yes" xml:space="preserve">
          <source>chardata_to_string(string)</source>
          <target state="translated">chardata_to_string(string)</target>
        </trans-unit>
        <trans-unit id="841fc018c2d17064c5fbae4f894b2027171e7a64" translate="yes" xml:space="preserve">
          <source>chgrp!(path, gid)</source>
          <target state="translated">chgrp!(path,gid)</target>
        </trans-unit>
        <trans-unit id="83d8709394f90073805facd15aa07469e3948e6f" translate="yes" xml:space="preserve">
          <source>chgrp(path, gid)</source>
          <target state="translated">chgrp(path,gid)</target>
        </trans-unit>
        <trans-unit id="0e3a7c11a06fe711f18dbf309b00286b0d793c29" translate="yes" xml:space="preserve">
          <source>child()</source>
          <target state="translated">child()</target>
        </trans-unit>
        <trans-unit id="86091951beedcbf72fdc554efb159ae47024df63" translate="yes" xml:space="preserve">
          <source>child_id()</source>
          <target state="translated">child_id()</target>
        </trans-unit>
        <trans-unit id="85e835fef7ac9a461b0fe36250ff0a8682412f33" translate="yes" xml:space="preserve">
          <source>child_spec()</source>
          <target state="translated">child_spec()</target>
        </trans-unit>
        <trans-unit id="a8f980b6663ce5365507de71b4710fc32a3a5ef5" translate="yes" xml:space="preserve">
          <source>child_spec(arg)</source>
          <target state="translated">child_spec(arg)</target>
        </trans-unit>
        <trans-unit id="09111146ba8624fdb98d7c1dcb703e9ad5ea6a28" translate="yes" xml:space="preserve">
          <source>child_spec(init_arg)</source>
          <target state="translated">child_spec(init_arg)</target>
        </trans-unit>
        <trans-unit id="539727c4dd89232de4636588e068794deb56c936" translate="yes" xml:space="preserve">
          <source>child_spec(module_or_map, overrides)</source>
          <target state="translated">child_spec(module_or_map,overrides)</target>
        </trans-unit>
        <trans-unit id="c3700ef202062b71ca39c68af9581bb6d089f74e" translate="yes" xml:space="preserve">
          <source>child_spec(opts)</source>
          <target state="translated">child_spec(opts)</target>
        </trans-unit>
        <trans-unit id="fd3ab6f1ad23a2991f023b22a6718b03206bd695" translate="yes" xml:space="preserve">
          <source>child_spec/1</source>
          <target state="translated">child_spec/1</target>
        </trans-unit>
        <trans-unit id="a71358b312012362c5471e8ee75d872182d2fbb1" translate="yes" xml:space="preserve">
          <source>children(supervisor)</source>
          <target state="translated">children(supervisor)</target>
        </trans-unit>
        <trans-unit id="618d777fee871efd6c85172d3bd853a4eb9246b8" translate="yes" xml:space="preserve">
          <source>chmod!(path, mode)</source>
          <target state="translated">chmod!(path,mode)</target>
        </trans-unit>
        <trans-unit id="0b87e43bb3ae70a6f0ac67e1f1b03ccf8d22d654" translate="yes" xml:space="preserve">
          <source>chmod(path, mode)</source>
          <target state="translated">chmod(path,mode)</target>
        </trans-unit>
        <trans-unit id="93b82202fdad2579bf8b763746c4afb5d2f7c817" translate="yes" xml:space="preserve">
          <source>chown!(path, uid)</source>
          <target state="translated">chown!(path,uid)</target>
        </trans-unit>
        <trans-unit id="aecfcafbd79f97782f0bc6ed3cfedc1cb44be5bd" translate="yes" xml:space="preserve">
          <source>chown(path, uid)</source>
          <target state="translated">chown(path,uid)</target>
        </trans-unit>
        <trans-unit id="8dcaa4a671e79e51b844c75ccf15abbe4e29e94d" translate="yes" xml:space="preserve">
          <source>chunk(string, trait)</source>
          <target state="translated">chunk(string,trait)</target>
        </trans-unit>
        <trans-unit id="c75281f825d0f2ad87fd2bd8a0550d5a79496ede" translate="yes" xml:space="preserve">
          <source>chunk_by(enum, fun)</source>
          <target state="translated">chunk_by(enum,fun)</target>
        </trans-unit>
        <trans-unit id="a10af27302650d5de9679a66a8cf28513348ad24" translate="yes" xml:space="preserve">
          <source>chunk_by(enumerable, fun)</source>
          <target state="translated">chunk_by(enumerable,fun)</target>
        </trans-unit>
        <trans-unit id="e8403167d4ad1dc5cbf0ba7e43ac17de9ee06cbb" translate="yes" xml:space="preserve">
          <source>chunk_every(enum, count)</source>
          <target state="translated">chunk_every(enum,count)</target>
        </trans-unit>
        <trans-unit id="414ead39f3c429a189cc01a03f7ace025eac0d10" translate="yes" xml:space="preserve">
          <source>chunk_every(enum, count, step, leftover \\ [])</source>
          <target state="translated">chunk_every(enum,count,step,leftover \ [])</target>
        </trans-unit>
        <trans-unit id="fd799c31ade1d68beed115abe3f5f1667e296457" translate="yes" xml:space="preserve">
          <source>chunk_every(enumerable, count)</source>
          <target state="translated">chunk_every(enumerable,count)</target>
        </trans-unit>
        <trans-unit id="b1b840253492289bc2a6eb56657c69ba214dfe4f" translate="yes" xml:space="preserve">
          <source>chunk_every(enumerable, count, step, leftover \\ [])</source>
          <target state="translated">chunk_every(enumerable,count,step,leftover \ [])</target>
        </trans-unit>
        <trans-unit id="86426607285a7499f7096cf3e4d35883633530a1" translate="yes" xml:space="preserve">
          <source>chunk_while(enum, acc, chunk_fun, after_fun)</source>
          <target state="translated">chunk_while(enum,acc,chunk_fun,after_fun)</target>
        </trans-unit>
        <trans-unit id="d20464a8c329af5b0041927667adbede6c25ea0c" translate="yes" xml:space="preserve">
          <source>chunk_while(enumerable, acc, chunk_fun, after_fun)</source>
          <target state="translated">chunk_while(enumerable,acc,chunk_fun,after_fun)</target>
        </trans-unit>
        <trans-unit id="af6ab064a94fb3e9fd590a99e474c2ed6fe59e97" translate="yes" xml:space="preserve">
          <source>clear()</source>
          <target state="translated">clear()</target>
        </trans-unit>
        <trans-unit id="cc4fa8909241cf935c15b6d6decd530c334c13d9" translate="yes" xml:space="preserve">
          <source>clear_deps_cache()</source>
          <target state="translated">clear_deps_cache()</target>
        </trans-unit>
        <trans-unit id="8e148bf4bd8c70a275395283a1fee3149c01a6db" translate="yes" xml:space="preserve">
          <source>clear_line()</source>
          <target state="translated">clear_line()</target>
        </trans-unit>
        <trans-unit id="a8542ae60b86c5b7fab2c0f0ec801edbdd358ec2" translate="yes" xml:space="preserve">
          <source>close(io_device)</source>
          <target state="translated">close(io_device)</target>
        </trans-unit>
        <trans-unit id="ad48d4f1daa0af6218d10f1d9bdaa68220659962" translate="yes" xml:space="preserve">
          <source>close(pid)</source>
          <target state="translated">close(pid)</target>
        </trans-unit>
        <trans-unit id="126f6a2d5d855131423de17cf0f340552968d16a" translate="yes" xml:space="preserve">
          <source>close(port)</source>
          <target state="translated">close(port)</target>
        </trans-unit>
        <trans-unit id="3474d1f0104de4abf39d17d28090501f2d14af64" translate="yes" xml:space="preserve">
          <source>cmd(command, args, opts \\ [])</source>
          <target state="translated">cmd(command,args,opts \ [])</target>
        </trans-unit>
        <trans-unit id="92e9397dcbef1fbc7087be42a03c5f070dc0ca08" translate="yes" xml:space="preserve">
          <source>cmd(command, opts \\ [])</source>
          <target state="translated">cmd(command,opts \ [])</target>
        </trans-unit>
        <trans-unit id="bce83c2643f3ffd948278c2f84d97c4499adbb97" translate="yes" xml:space="preserve">
          <source>cntrl - Control characters</source>
          <target state="translated">cntrl-控制字符</target>
        </trans-unit>
        <trans-unit id="008fcce5b9d0c4e7e823a52a6d540791a57eff66" translate="yes" xml:space="preserve">
          <source>code_change(old_vsn, state, extra)</source>
          <target state="translated">code_change(old_vsn,state,extra)</target>
        </trans-unit>
        <trans-unit id="efaff14494d5a7a6c75b8dc39649bcdb57a77e86" translate="yes" xml:space="preserve">
          <source>codepoint()</source>
          <target state="translated">codepoint()</target>
        </trans-unit>
        <trans-unit id="481504ade11e7bd75fac7f8c47cbaaed73a5aad1" translate="yes" xml:space="preserve">
          <source>codepoints(string)</source>
          <target state="translated">codepoints(string)</target>
        </trans-unit>
        <trans-unit id="e9fa4b7b4e3b16a346738a2f334d4f9662ec649d" translate="yes" xml:space="preserve">
          <source>collapse_lines(max)</source>
          <target state="translated">collapse_lines(max)</target>
        </trans-unit>
        <trans-unit id="ae1436cbaf361c172c76774c42997c1fe2df52b2" translate="yes" xml:space="preserve">
          <source>color(code)</source>
          <target state="translated">color(code)</target>
        </trans-unit>
        <trans-unit id="366078943e5fdc294278993179908cbdd1c7fb95" translate="yes" xml:space="preserve">
          <source>color(color, string)</source>
          <target state="translated">color(color,string)</target>
        </trans-unit>
        <trans-unit id="5b6b60bb9a814685bbbe82e6dd18d80c05b20273" translate="yes" xml:space="preserve">
          <source>color(doc, color_key, opts)</source>
          <target state="translated">color(doc,color_key,opts)</target>
        </trans-unit>
        <trans-unit id="a212a67103c32a864ce08c31456661e9c27539ab" translate="yes" xml:space="preserve">
          <source>color(r, g, b)</source>
          <target state="translated">color(r,g,b)</target>
        </trans-unit>
        <trans-unit id="ae8ce96620cbd80df8b6ba0cc7aebbb6fa9a40c0" translate="yes" xml:space="preserve">
          <source>color_background(code)</source>
          <target state="translated">color_background(code)</target>
        </trans-unit>
        <trans-unit id="d8cd01c394dc4a55dbdab64b2c004c6d9aeb59aa" translate="yes" xml:space="preserve">
          <source>color_background(r, g, b)</source>
          <target state="translated">color_background(r,g,b)</target>
        </trans-unit>
        <trans-unit id="06a0785bb2a6e3c0fb8be863151d12083ffd68e8" translate="yes" xml:space="preserve">
          <source>color_key()</source>
          <target state="translated">color_key()</target>
        </trans-unit>
        <trans-unit id="1106196ccdcd143f74bf0f42300cb9217d35cb4f" translate="yes" xml:space="preserve">
          <source>command()</source>
          <target state="translated">command()</target>
        </trans-unit>
        <trans-unit id="d2dba9b3d360e74e85badfe473bb5cbc6b47f7a8" translate="yes" xml:space="preserve">
          <source>command(port, data, options \\ [])</source>
          <target state="translated">command(port,data,options \ [])</target>
        </trans-unit>
        <trans-unit id="b7578fa140e5a48efc018542164ff7a387af429d" translate="yes" xml:space="preserve">
          <source>compare(date1, date2)</source>
          <target state="translated">比较(date1,date2)</target>
        </trans-unit>
        <trans-unit id="08c1682119656a1942fc3e1fabda12d21124e673" translate="yes" xml:space="preserve">
          <source>compare(datetime1, datetime2)</source>
          <target state="translated">比较(datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="2fb22b161c676bf6dc077aecadc4f0fcf693f7a8" translate="yes" xml:space="preserve">
          <source>compare(naive_datetime1, naive_datetime2)</source>
          <target state="translated">比较(naive_datetime1,naive_datetime2)</target>
        </trans-unit>
        <trans-unit id="8574cd59bc77840088b087620a0182089fd0206f" translate="yes" xml:space="preserve">
          <source>compare(time1, time2)</source>
          <target state="translated">比较(time1,time2)</target>
        </trans-unit>
        <trans-unit id="27497fe39089deb37ba63d0d9e02f22b644072bd" translate="yes" xml:space="preserve">
          <source>compare(version1, version2)</source>
          <target state="translated">出现(版本1,版本2)</target>
        </trans-unit>
        <trans-unit id="c2d46c76bd019622c7c6534b32df3b41792b1b96" translate="yes" xml:space="preserve">
          <source>compare_levels(left, right)</source>
          <target state="translated">比较级别(左,右)</target>
        </trans-unit>
        <trans-unit id="20426d6d1e27cd203aac7c5bc70cd30067784241" translate="yes" xml:space="preserve">
          <source>comparison operators (&lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#!=/2&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E=/2&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">比较运算符（&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#!=/2&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253E=/2&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="993f2b9d93576f6156c5314f57a27c460d6872c2" translate="yes" xml:space="preserve">
          <source>compatible_calendars?(calendar, calendar)</source>
          <target state="translated">compatible_calendars?(calendar,calendar)</target>
        </trans-unit>
        <trans-unit id="a21285aad6815be212fb835e436777093446d5f8" translate="yes" xml:space="preserve">
          <source>compile (2)</source>
          <target state="translated">编译 (2)</target>
        </trans-unit>
        <trans-unit id="bef628e04dd15e46ff8e79eaf27a98ee0eee5188" translate="yes" xml:space="preserve">
          <source>compile!(source, options \\ &quot;&quot;)</source>
          <target state="translated">compile!(source,options \ &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="4ec3c3cea79df7d0e03e54c5af660591362c2413" translate="yes" xml:space="preserve">
          <source>compile(args, config \\ [])</source>
          <target state="translated">编译(args,config \ [])</target>
        </trans-unit>
        <trans-unit id="61a71d51297295ea461ffe0b290cf6e12116c8c4" translate="yes" xml:space="preserve">
          <source>compile(files, options \\ [])</source>
          <target state="translated">编译(files,options \ [])</target>
        </trans-unit>
        <trans-unit id="364e2c894a558395743d27e00bd39cef2a1788b7" translate="yes" xml:space="preserve">
          <source>compile(pattern)</source>
          <target state="translated">compile(pattern)</target>
        </trans-unit>
        <trans-unit id="41a5b56e900391eaacfc800fc7bdda5db10d2f02" translate="yes" xml:space="preserve">
          <source>compile(source, options \\ &quot;&quot;)</source>
          <target state="translated">compile(source,options \ &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="8752d3c6d962fc52de0488799eb1d1f367e82bbb" translate="yes" xml:space="preserve">
          <source>compile_file(file, relative_to \\ nil)</source>
          <target state="translated">compile_file(file,relative_to \ nil)</target>
        </trans-unit>
        <trans-unit id="286b7f4b3b4d21e89ffd463d46f624d0f7fa3ffe" translate="yes" xml:space="preserve">
          <source>compile_file(filename, options \\ [])</source>
          <target state="translated">compile_file(filename,options \ [])</target>
        </trans-unit>
        <trans-unit id="f1ca4f378c23609b823bba9fbaeb5ae372112643" translate="yes" xml:space="preserve">
          <source>compile_path(config \\ config())</source>
          <target state="translated">compile_path(config \ config())</target>
        </trans-unit>
        <trans-unit id="6877fe6f402dd1870145026c15af85ae0959a568" translate="yes" xml:space="preserve">
          <source>compile_quoted(quoted, file \\ &quot;nofile&quot;)</source>
          <target state="translated">compile_quoted(quoted,file \ &quot;nofile&quot;)</target>
        </trans-unit>
        <trans-unit id="497d66512419f120dbd2b3672f9460d96b122232" translate="yes" xml:space="preserve">
          <source>compile_requirement(requirement)</source>
          <target state="translated">compile_requirement(requirement)</target>
        </trans-unit>
        <trans-unit id="c84ffc2b13f2af6829569aa80b18dee5d7a7510c" translate="yes" xml:space="preserve">
          <source>compile_string(source, options \\ [])</source>
          <target state="translated">compile_string(source,options \ [])</target>
        </trans-unit>
        <trans-unit id="45d187142888814fa068577ec3360d51bf6aeaac" translate="yes" xml:space="preserve">
          <source>compile_string(string, file \\ &quot;nofile&quot;)</source>
          <target state="translated">compile_string(string,file `nofile')</target>
        </trans-unit>
        <trans-unit id="fb2ff017711a4ae6f2fdf2db967bd96a679030a2" translate="yes" xml:space="preserve">
          <source>compile_to_path (3)</source>
          <target state="translated">编译到路径 (3)</target>
        </trans-unit>
        <trans-unit id="27b2eea245bc63f4b74c2d8b4be895b4289df549" translate="yes" xml:space="preserve">
          <source>compile_to_path(files, path, options \\ [])</source>
          <target state="translated">compile_to_path(files,path,options \ [])</target>
        </trans-unit>
        <trans-unit id="63277de6d69c5f9aad541b9ec3f789e8034e4bc4" translate="yes" xml:space="preserve">
          <source>compiled_endianness()</source>
          <target state="translated">compiled_endianness()</target>
        </trans-unit>
        <trans-unit id="2767c3af26cea7820de250a7de5ade3c3d1e2c81" translate="yes" xml:space="preserve">
          <source>compiler_options()</source>
          <target state="translated">compiler_options()</target>
        </trans-unit>
        <trans-unit id="252398d7a593b4d08a655ba826bccd955d572a55" translate="yes" xml:space="preserve">
          <source>compiler_options(opts)</source>
          <target state="translated">compiler_options(opts)</target>
        </trans-unit>
        <trans-unit id="1960356e2b2513d59967ebc737c60956d941201a" translate="yes" xml:space="preserve">
          <source>compilers()</source>
          <target state="translated">compilers()</target>
        </trans-unit>
        <trans-unit id="710d47d23ac1620245831f9c23544ee718443325" translate="yes" xml:space="preserve">
          <source>concat(doc1, doc2)</source>
          <target state="translated">协和(doc1,doc2)</target>
        </trans-unit>
        <trans-unit id="cb8dfe2df97c88031bad219115e5e55ba69e843f" translate="yes" xml:space="preserve">
          <source>concat(docs)</source>
          <target state="translated">concat(docs)</target>
        </trans-unit>
        <trans-unit id="31ef39524c4f24c9607790c33c07230530b841e5" translate="yes" xml:space="preserve">
          <source>concat(enumerables)</source>
          <target state="translated">concat(enumerables)</target>
        </trans-unit>
        <trans-unit id="3276c0c91b62f624a1a2a9614165cae56ca5cca9" translate="yes" xml:space="preserve">
          <source>concat(first, second)</source>
          <target state="translated">协和(第一、第二)</target>
        </trans-unit>
        <trans-unit id="dc6b4510c18288b6bd81ff643ebe9cbae8b7e431" translate="yes" xml:space="preserve">
          <source>concat(left, right)</source>
          <target state="translated">协和(左、右)</target>
        </trans-unit>
        <trans-unit id="8738f1a46de327c249c39d2354c3739f4766c63c" translate="yes" xml:space="preserve">
          <source>concat(list)</source>
          <target state="translated">concat(list)</target>
        </trans-unit>
        <trans-unit id="e28b38305a6df66c6e877af629349f1bffb459c1" translate="yes" xml:space="preserve">
          <source>conceal()</source>
          <target state="translated">conceal()</target>
        </trans-unit>
        <trans-unit id="21193427161cce7037d66c2f58602ad0dffd4246" translate="yes" xml:space="preserve">
          <source>cond (1)</source>
          <target state="translated">条件 (1)</target>
        </trans-unit>
        <trans-unit id="fda3d0abc0a657dad53979cf02e5d4c4602451da" translate="yes" xml:space="preserve">
          <source>cond(clauses)</source>
          <target state="translated">cond(clauses)</target>
        </trans-unit>
        <trans-unit id="c705b5c07e94e5b4ef420654932ee77cfc0d3039" translate="yes" xml:space="preserve">
          <source>config()</source>
          <target state="translated">config()</target>
        </trans-unit>
        <trans-unit id="268ada50ba28f4a1eb21673e04b67f33e9b7cc71" translate="yes" xml:space="preserve">
          <source>config(root_key, key, opts)</source>
          <target state="translated">配置(root_key,key,opts)</target>
        </trans-unit>
        <trans-unit id="71e62d46143958bb12d0e8aca6d3fdef1c23c638" translate="yes" xml:space="preserve">
          <source>config(root_key, opts)</source>
          <target state="translated">配置(root_key,opts)</target>
        </trans-unit>
        <trans-unit id="51db1b3ddad0a74ab91ca531fdeb54363cd27fe7" translate="yes" xml:space="preserve">
          <source>config/releases.exs</source>
          <target state="translated">config/releases.exs</target>
        </trans-unit>
        <trans-unit id="d26d5d64eb4ec8b0b59fe22b26c6debaa459f470" translate="yes" xml:space="preserve">
          <source>config_change(changed, new, removed)</source>
          <target state="translated">config_change(changed,new,removed)</target>
        </trans-unit>
        <trans-unit id="a2b49faf8bb6345054b26d8e0f6eda8ee34494ef" translate="yes" xml:space="preserve">
          <source>config_files()</source>
          <target state="translated">config_files()</target>
        </trans-unit>
        <trans-unit id="334194de3b6d2b09dd93cabd0a1ae6cf2b71dda9" translate="yes" xml:space="preserve">
          <source>config_mtime()</source>
          <target state="translated">config_mtime()</target>
        </trans-unit>
        <trans-unit id="df9a431584b9da726432a34c6513238a108a380c" translate="yes" xml:space="preserve">
          <source>config_path()</source>
          <target state="translated">config_path()</target>
        </trans-unit>
        <trans-unit id="f5d9470a017fdd49731d6a7be7af7facf824b125" translate="yes" xml:space="preserve">
          <source>configuration()</source>
          <target state="translated">configuration()</target>
        </trans-unit>
        <trans-unit id="efb487abbb5b37257c0df42bbc10e1e1a46011a2" translate="yes" xml:space="preserve">
          <source>configure(options)</source>
          <target state="translated">configure(options)</target>
        </trans-unit>
        <trans-unit id="93ff4e6cd0f004a518c2bf47b1b532396848878d" translate="yes" xml:space="preserve">
          <source>configure_backend(backend, options)</source>
          <target state="translated">configure_backend(backend,options)</target>
        </trans-unit>
        <trans-unit id="213d01061c45d9975b4c0fc9b01bc8c57c303834" translate="yes" xml:space="preserve">
          <source>connect(node)</source>
          <target state="translated">connect(node)</target>
        </trans-unit>
        <trans-unit id="c37276e9cce99c780366ccdf92242c4c6b96a9b5" translate="yes" xml:space="preserve">
          <source>connect(port, pid)</source>
          <target state="translated">连接(端口,pid)</target>
        </trans-unit>
        <trans-unit id="bcc685f8d95aa026046ad75079206d7d7146d391" translate="yes" xml:space="preserve">
          <source>consolidate(protocol, types)</source>
          <target state="translated">整合(协议,类型)</target>
        </trans-unit>
        <trans-unit id="ff9a3367bc5548931d607504f4135eea8b08e40e" translate="yes" xml:space="preserve">
          <source>consolidated?(protocol)</source>
          <target state="translated">consolidated?(protocol)</target>
        </trans-unit>
        <trans-unit id="3bcd211572f544f4bdf9b9136a1431b29996b7cc" translate="yes" xml:space="preserve">
          <source>consolidation_path(config \\ config())</source>
          <target state="translated">consolidation_path(config \ config())</target>
        </trans-unit>
        <trans-unit id="71bb4d3af21fa15513fe9e968ea68f9d771b40f7" translate="yes" xml:space="preserve">
          <source>container()</source>
          <target state="translated">container()</target>
        </trans-unit>
        <trans-unit id="596b992138ecebae696f6a437a81ed9d874af3ab" translate="yes" xml:space="preserve">
          <source>container_doc(left, collection, right, inspect_opts, fun, opts \\ [])</source>
          <target state="translated">container_doc(left,collection,right,inspect_opts,fun,opts \ [])</target>
        </trans-unit>
        <trans-unit id="00cc0ff8bc111a27033ad6d1937617686b746752" translate="yes" xml:space="preserve">
          <source>contains?(string, contents)</source>
          <target state="translated">包含?(字符串,内容)</target>
        </trans-unit>
        <trans-unit id="5648e41eade8e40602f4d057a18735bec5d5922d" translate="yes" xml:space="preserve">
          <source>contents(pid)</source>
          <target state="translated">contents(pid)</target>
        </trans-unit>
        <trans-unit id="433ddc2803d9550f1ebf4fc761e87912ccc4d23e" translate="yes" xml:space="preserve">
          <source>context()</source>
          <target state="translated">context()</target>
        </trans-unit>
        <trans-unit id="09fd5b57523755ba7fc5bb7ca2df3bd46996b34b" translate="yes" xml:space="preserve">
          <source>context_modules()</source>
          <target state="translated">context_modules()</target>
        </trans-unit>
        <trans-unit id="07bd0a836eee357f1aab122bbc4383a5366426fa" translate="yes" xml:space="preserve">
          <source>continuation()</source>
          <target state="translated">continuation()</target>
        </trans-unit>
        <trans-unit id="126a595f6a2cd3243001f2d487ff13caf328f459" translate="yes" xml:space="preserve">
          <source>continue()</source>
          <target state="translated">continue()</target>
        </trans-unit>
        <trans-unit id="dd69470ae4dfb70e8ea1c6c85819fb36678a004a" translate="yes" xml:space="preserve">
          <source>convert!(date, calendar)</source>
          <target state="translated">皈依</target>
        </trans-unit>
        <trans-unit id="1c33b2df18e9ce88483eef3574c53b7b2793a893" translate="yes" xml:space="preserve">
          <source>convert!(datetime, calendar)</source>
          <target state="translated">转换!(datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="1cf36367d8cfa4da26517918fca5c13a54055ea3" translate="yes" xml:space="preserve">
          <source>convert!(naive_datetime, calendar)</source>
          <target state="translated">转换!(naive_datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="f361ec115139de246f84ce003f0b3350df7bf9bf" translate="yes" xml:space="preserve">
          <source>convert!(time, calendar)</source>
          <target state="translated">皈依</target>
        </trans-unit>
        <trans-unit id="00249548daa360a253d43213898f3595b1380627" translate="yes" xml:space="preserve">
          <source>convert(date, calendar)</source>
          <target state="translated">转换(日期,日历)</target>
        </trans-unit>
        <trans-unit id="24a4224be3a1b2702d7906a4bdec40fde8da2338" translate="yes" xml:space="preserve">
          <source>convert(datetime, calendar)</source>
          <target state="translated">转换(datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="c90f751301ad073cdedbd95e930098bb8a37e34d" translate="yes" xml:space="preserve">
          <source>convert(naive_datetime, calendar)</source>
          <target state="translated">转换(naive_datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="b12620c26a1e588ccce13237c04766eaf29d6a92" translate="yes" xml:space="preserve">
          <source>convert(time, calendar)</source>
          <target state="translated">转换(时间、日历)</target>
        </trans-unit>
        <trans-unit id="1a139b7fce5447f07932df782f28ef0dadff66e0" translate="yes" xml:space="preserve">
          <source>convert_time_unit(time, from_unit, to_unit)</source>
          <target state="translated">convert_time_unit(time,from_unit,to_unit)</target>
        </trans-unit>
        <trans-unit id="3fdc485611de36b2b58552046a35421cedd2f635" translate="yes" xml:space="preserve">
          <source>copy!(source, destination, bytes_count \\ :infinity)</source>
          <target state="translated">copy!(source,destination,bytes_count :infinity)</target>
        </trans-unit>
        <trans-unit id="9d2b2ae9f27b1c6627226c7d6efd0249aeb20860" translate="yes" xml:space="preserve">
          <source>copy(source, destination, bytes_count \\ :infinity)</source>
          <target state="translated">copy(source,destination,bytes_count :infinity)</target>
        </trans-unit>
        <trans-unit id="510f4da65709e40b6e2377ff99043570e2cb21ac" translate="yes" xml:space="preserve">
          <source>count(enumerable)</source>
          <target state="translated">count(enumerable)</target>
        </trans-unit>
        <trans-unit id="41403e7108da2b83f6233e2925d1ecbc9d1d24bd" translate="yes" xml:space="preserve">
          <source>count(enumerable, fun)</source>
          <target state="translated">count(enumerable,fun)</target>
        </trans-unit>
        <trans-unit id="77675952b2d35edf5199701da8c50f1de5849bfc" translate="yes" xml:space="preserve">
          <source>count(registry)</source>
          <target state="translated">count(registry)</target>
        </trans-unit>
        <trans-unit id="3f70f3f02e3ec05efaa371be1d1ee5fb89d411d2" translate="yes" xml:space="preserve">
          <source>count_children(supervisor)</source>
          <target state="translated">count_children(supervisor)</target>
        </trans-unit>
        <trans-unit id="106fd67d7e3392da728be9f3f591e924444a38b0" translate="yes" xml:space="preserve">
          <source>count_match(registry, key, pattern, guards \\ [])</source>
          <target state="translated">count_match(registry,key,pattern,guards \ [])</target>
        </trans-unit>
        <trans-unit id="d14ed526880066adf9b34846d90fce34b50463ac" translate="yes" xml:space="preserve">
          <source>cp!(source_file, destination_file, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp！（source_file，destination_file，callback \\ fn _，_-&amp;gt; true end）</target>
        </trans-unit>
        <trans-unit id="8f1c0f03a48a96edab09cab7eb911681304a1b3a" translate="yes" xml:space="preserve">
          <source>cp(source_file, destination_file, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp（source_file，destination_file，callback \\ fn _，_-&amp;gt; true end）</target>
        </trans-unit>
        <trans-unit id="55b89c9f961030862db10ad8f6370e0b1e0827a4" translate="yes" xml:space="preserve">
          <source>cp_r!(source, destination, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp_r！（源，目标，回调\\ fn _，_-&amp;gt; true结束）</target>
        </trans-unit>
        <trans-unit id="089921e8c3e0d9e1d5f4d924e0fc755653c5c45f" translate="yes" xml:space="preserve">
          <source>cp_r(source, destination, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp_r（源，目标，回调\\ fn _，_-&amp;gt; true结束）</target>
        </trans-unit>
        <trans-unit id="23c9856582871a341c880734d6bc4316b9bb11ee" translate="yes" xml:space="preserve">
          <source>create(module, quoted, opts)</source>
          <target state="translated">create(module,quoted,opts)</target>
        </trans-unit>
        <trans-unit id="4933c87b83e35f8b169757195c9e0da68eeccecd" translate="yes" xml:space="preserve">
          <source>crossed_out()</source>
          <target state="translated">crossed_out()</target>
        </trans-unit>
        <trans-unit id="b120e7151cbb5c37886a4601d5af6ca3571b2105" translate="yes" xml:space="preserve">
          <source>cursor(line, column)</source>
          <target state="translated">游标(行、列)</target>
        </trans-unit>
        <trans-unit id="973f6b9a7b781c09f1b240bb5ec68f6e9fe8097b" translate="yes" xml:space="preserve">
          <source>cursor_down(lines \\ 1)</source>
          <target state="translated">cursor_down(lines \ 1)</target>
        </trans-unit>
        <trans-unit id="5496e3bf5bb4f4a7fb6071821ac9f62e9de14717" translate="yes" xml:space="preserve">
          <source>cursor_left(columns \\ 1)</source>
          <target state="translated">cursor_left(columns \ 1)</target>
        </trans-unit>
        <trans-unit id="81d9c99d50d61b77cee0688531d5ef10e2f9c0cb" translate="yes" xml:space="preserve">
          <source>cursor_right(columns \\ 1)</source>
          <target state="translated">cursor_right(columns \ 1)</target>
        </trans-unit>
        <trans-unit id="1c636366056e3f831eac233d5c56acac20ee3ea7" translate="yes" xml:space="preserve">
          <source>cursor_up(lines \\ 1)</source>
          <target state="translated">cursor_up(lines \ 1)</target>
        </trans-unit>
        <trans-unit id="dbed36184f87c8a60d6aa495d972b885ec4ecdfb" translate="yes" xml:space="preserve">
          <source>custom guards can also be defined with &lt;a href=&quot;kernel#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt;. A custom guard is always defined based on existing guards.</source>
          <target state="translated">还可以使用&lt;a href=&quot;kernel#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; &lt;/a&gt;定义自定义防护。始终根据现有防护定义自定义防护。</target>
        </trans-unit>
        <trans-unit id="59bd063262df86f1347fd1defe3b3a54024b3731" translate="yes" xml:space="preserve">
          <source>cwd!()</source>
          <target state="translated">cwd!()</target>
        </trans-unit>
        <trans-unit id="713621dce13a750b5cd39abe3f02112fa07b49f2" translate="yes" xml:space="preserve">
          <source>cwd()</source>
          <target state="translated">cwd()</target>
        </trans-unit>
        <trans-unit id="24208fa51359a68fed648c19fdab612baab71c2d" translate="yes" xml:space="preserve">
          <source>cyan()</source>
          <target state="translated">cyan()</target>
        </trans-unit>
        <trans-unit id="ec0527bf7bda19ab4423f6573f06d6ac2d7ffaf0" translate="yes" xml:space="preserve">
          <source>cyan_background()</source>
          <target state="translated">cyan_background()</target>
        </trans-unit>
        <trans-unit id="f1e6cf5bb8f26538d2c0c032bae10490bb0491dc" translate="yes" xml:space="preserve">
          <source>cycle(enumerable)</source>
          <target state="translated">cycle(enumerable)</target>
        </trans-unit>
        <trans-unit id="6d4d58d23a4acf486318e8b2edcd07953f7e3a1f" translate="yes" xml:space="preserve">
          <source>date()</source>
          <target state="translated">date()</target>
        </trans-unit>
        <trans-unit id="b9a0799ddc8b47547ab3f910fa26158a223639f9" translate="yes" xml:space="preserve">
          <source>date_to_string(year, month, day)</source>
          <target state="translated">date_to_string(年、月、日)</target>
        </trans-unit>
        <trans-unit id="4e9a33028e51de956ab47013ada3fe304bde64e0" translate="yes" xml:space="preserve">
          <source>date_to_string(year, month, day, format \\ :extended)</source>
          <target state="translated">date_to_string(year,month,day,format 延伸)</target>
        </trans-unit>
        <trans-unit id="3c241e49d736120b0a6cf65af63bc2008c9cfc60" translate="yes" xml:space="preserve">
          <source>datetime()</source>
          <target state="translated">datetime()</target>
        </trans-unit>
        <trans-unit id="f3d16862f7eb750bf0ed216a9c142f38403a2b93" translate="yes" xml:space="preserve">
          <source>datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</source>
          <target state="translated">datetime_to_string(年,月,日,时,分,秒,微秒,时区,zone_abbr,utc_offset,std_offset)</target>
        </trans-unit>
        <trans-unit id="7423fa8da88a5665ffbf2291fd6c0158bb72ff5f" translate="yes" xml:space="preserve">
          <source>datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset, format \\ :extended)</source>
          <target state="translated">datetime_to_string(年,月,日,时,分,秒,微秒,时区,zone_abbr,utc_offset,std_offset,format \ :extended)</target>
        </trans-unit>
        <trans-unit id="a28529eb1b1d3931c6698d964f850cb93333ef18" translate="yes" xml:space="preserve">
          <source>day()</source>
          <target state="translated">day()</target>
        </trans-unit>
        <trans-unit id="1b063a525a543dc2c253fd72734ce504880e4b8e" translate="yes" xml:space="preserve">
          <source>day_fraction()</source>
          <target state="translated">day_fraction()</target>
        </trans-unit>
        <trans-unit id="811ff05749a9414736da105cdc2a2aed21ba4e0a" translate="yes" xml:space="preserve">
          <source>day_of_era(date)</source>
          <target state="translated">day_of_era(date)</target>
        </trans-unit>
        <trans-unit id="bd88119f3585f530cf32203c36b31903249def4d" translate="yes" xml:space="preserve">
          <source>day_of_era(year, month, day)</source>
          <target state="translated">day_of_era(年、月、日)</target>
        </trans-unit>
        <trans-unit id="a91a690e09480d2cbecb939b6e661359026246c0" translate="yes" xml:space="preserve">
          <source>day_of_week()</source>
          <target state="translated">day_of_week()</target>
        </trans-unit>
        <trans-unit id="86c54bfef8f9f4c926aadb8902630929c2621b38" translate="yes" xml:space="preserve">
          <source>day_of_week(date)</source>
          <target state="translated">day_of_week(date)</target>
        </trans-unit>
        <trans-unit id="cb44cd78398423d3313516a053928c26b89408f0" translate="yes" xml:space="preserve">
          <source>day_of_week(year, month, day)</source>
          <target state="translated">周日(年、月、日)</target>
        </trans-unit>
        <trans-unit id="9b967aae1039adddad19417d56b422dacfed401f" translate="yes" xml:space="preserve">
          <source>day_of_year(date)</source>
          <target state="translated">day_of_year(date)</target>
        </trans-unit>
        <trans-unit id="24e50197c4d96fdaea7220afd1339183235a42fc" translate="yes" xml:space="preserve">
          <source>day_of_year(year, month, day)</source>
          <target state="translated">年月日(年、月、日)</target>
        </trans-unit>
        <trans-unit id="94705e24635b9a7c117cc00efc04fd28939250fd" translate="yes" xml:space="preserve">
          <source>day_rollover_relative_to_midnight_utc()</source>
          <target state="translated">day_rollover_relative_to_midnight_utc()</target>
        </trans-unit>
        <trans-unit id="96e670fd0175613023670473b000f5327cab39c5" translate="yes" xml:space="preserve">
          <source>days_in_month(date)</source>
          <target state="translated">days_in_month(date)</target>
        </trans-unit>
        <trans-unit id="b4be95b3459f0df397a2f434ee15a39bfdb888b2" translate="yes" xml:space="preserve">
          <source>days_in_month(year, month)</source>
          <target state="translated">天数_月(年,月)</target>
        </trans-unit>
        <trans-unit id="7c7594cc6b050fbac7c5b12fa905411430e20a9a" translate="yes" xml:space="preserve">
          <source>debug()</source>
          <target state="translated">debug()</target>
        </trans-unit>
        <trans-unit id="8545325ba223b0b81c405a6dea4e5ce19fda55b5" translate="yes" xml:space="preserve">
          <source>debug(chardata_or_fun, metadata \\ [])</source>
          <target state="translated">debug(chardata_or_fun,metadata \ [])</target>
        </trans-unit>
        <trans-unit id="2599ac2d0e793c9529c5e22506d0ae89e0350d2c" translate="yes" xml:space="preserve">
          <source>debug(debug)</source>
          <target state="translated">debug(debug)</target>
        </trans-unit>
        <trans-unit id="801a66a519a6d9740189196323d7beff91ec916e" translate="yes" xml:space="preserve">
          <source>debug?()</source>
          <target state="translated">debug?()</target>
        </trans-unit>
        <trans-unit id="1b87beb606f9e95e540d9ec45f41402328596700" translate="yes" xml:space="preserve">
          <source>declaring custom data types.</source>
          <target state="translated">声明自定义数据类型。</target>
        </trans-unit>
        <trans-unit id="e95a80c5a8b7c7884aebb4527e6b57ad9e1192ef" translate="yes" xml:space="preserve">
          <source>declaring typed function signatures (specifications);</source>
          <target state="translated">声明类型化的函数签名(规范)。</target>
        </trans-unit>
        <trans-unit id="4e3bc5ae1487c5d3a43a2718c7681e60ec68bf1b" translate="yes" xml:space="preserve">
          <source>decode(uri)</source>
          <target state="translated">decode(uri)</target>
        </trans-unit>
        <trans-unit id="5d54a76659c7341d180c21c170d7871299e0ab9b" translate="yes" xml:space="preserve">
          <source>decode16!(string, opts \\ [])</source>
          <target state="translated">decode16!(string,opts \ [])</target>
        </trans-unit>
        <trans-unit id="18930ba694f4985ea2d016ce72caa134499903e6" translate="yes" xml:space="preserve">
          <source>decode16(string, opts \\ [])</source>
          <target state="translated">decode16(string,opts \ [\])</target>
        </trans-unit>
        <trans-unit id="1cf420e93962dbd03d576bbf9496fb70f0ad0ad3" translate="yes" xml:space="preserve">
          <source>decode32!(string, opts \\ [])</source>
          <target state="translated">decode32!(string,opts \[])</target>
        </trans-unit>
        <trans-unit id="a67c24b3e139786f6169558c1a726ef22d85df70" translate="yes" xml:space="preserve">
          <source>decode32(string, opts \\ [])</source>
          <target state="translated">decode32(string,opts \ [\])</target>
        </trans-unit>
        <trans-unit id="bdf114ac40f87870a9df06fb82d6f010e7d756ff" translate="yes" xml:space="preserve">
          <source>decode64!(string, opts \\ [])</source>
          <target state="translated">decode64!(string,opts \ []))</target>
        </trans-unit>
        <trans-unit id="fa0dd665684eb04621f3b449f3c3ea5185f6d6cf" translate="yes" xml:space="preserve">
          <source>decode64(string, opts \\ [])</source>
          <target state="translated">decode64(string,opts \ [\])</target>
        </trans-unit>
        <trans-unit id="7342ee5b9818299033f2f11594cefe497ad2e384" translate="yes" xml:space="preserve">
          <source>decode_query(query, map \\ %{})</source>
          <target state="translated">decode_query(query,map \\%{})</target>
        </trans-unit>
        <trans-unit id="4df218b2f5d69ee184949dcb46fdcf1963aa0b8f" translate="yes" xml:space="preserve">
          <source>decode_www_form(string)</source>
          <target state="translated">decode_www_form(string)</target>
        </trans-unit>
        <trans-unit id="975da61ed8e464c70fb80d2ff71c474dae85358c" translate="yes" xml:space="preserve">
          <source>decompose_call(ast)</source>
          <target state="translated">decompose_call(ast)</target>
        </trans-unit>
        <trans-unit id="d3e7c6e13a39084d34116edb75613740981145d2" translate="yes" xml:space="preserve">
          <source>dedup(enum)</source>
          <target state="translated">dedup(enum)</target>
        </trans-unit>
        <trans-unit id="3ba906c1c4a0536c55a9bfd874e2c464bff086b9" translate="yes" xml:space="preserve">
          <source>dedup(enumerable)</source>
          <target state="translated">dedup(enumerable)</target>
        </trans-unit>
        <trans-unit id="2729ffddfb2dd23145c52a2153ca7dc9dd68113b" translate="yes" xml:space="preserve">
          <source>dedup_by(enum, fun)</source>
          <target state="translated">dedup_by(enum,fun)</target>
        </trans-unit>
        <trans-unit id="65327010494dde03c1230f7051db86bf54fa1fdf" translate="yes" xml:space="preserve">
          <source>dedup_by(enumerable, fun)</source>
          <target state="translated">dedup_by(enumerable,fun)</target>
        </trans-unit>
        <trans-unit id="d5fafcdb1dada72a6833ebabfe0de0b3b9e2fc98" translate="yes" xml:space="preserve">
          <source>def (2)</source>
          <target state="translated">防御(2)</target>
        </trans-unit>
        <trans-unit id="c470f8a327ac7f23e46ec38ad5caa68f3d921cd9" translate="yes" xml:space="preserve">
          <source>def(call, expr \\ nil)</source>
          <target state="translated">def(call,expr\ nil)</target>
        </trans-unit>
        <trans-unit id="1662037a44c1baf41df32bb8f1d39444ddb29741" translate="yes" xml:space="preserve">
          <source>default()</source>
          <target state="translated">default()</target>
        </trans-unit>
        <trans-unit id="720c9e8b85e049c1648b9bda224247c731368f83" translate="yes" xml:space="preserve">
          <source>default_background()</source>
          <target state="translated">default_background()</target>
        </trans-unit>
        <trans-unit id="7cd5427d98aac50e493f13001c7b8ee3d0f160d5" translate="yes" xml:space="preserve">
          <source>default_color()</source>
          <target state="translated">default_color()</target>
        </trans-unit>
        <trans-unit id="dcdff636637d312b957e042679e5cf260e13b546" translate="yes" xml:space="preserve">
          <source>default_port(scheme)</source>
          <target state="translated">default_port(scheme)</target>
        </trans-unit>
        <trans-unit id="ed1e42c4a87548da6c414925eb1b4b6458a88207" translate="yes" xml:space="preserve">
          <source>default_port(scheme, port)</source>
          <target state="translated">default_port(scheme,port)</target>
        </trans-unit>
        <trans-unit id="99013426646ca710fc2f1e60da26505b1b1d4f5a" translate="yes" xml:space="preserve">
          <source>defcallback(spec)</source>
          <target state="translated">defcallback(spec)</target>
        </trans-unit>
        <trans-unit id="9195fccd31d59cf2d2188d91df426b229d630927" translate="yes" xml:space="preserve">
          <source>defdelegate (2)</source>
          <target state="translated">递延 (2)</target>
        </trans-unit>
        <trans-unit id="65127b6832434adbde48f7e2e355f702d0451c85" translate="yes" xml:space="preserve">
          <source>defdelegate(funs, opts)</source>
          <target state="translated">defdelegate(funs,opts)</target>
        </trans-unit>
        <trans-unit id="43e6bc3931d9dbc3e56eb958cbda053cc06dad5d" translate="yes" xml:space="preserve">
          <source>defexception (1)</source>
          <target state="translated">异常(1)</target>
        </trans-unit>
        <trans-unit id="c280f116c76bfc2c1247fc2b66f196297c4dd709" translate="yes" xml:space="preserve">
          <source>defexception(fields)</source>
          <target state="translated">defexception(fields)</target>
        </trans-unit>
        <trans-unit id="8a9d7ea8a2d00276f2018a17709df570bdfff696" translate="yes" xml:space="preserve">
          <source>defguard (1)</source>
          <target state="translated">防御 (1)</target>
        </trans-unit>
        <trans-unit id="2cc59543af8f02a996bf040385eb8fbc10473dfc" translate="yes" xml:space="preserve">
          <source>defguard(guard)</source>
          <target state="translated">defguard(guard)</target>
        </trans-unit>
        <trans-unit id="cb32278c413fb8029841fb68c04a077f5a756822" translate="yes" xml:space="preserve">
          <source>defguardp (1)</source>
          <target state="translated">Defguardp (1)</target>
        </trans-unit>
        <trans-unit id="39b3c05bbaf590e9f4647a1da0e6992442018d24" translate="yes" xml:space="preserve">
          <source>defguardp(guard)</source>
          <target state="translated">defguardp(guard)</target>
        </trans-unit>
        <trans-unit id="f00d5ce5a96befac60e5e9451e8402c74bff5b37" translate="yes" xml:space="preserve">
          <source>defimpl (3)</source>
          <target state="translated">Defimpl (3)</target>
        </trans-unit>
        <trans-unit id="1c8ef401d0d367317758f0e9c0148a18bb67feae" translate="yes" xml:space="preserve">
          <source>defimpl(name, opts, do_block \\ [])</source>
          <target state="translated">defimpl(name,opts,do_block \ [])</target>
        </trans-unit>
        <trans-unit id="797cb4c37a2fb43d764844a2637d9162a987942d" translate="yes" xml:space="preserve">
          <source>define a set of functions that have to be implemented by a module;</source>
          <target state="translated">定义一组必须由模块实现的函数。</target>
        </trans-unit>
        <trans-unit id="6f514dc65e86d3cd296af9b806ab62763dded75c" translate="yes" xml:space="preserve">
          <source>defines?(module, tuple)</source>
          <target state="translated">defines?(module,tuple)</target>
        </trans-unit>
        <trans-unit id="8b777cf7c466df30bb568ea632d76c3ef3c71109" translate="yes" xml:space="preserve">
          <source>defines?(module, tuple, def_kind)</source>
          <target state="translated">defines?(module,tuple,def_kind)</target>
        </trans-unit>
        <trans-unit id="00a4e9c12eb7c34016877fc550cb55d175e6570e" translate="yes" xml:space="preserve">
          <source>defines_type?(module, definition)</source>
          <target state="translated">defines_type?(module,definition)</target>
        </trans-unit>
        <trans-unit id="b64d97e19f2fb032e7b9de0c642e2816c21b08a5" translate="yes" xml:space="preserve">
          <source>definitions_in(module)</source>
          <target state="translated">definitions_in(module)</target>
        </trans-unit>
        <trans-unit id="c53dfed821d83e2479a395648baa50e64f049c7d" translate="yes" xml:space="preserve">
          <source>definitions_in(module, def_kind)</source>
          <target state="translated">definitions_in(module,def_kind)</target>
        </trans-unit>
        <trans-unit id="7ca75819a8b175e83480c4deaa98c7d20d74b3fd" translate="yes" xml:space="preserve">
          <source>defmacro (2)</source>
          <target state="translated">Defmacro (2)</target>
        </trans-unit>
        <trans-unit id="28cea31bde449ade498f5e24fa27aa687e05a461" translate="yes" xml:space="preserve">
          <source>defmacro(call, expr \\ nil)</source>
          <target state="translated">defmacro(call,expr \ nil)</target>
        </trans-unit>
        <trans-unit id="ef3e4b85c7f2319a6aca7b8f70909de4a7e8ffcd" translate="yes" xml:space="preserve">
          <source>defmacrocallback(spec)</source>
          <target state="translated">defmacrocallback(spec)</target>
        </trans-unit>
        <trans-unit id="cd5741d6a5247ef08bcf41cf850f302845cdd5c5" translate="yes" xml:space="preserve">
          <source>defmacrop (2)</source>
          <target state="translated">defmacrop (2)</target>
        </trans-unit>
        <trans-unit id="73d315ed7ee341cabc2a10245ac41c2f81b4d5af" translate="yes" xml:space="preserve">
          <source>defmacrop(call, expr \\ nil)</source>
          <target state="translated">defmacrop(call,expr \ nil)</target>
        </trans-unit>
        <trans-unit id="5aa79b9fe33cfb22c299fc38772a33666033ccfc" translate="yes" xml:space="preserve">
          <source>defmodule (2)</source>
          <target state="translated">defmodule (2)</target>
        </trans-unit>
        <trans-unit id="078a2360d25d1f1c564fa7aec98a57719ce4b4ae" translate="yes" xml:space="preserve">
          <source>defmodule(alias, do_block)</source>
          <target state="translated">defmodule(alias,do_block)</target>
        </trans-unit>
        <trans-unit id="37d64f1eb85182f90dc45409602aab21c18e53e3" translate="yes" xml:space="preserve">
          <source>defoverridable (1)</source>
          <target state="translated">可改判 (1)</target>
        </trans-unit>
        <trans-unit id="6595ebe765210bb4d9b6cf386a04b6200e5c3cf5" translate="yes" xml:space="preserve">
          <source>defoverridable(keywords_or_behaviour)</source>
          <target state="translated">defoverridable(keywords_or_behaviour)</target>
        </trans-unit>
        <trans-unit id="ab7a535b1959d1cbd03261784c6e560b51032b8c" translate="yes" xml:space="preserve">
          <source>defp (2)</source>
          <target state="translated">辩护律师(2)</target>
        </trans-unit>
        <trans-unit id="1ed86a159c28f3d861cb5b60925f68db45b9bd0b" translate="yes" xml:space="preserve">
          <source>defp(call, expr \\ nil)</source>
          <target state="translated">defp(call,expr \ nil)</target>
        </trans-unit>
        <trans-unit id="c232e92c5e0a415c7a8cd0036146430d881692ec" translate="yes" xml:space="preserve">
          <source>defprotocol (2)</source>
          <target state="translated">defprotocol (2)</target>
        </trans-unit>
        <trans-unit id="f108716315356e82770dabba5ddfbf7baeda8fdd" translate="yes" xml:space="preserve">
          <source>defprotocol(name, do_block)</source>
          <target state="translated">defprotocol(name,do_block)</target>
        </trans-unit>
        <trans-unit id="e480715bcba50745613c62d5ed9e5d3822da1a86" translate="yes" xml:space="preserve">
          <source>defrecord(name, tag \\ nil, kv)</source>
          <target state="translated">defrecord(name,tag ndil,kv)</target>
        </trans-unit>
        <trans-unit id="1d0a571fcfb4926facbcdecd56ddca44ccc8a873" translate="yes" xml:space="preserve">
          <source>defrecordp(name, tag \\ nil, kv)</source>
          <target state="translated">defrecordp(name,tag ndil,kv)</target>
        </trans-unit>
        <trans-unit id="75056928201654756d5e397f7499d04993c357d1" translate="yes" xml:space="preserve">
          <source>defstruct (1)</source>
          <target state="translated">架构 (1)</target>
        </trans-unit>
        <trans-unit id="65c835833f695974c7c7f0cd8be2f5fe7d004ea6" translate="yes" xml:space="preserve">
          <source>defstruct(fields)</source>
          <target state="translated">defstruct(fields)</target>
        </trans-unit>
        <trans-unit id="de5a5ed1166a286422f0856edaee6463d511cc16" translate="yes" xml:space="preserve">
          <source>delete(dict, key)</source>
          <target state="translated">删除(dict,key)</target>
        </trans-unit>
        <trans-unit id="eb0f81ddf6314628b0ed67a1b562b13780fe346b" translate="yes" xml:space="preserve">
          <source>delete(key)</source>
          <target state="translated">delete(key)</target>
        </trans-unit>
        <trans-unit id="4a5e5382a06ba0a3ee3e733682c97f93f2040db4" translate="yes" xml:space="preserve">
          <source>delete(keywords, key)</source>
          <target state="translated">删除(keywords,key)</target>
        </trans-unit>
        <trans-unit id="ed641f6d49ec6172d70f646ee4c3874006721e12" translate="yes" xml:space="preserve">
          <source>delete(keywords, key, value)</source>
          <target state="translated">删除(keywords,key,value)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
