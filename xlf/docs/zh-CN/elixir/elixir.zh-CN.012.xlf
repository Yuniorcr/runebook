<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="a4164178e5929ed3fb0cfbbf5db866fa640026ff" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the current value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是通过返回的当前值的元组 &lt;code&gt;fun&lt;/code&gt; 和新的关键字列表与下更新值 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcdf4e0951183ef655924f609aa3f331a6262b10" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new container with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是通过返回的&amp;ldquo;获得&amp;rdquo;价值两元的元组 &lt;code&gt;fun&lt;/code&gt; 和新的容器下的更新值 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f9b50979454240749ecdc91833d5801c156188c" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the current value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是一个由两个元素组成的元组，当前值由 &lt;code&gt;fun&lt;/code&gt; 返回，一个新的映射在 &lt;code&gt;key&lt;/code&gt; 下具有更新的值。</target>
        </trans-unit>
        <trans-unit id="4ee34714ba69b3d5a504684c39dd1f4988c4abdf" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the number of seconds and microseconds.</source>
          <target state="translated">返回值是一个包含秒数和微秒的双元素元组。</target>
        </trans-unit>
        <trans-unit id="7e65f7f051c44e5c9c75a8f2f854fabd880fc538" translate="yes" xml:space="preserve">
          <source>The returned value of the environment variable &lt;code&gt;varname&lt;/code&gt; is a string. If the environment variable is not set, returns the string specified in &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; if none is specified.</source>
          <target state="translated">环境变量 &lt;code&gt;varname&lt;/code&gt; 的返回值是一个字符串。如果没有设置环境变量，返回指定的字符串 &lt;code&gt;default&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，如果没有指定。</target>
        </trans-unit>
        <trans-unit id="0f847cce0d292ae271a717b61d78816a1f1ea3fd" translate="yes" xml:space="preserve">
          <source>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</source>
          <target state="translated">右侧的路径将始终被扩展为相对格式,并且在连接时,任何尾部的斜线都将被删除。</target>
        </trans-unit>
        <trans-unit id="643a7d1289fc8c2df27def8f3faf469415ebab11" translate="yes" xml:space="preserve">
          <source>The right side of &lt;code&gt;.&lt;/code&gt; may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</source>
          <target state="translated">的右侧 &lt;code&gt;.&lt;/code&gt; 可以是以大写字母开头（代表别名）的单词，以小写字母或下划线开头的单词，任何有效的语言运算符或任何用单引号或双引号引起来的名称。这些都是有效的示例：</target>
        </trans-unit>
        <trans-unit id="c04e1c8f69c2f1a88e36a20e9901940c66e8dcfe" translate="yes" xml:space="preserve">
          <source>The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">四舍五入的方向总是与半上挂钩。该操作是在二进制浮点数上进行的,没有转换为十进制。</target>
        </trans-unit>
        <trans-unit id="4144dd4219963dfd0900f8f0b48ec21d6f4d014e" translate="yes" xml:space="preserve">
          <source>The router will check the first byte of the bucket name against the table and dispatch to the appropriate node based on that. For example, a bucket starting with the letter &amp;ldquo;a&amp;rdquo; (&lt;code&gt;?a&lt;/code&gt; represents the Unicode codepoint of the letter &amp;ldquo;a&amp;rdquo;) will be dispatched to node &lt;code&gt;foo@computer-name&lt;/code&gt;.</source>
          <target state="translated">路由器将对照表检查存储桶名称的第一个字节，并根据该表将其分发到适当的节点。例如，以字母&amp;ldquo; a&amp;rdquo;（ &lt;code&gt;?a&lt;/code&gt; 代表字母&amp;ldquo; a&amp;rdquo; 的Unicode代码点）开头的存储桶将被分派到节点 &lt;code&gt;foo@computer-name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff8ac86ff623f4bf3fb0733f54cbe348a65e9dc" translate="yes" xml:space="preserve">
          <source>The routing layer will receive a routing table of the following format:</source>
          <target state="translated">路由层将收到一个格式如下的路由表。</target>
        </trans-unit>
        <trans-unit id="4c154bbe6784f06daaef10626cc0bf86a4376497" translate="yes" xml:space="preserve">
          <source>The same applies to duplicate registries:</source>
          <target state="translated">这同样适用于重复的登记册。</target>
        </trans-unit>
        <trans-unit id="8461a29f68bfc60f9acb948d5fe98c088c56fd3e" translate="yes" xml:space="preserve">
          <source>The same applies to maps where each pair is treated as a list of tuples with two elements:</source>
          <target state="translated">同样的道理也适用于地图,在地图中,每个对子都被视为具有两个元素的图元组列表。</target>
        </trans-unit>
        <trans-unit id="b487f77f15de12365c59e270fe90d68cbbe73146" translate="yes" xml:space="preserve">
          <source>The same applies to qualified calls such as &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt;, which is the same as &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt;. However, remember parentheses are not optional for non-qualified calls with no arguments, such as &lt;code&gt;sum()&lt;/code&gt;. Removing the parentheses for &lt;code&gt;sum&lt;/code&gt; causes it to be represented as the variable &lt;code&gt;sum&lt;/code&gt;, which means they would be no longer equivalent.</source>
          <target state="translated">这同样适用于限定调用，例如 &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt; ，与 &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt; 相同。但是，请记住，对于没有参数的非限定调用 &lt;code&gt;sum()&lt;/code&gt; 例如sum（）），括号不是可选的。卸下的括号 &lt;code&gt;sum&lt;/code&gt; 导致它被表示为变量 &lt;code&gt;sum&lt;/code&gt; ，这意味着它们将不再相等。</target>
        </trans-unit>
        <trans-unit id="47e032a5027ea138ef1f6dce21b412d852e000c1" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cd/1&quot;&gt; &lt;code&gt;cd/1&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="4648fcff80dd7d416297fa509f0fce7c20f51db4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cd/1&quot;&gt; &lt;code&gt;cd/1&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="18e01d0d75a4c60af88fee26dd31622d04f96a97" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;bytes_copied&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a58fcd56739bfa5248246728d465bb758d5e5ea2" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;bytes_copied&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cf6de4f99822a7c8fe3b408ab5d4cf7f42930ca" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="696de6f1529a7a564fc637bc60de66470a73fed7" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f92c875af9b9262d24ee988fee5dadfcecefeb5a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp_r/3&quot;&gt; &lt;code&gt;cp_r/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回复制文件的列表。</target>
        </trans-unit>
        <trans-unit id="dced03231a36fd3a83cda83b79431542ee58a767" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp_r/3&quot;&gt; &lt;code&gt;cp_r/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回复制文件的列表。</target>
        </trans-unit>
        <trans-unit id="f459fdf18e68c368ea8cc4aa8ed5c7cc8b9dd88a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;cwd/0&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="0eee2e06aac8b82f8ed48294c71a788555a3adf5" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;cwd/0&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="fa8efe783d469a71d442d2785e538f32a3f185b8" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#eval!/2&quot;&gt;&lt;code&gt;eval!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="translated">与&lt;a href=&quot;#eval!/2&quot;&gt; &lt;code&gt;eval!/2&lt;/code&gt; &lt;/a&gt;相同，但只返回给定文件中的配置，而不返回导入的路径。</target>
        </trans-unit>
        <trans-unit id="e983c20087a73c47c1b91cd7c2c300a823c39d00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="translated">与&lt;a href=&quot;#ls/1&quot;&gt; &lt;code&gt;ls/1&lt;/code&gt; &lt;/a&gt;相同，但是在发生错误的情况下引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="2619800bcffc51ddabf679c548f67d8d665df758" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="translated">与&lt;a href=&quot;#ls/1&quot;&gt; &lt;code&gt;ls/1&lt;/code&gt; &lt;/a&gt;相同，但是在发生错误的情况下引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="e26cc2d303c7d487aeb4684f8a5ec5296d428a79" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出任何无效的选项，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="94d50f21dfa011da9b3d948e9722047f3d7526a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出任何无效的选项，则会引发&lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="e2165b5941176ebd36f68f510b06c8757c380d9a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出任何无效的选项，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="a5050ef6fcebfe967949f495038b1cf5998440f0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出了任何无效的选项，则会引发&lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="44ad2c47fd323d50a1b7a9d773f54ea42bbc2572" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="translated">与&lt;a href=&quot;#read_imports!/2&quot;&gt; &lt;code&gt;read_imports!/2&lt;/code&gt; &lt;/a&gt;相同，但只返回给定文件中的配置，而不返回导入的路径。</target>
        </trans-unit>
        <trans-unit id="76551e442cf0920ecab6d0eb8ea56bcf94c15620" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.renameerror&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#rename/2&quot;&gt; &lt;code&gt;rename/2&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.renameerror&quot;&gt; &lt;code&gt;File.RenameError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be26fa6408a4ea8bda26cf7e98b553592e7fd2e6" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.RenameError.html&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#rename/2&quot;&gt; &lt;code&gt;rename/2&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;https://hexdocs.pm/elixir/File.RenameError.html&quot;&gt; &lt;code&gt;File.RenameError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff7e3f389bbffc2c11af04820517b44446f5b5b0" translate="yes" xml:space="preserve">
          <source>The second approach uses function calls which better suits more complex APIs (for example, if you need to pass many options) and reads nicely in Elixir thanks to the pipe operator.</source>
          <target state="translated">第二种方法使用函数调用,它更适合更复杂的API(例如,如果你需要传递许多选项),并且由于管道操作符的存在,在Elixir中也能很好地读取。</target>
        </trans-unit>
        <trans-unit id="4989f7d201fe4b48e470058521e1ca80ae6c9569" translate="yes" xml:space="preserve">
          <source>The second argument is a keyword list of options:</source>
          <target state="translated">第二个参数是一个关键词的选项列表。</target>
        </trans-unit>
        <trans-unit id="43642aa7f67e7784c0b111753a92ead35aec4a5a" translate="yes" xml:space="preserve">
          <source>The second argument is either a timeout or &lt;code&gt;:brutal_kill&lt;/code&gt;. In case of a timeout, a &lt;code&gt;:shutdown&lt;/code&gt; exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With &lt;code&gt;:brutal_kill&lt;/code&gt; the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</source>
          <target state="translated">第二个参数是超时或 &lt;code&gt;:brutal_kill&lt;/code&gt; 。在超时的情况下， &lt;code&gt;:shutdown&lt;/code&gt; 退出信号被发送到任务进程，如果在超时时间内没有退出，则该信号被杀死。使用 &lt;code&gt;:brutal_kill&lt;/code&gt; 可以立即杀死任务。万一任务异常终止（可能被另一个进程终止），该功能将以相同的原因退出。</target>
        </trans-unit>
        <trans-unit id="fcb757bd7051270d8c819a13491903d89a8704fd" translate="yes" xml:space="preserve">
          <source>The second argument is first expanded to an absolute path.</source>
          <target state="translated">第二个参数首先扩展为绝对路径。</target>
        </trans-unit>
        <trans-unit id="524ef427f3aceff5423ab5acc031269f5e3169df" translate="yes" xml:space="preserve">
          <source>The second argument specifying every &lt;code&gt;nth&lt;/code&gt; element must be a non-negative integer.</source>
          <target state="translated">指定每个 &lt;code&gt;nth&lt;/code&gt; 元素的第二个参数必须是非负整数。</target>
        </trans-unit>
        <trans-unit id="6a6d508d801e049e82fe48d35683e28b76dc2200" translate="yes" xml:space="preserve">
          <source>The second change is in the &lt;code&gt;application&lt;/code&gt; function inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">第二个变化是在 &lt;code&gt;mix.exs&lt;/code&gt; 内部的 &lt;code&gt;application&lt;/code&gt; 函数中：</target>
        </trans-unit>
        <trans-unit id="36314cd4001b7103421433826074baa427430f61" translate="yes" xml:space="preserve">
          <source>The second concern is that, while using &lt;code&gt;mix run&lt;/code&gt; is completely fine to run our software in production, the command we use to start our services is getting increasingly more complex. For example, imagine we also want to &lt;code&gt;--preload-modules&lt;/code&gt;, to all code is loaded upfront, as well as set the &lt;code&gt;MIX_ENV=prod&lt;/code&gt; environment variable:</source>
          <target state="translated">第二个担忧是，尽管使用 &lt;code&gt;mix run&lt;/code&gt; 在生产环境中运行我们的软件完全可以，但是用于启动服务的命令却变得越来越复杂。例如，假设我们还想要 &lt;code&gt;--preload-modules&lt;/code&gt; ，以将所有代码预先加载，并设置 &lt;code&gt;MIX_ENV=prod&lt;/code&gt; 环境变量：</target>
        </trans-unit>
        <trans-unit id="59db642f7ebf3826674361ba0acf5de33120795d" translate="yes" xml:space="preserve">
          <source>The second definition matches the pattern and has no guard so it will be executed. It first prints our &lt;code&gt;msg&lt;/code&gt; and then calls itself passing &lt;code&gt;n - 1&lt;/code&gt; (&lt;code&gt;2&lt;/code&gt;) as the second argument.</source>
          <target state="translated">第二个定义与模式匹配并且没有保护，因此它将被执行。它首先打印我们的 &lt;code&gt;msg&lt;/code&gt; ，然后通过第二个参数 &lt;code&gt;n - 1&lt;/code&gt; （ &lt;code&gt;2&lt;/code&gt; ）调用自身。</target>
        </trans-unit>
        <trans-unit id="dae9460a51adde13fd535bc1aee22f1354a6ed7b" translate="yes" xml:space="preserve">
          <source>The second element is a keyword list containing metadata, like numbers and contexts;</source>
          <target state="translated">第二个元素是包含元数据的关键字列表,如数字和上下文。</target>
        </trans-unit>
        <trans-unit id="21d656a71ac68bd8b82b5427ffa0a32c0e82e5b7" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#t:metadata/0&quot;&gt;metadata&lt;/a&gt;.</source>
          <target state="translated">元组的第二个元素表示&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#t:metadata/0&quot;&gt;元数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09930d4769fdab8c631461548dda5978d0ffac47" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents metadata.</source>
          <target state="translated">元组的第二个元素代表元数据。</target>
        </trans-unit>
        <trans-unit id="49369ce9190f9083bafea50347ba1f7b69ded63d" translate="yes" xml:space="preserve">
          <source>The second flaw is related to the supervision strategy. If &lt;code&gt;KV.Registry&lt;/code&gt; dies, all information linking &lt;code&gt;KV.Bucket&lt;/code&gt; names to bucket processes is lost. Therefore the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; and all children must terminate too - otherwise we will have orphan processes.</source>
          <target state="translated">第二个缺陷与监管策略有关。如果 &lt;code&gt;KV.Registry&lt;/code&gt; 死亡， &lt;code&gt;KV.Bucket&lt;/code&gt; 名称链接到存储桶进程的所有信息都将丢失。因此， &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 和所有子代也必须终止-否则我们将具有孤立进程。</target>
        </trans-unit>
        <trans-unit id="1b27ec208e18d1eae9448f08cbc57e44112bc1f3" translate="yes" xml:space="preserve">
          <source>The second is to make sure your &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did:</source>
          <target state="translated">第二个是确保您的&lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; &lt;/a&gt;调用没有通配符。如果是这样，则需要手动执行通配符查找。例如，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="3f52940a3eb4585da7a86f017cdfc1095c4a0962" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, and so forth.</source>
          <target state="translated">第二部分，保护措施，是允许过滤结果的条件列表。每个防护是一个元组，它描述应该由模式的指定部分通过的检查。例如， &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 保护条件将表示为 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 元组。请注意，警戒条件只会工作，像赋值的变量 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ， &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="03c8c69c3a8917dcc36201eb8826bb675ed3a306" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">第二部分，保护措施，是允许过滤结果的条件列表。每个防护是一个元组，它描述应该由模式的指定部分通过的检查。例如， &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 保护条件将表示为 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 元组。请注意，警戒条件只会工作，像赋值的变量 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ， &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; ，等等。</target>
        </trans-unit>
        <trans-unit id="8279ae6c0770b2c5c483279a964f5a0fd686e18a" translate="yes" xml:space="preserve">
          <source>The second pitfall is that the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator works on calls. For example, when you write:</source>
          <target state="translated">第二个陷阱是 &lt;code&gt;|&amp;gt;&lt;/code&gt; 运算符可用于通话。例如，当您编写时：</target>
        </trans-unit>
        <trans-unit id="494117d2d88c4ce9741e6ac16716fddbb8f4cbe4" translate="yes" xml:space="preserve">
          <source>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</source>
          <target state="translated">第二个原则是尽可能少地提供配置。这样可以通过消除争议点来简化formatter的采用,同时确保整个社区一致遵循单一风格。</target>
        </trans-unit>
        <trans-unit id="661a367f5412305ec9e82e19ba1e4e566dc26d28" translate="yes" xml:space="preserve">
          <source>The second test checks that the code raises for unknown entries.</source>
          <target state="translated">第二个测试检查代码是否会引发未知条目。</target>
        </trans-unit>
        <trans-unit id="8cd7d01257f835cc5a3247359bf87ad73936ce2f" translate="yes" xml:space="preserve">
          <source>The server is now running, and you will even notice the console is blocked. Let&amp;rsquo;s use &lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;a &lt;code&gt;telnet&lt;/code&gt; client&lt;/a&gt; to access our server. There are clients available on most operating systems, and their command lines are generally similar:</source>
          <target state="translated">服务器现在正在运行，您甚至会注意到控制台已被阻止。让我们用&lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;一个 &lt;code&gt;telnet&lt;/code&gt; 客户端&lt;/a&gt;来访问我们的服务器。大多数操作系统上都有可用的客户端，它们的命令行通常类似：</target>
        </trans-unit>
        <trans-unit id="fd585ae8b1d0205e194512ad32642a694a88c604" translate="yes" xml:space="preserve">
          <source>The server reference.</source>
          <target state="translated">服务器参考。</target>
        </trans-unit>
        <trans-unit id="d40bf167b8d71e1dda39cd357ab868e4586251d2" translate="yes" xml:space="preserve">
          <source>The server responsibilities include:</source>
          <target state="translated">服务器的职责包括:</target>
        </trans-unit>
        <trans-unit id="ff65793db264093aa3a7a1cf46e0cbfc1e4b8a04" translate="yes" xml:space="preserve">
          <source>The setup callbacks are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as &lt;code&gt;context&lt;/code&gt;. The context to be used in the tests can be optionally extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="translated">设置回调是通过宏定义的，每个回调都可以选择接收包含测试状态和元数据（通常称为 &lt;code&gt;context&lt;/code&gt; )的映射。通过返回正确的结构化值（请参阅下文），安装程序回调可以扩展在测试中使用的上下文。</target>
        </trans-unit>
        <trans-unit id="beb94809dde5c8a8ccc0fe6fd795a37a627a36a9" translate="yes" xml:space="preserve">
          <source>The setup callbacks may be used to define &lt;a href=&quot;https://en.wikipedia.org/wiki/Test_fixture#Software&quot;&gt;test fixtures&lt;/a&gt; and run any initialization code which help bring the system into a known state. They are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as the &lt;code&gt;context&lt;/code&gt;. Optionally, the context to be used in the tests can be extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="translated">设置回调可用于定义&lt;a href=&quot;https://en.wikipedia.org/wiki/Test_fixture#Software&quot;&gt;测试装置&lt;/a&gt;并运行任何有助于使系统进入已知状态的初始化代码。它们是通过宏定义的，每个宏都可以选择接收包含测试状态和元数据（通常称为 &lt;code&gt;context&lt;/code&gt; 的映射。（可选）通过返回正确的结构化值（请参阅下文），安装回调可以扩展测试中要使用的上下文。</target>
        </trans-unit>
        <trans-unit id="be70f07b576f3a68fa738cef7302c8e28346ebfb" translate="yes" xml:space="preserve">
          <source>The shutdown process happens in reverse order.</source>
          <target state="translated">关机过程以相反的顺序进行。</target>
        </trans-unit>
        <trans-unit id="a344948a2691ee6269fc2879136d40e4dca1f373" translate="yes" xml:space="preserve">
          <source>The size can be a variable:</source>
          <target state="translated">大小可以是一个变量。</target>
        </trans-unit>
        <trans-unit id="8111a6aa75f3c6e4735d59b2e853a7faeadebe29" translate="yes" xml:space="preserve">
          <source>The size of a map is the number of key-value pairs that the map contains.</source>
          <target state="translated">地图的大小是指地图包含的键值对的数量。</target>
        </trans-unit>
        <trans-unit id="0078ede4075127860c2ade218ba7d232c2981cd7" translate="yes" xml:space="preserve">
          <source>The snippet above only works because numbers implement the &lt;code&gt;String.Chars&lt;/code&gt; protocol. Passing a tuple, for example, will lead to an error:</source>
          <target state="translated">上面的代码段仅适用于数字实现 &lt;code&gt;String.Chars&lt;/code&gt; 协议的情况。例如，传递元组将导致错误：</target>
        </trans-unit>
        <trans-unit id="6c615bba281ebbef820e4ccb712d2aa12dcf9a32" translate="yes" xml:space="preserve">
          <source>The solution here is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#take/2&quot;&gt;&lt;code&gt;Stream.take/2&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt;&lt;code&gt;Enum.take/2&lt;/code&gt;&lt;/a&gt; to filter elements before-hand:</source>
          <target state="translated">这里的解决方案是使用&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#take/2&quot;&gt; &lt;code&gt;Stream.take/2&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt; &lt;code&gt;Enum.take/2&lt;/code&gt; &lt;/a&gt;来预先过滤元素：</target>
        </trans-unit>
        <trans-unit id="6272c1202f90648d2a2419029598638bd1dd5c26" translate="yes" xml:space="preserve">
          <source>The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument:</source>
          <target state="translated">解决的办法是尽可能地在使用的地方提供配置,而不是通过应用环境。在函数的情况下,你可以期待关键字列表作为一个新的参数。</target>
        </trans-unit>
        <trans-unit id="2c2456d942f9ee207983a501b269e82c8ae7c4b6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm will be stable as long as the given function returns &lt;code&gt;true&lt;/code&gt; for values considered equal:</source>
          <target state="translated">只要给定函数对于认为相等的值返回 &lt;code&gt;true&lt;/code&gt; ，排序算法将保持稳定：</target>
        </trans-unit>
        <trans-unit id="972944894d27378714ceb941dffde3e2074c4f7f" translate="yes" xml:space="preserve">
          <source>The spec also provides a &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; set but Elixir does not include any character on this set. Therefore the identifier rule has been simplified to consider this.</source>
          <target state="translated">规范还提供了 &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; 集，但Elixir在此集上不包含任何字符。因此，简化了标识符规则以考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="fc80cf8cc0e875b59d4cb7a74f58a13e82e8e79b" translate="yes" xml:space="preserve">
          <source>The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching.</source>
          <target state="translated">堆栈是列表的一个小包装。它允许我们把一个元素放在堆栈的顶部,通过预置到列表中,并通过模式匹配获得堆栈的顶部。</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="c90a34e2afaa39e30146b58a596138ac46c6ee44" translate="yes" xml:space="preserve">
          <source>The steps necessary to work across nodes is already commented out as an example. You can enable full distribution by uncommenting the last two lines by removing the leading &lt;code&gt;# &lt;/code&gt;.</source>
          <target state="translated">作为示例，已经注释了跨节点工作所需的步骤。您可以通过删除开头的 &lt;code&gt;# &lt;/code&gt; 取消对最后两行的注释，从而启用完全分发。</target>
        </trans-unit>
        <trans-unit id="6547b77a17d5ef12542c7afee97cc798fc8b1249" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="translated">该流同时实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议，这意味着它可用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="6ee85dc5e71fc294b36604877aa25393a7df8e42" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="translated">流同时实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议，这意味着它可以用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="d0a2b7409cbfc04d5907be0d98cbcaddcde54753" translate="yes" xml:space="preserve">
          <source>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt;&lt;code&gt;node/0&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">提示中括号之间的字符串是您节点的名称。我们可以通过调用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt; &lt;code&gt;node/0&lt;/code&gt; &lt;/a&gt;函数来检索它：</target>
        </trans-unit>
        <trans-unit id="81e25ea527122c6269507a786b1fac990f5269a4" translate="yes" xml:space="preserve">
          <source>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</source>
          <target state="translated">字符串串联使代码适合于单行,也给formatter提供了更多的选择。</target>
        </trans-unit>
        <trans-unit id="86cdec7e4462e9309a1a4eb1db8bbf7175736e0b" translate="yes" xml:space="preserve">
          <source>The string concatenation operation is actually a binary concatenation operator:</source>
          <target state="translated">字符串连接操作实际上是一个二进制连接操作符。</target>
        </trans-unit>
        <trans-unit id="7f69f0cddd44731ccae3984440903fe5c39c51ec" translate="yes" xml:space="preserve">
          <source>The string concatenation operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is actually a binary concatenation operator:</source>
          <target state="translated">字符串串联运算符 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 实际上是二进制串联运算符：</target>
        </trans-unit>
        <trans-unit id="8259167cccd8df309147297c84a34df6a1de5df3" translate="yes" xml:space="preserve">
          <source>The string is split into as many parts as possible by default, but can be controlled via the &lt;code&gt;:parts&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，该字符串被分成尽可能多的部分，但是可以通过 &lt;code&gt;:parts&lt;/code&gt; 选项控制。</target>
        </trans-unit>
        <trans-unit id="ff34135d2b9fe9bf18a8b4692de3737dabb31735" translate="yes" xml:space="preserve">
          <source>The struct fields are private and should not be accessed.</source>
          <target state="translated">该结构的字段是私有的,不应该被访问。</target>
        </trans-unit>
        <trans-unit id="571837e3b232d92d474e8917fdedc1786ba58276" translate="yes" xml:space="preserve">
          <source>The struct fields can be given when building the struct:</source>
          <target state="translated">在构建结构时可以给定结构字段。</target>
        </trans-unit>
        <trans-unit id="92bf51de3e3e5df1170754020b84a38130fd526e" translate="yes" xml:space="preserve">
          <source>The supervision strategy dictates what happens when one of the children crashes. &lt;code&gt;:one_for_one&lt;/code&gt; means that if a child dies, it will be the only one restarted. Since we have only one child now, that&amp;rsquo;s all we need. The &lt;code&gt;Supervisor&lt;/code&gt; behaviour supports many different strategies and we will discuss them in this chapter.</source>
          <target state="translated">监督策略规定了其中一个孩子撞车时会发生什么。 &lt;code&gt;:one_for_one&lt;/code&gt; 表示如果一个孩子死亡，它将是唯一重启的孩子。由于我们现在只有一个孩子，这就是我们所需要的。该 &lt;code&gt;Supervisor&lt;/code&gt; 的行为支持许多不同的策略，我们将在本章讨论。</target>
        </trans-unit>
        <trans-unit id="d45ea759f46bff3ba089e89707b504285b2e2aff" translate="yes" xml:space="preserve">
          <source>The supervisor flags returned on init</source>
          <target state="translated">启动时返回的主管标志</target>
        </trans-unit>
        <trans-unit id="e3742ff69698c4acf77e80f28496fe07172ab4b1" translate="yes" xml:space="preserve">
          <source>The supervisor reference</source>
          <target state="translated">监理参考</target>
        </trans-unit>
        <trans-unit id="5aec5d17ff71d8a46be456b119441ed148f52e07" translate="yes" xml:space="preserve">
          <source>The supervisor specification</source>
          <target state="translated">监理规范</target>
        </trans-unit>
        <trans-unit id="55243bfac4a971c230124af0cb70d274159f15f1" translate="yes" xml:space="preserve">
          <source>The supervisor will then invoke &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; to retrieve a child specification. Now the &lt;code&gt;Stack&lt;/code&gt; module is responsible for building its own specification, for example, we could write:</source>
          <target state="translated">然后，主管将调用 &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; 来检索子规范。现在， &lt;code&gt;Stack&lt;/code&gt; 模块负责构建自己的规范，例如，我们可以编写：</target>
        </trans-unit>
        <trans-unit id="48df4bde49257478d542a437f9de2f0a2ea29a61" translate="yes" xml:space="preserve">
          <source>The supported class names are:</source>
          <target state="translated">支持的类名有:</target>
        </trans-unit>
        <trans-unit id="2acb742979d49cdd1ce894f691b11d6c69ead543" translate="yes" xml:space="preserve">
          <source>The supported forms are:</source>
          <target state="translated">支持的形式有:</target>
        </trans-unit>
        <trans-unit id="a8f9a7d8961a3767298fcfbab64cbbb6e0e6ee0b" translate="yes" xml:space="preserve">
          <source>The supported keys in the &lt;code&gt;:colors&lt;/code&gt; keyword list are:</source>
          <target state="translated">&lt;code&gt;:colors&lt;/code&gt; 关键字列表中支持的键是：</target>
        </trans-unit>
        <trans-unit id="3179160c7ddd0151d004050775f2d167fb2bf259" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by importance, are:</source>
          <target state="translated">按重要程度排序,所支持的级别为:</target>
        </trans-unit>
        <trans-unit id="b7878d33057652c5e4e57d591e83ecedf612c203" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by precedence, are:</source>
          <target state="translated">支持的级别按优先顺序排列如下:</target>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">支持的选项有:</target>
        </trans-unit>
        <trans-unit id="a909fba4eceb102c979e5e9c2b15d4702c456bf4" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (e.g., &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">Elixir提供的用于类型说明的语法类似于&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;Erlang中&lt;/a&gt;的语法。 Erlang提供的大多数内置类型（例如 &lt;code&gt;pid()&lt;/code&gt; ）都以相同的方式表示： &lt;code&gt;pid()&lt;/code&gt; （或简称为 &lt;code&gt;pid&lt;/code&gt; ）。还支持参数化类型（例如 &lt;code&gt;list(integer)&lt;/code&gt; ），也支持远程类型（例如 &lt;code&gt;Enum.t&lt;/code&gt; ）。允许使用整数和原子文字作为类型（例如 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;:atom&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。所有其他类型都是根据预定义类型的并集构建的。允许使用一些简写形式，例如 &lt;code&gt;[...]&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11e8b05ebb02ab602f5c99e81c78f285a85d25bf" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (for example, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">Elixir提供的用于类型说明的语法类似于&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;Erlang中&lt;/a&gt;的语法。 Erlang提供的大多数内置类型（例如 &lt;code&gt;pid()&lt;/code&gt; ）都以相同的方式表示： &lt;code&gt;pid()&lt;/code&gt; （或简称为 &lt;code&gt;pid&lt;/code&gt; ）。还支持参数化类型（例如 &lt;code&gt;list(integer)&lt;/code&gt; ），也支持远程类型（例如 &lt;code&gt;Enum.t&lt;/code&gt; ）。整数和原子文字可以作为类型使用（例如 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;:atom&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。所有其他类型都是根据预定义类型的并集构建的。允许使用一些速记，例如 &lt;code&gt;[...]&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d0036cfb43509daaf5a87c862104d3f9568ed85" translate="yes" xml:space="preserve">
          <source>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the &lt;code&gt;:c&lt;/code&gt; key failed because there is no &lt;code&gt;:c&lt;/code&gt; in the map.</source>
          <target state="translated">上面的语法要求给定密钥存在。它不能用于添加新密钥。例如，将其与 &lt;code&gt;:c&lt;/code&gt; 键一起使用失败，因为映射中没有 &lt;code&gt;:c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e74604ffed887af469a3ff79efc01a49993440e8" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;badstructerror&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">上面的语法将确保给定的键在编译时有效，并且将在运行时保证给定的参数是一个结构，否则将&lt;a href=&quot;badstructerror&quot;&gt; &lt;code&gt;BadStructError&lt;/code&gt; &lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="7180700097f6ff908399744578d9873946673ba9" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;https://hexdocs.pm/elixir/BadStructError.html&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">上面的语法将确保给定的键在编译时有效，并且将在运行时保证给定的参数为struct，否则会失败&lt;a href=&quot;https://hexdocs.pm/elixir/BadStructError.html&quot;&gt; &lt;code&gt;BadStructError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3346ccb7be2d14285ad110f9bf13a253d6668e2a" translate="yes" xml:space="preserve">
          <source>The syntax is to put the function and its input on the left side of the &lt;code&gt;::&lt;/code&gt; and the return value&amp;rsquo;s type on the right side. Be aware that types &lt;em&gt;may&lt;/em&gt; omit parentheses.</source>
          <target state="translated">语法是将函数及其输入放在 &lt;code&gt;::&lt;/code&gt; 的左侧，将返回值的类型放在右侧。请注意，类型&lt;em&gt;可能会&lt;/em&gt;省略括号。</target>
        </trans-unit>
        <trans-unit id="b84a63985dcdfb17ccdca5bd58bdd7687878200d" translate="yes" xml:space="preserve">
          <source>The system sets different environment variables. The following variables are set early on and can only be read by &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt;:</source>
          <target state="translated">系统设置不同的环境变量。以下变量是早期设置的，只能由 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 读取：</target>
        </trans-unit>
        <trans-unit id="15e9fc5e9c4c2be91d093aa25daa8c7249775f24" translate="yes" xml:space="preserve">
          <source>The tail elements of aliases are guaranteed to always be atoms.</source>
          <target state="translated">保证别名的尾元素永远是原子。</target>
        </trans-unit>
        <trans-unit id="0bcdf2274bc91e89bdf8524fe117cd1e390a0aae" translate="yes" xml:space="preserve">
          <source>The task can now be invoked with &lt;code&gt;mix hello&lt;/code&gt;.</source>
          <target state="translated">现在可以使用 &lt;code&gt;mix hello&lt;/code&gt; 调用该任务。</target>
        </trans-unit>
        <trans-unit id="2ca9f432a46eddec31b6e992a693b8edf32b4e5d" translate="yes" xml:space="preserve">
          <source>The template in &lt;code&gt;source&lt;/code&gt; is evaluated with the given &lt;code&gt;assigns&lt;/code&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;assigns&lt;/code&gt; 评估 &lt;code&gt;source&lt;/code&gt; 中的模板。</target>
        </trans-unit>
        <trans-unit id="4fec88603f65815ad051446d1e908302ee019778" translate="yes" xml:space="preserve">
          <source>The temporary directory path is unique (includes the test module and test name) and thus appropriate for running tests concurrently. You can customize the path further by setting the tag to a string, e.g.: &lt;code&gt;tmp_dir: &quot;my_path&quot;&lt;/code&gt;, which would make the final path to be: &lt;code&gt;tmp/&amp;lt;module&amp;gt;/&amp;lt;test&amp;gt;/my_path&lt;/code&gt;.</source>
          <target state="translated">临时目录路径是唯一的（包括测试模块和测试名称），因此适合同时运行测试。您可以通过将标签设置为字符串来进一步自定义路径，例如： &lt;code&gt;tmp_dir: &quot;my_path&quot;&lt;/code&gt; ，这将使最终路径为： &lt;code&gt;tmp/&amp;lt;module&amp;gt;/&amp;lt;test&amp;gt;/my_path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60d7de295785ea0605333a1eba6bb25d621b6acc" translate="yes" xml:space="preserve">
          <source>The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, &lt;code&gt;1 == 1.0&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but since they are of different types, &lt;code&gt;1 === 1.0&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果这些术语具有相同的值和相同的类型，则仅被视为完全相等。例如， &lt;code&gt;1 == 1.0&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，但是由于它们的类型不同， &lt;code&gt;1 === 1.0&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="705df9c2e6adef6ee615fd1500b80411120b3a6b" translate="yes" xml:space="preserve">
          <source>The test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.</source>
          <target state="translated">上面的测试将在最后一个断言上失败,因为即使我们停止了 bucket 进程,bucket 名称仍然在注册表中。</target>
        </trans-unit>
        <trans-unit id="c419758630890afee6c5cb360c0c3e39b020572b" translate="yes" xml:space="preserve">
          <source>The test files are sorted upfront in a round-robin fashion. Note the partition itself is given as an environment variable so it can be accessed in config files and test scripts. For example, it can be used to setup a different database instance per partition in &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">测试文件以循环方式预先排序。请注意，分区本身是作为环境变量给出的，因此可以在配置文件和测试脚本中对其进行访问。例如，它可用于在 &lt;code&gt;config/test.exs&lt;/code&gt; 中的每个分区上设置不同的数据库实例。</target>
        </trans-unit>
        <trans-unit id="2570223385e731ad04d7b7880f45f2e4a73c2ce4" translate="yes" xml:space="preserve">
          <source>The test is similar to &amp;ldquo;removes bucket on exit&amp;rdquo; except that we are being a bit more harsh by sending &lt;code&gt;:shutdown&lt;/code&gt; as the exit reason instead of &lt;code&gt;:normal&lt;/code&gt;. If a process terminates with a reason different than &lt;code&gt;:normal&lt;/code&gt;, all linked processes receive an EXIT signal, causing the linked process to also terminate unless it is trapping exits.</source>
          <target state="translated">该测试类似于&amp;ldquo;在退出时删除存储桶&amp;rdquo;，不同之处在于，通过发送 &lt;code&gt;:shutdown&lt;/code&gt; 作为退出原因而不是 &lt;code&gt;:normal&lt;/code&gt; 更加苛刻。如果某个进程由于不同于 &lt;code&gt;:normal&lt;/code&gt; 的原因而终止，则所有链接的进程都会收到EXIT信号，从而导致该链接的进程也终止，除非它正在捕获退出。</target>
        </trans-unit>
        <trans-unit id="80778ceb5bc9dd6da4a613a6cd5240315d4115bd" translate="yes" xml:space="preserve">
          <source>The test may also define a &lt;code&gt;var&lt;/code&gt;, which will pattern match on the test context. For more information on contexts, see &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">测试还可以定义一个 &lt;code&gt;var&lt;/code&gt; ，它将在测试上下文中进行模式匹配。有关上下文的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdde6c13039b2d4b85652376fce95fabfa20deef" translate="yes" xml:space="preserve">
          <source>The test should pass.</source>
          <target state="translated">测试应该会通过。</target>
        </trans-unit>
        <trans-unit id="3bf29b425a5cead446e53e0022f0fce0236e0195" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;exunit#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="translated">测试类型将转换为字符串并进行复数显示。您可以使用&lt;a href=&quot;exunit#plural_rule/2&quot;&gt; &lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt; &lt;/a&gt;设置自定义复数。</target>
        </trans-unit>
        <trans-unit id="04db17fea40288d1a870e2f7e8d0c93c33a565d3" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="translated">测试类型将转换为字符串并进行复数显示。您可以使用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#plural_rule/2&quot;&gt; &lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt; &lt;/a&gt;设置自定义复数。</target>
        </trans-unit>
        <trans-unit id="a927d1705beb862013fa4736d80e7112683437e5" translate="yes" xml:space="preserve">
          <source>The third approach uses macros, and is by far the most complex. It will take more lines of code to implement, it is hard and expensive to test (compared to testing simple functions), and it limits how the user may use the library since all validations need to be defined inside a module.</source>
          <target state="translated">第三种方法使用宏,是迄今为止最复杂的方法。它需要更多的代码行来实现,它的测试难度大,成本高(与测试简单的函数相比),而且它限制了用户使用库的方式,因为所有的验证都需要在一个模块中定义。</target>
        </trans-unit>
        <trans-unit id="1d45004d92cd0fa8dd37a67dc40c34ac5fe7a8f6" translate="yes" xml:space="preserve">
          <source>The third argument given to &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary.</source>
          <target state="translated">给&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt;的第三个参数是与当前进程关联的值。尽管在上一节中我们在调度时使用了它，但在这个特定示例中，我们对此不感兴趣，因此我们将其设置为空列表。如有必要，您可以存储更有意义的值。</target>
        </trans-unit>
        <trans-unit id="286a4f81139162ba612e0fc78d910245b92506ae" translate="yes" xml:space="preserve">
          <source>The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.</source>
          <target state="translated">第三个参数是stacktrace,用来给归一化的错误添加更多信息。它只在错误类型时使用。</target>
        </trans-unit>
        <trans-unit id="b0469bb3fc164355009dcbe32b659229c5de7434" translate="yes" xml:space="preserve">
          <source>The third element is either a list of arguments for the function call or an atom. When this element is an atom, it means the tuple represents a variable.</source>
          <target state="translated">第三个元素是函数调用的参数列表或原子。当这个元素是一个原子时,它意味着元组代表一个变量。</target>
        </trans-unit>
        <trans-unit id="61d0bd68d9312dd1a2b6bc353f3631650af592e9" translate="yes" xml:space="preserve">
          <source>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).</source>
          <target state="translated">元组的第三个元素是函数调用的参数。第三个参数可能是一个原子,它通常是一个变量(或一个局部调用)。</target>
        </trans-unit>
        <trans-unit id="e03e20762e8bbf0a5e287057fa9da1be08a2ebb0" translate="yes" xml:space="preserve">
          <source>The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt;, assuming you bound those variables in order in the match part, you would provide a body like &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt;. Like guards, you can use some operations like &lt;code&gt;:element&lt;/code&gt; to modify the output format.</source>
          <target state="translated">第三部分，主体，是返回条目的形状的列表。像警卫一样，您可以访问分配的变量，如 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ，可以将其与硬编码的值组合以自由调整条目的形状。请注意，元组必须包装在其他元组中。要获得类似 &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt; 的结果格式，假设您按顺序在匹配部分中绑定了这些变量，则应提供一个类似于 &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt; 。与警卫一样，您可以使用诸如 &lt;code&gt;:element&lt;/code&gt; 之类的一些操作来修改输出格式。</target>
        </trans-unit>
        <trans-unit id="dd8a93e3bf717eed4a2e3026f8f31870641fb464" translate="yes" xml:space="preserve">
          <source>The time functions in this module work in the &lt;code&gt;:native&lt;/code&gt; unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the &lt;code&gt;:native&lt;/code&gt; unit, to avoid loss of precision, with &lt;a href=&quot;#convert_time_unit/3&quot;&gt;&lt;code&gt;convert_time_unit/3&lt;/code&gt;&lt;/a&gt; being invoked at the end to convert to a specific time unit like &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:microsecond&lt;/code&gt;. See the &lt;a href=&quot;#t:time_unit/0&quot;&gt;&lt;code&gt;time_unit/0&lt;/code&gt;&lt;/a&gt; type for more information.</source>
          <target state="translated">该模块中的时间功能以 &lt;code&gt;:native&lt;/code&gt; 单位（除非另有说明）工作，这取决于操作系统。大多数时候，所有计算都以 &lt;code&gt;:native&lt;/code&gt; 单位进行，以避免精度损失，最后会调用&lt;a href=&quot;#convert_time_unit/3&quot;&gt; &lt;code&gt;convert_time_unit/3&lt;/code&gt; &lt;/a&gt;转换为特定的时间单位，如 &lt;code&gt;:millisecond&lt;/code&gt; 或 &lt;code&gt;:microsecond&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;#t:time_unit/0&quot;&gt; &lt;code&gt;time_unit/0&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="c81a5f56c30620f4ca3fdbd7994e540bcd3307ec" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in options. &lt;code&gt;{:time, type}&lt;/code&gt; where type can be &lt;code&gt;:local&lt;/code&gt;, &lt;code&gt;:universal&lt;/code&gt;, or &lt;code&gt;:posix&lt;/code&gt;. Default is &lt;code&gt;:universal&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中返回的时间类型取决于在options中设置的时间类型。 &lt;code&gt;{:time, type}&lt;/code&gt; ，其中type可以是 &lt;code&gt;:local&lt;/code&gt; ， &lt;code&gt;:universal&lt;/code&gt; 或 &lt;code&gt;:posix&lt;/code&gt; 。默认是 &lt;code&gt;:universal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ccc7b51abb959b7b6a642bc36ea122d38002d9a" translate="yes" xml:space="preserve">
          <source>The time unit to be passed to functions like &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">要传递给诸如&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; 之&lt;/a&gt;类的函数的时间单位。</target>
        </trans-unit>
        <trans-unit id="1bbd3b4515f159eff3b51909840a9c295b77b423" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</source>
          <target state="translated">根据IANA tz数据库的时区ID(如欧洲/苏黎世)。</target>
        </trans-unit>
        <trans-unit id="9e127d4e3ff4d398a6cfe90803c629c4523b576a" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (for example, Europe/Zurich)</source>
          <target state="translated">根据IANA tz数据库的时区ID(例如,欧洲/苏黎世)。</target>
        </trans-unit>
        <trans-unit id="b125596c86be66bad3036f66746716d52648f027" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds</source>
          <target state="translated">时区UTC偏移量(秒)</target>
        </trans-unit>
        <trans-unit id="3df5c55c74cecebffe247785901344586d62d59b" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds for standard time.</source>
          <target state="translated">标准时间的时区UTC偏移,单位为秒。</target>
        </trans-unit>
        <trans-unit id="4a33e0326e0255c69b66326b76b995f67cc50bc7" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (e.g. CET or CEST or BST etc.)</source>
          <target state="translated">时区缩写(如CET或CEST或BST等)</target>
        </trans-unit>
        <trans-unit id="e483f17410a33eb44510ffea9561b18ac2cf91e9" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (for example, CET or CEST or BST, and such)</source>
          <target state="translated">时区缩写(例如,CET或CEST或BST等)。</target>
        </trans-unit>
        <trans-unit id="fcad795376e4abb458cc8e3841c41b9eba5c998c" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (not zero in summer times)</source>
          <target state="translated">时区标准偏移量,以秒为单位(夏季不为零)。</target>
        </trans-unit>
        <trans-unit id="25fd14442f68de45c7fa315a32da5dbaeb94d1d8" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (typically not zero in summer times).</source>
          <target state="translated">时区标准偏移量,以秒为单位(夏季一般不为零)。</target>
        </trans-unit>
        <trans-unit id="cce73f4a8a7c3c6d7d87f75bc5aa727351d2f2f2" translate="yes" xml:space="preserve">
          <source>The timer will be automatically canceled if the given &lt;code&gt;dest&lt;/code&gt; is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when &lt;code&gt;dest&lt;/code&gt; is an atom (as the atom resolution is done on delivery).</source>
          <target state="translated">如果给定的 &lt;code&gt;dest&lt;/code&gt; 是一个未激活的PID或给定的PID退出，则计时器将自动取消。请注意，当 &lt;code&gt;dest&lt;/code&gt; 是一个原子时，计时器将不会自动取消（因为原子分辨率是在交付时完成的）。</target>
        </trans-unit>
        <trans-unit id="95f67c03b8dd416c9af30e47423ea3401d29e99a" translate="yes" xml:space="preserve">
          <source>The trait can be one of two options:</source>
          <target state="translated">该性状可以是两个选项之一。</target>
        </trans-unit>
        <trans-unit id="8c51e1e67805ed16c58e9c1e802e36335ea6aca4" translate="yes" xml:space="preserve">
          <source>The trouble with state</source>
          <target state="translated">国家的问题</target>
        </trans-unit>
        <trans-unit id="a1d02c2f92fc207d7072d19d88bfe702734e4f16" translate="yes" xml:space="preserve">
          <source>The tuple above represents a function call to &lt;code&gt;sum&lt;/code&gt; passing 1, 2 and 3 as arguments. The tuple elements are:</source>
          <target state="translated">上面的元组表示一个函数调用， &lt;code&gt;sum&lt;/code&gt; 传递1、2和3作为参数。元组元素是：</target>
        </trans-unit>
        <trans-unit id="88ca5571ed44473b8f3ce89710c5edfce0720f58" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keyword lists keys must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="translated">这两种语法是完全等效的。像原子一样，关键字列表键必须由Unicode字符组成，例如字母，数字，下划线和 &lt;code&gt;@&lt;/code&gt; 。如果关键字的字符不属于上述类别，例如空格，则可以将其用引号引起来：</target>
        </trans-unit>
        <trans-unit id="0be32613fcd0e0034d6c53c421573b087961e380" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keywords must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="translated">这两种语法是完全等效的。像原子一样，关键字必须由Unicode字符组成，例如字母，数字，下划线和 &lt;code&gt;@&lt;/code&gt; 。如果关键字的字符不属于上述类别，例如空格，则可以将其用引号引起来：</target>
        </trans-unit>
        <trans-unit id="c03fb1d89c3fb5cf593c60e9aa138dedff7e09ba" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="translated">访问密钥的两种语法揭示了映射的双重性质。的 &lt;code&gt;map[key]&lt;/code&gt; 语法用于可具有任意键的任何类型的，动态创建的地图。 &lt;code&gt;map.key&lt;/code&gt; 与持有预定的原子键集合的地图一起使用，该原子键预计将始终存在。通过&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;定义的结构是此类&amp;ldquo;静态映射&amp;rdquo;的一个示例，其中的键也可以在编译时进行检查。</target>
        </trans-unit>
        <trans-unit id="7bf824f894b5901f732af99ee1c6741c2c8f9460" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="translated">访问密钥的两种语法揭示了映射的双重性质。的 &lt;code&gt;map[key]&lt;/code&gt; 语法用于可具有任意键的任何类型的，动态创建的地图。 &lt;code&gt;map.key&lt;/code&gt; 与持有预定的原子键集合的地图一起使用，该原子键预计将始终存在。通过&lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;定义的结构是此类&amp;ldquo;静态映射&amp;rdquo;的一个示例，其中的键也可以在编译时进行检查。</target>
        </trans-unit>
        <trans-unit id="27b2df44172f3a57aa97a9d731e7cf407e529ef4" translate="yes" xml:space="preserve">
          <source>The type of keys allowed on registration</source>
          <target state="translated">注册时允许的钥匙类型</target>
        </trans-unit>
        <trans-unit id="2981849bde4b665272891869623a6b0939beaaa5" translate="yes" xml:space="preserve">
          <source>The type of registry metadata keys</source>
          <target state="translated">登记处元数据键的类型</target>
        </trans-unit>
        <trans-unit id="1b222464dab205a6bd54b94d0bb3729d611af5dc" translate="yes" xml:space="preserve">
          <source>The type of registry metadata values</source>
          <target state="translated">登记处元数据值的类型</target>
        </trans-unit>
        <trans-unit id="1d6b108d320c16acf0d32c924ccacb139089d8c7" translate="yes" xml:space="preserve">
          <source>The type of the registry</source>
          <target state="translated">登记处的类型</target>
        </trans-unit>
        <trans-unit id="53279e10023dca8a2288968b9bcf710b0c986964" translate="yes" xml:space="preserve">
          <source>The type of values allowed on registration</source>
          <target state="translated">注册时允许的值的类型</target>
        </trans-unit>
        <trans-unit id="96d309a1ca8c9b49d61652c9574ee5761b49d46b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">类型 &lt;code&gt;String.t()&lt;/code&gt; 和 &lt;code&gt;binary()&lt;/code&gt; 等效于分析工具。尽管对于那些阅读文档的人， &lt;code&gt;String.t()&lt;/code&gt; 暗示它是UTF-8编码的二进制文件。</target>
        </trans-unit>
        <trans-unit id="fd984a4e58cc83d476fe33ed807205982b711883" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%User{}&lt;/code&gt; 中不包含的struct字段的类型默认为 &lt;code&gt;term()&lt;/code&gt; （请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;term/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cb8c250a62b4261ebc510b4a71573c121311d0bb" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%User{}&lt;/code&gt; 中不包含的struct字段的类型默认为 &lt;code&gt;term()&lt;/code&gt; （请参阅&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;term/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b4b4572dc37f28e7b3a1df4f6c8add52491639ae" translate="yes" xml:space="preserve">
          <source>The underscore variable (&lt;code&gt;_&lt;/code&gt;) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:</source>
          <target state="translated">下划线变量（ &lt;code&gt;_&lt;/code&gt; ）具有特殊含义，因为它永远不能绑定到任何值。当您不关心模式中的某些值时，它特别有用：</target>
        </trans-unit>
        <trans-unit id="d2b5512b33fdcb38fab8fdf28a5c744cc440968f" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">单位也可以是&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;的整数：</target>
        </trans-unit>
        <trans-unit id="8b47b534c105a2118838e65f4bd8f13e6c75b738" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">单位也可以是&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;的整数：</target>
        </trans-unit>
        <trans-unit id="a447ce422905d13f06edc954109b01bb1211f3ed" translate="yes" xml:space="preserve">
          <source>The unreachable and deprecated checks below happen every time your project is compiled via &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;mix compile.xref&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">每次通过&lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;mix compile.xref&lt;/code&gt; &lt;/a&gt;编译您的项目时，都会发生以下不可达和不推荐使用的检查。有关更多信息，请参见&lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f350c7b62e10906702ea9465bc4c4e8ee009110d" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;:ok&lt;/code&gt;/&lt;code&gt;:error&lt;/code&gt; tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary.</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; / &lt;code&gt;:error&lt;/code&gt; 元组的用法与该函数起作用的域有关，在这种情况下，是文件系统访问权限。无论函数名如何，错误的参数，逻辑错误，无效的选项都应引发。如有疑问，最好返回元组而不是加元，因为您库的用户始终可以匹配结果，并在必要时加元。</target>
        </trans-unit>
        <trans-unit id="f2761fc5ed5c6c550d3c3f11fa24ee7951107bd4" translate="yes" xml:space="preserve">
          <source>The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;.</source>
          <target state="translated">用户必须按Enter键或输入 &quot;y&quot;、&quot;yes&quot;、&quot;Y&quot;、&quot;YES &quot;或 &quot;Yes &quot;中的一个。</target>
        </trans-unit>
        <trans-unit id="067adddb8899b26a44c6d119cc5060679343ac3f" translate="yes" xml:space="preserve">
          <source>The valid parameters you can use are:</source>
          <target state="translated">你可以使用的有效参数有:</target>
        </trans-unit>
        <trans-unit id="3e5fe130617142d21e815f74a253669918514b41" translate="yes" xml:space="preserve">
          <source>The value emitted is &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given time until the element is streamed.</source>
          <target state="translated">发出的值为 &lt;code&gt;0&lt;/code&gt; 。此操作将在给定时间之前阻止调用者，直到流式传输元素为止。</target>
        </trans-unit>
        <trans-unit id="d90bdb7c5d59a88b306900023f5ca84001349ca6" translate="yes" xml:space="preserve">
          <source>The value is a keyword list with two possible keys representing prompt types:</source>
          <target state="translated">该值是一个关键字列表,有两个可能的键代表提示类型。</target>
        </trans-unit>
        <trans-unit id="caa6577865e36568b3711626c14e00f9b424ae56" translate="yes" xml:space="preserve">
          <source>The value is no longer a binary, but a bitstring &amp;ndash; a bunch of bits! So a binary is a bitstring where the number of bits is divisible by 8.</source>
          <target state="translated">该值不再是二进制，而是一个位串-一堆位！因此，二进制是一个位串，其中位数可以被8整除。</target>
        </trans-unit>
        <trans-unit id="3cc68a54cd0dbc959bc6164a6a2b53075dfa30ea" translate="yes" xml:space="preserve">
          <source>The values emitted are an increasing counter starting at &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given interval every time a new element is streamed.</source>
          <target state="translated">发出的值是一个从 &lt;code&gt;0&lt;/code&gt; 开始的递增计数器。每当有新元素流式传输时，此操作将以给定的时间间隔阻止调用者。</target>
        </trans-unit>
        <trans-unit id="be1b57a18ace41fb8f93930afe8b1ad887b40d1d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:case&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:case&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="3a8416871ca07e4a4f59fb2e54024c09ce510c3d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:padding&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="48b014b54ab14e39b32c6219693fd725eede8847" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:time&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="21f3f4f945d9026f4fff4e43f08cf7f4707e46e4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;_&lt;/code&gt; is special in that it can never be read from. Trying to read from it gives a compile error:</source>
          <target state="translated">变量 &lt;code&gt;_&lt;/code&gt; 的特殊之处在于它永远无法读取。尝试从中读取会产生编译错误：</target>
        </trans-unit>
        <trans-unit id="9e1be81239623e7fbf2a82d7e2a4f2b80599067d" translate="yes" xml:space="preserve">
          <source>The variables defined inside &lt;code&gt;quote&lt;/code&gt; won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</source>
          <target state="translated">由于引用表达式中的卫生机制，因此在撬动期间在 &lt;code&gt;quote&lt;/code&gt; 内定义的变量将不可用。卫生机制会更改带引号的表达式中的变量名称，以免它们与宏用户定义的变量冲突。因此，原始名称不可用。</target>
        </trans-unit>
        <trans-unit id="c8744b53eaf293e92df6d8b3f6054f83b09340e5" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer 2.0: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="translated">版本由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;结构表示，并且字段根据SemVer 2.0命名 &lt;code&gt;:major&lt;/code&gt; ， &lt;code&gt;:minor&lt;/code&gt; ， &lt;code&gt;:patch&lt;/code&gt; ， &lt;code&gt;:pre&lt;/code&gt; 和 &lt;code&gt;:build&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d0b621f78879c76c317ddf557989e7b4d0a18c9" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="translated">版本由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;结构表示，字段根据SemVer &lt;code&gt;:major&lt;/code&gt; ， &lt;code&gt;:minor&lt;/code&gt; ， &lt;code&gt;:patch&lt;/code&gt; ， &lt;code&gt;:pre&lt;/code&gt; 和 &lt;code&gt;:build&lt;/code&gt; 命名。</target>
        </trans-unit>
        <trans-unit id="64e09f157d5e5070ea793feca6351f0810f54544" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;!&lt;/code&gt; is preferred when you want to handle different outcomes using pattern matching:</source>
          <target state="translated">没有版本 &lt;code&gt;!&lt;/code&gt; 如果您想使用模式匹配来处理不同的结果，则首选：</target>
        </trans-unit>
        <trans-unit id="e2528fcfa71e426e6f186925ba5d183a72e0825f" translate="yes" xml:space="preserve">
          <source>The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">通配符看起来就像一个普通的路径,只是下面的 &quot;通配符 &quot;会有特殊的解释。</target>
        </trans-unit>
        <trans-unit id="0fcbc9b2e71d94abc862c5aacc86295bf5f87ef7" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits and, while ISO 8601 allows datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Note leap seconds are not supported by the built-in Calendar.ISO.</source>
          <target state="translated">该函数解析的年份仅限于四位数,虽然ISO 8601允许将日期时间指定为24:00:00作为第二天的零时,但Elixir不支持这种符号。注意内置的Calendar.ISO不支持闰秒。</target>
        </trans-unit>
        <trans-unit id="43359a56ca5b9f74f8ed54225f235a4eac841d33" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits.</source>
          <target state="translated">该函数解析的年份限定为四位数。</target>
        </trans-unit>
        <trans-unit id="42c8fd279491ba3a5a79a3fc57c18b896f2e8d7e" translate="yes" xml:space="preserve">
          <source>The zip and zlib modules</source>
          <target state="translated">zip和zlib模块</target>
        </trans-unit>
        <trans-unit id="a928b0d99e54733f051669ca9f28257ad67f0a00" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable completes.</source>
          <target state="translated">拉链完成后,只要任何列举完成。</target>
        </trans-unit>
        <trans-unit id="92c61e8c081422e6cb087e5091e2eef8743332a7" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable in the given collection completes.</source>
          <target state="translated">当给定集合中的任何一个枚举完成后,拉链就完成了。</target>
        </trans-unit>
        <trans-unit id="5390d109c8d9531238497e8770981143c5154c71" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any list terminates.</source>
          <target state="translated">当任何列表终止时,拉链就结束了。</target>
        </trans-unit>
        <trans-unit id="b625dd872916e65cdac731dbaa58c2540d9b95a9" translate="yes" xml:space="preserve">
          <source>Then we define a &lt;code&gt;start_link/1&lt;/code&gt; function, which will effectively start the agent. It is a convention to define a &lt;code&gt;start_link/1&lt;/code&gt; function that always accepts a list of options. We don&amp;rsquo;t plan on using any options right now, but we might later on. We then proceed to call &lt;code&gt;Agent.start_link/1&lt;/code&gt;, which receives an anonymous function that returns the Agent&amp;rsquo;s initial state.</source>
          <target state="translated">然后，我们定义一个 &lt;code&gt;start_link/1&lt;/code&gt; 函数，它将有效地启动代理。约定定义一个 &lt;code&gt;start_link/1&lt;/code&gt; 函数，该函数始终接受选项列表。我们暂时不打算使用任何选项，但稍后可能会使用。然后，我们继续调用 &lt;code&gt;Agent.start_link/1&lt;/code&gt; ，它接收一个返回代理程序初始状态的匿名函数。</target>
        </trans-unit>
        <trans-unit id="87d5cb2e280470b50ded81bad6b2dc9e656de005" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider in the release configuration:</source>
          <target state="translated">然后在指定发布时,你可以在发布配置中指定提供者。</target>
        </trans-unit>
        <trans-unit id="a9efffd6370bf177135cf0838aedef8c490edaff" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider:</source>
          <target state="translated">然后在指定你的发布时,你可以指定提供者。</target>
        </trans-unit>
        <trans-unit id="90be63383bb86c2a9b4266d11b3e7f59bb1305ef" translate="yes" xml:space="preserve">
          <source>Then, we add the head of the list to the accumulator &lt;code&gt;head + accumulator&lt;/code&gt; and call &lt;code&gt;sum_list&lt;/code&gt; again, recursively, passing the tail of the list as its first argument. The tail will once again match &lt;code&gt;[head | tail]&lt;/code&gt; until the list is empty, as seen below:</source>
          <target state="translated">然后，我们将列表的开头添加到累加器的 &lt;code&gt;head + accumulator&lt;/code&gt; 并递归地再次调用 &lt;code&gt;sum_list&lt;/code&gt; ，并将列表的结尾作为第一个参数。尾巴将再次匹配 &lt;code&gt;[head | tail]&lt;/code&gt; 直到列表为空，如下所示：</target>
        </trans-unit>
        <trans-unit id="6b87f84651e39aeea5d926774256f894a29c7180" translate="yes" xml:space="preserve">
          <source>Then, whenever desired, those tests could be included in the run via the &lt;code&gt;--include&lt;/code&gt; option:</source>
          <target state="translated">然后，只要需要，就可以通过 &lt;code&gt;--include&lt;/code&gt; 选项将这些测试包括在运行中：</target>
        </trans-unit>
        <trans-unit id="34c7a694bb4b3edc18ed538476727a5e7423da3d" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to guarantee that a release is built on a host with the same properties as the target. A simple option is to fetch the source, compile the code and assemble the release on the target itself. It would be something like this:</source>
          <target state="translated">有几种方法可以保证发布版本是在与目标相同属性的主机上构建的。一个简单的方法是获取源代码,编译代码,然后在目标机上组装发布。它将是这样的。</target>
        </trans-unit>
        <trans-unit id="b194d7af362d9259824b1fbfd5de6ca884c3d2da" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve a character integer code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="translated">有两种方法可以检索字符整数代码点。一个可以使用 &lt;code&gt;?&lt;/code&gt; 构造：</target>
        </trans-unit>
        <trans-unit id="fd47a0efe22eeb6657bd6cb7a37660028cc2160e" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve the character code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="translated">有两种方法可以检索字符代码点。一个可以使用 &lt;code&gt;?&lt;/code&gt; 构造：</target>
        </trans-unit>
        <trans-unit id="d172ca4ba6fbab564abb0cac6cec14ca318e2156" translate="yes" xml:space="preserve">
          <source>There are a couple other modifiers that can be useful when doing pattern matches on binaries. The &lt;code&gt;binary-size(n)&lt;/code&gt; modifier will match &lt;code&gt;n&lt;/code&gt; bytes in a binary:</source>
          <target state="translated">在二进制文件上进行模式匹配时，还有其他几个修饰符可能会很有用。的 &lt;code&gt;binary-size(n)&lt;/code&gt; 改性剂将匹配 &lt;code&gt;n&lt;/code&gt; 字节在二进制：</target>
        </trans-unit>
        <trans-unit id="1fd8e7b8f98e5336f83be9a7d713b450297e94ab" translate="yes" xml:space="preserve">
          <source>There are a couple other options here. One option is to spawn the distributed node programmatically at the beginning of &lt;code&gt;test/test_helper.exs&lt;/code&gt;. Erlang/OTP does provide APIs for doing so, but they are non-trivial and therefore we won&amp;rsquo;t cover them here.</source>
          <target state="translated">这里还有其他几个选择。一种选择是在 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 的开头以编程方式生成分布式节点。Erlang / OTP确实提供了这样做的API，但是它们并非易事，因此我们在这里不介绍它们。</target>
        </trans-unit>
        <trans-unit id="b5c718f04d68cfff9168f654a99aa0bd9577e3dd" translate="yes" xml:space="preserve">
          <source>There are a couple ways in which developers can customize the generated artifacts inside a release.</source>
          <target state="translated">开发者可以通过几种方式来定制发行版内生成的工件。</target>
        </trans-unit>
        <trans-unit id="c36172e9cd5c05c77e84149217392745df0757dd" translate="yes" xml:space="preserve">
          <source>There are a few attributes available in Mix tasks to configure them in Mix:</source>
          <target state="translated">Mix任务中有一些属性可以在Mix中进行配置。</target>
        </trans-unit>
        <trans-unit id="29207daf154a421b800aeacb77caf5c5eb506793" translate="yes" xml:space="preserve">
          <source>There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case.</source>
          <target state="translated">有几个合适的替代方案可以取代GenEvent。其中每一种都可以根据用例成为最有利的选择。</target>
        </trans-unit>
        <trans-unit id="10bcc082a2d994b16cb89b80b77c2f9140673c29" translate="yes" xml:space="preserve">
          <source>There are a few ways to quit the IEx shell:</source>
          <target state="translated">有几种方法可以退出 IEx shell。</target>
        </trans-unit>
        <trans-unit id="622f4d4a041d29a7624f6c3efe7c38d00a98501a" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="translated">IEx提供了许多自定义选项。通过输入 &lt;code&gt;h IEx.configure/1&lt;/code&gt; 来查看&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt;函数的文档。</target>
        </trans-unit>
        <trans-unit id="7d8ce000a8dc139890c07c24e80b5de5ae99f4f0" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="translated">IEx提供了许多自定义选项。通过输入 &lt;code&gt;h IEx.configure/1&lt;/code&gt; 来查看&lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt;函数的文档。</target>
        </trans-unit>
        <trans-unit id="09d8b4775b01e8f623175d798409cd369f28544b" translate="yes" xml:space="preserve">
          <source>There are a number of ways to debug code in Elixir. In this chapter we will cover some of the more common ways of doing so.</source>
          <target state="translated">在Elixir中,有很多方法可以调试代码,本章我们将介绍一些比较常见的方法。在本章中,我们将介绍一些比较常见的方法。</target>
        </trans-unit>
        <trans-unit id="aa57737d9360fbe5afeae180cdd5ea0fce51697c" translate="yes" xml:space="preserve">
          <source>There are additional macros for other levels.</source>
          <target state="translated">还有其他级别的宏。</target>
        </trans-unit>
        <trans-unit id="a57a74b23748fb93cbfac3d76920a5b6c297f9f8" translate="yes" xml:space="preserve">
          <source>There are also other known problems like flooring or rounding numbers. See &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for more details about them.</source>
          <target state="translated">还存在其他已知问题，例如地板号或舍入数字。有关它们的更多详细信息，请参见&lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5aa51c40876eefd1b0d73b2bb1e06b02c0333f56" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些不成对的函数，没有非爆炸变体。爆炸仍然表示它将在失败时引发异常。示例：&lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#assert_protocol!/1&quot;&gt; &lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e4e195bc2fdfc89b8bda777699ef0647f0c7ff7" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些不成对的函数，没有非爆炸变体。爆炸仍然表示它将在失败时引发异常。示例：&lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt; &lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5ae6e32d973b8c6e5e16938f53a6274e7ce3ca" translate="yes" xml:space="preserve">
          <source>There are currently no plans for a major v2 release.</source>
          <target state="translated">目前还没有重大的v2发布计划。</target>
        </trans-unit>
        <trans-unit id="579246d0821bd1ab37dccebc3ea342f2ad2e0066" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块上也有与浮点数有关的功能。以下是它们的列表：</target>
        </trans-unit>
        <trans-unit id="70fbc19347af9335ddb73d64b97e33f72c2ab414" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块上也有与浮点数有关的功能。以下是它们的列表：</target>
        </trans-unit>
        <trans-unit id="0447596598be1689749a73489423ead2b26c8b89" translate="yes" xml:space="preserve">
          <source>There are many functions in Elixir's standard library that return streams, some examples are:</source>
          <target state="translated">在Elixir的标准库中,有很多函数可以返回流,一些例子是。</target>
        </trans-unit>
        <trans-unit id="87db69fabab6d8aebc72fcaa67f0f5d2378adab2" translate="yes" xml:space="preserve">
          <source>There are many other helpers available, here are some examples:</source>
          <target state="translated">还有很多其他的辅助工具,下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="926409681cd9a91dbce4de89116e3485c968a501" translate="yes" xml:space="preserve">
          <source>There are many situations where using the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string &lt;code&gt;prefix&lt;/code&gt; and you want to remove this prefix from another string named &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">在许多情况下，可以避免使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块，而使用二进制函数或模式匹配。例如，假设您有一个字符串 &lt;code&gt;prefix&lt;/code&gt; 并且想要从另一个名为 &lt;code&gt;full&lt;/code&gt; 的字符串中删除此前缀。</target>
        </trans-unit>
        <trans-unit id="d8989cd7033f2099b81956882184639864ede98b" translate="yes" xml:space="preserve">
          <source>There are no guarantees about the order of keys in the returned keyword.</source>
          <target state="translated">在返回的关键词中,不保证键的顺序。</target>
        </trans-unit>
        <trans-unit id="54c0f70e4a42a4d0d67a77196f05623f3bcdb80e" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones.</source>
          <target state="translated">Elixir中还有其他协议,但这涵盖了最常见的协议。</target>
        </trans-unit>
        <trans-unit id="acb7aab73db89a3f93bdbd205b772057e9bacc95" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones. You can learn more about protocols and implementations in the &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Elixir中还有其他协议，但这涵盖了最常见的协议。您可以在&amp;ldquo;&lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt;模块中了解有关协议和实现的更多信息。</target>
        </trans-unit>
        <trans-unit id="3101471cbaca1a87da38ada818ec10b102a0a294" translate="yes" xml:space="preserve">
          <source>There are other tuple formats both &lt;code&gt;handle_call/3&lt;/code&gt; and &lt;code&gt;handle_cast/2&lt;/code&gt; callbacks may return. There are also other callbacks like &lt;code&gt;terminate/2&lt;/code&gt; and &lt;code&gt;code_change/3&lt;/code&gt; that we could implement. You are welcome to explore the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;full GenServer documentation&lt;/a&gt; to learn more about those.</source>
          <target state="translated">还有其他元组格式， &lt;code&gt;handle_call/3&lt;/code&gt; 和 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调都可能返回。我们还可以实现其他回调，例如 &lt;code&gt;terminate/2&lt;/code&gt; 和 &lt;code&gt;code_change/3&lt;/code&gt; 。欢迎您浏览&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;完整的GenServer文档，&lt;/a&gt;以进一步了解这些内容。</target>
        </trans-unit>
        <trans-unit id="8c6bd7329e736075fbed60e12572ebdf4871cb55" translate="yes" xml:space="preserve">
          <source>There are probably many more to come too!</source>
          <target state="translated">可能还有更多的人要来!</target>
        </trans-unit>
        <trans-unit id="eabb9c46f92e64d3211aa2057e1cb64ad70409b3" translate="yes" xml:space="preserve">
          <source>There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:</source>
          <target state="translated">有一些模块目前Elixir还没有实现,但将来可能会实现。这些模块是保留的,定义它们会导致编译错误。</target>
        </trans-unit>
        <trans-unit id="eb77960230e6dd3139afa82409f2f1ffc3a5c2e5" translate="yes" xml:space="preserve">
          <source>There are some very well known problems with floating-point numbers and arithmetics due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.</source>
          <target state="translated">浮点数字和算术有一些众所周知的问题,因为大多数小数不能用浮点二进制表示,而且大多数运算不是精确的,而是在近似值上操作。这些问题并不是Elixir所特有的,而是浮点表示法本身的一个特性。</target>
        </trans-unit>
        <trans-unit id="e3154b8cdccf8ec261d752f5f3690d9739db0824" translate="yes" xml:space="preserve">
          <source>There are three better alternatives to &lt;code&gt;Node.spawn_link/2&lt;/code&gt; that we could use in our implementation:</source>
          <target state="translated">我们可以在实现中使用三种更好的 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 替代方案：</target>
        </trans-unit>
        <trans-unit id="0a011fd8fc19265bbdfa804b9e46482377afe2df" translate="yes" xml:space="preserve">
          <source>There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated.</source>
          <target state="translated">有三个回调在定义函数时被调用,以及在模块字节码生成之前和之后立即被调用。</target>
        </trans-unit>
        <trans-unit id="f0cff0a96056604973d2ce970f4952a288926525" translate="yes" xml:space="preserve">
          <source>There are three main use cases for not replying using the return value:</source>
          <target state="translated">使用返回值不回复主要有三种用例。</target>
        </trans-unit>
        <trans-unit id="adbd396ed0556c8293f2a87ae93d14c10746024c" translate="yes" xml:space="preserve">
          <source>There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module.</source>
          <target state="translated">有两种 API 用于处理 ports。它可以像上面的例子一样,通过消息传递进行异步操作,也可以通过调用这个模块上的函数来实现。</target>
        </trans-unit>
        <trans-unit id="701240237d3a52a3d32e044be779f88e8b80021f" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls when using the pipe operator.</source>
          <target state="translated">在使用管道运营商时,有两个常见的陷阱。</target>
        </trans-unit>
        <trans-unit id="406dbf0d435a200ca4cabd1441349a8cdaeded38" translate="yes" xml:space="preserve">
          <source>There are two concerns in this approach.</source>
          <target state="translated">这种做法有两个问题。</target>
        </trans-unit>
        <trans-unit id="5cac6c30b6750da044a369458652387600eab8a0" translate="yes" xml:space="preserve">
          <source>There are two data types without an accompanying module:</source>
          <target state="translated">有两种数据类型没有附带模块。</target>
        </trans-unit>
        <trans-unit id="b081e88ef54c7ae6048998f8dea958b729c0be39" translate="yes" xml:space="preserve">
          <source>There are two important things to consider when using &lt;code&gt;async&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;async&lt;/code&gt; 时，有两点要考虑的重要事项：</target>
        </trans-unit>
        <trans-unit id="a03d1dfcb5538f40d22abd10d512a80d2c451bc1" translate="yes" xml:space="preserve">
          <source>There are two topics left before we move on to the next chapter.</source>
          <target state="translated">在我们进入下一章之前,还剩下两个题目。</target>
        </trans-unit>
        <trans-unit id="b6bcf7cf68be2f9527622d710936107d32e56ffb" translate="yes" xml:space="preserve">
          <source>There are two types of captured functions: &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. External functions are functions residing in modules that are captured with &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt;. Local functions are anonymous functions defined with &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn/1&lt;/code&gt;&lt;/a&gt; or with the capture operator &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt;, and so on as replacements.</source>
          <target state="translated">捕获的函数有两种类型：&lt;strong&gt;external&lt;/strong&gt;和&lt;strong&gt;local&lt;/strong&gt;。外部函数是驻留在用&lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; &lt;/a&gt;捕获的模块中的函数，例如 &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt; 。局部函数是使用&lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt; &lt;code&gt;fn/1&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;&amp;amp;1&lt;/code&gt; ， &lt;code&gt;&amp;amp;2&lt;/code&gt; 等作为捕获运算符&lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; &lt;/a&gt;定义的匿名函数，以此类推。</target>
        </trans-unit>
        <trans-unit id="71487477c04c1e20b0a1c8eb6cde1dc3cb98c687" translate="yes" xml:space="preserve">
          <source>There are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server &lt;strong&gt;must&lt;/strong&gt; send a response back to such requests. While the server computes the response, the client is &lt;strong&gt;waiting&lt;/strong&gt;. Casts are asynchronous: the server won&amp;rsquo;t send a response back and therefore the client won&amp;rsquo;t wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the &lt;code&gt;:create&lt;/code&gt; messages, to be handled as cast, and on the &lt;code&gt;:lookup&lt;/code&gt; messages, to be handled as call.</source>
          <target state="translated">您可以向GenServer发送两种类型的请求：调用和强制转换。调用是同步的，服务器&lt;strong&gt;必须&lt;/strong&gt;将响应发送回此类请求。服务器计算响应时，客户端正在&lt;strong&gt;等待&lt;/strong&gt;。强制转换是异步的：服务器不会发回响应，因此客户端不会等待响应。这两个请求都是发送到服务器的消息，将按顺序处理。在上面的实现中，我们对 &lt;code&gt;:create&lt;/code&gt; 消息（将作为强制转换）和 &lt;code&gt;:lookup&lt;/code&gt; 消息（作为调用进行处理）进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="99e8c78e4095307ef4673f7069817242c3a373e9" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt; expressions in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. The following code:</source>
          <target state="translated">存在简化警卫队中的 &lt;code&gt;or&lt;/code&gt; 表达式链的另一种方法：Elixir支持在同一子句中编写&amp;ldquo;多个警卫队&amp;rdquo;。如下代码：</target>
        </trans-unit>
        <trans-unit id="3c9ea73ebc91f0affdf337778b29e743e68daec7" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt;s in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. This:</source>
          <target state="translated">还有另一种方法可以简化防护中的 &lt;code&gt;or&lt;/code&gt; 链：Elixir支持在同一子句中编写&amp;ldquo;多个防护&amp;rdquo;。这个：</target>
        </trans-unit>
        <trans-unit id="36182dc39abbf8ba08b014521f410bb7023fa49b" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, that is rarely changed. It is set automatically based on the value in &lt;code&gt;:start&lt;/code&gt;.</source>
          <target state="translated">第六个键 &lt;code&gt;:modules&lt;/code&gt; 很少更改。它是根据 &lt;code&gt;:start&lt;/code&gt; 中的值自动设置的。</target>
        </trans-unit>
        <trans-unit id="3abc172d49d7232eeddc547e457e9a9da963ba98" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, which is optional and is rarely changed. It is set automatically based on the &lt;code&gt;:start&lt;/code&gt; value.</source>
          <target state="translated">有第六个键 &lt;code&gt;:modules&lt;/code&gt; ，它是可选的，很少更改。它是基于 &lt;code&gt;:start&lt;/code&gt; 值自动设置的。</target>
        </trans-unit>
        <trans-unit id="cacb5192e79338de26b6ff207a8ab99cd8a36150" translate="yes" xml:space="preserve">
          <source>There is also a deprecated strategy called &lt;code&gt;:simple_one_for_one&lt;/code&gt; which has been replaced by the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;:simple_one_for_one&lt;/code&gt; supervisor was similar to &lt;code&gt;:one_for_one&lt;/code&gt; but suits better when dynamically attaching children. Many functions in this module behaved slightly differently when this strategy was used. See the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module for more information and migration strategies.</source>
          <target state="translated">还有一个不推荐使用的策略 &lt;code&gt;:simple_one_for_one&lt;/code&gt; ，已由&lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;取代。的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 主管是相似的 &lt;code&gt;:one_for_one&lt;/code&gt; 但西服的时候动态附加儿童更好。使用此策略时，此模块中的许多功能的行为略有不同。有关更多信息和迁移策略，请参见&lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="21605b424eea559d8c71a63a6ba5de9f7a6c7351" translate="yes" xml:space="preserve">
          <source>There is also a private function named &lt;code&gt;deps&lt;/code&gt;, which is invoked from the &lt;code&gt;project&lt;/code&gt; function, that defines our project dependencies. Defining &lt;code&gt;deps&lt;/code&gt; as a separate function is not required, but it helps keep the project configuration tidy.</source>
          <target state="translated">还有一个名为 &lt;code&gt;deps&lt;/code&gt; 的私有函数，它从 &lt;code&gt;project&lt;/code&gt; 函数中调用，它定义了我们的项目依赖项。不需要将 &lt;code&gt;deps&lt;/code&gt; 定义为单独的功能，但这有助于保持项目配置整洁。</target>
        </trans-unit>
        <trans-unit id="bb7b6e86fbf7b732fa4c4c68a1745621601d30ca" translate="yes" xml:space="preserve">
          <source>There is more to learn about &lt;code&gt;put_in/2&lt;/code&gt; and &lt;code&gt;update_in/2&lt;/code&gt;, including the &lt;code&gt;get_and_update_in/2&lt;/code&gt; that allows us to extract a value and update the data structure at once. There are also &lt;code&gt;put_in/3&lt;/code&gt;, &lt;code&gt;update_in/3&lt;/code&gt; and &lt;code&gt;get_and_update_in/3&lt;/code&gt; which allow dynamic access into the data structure. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;Check their respective documentation in the &lt;code&gt;Kernel&lt;/code&gt; module for more information&lt;/a&gt;.</source>
          <target state="translated">还有更多关于 &lt;code&gt;put_in/2&lt;/code&gt; 和 &lt;code&gt;update_in/2&lt;/code&gt; 的知识，包括 &lt;code&gt;get_and_update_in/2&lt;/code&gt; ，它使我们能够提取值并立即更新数据结构。还有 &lt;code&gt;put_in/3&lt;/code&gt; ， &lt;code&gt;update_in/3&lt;/code&gt; 和 &lt;code&gt;get_and_update_in/3&lt;/code&gt; ，它们允许动态访问数据结构。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;有关详细信息，&lt;/a&gt;请查看 &lt;code&gt;Kernel&lt;/code&gt; 模块中各自的文档。</target>
        </trans-unit>
        <trans-unit id="6b4424ea8037c81012b4a89fa0c4119c6711e1c4" translate="yes" xml:space="preserve">
          <source>There is much more to Mix, and we will continue to explore it as we build our project. A &lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;general overview is available on the Mix documentation&lt;/a&gt;. Read &lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;the Mix source code here&lt;/a&gt;.</source>
          <target state="translated">Mix还有很多，我们将在构建项目时继续探索它。一个&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;总体概述可在混合文档上&lt;/a&gt;。&lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;在此处&lt;/a&gt;阅读Mix源代码。</target>
        </trans-unit>
        <trans-unit id="237778ff123bf6054865096a64c61845e79b8f82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;try/rescue&lt;/code&gt; here. In case you want to handle multiple outcomes of opening a file, you can use pattern matching within the &lt;code&gt;case&lt;/code&gt; construct:</source>
          <target state="translated">这里没有 &lt;code&gt;try/rescue&lt;/code&gt; 。如果要处理打开文件的多种结果，可以在 &lt;code&gt;case&lt;/code&gt; 构造中使用模式匹配：</target>
        </trans-unit>
        <trans-unit id="f0bc74ac50000eb990e97f6493bd512424cfda40" translate="yes" xml:space="preserve">
          <source>There is one important difference between the &lt;code&gt;setup&lt;/code&gt; block we wrote for &lt;code&gt;KV.Registry&lt;/code&gt; and the one we wrote for &lt;code&gt;KV.Bucket&lt;/code&gt;. Instead of starting the registry by hand by calling &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;, we instead called &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;the &lt;code&gt;start_supervised!/2&lt;/code&gt; function&lt;/a&gt;, passing the &lt;code&gt;KV.Registry&lt;/code&gt; module.</source>
          <target state="translated">还有就是之间的一个重要区别 &lt;code&gt;setup&lt;/code&gt; 我们为写块 &lt;code&gt;KV.Registry&lt;/code&gt; 与大家写了一个 &lt;code&gt;KV.Bucket&lt;/code&gt; 。与其通过调用 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 手动启动注册表，我们通过传递 &lt;code&gt;KV.Registry&lt;/code&gt; 模块调用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;了 &lt;code&gt;start_supervised!/2&lt;/code&gt; 函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02df8421114d1f579a4430e4f56430c17c3fdd06" translate="yes" xml:space="preserve">
          <source>There is one project-level option that affects how the escript is generated:</source>
          <target state="translated">有一个项目级的选项会影响脚本的生成方式。</target>
        </trans-unit>
        <trans-unit id="690ca402cdab5a8902f2e2787a305dd6116dc3d0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.</source>
          <target state="translated">GenServer代码中多了不少仪式感,但正如我们将看到的,它也带来了一些好处。</target>
        </trans-unit>
        <trans-unit id="26cfa9d95846d7cc788a552bbc32762f5176596e" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">由于许多Mix任务定义了从此配置读取的自己的选项，因此没有由 &lt;code&gt;project/0&lt;/code&gt; 返回的所有选项的完整列表。例如，查看文档中&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务的&amp;ldquo;配置&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="868c9d3de02a9c397e5804f3e5b1beeb25227226" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">由于许多Mix任务定义了从该配置读取的自己的选项，因此没有由 &lt;code&gt;project/0&lt;/code&gt; 返回的所有选项的完整列表。例如，查看文档中&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务的&amp;ldquo;配置&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="06cb32d59125a8444c6ab67709a472cedf77eb2d" translate="yes" xml:space="preserve">
          <source>There, &lt;code&gt;byte_size/1&lt;/code&gt; counts the underlying raw bytes, and &lt;code&gt;String.length/1&lt;/code&gt; counts characters.</source>
          <target state="translated">在那里， &lt;code&gt;byte_size/1&lt;/code&gt; 计算基础裸字节，而 &lt;code&gt;String.length/1&lt;/code&gt; 计算字符。</target>
        </trans-unit>
        <trans-unit id="4307601f224307e22cd02454aa0b8b4d5545438a" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (e.g. &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;file#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">因此，不能保证在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;退出时调用Terminate &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。由于这些原因，我们通常建议使用监视或链接本身在单独的进程中发生重要的清理规则。当&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;控制 &lt;code&gt;port&lt;/code&gt; （例如 &lt;code&gt;:gen_tcp.socket&lt;/code&gt; ）或&lt;a href=&quot;file#t:io_device/0&quot;&gt; &lt;code&gt;File.io_device/0&lt;/code&gt; 时&lt;/a&gt;，不需要清理，因为它们将在收到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的退出信号时关闭，并且不需要在Terminate &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;手动关闭。。</target>
        </trans-unit>
        <trans-unit id="7f067dca9ef5e27637d0921507ba04af5a01c66e" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (for example, &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">因此，不能保证在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;退出时调用Terminate &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。由于这些原因，我们通常建议使用监视或链接本身在单独的进程中发生重要的清理规则。当&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;控制 &lt;code&gt;port&lt;/code&gt; （例如 &lt;code&gt;:gen_tcp.socket&lt;/code&gt; ）或&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#t:io_device/0&quot;&gt; &lt;code&gt;File.io_device/0&lt;/code&gt; 时&lt;/a&gt;，不需要清理，因为它们将在收到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的退出信号时关闭，并且不需要在&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;手动关闭/ 2。</target>
        </trans-unit>
        <trans-unit id="f4064ff8458c4f5d1958ee9109a3740ff3b2b0e6" translate="yes" xml:space="preserve">
          <source>Therefore, an Elixir developer prefers to &amp;ldquo;let it crash&amp;rdquo; or &amp;ldquo;fail fast&amp;rdquo;. And one of the most common ways we can recover from a failure is by restarting whatever part of the system crashed.</source>
          <target state="translated">因此，Elixir开发人员更喜欢&amp;ldquo;使其崩溃&amp;rdquo;或&amp;ldquo;快速失败&amp;rdquo;。我们可以从故障中恢复的最常见方法之一是重新启动系统崩溃的任何部分。</target>
        </trans-unit>
        <trans-unit id="67da13e4777f268949639e3941225f274f61e540" translate="yes" xml:space="preserve">
          <source>Therefore, if you don&amp;rsquo;t want to handle the error outcomes, prefer using &lt;code&gt;File.read!/1&lt;/code&gt;.</source>
          <target state="translated">因此，如果您不想处理错误结果，请首选使用 &lt;code&gt;File.read!/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ef416d8b169a4f47a3dda56e98187b8d57d742" translate="yes" xml:space="preserve">
          <source>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">因此,如果你打算比较多个字符串,连续多次比较,可以在前期将它们归一化,直接进行比较,避免多次归一化。</target>
        </trans-unit>
        <trans-unit id="5cb2ec194ba3355670294e9c457ea3adb567e875" translate="yes" xml:space="preserve">
          <source>Therefore, in order to minimize the distributed tests, let&amp;rsquo;s pick a routing table that does not require distribution. Then, for the distributed tests, we will programatically change the routing table. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="translated">因此，为了最小化分布式测试，让我们选择一个不需要分布式的路由表。然后，对于分布式测试，我们将以编程方式更改路由表。返回 &lt;code&gt;config/config.exs&lt;/code&gt; ，添加以下行：</target>
        </trans-unit>
        <trans-unit id="5587ebee880284a6f70ef3328784590a49e488e5" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="translated">因此，此功能用于在使用某个模块之前检查是否已加载该模块，并允许其做出相应的反应。例如，&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;模块使用此功能来检查给定URI方案是否存在特定的解析器。</target>
        </trans-unit>
        <trans-unit id="af72f8d5888562059c52cc4bad66a2a3aa2e8b0b" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="translated">因此，此功能用于在使用模块之前检查是否已加载模块，并允许其做出相应的反应。例如，&lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;模块使用此功能来检查给定URI方案是否存在特定的解析器。</target>
        </trans-unit>
        <trans-unit id="de86214129da9f1e44a45df425ff060e9ce48710" translate="yes" xml:space="preserve">
          <source>Therefore, using a combination of &lt;code&gt;--sink&lt;/code&gt; with &lt;code&gt;--label&lt;/code&gt; is useful to find all files that will change once the sink changes, alongside the transitive dependencies that will cause said recompilations.</source>
          <target state="translated">因此，结合使用 &lt;code&gt;--sink&lt;/code&gt; 和 &lt;code&gt;--label&lt;/code&gt; 很有用，以查找一旦接收器发生更改将更改的所有文件，以及将导致所述重新编译的可传递依赖项。</target>
        </trans-unit>
        <trans-unit id="f4b754bf2a64e107bf9d3b99490d4c968dbf741e" translate="yes" xml:space="preserve">
          <source>Therefore, when pattern matching on strings, it is important to use the &lt;code&gt;utf8&lt;/code&gt; modifier:</source>
          <target state="translated">因此，在字符串上进行模式匹配时，使用 &lt;code&gt;utf8&lt;/code&gt; 修饰符很重要：</target>
        </trans-unit>
        <trans-unit id="d10b167c94497dff77b11dad17668b97ba38a48a" translate="yes" xml:space="preserve">
          <source>These are a few options that are not used by just one Mix task (and will thus be documented here):</source>
          <target state="translated">这几个选项并不是只有一个Mix任务才会用到的(因此,这里将对其进行记录)。</target>
        </trans-unit>
        <trans-unit id="41d198d3d66dfd7fa75bf909de01737698c3fc91" translate="yes" xml:space="preserve">
          <source>These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:</source>
          <target state="translated">这些是Elixir语言中的保留词汇。本指南中对它们进行了详细介绍,但为了方便起见,在此进行了总结。</target>
        </trans-unit>
        <trans-unit id="c6ad74fbcf6aea4c5436fcd89c622233b6bfb3f0" translate="yes" xml:space="preserve">
          <source>These building blocks are defined in this module. Some of these special forms are lexical (such as &lt;a href=&quot;#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;). The macros &lt;a href=&quot;#%7B%7D/1&quot;&gt;&lt;code&gt;{}/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; are also special forms used to define tuple and binary data structures respectively.</source>
          <target state="translated">这些模块在此模块中定义。这些特殊形式中的一些是词汇形式的（例如&lt;a href=&quot;#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt;）。宏&lt;a href=&quot;#%7B%7D/1&quot;&gt; &lt;code&gt;{}/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt;也是分别用于定义元组和二进制数据结构的特殊形式。</target>
        </trans-unit>
        <trans-unit id="26cd6bcff6d81ebade774a0f501e5b9a49a3141c" translate="yes" xml:space="preserve">
          <source>These can be used anywhere you want to refer to a characters codepoint.</source>
          <target state="translated">这些可以用在任何你想引用一个字符代码点的地方。</target>
        </trans-unit>
        <trans-unit id="c01193dcf91e904667491de473d13c72e0b284bc" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned that the following syntax is supported:</source>
          <target state="translated">这些特征是提示关键字列表成为将选项传递给Elixir中的函数的默认机制的原因。在第5章中，当我们讨论 &lt;code&gt;if/2&lt;/code&gt; 宏时，我们提到支持以下语法：</target>
        </trans-unit>
        <trans-unit id="a33f02a3cf972439fc9644228266bf6ac583f283" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned the following syntax is supported:</source>
          <target state="translated">这些特征是提示关键字列表成为将选项传递给Elixir中的函数的默认机制的原因。在第5章中，当我们讨论 &lt;code&gt;if/2&lt;/code&gt; 宏时，我们提到了支持以下语法：</target>
        </trans-unit>
        <trans-unit id="8fea9325510bd25065ba64a7fe2de349a02f06d3" translate="yes" xml:space="preserve">
          <source>These configurations can be set in the &lt;code&gt;def project&lt;/code&gt; section of your &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">可以在 &lt;code&gt;mix.exs&lt;/code&gt; 的 &lt;code&gt;def project&lt;/code&gt; 部分中设置这些配置：</target>
        </trans-unit>
        <trans-unit id="76567fa6ed57b5e28a73659cbd673c9a7f350853" translate="yes" xml:space="preserve">
          <source>These functions and macros follow the Erlang convention of an &lt;code&gt;is_&lt;/code&gt; prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.</source>
          <target state="translated">这些函数和宏遵循 &lt;code&gt;is_&lt;/code&gt; 前缀的Erlang约定，而不是尾随的问号，以精确地指示在保护子句中允许使用它们。</target>
        </trans-unit>
        <trans-unit id="add5b2dbfbafe6da3d0a22b6f870b2eed75d677f" translate="yes" xml:space="preserve">
          <source>These options are expected to be literals (including the binary values) at compile time.</source>
          <target state="translated">在编译时,这些选项应该是 literals(包括二进制值)。</target>
        </trans-unit>
        <trans-unit id="2ec1191cd2717326d5b2f8e25c4fb58ff593d194" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's Code Server.</source>
          <target state="translated">这些选项是全局性的,因为它们是由Elixir的Code Server存储的。</target>
        </trans-unit>
        <trans-unit id="626e3d5b2ff83140a65abc0074ea71a000293b27" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's code server.</source>
          <target state="translated">这些选项是全局的,因为它们由Elixir的代码服务器存储。</target>
        </trans-unit>
        <trans-unit id="8aca497f05ede32d92fad7a0a08861307fed5d02" translate="yes" xml:space="preserve">
          <source>These paths are based on the &lt;code&gt;:apps_path&lt;/code&gt; and &lt;code&gt;:apps&lt;/code&gt; configurations.</source>
          <target state="translated">这些路径基于 &lt;code&gt;:apps_path&lt;/code&gt; 和 &lt;code&gt;:apps&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="90f90a0bd1abd66881352917a593420e21df4638" translate="yes" xml:space="preserve">
          <source>They also support &lt;code&gt;else&lt;/code&gt; blocks:</source>
          <target state="translated">它们还支持 &lt;code&gt;else&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="c272e830fb2eeca6af73d25f9dc7ec1a9ffc0efc" translate="yes" xml:space="preserve">
          <source>They are discussed individually in the sections below.</source>
          <target state="translated">以下各节将分别讨论这些问题。</target>
        </trans-unit>
        <trans-unit id="d328fd2e41813b144fcdf9de5a1a99985a2c6ade" translate="yes" xml:space="preserve">
          <source>They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">它们通常用于列举不同的值,例如:</target>
        </trans-unit>
        <trans-unit id="d984bcb0628847679167196f524ecb516b6c251c" translate="yes" xml:space="preserve">
          <source>They serve to annotate the module, often with information to be used by the user or the</source>
          <target state="translated">它们的作用是对模块进行注解,通常是提供用户或企业使用的信息。</target>
        </trans-unit>
        <trans-unit id="97ca407460ebb22e0ec5bdeff0b3e028c669bf37" translate="yes" xml:space="preserve">
          <source>They work as a temporary module storage to be used during compilation.</source>
          <target state="translated">它们作为临时模块存储,在编译过程中使用。</target>
        </trans-unit>
        <trans-unit id="ee6dd5d64b66e821ff94c4d17d21b9f93db749f2" translate="yes" xml:space="preserve">
          <source>They work as constants.</source>
          <target state="translated">它们作为常量工作。</target>
        </trans-unit>
        <trans-unit id="e53339d9d0bc53c58fe8778d10ade8bb49736f46" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang Syntax: A Crash Course&lt;/a&gt; provides a concise intro to Erlang&amp;rsquo;s syntax. Each code snippet is accompanied by equivalent code in Elixir. This is an opportunity for you to not only get some exposure to Erlang&amp;rsquo;s syntax but also review some of the things you have learned in this guide.</source>
          <target state="translated">本《&lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang语法：速成班》&lt;/a&gt;简要介绍了Erlang的语法。每个代码段均随附Elixir中的等效代码。这是一个机会，您不仅可以了解Erlang的语法，还可以查看本指南中学到的一些知识。</target>
        </trans-unit>
        <trans-unit id="c3d65d16574f84519ba2e69aa0d37e68059885e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值（如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;nil&lt;/code&gt; ），并且必须返回一个包含两个元素的元组：&amp;ldquo; get&amp;rdquo;值（检索到的值，可以在返回之前对其进行操作），并将新值存放在 &lt;code&gt;key&lt;/code&gt; 下。该 &lt;code&gt;fun&lt;/code&gt; 也可能返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值应从关键字列表中删除并返回。</target>
        </trans-unit>
        <trans-unit id="7730fb9921d8f6aa0bc9c8111d351054831c02de" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值（如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;nil&lt;/code&gt; ），并且必须返回一个由两个元素组成的元组：当前值（检索到的值，可以在返回之前对其进行操作）以及要存储的新值在 &lt;code&gt;key&lt;/code&gt; 下。该 &lt;code&gt;fun&lt;/code&gt; 也可能返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值应从关键字列表中删除并返回。</target>
        </trans-unit>
        <trans-unit id="21531bdd28fd8a4fab193e8f907a1304804427e8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值，并且必须返回一个包含两个元素的元组：&amp;ldquo; get&amp;rdquo;值（获取的值，可以在返回之前对其进行操作）和要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值。</target>
        </trans-unit>
        <trans-unit id="53bda49c2b15fa76b2cbd3fb19123910db00ced4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值，并且必须返回一个由两个元素组成的元组：当前值（获取的值，可以在返回之前对其进行操作）以及要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值。</target>
        </trans-unit>
        <trans-unit id="106724662d1a48acf5e96ebf33c77969eed35e72" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="translated">该建议不仅适用于库，还适用于任何Elixir代码。每次收到多个选项或使用外部数据时，都应在边界处验证数据并将其转换为结构化数据。例如，如果您提供可以通过多个选项启动的&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则希望在服务器启动时验证这些选项，并且仅在整个流程生命周期中依赖结构化数据。同样，如果数据库或套接字为您提供了字符串映射，则在接收到数据后，您应该对其进行验证，并有可能将其转换为结构或原子映射。</target>
        </trans-unit>
        <trans-unit id="1ca51ca3cb9bf6182cc66703ef3fbbdd192c7934" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="translated">该建议不仅适用于库，还适用于任何Elixir代码。每次收到多个选项或使用外部数据时，都应在边界处验证数据并将其转换为结构化数据。例如，如果您提供可以通过多个选项启动的&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则希望在服务器启动时验证这些选项，并且仅在整个流程生命周期中依赖结构化数据。同样，如果数据库或套接字为您提供了字符串映射，则在接收到数据之后，您应该对其进行验证，并有可能将其转换为结构或原子映射。</target>
        </trans-unit>
        <trans-unit id="38b51c7863a18d9dea71afde173bd863c4339d77" translate="yes" xml:space="preserve">
          <source>This also works with nested structs and the &lt;code&gt;struct.path.to.value&lt;/code&gt; way to specify paths:</source>
          <target state="translated">这也适用于嵌套结构和 &lt;code&gt;struct.path.to.value&lt;/code&gt; 方法来指定路径：</target>
        </trans-unit>
        <trans-unit id="35f4524e9d598f3528101bd75ddd379bcc553a48" translate="yes" xml:space="preserve">
          <source>This approach has one big limitation: if you change the value of the application environment after the code is compiled, the value used at runtime is not going to change! For example, if your &lt;code&gt;config/runtime.exs&lt;/code&gt; has:</source>
          <target state="translated">这种方法有一个很大的局限性：如果在编译代码后更改应用程序环境的值，则运行时使用的值不会改变！例如，如果您的 &lt;code&gt;config/runtime.exs&lt;/code&gt; 具有：</target>
        </trans-unit>
        <trans-unit id="0cc4748ce3f5882d3817d17380c6efaea1cbe2e2" translate="yes" xml:space="preserve">
          <source>This behaviour function checks out dependencies.</source>
          <target state="translated">这个行为函数可以检查出依赖关系。</target>
        </trans-unit>
        <trans-unit id="8063234c54496c74deb524505ab53e03e89b8cac" translate="yes" xml:space="preserve">
          <source>This behaviour function checks the status of the lock. In particular, it checks if the revision stored in the lock is the same as the repository it is currently in.</source>
          <target state="translated">这个行为函数检查锁的状态。特别是,它检查存储在锁中的版本是否与当前所在的版本库相同。</target>
        </trans-unit>
        <trans-unit id="d1a9f92cb4e97a9d75cd6dadc068bea5309a11a2" translate="yes" xml:space="preserve">
          <source>This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency</source>
          <target state="translated">此行为功能接收 &lt;code&gt;opts&lt;/code&gt; 的关键字列表，并应返回更新的列表，以防SCM使用可用的选项。例如，当开发人员指定依赖项时</target>
        </trans-unit>
        <trans-unit id="5b3cf369974ea57c7d2b5f2b67a09ff6bb9cb520" translate="yes" xml:space="preserve">
          <source>This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency:</source>
          <target state="translated">此行为功能接收 &lt;code&gt;opts&lt;/code&gt; 的关键字列表，并应返回更新的列表，以防SCM使用可用的选项。例如，当开发人员指定依赖项时：</target>
        </trans-unit>
        <trans-unit id="3e3e7ef108fbc0b5b099888c738ff953bc262988" translate="yes" xml:space="preserve">
          <source>This behaviour function returns a boolean if the dependency is available.</source>
          <target state="translated">如果依赖关系可用,该行为函数返回一个布尔值。</target>
        </trans-unit>
        <trans-unit id="0b4620b1a57c643e178ccb4b09127ceadcd467a0" translate="yes" xml:space="preserve">
          <source>This behaviour function updates dependencies. It may be called by &lt;code&gt;deps.get&lt;/code&gt; or &lt;code&gt;deps.update&lt;/code&gt;.</source>
          <target state="translated">此行为函数更新依赖关系。它可以被 &lt;code&gt;deps.get&lt;/code&gt; 或 &lt;code&gt;deps.update&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="c86b0384c6fa0ab23e023705951a2e26ece47398" translate="yes" xml:space="preserve">
          <source>This behaviour is deprecated. Use Erlang/OTP's :gen_event module instead.</source>
          <target state="translated">这种行为已经被废弃了,请使用Erlang/OTP的:gen_event模块。使用 Erlang/OTP 的 :gen_event 模块代替。</target>
        </trans-unit>
        <trans-unit id="72f035035b3d70bcbf1171738b7f8c7d508d05aa" translate="yes" xml:space="preserve">
          <source>This behaviour is relied on in many different places. For example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;exit(:shutdown)&lt;/code&gt; when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.</source>
          <target state="translated">在许多不同的地方都依赖此行为。例如，&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;在退出测试过程时使用 &lt;code&gt;exit(:shutdown)&lt;/code&gt; 来向链接的过程，监督树等发出信号，从而也有礼貌地关闭。</target>
        </trans-unit>
        <trans-unit id="c8eb2df7e5f6ba76a64892942e28c56d4c4a7f04" translate="yes" xml:space="preserve">
          <source>This break can be rendered as a linebreak or as the given &lt;code&gt;string&lt;/code&gt;, depending on the &lt;code&gt;mode&lt;/code&gt; of the chosen layout.</source>
          <target state="translated">此中断可以呈现为换行符或给定的 &lt;code&gt;string&lt;/code&gt; ，具体取决于所选布局的 &lt;code&gt;mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7ad5339c141f0de9e312dc2f25b5df3e7d8cb4" translate="yes" xml:space="preserve">
          <source>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt;, the macro will receive the AST representing the &lt;code&gt;self()&lt;/code&gt; call, and not the PID itself.</source>
          <target state="translated">因为宏从不接收PID，所以永远不会达到此断点。即使您将宏调用为 &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt; ，该宏也会收到表示 &lt;code&gt;self()&lt;/code&gt; 调用的AST ，而不是PID本身。</target>
        </trans-unit>
        <trans-unit id="8761ea35931ac08c3f3679fbf6f993fa3ef09746" translate="yes" xml:space="preserve">
          <source>This calendar implements the proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.</source>
          <target state="translated">该日历采用的是格里高利历,因此与当今大多数国家使用的日历兼容。闰年意味着格里高利历的闰年规则适用于所有时间,因此,1583年之前的日期与采用格里高利历的日期有不同的结果。</target>
        </trans-unit>
        <trans-unit id="7991ee0aa425c7d3f3afff7118c6225869810d3f" translate="yes" xml:space="preserve">
          <source>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</source>
          <target state="translated">此调用将设置一个停止一次的断点。要设置一个停止10次的断点。</target>
        </trans-unit>
        <trans-unit id="b325289ad4384d9c3ff3e14f0e004ec0fadc1690" translate="yes" xml:space="preserve">
          <source>This callback can be useful to control the &lt;em&gt;appearance&lt;/em&gt; of the status of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. For example, it can be used to return a compact representation of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s state to avoid having large state terms printed.</source>
          <target state="translated">此回调对于控制&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;状态的&lt;em&gt;外观&lt;/em&gt;很有用。例如，它可以用于返回&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;状态的紧凑表示形式，以避免打印大的状态项。</target>
        </trans-unit>
        <trans-unit id="1327f9cbc59e218b07255d5dfd814547d5d8807b" translate="yes" xml:space="preserve">
          <source>This callback is only supported on Erlang/OTP 21+.</source>
          <target state="translated">这个回调只在Erlang/OTP 21+上支持。</target>
        </trans-unit>
        <trans-unit id="ee5f243ca65efd502d5c4c6af5c8cd9dfd5d476c" translate="yes" xml:space="preserve">
          <source>This callback is optional.</source>
          <target state="translated">这个回调是可选的。</target>
        </trans-unit>
        <trans-unit id="f2424dc84d136b7783611865075888a14d9c990b" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the received message will be logged.</source>
          <target state="translated">这个回调是可选的。如果没有实现,收到的消息将被记录。</target>
        </trans-unit>
        <trans-unit id="985bade6a0d966231f4d34d8934365d5ebe8193e" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a call is performed against it.</source>
          <target state="translated">这个回调是可选的。如果没有实现这个回调,如果对它进行调用,服务器将失败。</target>
        </trans-unit>
        <trans-unit id="f84f9f7a0fb58e5af47a01d8f797b8c62ea95537" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.</source>
          <target state="translated">这个回调是可选的。如果没有实现这个回调,如果服务器对它进行投射,就会失败。</target>
        </trans-unit>
        <trans-unit id="5a8f931c4cb12fef7b434a37af006aef2ba0d46a" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.</source>
          <target state="translated">这个回调是可选的。如果没有实现,如果使用了继续指令,服务器将失败。</target>
        </trans-unit>
        <trans-unit id="ddfd8ff82f8cdfbfeb3d06aa0134b83f46048ef4" translate="yes" xml:space="preserve">
          <source>This can be added to any custom engine by invoking &lt;a href=&quot;#handle_assign/1&quot;&gt;&lt;code&gt;handle_assign/1&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以通过使用&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;#handle_assign/1&quot;&gt; &lt;code&gt;handle_assign/1&lt;/code&gt; &lt;/a&gt;将其添加到任何自定义引擎中：</target>
        </trans-unit>
        <trans-unit id="9a48050cb80bb5c2bc634b01accf3b4f5bd8c332" translate="yes" xml:space="preserve">
          <source>This chapter is a quick introduction to input/output mechanisms and file-system-related tasks, as well as to related modules like &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本章是对输入/输出机制和文件系统相关任务以及&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;等相关模块的快速介绍。</target>
        </trans-unit>
        <trans-unit id="3b602041d24e676175f7fd300fe9987bf2555172" translate="yes" xml:space="preserve">
          <source>This chapter is part of the</source>
          <target state="translated">这一章是 &quot;中国梦 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="d39494a06027e3ecee2968740895a5b78940cdae" translate="yes" xml:space="preserve">
          <source>This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.</source>
          <target state="translated">这将检查存储在正则表达式中的版本,并在版本不匹配的情况下重新编译regex。</target>
        </trans-unit>
        <trans-unit id="9ba63be17004fe209fc861513a8577afc4eb4889" translate="yes" xml:space="preserve">
          <source>This code counts the number of files in a ZIP file:</source>
          <target state="translated">该代码计算ZIP文件中的文件数量。</target>
        </trans-unit>
        <trans-unit id="b9d6dcf55f45221cfb511f9790e81d0872563106" translate="yes" xml:space="preserve">
          <source>This code generates a warning letting you know that you are mistakenly implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;. You can read more about &lt;code&gt;@impl&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;module documentation&lt;/a&gt;.</source>
          <target state="translated">此代码会生成警告，让您知道您错误地实现了 &lt;code&gt;parse/0&lt;/code&gt; 而不是 &lt;code&gt;parse/1&lt;/code&gt; 。您可以在&lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;模块文档中&lt;/a&gt;阅读有关 &lt;code&gt;@impl&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="7461ed387e3c81526760cfc0eb288d63eeb1988f" translate="yes" xml:space="preserve">
          <source>This command deletes all build artifacts for the current project. Dependencies' sources and build files are cleaned only if the &lt;code&gt;--deps&lt;/code&gt; option is given.</source>
          <target state="translated">此命令删除当前项目的所有构建工件。仅在指定了 &lt;code&gt;--deps&lt;/code&gt; 选项的情况下，才会清除依赖项的源文件和构建文件。</target>
        </trans-unit>
        <trans-unit id="8e27e95f38d4b57c9fdf5d7529c98e07460e6cfe" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="translated">该命令仅在通过&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;手动启动的撬会话或通过&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;设置的断点内起作用。在常规&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt;会话期间调用此函数将打印错误。</target>
        </trans-unit>
        <trans-unit id="f03f46afb53748c93f12e42d7a94c9567ade9ff8" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;iex&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="translated">该命令仅在通过&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;手动启动的撬会话或通过&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;设置的断点内起作用。在常规&lt;a href=&quot;iex&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt;会话期间调用此函数将打印错误。</target>
        </trans-unit>
        <trans-unit id="9a69791b2bccfac2d2c8e3aaab714d3c02736c70" translate="yes" xml:space="preserve">
          <source>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</source>
          <target state="translated">我们对Elixir中关联数据结构的介绍到此结束。你会发现,只要给定关键字列表和映射,你总会有合适的工具来解决Elixir中需要关联数据结构的问题。</target>
        </trans-unit>
        <trans-unit id="16f934bff72f27aaf7d700d67cebd5f253fc677d" translate="yes" xml:space="preserve">
          <source>This concludes our optimization chapter. We have used ETS as a cache mechanism where reads can happen from any processes but writes are still serialized through a single process. More importantly, we have also learned that once data can be read asynchronously, we need to be aware of the race conditions it might introduce.</source>
          <target state="translated">我们的优化章节到此结束。我们将ETS作为一种缓存机制,读取可以发生在任何进程中,但写入仍然是通过单一进程串行化的。更重要的是,我们还了解到,一旦数据可以异步读取,我们需要注意它可能引入的竞赛条件。</target>
        </trans-unit>
        <trans-unit id="5688f14ee7763837295cf0cfb6c3645fbb0e591b" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="translated">可以使用&lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt;读取此配置。注意，如果未定义项目，&lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;config/0&lt;/code&gt; &lt;/a&gt;不会失败；这使许多Mix任务无需项目即可工作。</target>
        </trans-unit>
        <trans-unit id="e537b568fbfe0eb80dc56346fdc7829c98d99600" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="translated">可以使用&lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt;读取此配置。请注意，如果未定义项目，则&lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;config/0&lt;/code&gt; &lt;/a&gt;不会失败；这使许多Mix任务无需项目即可工作。</target>
        </trans-unit>
        <trans-unit id="a6e1f3335434ce7c6c1db9f585fc250ca17087fe" translate="yes" xml:space="preserve">
          <source>This configuration is split in three categories:</source>
          <target state="translated">这种配置分为三类。</target>
        </trans-unit>
        <trans-unit id="50abf55bb08a41598a90aba43d936a7f680d70a0" translate="yes" xml:space="preserve">
          <source>This configures a routing table that always points to the current node. Now remove &lt;code&gt;@tag :distributed&lt;/code&gt; from the test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; and run the suite, the test should now pass.</source>
          <target state="translated">这将配置一个始终指向当前节点的路由表。现在，从 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 中的测试中删除 &lt;code&gt;@tag :distributed&lt;/code&gt; ，并运行套件，测试现在应该通过了。</target>
        </trans-unit>
        <trans-unit id="300ecf84b2025cc5045f1e2f3e97de582fbc3fe7" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by checking equality instead, like &lt;code&gt;val == %{}&lt;/code&gt;.</source>
          <target state="translated">可以通过确保不引发异常来纠正此问题，可以通过 &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt; 类的类型检查，或者通过检查 &lt;code&gt;val == %{}&lt;/code&gt; 类的相等性来进行纠正。</target>
        </trans-unit>
        <trans-unit id="d60706226e387d43664cfb1abdf069dc132f410b" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">可以通过确保没有引发异常来纠正此问题，可以通过 &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt; 类的类型检查，也可以通过使用多个防护措施，这样，如果异常导致一个防护措施失败，则下一个防护措施将失败被评估。</target>
        </trans-unit>
        <trans-unit id="9c9bc7bb0b19c22166e70549a7bdc2d167883d30" translate="yes" xml:space="preserve">
          <source>This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</source>
          <target state="translated">这个日期时间可以被看作是一个特定时区的日期时间的短暂快照。为此,它还包括UTC和标准偏移量,以及专门用于格式化目的的区域缩写字段。</target>
        </trans-unit>
        <trans-unit id="025523ae9891a8ad2cd843de98bd87706ff12c27" translate="yes" xml:space="preserve">
          <source>This day fraction should be in its most simplified form possible, to make comparisons fast.</source>
          <target state="translated">这个日分数应该是最简化的形式,以便快速比较。</target>
        </trans-unit>
        <trans-unit id="99d3f98fe052dbacd8470e76a4e43e20ad18ae6f" translate="yes" xml:space="preserve">
          <source>This default can be overridden by &lt;code&gt;@tag capture_log: false&lt;/code&gt; or &lt;code&gt;@moduletag capture_log: false&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;@tag capture_log: false&lt;/code&gt; 或 &lt;code&gt;@moduletag capture_log: false&lt;/code&gt; 覆盖此默认值。</target>
        </trans-unit>
        <trans-unit id="dc33441b7a8711ad3ca32a6f565dfd02fa511842" translate="yes" xml:space="preserve">
          <source>This dependency refers to the latest version of Plug in the 1.x.x version series that has been pushed to Hex. This is indicated by the &lt;code&gt;~&amp;gt;&lt;/code&gt; preceding the version number. For more information on specifying version requirements, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;documentation for the Version module&lt;/a&gt;.</source>
          <target state="translated">此依赖性是指已推入十六进制的1.xx版本系列中插件的最新版本。版本号前面的 &lt;code&gt;~&amp;gt;&lt;/code&gt; 表示。有关指定版本要求的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;Version模块&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b6c49f1989fcd795b139792169130547ab503617" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="translated">这种设计是有意的。&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;旨在支持无限集合，资源和其他形状固定的结构。例如，将值插入范围是没有意义的，因为它具有固定的形状，仅存储范围限制。</target>
        </trans-unit>
        <trans-unit id="6e5cd48930bfba2e7e8edb59d564ea07b6d9edb0" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="translated">这种设计是有意的。&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;旨在支持无限集合，资源和其他形状固定的结构。例如，将值插入范围是没有意义的，因为它具有固定的形状，仅存储范围限制。</target>
        </trans-unit>
        <trans-unit id="7534091aa8dce080c878d8bf8e2b8c4a424f0e53" translate="yes" xml:space="preserve">
          <source>This difference is exclusive, so the test will fail if the difference and the delta are equal.</source>
          <target state="translated">这个差值是排他性的,所以如果差值和delta相等,测试就会失败。</target>
        </trans-unit>
        <trans-unit id="2dd776fd236b4c910c6f960d04bcbda080e07c54" translate="yes" xml:space="preserve">
          <source>This difference is inclusive, so the test will pass if the difference and the &lt;code&gt;delta&lt;/code&gt; are equal.</source>
          <target state="translated">此差异是包含性的，因此，如果差异和 &lt;code&gt;delta&lt;/code&gt; 相等，则测试将通过。</target>
        </trans-unit>
        <trans-unit id="98215fb8db656d563463f8fe38acbb92d7848ad1" translate="yes" xml:space="preserve">
          <source>This distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:</source>
          <target state="translated">这种区分很重要。如果有昂贵的操作要做,你必须考虑是在客户端还是在服务器上执行这些操作更好。例如:</target>
        </trans-unit>
        <trans-unit id="df29062cd643c03ef91e3b2f35c7d26d81006829" translate="yes" xml:space="preserve">
          <source>This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.</source>
          <target state="translated">本文档涵盖了所有的Elixir语法结构作为参考,然后讨论它们的确切AST表示。</target>
        </trans-unit>
        <trans-unit id="5ca6dcbf01e5b678fc80bf68968384a6697f2309" translate="yes" xml:space="preserve">
          <source>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</source>
          <target state="translated">本文档涵盖了Elixir中的操作符,它们是如何被解析的,如何被定义的,以及如何被覆盖的。</target>
        </trans-unit>
        <trans-unit id="76b6d6a8fc49e94c927ef5f992d5906c281ba114" translate="yes" xml:space="preserve">
          <source>This document covers some naming conventions in Elixir code, from casing to punctuation characters.</source>
          <target state="translated">本文档介绍了Elixir代码中的一些命名惯例,从套管到标点符号。</target>
        </trans-unit>
        <trans-unit id="e522e86f1169f55700b99174079a5a7fddfa90ed" translate="yes" xml:space="preserve">
          <source>This document defines the commonly used base 16, base 32, and base 64 encoding schemes.</source>
          <target state="translated">本文档定义了常用的基数16、基数32和基数64编码方案。</target>
        </trans-unit>
        <trans-unit id="d8780e3a54cb0fb8d842fe0203eab3683b262d16" translate="yes" xml:space="preserve">
          <source>This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.</source>
          <target state="translated">本文档为那些编写和发布供其他开发者使用的Elixir库的人概述了一般指南、反模式和规则。</target>
        </trans-unit>
        <trans-unit id="7635e286607ededea5965d1544a7717ea9ae091d" translate="yes" xml:space="preserve">
          <source>This document provides a reference to Elixir syntax, exploring its constructs and their AST equivalents.</source>
          <target state="translated">本文档提供了Elixir语法的参考,探讨了其构造及其AST等价物。</target>
        </trans-unit>
        <trans-unit id="36fa202c6f9b610fe0535f0fc2890016238cbe23" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本文档涉及为您自己的数据结构实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议。要了解有关使用检查的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/2&quot;&gt; &lt;code&gt;Kernel.inspect/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb11a86f08fe1f7ebc5f36609a52188a6715fc6d" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;kernel#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本文档涉及为您自己的数据结构实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议。要了解有关使用检查的更多信息，请参见&lt;a href=&quot;kernel#inspect/2&quot;&gt; &lt;code&gt;Kernel.inspect/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eb21e9b605b4017af593e4546f378df0b372b6e" translate="yes" xml:space="preserve">
          <source>This effectively loads the non-instrumented version of currently instrumented modules into memory.</source>
          <target state="translated">这将有效地把当前仪器化模块的非仪器化版本加载到内存中。</target>
        </trans-unit>
        <trans-unit id="1e8dce1c252882c1cf04fa14931f6945bcc1320f" translate="yes" xml:space="preserve">
          <source>This effectively loads the non-instrumented version of the module into memory.</source>
          <target state="translated">这将有效地把模块的非指令版本加载到内存中。</target>
        </trans-unit>
        <trans-unit id="1c15107405a954dcb039847f9ffc0e90a3a08175" translate="yes" xml:space="preserve">
          <source>This example shows how to get everything from the registry.</source>
          <target state="translated">这个例子展示了如何从注册表中获取一切。</target>
        </trans-unit>
        <trans-unit id="370c43dc94083c1b83066d682a8c408a4aa46d4b" translate="yes" xml:space="preserve">
          <source>This feature is considered experimental and may change in future releases.</source>
          <target state="translated">此功能被认为是试验性的,可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="91e35a46b080fba070b1bb9706d962577f541321" translate="yes" xml:space="preserve">
          <source>This file can be compiled using &lt;code&gt;elixirc&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;elixirc&lt;/code&gt; 编译该文件：</target>
        </trans-unit>
        <trans-unit id="b21275a067c181042b1ef479348b07d28e434640" translate="yes" xml:space="preserve">
          <source>This file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application &lt;code&gt;version&lt;/code&gt;, all the modules defined by it, as well as a list of applications we depend on, like Erlang&amp;rsquo;s &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; itself, and &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">该文件包含Erlang术语（使用Erlang语法编写）。即使我们不熟悉Erlang，也很容易猜出此文件包含我们的应用程序定义。它包含我们的应用程序 &lt;code&gt;version&lt;/code&gt; ，由它定义的所有模块，以及我们依赖的应用程序列表，例如Erlang的 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;elixir&lt;/code&gt; 本身和 &lt;code&gt;logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3fde4ae93a3daf8d4be0e8acc8e91d708da691b" translate="yes" xml:space="preserve">
          <source>This file will be executed whenever your Mix project or your release starts.</source>
          <target state="translated">每当您的Mix项目或您的发布开始时,这个文件就会被执行。</target>
        </trans-unit>
        <trans-unit id="d4e5090203b164b7b8cda10cfcc22848f5f4e098" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">每次运行测试之前，Mix都会需要此文件。我们可以使用 &lt;code&gt;mix test&lt;/code&gt; 运行测试：</target>
        </trans-unit>
        <trans-unit id="7951ed44572734ba9901e12d5c5112665c200cb8" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with:</source>
          <target state="translated">在我们每次运行测试之前,Mix都需要这个文件。我们可以用以下方法运行测试</target>
        </trans-unit>
        <trans-unit id="5c84c085804b613daf8adcad4e1c5bc2c3c89312" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;rescue&lt;/code&gt;. You will find they are used less frequently in Elixir than in other languages, although they may be handy in some situations where a library or some particular code is not playing &amp;ldquo;by the rules&amp;rdquo;.</source>
          <target state="translated">至此，我们完成了对 &lt;code&gt;try&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;rescue&lt;/code&gt; 。您会发现在Elixir中使用它们的频率比在其他语言中要低，尽管在某些情况下，如果库或某些特定代码未按&amp;ldquo;规则&amp;rdquo;播放，它们可能会很方便。</target>
        </trans-unit>
        <trans-unit id="5e21f5a627b95129ae5af664e7fd87944d88dfd3" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs.</source>
          <target state="translated">我们对模式匹配的介绍到此结束。我们将在下一章中看到,模式匹配在许多语言结构中非常常见。</target>
        </trans-unit>
        <trans-unit id="8a8c048ae2840f3778becb01897e7dcb0a936037" translate="yes" xml:space="preserve">
          <source>This finishes our short introduction to modules. In the next chapters, we will learn how to use named functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules and discuss module attributes.</source>
          <target state="translated">我们对模块的简短介绍到此结束。在接下来的章节中,我们将学习如何使用命名函数进行递归,探索可用于从其他模块导入函数的Elixir词汇指令,并讨论模块属性。</target>
        </trans-unit>
        <trans-unit id="d37728bdb738ca01b9639cfc5853b77bca6e2f31" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about four Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="translated">至此，我们完成了IO设备和IO相关功能的介绍。我们已经学会了大约四个药剂模块- &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; 的&lt;/a&gt; -以及如何</target>
        </trans-unit>
        <trans-unit id="38be33edc941fc8a3ad680d80133cb5df88f95ae" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about three Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="translated">至此，我们完成了IO设备和IO相关功能的介绍。我们已经了解了三个Elixir模块&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; -&lt;/a&gt;以及如何</target>
        </trans-unit>
        <trans-unit id="8c32849fe51611a16560a9bffff17dd6edd351d8" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="translated">此函数接受任何至少包含与&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;结构相同字段的映射或结构。最常见的示例是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。在这种情况下，有关该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;时区的信息将被完全忽略。这与将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;传递到&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; 的&lt;/a&gt;原理相同。&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt;仅提取给定结构的特定于日期的字段（日历，年，月和日），而忽略所有其他字段。</target>
        </trans-unit>
        <trans-unit id="4be537303d97003eb7a277c4a7ca1256fe24cb96" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="translated">此函数接受任何至少包含与&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;结构相同的字段的映射或结构。最常见的示例是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。在这种情况下，有关该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;时区的信息将被完全忽略。这与将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;传递到&lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; 的&lt;/a&gt;原理相同。&lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt;仅提取给定结构的特定于日期的字段（日历，年，月和日），而忽略所有其他字段。</target>
        </trans-unit>
        <trans-unit id="5bf6aff9caccdb3a64ed2f33e59b9d34b47e60ba" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="translated">该函数接受的 &lt;code&gt;number&lt;/code&gt; 根据所测&lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;。时间以与给定的日历相同的日历返回。</target>
        </trans-unit>
        <trans-unit id="3e2dd6bd7df969320413c030c37f5eb3baf88d93" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="translated">此函数接受根据&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;测量的 &lt;code&gt;number&lt;/code&gt; 。时间以与给定的日历相同的日历返回。</target>
        </trans-unit>
        <trans-unit id="e2a89e508cd312bb2a9827f189a0607424832acb" translate="yes" xml:space="preserve">
          <source>This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call):</source>
          <target state="translated">该函数接受以下选项,这些选项相互排斥(即在同一调用中只能使用其中一个)。</target>
        </trans-unit>
        <trans-unit id="01d34bc3e6a8b2f03537e43d3d5e42ba54d0dddb" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped.</source>
          <target state="translated">此函数还接受 &lt;code&gt;predicate&lt;/code&gt; 函数作为可选参数。如果传递了此函数，则将使用 &lt;code&gt;string&lt;/code&gt; 每个字节作为参数调用此函数，如果给定的字节应保留原样，则应返回真实值（除 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 以外的任何值），或者返回虚假值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）。是否应该转义字符。</target>
        </trans-unit>
        <trans-unit id="bc20380be19f829ddb16dcf0ed86935745a4613d" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped. Defaults to &lt;a href=&quot;#char_unescaped?/1&quot;&gt;&lt;code&gt;URI.char_unescaped?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数还接受 &lt;code&gt;predicate&lt;/code&gt; 函数作为可选参数。如果传递了此函数，则将使用 &lt;code&gt;string&lt;/code&gt; 每个字节作为其参数来调用此函数，并且如果给定的字节应保留原样，则应返回真实值（除 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 以外的任何值），或者返回虚假值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）。是否应该转义字符。默认为&lt;a href=&quot;#char_unescaped?/1&quot;&gt; &lt;code&gt;URI.char_unescaped?/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95e711242672aeb8dcafbe40b2392be2c750c645" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="translated">如果 &lt;code&gt;pattern&lt;/code&gt; 是正则表达式，则此函数还接受&lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt;接受的所有选项。</target>
        </trans-unit>
        <trans-unit id="b98eb6f021aa33018c50a97a2ae82859d4b9d5d9" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="translated">如果 &lt;code&gt;pattern&lt;/code&gt; 是正则表达式，则此函数还接受&lt;a href=&quot;regex#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt;接受的所有选项。</target>
        </trans-unit>
        <trans-unit id="ac6f41672cc7456ee783ae52a0830c9c41b7db86" translate="yes" xml:space="preserve">
          <source>This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">此功能还通知编译器打印警告（如果启用了--warnings-as-errors）。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f335fe1ab0a202ff3768395fb418ab92d63c45f8" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt; regardless of whether the destination &lt;code&gt;server&lt;/code&gt; (or node) exists. Therefore it is unknown whether the destination &lt;code&gt;server&lt;/code&gt; successfully handled the message.</source>
          <target state="translated">无论目标 &lt;code&gt;server&lt;/code&gt; （或节点）是否存在，此函数始终返回 &lt;code&gt;:ok&lt;/code&gt; 。因此，未知目标 &lt;code&gt;server&lt;/code&gt; 是否成功处理了该消息。</target>
        </trans-unit>
        <trans-unit id="bc08e67f2fe286bbaa38c013f9a0710de372c88c" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">此函数始终返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38b1ffa237bfd139fe63c018eb6902804eab77a" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="440a46241c8ccf32d2a66af8c374d6f2f268c12c" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="502243a350ea8c22efdb92a69f5b1758006a416e" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="57434e8d5ce39ceeb05917e87327e9180f6a8556" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="0953d55a24fb80955003844da1bc3b8af51086cb" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">此功能假定任务的监视器仍处于活动状态，或者该监视器的 &lt;code&gt;:DOWN&lt;/code&gt; 消息在消息队列中。如果已被监视或已接收到消息，则此功能将等待超时，等待消息。</target>
        </trans-unit>
        <trans-unit id="7b478825975b2adf1e339715031349cd41d1d953" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">此功能假定任务的监视器仍处于活动状态，或者该监视器的 &lt;code&gt;:DOWN&lt;/code&gt; 消息在消息队列中。如果已对其进行监视，或者已经接收到消息，则此功能将等待超时的持续时间，以等待消息。</target>
        </trans-unit>
        <trans-unit id="61db13a99cd2b6f7c8e9e14b335594be40a81ac4" translate="yes" xml:space="preserve">
          <source>This function assumes the tasks' monitors are still active or the monitors' &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout.</source>
          <target state="translated">此功能假定任务的监视器仍处于活动状态，或者监视器的 &lt;code&gt;:DOWN&lt;/code&gt; 消息在消息队列中。如果显示了任何任务，或者已经接收到消息，则此功能将等待超时时间。</target>
        </trans-unit>
        <trans-unit id="a19b113270ec008da90487c67a8732f8a8235703" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;a href=&quot;#pop/3&quot;&gt;&lt;code&gt;pop/3&lt;/code&gt;&lt;/a&gt;, but raises in cases the &lt;code&gt;key&lt;/code&gt; is not present in the given &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">此函数的行为类似于&lt;a href=&quot;#pop/3&quot;&gt; &lt;code&gt;pop/3&lt;/code&gt; &lt;/a&gt;，但在给定 &lt;code&gt;keywords&lt;/code&gt; 不存在该 &lt;code&gt;key&lt;/code&gt; 情况下引发。</target>
        </trans-unit>
        <trans-unit id="12bd78dfccf68211322b54eebf7d9f19fae21105" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare a DateTime without the time zone information:</source>
          <target state="translated">这个函数也可以用来比较一个没有时区信息的DateTime。</target>
        </trans-unit>
        <trans-unit id="6685e43cbdb2479bfe075aeca3ae08082570222e" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the date fields:</source>
          <target state="translated">这个函数也可以用来比较更复杂的日历类型,只考虑日期字段。</target>
        </trans-unit>
        <trans-unit id="abca05fe88ba596b97d33bdad630bb0ce33ca0d8" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the time fields:</source>
          <target state="translated">这个函数也可以用来比较更复杂的日历类型,只考虑时间字段。</target>
        </trans-unit>
        <trans-unit id="50c88d683e6ca48ffff95675148916e0e611983e" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to ISO 8601 without the time zone information:</source>
          <target state="translated">这个功能也可以用来将DateTime转换为不含时区信息的ISO 8601。</target>
        </trans-unit>
        <trans-unit id="41a09a6604ea410d09611cc0508b8a9905bff4c2" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a erl format without the time zone information:</source>
          <target state="translated">这个函数也可以用来将DateTime转换为不含时区信息的erl格式。</target>
        </trans-unit>
        <trans-unit id="90561437b8e4f9d3679b45a602783e2cfc785f58" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a string without the time zone information:</source>
          <target state="translated">这个函数也可以用来将DateTime转换为没有时区信息的字符串。</target>
        </trans-unit>
        <trans-unit id="a058c913c46d45fd26854e6d03a3a8d889e6bda9" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information:</source>
          <target state="translated">这个函数也可以用来将DateTime转换为不包含时区信息的Erlang日期时间元组。</target>
        </trans-unit>
        <trans-unit id="607aaac2692d9ae79c5be1d1f95f4b67e7e30692" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以将此功能视为&lt;a href=&quot;#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;#transform/3&quot;&gt; &lt;code&gt;Stream.transform/3&lt;/code&gt; 的组合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7b8cf5df777bb4d4ddd30603ec1dffb30552797" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;stream#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以将此功能视为&lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;stream#transform/3&quot;&gt; &lt;code&gt;Stream.transform/3&lt;/code&gt; 的组合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8bf264a9f407b070cd0c90cff65f5b5b2f3cb5a" translate="yes" xml:space="preserve">
          <source>This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function.</source>
          <target state="translated">这个功能可以用来显示机器刚好有的时区配置的现在的时间。一个例子是桌面程序向用户显示时钟。对于任何其他用途,使用这个功能可能是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="65aef6f44f45a3fc1e3176aa1c4a4acc551773fb" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly send a reply to a client that called &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multi_call/4&quot;&gt;&lt;code&gt;multi_call/4&lt;/code&gt;&lt;/a&gt; when the reply cannot be specified in the return value of &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当无法在&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;的返回值中指定回复时，可以使用此函数向调用&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#multi_call/4&quot;&gt; &lt;code&gt;multi_call/4&lt;/code&gt; &lt;/a&gt;的客户端显式发送回复。</target>
        </trans-unit>
        <trans-unit id="e57ccc748f6208d195990a8cc4f2ec6d283e0449" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">对于任何给定任务，只能调用一次此函数。如果您希望能够多次检查长时间运行的任务是否已完成其计算，请改用&lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbc62789df38c8a43882a7041f6f112d727b0b2b" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield_many/2&quot;&gt;&lt;code&gt;yield_many/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">对于任何给定任务，只能调用一次此函数。如果您希望能够多次检查长时间运行的任务是否已完成其计算，请改用&lt;a href=&quot;#yield_many/2&quot;&gt; &lt;code&gt;yield_many/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1236468bd1c1382c4248a39818bd66a17820a8e1" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled.</source>
          <target state="translated">该函数只能用于尚未编译的模块。</target>
        </trans-unit>
        <trans-unit id="f3167d5a749467583b4064a26d582340a4353d73" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt; &lt;code&gt;Kernel.function_exported?/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt; &lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt; &lt;/a&gt;分别检查编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="98e8c080a62ccf76ac34e7992cc0abb94cb3247b" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;Kernel.function_exported?/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt; &lt;/a&gt;分别检查编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="bf1f12a9ef0b2d87e6b97c45dc8af653b0c41485" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取所有持久化的属性，或使用&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;检索已编译模块中的所有与文档相关的属性。</target>
        </trans-unit>
        <trans-unit id="fd3fe0cfc1b1ddd655c5e5aa49bdc3d3f6ab9cce" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取已编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="b999fb0a29efbf4b7d7e63844d3c5a01d70c5786" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取所有持久化的属性，或使用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;检索已编译模块中的所有与文档相关的属性。</target>
        </trans-unit>
        <trans-unit id="8efbd3ec7525b3bf67461748ab16a84e708bda9c" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取已编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="4d5f5ab7615681bbf6fd8b48511d63b244920517" translate="yes" xml:space="preserve">
          <source>This function changes the current working directory and loads the project at the given directory onto the project stack.</source>
          <target state="translated">该函数改变当前工作目录,并将给定目录下的项目加载到项目栈中。</target>
        </trans-unit>
        <trans-unit id="8e3b67a18d5ef72f20a07d2887c95146e1126e8b" translate="yes" xml:space="preserve">
          <source>This function checks if &lt;code&gt;map_set1&lt;/code&gt; is a subset of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">此功能检查 &lt;code&gt;map_set1&lt;/code&gt; 的一个子集 &lt;code&gt;map_set2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2d91333f4d34514a5b0456ce852915cb7c3b1bf" translate="yes" xml:space="preserve">
          <source>This function could also receive &lt;code&gt;:restart&lt;/code&gt; and &lt;code&gt;:shutdown&lt;/code&gt; as options but those two options have been deprecated and it is now preferred to give them directly to &lt;code&gt;start_child&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">此函数还可以接收 &lt;code&gt;:restart&lt;/code&gt; 和 &lt;code&gt;:shutdown&lt;/code&gt; 作为选项，但是不建议使用这两个选项，现在最好直接将它们提供给 &lt;code&gt;start_child&lt;/code&gt; 和 &lt;code&gt;async&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff81d1869547c10033febe62aa38e4cdb8f5c51e" translate="yes" xml:space="preserve">
          <source>This function discards all formatting of the original code.</source>
          <target state="translated">这个函数放弃了原始代码的所有格式化。</target>
        </trans-unit>
        <trans-unit id="bc64919f284870e1f397d0b40b0bdb1f6bff9e2a" translate="yes" xml:space="preserve">
          <source>This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.</source>
          <target state="translated">这个函数在任何时候都不加载协议,也不加载编译模块的新字节码。然而,每个实现必须是可用的,它将被加载。</target>
        </trans-unit>
        <trans-unit id="5e9ba48e0ab714ebacb38f83050628f3e221fabd" translate="yes" xml:space="preserve">
          <source>This function does not query the file system, so it assumes no symlinks between the paths.</source>
          <target state="translated">这个函数不查询文件系统,所以假设路径之间没有符号链接。</target>
        </trans-unit>
        <trans-unit id="352c8d36738c6dbc1f9234ecd7c20913e38da8c4" translate="yes" xml:space="preserve">
          <source>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</source>
          <target state="translated">这个函数在设计上不支持正则表达式。当使用正则表达式时,让正则表达式一次遍历字符串通常比像本函数这样分批遍历更有效率。</target>
        </trans-unit>
        <trans-unit id="e8a6e9d8eb826748ee60c4f58dedbbe4f6cb4a1b" translate="yes" xml:space="preserve">
          <source>This function does nothing if the given directory already exists; in this case, it still logs the directory creation.</source>
          <target state="translated">如果给定的目录已经存在,这个函数不做任何事情;在这种情况下,它仍然记录目录的创建。</target>
        </trans-unit>
        <trans-unit id="36b23a290c43ebbc586e10e0e06f96b58b15d87c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="translated">该函数需要一个有效的Elixir AST（也称为带引号的表达式）作为参数。如果你想 &lt;code&gt;unquote&lt;/code&gt; 任何值，如地图或四元元组，你应该叫&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; unquoting前。</target>
        </trans-unit>
        <trans-unit id="df30bac7bb7c4cc8e50dfd93b53e8ccc88b71e0c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="translated">此函数需要有效的Elixir AST（也称为带引号的表达式）作为参数。如果你想 &lt;code&gt;unquote&lt;/code&gt; 任何值，如地图或四元元组，你应该叫&lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; unquoting前。</target>
        </trans-unit>
        <trans-unit id="9f41d20e5f7f0240b4127af0359d8f266f1d505e" translate="yes" xml:space="preserve">
          <source>This function expects the &lt;code&gt;id&lt;/code&gt; in the child specification. For example:</source>
          <target state="translated">该函数需要子规范中的 &lt;code&gt;id&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="0a24e422135d3a72abf7a20c0e4887299173a50a" translate="yes" xml:space="preserve">
          <source>This function expects the file to be closed with success, which is usually the case unless the &lt;code&gt;:delayed_write&lt;/code&gt; option is given. For this reason, we do not recommend passing &lt;code&gt;:delayed_write&lt;/code&gt; to this function.</source>
          <target state="translated">该函数期望文件成功关闭，通常情况下，除非指定 &lt;code&gt;:delayed_write&lt;/code&gt; 选项，否则通常情况如此。因此，我们不建议将 &lt;code&gt;:delayed_write&lt;/code&gt; 传递给此函数。</target>
        </trans-unit>
        <trans-unit id="295cf4a022ae9886df00b43f0a66cd0e9487ce78" translate="yes" xml:space="preserve">
          <source>This function fails unless &lt;code&gt;enumerable&lt;/code&gt; is or can be converted into a list of tuples with &lt;em&gt;exactly&lt;/em&gt; two elements in each tuple.</source>
          <target state="translated">除非将 &lt;code&gt;enumerable&lt;/code&gt; 或可以将其转换为元组列表，且每个元组中&lt;em&gt;恰好有&lt;/em&gt;两个元素，否则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="2b4e5979f3e77e3276f95ef316da429597fdbf6e" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a directory, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">此函数遵循符号链接，因此，如果符号链接指向目录，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3644ab39c8ba48b5055b8839db30ad7f73881153" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a regular file, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">该函数遵循符号链接，因此，如果符号链接指向常规文件，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2249c2f938c82b4201fa3098032739f601917fd" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="translated">在&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;完成之后但在&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;返回之前调用此函数。对于应用程序（和任何包含的应用程序）规范中定义的每个开始阶段，将按其列出的顺序调用一次。</target>
        </trans-unit>
        <trans-unit id="ffa8e1b3e795c072d918d9fb7e14d1f0f556146a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="translated">在&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;完成之后但在&lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;返回之前调用此函数。对于应用程序（和任何包含的应用程序）规范中定义的每个开始阶段，将按列出顺序将其调用一次。</target>
        </trans-unit>
        <trans-unit id="324f00c4d8269119ff0a84cb2a42e9f018297cf4" translate="yes" xml:space="preserve">
          <source>This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</source>
          <target state="translated">在应用程序停止后，即在其监视树停止后，将调用此函数。它应该执行与&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调相反的操作，并应执行任何必要的清除。此回调的返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="d1e69bba301a1e9a02d953f1b325981a44e10b03" translate="yes" xml:space="preserve">
          <source>This function is called before the top-level supervisor is terminated. It receives the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value is later passed to &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在终止顶级主管之前，将调用此函数。它接收&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;返回的状态（如果存在），否则返回 &lt;code&gt;[]&lt;/code&gt; 。返回值稍后传递给&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9100c3a64f894ac6d7e9c96487fe6fde6165a293" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">当使用&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;启动应用程序时（以及位于其之上的函数，例如&lt;a href=&quot;#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;），将调用此函数。此功能应启动应用程序的顶层过程（如果应用程序遵循围绕监督的OTP设计原则，则该应用程序应是应用程序监督树的最高主管）。</target>
        </trans-unit>
        <trans-unit id="82b44336c3cb3815e176b242c09b89fad73c5747" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;application#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">当使用&lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;启动应用程序时调用此函数（以及位于其之上的函数，例如&lt;a href=&quot;application#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;）。此功能应启动应用程序的顶级过程（如果应用程序遵循围绕监督的OTP设计原则，则该功能应成为应用程序的监督树的最高主管）。</target>
        </trans-unit>
        <trans-unit id="6397213a49d0900b8102d7287a15cef482e32621" translate="yes" xml:space="preserve">
          <source>This function is commonly used on sigil implementations (like &lt;code&gt;~r&lt;/code&gt;, &lt;code&gt;~s&lt;/code&gt; and others) which receive a raw, unescaped string.</source>
          <target state="translated">此功能上印记实现常用（如 &lt;code&gt;~r&lt;/code&gt; ， &lt;code&gt;~s&lt;/code&gt; 及其他），其接收原料，不转义字符串。</target>
        </trans-unit>
        <trans-unit id="d995248df30d102cca47a9415c594b82af5a6b24" translate="yes" xml:space="preserve">
          <source>This function is deprecated in favor of register&lt;em&gt;test/6 which performs better under tight loops by avoiding `&lt;em&gt;_ENV&lt;/em&gt;&lt;/em&gt;`.</source>
          <target state="translated">不推荐使用此功能，而推荐使用寄存器&lt;em&gt;test / 6，该&lt;em&gt;&lt;/em&gt;&lt;/em&gt;寄存器&lt;em&gt;可以通过避免` &lt;/em&gt;&lt;em&gt;&lt;em&gt;_ENV`&lt;/em&gt;&lt;/em&gt;&lt;em&gt;在紧密循环下更好地执行&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c1d006a8fc94dd9c7e1ba97fca6cd955efbe08aa" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead.</source>
          <target state="translated">这个函数已经过时了。Code.get_docs/2总是返回nil,因为它的过期文档不再存储在BEAM文件中。请使用Code.fetch_docs/1来代替。</target>
        </trans-unit>
        <trans-unit id="d817e277c636af5ee8696b4df5a417a3f80ca798" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use :unicode.characters_to_nfc_binary/1 or :unicode.characters_to_nfd_binary/1 instead.</source>
          <target state="translated">这个函数已经过时了,请使用:unicode.characters_to_nfc_binary/1或:unicode.characters_to_nfd_binary/1代替。使用:unicode.characters_to_nfc_binary/1或:unicode.characters_to_nfd_binary/1代替。</target>
        </trans-unit>
        <trans-unit id="60a45058b6790fa9239d39a09ba1cdda7435ef0c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Application.put_all_env/2 instead.</source>
          <target state="translated">这个函数已经过时了。使用Application.put_all_env/2代替。</target>
        </trans-unit>
        <trans-unit id="0b23beae139d2fe3b8dd9e0473697f46a6bf3126" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.merge/2 instead.</source>
          <target state="translated">此功能已被废弃,请使用Config.Reader.merge/2代替。请使用Config.Reader.merge/2代替。</target>
        </trans-unit>
        <trans-unit id="86105be5ebb65f8fc111c1f572d090b08b31bb9f" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.read!/2 instead.</source>
          <target state="translated">此功能已被废弃,请使用Config.Reader.read!/2代替。请使用Config.Reader.read!/2代替。</target>
        </trans-unit>
        <trans-unit id="32063e9041204452ecaa501f77654e27a25810d5" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.read_imports!/2 instead.</source>
          <target state="translated">此功能已被废弃。请使用Config.Reader.read_imports!/2代替。</target>
        </trans-unit>
        <trans-unit id="6d197dc51c7a88c8b078c1ba4ae70a662b56ba4a" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd!/0 instead.</source>
          <target state="translated">此函数已被废弃,请使用File.cwd!/0代替。使用File.cwd!/0代替。</target>
        </trans-unit>
        <trans-unit id="68131068aaa063f7af71e9caaedd8601eae221d0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd/0 instead.</source>
          <target state="translated">此函数已被废弃,请使用File.cwd/0代替。使用File.cwd/0代替。</target>
        </trans-unit>
        <trans-unit id="0d830aeb45447ac17882f0a978208672f2f7513b" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Kernel.is_exception/1 instead.</source>
          <target state="translated">这个函数已经被废弃了,请使用Kernel.is_exception/1代替。使用Kernel.is_exception/1代替。</target>
        </trans-unit>
        <trans-unit id="ad1c80a22d94657b35b167d9b5a2864907218fe0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Kernel.is_struct/2 or pattern match on %Regex{} instead.</source>
          <target state="translated">这个函数已经被废弃了,请使用 Kernel.is_struct/2 或模式匹配 %Regex{}来代替。使用Kernel.is_struct/2或%Regex{}的模式匹配来代替。</target>
        </trans-unit>
        <trans-unit id="d9e5b31b2e69678e54278c031112af02d71d6009" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Mix.Project.compile_path/1 instead.</source>
          <target state="translated">这个函数已经过时了,请使用Mix.Project.compile_path/1代替。使用Mix.Project.compile_path/1代替。</target>
        </trans-unit>
        <trans-unit id="276ba4e5a68c3327954a5805cb6a3557ffa0219d" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use System.pid/0 instead.</source>
          <target state="translated">此功能已被废弃,请使用System.pid/0代替。使用System.pid/0代替。</target>
        </trans-unit>
        <trans-unit id="f81151223ea682b301965bb3a3e0dd982cec6acb" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use __STACKTRACE__ instead.</source>
          <target state="translated">这个函数已经过时了,请使用__STACKTRACE__代替。使用__STACKTRACE__代替。</target>
        </trans-unit>
        <trans-unit id="135f175d7851a47b5eed88f4c873758b05277e6c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use compilation tracers described in the Code module.</source>
          <target state="translated">此功能已被废弃。使用代码模块中描述的编译跟踪器。</target>
        </trans-unit>
        <trans-unit id="a03218696b1f2f17e92328d8d93708ef4f7e2fab" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use maps and the Map module instead.</source>
          <target state="translated">此功能已被废弃。使用地图和地图模块代替。</target>
        </trans-unit>
        <trans-unit id="5383727db2a4be3cae258dc51e6f2efc4de4ed67" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use register_test/6 instead.</source>
          <target state="translated">这个函数已经过时了,请使用register_test/6代替。使用 register_test/6 代替。</target>
        </trans-unit>
        <trans-unit id="294ad166bf50a35c62c560f0efcfd8102e974b3c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Config module instead.</source>
          <target state="translated">此功能已废弃。请使用配置模块。</target>
        </trans-unit>
        <trans-unit id="afca0b7ebdad39b2deed844f934a667e8bfea571" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Map module for working with maps or the Keyword module for working with keyword lists.</source>
          <target state="translated">此功能已被废弃,请使用地图模块处理地图或关键字模块处理关键字列表。使用地图模块来处理地图,或者使用关键字模块来处理关键字列表。</target>
        </trans-unit>
        <trans-unit id="9a82ec0a465ee3ffdfcf230d76d58430e9467641" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module for working with sets.</source>
          <target state="translated">此功能已被废弃,请使用MapSet模块来处理集合。使用MapSet模块来处理集合。</target>
        </trans-unit>
        <trans-unit id="01a53758d90cccf848faf6930295f5427dfb10e9" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module instead.</source>
          <target state="translated">此功能已被废弃,请使用MapSet模块代替。使用MapSet模块代替。</target>
        </trans-unit>
        <trans-unit id="bc379a87241e5a13ab44a63bf4ea91b193d573b0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="translated">此功能已被废弃。请使用 Supervisor 模块中概述的新子规范。</target>
        </trans-unit>
        <trans-unit id="03ea43b93839fafbcde7b68af462e5f9eed5a8d0" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</source>
          <target state="translated">此函数用于开发和调试的目的。不要在生产代码中依赖它。</target>
        </trans-unit>
        <trans-unit id="a44ba9065763e466dc65d136dacf651b48b4c551" translate="yes" xml:space="preserve">
          <source>This function is often used to set an &lt;code&gt;:id&lt;/code&gt; option when the same module needs to be started multiple times in the supervision tree:</source>
          <target state="translated">当需要在监管树中多次启动同一模块时，通常使用此函数设置 &lt;code&gt;:id&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="8b1fd4e59486849679c33280edfff500c42ca784" translate="yes" xml:space="preserve">
          <source>This function is often used with &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; since any evaluation is delayed until the stream is executed. See &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">此功能通常与&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;一起使用，因为任何评估都将延迟到执行流之前。有关示例，请参见&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35db107573e34332f733e95b887f5793867baa7f" translate="yes" xml:space="preserve">
          <source>This function is only available for modules being compiled.</source>
          <target state="translated">该功能仅适用于正在编译的模块。</target>
        </trans-unit>
        <trans-unit id="104264e00ba2e4cbd7fe3847934c61231f453ccd" translate="yes" xml:space="preserve">
          <source>This function is rarely invoked in practice. Instead, nodes are named and started via the command line by using the &lt;code&gt;--sname&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; flags. If you need to use this function to dynamically name a node, please make sure the &lt;code&gt;epmd&lt;/code&gt; operating system process is running by calling &lt;code&gt;epmd -daemon&lt;/code&gt;.</source>
          <target state="translated">在实践中很少调用此功能。而是使用 &lt;code&gt;--sname&lt;/code&gt; 和 &lt;code&gt;--name&lt;/code&gt; 标志通过命令行来命名和启动节点。如果需要使用此函数动态命名节点，请通过调用 &lt;code&gt;epmd -daemon&lt;/code&gt; 来确保 &lt;code&gt;epmd&lt;/code&gt; 操作系统进程正在运行。</target>
        </trans-unit>
        <trans-unit id="d6bf228951da57a994d903de6610ec9973c50adc" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;a href=&quot;#container_doc/6&quot;&gt;&lt;code&gt;container_doc/6&lt;/code&gt;&lt;/a&gt; and friends to the maximum number of entries on the same line.</source>
          <target state="translated">&lt;a href=&quot;#container_doc/6&quot;&gt; &lt;code&gt;container_doc/6&lt;/code&gt; &lt;/a&gt;和其朋友使用此功能以达到同一行上的最大条目数。</target>
        </trans-unit>
        <trans-unit id="4934d4902c08909612efec0de002f5df60337c47" translate="yes" xml:space="preserve">
          <source>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</source>
          <target state="translated">当你的代码已经在本地编译或更新,而你想在其他节点上运行时,这个函数对开发和调试很有用。</target>
        </trans-unit>
        <trans-unit id="50108ad28c85db6aa26c7746481f7a06145abb10" translate="yes" xml:space="preserve">
          <source>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate &lt;code&gt;:__struct__&lt;/code&gt; field into the map may not be enough and &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">此功能对于动态创建和更新结构以及将映射转换为结构很有用。在后一种情况下，仅将适当的 &lt;code&gt;:__struct__&lt;/code&gt; 字段插入映射中可能不够，而应使用&lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5385bb3c5cc1848788f9b3bfe82e294efa3644f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you have templates but you want to precompile inside a module for speed.</source>
          <target state="translated">这个函数在你有模板,但你想在一个模块内预编译以提高速度的情况下很有用。</target>
        </trans-unit>
        <trans-unit id="d4f1c9110eb148d436155bff7b34df88e2134afb" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present (e.g., the value is expensive to calculate or generally difficult to setup and teardown again).</source>
          <target state="translated">如果仅当 &lt;code&gt;key&lt;/code&gt; 不存在时才想计算要放入 &lt;code&gt;key&lt;/code&gt; 下的值（例如，该值计算起来很昂贵或通常很难再次设置和拆卸），此功能很有用。</target>
        </trans-unit>
        <trans-unit id="e5bb11de88319e8025850f4eadfe13c588a0a62f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present, as for example, when the value is expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">如果仅当 &lt;code&gt;key&lt;/code&gt; 不存在时才想计算要放入 &lt;code&gt;key&lt;/code&gt; 下的值，例如，当该值计算起来很昂贵或通常很难再次设置和拆卸时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="bf89a2dec2302779e475a219a3cc56e86137d9f9" translate="yes" xml:space="preserve">
          <source>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:</source>
          <target state="translated">当需要检索当前值(或当前值的函数计算)并同时更新时,这个函数很有用。例如,它可以用来读取用户的当前年龄,同时一次增加一个年龄。</target>
        </trans-unit>
        <trans-unit id="68a1bac27fa5baaa472b5537d1c8fee1ec1e9478" translate="yes" xml:space="preserve">
          <source>This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.</source>
          <target state="translated">当您知道模块的字节码已经在文件系统中更新,并且您想告诉虚拟机加载它时,这个功能很有用。</target>
        </trans-unit>
        <trans-unit id="80a765f43bfbc2222f8ba2acffb613f97fc1ff91" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</source>
          <target state="translated">该函数通常用于编译任务中,每当此类配置文件发生变化时,就会触发一次完整的重新编译。</target>
        </trans-unit>
        <trans-unit id="5161d32c18b7b4c986062d2c9d65d697f139b8ce" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.</source>
          <target state="translated">这个函数通常用于编译任务中,每当此类配置文件发生变化时,就会触发一次完整的重新编译。因此,mtime被缓存以避免文件系统的查找。</target>
        </trans-unit>
        <trans-unit id="79351219ceeb1dfd5ceb68c4d1517bb1d53f3be9" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report is logged.</source>
          <target state="translated">此功能保留有关错误报告的OTP语义。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 之外的其他原因，则会记录错误报告。</target>
        </trans-unit>
        <trans-unit id="9fb9a7593d63fc692737aa5ebbecdecf78a06b53" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report will be logged.</source>
          <target state="translated">此功能保留有关错误报告的OTP语义。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 以外的其他原因，则会记录错误报告。</target>
        </trans-unit>
        <trans-unit id="78ffeed4e3d53d08c6f8c5350cc948af11ad5cb9" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Unix and Windows. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="translated">该函数使用Unix和Windows上的环境变量PATH查找给定名称的可执行程序。它还考虑了每个操作系统的适当可执行扩展名，因此对于Windows，它将尝试查找具有 &lt;code&gt;.com&lt;/code&gt; ， &lt;code&gt;.cmd&lt;/code&gt; 或类似扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="f333cc8d70b1f8c9b88e75ba1e997bdd40b786ac" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Windows and Unix-like operating systems. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="translated">该函数在Windows和类似Unix的操作系统上使用环境变量PATH查找给定名称的可执行程序。它还考虑了每个操作系统的适当可执行扩展名，因此对于Windows，它将尝试查找具有 &lt;code&gt;.com&lt;/code&gt; ， &lt;code&gt;.cmd&lt;/code&gt; 或类似扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="5b2d601e721f14118337f53a36587c0e933c7a5a" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数使用提供的 &lt;code&gt;mapper&lt;/code&gt; 函数映射 &lt;code&gt;enumerable&lt;/code&gt; 每个元素。然后使用 &lt;code&gt;sorter&lt;/code&gt; 函数由映射的元素对可枚举数进行排序，该函数默认为&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03c6c18f32c36e354994adeed127bb47604a29a4" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数使用提供的 &lt;code&gt;mapper&lt;/code&gt; 函数映射 &lt;code&gt;enumerable&lt;/code&gt; 每个元素。然后使用 &lt;code&gt;sorter&lt;/code&gt; 函数（默认为&lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt; &lt;/a&gt;通过映射的元素对可枚举数进行排序。</target>
        </trans-unit>
        <trans-unit id="23713134a12e3df672b0e8ed70b6c1e947176852" translate="yes" xml:space="preserve">
          <source>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed.</source>
          <target state="translated">这个功能在复制文件时可能会失败,在这种情况下,它将使目标目录处于肮脏状态,已经复制的文件不会被删除。</target>
        </trans-unit>
        <trans-unit id="fc53ec83419111665403d3184c5309cb3ac3114b" translate="yes" xml:space="preserve">
          <source>This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">如果未找到 &lt;code&gt;child_id&lt;/code&gt; ，或者当前进程正在运行或正在重新启动，则此函数可能返回带有适当错误元组的错误。</target>
        </trans-unit>
        <trans-unit id="8ae84d6b7d02c1f5e4d3d90e843aa4994fe5afbb" translate="yes" xml:space="preserve">
          <source>This function merges two URIs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986, section 5.2&lt;/a&gt;.</source>
          <target state="translated">此功能根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986第5.2节&lt;/a&gt;合并两个URI 。</target>
        </trans-unit>
        <trans-unit id="37485440bd71be8d2898fa309650b1d1cd41ee6d" translate="yes" xml:space="preserve">
          <source>This function must be invoked passing a keyword list. Each key in the keyword list can be accessed in the template using the &lt;code&gt;@&lt;/code&gt; macro.</source>
          <target state="translated">必须通过传递关键字列表来调用此函数。可以使用 &lt;code&gt;@&lt;/code&gt; 宏在模板中访问关键字列表中的每个关键字。</target>
        </trans-unit>
        <trans-unit id="05add340c108b6747380b0569be39878bbcf49a1" translate="yes" xml:space="preserve">
          <source>This function mutes the &lt;code&gt;:console&lt;/code&gt; backend and captures any log messages sent to Logger from the calling processes. It is possible to ensure explicit log messages from other processes are captured by waiting for their exit or monitor signal.</source>
          <target state="translated">该功能使 &lt;code&gt;:console&lt;/code&gt; 后端静音，并捕获从调用进程发送到Logger的所有日志消息。通过等待其他进程的退出或监视信号，可以确保捕获到来自其他进程的明确日志消息。</target>
        </trans-unit>
        <trans-unit id="590e88bd007ad46708757dcaddaef35962698f85" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="translated">该函数仅接受浮点数，并且始终返回浮点数。如果您想要一个既接受浮点数又接受整数并且始终返回整数的函数，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt; &lt;code&gt;Kernel.round/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7249b2b7e8627d3ee0f960577e5cfe5cf5a1c42f" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;kernel#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="translated">该函数仅接受浮点数，并且始终返回浮点数。如果您想要一个既接受浮点数又接受整数并且始终返回整数的函数，请使用&lt;a href=&quot;kernel#round/1&quot;&gt; &lt;code&gt;Kernel.round/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50d8af487774d9f7e007fed31c88d7f628e11c28" translate="yes" xml:space="preserve">
          <source>This function only ever needs to store the last emitted element.</source>
          <target state="translated">这个函数只需要存储最后一个发射的元素。</target>
        </trans-unit>
        <trans-unit id="295eba0c064a53ae3a651500b18114cd09951154" translate="yes" xml:space="preserve">
          <source>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</source>
          <target state="translated">这个功能只有在shell上启用ANSI转义码的情况下才有效,这意味着这个功能在Windows机器上默认是不可用的。</target>
        </trans-unit>
        <trans-unit id="f8e779fa093dd3331e4911e8f1f5e060533eb427" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="translated">此函数产生的结果与用于列表的&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt;运算符相同。</target>
        </trans-unit>
        <trans-unit id="528389cc0cdba8ed58acc495892cfb708eb725e7" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="translated">此函数产生的结果与用于列表的&lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt;运算符相同。</target>
        </trans-unit>
        <trans-unit id="2bd92c0ea07d00b8bd2fd96f2a2022d49efc3e5e" translate="yes" xml:space="preserve">
          <source>This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too.</source>
          <target state="translated">该函数清除当前由编译器保存的所有模块,允许旧的编译器模块名被重新使用。如果有任何进程在运行这些模块的代码,它们也将被终止。</target>
        </trans-unit>
        <trans-unit id="e3b8f5e13f2da9604ba811f1ee787c3cba445b85" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="translated">此函数接收任务列表，并在给定的时间间隔内等待其答复。它以与 &lt;code&gt;tasks&lt;/code&gt; 输入参数中提供的任务相同的顺序返回结果列表。</target>
        </trans-unit>
        <trans-unit id="0c8f05dda04bc767a1282d611e4af5dafdcb7b8d" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="translated">该函数接收任务列表，并在给定的时间间隔内等待其答复。它返回一个包含两个元素的元组的列表，任务是第一个元素，而产生的结果是第二个。返回列表中的任务将与 &lt;code&gt;tasks&lt;/code&gt; 输入参数中提供的任务的顺序相同。</target>
        </trans-unit>
        <trans-unit id="66ca8de099428d7febba36a7eae6660d193647fb" translate="yes" xml:space="preserve">
          <source>This function reruns the given task; to do that, it first re-enables the task and then runs it as normal.</source>
          <target state="translated">这个函数重新运行给定的任务;要做到这一点,它首先重新启用任务,然后正常运行。</target>
        </trans-unit>
        <trans-unit id="7f88acb523db6223367758a20b1546d9d8c207d7" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, owner}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;. The &lt;code&gt;owner&lt;/code&gt; is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller.</source>
          <target state="translated">此函数返回 &lt;code&gt;{:ok, owner}&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 。该 &lt;code&gt;owner&lt;/code&gt; 是负责的PID注册表分区PID。所有者自动链接到呼叫者。</target>
        </trans-unit>
        <trans-unit id="902dd92c08e25103df4b50bae4697cf10a6fc6fd" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, pid}&lt;/code&gt; in case of success, otherwise it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3353899fe4360fc7c94245abd3933c4141ee40" translate="yes" xml:space="preserve">
          <source>This function returns a list of &lt;code&gt;{id, child, type, modules}&lt;/code&gt; tuples, where:</source>
          <target state="translated">此函数返回 &lt;code&gt;{id, child, type, modules}&lt;/code&gt; 元组的列表，其中：</target>
        </trans-unit>
        <trans-unit id="c22e6a9591d2580a185def76ec2a7822b6c5d175" translate="yes" xml:space="preserve">
          <source>This function returns a list of tuples containing:</source>
          <target state="translated">这个函数返回一个包含以下内容的元组列表。</target>
        </trans-unit>
        <trans-unit id="4ffb7797732e8eabda6ec4358625e5d11748d93c" translate="yes" xml:space="preserve">
          <source>This function returns a new enumerable built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together; conceptually, this is similar to a combination of &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个函数返回附加调用的结果，建立一个新的枚举 &lt;code&gt;fun&lt;/code&gt; 中的每个元素 &lt;code&gt;enumerable&lt;/code&gt; 在一起; 从概念上讲，这类似于&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; 的组合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4c4692a1b2085c0d5c4c7060abeb21e5e80d789" translate="yes" xml:space="preserve">
          <source>This function returns a new stream built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together.</source>
          <target state="translated">这个函数返回附加调用的结果，建立一个新的数据流 &lt;code&gt;fun&lt;/code&gt; 中的每个元素 &lt;code&gt;enumerable&lt;/code&gt; 在一起。</target>
        </trans-unit>
        <trans-unit id="9207161e31f07b71a8de0abeb84876a37ff477ac" translate="yes" xml:space="preserve">
          <source>This function returns a timer reference, which can be read with &lt;a href=&quot;#read_timer/1&quot;&gt;&lt;code&gt;read_timer/1&lt;/code&gt;&lt;/a&gt; or canceled with &lt;a href=&quot;#cancel_timer/1&quot;&gt;&lt;code&gt;cancel_timer/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数返回一个计时器参考，它可以与读取&lt;a href=&quot;#read_timer/1&quot;&gt; &lt;code&gt;read_timer/1&lt;/code&gt; &lt;/a&gt;或取消&lt;a href=&quot;#cancel_timer/1&quot;&gt; &lt;code&gt;cancel_timer/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3b4424c23b3b31b7bea686c83f6fbd90413317a" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the collected result and the command exit status.</source>
          <target state="translated">该函数返回一个包含收集结果和命令退出状态的元组。</target>
        </trans-unit>
        <trans-unit id="1c1572156370222a67bdcd453345528785b5b103" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor flags and child specifications.</source>
          <target state="translated">这个函数返回一个包含主管标志和子规范的元组。</target>
        </trans-unit>
        <trans-unit id="a236219391c9665ab6cd417a5f529892164a5643" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor options.</source>
          <target state="translated">这个函数返回一个包含主管选项的元组。</target>
        </trans-unit>
        <trans-unit id="f10657fb9f9d2dbe8abd5fb7b8f8b43416880ed5" translate="yes" xml:space="preserve">
          <source>This function returns an empty list when used at the root of an umbrella project because there is no compile manifest to extract the function call information from. To get the function calls of each child in an umbrella, execute the function at the root of each individual application.</source>
          <target state="translated">这个函数在伞形项目的根部使用时,返回一个空列表,因为没有编译清单来提取函数调用信息。要获取伞形项目中每个子程序的函数调用,请在每个应用程序的根部执行该函数。</target>
        </trans-unit>
        <trans-unit id="a6fbf0f83b2acb02bb139f54eef721ae8347767a" translate="yes" xml:space="preserve">
          <source>This function returns either &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. Where &lt;code&gt;definition&lt;/code&gt; is &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt; or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">此函数返回 &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 。其中 &lt;code&gt;definition&lt;/code&gt; 为 &lt;code&gt;:def&lt;/code&gt; ， &lt;code&gt;:defp&lt;/code&gt; ， &lt;code&gt;:defmacro&lt;/code&gt; 或 &lt;code&gt;:defmacrop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5908984f567478e4a60e81ad1b7f0e0a95ff38d7" translate="yes" xml:space="preserve">
          <source>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</source>
          <target state="translated">该函数立即返回,并忽略不存在的节点,或服务器名称不存在的节点。</target>
        </trans-unit>
        <trans-unit id="3c26de55ed91737da0adcc687c60b204ef4f41f8" translate="yes" xml:space="preserve">
          <source>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</source>
          <target state="translated">该函数返回断点ID,如果断点设置错误,则会引发。</target>
        </trans-unit>
        <trans-unit id="ac0ff9db2cb58b04d706d4d0f95101c014828e27" translate="yes" xml:space="preserve">
          <source>This function returns the current application name, but only if the application name should be printed.</source>
          <target state="translated">该函数返回当前的申请名称,但仅限于是否要打印申请名称。</target>
        </trans-unit>
        <trans-unit id="e9031a38e543bd6739ba00dbc5fed0a5a01f11ea" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回以秒为单位的差异，其中根据&lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;测量秒。</target>
        </trans-unit>
        <trans-unit id="f5af0f8f1d39fdde7d2176a52228d4efede75942" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回以秒为单位的差异，其中秒根据&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;进行测量。</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">该函数返回:</target>
        </trans-unit>
        <trans-unit id="dc16b8c0d60d4a66a61b6088df628cb2cdbe5f10" translate="yes" xml:space="preserve">
          <source>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</source>
          <target state="translated">此函数用于将一个路径列表转换为路径。请注意,在连接时,任何尾部的斜线都会被删除。</target>
        </trans-unit>
        <trans-unit id="f72643333bea463c7a8ea5767e80e22d1a7036bf" translate="yes" xml:space="preserve">
          <source>This function should be used to remove a specific extension which may or may not be there.</source>
          <target state="translated">这个功能应该用来删除一个可能存在或不存在的特定扩展。</target>
        </trans-unit>
        <trans-unit id="1fc59171af9c1101b367bf06403fbdf95aa428ac" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback (see the documentation for the &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback for more information).</source>
          <target state="translated">如果启动成功 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; 此函数应该返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 或{：ok，pid，state}。 &lt;code&gt;pid&lt;/code&gt; 应该是最高主管的PID。 &lt;code&gt;state&lt;/code&gt; 可以是任意术语，如果省略，将默认为 &lt;code&gt;[]&lt;/code&gt; ；如果应用程序后停止， &lt;code&gt;state&lt;/code&gt; 传递到&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;的回调（请参阅文件&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;的详细信息，回调）。</target>
        </trans-unit>
        <trans-unit id="21a65796034b404efe85bb5cf745e9599f9e6028" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</source>
          <target state="translated">这个函数不应该在应用程序代码的运行时使用(相对于基础架构和构建代码,比如Mix任务)。Mix是一个构建工具,在代码编译后可能无法使用(例如在发行版中)。</target>
        </trans-unit>
        <trans-unit id="7d9efdf471f60e2ed682dd93f955c9a027ea855c" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (see &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;env/0&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">不应在运行时在应用程序代码中使用此函数（有关更多信息，请参见&lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;env/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">该函数应该返回 &lt;code&gt;{:ok, value}&lt;/code&gt; ，如果键中存在 &lt;code&gt;key&lt;/code&gt; 则 &lt;code&gt;value&lt;/code&gt; 是键下的值；如果键中不存在键，则为 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec58ff70bd307ba9cba1f4ad5eec25344d58ad92" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="translated">这个函数不应该直接调用，除非实现自定义时 &lt;code&gt;inspect_fun&lt;/code&gt; 必须考虑到&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;。在其他任何地方，应该首选&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; ,&lt;/a&gt;因为它可以处理结构和异常。</target>
        </trans-unit>
        <trans-unit id="4e0b499c79fbb5106ff12e9b189fd33d1ca2f878" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="translated">这个函数不应该直接调用，除非实现自定义时 &lt;code&gt;inspect_fun&lt;/code&gt; 必须考虑到&lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;。在其他任何地方，应该首选&lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; ,&lt;/a&gt;因为它可以处理结构和异常。</target>
        </trans-unit>
        <trans-unit id="7c7b31de7bb27ac0e240dd4370dcbe439841a348" translate="yes" xml:space="preserve">
          <source>This function simply reads the configuration value for &lt;code&gt;:ansi_enabled&lt;/code&gt; in the &lt;code&gt;:elixir&lt;/code&gt; application. The value is by default &lt;code&gt;false&lt;/code&gt; unless Elixir can detect during startup that both &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; are terminals.</source>
          <target state="translated">此函数仅在 &lt;code&gt;:elixir&lt;/code&gt; 应用程序中读取 &lt;code&gt;:ansi_enabled&lt;/code&gt; 的配置值。除非Elixir在启动过程中可以检测到 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 均为终端，否则该值默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="334f3d5e4471a23891371c10f4d6629f6f864306" translate="yes" xml:space="preserve">
          <source>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</source>
          <target state="translated">这个函数产生一个进程,这个进程与调用者进程相连接,并由调用者进程监控。链接部分很重要,因为如果父进程死亡,它就会中止任务。它还能保证async/await之前的代码在你添加async调用后具有相同的属性。例如,想象一下你有这样的内容。</target>
        </trans-unit>
        <trans-unit id="c734a84fb40ac9d66210c296db69e31b0a02eadc" translate="yes" xml:space="preserve">
          <source>This function splits the given &lt;code&gt;string&lt;/code&gt; into a list of strings in a similar way to many shells.</source>
          <target state="translated">该函数将给定的 &lt;code&gt;string&lt;/code&gt; 拆分为字符串列表，其方式与许多Shell相似。</target>
        </trans-unit>
        <trans-unit id="ef2d261f9369eef612d3e5142c44d6cc0051a05a" translate="yes" xml:space="preserve">
          <source>This function takes the same options as &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数采用与&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="2feb07f1ca6bdd2a159c3be3d1d2d967088b7ce0" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#expand_once/2&quot;&gt;&lt;code&gt;expand_once/2&lt;/code&gt;&lt;/a&gt; under the hood. Check it out for more information and examples.</source>
          <target state="translated">该函数在&lt;a href=&quot;#expand_once/2&quot;&gt; &lt;code&gt;expand_once/2&lt;/code&gt; &lt;/a&gt;使用expand_once / 2。查阅更多信息和示例。</target>
        </trans-unit>
        <trans-unit id="6e2fc530fdd36a8deb023fe2c739cc5eac5cf4d5" translate="yes" xml:space="preserve">
          <source>This function uses Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt;&lt;code&gt;:rand&lt;/code&gt; module&lt;/a&gt; to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</source>
          <target state="translated">该函数使用Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt; &lt;code&gt;:rand&lt;/code&gt; 模块&lt;/a&gt;来计算随机值。检查其文档以设置其他随机算法或其他种子。</target>
        </trans-unit>
        <trans-unit id="97aac23199beb8d9422f08074a16068341921614" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">该功能使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个功能，这将在后面的部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="f5a185e1be937b1dd6a14d707efd0c65f663b9df" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">该功能使用&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个功能，这将在后面的部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="8aa0a6bd6b734aebad750c42bf0f37171db0b991" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; environment variable and falls back to &lt;code&gt;EDITOR&lt;/code&gt; if the former is not available.</source>
          <target state="translated">此函数使用 &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; 环境变量，如果前者不可用，则退回到 &lt;code&gt;EDITOR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b61a016ed8075bfc5c39ffca808acebff61a6a18" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. Do not use this function to sort structs, see &lt;a href=&quot;#sort/2&quot;&gt;&lt;code&gt;sort/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此函数使用合并排序算法。不要使用此函数对结构进行排序，有关更多信息，请参见&lt;a href=&quot;#sort/2&quot;&gt; &lt;code&gt;sort/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8837dfaf4412802924cfa8f14dc7efe7bf20108" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes or is in the same place as the second one.</source>
          <target state="translated">此函数使用合并排序算法。给定的函数应该比较两个参数，如果第一个参数在第二个参数之前或与第二个参数相同，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbfcbb53a61b66a747c2491e188753fa8068b44" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes the second one.</source>
          <target state="translated">此函数使用合并排序算法。给定的函数应该比较两个参数，如果第一个参数在第二个参数之前，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="862ee811fb4cabde3cfb7ab7a9097a9d6c254988" translate="yes" xml:space="preserve">
          <source>This function uses the parsing regular expression as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986, Appendix B&lt;/a&gt;.</source>
          <target state="translated">此函数使用&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986附录B中&lt;/a&gt;定义的解析正则表达式。</target>
        </trans-unit>
        <trans-unit id="d26051019e95731e1d7b99be08f5928a37367d27" translate="yes" xml:space="preserve">
          <source>This function was designed to camelize language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">该功能旨在将语言标识符/令牌标记化，因此它属于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt;模块。不要将其用作驼峰化字符串的通用机制，因为它不支持Unicode或在Elixir标识符中无效的字符。</target>
        </trans-unit>
        <trans-unit id="582211980e20afdfe93b93a25608463f5c56a8bf" translate="yes" xml:space="preserve">
          <source>This function was designed to underscore language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">此函数旨在强调语言标识符/标记，因此它属于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt;模块。请勿将其用作下划线字符串的通用机制，因为它不支持Unicode或Elixir标识符中无效的字符。</target>
        </trans-unit>
        <trans-unit id="ddcb598fb0ce62c01ead735edd62ec7ef5afb147" translate="yes" xml:space="preserve">
          <source>This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</source>
          <target state="translated">这个函数将对给定的模块进行仪表化处理,并在内存中加载一个新的版本,并在给定的函数和arity处设置断点。如果模块被重新编译,所有断点都会丢失。</target>
        </trans-unit>
        <trans-unit id="8b8f47c44e23aa37c7285c683f845cd5e9a96e09" translate="yes" xml:space="preserve">
          <source>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to &lt;code&gt;nil&lt;/code&gt;, which will remove that key from the metadata.</source>
          <target state="translated">此功能会将给定的关键字列表合并到现有的元数据中，但将键设置为 &lt;code&gt;nil&lt;/code&gt; 除外，这会将键从元数据中删除。</target>
        </trans-unit>
        <trans-unit id="11a397f1ed689beeb86c4bc32143ddefc115ba76" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;functionclauseerror&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="translated">如果给定的 &lt;code&gt;node&lt;/code&gt; 未处于活动状态，则此函数将引发&lt;a href=&quot;functionclauseerror&quot;&gt; &lt;code&gt;FunctionClauseError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3549fd2102012a4f6115406e1d4d00d9843abf5" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;https://hexdocs.pm/elixir/FunctionClauseError.html&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="translated">如果给定的 &lt;code&gt;node&lt;/code&gt; 未处于活动状态，则此函数将引发&lt;a href=&quot;https://hexdocs.pm/elixir/FunctionClauseError.html&quot;&gt; &lt;code&gt;FunctionClauseError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b9fdfcab204aeb9ec68e1e7116d2ac8debacde" translate="yes" xml:space="preserve">
          <source>This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of &lt;code&gt;{args, guards}&lt;/code&gt; pairs where each argument and each top-level condition in a guard separated by &lt;code&gt;and&lt;/code&gt;/&lt;code&gt;or&lt;/code&gt; is wrapped in a tuple with blame metadata.</source>
          <target state="translated">此函数将从字节码中检索可用子句，并根据给定的参数对它们进行评估。这些子句以 &lt;code&gt;{args, guards}&lt;/code&gt; 对的列表形式返回，其中，每个参数和保护中的每个顶级条件都由 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 分隔，并包装在带有非常规元数据的元组中。</target>
        </trans-unit>
        <trans-unit id="029c82ca4692615f6cc90f101026e01c3b5dc4e0" translate="yes" xml:space="preserve">
          <source>This functionality starts the &lt;code&gt;:net_kernel&lt;/code&gt; and other related processes.</source>
          <target state="translated">此功能将启动 &lt;code&gt;:net_kernel&lt;/code&gt; 和其他相关过程。</target>
        </trans-unit>
        <trans-unit id="a5c0fe11d15d66b3e64978f03cccbe68ad69f39c" translate="yes" xml:space="preserve">
          <source>This guarantees all messages sent to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; prior to this call will be processed. This is useful for testing and it should not be called in production code.</source>
          <target state="translated">这样可以确保在此调用之前发送给&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 的&lt;/a&gt;所有消息都将得到处理。这对于测试很有用，不应在生产代码中调用。</target>
        </trans-unit>
        <trans-unit id="931eb8597cbb84926c09fb6a3b1aa749f547e621" translate="yes" xml:space="preserve">
          <source>This guide aims to introduce the meta-programming techniques available in Elixir. The ability to represent an Elixir program by its own data structures is at the heart of meta-programming. This chapter starts by exploring those structures and the associated &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; constructs, so we can take a look at macros in the next chapter and finally build our own domain specific language.</source>
          <target state="translated">本指南旨在介绍Elixir中可用的元编程技术。通过自身的数据结构表示Elixir程序的能力是元编程的核心。本章将通过探索这些结构和相关的开始 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;unquote&lt;/code&gt; 的构建，所以我们可以在下一章看看宏和最终建立我们自己的领域特定语言。</target>
        </trans-unit>
        <trans-unit id="217ac3dbe93c0cad13af56d1e1ef16871421d82f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">发生这种情况是因为格式设置程序可以在不更改代码语义的情况下引入新行的唯一位置是插值。在这种情况下，我们建议开发人员直接调整代码。在这里，我们可以使用二进制连接运算符&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5849b2456045ed3a32dde6f55db3e066f023528f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;kernel#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">发生这种情况是因为格式设置程序可以在不更改代码语义的情况下引入新行的唯一位置是插值。在这种情况下，我们建议开发人员直接调整代码。在这里，我们可以使用二进制连接运算符&lt;a href=&quot;kernel#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ccb1f24686f9c6bcd91b3b281d116c9f04cb68f5" translate="yes" xml:space="preserve">
          <source>This helper only works when IEx is started with a Mix project, for example, &lt;code&gt;iex -S mix&lt;/code&gt;. The application is not restarted after compilation, which means any long running process may crash as any changed module will be temporarily removed and recompiled, without going through the proper code changes callback.</source>
          <target state="translated">仅当从Mix项目启动IEx（例如 &lt;code&gt;iex -S mix&lt;/code&gt; )时，此帮助程序才起作用。编译后，应用程序不会重新启动，这意味着任何长时间运行的进程都可能崩溃，因为任何更改的模块都将被临时删除并重新编译，而不经过适当的代码更改回调。</target>
        </trans-unit>
        <trans-unit id="af9ea0d60815c82f22be854ae11982e7962bd190" translate="yes" xml:space="preserve">
          <source>This implementation also adds &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; which give more control over the document fitting.</source>
          <target state="translated">此实现还添加了&lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#next_break_fits/2&quot;&gt; &lt;code&gt;next_break_fits/2&lt;/code&gt; &lt;/a&gt;，它们可以更好地控制文档的拟合。</target>
        </trans-unit>
        <trans-unit id="ecf1cb6c3f0131a137b0e41a93d52ab7359f8a7c" translate="yes" xml:space="preserve">
          <source>This implementation provides two types of breaks: &lt;code&gt;:strict&lt;/code&gt; and &lt;code&gt;:flex&lt;/code&gt;. When a group does not fit, all strict breaks are treated as newlines. Flex breaks however are re-evaluated on every occurrence and may still be rendered flat. See &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此实现提供两种类型的中断 &lt;code&gt;:strict&lt;/code&gt; 和 &lt;code&gt;:flex&lt;/code&gt; 。当一组不合适时，所有严格的休息时间都被视为换行符。但是，每次发生时都会重新评估柔韧性折断，并且可能仍会变得平坦。有关更多信息，请参见&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc54167321bb690ef67cdb4d7c3892839915a92e" translate="yes" xml:space="preserve">
          <source>This information is returned based on the code path. Here is an example:</source>
          <target state="translated">这些信息是根据代码路径返回的。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="b0ecce7e0d6c0fe3474303fad5ddb7ee794ff9c6" translate="yes" xml:space="preserve">
          <source>This interpretation is the same regardless if &lt;code&gt;--source&lt;/code&gt; or &lt;code&gt;--sink&lt;/code&gt; flags are used. For example, if we use the &lt;code&gt;--sink lib/c.ex&lt;/code&gt; flag, we would see the same tree:</source>
          <target state="translated">无论使用 &lt;code&gt;--source&lt;/code&gt; 还是 &lt;code&gt;--sink&lt;/code&gt; 标志，这种解释都是相同的。例如，如果使用 &lt;code&gt;--sink lib/c.ex&lt;/code&gt; 标志，则会看到同一棵树：</target>
        </trans-unit>
        <trans-unit id="d91881e1d6ed1dd4db7e1e2c49686c721a6638ef" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell when the &lt;code&gt;MIX_QUIET&lt;/code&gt; environment variable is set.</source>
          <target state="translated">当设置了 &lt;code&gt;MIX_QUIET&lt;/code&gt; 环境变量时，这是Mix的默认外壳程序。</target>
        </trans-unit>
        <trans-unit id="60031e59b55c11c2eb9a171c6db3ebaf52a6c050" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell.</source>
          <target state="translated">这是Mix的默认外壳。</target>
        </trans-unit>
        <trans-unit id="5053391a8e72e9d443f680cf9656acc6cdd0a4d5" translate="yes" xml:space="preserve">
          <source>This is a bad idea, as we don&amp;rsquo;t want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.</source>
          <target state="translated">这是一个坏主意，因为我们不希望注册表在存储桶崩溃时崩溃。正确的解决方法是实际上不将存储桶链接到注册表。取而代之的是，我们将每个存储段链接到一种称为Supervisor的特殊类型的过程，该过程专门用于处理故障和崩溃。我们将在下一章中详细了解它们。</target>
        </trans-unit>
        <trans-unit id="9e5ab726c57b0fb6f6da70a28676a9b1f70f7bab" translate="yes" xml:space="preserve">
          <source>This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated:</source>
          <target state="translated">这是一个硬解,因为它会发出警告,并将文档注释为弃用。</target>
        </trans-unit>
        <trans-unit id="c34842432839543d617525657c5d1288600c6c0e" translate="yes" xml:space="preserve">
          <source>This is a soft-deprecation as it simply annotates the documentation as deprecated:</source>
          <target state="translated">这是一个软解读,因为它只是简单地将文档注释为废弃的。</target>
        </trans-unit>
        <trans-unit id="9b525f4650716afc52d0be5f7a029605ace74f36" translate="yes" xml:space="preserve">
          <source>This is a task that can be aliased by projects that need to execute certain tasks before compiling dependencies:</source>
          <target state="translated">这是一个任务,可以被需要在编译依赖关系之前执行某些任务的项目所别名。</target>
        </trans-unit>
        <trans-unit id="77df0c1b4e2776653e0c5177f9ffa6268916531c" translate="yes" xml:space="preserve">
          <source>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</source>
          <target state="translated">这其实是开发宏时常见的陷阱。我们在宏中假设了一个特定的形状。我们可以通过取消引用表达式里面的变量的引用来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="0dc899362b8fa129cf65071f623d739413cc73aa" translate="yes" xml:space="preserve">
          <source>This is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.</source>
          <target state="translated">这一切都很好,但我们仍然希望为用户提供一个API,让我们隐藏我们的实现细节。</target>
        </trans-unit>
        <trans-unit id="f7b133b5999cc2d686bfdd612eea0550282bc0a5" translate="yes" xml:space="preserve">
          <source>This is also the syntax that Elixir uses to inspect keyword lists:</source>
          <target state="translated">这也是Elixir用来检查关键字列表的语法。</target>
        </trans-unit>
        <trans-unit id="695d7b0825ac4fbdcbd163159a7fc336c49f943b" translate="yes" xml:space="preserve">
          <source>This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly:</source>
          <target state="translated">这是一种反模式,不仅因为它使计算器逻辑复杂化,而且因为你把计算器逻辑放在一个单一的进程后面,这将成为你系统的潜在瓶颈,特别是当调用的数量增加时。相反直接定义函数就好了。</target>
        </trans-unit>
        <trans-unit id="9d1d1dd333c995d40a1c0f70de189cf4bf055fbb" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;a href=&quot;#myers_difference/2&quot;&gt;&lt;code&gt;myers_difference/2&lt;/code&gt;&lt;/a&gt; where a &lt;code&gt;diff_script&lt;/code&gt; function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or &lt;code&gt;nil&lt;/code&gt; in case there is no such script. The returned inner edit script will be under the &lt;code&gt;:diff&lt;/code&gt; key.</source>
          <target state="translated">这是&lt;a href=&quot;#myers_difference/2&quot;&gt; &lt;code&gt;myers_difference/2&lt;/code&gt; &lt;/a&gt;的扩展，其中在需要计算嵌套差异的情况下可以提供 &lt;code&gt;diff_script&lt;/code&gt; 函数。该函数可以返回带有内部编辑脚本的列表，如果没有这样的脚本，则返回 &lt;code&gt;nil&lt;/code&gt; 。返回的内部编辑脚本将在 &lt;code&gt;:diff&lt;/code&gt; 键下。</target>
        </trans-unit>
        <trans-unit id="1c0d7fab04e5bf783756a7f428e6b36128d23270" translate="yes" xml:space="preserve">
          <source>This is an optimization for &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt;.</source>
          <target state="translated">这是对 &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8a27bb1d6f71fa4c6c204cb8cc47805a7ed11d7" translate="yes" xml:space="preserve">
          <source>This is an option determining the prompt displayed to the user when awaiting input.</source>
          <target state="translated">这是一个决定在等待输入时向用户显示提示的选项。</target>
        </trans-unit>
        <trans-unit id="aae1c3bc3412e0ceca9643bedadc02d43a2f03a1" translate="yes" xml:space="preserve">
          <source>This is because by the time Elixir starts, Erlang's kernel has already been started, which means the configuration above would have no effect.</source>
          <target state="translated">这是因为当Elixir启动时,Erlang的内核已经被启动了,这意味着上面的配置不会有任何影响。</target>
        </trans-unit>
        <trans-unit id="d40bb6ddf99cda982a812b8ae52262c178bb85e3" translate="yes" xml:space="preserve">
          <source>This is because the macro is expecting its arguments to be a keyword list at &lt;strong&gt;compilation&lt;/strong&gt; time. Since in the example above we are passing the representation of the variable &lt;code&gt;kv&lt;/code&gt;, our code fails.</source>
          <target state="translated">这是因为宏在&lt;strong&gt;编译&lt;/strong&gt;时期望其参数是关键字列表。由于在上面的示例中，我们传递了变量 &lt;code&gt;kv&lt;/code&gt; 的表示形式，因此我们的代码失败了。</target>
        </trans-unit>
        <trans-unit id="69794bbecc9e248ec94d8fbad95cc7668576d9ad" translate="yes" xml:space="preserve">
          <source>This is done by loading &lt;code&gt;config/runtime.exs&lt;/code&gt; if one exists.</source>
          <target state="translated">如果存在，则通过加载 &lt;code&gt;config/runtime.exs&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="21f107c1b12d2af11cc6fc5fce200280f5598e01" translate="yes" xml:space="preserve">
          <source>This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.</source>
          <target state="translated">这可以是一个普通的PID,也可以是一个代表注册名称的值。更多信息请参见本文件的 &quot;名称注册 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="08a0e9ee70b7df166382e2da0f79cdb8aafbbed0" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used much less frequently here).</source>
          <target state="translated">这等效于许多命令式语言中的 &lt;code&gt;else if&lt;/code&gt; 子句（尽管在这里使用的频率更低）。</target>
        </trans-unit>
        <trans-unit id="b9679cc98b384d2fae74f5c4e147d814a3605b34" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used way less frequently here).</source>
          <target state="translated">这等效于许多命令式语言中的 &lt;code&gt;else if&lt;/code&gt; 子句（尽管此处使用频率较低）。</target>
        </trans-unit>
        <trans-unit id="20b3f3a29153ddca60608cf1ff19217f8f298150" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro so it can be used in guard clauses.</source>
          <target state="translated">这是以宏的形式实现的,所以它可以在保护子句中使用。</target>
        </trans-unit>
        <trans-unit id="b6ca1cc005536f5b89386dac5e9eaab2c71326b3" translate="yes" xml:space="preserve">
          <source>This is in contrast to &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt; which splits the entire string upfront.</source>
          <target state="translated">这与&lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;split/3&lt;/code&gt; &lt;/a&gt;相反，后者将预先拆分整个字符串。</target>
        </trans-unit>
        <trans-unit id="d6a69df7f8c6fe2ffd7e21f569ce958484e18a07" translate="yes" xml:space="preserve">
          <source>This is mainly useful in tests, allowing us to assert if given messages were received or not instead of performing checks on some captured IO. Since we need to guarantee a clean slate between tests, there is also a &lt;a href=&quot;#flush/1&quot;&gt;&lt;code&gt;flush/1&lt;/code&gt;&lt;/a&gt; function responsible for flushing all &lt;code&gt;:mix_shell&lt;/code&gt; related messages from the process inbox.</source>
          <target state="translated">这主要在测试中有用，它使我们能够断言是否接收​​到给定消息，而不是对某些捕获的IO进行检查。由于我们需要保证测试之间的间隔 &lt;code&gt;:mix_shell&lt;/code&gt; ，因此还有一个&lt;a href=&quot;#flush/1&quot;&gt; &lt;code&gt;flush/1&lt;/code&gt; &lt;/a&gt;函数负责从进程收件箱中刷新所有与：mix_shell相关的消息。</target>
        </trans-unit>
        <trans-unit id="a0fa3a9b78fa54d020541ab16426b8460b60af20" translate="yes" xml:space="preserve">
          <source>This is most commonly used by shell implementations but can also be invoked directly.</source>
          <target state="translated">这是最常用的shell实现,但也可以直接调用。</target>
        </trans-unit>
        <trans-unit id="72d44ff95753d13859fe1556278fcc193088f3be" translate="yes" xml:space="preserve">
          <source>This is most often used to execute conditional code:</source>
          <target state="translated">这最常用于执行条件代码。</target>
        </trans-unit>
        <trans-unit id="06d6ae37e05a3ae9f28e4ea5d06be5fb1cde0b89" translate="yes" xml:space="preserve">
          <source>This is often represented in the form of target triples, for example, &lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt;, &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt;, &lt;code&gt;x86_64-apple-darwin&lt;/code&gt;.</source>
          <target state="translated">这通常以目标三元组的形式表示，例如 &lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt; ， &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; ， &lt;code&gt;x86_64-apple-darwin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3cb696d174caaa2396a3c713ad639f81cfe5da1" translate="yes" xml:space="preserve">
          <source>This is often used to emulate configuration across environments:</source>
          <target state="translated">这通常用于模拟跨环境的配置。</target>
        </trans-unit>
        <trans-unit id="58dabc93b2ce93a10dc83d366ab232e1eea3c140" translate="yes" xml:space="preserve">
          <source>This is often used to start the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; as part of a supervision tree.</source>
          <target state="translated">通常将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用作监督树的一部分来启动GenServer。</target>
        </trans-unit>
        <trans-unit id="320f2d885658e9db2171a44a753f72f41faf6056" translate="yes" xml:space="preserve">
          <source>This is often used to start the agent as part of a supervision tree.</source>
          <target state="translated">这通常用于启动代理作为监督树的一部分。</target>
        </trans-unit>
        <trans-unit id="626d510108035955935a541c301f344a380255ad" translate="yes" xml:space="preserve">
          <source>This is often used to start the process as part of a supervision tree.</source>
          <target state="translated">这经常被用来作为监督树的一部分来启动这个过程。</target>
        </trans-unit>
        <trans-unit id="71cf2a71b0daa952a75b8e9a75ad4350e4dc2204" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="translated">与&lt;a href=&quot;#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt;一起使用时，这通常非常有用，它可以从表达式中删除行和卫生计数器之类的信息以进行存储或比较。</target>
        </trans-unit>
        <trans-unit id="30067513715299ced12cf77d1d47bd85e8cef7ec" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;macro#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="translated">与&lt;a href=&quot;macro#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt;一起使用时，这通常非常有用，它可以从表达式中删除行和卫生计数器之类的信息以进行存储或比较。</target>
        </trans-unit>
        <trans-unit id="4240cfedebaf42c2fac3f95a041f2d57c453967e" translate="yes" xml:space="preserve">
          <source>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</source>
          <target state="translated">这只在任务用于副作用时使用(即对返回的结果没有兴趣),而且它不应该与当前进程相联系。</target>
        </trans-unit>
        <trans-unit id="077e7548b6aaec650e916de489ebe79d6d5f3c44" translate="yes" xml:space="preserve">
          <source>This is pretty much all we need to implement our echo server. Let&amp;rsquo;s give it a try!</source>
          <target state="translated">这几乎是我们实现回显服务器所需的全部。试一试吧！</target>
        </trans-unit>
        <trans-unit id="6e08b933f971cdb50d5df304426433cd92e87e4c" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容性的原因,在Elixir的日志记录器后端中,这被报告为 &quot;错误&quot;。</target>
        </trans-unit>
        <trans-unit id="5ec5639249ca1a34b536a5264b41327593f5fb5f" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;info&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">出于向后兼容的原因,在Elixir的日志记录器后端中,这被报告为 &quot;info&quot;。</target>
        </trans-unit>
        <trans-unit id="a3346bf358b79fcbcf2b055d550e9935fe8f45fd" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;warn&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容性的原因,在Elixir的日志记录器后端中,这被报告为 &quot;警告&quot;。</target>
        </trans-unit>
        <trans-unit id="81016b61e7a2b5883ac247d4885c2d149315bdb9" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这与&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt;相似，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="50c031832816906ca789ff0f4ad1f1b4dfcf5d4e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#pop_in/2&quot;&gt;&lt;code&gt;pop_in/2&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这类似于&lt;a href=&quot;#pop_in/2&quot;&gt; &lt;code&gt;pop_in/2&lt;/code&gt; &lt;/a&gt;，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="7523a1751f43741a0a08ddae723c5c9199fa87e6" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#put_in/3&quot;&gt;&lt;code&gt;put_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这类似于&lt;a href=&quot;#put_in/3&quot;&gt; &lt;code&gt;put_in/3&lt;/code&gt; &lt;/a&gt;，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="22e8ffb1e74ab770f905747e9a80ef5c0478eb99" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#update_in/3&quot;&gt;&lt;code&gt;update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这与&lt;a href=&quot;#update_in/3&quot;&gt; &lt;code&gt;update_in/3&lt;/code&gt; &lt;/a&gt;相似，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="08ab0b2ff940cf63760635df2e0fe23beb3cbaa7" translate="yes" xml:space="preserve">
          <source>This is similar to the mistake we made when we called &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; straight from the registry. That meant a failure in any bucket would bring the whole registry down.</source>
          <target state="translated">这类似于我们直接从注册表中调用 &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; 时所犯的错误。这意味着任何存储桶中的故障都会使整个注册表崩溃。</target>
        </trans-unit>
        <trans-unit id="3ba1fb1b640495bd967734dfd1acecd010aa5148" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both &lt;a href=&quot;#char_reserved?/1&quot;&gt;reserved&lt;/a&gt; and &lt;a href=&quot;#char_unreserved?/1&quot;&gt;unreserved characters&lt;/a&gt; are kept unescaped.</source>
          <target state="translated">这是&lt;a href=&quot;#encode/2&quot;&gt; &lt;code&gt;URI.encode/2&lt;/code&gt; &lt;/a&gt;使用的默认值，其中&lt;a href=&quot;#char_reserved?/1&quot;&gt;保留&lt;/a&gt;和&lt;a href=&quot;#char_unreserved?/1&quot;&gt;未保留的字符&lt;/a&gt;都保持不转义。</target>
        </trans-unit>
        <trans-unit id="e61420057f50d9b6c715f4347be7ca8efd78730b" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;uri#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both reserved and unreserved characters are kept unescaped.</source>
          <target state="translated">这是&lt;a href=&quot;uri#encode/2&quot;&gt; &lt;code&gt;URI.encode/2&lt;/code&gt; &lt;/a&gt;使用的默认值，其中保留和未保留的字符都保持不转义。</target>
        </trans-unit>
        <trans-unit id="0dc79651e84bb5089915ce0f6bd2c110d8036119" translate="yes" xml:space="preserve">
          <source>This is the function invoked when there is string interpolation.</source>
          <target state="translated">这是字符串插值时调用的函数。</target>
        </trans-unit>
        <trans-unit id="9b687c89eb6e152da4dd73f09f730d0ddb490ab0" translate="yes" xml:space="preserve">
          <source>This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">这是Erlang VM用来查找模块代码的目录列表。</target>
        </trans-unit>
        <trans-unit id="a08d7b564f58b24087fbb35fa3617eff44897de1" translate="yes" xml:space="preserve">
          <source>This is the moment, in your calendar, when the current day ends and the next day starts.</source>
          <target state="translated">在你的日历中,这是当前一天结束和第二天开始的时刻。</target>
        </trans-unit>
        <trans-unit id="9162b52e4ae81113f3c3ee3bea2997ff399ccecc" translate="yes" xml:space="preserve">
          <source>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</source>
          <target state="translated">这是自ISO 8601记数法0000-01-01+00:00T00:00.000000(也称为公元前1月1日午夜的格里高利历)以来,包括最后一天的小数部分在内的天数。</target>
        </trans-unit>
        <trans-unit id="289ea50e9ca33fea490350d4d95a5411c3088228" translate="yes" xml:space="preserve">
          <source>This is the same AST as &lt;code&gt;not(left in right)&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;not(left in right)&lt;/code&gt; 相同（左向右）。</target>
        </trans-unit>
        <trans-unit id="e66f4430d7555e8a783dad322115e9a5ec53c0d1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; but it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the configuration is not available.</source>
          <target state="translated">这与&lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt;相同，但是如果配置不可用，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a74b9fe2a2d8c864a5673ce9cb8533effa232a81" translate="yes" xml:space="preserve">
          <source>This is the same supervisor as used by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;&lt;code&gt;ExUnit.Callbacks.start_supervised/2&lt;/code&gt;&lt;/a&gt; and similar, see &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt; module documentation for more information.</source>
          <target state="translated">该管理员与&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt; &lt;code&gt;ExUnit.Callbacks.start_supervised/2&lt;/code&gt; &lt;/a&gt;所使用的管理员相同，并且类似，请参阅&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; &lt;/a&gt;模块文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="b6d704491ec250974e27401b8e2b811c3f199e66" translate="yes" xml:space="preserve">
          <source>This is the same template generated by &lt;code&gt;mix new --sup&lt;/code&gt;.</source>
          <target state="translated">这是由 &lt;code&gt;mix new --sup&lt;/code&gt; 生成的模板。</target>
        </trans-unit>
        <trans-unit id="5580fdfd5d3be89e971bd5cfbc417edd38ca5b8e" translate="yes" xml:space="preserve">
          <source>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</source>
          <target state="translated">这是Elixir中每当我们有一个表达式块时使用的特殊形式。这种特殊形式是私有的,不应直接调用。</target>
        </trans-unit>
        <trans-unit id="ac7417af7c2a4cf8300b3d4dd8d7d38b6e9711f6" translate="yes" xml:space="preserve">
          <source>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check &lt;a href=&quot;#unescape_string/2&quot;&gt;&lt;code&gt;unescape_string/2&lt;/code&gt;&lt;/a&gt; for information on how to customize the escaping map.</source>
          <target state="translated">这是Elixir单引号和双引号字符串中默认使用的转义行为。检查&lt;a href=&quot;#unescape_string/2&quot;&gt; &lt;code&gt;unescape_string/2&lt;/code&gt; &lt;/a&gt;以获取有关如何自定义转义图的信息。</target>
        </trans-unit>
        <trans-unit id="13cd7a952e7bcf9bdf6ec9068841b4aa1581c6f4" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information.</source>
          <target state="translated">通常在基于模块的管理器的&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调的末尾调用此函数。有关更多信息，请参见模块文档中的&amp;ldquo;基于模块的主管&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4c3451cd606049c68c6fdb6bd088a1087ca448fd" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the sections &quot;Module-based supervisors&quot; and &quot;start_link/2, init/2, and strategies&quot; in the module documentation for more information.</source>
          <target state="translated">通常在基于模块的管理器的&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调的末尾调用此函数。有关更多信息，请参见模块文档中的&amp;ldquo;基于模块的管理器&amp;rdquo;和&amp;ldquo; start_link / 2，init / 2和策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="af7248045672bdf709fa9a7434ee693bbb5b3f33" translate="yes" xml:space="preserve">
          <source>This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code:</source>
          <target state="translated">这是Elixir的代码格式化器用来避免在某些特定位置中断代码的。例如,考虑这段代码。</target>
        </trans-unit>
        <trans-unit id="b9e62f945dfe72ca17b7bcf35230b54a13d5ce33" translate="yes" xml:space="preserve">
          <source>This is used by third-party projects, like QuickCheck, to implement macros like &lt;code&gt;property/3&lt;/code&gt; that works like &lt;code&gt;test&lt;/code&gt; but instead defines a property. See &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; implementation for an example of invoking this function.</source>
          <target state="translated">第三方项目（如QuickCheck）使用它来实现诸如 &lt;code&gt;property/3&lt;/code&gt; 之类的宏，该宏的作用类似于 &lt;code&gt;test&lt;/code&gt; ,但定义了一个属性。有关调用此功能的示例，请参见&lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="37d46fa38c10dd65a76b1733d8c4d14f6e5122f5" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">这对于调试由特定进程执行的特定代码块很有用。该过程将成为IEx命令的评估者，并且会暂时更改为具有自定义组长。通过调用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt; &lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt; &lt;/a&gt;恢复这些值，这将启动一个新的IEx shell，从而释放撬出的外壳。</target>
        </trans-unit>
        <trans-unit id="7c60447d6bcf0312eb4c4e52c080f8e8aeffd1b2" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">这在调试由特定进程执行的特定代码块时非常有用。该过程将成为IEx命令的评估者，并且会暂时更改为具有自定义组负责人。通过调用&lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt; &lt;/a&gt;还原这些值，这将启动一个新的IEx shell，从而释放撬出的外壳。</target>
        </trans-unit>
        <trans-unit id="aaba5c733f8e5f3a464f80421ccdf2cbfb12126e" translate="yes" xml:space="preserve">
          <source>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">如果默认值的计算成本很高,或者一般很难设置和再次拆解,这一点很有用。</target>
        </trans-unit>
        <trans-unit id="e90f6c096938c0c1b08fe0f1a4ed6112b1726e64" translate="yes" xml:space="preserve">
          <source>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">如果数值的计算非常昂贵,或者一般难以设置和再次拆解,这一点很有用。</target>
        </trans-unit>
        <trans-unit id="c7ade3c8c2220433a36448cb76b4d6669b0207f9" translate="yes" xml:space="preserve">
          <source>This is useful in two cases:</source>
          <target state="translated">这在两种情况下是有用的。</target>
        </trans-unit>
        <trans-unit id="5a46a616db1ce450247219cde25e3ee509bdc87d" translate="yes" xml:space="preserve">
          <source>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</source>
          <target state="translated">当需要运行一个流时,这很有用,因为副作用,而且对其返回结果没有兴趣。</target>
        </trans-unit>
        <trans-unit id="64ec9debc1653fe16f8858cb9974d03451f758f7" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled.</source>
          <target state="translated">当一个结构需要在编译时被扩展,而被扩展的结构可能已经被编译过,也可能还没有被编译过时,这个函数就很有用。这个函数也可以扩展在被编译的模块下定义的结构。</target>
        </trans-unit>
        <trans-unit id="8454071c897ae3b3f6c5cf6b435c8859ed4d0efe" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is even capable of expanding structs defined under the module being compiled.</source>
          <target state="translated">当一个结构需要在编译时被展开,而被展开的结构可能已经被编译过,也可能还没有被编译过,这个函数就很有用。这个函数甚至可以扩展在被编译的模块下定义的结构。</target>
        </trans-unit>
        <trans-unit id="58f647f53c93e0adaedcaedcde7d2a04c6e11b1a" translate="yes" xml:space="preserve">
          <source>This is useful when the result is something variable (like a PID in the example above) or when the result is a complicated data structure and you don't want to show it all, but just parts of it or some of its properties.</source>
          <target state="translated">当结果是一些变量(如上面例子中的PID),或者当结果是一个复杂的数据结构,而你不想显示全部,而只想显示它的一部分或它的一些属性时,这很有用。</target>
        </trans-unit>
        <trans-unit id="42708290411e38f509da43bac650f9a95ec98921" translate="yes" xml:space="preserve">
          <source>This is useful when there are a set of setup callbacks or a set of functions that should be shared between test modules.</source>
          <target state="translated">当有一组设置回调或一组函数应该在测试模块之间共享时,这很有用。</target>
        </trans-unit>
        <trans-unit id="bca60e4733f4f8f89c26ce0231040f2ac6f94040" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="translated">通常由以&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;开头的会话调用。这允许当前进程执行到下一个断点，这将自动将控制权交还给IEx，而无需请求允许撬动。</target>
        </trans-unit>
        <trans-unit id="5765e6f4f6c943fc2869a6d958ffb07d4ecdc95a" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="translated">通常由以&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;开头的会话调用。这允许当前进程执行到下一个断点，这将自动将控制权交还给IEx，而无需请求允许撬动。</target>
        </trans-unit>
        <trans-unit id="9795df452756bfa4ad139a3e1454b0c1c3e19967" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="translated">通常由需要在项目上定义其他功能的任务来调用。由于此类任务通常取决于定义的项目，因此在没有可用项目的情况下，此函数会引发&lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="d5c28e5992d11ab017599cfba8c0660377868c31" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="translated">通常由需要在项目上定义其他功能的任务来调用。由于此类任务通常取决于定义的项目，因此在没有可用项目的情况下，此函数会引发&lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="70a55e5fc2aa3b9db64d4f94cf960265a3232cd2" translate="yes" xml:space="preserve">
          <source>This is where protocols can help us: protocols allow us to extend the original behavior for as many data types as we need. That&amp;rsquo;s because &lt;strong&gt;dispatching on a protocol is available to any data type that has implemented the protocol&lt;/strong&gt; and a protocol can be implemented by anyone, at any time.</source>
          <target state="translated">这是协议可以为我们提供帮助的地方：协议允许我们根据需要扩展任意数量数据类型的原始行为。这是因为&lt;strong&gt;协议&lt;/strong&gt;的&lt;strong&gt;分派可用于实现该协议的任何数据类型，&lt;/strong&gt;并且任何人都可以随时实现该协议。</target>
        </trans-unit>
        <trans-unit id="b871a08121731acae06ea58fe3ca7e1bb16748e0" translate="yes" xml:space="preserve">
          <source>This keeps only significant chunks necessary for the VM operation, discarding documentation, debug info, compile information and others.</source>
          <target state="translated">这样就只保留了虚拟机运行所需的重要分块,丢弃了文档、调试信息、编译信息等。</target>
        </trans-unit>
        <trans-unit id="89c99ecc9ec64bbd119250b6f605dbf4510f1e46" translate="yes" xml:space="preserve">
          <source>This key is optional, only needed for applications that start a supervision tree.</source>
          <target state="translated">这个键是可选的,只有启动监督树的应用才需要。</target>
        </trans-unit>
        <trans-unit id="29ecf7d31c543b3beaa11f8d6b32d12f2cddd50a" translate="yes" xml:space="preserve">
          <source>This lets you put imports in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">如果您打开模块不可用的控制台，则可以将导入放入 &lt;code&gt;.iex.exs&lt;/code&gt; 文件（包括 &lt;code&gt;~/.iex.exs&lt;/code&gt; ）中，而不会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="e5847e98d18087e669daaf541b861bb0616506ae" translate="yes" xml:space="preserve">
          <source>This lets you use the module in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">如果您打开一个模块不可用的控制台，则可以在 &lt;code&gt;.iex.exs&lt;/code&gt; 文件（包括 &lt;code&gt;~/.iex.exs&lt;/code&gt; ）中使用该模块，而不会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="e593f23f33013dc92ddfcd3a9c60d10f99bd1858" translate="yes" xml:space="preserve">
          <source>This linear behaviour should also be expected on operations like &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#at/2&quot;&gt;&lt;code&gt;at/2&lt;/code&gt;&lt;/a&gt; and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</source>
          <target state="translated">在诸如&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#at/2&quot;&gt; &lt;code&gt;at/2&lt;/code&gt; 之&lt;/a&gt;类的操作上也应该期望这种线性行为。尽管Elixir确实允许数据类型为此类操作提供高性能的变体，但您不应期望它始终可用，因为&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块旨在使用多种数据类型，并且并非所有数据类型都可以提供优化的性能。</target>
        </trans-unit>
        <trans-unit id="0519fbd8b9b5639ec90e00d83250f771f4f40453" translate="yes" xml:space="preserve">
          <source>This macro addresses this issue by checking if the file exists or not in behalf of the user.</source>
          <target state="translated">这个宏通过代表用户检查文件是否存在来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="5cc6e8a94ed92b3b0f91dd0c407badd0f4cd9583" translate="yes" xml:space="preserve">
          <source>This macro defines a module with the given &lt;code&gt;alias&lt;/code&gt; as its name and with the given contents. It returns a tuple with four elements:</source>
          <target state="translated">该宏定义了一个模块，该模块具有给定的 &lt;code&gt;alias&lt;/code&gt; 作为其名称并具有给定的内容。它返回一个包含四个元素的元组：</target>
        </trans-unit>
        <trans-unit id="ba5022c9c8161864d7b55a2f306a7cb1932890b2" translate="yes" xml:space="preserve">
          <source>This macro evaluates and returns the &lt;code&gt;do&lt;/code&gt; block passed in as the second argument if &lt;code&gt;condition&lt;/code&gt; evaluates to a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;). Otherwise, it returns the value of the &lt;code&gt;else&lt;/code&gt; block if present or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">如果 &lt;code&gt;condition&lt;/code&gt; 的值为 &lt;code&gt;false&lt;/code&gt; （false或 &lt;code&gt;nil&lt;/code&gt; ），则此宏将求值并返回作为第二个参数传入的 &lt;code&gt;do&lt;/code&gt; 块。否则，如果存在则返回 &lt;code&gt;else&lt;/code&gt; 块的值，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed734b49c8a157748138d4db51538d7e06cee2ee" translate="yes" xml:space="preserve">
          <source>This macro expects a variable and it is typically invoked inside &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt; to mark that a variable should not be hygienized. See &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">该宏需要一个变量，通常在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt;内部调用该变量，以指示不应对变量进行卫生处理。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="053dc4326086a38d85524369b85300ca1b5d0614" translate="yes" xml:space="preserve">
          <source>This macro expects the first argument to be a condition and the second argument to be a keyword list.</source>
          <target state="translated">这个宏希望第一个参数是一个条件,第二个参数是一个关键字列表。</target>
        </trans-unit>
        <trans-unit id="09100845f4d4f229d78b6113f1e6a5dce38e078d" translate="yes" xml:space="preserve">
          <source>This macro is auto-imported with every &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该宏会与每个&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;自动导入。</target>
        </trans-unit>
        <trans-unit id="116b64f16c1348abfeaaf5c29004dd2cd4513959" translate="yes" xml:space="preserve">
          <source>This macro is deprecated in favour of &lt;a href=&quot;#warning/2&quot;&gt;&lt;code&gt;warning/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不建议使用此宏，而建议使用&lt;a href=&quot;#warning/2&quot;&gt; &lt;code&gt;warning/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1884b82116e213d51fde668f93db8aefff68f2db" translate="yes" xml:space="preserve">
          <source>This macro is deprecated. Use the Config module instead.</source>
          <target state="translated">此宏已被废弃。请使用配置模块。</target>
        </trans-unit>
        <trans-unit id="fa58f8e50bd6c8d47ad7511ec3aec19833923a02" translate="yes" xml:space="preserve">
          <source>This macro is used to generate ExUnit test cases for doctests.</source>
          <target state="translated">这个宏用于为doctests生成ExUnit测试用例。</target>
        </trans-unit>
        <trans-unit id="b7318b11fdb5ce2984ea08a62c18118bc9d28bcc" translate="yes" xml:space="preserve">
          <source>This makes your code clearer and easier to test and maintain, as you can invoke and test &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; directly. It also helps you design an actual API for developers that do not want to rely on macros.</source>
          <target state="translated">因为您可以直接调用和测试 &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; ，所以这使您的代码更清晰，更易于测试和维护。它还可以帮助您为不想依赖宏的开发人员设计实际的API。</target>
        </trans-unit>
        <trans-unit id="781a3479b6ef9afbd878f1e315bbde3afc7381db" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">这意味着可以扩展&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt;以提供自定义查找。缺点是，函数不能作为键存储在访问的数据结构中。</target>
        </trans-unit>
        <trans-unit id="31c83c38260c43e23e00b1d110954e0ba5266ba4" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">这意味着可以将&lt;a href=&quot;#get_in/2&quot;&gt; &lt;code&gt;get_in/2&lt;/code&gt; &lt;/a&gt;扩展为提供自定义查找。在下面的示例中，我们使用一个函数来获取列表内的所有地图：</target>
        </trans-unit>
        <trans-unit id="cfd9674170ea7f680e0ec4f0f9ace7b923ad6168" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">这意味着可以将&lt;a href=&quot;#get_in/2&quot;&gt; &lt;code&gt;get_in/2&lt;/code&gt; &lt;/a&gt;扩展为提供自定义查找。缺点是，函数不能作为键存储在访问的数据结构中。</target>
        </trans-unit>
        <trans-unit id="7a04c313f02da8b2b423b92a32377c49ecdd6219" translate="yes" xml:space="preserve">
          <source>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</source>
          <target state="translated">这意味着文件可以在节点之间传递,消息传递保证它们可以在网络中写入同一个文件。</target>
        </trans-unit>
        <trans-unit id="1e15019a33fea88c51d5e497980380e75ee3dd48" translate="yes" xml:space="preserve">
          <source>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</source>
          <target state="translated">这意味着在使用该模块中的函数时,与直接使用二进制文件的更低级的操作相比,往往会有性能成本。</target>
        </trans-unit>
        <trans-unit id="8571bea1bef1bde6a2d1b2d12776f78df57e4340" translate="yes" xml:space="preserve">
          <source>This means our implementation is going in the correct direction, but it doesn&amp;rsquo;t look very elegant, does it?</source>
          <target state="translated">这意味着我们的实现朝着正确的方向发展，但是看起来并不优雅，是吗？</target>
        </trans-unit>
        <trans-unit id="64cb76e001bde4ce0c23b9ae9350ed13f2f87e6d" translate="yes" xml:space="preserve">
          <source>This means reserved characters, such as &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default.</source>
          <target state="translated">这意味着保留字符（例如 &lt;code&gt;:&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; ）以及具有转义和未转义含义相同的所谓未保留字符在默认情况下不会被转义。</target>
        </trans-unit>
        <trans-unit id="466121cf36d188101adba56c09d86681a5f8592b" translate="yes" xml:space="preserve">
          <source>This means that when performing multiple operations with &lt;code&gt;Enum&lt;/code&gt;, each operation is going to generate an intermediate list until we reach the result:</source>
          <target state="translated">这意味着，当使用 &lt;code&gt;Enum&lt;/code&gt; 执行多个操作时，每个操作将生成一个中间列表，直到我们得到结果：</target>
        </trans-unit>
        <trans-unit id="e439478d8b723981d4581d054a8682120535699c" translate="yes" xml:space="preserve">
          <source>This means the VM no longer needs to keep the stacktrace once inside an &lt;code&gt;else&lt;/code&gt; clause and so tail recursion is possible when using a &lt;code&gt;try&lt;/code&gt; with a tail call as the final call inside an &lt;code&gt;else&lt;/code&gt; clause. The same is true for &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; clauses.</source>
          <target state="translated">这意味着虚拟机不再需要保持堆栈跟踪一次内部 &lt;code&gt;else&lt;/code&gt; 条款，所以使用时尾递归可以 &lt;code&gt;try&lt;/code&gt; 用尾调用作为内部最终调用 &lt;code&gt;else&lt;/code&gt; 条款。 &lt;code&gt;rescue&lt;/code&gt; 条款和 &lt;code&gt;catch&lt;/code&gt; 条款也是如此。</target>
        </trans-unit>
        <trans-unit id="03cbb2743a8fea6a87cdaa1b5871df611958047b" translate="yes" xml:space="preserve">
          <source>This means we can also configure our &lt;code&gt;:routing_table&lt;/code&gt; directly in the &lt;code&gt;config/config.exs&lt;/code&gt; file. However, which configuration value should we use?</source>
          <target state="translated">这意味着我们也可以直接在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:routing_table&lt;/code&gt; 。但是，我们应该使用哪个配置值？</target>
        </trans-unit>
        <trans-unit id="d88b91b0ac64ad4e82abb4e5d0dae196f85569c8" translate="yes" xml:space="preserve">
          <source>This message was triggered by invoking the helper &lt;code&gt;h()&lt;/code&gt;, usually referred to as &lt;a href=&quot;#h/0&quot;&gt;&lt;code&gt;h/0&lt;/code&gt;&lt;/a&gt; (since it expects 0 arguments).</source>
          <target state="translated">该消息是通过调用辅助程序 &lt;code&gt;h()&lt;/code&gt; 触发的，通常被称为&lt;a href=&quot;#h/0&quot;&gt; &lt;code&gt;h/0&lt;/code&gt; &lt;/a&gt;（因为它需要0个参数）。</target>
        </trans-unit>
        <trans-unit id="0f38cc8ed71ef5111e6f4d0950287ab1718bd370" translate="yes" xml:space="preserve">
          <source>This module allows a developer to define a test case template to be used throughout their tests. This is useful when there are a set of functions that should be shared between tests or a set of setup callbacks.</source>
          <target state="translated">这个模块允许开发人员定义一个测试用例模板,以便在整个测试中使用。当有一组函数需要在测试之间共享或一组设置回调时,这很有用。</target>
        </trans-unit>
        <trans-unit id="29465ded0e12b42e58045ba6de87bf204437ce87" translate="yes" xml:space="preserve">
          <source>This module allows developers to specify a string that serves as template for log messages, for example:</source>
          <target state="translated">该模块允许开发人员指定一个字符串作为日志消息的模板,例如。</target>
        </trans-unit>
        <trans-unit id="4305f790d0ec82e224afef341de114e73b6a1e74" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块还文档中的宏，大约药剂的编译环境返回信息，如（&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3741d9dd92ba5c7f8bc185d6546445601bc27a51" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块还文档中的宏，大约药剂的编译环境返回信息，如（&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d8c660841c33dff8911e93abdee348ab3a09d4db" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此模块还包括用于调试目的的帮助程序，有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d05e55cf46fce50db35799f75e85316f97b59d" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此模块还包括用于调试目的的帮助程序，有关更多信息，请参见&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef6795d77de60f24997761f8faf2a5faa8a9879b" translate="yes" xml:space="preserve">
          <source>This module also provides low-level functions, such as &lt;a href=&quot;#next/2&quot;&gt;&lt;code&gt;next/2&lt;/code&gt;&lt;/a&gt;, for parsing switches manually, as well as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#to_argv/1&quot;&gt;&lt;code&gt;to_argv/1&lt;/code&gt;&lt;/a&gt; for parsing from and converting switches to strings.</source>
          <target state="translated">此模块还提供了低级功能，例如&lt;a href=&quot;#next/2&quot;&gt; &lt;code&gt;next/2&lt;/code&gt; &lt;/a&gt;，用于手动分析开关，以及&lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#to_argv/1&quot;&gt; &lt;code&gt;to_argv/1&lt;/code&gt; ,&lt;/a&gt;用于从开关进行解析并将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="5a3684a4a565b66b7520e22d3fbaa6d25f44fe28" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">此模块还提供了许多用于创建流的便捷功能，例如&lt;a href=&quot;#cycle/1&quot;&gt; &lt;code&gt;Stream.cycle/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#unfold/2&quot;&gt; &lt;code&gt;Stream.unfold/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="08818329b397b72cb93efb576183f5c8fee90efe" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;stream#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">此模块还提供了许多用于创建流的便捷功能，例如&lt;a href=&quot;stream#cycle/1&quot;&gt; &lt;code&gt;Stream.cycle/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stream#unfold/2&quot;&gt; &lt;code&gt;Stream.unfold/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="ad2b3a4e9085aa555ad326d7ab4e688a30372b07" translate="yes" xml:space="preserve">
          <source>This module also provides other convenience functions like &lt;code&gt;assert_in_delta&lt;/code&gt; and &lt;code&gt;assert_raise&lt;/code&gt; to easily handle other common cases such as checking a floating-point number or handling exceptions.</source>
          <target state="translated">该模块还提供其他便利功能，例如 &lt;code&gt;assert_in_delta&lt;/code&gt; 和 &lt;code&gt;assert_raise&lt;/code&gt; ,以轻松处理其他常见情况，例如检查浮点数或处理异常。</target>
        </trans-unit>
        <trans-unit id="9e2d831a828a6863612cdac8824ced54a83aa6de" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;exunit.callbacks&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process lifecycle.</source>
          <target state="translated">此模块自动包括&lt;a href=&quot;exunit.callbacks&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; 中&lt;/a&gt;定义的所有回调。有关 &lt;code&gt;setup&lt;/code&gt; ， &lt;code&gt;start_supervised&lt;/code&gt; ， &lt;code&gt;on_exit&lt;/code&gt; 和测试过程生命周期的更多信息，请参见该模块。</target>
        </trans-unit>
        <trans-unit id="be140f9c425b22d10787335e62d9c0f4bf2df955" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process life cycle.</source>
          <target state="translated">该模块自动包含&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; 中&lt;/a&gt;定义的所有回调。有关 &lt;code&gt;setup&lt;/code&gt; ， &lt;code&gt;start_supervised&lt;/code&gt; ， &lt;code&gt;on_exit&lt;/code&gt; 和测试过程生命周期的更多信息，请参见该模块。</target>
        </trans-unit>
        <trans-unit id="a6257d1fd58c649338860fae4d9c7189fabdb3f2" translate="yes" xml:space="preserve">
          <source>This module complements Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt; to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</source>
          <target state="translated">此模块是对Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 模块&lt;/a&gt;的补充，以添加特定于Elixir的行为。此模块中的几乎所有功能都对Elixir的行为产生全局副作用。</target>
        </trans-unit>
        <trans-unit id="653ac253ebf8eeb2f4ad27098db4993bb2625263" translate="yes" xml:space="preserve">
          <source>This module contains a set of assertion functions that are imported by default into your test cases.</source>
          <target state="translated">这个模块包含了一组默认导入测试用例的断言函数。</target>
        </trans-unit>
        <trans-unit id="922f087298c98adf032ad8b0ed4a5b0046285656" translate="yes" xml:space="preserve">
          <source>This module contains functions to manipulate files.</source>
          <target state="translated">该模块包含操作文件的功能。</target>
        </trans-unit>
        <trans-unit id="999b5229e2658017fe9fe551f8ab83bda85a2221" translate="yes" xml:space="preserve">
          <source>This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour:</source>
          <target state="translated">这个模块包含三个编译和评估文件的函数。下面是它们的摘要和行为。</target>
        </trans-unit>
        <trans-unit id="6edd43c8bb392184539818160b2c1a73b42dd599" translate="yes" xml:space="preserve">
          <source>This module defines a behaviour for providing time zone data.</source>
          <target state="translated">该模块定义了提供时区数据的行为。</target>
        </trans-unit>
        <trans-unit id="fc612a9ae903e6387df477d371e55523892dcb6f" translate="yes" xml:space="preserve">
          <source>This module defines a supervisor which can be used to dynamically supervise tasks.</source>
          <target state="translated">该模块定义了一个监督器,可以用来动态监督任务。</target>
        </trans-unit>
        <trans-unit id="ff54a5422bbcc14ae0339cf9003ae87e696322e7" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;a href=&quot;#setup/1&quot;&gt;&lt;code&gt;setup/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup/2&quot;&gt;&lt;code&gt;setup/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#setup_all/2&quot;&gt;&lt;code&gt;setup_all/2&lt;/code&gt;&lt;/a&gt; callbacks, as well as the &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">此模块定义&lt;a href=&quot;#setup/1&quot;&gt; &lt;code&gt;setup/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setup/2&quot;&gt; &lt;code&gt;setup/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#setup_all/2&quot;&gt; &lt;code&gt;setup_all/2&lt;/code&gt; &lt;/a&gt;回调，以及&lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="7bb87d9bb4c75afab1fe54071112deb7c5a60247" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour for a Mix task that does compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adca2c4f19b234afbf1c3981b55410081f195e79" translate="yes" xml:space="preserve">
          <source>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</source>
          <target state="translated">本模块定义了在Elixir中使用日历、日期、时间和日期时间的职责。</target>
        </trans-unit>
        <trans-unit id="1b157bc741bdfd8ba6ae8d42ded3b63cf4cd77d7" translate="yes" xml:space="preserve">
          <source>This module implements the functionality described in &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;&quot;Strictly Pretty&quot; (2000) by Christian Lindig&lt;/a&gt; with small additions, like support for binary nodes and a break mode that maximises use of horizontal space.</source>
          <target state="translated">该模块实现了&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Christian Lindig&lt;/a&gt;在&amp;ldquo; Strictly Pretty&amp;rdquo;（2000年）中描述的功能，并增加了一些附加功能，例如对二进制节点的支持以及使水平空间的使用最大化的中断模式。</target>
        </trans-unit>
        <trans-unit id="112202a17c89837b3a647d3e666a456f2e4b078d" translate="yes" xml:space="preserve">
          <source>This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the &lt;code&gt;when&lt;/code&gt; operator. For example:</source>
          <target state="translated">该模块包括Elixir开发人员使用的内置防护。它们是一组预定义的函数和宏，可以增强模式匹配，通常在 &lt;code&gt;when&lt;/code&gt; 运算符之后调用。例如：</target>
        </trans-unit>
        <trans-unit id="cc9a3de9fefb0b3c084b5528aedf73062faf9707" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83714cee8828e8f9110c531415bac329978b2d35" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块，请改用&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="0495cc6d49a1f2bcfa929825091c762ee979f726" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the modules &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt;&lt;code&gt;Config.Reader&lt;/code&gt;&lt;/a&gt; from Elixir's standard library instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fd8da7254ec766067fc2237c8a6fbc5505757a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698253e94267be04646f8c090c390fb2cc54ab28" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="translated">不建议使用此模块。代替&lt;a href=&quot;#defcallback/1&quot;&gt; &lt;code&gt;defcallback/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#defmacrocallback/1&quot;&gt; &lt;code&gt;defmacrocallback/1&lt;/code&gt; &lt;/a&gt;，可以分别使用 &lt;code&gt;@callback&lt;/code&gt; 和 &lt;code&gt;@macrocallback&lt;/code&gt; 模块属性。有关这些属性的更多信息，请参见&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="fdf2b70f41d95f88ee9e4aeda784850c33cb6114" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use @callback and @macrocallback attributes instead.</source>
          <target state="translated">这个模块已经废弃了。使用@callback和@macrocallback属性代替。</target>
        </trans-unit>
        <trans-unit id="3d00a52e370b2dc890428ed554a01c357e7af552" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Config and Config.Reader instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c46dbb91fb819b2c0d1361c70dbb30920cffa0" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map instead.</source>
          <target state="translated">这个模块已经不适用了。使用Map代替。</target>
        </trans-unit>
        <trans-unit id="39e094eeeb209ce88d3bf96eb154f3cef16627e8" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map or Keyword modules instead.</source>
          <target state="translated">此模块已被废弃,请使用地图或关键字模块。使用地图或关键字模块代替。</target>
        </trans-unit>
        <trans-unit id="45cb95722786d1fc420f1550713942a3d2a40ee4" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use MapSet instead.</source>
          <target state="translated">这个模块已经废弃。使用MapSet代替。</target>
        </trans-unit>
        <trans-unit id="8bfe2ac5b2ad8a73d077417b66f5ed47d757f034" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e498b026f4f6f31e26916a4df3d6d96afaccb2" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d2e8897e9809b530aad6556d1d82b7d911062f" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块。请改用&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="ff61ace86ab234eb7df8bf6ecf37e092b5b0882a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块。请改用&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="51805cd79a5e913405d55c2dfa613daced6e0652" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="translated">该模块已被废弃。请使用 Supervisor 模块中概述的新的子规范。</target>
        </trans-unit>
        <trans-unit id="090a0510a4b709bb729894c57c0c587dc11055ba" translate="yes" xml:space="preserve">
          <source>This module is most commonly used to define application configuration, typically in &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">该模块最常用于定义应用程序配置，通常在 &lt;code&gt;config/config.exs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="2befac5116f60db9c19a013fd1aa9a67a87481ad" translate="yes" xml:space="preserve">
          <source>This module must be used in other modules as a way to configure and prepare them for testing.</source>
          <target state="translated">该模块必须在其他模块中使用,作为配置和准备测试的方式。</target>
        </trans-unit>
        <trans-unit id="5b22afa6be61052c1f9cdf8dac15ff3c336d6750" translate="yes" xml:space="preserve">
          <source>This module provides 3 main APIs for you to use:</source>
          <target state="translated">这个模块提供了3个主要的API供你使用。</target>
        </trans-unit>
        <trans-unit id="769d078447abaa6265ad7bb0de8a70d942cff612" translate="yes" xml:space="preserve">
          <source>This module provides a Mix shell implementation that uses the current process mailbox for communication instead of IO.</source>
          <target state="translated">该模块提供了一个Mix shell的实现,它使用当前进程邮箱来代替IO进行通信。</target>
        </trans-unit>
        <trans-unit id="97378d1871eb3d3c2cbd5fdcf8a5c1c351518c6d" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d141fedc9a9bf97077c1d4c4dd489c9b785e1b" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块提供了遍历其他结构（如元组和列表）的便捷功能。这些功能可以在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中所有与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;有关的功能和宏中使用。</target>
        </trans-unit>
        <trans-unit id="782a5e74e17fd10ef3053ba12c4f6db6d729bfdd" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for manipulating or retrieving file system paths.</source>
          <target state="translated">该模块提供了操作或检索文件系统路径的便利。</target>
        </trans-unit>
        <trans-unit id="da08bc2535ffa10b4ff19a553d1b9ea3a60095e8" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure.</source>
          <target state="translated">该模块为在编译时处理记录提供了便利,编译时的字段名用于操作元组,在元组的紧凑结构之上提供了快速操作。</target>
        </trans-unit>
        <trans-unit id="d8865f287fbd66961e8c5ed897c4cb1e98bb7854" translate="yes" xml:space="preserve">
          <source>This module provides data encoding and decoding functions according to &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;.</source>
          <target state="translated">该模块根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;提供数据编码和解码功能。</target>
        </trans-unit>
        <trans-unit id="775daee9805ae8be33fdd0d2d338cd5f646e58b6" translate="yes" xml:space="preserve">
          <source>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;.</source>
          <target state="translated">此模块提供用于处理URI的功能（例如，解析URI或编码查询字符串）。此模块中的功能根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1925b1b9c75dedb57897285758fc633fa67f4392" translate="yes" xml:space="preserve">
          <source>This module provides helper functions and defines the behaviour required by any source code manager (SCM) used by Mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975d761a831604643250ee0022304cbf208c888f" translate="yes" xml:space="preserve">
          <source>This module relies on this behaviour to ignore such invalid characters. For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; will return a correct result even if an invalid code point is fed into it.</source>
          <target state="translated">此模块依靠此行为来忽略此类无效字符。例如，即使将无效的代码点输入给&lt;a href=&quot;#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;，length / 1也将返回正确的结果。</target>
        </trans-unit>
        <trans-unit id="c0fcf25a6b73787d9a7e552929b18116ce2e70ec" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a3fd3d8cfc91e72f80f4c370ccf8f3a32b7b9d" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="translated">该模块使用字节大小计算剩余的空间。如果您的文档包含字符串，则需要将它们包装在&lt;a href=&quot;#string/1&quot;&gt; &lt;code&gt;string/1&lt;/code&gt; 中&lt;/a&gt;，然后使用&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;来预先计算文档的大小。</target>
        </trans-unit>
        <trans-unit id="bf6c5bbe802615e0aa5a1527fbeb868a3dd4e46f" translate="yes" xml:space="preserve">
          <source>This operation happens in constant time.</source>
          <target state="translated">这个操作是在恒定的时间内发生的。</target>
        </trans-unit>
        <trans-unit id="0323d90aa13d0480aa31c479eb72ceeb1afc3cbd" translate="yes" xml:space="preserve">
          <source>This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given &lt;code&gt;iodata&lt;/code&gt; is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation.</source>
          <target state="translated">该操作旨在与未经编码启动的&amp;ldquo;原始&amp;rdquo;设备一起使用。给定的 &lt;code&gt;iodata&lt;/code&gt; 将直接写入设备，而无需进行转换。有关IO数据的更多信息，请参见模块文档中的&amp;ldquo; IO数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="caa455aca538782e938e4b888f46d0efc72ad432" translate="yes" xml:space="preserve">
          <source>This operation is not recursive.</source>
          <target state="translated">这个操作不是递归的。</target>
        </trans-unit>
        <trans-unit id="6cf233431f4056abd018dbc95c859c52d627d1ab" translate="yes" xml:space="preserve">
          <source>This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on.</source>
          <target state="translated">这个操作可能很昂贵,因为它从文件系统中读取数据,解析梁文件,评估代码等。</target>
        </trans-unit>
        <trans-unit id="4ac87cbe297ccc151c1adeb864d9d02cdda18b09" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;enum#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="translated">此运算符（是宏）仅转换为对&lt;a href=&quot;enum#member?/2&quot;&gt; &lt;code&gt;Enum.member?/2&lt;/code&gt; &lt;/a&gt;的调用。上面的示例将转换为：</target>
        </trans-unit>
        <trans-unit id="dce7f3b5f6d1002f08c83e9f800ba97413046570" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331fe094cd09d757ad66d6f225117b31c709d88f" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For match comparison, use &lt;a href=&quot;#!==/2&quot;&gt;&lt;code&gt;!==/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">该运算符认为1和1.0相等。对于匹配比较，请使用&lt;a href=&quot;#!==/2&quot;&gt; &lt;code&gt;!==/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a93d5027785794a41da95cb35f0cd6d2acb007f9" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For stricter semantics, use &lt;a href=&quot;#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">该运算符认为1和1.0相等。对于更严格的语义，请改用&lt;a href=&quot;#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d9501c58df67371e18635ed16fc7a445f5df561" translate="yes" xml:space="preserve">
          <source>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</source>
          <target state="translated">这个运算符将左手边的表达式作为右手边函数调用的第一个参数引入。</target>
        </trans-unit>
        <trans-unit id="f341e422c93c5bb9c0446195cea1180bec59b5b7" translate="yes" xml:space="preserve">
          <source>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</source>
          <target state="translated">在Elixir中,这个操作符在两种不同的场合下使用。它在 typespecs 中用于指定变量、函数或类型本身的类型。</target>
        </trans-unit>
        <trans-unit id="0255b05dbc6a872386af8aa97dc81394e15f507f" translate="yes" xml:space="preserve">
          <source>This page describes the semantics of patterns and guards, where they are all allowed, and how to extend them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769404e29fd0d9c0c1b74fd982594f4931cda146" translate="yes" xml:space="preserve">
          <source>This protocol requires four functions to be implemented, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#slice/1&quot;&gt;&lt;code&gt;slice/1&lt;/code&gt;&lt;/a&gt;. The core of the protocol is the &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.</source>
          <target state="translated">该协议需要实现四个功能，&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#slice/1&quot;&gt; &lt;code&gt;slice/1&lt;/code&gt; &lt;/a&gt;。该协议的核心是&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;功能。所有其他功能作为数据结构的优化路径而存在，可以比线性时间更好地实现某些属性。</target>
        </trans-unit>
        <trans-unit id="fb7da1dc23c1e9f315adf4ca89a991f2f576c3b4" translate="yes" xml:space="preserve">
          <source>This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the &lt;code&gt;zip/1&lt;/code&gt; and &lt;code&gt;zip/2&lt;/code&gt; functions).</source>
          <target state="translated">该协议使用标记的元组在化简函数和实现该协议的数据类型之间交换信息。这样可以高效完成资源（例如文件）的枚举，同时还可以确保在枚举结束时将关闭资源。该协议还允许中止枚举，这在需要许多可枚举之间的交织时非常有用（如 &lt;code&gt;zip/1&lt;/code&gt; 和 &lt;code&gt;zip/2&lt;/code&gt; 函数中所示）。</target>
        </trans-unit>
        <trans-unit id="2a476c9109b8e7bd77f398d609ce8b45633486cf" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2faccf1f4cab6a9360849e0c4b192286433613" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="translated">从IO读取为UTF-8。&lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; &lt;/a&gt;出IO.binstream / 2以将IO作为原始二进制文件进行处理。</target>
        </trans-unit>
        <trans-unit id="fb3289e1168d746e447207053b10b0f0b058ccb5" translate="yes" xml:space="preserve">
          <source>This returns true if a task is marked as recursive and it is being executed inside an umbrella project.</source>
          <target state="translated">如果任务被标记为递归,并且在伞形项目中执行,则返回true。</target>
        </trans-unit>
        <trans-unit id="ea9af91069aa4c9d64215d6cd9db073871191b73" translate="yes" xml:space="preserve">
          <source>This section covers built-in attributes. However, attributes can also be used by developers or extended by libraries to support custom behaviour.</source>
          <target state="translated">本节介绍了内置属性。然而,属性也可以被开发者使用,或者被库扩展以支持自定义行为。</target>
        </trans-unit>
        <trans-unit id="cd8870a170daeec23154d49d471c2dd9485fac0a" translate="yes" xml:space="preserve">
          <source>This shortcut will be extremely useful as we build our project, allowing us to quickly iterate by running a single test.</source>
          <target state="translated">在我们构建项目的过程中,这个快捷方式将非常有用,它允许我们通过运行一个测试来快速迭代。</target>
        </trans-unit>
        <trans-unit id="bd1e1ed3f015a12c58d63db1a9d93b599be9e3dd" translate="yes" xml:space="preserve">
          <source>This structure is enough to compile our project:</source>
          <target state="translated">这个结构足以编译我们的项目。</target>
        </trans-unit>
        <trans-unit id="5aeacadd2f95dc684bd082e5479290a732535d0b" translate="yes" xml:space="preserve">
          <source>This syntax is very convenient as it can be nested arbitrarily:</source>
          <target state="translated">这种语法非常方便,因为它可以任意嵌套。</target>
        </trans-unit>
        <trans-unit id="a3f217bb694fd565ea5471a5519af65161e8bfcb" translate="yes" xml:space="preserve">
          <source>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</source>
          <target state="translated">这种语法反映了有效尺寸是由尺寸乘以单位给出的。</target>
        </trans-unit>
        <trans-unit id="d91886050dfd3b8b0ffcd36baeadec3113935150" translate="yes" xml:space="preserve">
          <source>This task also removes documentation and debugging chunks from the compiled &lt;code&gt;.beam&lt;/code&gt; files to reduce the size of the escript. If this is not desired, check the &lt;code&gt;:strip_beams&lt;/code&gt; option.</source>
          <target state="translated">此任务还从已编译的 &lt;code&gt;.beam&lt;/code&gt; 文件中删除文档和调试块，以减小escript的大小。如果不希望这样做，请检查 &lt;code&gt;:strip_beams&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="e372a4a60d70f77f44ec0d0a534418195e400445" translate="yes" xml:space="preserve">
          <source>This task attempts to detect if the project contains one of the following files and act accordingly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435e4488fd4c9f6223b1ef1bcd4f2e99c900fe4" translate="yes" xml:space="preserve">
          <source>This task consolidates all protocols in the code path and outputs the new binary files to the given directory. Defaults to &quot;_build/MIX_ENV/lib/YOUR_APP/consolidated&quot; for regular apps and &quot;_build/MIX_ENV/consolidated&quot; in umbrella projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4cda0b866fc4bd88710556e9ee176eb8201a71" translate="yes" xml:space="preserve">
          <source>This task guarantees the project and its dependencies are compiled and packages them inside an escript. Before invoking &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, it is only necessary to define a &lt;code&gt;:escript&lt;/code&gt; key with a &lt;code&gt;:main_module&lt;/code&gt; option in your &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">该任务确保项目及其依赖项被编译并将其打包在escript中。在调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;之前，只需要在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中使用 &lt;code&gt;:main_module&lt;/code&gt; 选项定义一个 &lt;code&gt;:escript&lt;/code&gt; 键：</target>
        </trans-unit>
        <trans-unit id="b4e94347be43d3ad1c1f8b54ecc6bc826651d565" translate="yes" xml:space="preserve">
          <source>This task guarantees this option is respected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0f25b9bb663d2e0c92536a5493fa56feb94b3f" translate="yes" xml:space="preserve">
          <source>This task is automatically invoked unless the project disables the &lt;code&gt;:consolidate_protocols&lt;/code&gt; option in their configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95bdbfd4b655866a594149ce367ef4e30f87be" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times to load different configs.</source>
          <target state="translated">这个任务会自动重新启用,所以可以多次调用它来加载不同的配置。</target>
        </trans-unit>
        <trans-unit id="60b7baa6b3d14e1c34ecb1ce263c22e53b326d02" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times with different arguments.</source>
          <target state="translated">这个任务是自动重新启用的,所以可以用不同的参数多次调用。</target>
        </trans-unit>
        <trans-unit id="26dd7e67f1b7b3ef5db86ff692753739683ca6d1" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times.</source>
          <target state="translated">这个任务会自动重新启用,所以可以多次调用。</target>
        </trans-unit>
        <trans-unit id="ee1da0440bde8a127669b55f6844894777d90f76" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can perform multiple cross reference checks in the same Mix invocation.</source>
          <target state="translated">这个任务会自动重新启用,所以你可以在同一个Mix调用中执行多个交叉引用检查。</target>
        </trans-unit>
        <trans-unit id="83f0ea3aa09fb8c86fe400793e6f276b65a06e3e" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can print information multiple times in the same Mix invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59102e430969db44aa9dbab5520c01e316dd3de5" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can profile multiple times in the same Mix invocation.</source>
          <target state="translated">这个任务会自动重新启用,所以你可以在同一个Mix调用中多次配置文件。</target>
        </trans-unit>
        <trans-unit id="092ef0d136b59efa09b303487e88d69e710c4f88" translate="yes" xml:space="preserve">
          <source>This task is never directly invoked from the command line, but it is rather used as building block by other tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ec3e34affdc5b118add6428766793ecf3c3afd" translate="yes" xml:space="preserve">
          <source>This task starts the current application, loads up &lt;code&gt;test/test_helper.exs&lt;/code&gt; and then requires all files matching the &lt;code&gt;test/**/*_test.exs&lt;/code&gt; pattern in parallel.</source>
          <target state="translated">此任务将启动当前应用程序，加载 &lt;code&gt;test/test_helper.exs&lt;/code&gt; ，然后要求并行匹配 &lt;code&gt;test/**/*_test.exs&lt;/code&gt; 模式的所有文件。</target>
        </trans-unit>
        <trans-unit id="1c60c4d233c9160c073150ba4ff8097d082b6e81" translate="yes" xml:space="preserve">
          <source>This task supports importing formatter configuration from dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d9fcf010b1211b86ea4237770d26b428fafb33" translate="yes" xml:space="preserve">
          <source>This time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt;, one extra test should run and successfully pass as long as the &lt;code&gt;bar@computer-name&lt;/code&gt; node is available.</source>
          <target state="translated">这次所有测试都通过了，ExUnit警告我们分布式测试被排除在外了。如果使用 &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt; 运行测试，则只要 &lt;code&gt;bar@computer-name&lt;/code&gt; 节点可用，就应该运行一项额外的测试并成功通过。</target>
        </trans-unit>
        <trans-unit id="477d833785327cf68017043ef90fe5f9da786575" translate="yes" xml:space="preserve">
          <source>This time is monotonically increasing and starts in an unspecified point in time.</source>
          <target state="translated">这个时间是单调递增的,并从一个不确定的时间点开始。</target>
        </trans-unit>
        <trans-unit id="d29fa001afdf2d6ca161492ebf202a329eec33bb" translate="yes" xml:space="preserve">
          <source>This time let&amp;rsquo;s add a &lt;code&gt;:distributed&lt;/code&gt; tag to &lt;code&gt;test/kv/router_test.exs&lt;/code&gt;:</source>
          <target state="translated">这次，我们将一个 &lt;code&gt;:distributed&lt;/code&gt; 标签添加到 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8a08500e8bc91707c167cbe26d52c3bd3806ea0d" translate="yes" xml:space="preserve">
          <source>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</source>
          <target state="translated">这个时间可以无限制地向前或向后调整,而且不是单调的。</target>
        </trans-unit>
        <trans-unit id="6d3ccee502b139d7db4ac43bc5181f6363d2dc18" translate="yes" xml:space="preserve">
          <source>This time the supervisor started a named registry, allowing us to create buckets without having to explicitly fetch the PID from the supervisor. You should also know how to make the registry crash again, without looking up its PID: give it a try.</source>
          <target state="translated">这次主管启动了一个命名的注册表,使我们可以创建桶,而不必明确地从主管那里获取PID。你应该也知道如何让注册表再次崩溃,而不需要查找它的PID:试一试。</target>
        </trans-unit>
        <trans-unit id="2674a77869b19062b86e06c05052e9cdedb0c192" translate="yes" xml:space="preserve">
          <source>This time, since our test relies on global data, we have not given &lt;code&gt;async: true&lt;/code&gt; to &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Furthermore, in order to guarantee our test is always in a clean state, we stop and start the &lt;code&gt;:kv&lt;/code&gt; application before each test. In fact, stopping the &lt;code&gt;:kv&lt;/code&gt; application even prints a warning on the terminal:</source>
          <target state="translated">这一次，因为我们的测试依赖于全局数据，我们没有给 &lt;code&gt;async: true&lt;/code&gt; 要 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 。此外，为了确保我们的测试始终处于干净状态，请在每次测试之前停止并启动 &lt;code&gt;:kv&lt;/code&gt; 应用程序。实际上，停止 &lt;code&gt;:kv&lt;/code&gt; 应用程序甚至会在终端上显示警告：</target>
        </trans-unit>
        <trans-unit id="c22b7275344f29b83a9a0084e4877ef048fc7831" translate="yes" xml:space="preserve">
          <source>This time, we have joined two aliases, defining the final alias &lt;code&gt;Hello.World&lt;/code&gt;.</source>
          <target state="translated">这次，我们加入了两个别名，定义了最终别名 &lt;code&gt;Hello.World&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b92fdce12a5311e4693203aaafe3726c0337e1b5" translate="yes" xml:space="preserve">
          <source>This tree means that &lt;code&gt;lib/a.ex&lt;/code&gt; depends on &lt;code&gt;lib/b.ex&lt;/code&gt; at compile time which then depends on &lt;code&gt;lib/c.ex&lt;/code&gt; at runtime. This is often problematic because if &lt;code&gt;lib/c.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; also has to recompile due to this indirect compile time dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2295ba054b7587077fd7b62e8108fca19b1176d6" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f412811fd9f81fa6e535feea04f5cd402448c56" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="translated">该元组遵循Elixir中通用引用的表达式结构，名称为第一个参数，某些关键字列表作为元数据为第二个，参数列表为第三个。在这种情况下，参数是别名&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和atom &lt;code&gt;:downcase&lt;/code&gt; 。远程调用中的第二个参数&lt;strong&gt;始终&lt;/strong&gt;是一个原子。</target>
        </trans-unit>
        <trans-unit id="7ecec438aa5cf5d56bd4c9ece80a8b63bd733893" translate="yes" xml:space="preserve">
          <source>This value will have no effect as the code was compiled to connect to &quot;db.local&quot;, which is mostly likely unavailable in the production environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09127719cfc463768ae7ae77dbace1cb3021f292" translate="yes" xml:space="preserve">
          <source>This way if you have a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for 2018-08-24 10:00:00 in UTC you can do:</source>
          <target state="translated">这样，如果您在一个时区中有一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，则可以在另一个时区中获得相同的时间。例如，如果您在哥本哈根有2018-08-24 10:00:00，并且想要在UTC中有2018-08-24 10:00:00的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="07671b087d75abe1588362cd61ce69e954d8e6a8" translate="yes" xml:space="preserve">
          <source>This will appear to the &lt;code&gt;node&lt;/code&gt; as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns &lt;code&gt;true&lt;/code&gt; if disconnection succeeds, otherwise &lt;code&gt;false&lt;/code&gt;. If the local node is not alive, the function returns &lt;code&gt;:ignored&lt;/code&gt;.</source>
          <target state="translated">这将对 &lt;code&gt;node&lt;/code&gt; 显示，好像本地节点已崩溃。此功能主要用于Erlang网络身份验证协议中。如果断开连接成功，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果本地节点未处于活动状态，则该函数返回 &lt;code&gt;:ignored&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3db39e63e0c8d60956e47f7856c88ea07f5720f2" translate="yes" xml:space="preserve">
          <source>This will cause the operating system process to exit with the status given by &lt;code&gt;integer&lt;/code&gt; while signaling all linked Erlang processes to politely shut down.</source>
          <target state="translated">这将导致操作系统进程以 &lt;code&gt;integer&lt;/code&gt; 给定的状态退出，同时发信号通知所有链接的Erlang进程以礼貌地关闭。</target>
        </trans-unit>
        <trans-unit id="932ec01a6dc27cb0bacb799b1bb13427b2604043" translate="yes" xml:space="preserve">
          <source>This will generate a file named &lt;code&gt;Elixir.Math.beam&lt;/code&gt; containing the bytecode for the defined module. If we start &lt;code&gt;iex&lt;/code&gt; again, our module definition will be available (provided that &lt;code&gt;iex&lt;/code&gt; is started in the same directory the bytecode file is in):</source>
          <target state="translated">这将生成一个名为 &lt;code&gt;Elixir.Math.beam&lt;/code&gt; 的文件，其中包含已定义模块的字节码。如果再次启动 &lt;code&gt;iex&lt;/code&gt; ，则模块定义将可用（前提是 &lt;code&gt;iex&lt;/code&gt; 在字节码文件所在的同一目录中启动）：</target>
        </trans-unit>
        <trans-unit id="8486c3ebf35a38d29570441bb6cd8b2ae73dbe68" translate="yes" xml:space="preserve">
          <source>This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e50caa68b186c476cfb0083912fddaf93761ce6" translate="yes" xml:space="preserve">
          <source>This won't work as it will rather try to invoke the local function &lt;code&gt;fun&lt;/code&gt;:</source>
          <target state="translated">这将不起作用，因为它将尝试调用局部函数 &lt;code&gt;fun&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="988a9f0b35eb11882e7b92d107c2e4d9a3c956cd" translate="yes" xml:space="preserve">
          <source>This works because accessing anything on a &lt;code&gt;nil&lt;/code&gt; value, returns &lt;code&gt;nil&lt;/code&gt; itself:</source>
          <target state="translated">之所以有效，是因为访问 &lt;code&gt;nil&lt;/code&gt; 值上的任何东西，本身都会返回 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="504c9c579f50eb0d399c3090d69552f011806877" translate="yes" xml:space="preserve">
          <source>This works because the &lt;code&gt;--partitions&lt;/code&gt; option automatically exports the coverage results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ae4006317b94bfaa968ed593d618d9dbca367b" translate="yes" xml:space="preserve">
          <source>This works:</source>
          <target state="translated">这个很管用</target>
        </trans-unit>
        <trans-unit id="35b2e50e251cc0ba39a82b26384abdc7366f7bc3" translate="yes" xml:space="preserve">
          <source>This would be repetitive to write every time we need this check, so, as mentioned at the beginning of this section, we can abstract this away using a macro. Remember that defining a function that performs this check wouldn't work because we can't use custom functions in guards. Use &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; to create guard macros. Here's an example:</source>
          <target state="translated">每次需要此检查时，这都是重复的，因此，如本节开头所述，我们可以使用宏将其抽象化。请记住，定义执行该检查的功能将不起作用，因为我们无法在后卫中使用自定义功能。使用 &lt;code&gt;defguard&lt;/code&gt; 和 &lt;code&gt;defguardp&lt;/code&gt; 创建保护宏。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="e6043c141b8f19b7be4caf31617881f52b255da5" translate="yes" xml:space="preserve">
          <source>This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it.</source>
          <target state="translated">这就相当于得到所有的文件内容,并将其全部打包成一行在IEx中执行。</target>
        </trans-unit>
        <trans-unit id="6ff1d4baf9340ffd06f6ffb996d0e212cbfa8737" translate="yes" xml:space="preserve">
          <source>Those are all protocols that ship with Elixir and they are being consolidated. Because a protocol can dispatch to any data type, the protocol must check on every call if an implementation for the given type exists. This may be expensive.</source>
          <target state="translated">这些都是Elixir附带的协议,它们正在被合并。因为一个协议可以调度到任何数据类型,所以协议必须在每次调用时检查是否存在给定类型的实现。这可能是昂贵的。</target>
        </trans-unit>
        <trans-unit id="20eb63dea1b46358d700b88edabba7314d37424c" translate="yes" xml:space="preserve">
          <source>Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST.</source>
          <target state="translated">这些构造只存在于语法层面。上面所有的例子在AST中都以它们的底层整数来表示。</target>
        </trans-unit>
        <trans-unit id="2a23b257e1a8396bae8e624da37c5fa4a14cd69d" translate="yes" xml:space="preserve">
          <source>Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.</source>
          <target state="translated">这些文件是并行编译的,可以自动检测它们之间的依赖关系。一旦发现依赖关系,当前文件就会停止编译,直到依赖关系解决为止。</target>
        </trans-unit>
        <trans-unit id="e697466781be26b9795959553f68c3100b1e1fc6" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).</source>
          <target state="translated">这些功能被优化为处理常见的纪元,如上面的Unix纪元或Gregorian纪元(0000-01-01 00:00:00)。</target>
        </trans-unit>
        <trans-unit id="c4de8ddc259e007e8ba142a7f915e7b9f301d071" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</source>
          <target state="translated">这些功能经过优化,可以处理常见的纪元,如上面的Unix纪元或Gregorian纪元(0000-01-01)。</target>
        </trans-unit>
        <trans-unit id="394d2aacfa0d4e93088c549af6bbb4449e2dc409" translate="yes" xml:space="preserve">
          <source>Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.</source>
          <target state="translated">这些函数将在其文档中明确标记为 &quot;编译器内联&quot;。</target>
        </trans-unit>
        <trans-unit id="63c1f7abeafa00aa21caec35b0a45a7d4562b860" translate="yes" xml:space="preserve">
          <source>Those options are shared across all modes:</source>
          <target state="translated">这些选项在所有模式中都是共享的。</target>
        </trans-unit>
        <trans-unit id="d6d6ce8d2fc67ab737881fd056832c2d5309c627" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7600e9dc66e9f49a5eef98b40a90050ef4b71a9b" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="translated">这些选项可以在项目配置文件中进行配置，也可以通过从 &lt;code&gt;~/.iex.exs&lt;/code&gt; 文件中调用&lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; 进行&lt;/a&gt;全局配置。例如：</target>
        </trans-unit>
        <trans-unit id="74a14ac9f70e4b2f7b26991bd0d257ac84bd9ed1" translate="yes" xml:space="preserve">
          <source>Those options mean all dependencies will be checked out to &lt;code&gt;kv_umbrella/deps&lt;/code&gt;, and they will share the same build, config and lock files. We haven&amp;rsquo;t talked about configuration yet, but from here we can build the intuition that all configuration and dependencies are shared across all projects in an umbrella, and it is not per application.</source>
          <target state="translated">这些选项意味着所有依赖项都将检出到 &lt;code&gt;kv_umbrella/deps&lt;/code&gt; ，并且它们将共享相同的构建，配置和锁定文件。我们还没有讨论过配置，但是从这里我们可以直觉，所有配置和依赖项在一个伞中跨所有项目共享，而不是针对每个应用程序。</target>
        </trans-unit>
        <trans-unit id="ff34978b55b28c6dbd12a23ca68d40a4861e6f90" translate="yes" xml:space="preserve">
          <source>Those performance characteristics dictate the usage of those data structures. One very common use case for tuples is to use them to return extra information from a function. For example, &lt;code&gt;File.read/1&lt;/code&gt; is a function that can be used to read file contents. It returns a tuple:</source>
          <target state="translated">这些性能特征决定了这些数据结构的使用。元组的一种非常常见的用例是使用它们从函数中返回额外的信息。例如， &lt;code&gt;File.read/1&lt;/code&gt; 是可用于读取文件内容的函数。它返回一个元组：</target>
        </trans-unit>
        <trans-unit id="c4f3c9a9eefe9427c2dedc41fe39d6f07ee20806" translate="yes" xml:space="preserve">
          <source>Those situations are quite uncommon in practice except when interfacing with libraries that do not provide a proper API. For example, let&amp;rsquo;s imagine the &lt;code&gt;Enum&lt;/code&gt; module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers:</source>
          <target state="translated">这些情况在实践中很少见，除非与不提供适当API的库接口时。例如，假设 &lt;code&gt;Enum&lt;/code&gt; 模块没有提供任何用于查找值的API，而我们需要在数字列表中查找13的第一个倍数：</target>
        </trans-unit>
        <trans-unit id="aad090c769c6e03a992f9e5138ceea80922ae0f4" translate="yes" xml:space="preserve">
          <source>Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, got familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.</source>
          <target state="translated">在整个指南中,我们构建了一个非常简单的分布式键值存储,以此为契机,我们探索了许多构造,如通用服务器、主管、任务、代理、应用等。不仅如此,我们还为整个应用程序编写了测试,熟悉了ExUnit,并学会了如何使用Mix构建工具来完成各种任务。</target>
        </trans-unit>
        <trans-unit id="d3b0d5df9824877f9b29731225c4ba90e068aada" translate="yes" xml:space="preserve">
          <source>Throughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions &lt;code&gt;hd/1&lt;/code&gt; and &lt;code&gt;tl/1&lt;/code&gt;. Let&amp;rsquo;s assign a list to a variable and retrieve its head and tail:</source>
          <target state="translated">在整个教程中，我们将大量讨论列表的开头和结尾。头部是列表的第一个元素，而尾部是列表的其余部分。可以使用功能 &lt;code&gt;hd/1&lt;/code&gt; 和 &lt;code&gt;tl/1&lt;/code&gt; 检索它们。让我们为变量分配一个列表并检索其头部和尾部：</target>
        </trans-unit>
        <trans-unit id="090c252d7880a95a839fb25bf07e4aad923532bf" translate="yes" xml:space="preserve">
          <source>Throughout this tutorial, we have been using the notation &lt;code&gt;name/arity&lt;/code&gt; to refer to functions. It happens that this notation can actually be used to retrieve a named function as a function type. Start &lt;code&gt;iex&lt;/code&gt;, running the &lt;code&gt;math.exs&lt;/code&gt; file defined above:</source>
          <target state="translated">在本教程中，我们一直使用符号 &lt;code&gt;name/arity&lt;/code&gt; 来表示函数。碰巧这种表示法实际上可以用于检索命名函数作为函数类型。启动 &lt;code&gt;iex&lt;/code&gt; ，运行上面定义的 &lt;code&gt;math.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="4dc17499006fce61c64e8dfd0c8c4c038df992f0" translate="yes" xml:space="preserve">
          <source>Time representations with reduced accuracy are not supported.</source>
          <target state="translated">不支持精度降低的时间表示。</target>
        </trans-unit>
        <trans-unit id="c9e59bfbdd7898eae663b5796d19938441eff8ed" translate="yes" xml:space="preserve">
          <source>Time units in its plural form, such as: &lt;code&gt;:seconds&lt;/code&gt;, &lt;code&gt;:milliseconds&lt;/code&gt;, and the like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb40cd5eccc115002264851e51de0dcee9fe00b" translate="yes" xml:space="preserve">
          <source>Time zone abbreviation (empty string if naive)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452a856dc424a6f92632b47f9b6540703986d72" translate="yes" xml:space="preserve">
          <source>Time zone database</source>
          <target state="translated">时区数据库</target>
        </trans-unit>
        <trans-unit id="dad962fdacc68e64400f9f34e93f5814f862947c" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</source>
          <target state="translated">时区偏移可以包含在字符串中,但它们将被直接丢弃,因为这些信息不包含在天真的日期时间中。</target>
        </trans-unit>
        <trans-unit id="55ded65dce8b65205b0b4f7c820bffa416a68f37" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</source>
          <target state="translated">时区偏移可以包含在字符串中,但它们将被直接丢弃,因为这些信息不包含在时间中。</target>
        </trans-unit>
        <trans-unit id="f905b9189d8d13ac7a8491eceeb00e40cf5247c7" translate="yes" xml:space="preserve">
          <source>Time zone period for a point in time in UTC for a specific time zone.</source>
          <target state="translated">以UTC为单位的某一特定时区时间点的时区周期。</target>
        </trans-unit>
        <trans-unit id="4ca2fde51c11eb446c9f4471c5d166e6cd917c52" translate="yes" xml:space="preserve">
          <source>Timeout is set to 0, so there is no waiting time.</source>
          <target state="translated">超时设置为0,所以没有等待时间。</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="25e1a3000b3069b54f62fa349e25e048a6ebb374" translate="yes" xml:space="preserve">
          <source>Tmp Dir</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b72f11edef4c0745d904f701fa487d703c27edf" translate="yes" xml:space="preserve">
          <source>To access atom keys, one may also use the &lt;code&gt;map.key&lt;/code&gt; notation. Note that &lt;code&gt;map.key&lt;/code&gt; will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; if the &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;, compared to &lt;code&gt;map[:key]&lt;/code&gt;, that would return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b3091799895b01e6aa24802a8c476d47d3c391" translate="yes" xml:space="preserve">
          <source>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</source>
          <target state="translated">为了符合Unicode标准,本模块中的许多函数都以线性时间运行,因为它们需要遍历整个字符串,考虑适当的Unicode码点。</target>
        </trans-unit>
        <trans-unit id="ce008b888ee0241e97659cba8355716eba5bef7f" translate="yes" xml:space="preserve">
          <source>To add a new key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916b5fa900a6f384af0597e7d8f402a05c3c1c1f" translate="yes" xml:space="preserve">
          <source>To aid in the correct implementation of behaviours, you may optionally declare &lt;code&gt;@impl&lt;/code&gt; for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:</source>
          <target state="translated">为了帮助正确实现行为，您可以选择为行为的已实现回调声明 &lt;code&gt;@impl&lt;/code&gt; 。这使回调变得显式，并可以帮助您捕获代码中的错误。在以下情况下，编译器将发出警告：</target>
        </trans-unit>
        <trans-unit id="688d49bd28e977f5619e4299defc87b3580ff416" translate="yes" xml:space="preserve">
          <source>To assert exits from linked processes started from the test, trap exits with &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt;&lt;code&gt;Process.flag/2&lt;/code&gt;&lt;/a&gt; and assert the exit message with &lt;a href=&quot;#assert_received/2&quot;&gt;&lt;code&gt;assert_received/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要声明从测试开始的链接进程的退出，陷阱将使用&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt; &lt;code&gt;Process.flag/2&lt;/code&gt; &lt;/a&gt;退出，并使用&lt;a href=&quot;#assert_received/2&quot;&gt; &lt;code&gt;assert_received/2&lt;/code&gt; &lt;/a&gt;声明退出消息。</target>
        </trans-unit>
        <trans-unit id="60dda8ca6a65152c1c53235c6221b24d765a7234" translate="yes" xml:space="preserve">
          <source>To avoid printing log messages during tests, ExUnit provides a neat feature called &lt;code&gt;:capture_log&lt;/code&gt;. By setting &lt;code&gt;@tag :capture_log&lt;/code&gt; before each test or &lt;code&gt;@moduletag :capture_log&lt;/code&gt; for the whole test case, ExUnit will automatically capture anything that is logged while the test runs. In case our test fails, the captured logs will be printed alongside the ExUnit report.</source>
          <target state="translated">为避免在测试期间打印日志消息，ExUnit提供了一个名为 &lt;code&gt;:capture_log&lt;/code&gt; 的简洁功能。通过设置 &lt;code&gt;@tag :capture_log&lt;/code&gt; 每次测试或之前 &lt;code&gt;@moduletag :capture_log&lt;/code&gt; 整个测试案例，ExUnit会自动捕获任何记录，而试运行。万一我们的测试失败，捕获的日志将与ExUnit报告一起打印。</target>
        </trans-unit>
        <trans-unit id="f974b60e8a8ca0fdff2c240dbeb8be96e5b7e1d4" translate="yes" xml:space="preserve">
          <source>To avoid that late answers (after the timeout) pollute the caller's message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process.</source>
          <target state="translated">为了避免延迟应答(超时后)污染呼叫者的消息队列,使用一个中间人进程来进行实际呼叫。迟来的应答在到达终止的进程时将被丢弃。</target>
        </trans-unit>
        <trans-unit id="915324fb4db3a9cfde09b72fdeb57083f3b6ada4" translate="yes" xml:space="preserve">
          <source>To be converted to a string, a list must either be empty or only contain the following elements:</source>
          <target state="translated">要转换为字符串,列表必须为空或只包含以下元素。</target>
        </trans-unit>
        <trans-unit id="e45579800e96aeff05376f3bbc05633e2fce0d09" translate="yes" xml:space="preserve">
          <source>To be precise, &lt;code&gt;nil&lt;/code&gt; is returned whenever a &lt;code&gt;pid&lt;/code&gt; or &lt;code&gt;{name, node}&lt;/code&gt; cannot be returned. Note there is no guarantee the returned &lt;code&gt;pid&lt;/code&gt; or &lt;code&gt;{name, node}&lt;/code&gt; is alive, as a process could terminate immediately after it is looked up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b6088332075b01c651b352f9aa53d48a4e4c87" translate="yes" xml:space="preserve">
          <source>To capture a definition within the current module, you can skip the module prefix, such as &lt;code&gt;&amp;amp;my_fun/2&lt;/code&gt;. In those cases, the captured function can be public (&lt;code&gt;def&lt;/code&gt;) or private (&lt;code&gt;defp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7a4b67b1cf2b13d1bec5831057b11f1a8ac991" translate="yes" xml:space="preserve">
          <source>To check the Unicode version of your current Elixir installation, run &lt;code&gt;String.Unicode.version()&lt;/code&gt;.</source>
          <target state="translated">要检查当前Elixir安装的Unicode版本，请运行 &lt;code&gt;String.Unicode.version()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32741725588800279ae172b79b44e5964f47f63a" translate="yes" xml:space="preserve">
          <source>To convert maps into keywords and vice-versa, use the &lt;code&gt;new&lt;/code&gt; function in the respective modules.</source>
          <target state="translated">要将地图转换为关键字，反之亦然，请在相应模块中使用 &lt;code&gt;new&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="90fe397a356898d27888dc41d52d7983ef57d2b2" translate="yes" xml:space="preserve">
          <source>To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="translated">要创建自定义 &lt;code&gt;sigil_{identifier}&lt;/code&gt; ，请定义一个名称为sigil_ {identifier}的函数，该函数带有两个参数。第一个参数是字符串，第二个参数是包含任何修饰符的字符列表。如果sigil是小写字母（例如 &lt;code&gt;sigil_x&lt;/code&gt; ），则字符串参数将允许插值。如果sigil是大写字母（例如 &lt;code&gt;sigil_X&lt;/code&gt; ），则不会插入字符串。</target>
        </trans-unit>
        <trans-unit id="bb585bff51bf0b0752f3b9643ada939cb21bacf2" translate="yes" xml:space="preserve">
          <source>To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (for function callbacks and macro callbacks respectively).</source>
          <target state="translated">要定义一个行为模块，在该模块中定义一个或多个回调就足够了。要定义回调，可以使用 &lt;code&gt;@callback&lt;/code&gt; 和 &lt;code&gt;@macrocallback&lt;/code&gt; 模块属性（分别用于函数回调和宏回调）。</target>
        </trans-unit>
        <trans-unit id="748c36f2db63d3a03dc4e6fadef52aac3b262d3c" translate="yes" xml:space="preserve">
          <source>To define a struct, a developer must define both &lt;code&gt;__struct__/0&lt;/code&gt; and &lt;code&gt;__struct__/1&lt;/code&gt; functions. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; is a convenience macro which defines such functions with some conveniences.</source>
          <target state="translated">要定义结构，开发人员必须同时定义 &lt;code&gt;__struct__/0&lt;/code&gt; 和 &lt;code&gt;__struct__/1&lt;/code&gt; 函数。&lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;是一个便利宏，它以一些便利来定义此类功能。</target>
        </trans-unit>
        <trans-unit id="5e46e68069cc59aab3678e72e8671077b9e1f5c1" translate="yes" xml:space="preserve">
          <source>To define a struct, the &lt;code&gt;defstruct&lt;/code&gt; construct is used:</source>
          <target state="translated">要定义一个结构，可以使用 &lt;code&gt;defstruct&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="15c7a0bd6bb05c83760ad9659631936c1f603b9d" translate="yes" xml:space="preserve">
          <source>To define an operator, you can use the usual &lt;code&gt;def*&lt;/code&gt; constructs (&lt;code&gt;def&lt;/code&gt;, &lt;code&gt;defp&lt;/code&gt;, &lt;code&gt;defmacro&lt;/code&gt;, and so on) but with a syntax similar to how the operator is used:</source>
          <target state="translated">要定义运算符，可以使用常用的 &lt;code&gt;def*&lt;/code&gt; 构造（ &lt;code&gt;def&lt;/code&gt; ， &lt;code&gt;defp&lt;/code&gt; ， &lt;code&gt;defmacro&lt;/code&gt; 等），但语法类似于使用运算符的方式：</target>
        </trans-unit>
        <trans-unit id="97bc558ded88de997eb4b20c7b44aa7a1d127e07" translate="yes" xml:space="preserve">
          <source>To deploy straight from a host to a separate target without cross-compilation, the following must be the same between the host and the target:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1416bbc268b001f44ff03e41dd657568db375a9" translate="yes" xml:space="preserve">
          <source>To determine how many seconds the &lt;code&gt;:native&lt;/code&gt; unit represents in your current runtime, you can can call this function to convert 1 second to the &lt;code&gt;:native&lt;/code&gt; time unit: &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt;.</source>
          <target state="translated">要确定 &lt;code&gt;:native&lt;/code&gt; 单位在当前运行时中所代表的秒数，可以调用此函数将1秒钟转换为 &lt;code&gt;:native&lt;/code&gt; 时间单位： &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb35bc4715abc885d6ad16dcca4ef00591e6ce0e" translate="yes" xml:space="preserve">
          <source>To differentiate the program behavior depending on the environment, it is recommended to use application environment through &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt;. Proper configuration can be set in config files, often per-environment (see the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module for more information).</source>
          <target state="translated">为了根据环境区分程序行为，建议通过&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; &lt;/a&gt;使用应用程序环境。可以在每个环境中的配置文件中设置正确的配置（有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;模块）。</target>
        </trans-unit>
        <trans-unit id="ade0297c81614f897441b308bffb7079cbf4b959" translate="yes" xml:space="preserve">
          <source>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</source>
          <target state="translated">要发现一个模块的公共功能或其他模块,键入模块名称后加一个点,然后按tab键触发自动完成。例如</target>
        </trans-unit>
        <trans-unit id="0f350e9537ca99b19347d61d7b15f4ba1b815fe4" translate="yes" xml:space="preserve">
          <source>To display &quot;What is your name?&quot; as a prompt and await user input:</source>
          <target state="translated">要显示 &quot;你叫什么名字?&quot;作为提示并等待用户输入。</target>
        </trans-unit>
        <trans-unit id="9392c58481cde14e24d585ca66473875cbcb0d13" translate="yes" xml:space="preserve">
          <source>To drive the point home, imagine you want to validate a certain attribute only if a given condition is met. We could easily achieve it with the first solution, by manipulating the data structure accordingly, or with the second solution by using conditionals (if/else) before invoking the function. However, it is impossible to do so with the macros approach unless its DSL is augmented.</source>
          <target state="translated">为了让大家明白这一点,想象一下,只有在满足给定条件的情况下,你才想验证某个属性。我们可以通过第一种解决方案,通过对数据结构进行相应的操作,或者通过在调用函数之前使用条件(if/else),轻松地实现这一目标。但是,用宏方法是不可能做到的,除非对其DSL进行增强。</target>
        </trans-unit>
        <trans-unit id="691c11ca8ab2ebe304045dcb2e0736f03a5a8a17" translate="yes" xml:space="preserve">
          <source>To dynamically supervise children, see &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7191bed803a12f545045cca3f35df2867866ca" translate="yes" xml:space="preserve">
          <source>To enable runtime configuration in your release, all you need to do is to create a file named &lt;code&gt;config/runtime.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fa53a2359799d77d9a3c808a0fe3f75458448c" translate="yes" xml:space="preserve">
          <source>To escape an EEx expression in EEx use &lt;code&gt;&amp;lt;%% content %&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842501ce37fce5610a16f26dd98d6da220a3b08e" translate="yes" xml:space="preserve">
          <source>To exit a breakpoint, the developer can either invoke &lt;code&gt;continue()&lt;/code&gt;, which will block the shell until the next breakpoint is found or the process terminates, or invoke &lt;code&gt;respawn()&lt;/code&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">要退出断点，开发人员可以调用 &lt;code&gt;continue()&lt;/code&gt; ，它将阻塞外壳程序，直到找到下一个断点或进程终止为止；或者可以调用 &lt;code&gt;respawn()&lt;/code&gt; ，后者启动一个新的IEx shell，以释放撬出的外壳程序。</target>
        </trans-unit>
        <trans-unit id="77caae61840ab6ad348e3ba1e35de2b7d3be118d" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s back to &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; and change the function and its callback as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c693fb70a5169722986ac65b4c67dfb305f68f" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s change the function and its callback as follows:</source>
          <target state="translated">要解决该故障，我们需要使用 &lt;code&gt;call/2&lt;/code&gt; 而不是 &lt;code&gt;cast/2&lt;/code&gt; 来使 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 同步。这将确保客户端仅在对表进行更改后才能继续。让我们如下更改函数及其回调：</target>
        </trans-unit>
        <trans-unit id="248a8954323fae01b279eb29892eb672151e34bd" translate="yes" xml:space="preserve">
          <source>To generate an app with a supervision tree and an application callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b84e64c358c14778edadcae30a553429d81661" translate="yes" xml:space="preserve">
          <source>To generate an umbrella application with sub applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1859a67f28b2dad5db51af942e1a02086e453015" translate="yes" xml:space="preserve">
          <source>To get individual options, see &lt;a href=&quot;#get_compiler_option/1&quot;&gt;&lt;code&gt;get_compiler_option/1&lt;/code&gt;&lt;/a&gt;. For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d939e666619b837bbfc72a19c0edb64540f7b914" translate="yes" xml:space="preserve">
          <source>To give the formatter a try, change a file in the &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; directories to include extra spaces or extra newlines, such as &lt;code&gt;def  hello  do&lt;/code&gt;, and then run &lt;code&gt;mix format&lt;/code&gt;.</source>
          <target state="translated">要尝试格式化程序，请在 &lt;code&gt;lib&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 目录中更改文件以包含额外的空格或额外的换行符，例如 &lt;code&gt;def hello do&lt;/code&gt; ，然后运行 &lt;code&gt;mix format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a15120dae8d76afe9639289d60fb9093810c397a" translate="yes" xml:space="preserve">
          <source>To help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny &lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;GenServer cheat sheet&lt;/a&gt;.</source>
          <target state="translated">为了帮助开发人员记住调用，&lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;强制转换&lt;/a&gt;和信息之间的差异，支持的返回值等等，我们提供了一个很小的GenServer备忘单。</target>
        </trans-unit>
        <trans-unit id="555a879eb773cd3d2dff7da0f2a52cb90ca0b876" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;Application&lt;/code&gt; behaviour, we have to &lt;code&gt;use Application&lt;/code&gt; and define a &lt;code&gt;start/2&lt;/code&gt; function. The goal of &lt;code&gt;start/2&lt;/code&gt; is to start a supervisor, which will then start any child services or execute any other code our application may need. Let&amp;rsquo;s use this opportunity to start the &lt;code&gt;KV.Supervisor&lt;/code&gt; we have implemented earlier in this chapter.</source>
          <target state="translated">要实现 &lt;code&gt;Application&lt;/code&gt; 行为，我们必须 &lt;code&gt;use Application&lt;/code&gt; 并定义一个 &lt;code&gt;start/2&lt;/code&gt; 函数。 &lt;code&gt;start/2&lt;/code&gt; 的目标是启动主管，然后主管将启动任何子服务或执行应用程序可能需要的任何其他代码。让我们利用这个机会来启动我们在本章前面实现的 &lt;code&gt;KV.Supervisor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4febdf906d953be4fd2821fd877395877b196fe9" translate="yes" xml:space="preserve">
          <source>To learn more about Elixir's AST and how to build them programmatically, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee64280d1fb25258cd437b5d0c77efe55acbd252" translate="yes" xml:space="preserve">
          <source>To learn more about IEx as a whole, type &lt;code&gt;h(IEx)&lt;/code&gt;.</source>
          <target state="translated">要总体上了解有关IEx的更多信息，请键入 &lt;code&gt;h(IEx)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699ef2c862a7af01ce3ea7b060fc68320ed60961" translate="yes" xml:space="preserve">
          <source>To learn more about floating-point arithmetic visit:</source>
          <target state="translated">要了解更多关于浮点运算的信息,请访问。</target>
        </trans-unit>
        <trans-unit id="101e8672c7193137af23129687e2ed29b0030ea4" translate="yes" xml:space="preserve">
          <source>To learn more about specific optimizations and performance considerations, check out &lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang's Efficiency Guide on handling binaries&lt;/a&gt;.</source>
          <target state="translated">要了解有关特定优化和性能注意事项的更多信息，请查看&lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang关于处理二进制文件的效率指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a32f6bfbd0a46a1fe8412990dabfb9a92464fbb" translate="yes" xml:space="preserve">
          <source>To list all IEx helpers available, which is effectively all exports (functions and macros) in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">要列出所有可用的IEx帮助器，实际上就是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块中的所有导出（函数和宏）：</target>
        </trans-unit>
        <trans-unit id="93e48689655deecbe42b747b91efa43959aec278" translate="yes" xml:space="preserve">
          <source>To list all available keys showing the keys themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bfde2bf5fe079fb8473d1b45bac69e05a6486e" translate="yes" xml:space="preserve">
          <source>To list all available keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e7dd0dfd16f5649cf89b74d291b7e7a795f96b" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f6e4a2bb843898b6a1a63430d9ad523188262e" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="translated">要分析代码，可以使用类似于&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;任务的语法：</target>
        </trans-unit>
        <trans-unit id="b90e482b9b75d2e1ab9c0ff8e4d1e0e5aecc5f06" translate="yes" xml:space="preserve">
          <source>To quote &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;the official guide on Macros&lt;/a&gt;:</source>
          <target state="translated">引用&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;有关宏的官方指南&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e5139cf2a16e17732e5bda38b6b67324152e536b" translate="yes" xml:space="preserve">
          <source>To reply after returning from the callback because the response is not yet available.</source>
          <target state="translated">在从回调中返回后回复,因为响应还没有到。</target>
        </trans-unit>
        <trans-unit id="716f6562922e06c13563ae83ce61a300e8352363" translate="yes" xml:space="preserve">
          <source>To reply before returning from the callback because the response is known before calling a slow function.</source>
          <target state="translated">要在从回调中返回之前回复,因为在调用慢速函数之前已经知道了响应。</target>
        </trans-unit>
        <trans-unit id="e57aadf0943d8ee32b1daf18536595cdf4b85435" translate="yes" xml:space="preserve">
          <source>To reply from another process, such as a task.</source>
          <target state="translated">从另一个进程(如任务)中回复。</target>
        </trans-unit>
        <trans-unit id="5ca8eab4577e8b135c578b17a24c88f164743db6" translate="yes" xml:space="preserve">
          <source>To retrieve all dates in descending order, you can wrap the module in a tuple with &lt;code&gt;:asc&lt;/code&gt; or &lt;code&gt;:desc&lt;/code&gt; as first element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b5421b45e250d1129a17a5d3f7268bca4e4081" translate="yes" xml:space="preserve">
          <source>To retrieve code points in their natural integer representation, see &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt;. For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa09c7d0058c95fdae6640e10ab83ae7e2c7d29c" translate="yes" xml:space="preserve">
          <source>To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">要检索当前进程的堆栈跟踪，请改用 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6478efdf0d6ae4efc7373afc872fb60986f2bb5" translate="yes" xml:space="preserve">
          <source>To run doctests include them in an ExUnit case with a &lt;code&gt;doctest&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9be81917be7c5a65d20c56cce5430337e7437a2" translate="yes" xml:space="preserve">
          <source>To run our doctests, we&amp;rsquo;ll create a file at &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; and call &lt;code&gt;doctest KVServer.Command&lt;/code&gt; in the test case:</source>
          <target state="translated">要运行doctest，我们将在 &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; 创建一个文件，并在测试用例中调用 &lt;code&gt;doctest KVServer.Command&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c550ca70984ac8e2f646e72f7f0c9faa1dd704b7" translate="yes" xml:space="preserve">
          <source>To run the tests above, run the file using &lt;code&gt;elixir&lt;/code&gt; from the command line. Assuming you named the file &lt;code&gt;assertion_test.exs&lt;/code&gt;, you can run it as:</source>
          <target state="translated">要运行上述测试，请从命令行使用 &lt;code&gt;elixir&lt;/code&gt; 运行文件。假设您将文件命名为 &lt;code&gt;assertion_test.exs&lt;/code&gt; ，则可以按以下方式运行它：</target>
        </trans-unit>
        <trans-unit id="e079c912f8f4dac650321807cd475663a5b52c69" translate="yes" xml:space="preserve">
          <source>To see an example of using module attributes as for storage, look no further than Elixir&amp;rsquo;s unit test framework called &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;. ExUnit uses module attributes for multiple different purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88b35a6396b6373f09d679595715d5f894666f2" translate="yes" xml:space="preserve">
          <source>To see documentation for each specific compiler, you must invoke &lt;code&gt;help&lt;/code&gt; directly for the compiler command:</source>
          <target state="translated">要查看每个特定编译器的文档，必须直接为编译器命令调用 &lt;code&gt;help&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7fcc2e5f60178276dfc7759916301cae9d1d546f" translate="yes" xml:space="preserve">
          <source>To show all entries, configure the limit to &lt;code&gt;:infinity&lt;/code&gt;:</source>
          <target state="translated">要显示所有条目，请将限制配置为 &lt;code&gt;:infinity&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6d46460a95ec8fd91d8032b072da8de876729d16" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can again look at the implementation for &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50964644227148ad32fc703cd3d520d71c70f6b" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can take again a look at the implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;mapset#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了展示如何实现该协议，我们可以再次看看&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;的实现。在此实现中，&amp;ldquo;收集&amp;rdquo;元素仅意味着通过&lt;a href=&quot;mapset#put/2&quot;&gt; &lt;code&gt;MapSet.put/2&lt;/code&gt; &lt;/a&gt;将它们插入到集合中。</target>
        </trans-unit>
        <trans-unit id="987c795e4ee5f17f665e41830d152e223b2b4556" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baefde74a3b1948259d37f28d66b2da3cc95503" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了展示如何手动使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议，让我们&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="5683b1948dc754efdfed9ba11dc087a421c0449e" translate="yes" xml:space="preserve">
          <source>To specify that a module implements a given behaviour, the &lt;code&gt;@behaviour&lt;/code&gt; attribute must be used:</source>
          <target state="translated">要指定模块实现给定的行为，必须使用 &lt;code&gt;@behaviour&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="e0fee1e5263eb41b6e360a95cfaf76805e6190b5" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">要启动管理程序，将在给定 &lt;code&gt;module&lt;/code&gt; 中使用 &lt;code&gt;arg&lt;/code&gt; 作为其参数调用&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调。在&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调必须返回可与的帮助下创建了一个主管规格&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="340467355095ab2102cf53f317a261f28f43cfa1" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;init_arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">要启动管理程序，将在给定 &lt;code&gt;module&lt;/code&gt; 中使用 &lt;code&gt;init_arg&lt;/code&gt; 作为其参数调用&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调。在&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调必须返回可与的帮助下创建了一个主管规格&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="ea3cc861aafddb9c5584732baff0a5d8fc163c1d" translate="yes" xml:space="preserve">
          <source>To store individual options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;. For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd659c0fd4a88cb66bdff02f16f40278b81dd1f" translate="yes" xml:space="preserve">
          <source>To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions.</source>
          <target state="translated">总结一下:由于格式化器不能改变代码的语义,所以有时需要调整或重构代码以获得最佳的格式化。为了帮助更好地理解如何控制格式化器,我们在接下来的章节中描述格式化器保留用户编码的情况以及如何控制多行表达式。</target>
        </trans-unit>
        <trans-unit id="dc5e717b9aecb2c9e25ade231bba83d35b0f1df7" translate="yes" xml:space="preserve">
          <source>To this point, we have been starting &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;. Typically the registry is started as part of a supervision tree though:</source>
          <target state="translated">至此，我们已经使用&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;启动&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;。通常，注册表是作为监督树的一部分启动的：</target>
        </trans-unit>
        <trans-unit id="16500310cbb3ebb314cb2217a6e54228c69e7280" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69493266441ce87de2c6a579e769590bf4ddfcf" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="translated">要跟踪您的代码与任务之间的关系，我们在流程字典中使用 &lt;code&gt;$callers&lt;/code&gt; 键。因此，假设上面有&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;调用，我们有：</target>
        </trans-unit>
        <trans-unit id="4d8cdd3c2f7959e04910020a7c04a125591711d6" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac68b9ffcf6a8ac8be05349df7088ceecbb4122" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97175bd03b3eda9bcbde862759fc67493bd67482" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">要在测试期间使用&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;，您需要在 &lt;code&gt;iex&lt;/code&gt; 命令中运行 &lt;code&gt;mix&lt;/code&gt; 并传递 &lt;code&gt;--trace&lt;/code&gt; 来进行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;以避免超时：</target>
        </trans-unit>
        <trans-unit id="ad497a0e7b4707958b2bbdf25658f61ced2eef66" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">要在测试过程中使用&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，您需要在 &lt;code&gt;iex&lt;/code&gt; 命令中运行 &lt;code&gt;mix&lt;/code&gt; 并传递 &lt;code&gt;--trace&lt;/code&gt; 来进行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;以避免超时：</target>
        </trans-unit>
        <trans-unit id="525e76db8eaa15a02d475c0b25c1748678200a4e" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;:keep&lt;/code&gt; with a type other than &lt;code&gt;:string&lt;/code&gt;, use a list as the type for the switch. For example: &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt;.</source>
          <target state="translated">要使用 &lt;code&gt;:keep&lt;/code&gt; 而不是 &lt;code&gt;:string&lt;/code&gt; 的类型，请使用列表作为开关的类型。例如： &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b67f756b7a47a192314501d13fc2788976f1a9c" translate="yes" xml:space="preserve">
          <source>To use the newly defined operators, we &lt;strong&gt;have to&lt;/strong&gt; import the module that defines them:</source>
          <target state="translated">要使用新定义的运算符，我们&lt;strong&gt;必须&lt;/strong&gt;导入定义它们的模块：</target>
        </trans-unit>
        <trans-unit id="2c8de6b1ffba1e94f756b45cb853dd0d24f391d0" translate="yes" xml:space="preserve">
          <source>To use them, first make sure it is added as a dependency in &lt;code&gt;mix.exs&lt;/code&gt;. It can then be configured either via configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e084ee0583dab5cdb8f2aaa6336b9ae8900f06" translate="yes" xml:space="preserve">
          <source>To work around this error, redefine the field with your own &amp;amp;M.f/a function, like so:</source>
          <target state="translated">要变通解决此错误，请使用您自己的＆M.f / a函数重新定义该字段，如下所示：</target>
        </trans-unit>
        <trans-unit id="123be2f9bdd25b0f49703cfe940d72bfca8fdce4" translate="yes" xml:space="preserve">
          <source>TokenMissingError</source>
          <target state="translated">TokenMissingError</target>
        </trans-unit>
        <trans-unit id="42d5db27696210e57467dc675285521f0930aa67" translate="yes" xml:space="preserve">
          <source>TokenMissingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TokenMissingError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="cd770bf19fa776a62cbc130cb90d8f5cd6a0b438" translate="yes" xml:space="preserve">
          <source>Tools like Mix may use this information to ensure the module is recompiled in case any of the external resources change.</source>
          <target state="translated">像Mix这样的工具可能会使用这些信息来确保模块在任何外部资源发生变化时被重新编译。</target>
        </trans-unit>
        <trans-unit id="71f3b1bc352a87eabb6f98c3505cc5cd7766eaec" translate="yes" xml:space="preserve">
          <source>Tools may use this information to ensure the module is recompiled in case any of the external resources change, see for example: &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt;&lt;code&gt;mix compile.elixir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77431b38c8bb01a363da5bccdb519bd75745358b" translate="yes" xml:space="preserve">
          <source>Trailing bang (&lt;code&gt;foo!&lt;/code&gt;)</source>
          <target state="translated">尾随爆炸（ &lt;code&gt;foo!&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ff6cffeaff58c52204a5122da57dc4b26f381da0" translate="yes" xml:space="preserve">
          <source>Trailing question mark (&lt;code&gt;foo?&lt;/code&gt;)</source>
          <target state="translated">尾随问号（ &lt;code&gt;foo?&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b7a933d6378a29d15a7b6795f6516bd8c8f0c0ab" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream with function-based start and finish.</source>
          <target state="translated">用基于函数的开始和结束来转换一个现有的流。</target>
        </trans-unit>
        <trans-unit id="0183630f154b045739040c0a476db00c0d8d8489" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream.</source>
          <target state="translated">改造现有的流。</target>
        </trans-unit>
        <trans-unit id="a0bf22bc28c174dfbe4750edd483edd80c1c1f1c" translate="yes" xml:space="preserve">
          <source>Translates to:</source>
          <target state="translated">译为:</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="eb726f366153f5273c287e7afe4de066bacf45f4" translate="yes" xml:space="preserve">
          <source>Traverses paths according to the given &lt;code&gt;glob&lt;/code&gt; expression and returns a list of matches.</source>
          <target state="translated">根据给定的 &lt;code&gt;glob&lt;/code&gt; 表达式遍历路径并返回匹配项列表。</target>
        </trans-unit>
        <trans-unit id="2b9bae059da0df068a9a43bf70813a2cc0165c80" translate="yes" xml:space="preserve">
          <source>Tries to create the directory &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试创建目录 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1274a0f5d2ed4698598c860012ff8d0e34e7aeca" translate="yes" xml:space="preserve">
          <source>Tries to delete the dir at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试删除 &lt;code&gt;path&lt;/code&gt; 中的目录。</target>
        </trans-unit>
        <trans-unit id="79494b7d121b41ed702af12c8820f16d4b440ca4" translate="yes" xml:space="preserve">
          <source>Tries to delete the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试删除文件 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7267f3b3b246e3958379e99f6b106bc8021e929a" translate="yes" xml:space="preserve">
          <source>Tries to set up a connection to node.</source>
          <target state="translated">试图建立与节点的连接。</target>
        </trans-unit>
        <trans-unit id="836d86c6c848f493d3ff2e48bb6f5f308c9c411f" translate="yes" xml:space="preserve">
          <source>Truthy and falsy values</source>
          <target state="translated">真实和虚假的价值观</target>
        </trans-unit>
        <trans-unit id="a0d62e00a429e56556bf1455c0175bc4654fbf2a" translate="yes" xml:space="preserve">
          <source>Truthy values:</source>
          <target state="translated">真理价值。</target>
        </trans-unit>
        <trans-unit id="ccf6e0cd6e8c63d5ae42d6c2569741d54c61f4d5" translate="yes" xml:space="preserve">
          <source>Try to connect two telnet clients at the same time. When you do so, you will notice that the second client doesn&amp;rsquo;t echo:</source>
          <target state="translated">尝试同时连接两个telnet客户端。这样做时，您会注意到第二个客户端没有回显：</target>
        </trans-unit>
        <trans-unit id="965b5b1e76f73cc1dd48f82e36854d491ebbe607" translate="yes" xml:space="preserve">
          <source>TryClauseError</source>
          <target state="translated">TryClauseError</target>
        </trans-unit>
        <trans-unit id="bb04413eca53d9d4f9ada422b12b458b1a19dc69" translate="yes" xml:space="preserve">
          <source>TryClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TryClauseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3d6d3a96a93234d43a687b1131b3901f142d46c" translate="yes" xml:space="preserve">
          <source>Trying to access an attribute that was not defined will print a warning:</source>
          <target state="translated">试图访问一个未定义的属性会打印一个警告。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="dc4f3a01c46fc5525a4e91e907b957d6688cd48a" translate="yes" xml:space="preserve">
          <source>Tuple describing the client of a call request.</source>
          <target state="translated">描述调用请求的客户端的元组。</target>
        </trans-unit>
        <trans-unit id="eb4abd3a92bef73903da00d10d474ba4501f6bab" translate="yes" xml:space="preserve">
          <source>Tuple-based HashDict implementation.</source>
          <target state="translated">基于Tuple的HashDict实现。</target>
        </trans-unit>
        <trans-unit id="91c1b6c09400f880e21ca1e3d43c7f7b3443b423" translate="yes" xml:space="preserve">
          <source>Tuple-based HashSet implementation.</source>
          <target state="translated">基于Tuple的HashSet实现。</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="a76966417cbfeb7cb220fffc01419f6c11debbd2" translate="yes" xml:space="preserve">
          <source>Tuples are a compound type and each tuple is identified by the types inside it (in this case, a number and a string). To understand why &lt;code&gt;String.t&lt;/code&gt; is not written as &lt;code&gt;string&lt;/code&gt;, have another look at the &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#the-string-type&quot;&gt;typespecs docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793259df3cfbea29ea94e801a3dc852ba0481364" translate="yes" xml:space="preserve">
          <source>Tuples are compared by size, then element by element.</source>
          <target state="translated">图元组按大小比较,然后按元素比较。</target>
        </trans-unit>
        <trans-unit id="cbb1dd7716c923dc57835e6545295dd3e5141a82" translate="yes" xml:space="preserve">
          <source>Tuples are denoted with curly braces:</source>
          <target state="translated">图元组用大括号表示。</target>
        </trans-unit>
        <trans-unit id="f9d295b48169d12e8a4a885f2969f7ebb5f288bf" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="translated">元组旨在用作多个元素的固定大小的容器。要操作元素集合，请改用列表。&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;函数不适用于元组。</target>
        </trans-unit>
        <trans-unit id="9c44772da431d393d0ff2d0292ec743fdb504db7" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6007daf5620486dbca1cb7e87969100af322cc9f" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="translated">元组通常在函数具有多个返回值或用于错误处理时使用。如果成功读取给定文件，则&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;{:ok, contents}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 例如文件不存在时）。</target>
        </trans-unit>
        <trans-unit id="c05d54cdc90ebeef0a2917964fc5bc31fa686547" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db66b3f610de5841b308865fc05862649e3b269d" translate="yes" xml:space="preserve">
          <source>Tuples have their own representation, except for two-element tuples, which are represented as themselves:</source>
          <target state="translated">除了双元素元组外,其他元组都有自己的表示方式。</target>
        </trans-unit>
        <trans-unit id="c8f2c5c5f76542db20a27b0649c5619472b41e0e" translate="yes" xml:space="preserve">
          <source>Tuples may appear in patterns using the curly brackets syntax (&lt;code&gt;{}&lt;/code&gt;). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d23bff74f82a432abab310b02bda096c901d05c" translate="yes" xml:space="preserve">
          <source>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:</source>
          <target state="translated">图元组在内存中连续地存储元素。这意味着通过索引访问一个元组元素或获取元组大小是一个快速的操作。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="4827be384e5b92dfa89593fd34e759c469d83f68" translate="yes" xml:space="preserve">
          <source>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:</source>
          <target state="translated">另一方面,Tuple在内存中是连续存储的。这意味着获取元组大小或通过索引访问元素的速度很快。然而,更新或添加元素到元组是昂贵的,因为它需要在内存中创建一个新的元组。</target>
        </trans-unit>
        <trans-unit id="c4eeec2166369454fe72d485310480999d9e41ff" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node.</source>
          <target state="translated">将一个分布式节点变成一个非分布式节点。</target>
        </trans-unit>
        <trans-unit id="78cb13dab8abb15c4418dcf574cee609f60fff10" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node.</source>
          <target state="translated">将一个非分布式节点变成分布式节点。</target>
        </trans-unit>
        <trans-unit id="0d200b5cca6122d2ea47ef95bc1ae207e6bed360" translate="yes" xml:space="preserve">
          <source>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">如果两个关键字包含相同的键,并且这些键包含相同的值,则认为它们是相等的。</target>
        </trans-unit>
        <trans-unit id="ef661032731cfceb2a4bb6e8a73cfcacce40a182" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddf4faa5ad6ac7c7817431eda4bde5737ecc7a7" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="translated">可以使用&lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#--/2&quot;&gt; &lt;code&gt;Kernel.--/2&lt;/code&gt; &lt;/a&gt;运算符来连接和减去两个列表：</target>
        </trans-unit>
        <trans-unit id="c6eb24ea9f355df425e35046856649369306137b" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated or subtracted using the &lt;code&gt;++/2&lt;/code&gt; and &lt;code&gt;--/2&lt;/code&gt; operators respectively:</source>
          <target state="translated">可以分别使用 &lt;code&gt;++/2&lt;/code&gt; 和 &lt;code&gt;--/2&lt;/code&gt; 运算符来连接或减去两个列表：</target>
        </trans-unit>
        <trans-unit id="28dd04de329219b61258e459b05052b6d195ed8c" translate="yes" xml:space="preserve">
          <source>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">如果两个地图包含相同的键,并且这些键包含相同的值,则被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="130c35a2878e328189066b98bf54e31f721289db" translate="yes" xml:space="preserve">
          <source>Type &amp;ldquo;hello&amp;rdquo;, press enter, and you will get &amp;ldquo;hello&amp;rdquo; back. Excellent!</source>
          <target state="translated">输入&amp;ldquo; hello&amp;rdquo;，按Enter，您将返回&amp;ldquo; hello&amp;rdquo;。优秀的！</target>
        </trans-unit>
        <trans-unit id="e252ef20859612096fbf35e99f3db43d0d903502" translate="yes" xml:space="preserve">
          <source>Type checks and other boolean checks that are allowed in guard clauses are named with an &lt;code&gt;is_&lt;/code&gt; prefix.</source>
          <target state="translated">保护子句中允许的类型检查和其他布尔检查使用 &lt;code&gt;is_&lt;/code&gt; 前缀命名。</target>
        </trans-unit>
        <trans-unit id="63885d680ea99a25f2552e75b805c2d3723587d4" translate="yes" xml:space="preserve">
          <source>Type operator. Used by types and bitstrings to specify types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a99d47d96ec4a8d262432fdeeb24d34842d1c" translate="yes" xml:space="preserve">
          <source>Type specifications (sometimes referred to as &lt;em&gt;typespecs&lt;/em&gt;) are defined in different contexts using the following attributes:</source>
          <target state="translated">使用以下属性在不同的上下文中定义类型规范（有时称为&lt;em&gt;typespecs&lt;/em&gt;）：</target>
        </trans-unit>
        <trans-unit id="c6f295ce9af290691ba77bd28066b72b6d97e560" translate="yes" xml:space="preserve">
          <source>Type variables with no restriction can also be defined using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">无限制的类型变量也可以使用 &lt;code&gt;var&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="9c292c75a9bfb2deb75a816df8b4fa93d8b86cdf" translate="yes" xml:space="preserve">
          <source>Types and specs</source>
          <target state="translated">类型和规格</target>
        </trans-unit>
        <trans-unit id="cd76b0391fb1a7a64c931e4a4dc1d98639420e28" translate="yes" xml:space="preserve">
          <source>Types and their syntax</source>
          <target state="translated">类型及其语法</target>
        </trans-unit>
        <trans-unit id="0bc4703b28f4924a9c44bceee00bf1363064b5ea" translate="yes" xml:space="preserve">
          <source>Types can be defined for tuples with the &lt;code&gt;record/2&lt;/code&gt; macro (only available in typespecs). This macro will expand to a tuple as seen in the example below:</source>
          <target state="translated">可以使用 &lt;code&gt;record/2&lt;/code&gt; 宏为元组定义类型（仅在typespec中可用）。如下例所示，该宏将扩展为元组：</target>
        </trans-unit>
        <trans-unit id="aa2e6017cafdcec12ffadda705782bbfa3365007" translate="yes" xml:space="preserve">
          <source>Types can be parameterized by defining variables as parameters; these variables can then be used to define the type.</source>
          <target state="translated">类型可以通过定义变量作为参数进行参数化;然后这些变量可以用来定义类型。</target>
        </trans-unit>
        <trans-unit id="9642fee222699c21f35d30c296f0220d194b3b26" translate="yes" xml:space="preserve">
          <source>Typespec attributes</source>
          <target state="translated">Typespec属性</target>
        </trans-unit>
        <trans-unit id="ec4586f03bdf53faaacd4a0a1f5bfd0f6c72e82a" translate="yes" xml:space="preserve">
          <source>Typespecs</source>
          <target state="translated">Typespecs</target>
        </trans-unit>
        <trans-unit id="12ee67883b50a8a9b8616d935b79570fd90fb391" translate="yes" xml:space="preserve">
          <source>Typespecs and behaviours</source>
          <target state="translated">类型规格和行为</target>
        </trans-unit>
        <trans-unit id="426efe2f128e5103f26a5651730adbe39dfe3a7f" translate="yes" xml:space="preserve">
          <source>Typespecs are not only useful to developers as additional documentation. The Erlang tool &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;Dialyzer&lt;/a&gt;, for example, uses typespecs in order to perform static analysis of code. That&amp;rsquo;s why, in the &lt;code&gt;QuietCalculator&lt;/code&gt; example, we wrote a spec for the &lt;code&gt;make_quiet/1&lt;/code&gt; function even though it was defined as a private function.</source>
          <target state="translated">Typespecs作为附加文档不仅对开发人员有用。Erlang的工具&lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;透析器&lt;/a&gt;，例如，使用typespecs为了执行的代码的静态分析。这就是为什么在 &lt;code&gt;QuietCalculator&lt;/code&gt; 示例中，我们为 &lt;code&gt;make_quiet/1&lt;/code&gt; 函数编写了一个规范，即使它被定义为私有函数也是如此。</target>
        </trans-unit>
        <trans-unit id="27a01a6204a37c38992dd52cc20fa3db2b61cbf1" translate="yes" xml:space="preserve">
          <source>Typical error reasons are the same as in &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#read/1&quot;&gt;&lt;code&gt;read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#write/3&quot;&gt;&lt;code&gt;write/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">典型的错误原因与&lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#read/1&quot;&gt; &lt;code&gt;read/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#write/3&quot;&gt; &lt;code&gt;write/3&lt;/code&gt; 相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">典型的错误原因有:</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">典型的错误原因。</target>
        </trans-unit>
        <trans-unit id="29820537aaefd464fe53b0df62deac28df35005d" translate="yes" xml:space="preserve">
          <source>Typically called after formatting when the data cannot be printed.</source>
          <target state="translated">当数据不能被打印时,通常在格式化后调用。</target>
        </trans-unit>
        <trans-unit id="0018f0d1c5a28ac0ba1af21c25d258db67bae7ff" translate="yes" xml:space="preserve">
          <source>Typically developers do not use the &lt;code&gt;spawn&lt;/code&gt; functions, instead they use abstractions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, built on top of &lt;code&gt;spawn&lt;/code&gt;, that spawns processes with more conveniences in terms of introspection and debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebdb0dbd819b614930942168eaeeb854d37cbf9" translate="yes" xml:space="preserve">
          <source>Typically developers do not use the &lt;code&gt;spawn&lt;/code&gt; functions, instead they use abstractions such as &lt;a href=&quot;task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, built on top of &lt;code&gt;spawn&lt;/code&gt;, that spawns processes with more conveniences in terms of introspection and debugging.</source>
          <target state="translated">通常，开发商不使用 &lt;code&gt;spawn&lt;/code&gt; 的功能，而不是他们使用抽象，例如&lt;a href=&quot;task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;，建立在上面 &lt;code&gt;spawn&lt;/code&gt; ，与自省和调试方面更加便利产卵过程。</target>
        </trans-unit>
        <trans-unit id="a41048f60fc8036bd19784fff24807617c9ba6f2" translate="yes" xml:space="preserve">
          <source>Typically, stable releases are pushed to Hex. If you want to depend on an external dependency still in development, Mix is able to manage Git dependencies too:</source>
          <target state="translated">通常情况下,稳定的发布版本会被推送到Hex上。如果你想依赖还在开发中的外部依赖,Mix也能管理Git依赖。</target>
        </trans-unit>
        <trans-unit id="e81c0c3d0d9554aaaa890589c591cb2c6de83b83" translate="yes" xml:space="preserve">
          <source>Typically, this is used when a process started from a certain shell should have a group leader other than &lt;code&gt;:init&lt;/code&gt;.</source>
          <target state="translated">通常，当从某个外壳启动的进程应具有除 &lt;code&gt;:init&lt;/code&gt; 以外的组长时，将使用此选项。</target>
        </trans-unit>
        <trans-unit id="19526e6dfc6064b512194499eae8afdcd81dca35" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;a href=&quot;#async_nolink/3&quot;&gt;&lt;code&gt;async_nolink/3&lt;/code&gt;&lt;/a&gt; when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is meant to run a single task and track its status:</source>
          <target state="translated">通常，在合理预期任务可能会失败并且您不希望它中断调用者的情况下，请使用&lt;a href=&quot;#async_nolink/3&quot;&gt; &lt;code&gt;async_nolink/3&lt;/code&gt; &lt;/a&gt;。让我们看一个示例，其中&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;旨在运行单个任务并跟踪其状态：</target>
        </trans-unit>
        <trans-unit id="8798d630c8e10ea5c64e566bec0b0fe8e5e77e30" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;a href=&quot;#async_nolink/3&quot;&gt;&lt;code&gt;async_nolink/3&lt;/code&gt;&lt;/a&gt; when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is meant to run a single task and track its status:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="09f0409f5ecd55093b52d29617566df8dfd0cc27" translate="yes" xml:space="preserve">
          <source>UTF-8 and Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d44fb77280648f021d454874b73243b9965e08" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode</source>
          <target state="translated">UTF-8和Unicode</target>
        </trans-unit>
        <trans-unit id="93fa3107e0f78c4c5bf63b64e4e03caae13e12dc" translate="yes" xml:space="preserve">
          <source>UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, and &lt;code&gt;o&lt;/code&gt;, but two bytes to represent &lt;code&gt;ł&lt;/code&gt;. In Elixir, you can get a character&amp;rsquo;s code point by using &lt;code&gt;?&lt;/code&gt;:</source>
          <target state="translated">UTF-8需要一个字节来表示字符 &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;o&lt;/code&gt; ，但是需要两个字节来表示 &lt;code&gt;ł&lt;/code&gt; 。在Elixir中，您可以使用 &lt;code&gt;?&lt;/code&gt; 获得字符的代码点。：</target>
        </trans-unit>
        <trans-unit id="4ba0eecf4f2b37abbf01f86b85c444b51d79130b" translate="yes" xml:space="preserve">
          <source>Umbrella applications can also be used as a stepping stone for eventually extracting an application from your codebase. For example, imagine a web application that has to send &amp;ldquo;push notifications&amp;rdquo; to its users. The whole &amp;ldquo;push notifications system&amp;rdquo; can be developed as a separate application in the umbrella, with its own supervision tree and APIs. If you ever run into a situation where another project needs the push notifications system, the system can be moved to a private repository or a Hex package.</source>
          <target state="translated">伞形应用程序也可用作最终从代码库中提取应用程序的垫脚石。例如，假设一个Web应用程序必须向其用户发送&amp;ldquo;推送通知&amp;rdquo;。整个&amp;ldquo;推送通知系统&amp;rdquo;可以作为单独的应用程序开发，并具有自己的监督树和API。如果遇到其他项目需要推送通知系统的情况，则可以将该系统移至专用存储库或十六进制包。</target>
        </trans-unit>
        <trans-unit id="851ed712aa0571dbe2c6f112b44c8797ec7c4c5e" translate="yes" xml:space="preserve">
          <source>Umbrella projects</source>
          <target state="translated">伞形项目</target>
        </trans-unit>
        <trans-unit id="43c968179421920425ac688f848988a9c56a1013" translate="yes" xml:space="preserve">
          <source>Umbrella projects are a convenience to help you organize and manage multiple applications. While it provides a degree of separation between applications, those applications are not fully decoupled, as they share the same configuration and the same dependencies.</source>
          <target state="translated">伞形项目是一种方便,可以帮助你组织和管理多个应用程序。虽然它提供了应用程序之间一定程度的分离,但这些应用程序并没有完全解耦,因为它们共享相同的配置和相同的依赖关系。</target>
        </trans-unit>
        <trans-unit id="b04e40d6c4b172a53c1b297ef8e44dbbe21358ea" translate="yes" xml:space="preserve">
          <source>Umbrellas</source>
          <target state="translated">Umbrellas</target>
        </trans-unit>
        <trans-unit id="7d6b777bb78f858357184c0cf5af750b3f2ffa24" translate="yes" xml:space="preserve">
          <source>Unary</source>
          <target state="translated">Unary</target>
        </trans-unit>
        <trans-unit id="de5d06c8499ec2b6ae1a8811f2fac4af788e75b6" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError</source>
          <target state="translated">UndefinedFunctionError</target>
        </trans-unit>
        <trans-unit id="305519a8e77b6e01d180181d201634eba9423ae4" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UndefinedFunctionError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="47bcfae4a535fdd5dc3c9474709313c0c05cda2a" translate="yes" xml:space="preserve">
          <source>Underline: none.</source>
          <target state="translated">下划线:无。</target>
        </trans-unit>
        <trans-unit id="74cc1e1026bd71e93c70958a6c844e8826bbbfcc" translate="yes" xml:space="preserve">
          <source>Underline: single.</source>
          <target state="translated">下划线:单。</target>
        </trans-unit>
        <trans-unit id="f97b844a47d0ddc9c28ad5334d4b5c8bebe7ba04" translate="yes" xml:space="preserve">
          <source>Underneath a struct is just a map with a &lt;code&gt;:__struct__&lt;/code&gt; key pointing to the &lt;code&gt;User&lt;/code&gt; module:</source>
          <target state="translated">在结构下面只是一个带有 &lt;code&gt;:__struct__&lt;/code&gt; 键指向 &lt;code&gt;User&lt;/code&gt; 模块的映射：</target>
        </trans-unit>
        <trans-unit id="8ecb7df30047a87c4fc859f515326bcb1df1fdc5" translate="yes" xml:space="preserve">
          <source>Underscore (&lt;code&gt;_foo&lt;/code&gt;)</source>
          <target state="translated">下划线（ &lt;code&gt;_foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="860a89de764183b070c833d2c56a715407fdf5ae" translate="yes" xml:space="preserve">
          <source>Underscore functions</source>
          <target state="translated">下划线功能</target>
        </trans-unit>
        <trans-unit id="07214c1f037134f45b6afd6fb6be34b85a19cbdd" translate="yes" xml:space="preserve">
          <source>Understanding Aliases</source>
          <target state="translated">了解别名</target>
        </trans-unit>
        <trans-unit id="cf49459d86609fbaea12c1c990c331d67fab00b7" translate="yes" xml:space="preserve">
          <source>Understanding applications</source>
          <target state="translated">了解应用</target>
        </trans-unit>
        <trans-unit id="a5d78374ca4469419766b74347b324cc8a588c26" translate="yes" xml:space="preserve">
          <source>Understanding the printed graph</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6e7909c64b19402a59c9e41bf6f2ead8be7854" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars according to the map given.</source>
          <target state="translated">根据给定的地图解开给定的字符。</target>
        </trans-unit>
        <trans-unit id="17a4b21d25e341e163b3fc9fec0b7c0beae4ac5a" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars.</source>
          <target state="translated">Unescapes the given chars.</target>
        </trans-unit>
        <trans-unit id="4f4713c47fdabdbf578d4a71eec889931003b842" translate="yes" xml:space="preserve">
          <source>Unfortunately, similar to &lt;code&gt;IO.inspect/2&lt;/code&gt;, &lt;code&gt;IEx.pry/0&lt;/code&gt; also requires us to change the code we intend to debug. Luckily IEx also provides a &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt;&lt;code&gt;break!/2&lt;/code&gt;&lt;/a&gt; function which allows you set and manage breakpoints on any Elixir code without modifying its source:</source>
          <target state="translated">不幸的是，类似于 &lt;code&gt;IO.inspect/2&lt;/code&gt; ， &lt;code&gt;IEx.pry/0&lt;/code&gt; 还要求我们更改要调试的代码。幸运的是，IEx还提供了&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt; &lt;code&gt;break!/2&lt;/code&gt; &lt;/a&gt;函数，使您可以在任何Elixir代码上设置和管理断点，而无需修改其源代码：</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="c9219d4bebf3a43b3cb39fddf36fce444eec5523" translate="yes" xml:space="preserve">
          <source>Unicode Syntax</source>
          <target state="translated">统一码语法</target>
        </trans-unit>
        <trans-unit id="0b474ff440f8ab612fe1e1943a887fd958d5ed36" translate="yes" xml:space="preserve">
          <source>Unicode and Code Points</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9230bbe0897bd3834d6a401ee2097bdf85ecad8d" translate="yes" xml:space="preserve">
          <source>Unicode atoms in Elixir follow the identifier rule above with the following modifications:</source>
          <target state="translated">Elixir中的Unicode原子遵循上述标识符规则,但做了如下修改。</target>
        </trans-unit>
        <trans-unit id="7372ec76fd7737f65218f4920228b83bfa1d58d4" translate="yes" xml:space="preserve">
          <source>Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Code Point&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cd0bc55280570ee38ec7b425e9a53867a918b8" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError</source>
          <target state="translated">UnicodeConversionError</target>
        </trans-unit>
        <trans-unit id="17431ce3c7303d531227e8a58c83d5667bb2fc09" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UnicodeConversionError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="39e7100b363b0c844d4355a58d8d2bcf3d045da9" translate="yes" xml:space="preserve">
          <source>Uninstalls local archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987e61e41c4febfea2dd5909d903f8a6923f84be" translate="yes" xml:space="preserve">
          <source>Uninstalls local escripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7917e8b4eb34e9ee648bbddd83c2ea876861aa" translate="yes" xml:space="preserve">
          <source>Uninstalls local escripts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24756b8871b9d0b4227e2aeadf94c161941dedb" translate="yes" xml:space="preserve">
          <source>Unit and Size</source>
          <target state="translated">单位和尺寸</target>
        </trans-unit>
        <trans-unit id="7476fffdc753c76439401e20c5fa467d3860aa0e" translate="yes" xml:space="preserve">
          <source>Unit testing framework for Elixir.</source>
          <target state="translated">Elixir的单元测试框架。</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="cfbf337783a51f862d0cc59c306e1cd8f3532bc3" translate="yes" xml:space="preserve">
          <source>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</source>
          <target state="translated">Unix时间总是以UTC为单位,因此DateTime将以UTC返回。</target>
        </trans-unit>
        <trans-unit id="ada7bf7ca1b8ad5c554b83d4ab0831e359db85dc" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ac014f65a6115890eb6cc91e8f2865ac295f23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;expand/2&lt;/code&gt;&lt;/a&gt;, no attempt is made to resolve &lt;code&gt;..&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;expand/2&lt;/code&gt; &lt;/a&gt;不同，没有尝试解决 &lt;code&gt;..&lt;/code&gt; ， &lt;code&gt;.&lt;/code&gt; 或 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e18509c97a5b05619653ea5f9061749ced83e99e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;assert_received&lt;/code&gt;, it has a default &lt;code&gt;timeout&lt;/code&gt; of 100 milliseconds.</source>
          <target state="translated">与 &lt;code&gt;assert_received&lt;/code&gt; 不同，它的默认 &lt;code&gt;timeout&lt;/code&gt; 为100毫秒。</target>
        </trans-unit>
        <trans-unit id="90388e527e157889a4f6398ea86608eb36a3d8e9" translate="yes" xml:space="preserve">
          <source>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2436badc9eff92032ec9ac619271277eb100f7c7" translate="yes" xml:space="preserve">
          <source>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与Erlang不同，此类属性默认情况下不会存储在模块中，因为在Elixir中很常见的是使用自定义属性来存储在编译时可用的临时数据。可以使用&lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将自定义属性配置为更接近Erlang 。</target>
        </trans-unit>
        <trans-unit id="b56b7c857aa7ffa6e7b36170f0491a230a7cf9f0" translate="yes" xml:space="preserve">
          <source>Unlike other hooks, &lt;code&gt;@on_definition&lt;/code&gt; will only invoke functions and never macros. This is to avoid &lt;code&gt;@on_definition&lt;/code&gt; callbacks from redefining functions that have just been defined in favor of more explicit approaches.</source>
          <target state="translated">与其他钩子不同， &lt;code&gt;@on_definition&lt;/code&gt; 将仅调用函数，而不会调用宏。这是为了避免 &lt;code&gt;@on_definition&lt;/code&gt; 回调重新定义刚刚定义的函数，以支持更明确的方法。</target>
        </trans-unit>
        <trans-unit id="94507a67a9f296aef298df58dcc28d14f54c548d" translate="yes" xml:space="preserve">
          <source>Unlike pattern matching via &lt;code&gt;=&lt;/code&gt;, if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error.</source>
          <target state="translated">与通过 &lt;code&gt;=&lt;/code&gt; 进行模式匹配不同，如果左右列表的大小不匹配，则解构只是停止而不是引发错误。</target>
        </trans-unit>
        <trans-unit id="d9890160c4982970542ec14738f7c0e637cd08c2" translate="yes" xml:space="preserve">
          <source>Unlinking the task process started with &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies.</source>
          <target state="translated">取消链接以 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 开始的任务过程。如果您取消流程链接并且该任务不属于任何主管，则可以悬空任务，以防父母死亡。</target>
        </trans-unit>
        <trans-unit id="11bf0305dcee4e7f1f93ac8f6d2c882005c71769" translate="yes" xml:space="preserve">
          <source>Unlinks and shuts down the task, and then checks for a reply.</source>
          <target state="translated">解除链接并关闭任务,然后检查是否有回复。</target>
        </trans-unit>
        <trans-unit id="e12be5ddb337ed9c6e7cda41d5621c3350bb29f0" translate="yes" xml:space="preserve">
          <source>Unloads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">卸载给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91e4a94ba2bbaf79b224a6d7c13a57d58235dccd" translate="yes" xml:space="preserve">
          <source>Unlocks the given dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a00f27d2826c92443fcf4fb80f0a03b5f251cb2" translate="yes" xml:space="preserve">
          <source>Unquoted atoms start with a colon (&lt;code&gt;:&lt;/code&gt;) which must be immediately followed by an underscore or a Unicode letter. The atom may continue using a sequence of Unicode letters, numbers, underscores, and &lt;code&gt;@&lt;/code&gt;. Atoms may end in &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification. Valid unquoted atoms are: &lt;code&gt;:ok&lt;/code&gt;, &lt;code&gt;:ISO8601&lt;/code&gt;, and &lt;code&gt;:integer?&lt;/code&gt;.</source>
          <target state="translated">无引号原子开始冒号（ &lt;code&gt;:&lt;/code&gt; ），其必须立即后跟下划线或一个Unicode字母。原子可以继续使用Unicode字母，数字，下划线和 &lt;code&gt;@&lt;/code&gt; 的序列。原子可能以 &lt;code&gt;!&lt;/code&gt; 还是 &lt;code&gt;?&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。有效的不带引号的原子是：： &lt;code&gt;:ok&lt;/code&gt; ， &lt;code&gt;:ISO8601&lt;/code&gt; 和 &lt;code&gt;:integer?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dac4c6b4443202cc8583016a137c1afc9253dd0" translate="yes" xml:space="preserve">
          <source>Unquotes the given expression inside a quoted expression.</source>
          <target state="translated">在一个被引用的表达式中解除对给定表达式的引用。</target>
        </trans-unit>
        <trans-unit id="51a3755b8963981e97be12c3f11d259db2190b9a" translate="yes" xml:space="preserve">
          <source>Unquotes the given list expanding its arguments.</source>
          <target state="translated">解除给定列表的引号,扩展其参数。</target>
        </trans-unit>
        <trans-unit id="08053b86ce7b78d018827349dcd3d261a98511fd" translate="yes" xml:space="preserve">
          <source>Unquoting</source>
          <target state="translated">Unquoting</target>
        </trans-unit>
        <trans-unit id="3494d6cc701ad4351f6f7781151b09d2bb134df7" translate="yes" xml:space="preserve">
          <source>Unquoting is very useful when working with macros. When writing macros, developers are able to receive code chunks and inject them inside other code chunks, which can be used to transform code or write code that generates code during compilation.</source>
          <target state="translated">在使用宏的时候,取消引号是非常有用的。在编写宏时,开发人员能够接收代码块,并将其注入到其他代码块内,可以用来转换代码或编写代码,在编译过程中生成代码。</target>
        </trans-unit>
        <trans-unit id="70957cdc250ef56f1d10dffbca7af3e59a0b3d13" translate="yes" xml:space="preserve">
          <source>Unregister entries for a given key matching a pattern.</source>
          <target state="translated">取消注册与模式匹配的给定键的条目。</target>
        </trans-unit>
        <trans-unit id="e900939218e97f5edc5de0f78b18c10f6778936f" translate="yes" xml:space="preserve">
          <source>Unregisters all entries for the given &lt;code&gt;key&lt;/code&gt; associated to the current process in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">注销与 &lt;code&gt;registry&lt;/code&gt; 的当前进程相关联的给定 &lt;code&gt;key&lt;/code&gt; 所有条目。</target>
        </trans-unit>
        <trans-unit id="d8766d37827e5742cd1fbee4aed47607e97dcf45" translate="yes" xml:space="preserve">
          <source>Unregisters entries for keys matching a pattern associated to the current process in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872098875ed11d68f92691129750cd5f8910e31e" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">用给定的功能更新 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd67c840db661b5ff35c7988f0c313e081b6c4a7" translate="yes" xml:space="preserve">
          <source>Updates a key in a nested structure.</source>
          <target state="translated">更新嵌套结构中的键。</target>
        </trans-unit>
        <trans-unit id="913040a7783b16d3a66109d11466e1f3715b2f23" translate="yes" xml:space="preserve">
          <source>Updates a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">通过给定 &lt;code&gt;path&lt;/code&gt; 更新嵌套结构。</target>
        </trans-unit>
        <trans-unit id="a6ff992d51a35ca8eeaea3b46d7a9f9c7a1d02bf" translate="yes" xml:space="preserve">
          <source>Updates modification time (mtime) and access time (atime) of the given file.</source>
          <target state="translated">更新给定文件的修改时间(mtime)和访问时间(atime)。</target>
        </trans-unit>
        <trans-unit id="97ba8cd55c834ecfd3ee8f8cbce9327196d85da6" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;keywords&lt;/code&gt; with the given function.</source>
          <target state="translated">更新 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;keywords&lt;/code&gt; 与给定功能。</target>
        </trans-unit>
        <trans-unit id="b837a72c944278925f970add9604780f7fe0b85f" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; with the given function.</source>
          <target state="translated">更新 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; 给定功能。</target>
        </trans-unit>
        <trans-unit id="37bc2bc502a7c11dcf205d8472d9e975015a6ad3" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">用给定的功能更新 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40277704761ae2f8a4bc8d33a1fd26a3d503725b" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数更新代理状态。</target>
        </trans-unit>
        <trans-unit id="f8a3623b94bb3839740129bc6596f649a9a9ecf0" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given function.</source>
          <target state="translated">通过给定的函数更新代理状态。</target>
        </trans-unit>
        <trans-unit id="9f675d5eaf4774279a670e6224dcc645e0067b54" translate="yes" xml:space="preserve">
          <source>Updates the given dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416682303e7f5a28e1fe42385084449506b18f32" translate="yes" xml:space="preserve">
          <source>Updates the value for &lt;code&gt;key&lt;/code&gt; for the current process in the unique &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">更新的价值 &lt;code&gt;key&lt;/code&gt; 在独特的当前进程 &lt;code&gt;registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c9bcfae2fb3ebecd029c8eccc3ce697839499a2" translate="yes" xml:space="preserve">
          <source>Upgrading a dependency often requires the projects it depends on to upgrade too. If you would rather update a single dependency and not touch its children, you can explicitly unlock the single dependency and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">用途将是:</target>
        </trans-unit>
        <trans-unit id="ad0ecf3efc2fafd77bbedf42c03404f90e27c42f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#defines?/3&quot;&gt;&lt;code&gt;defines?/3&lt;/code&gt;&lt;/a&gt; to assert for a specific type.</source>
          <target state="translated">使用&lt;a href=&quot;#defines?/3&quot;&gt; &lt;code&gt;defines?/3&lt;/code&gt; &lt;/a&gt;声明特定类型。</target>
        </trans-unit>
        <trans-unit id="787801e07ca737f4cd69bf93e70004cb3e751db3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#query_decoder/1&quot;&gt;&lt;code&gt;query_decoder/1&lt;/code&gt;&lt;/a&gt; if you want to iterate over each value manually.</source>
          <target state="translated">如果要手动遍历每个值，请使用&lt;a href=&quot;#query_decoder/1&quot;&gt; &lt;code&gt;query_decoder/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3797a8276a8bc54fb5a97169a1b9a858a6ddd368" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#write/2&quot;&gt;&lt;code&gt;write/2&lt;/code&gt;&lt;/a&gt; for devices with encoding.</source>
          <target state="translated">将&lt;a href=&quot;#write/2&quot;&gt; &lt;code&gt;write/2&lt;/code&gt; &lt;/a&gt;用于具有编码的设备。</target>
        </trans-unit>
        <trans-unit id="1b36f40ce27bbfefdab4f321df212af5d062ba4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; to traverse over the arguments (v1.0)</source>
          <target state="translated">使用&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;遍历参数（v1.0）</target>
        </trans-unit>
        <trans-unit id="e5cf1dfe97340fea8a70dd96826ef4351d80ad46" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt;&lt;code&gt;:binary.replace/4&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">使用&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt; &lt;code&gt;:binary.replace/4&lt;/code&gt; &lt;/a&gt;（v1.0）</target>
        </trans-unit>
        <trans-unit id="b10d005a7cda664f5d2f9f25b76adbe1cd127651" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; to traverse over the arguments (v1.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cd7437712581c1861b1448cca82e849c0c602e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#def/2&quot;&gt;public functions&lt;/a&gt; (v1.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b50f96a6422a56c25eb2e39a749132fd99302b1" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_leading/3&quot;&gt;&lt;code&gt;String.pad_leading/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_trailing/3&quot;&gt;&lt;code&gt;String.pad_trailing/3&lt;/code&gt;&lt;/a&gt; with a binary padding (v1.3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d593b29c9401cb9ed1f77973372f98c62abba4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_leading/2&quot;&gt;&lt;code&gt;String.trim_leading/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_trailing/2&quot;&gt;&lt;code&gt;String.trim_trailing/2&lt;/code&gt;&lt;/a&gt; with a binary as second argument (v1.3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a9dd9a756931a4a385ac5c2dd7ee781d1b07f9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#pad_leading/3&quot;&gt;&lt;code&gt;String.pad_leading/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#pad_trailing/3&quot;&gt;&lt;code&gt;String.pad_trailing/3&lt;/code&gt;&lt;/a&gt; with a binary padding (v1.3)</source>
          <target state="translated">结合使用&lt;a href=&quot;string#pad_leading/3&quot;&gt; &lt;code&gt;String.pad_leading/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string#pad_trailing/3&quot;&gt; &lt;code&gt;String.pad_trailing/3&lt;/code&gt; &lt;/a&gt;和二进制填充（v1.3）</target>
        </trans-unit>
        <trans-unit id="20040427069949a8d4027129b310722c2c30b8ff" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#trim_leading/2&quot;&gt;&lt;code&gt;String.trim_leading/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#trim_trailing/2&quot;&gt;&lt;code&gt;String.trim_trailing/2&lt;/code&gt;&lt;/a&gt; with a binary as second argument (v1.3)</source>
          <target state="translated">将&lt;a href=&quot;string#trim_leading/2&quot;&gt; &lt;code&gt;String.trim_leading/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string#trim_trailing/2&quot;&gt; &lt;code&gt;String.trim_trailing/2&lt;/code&gt; &lt;/a&gt;与二进制文件一起用作第二个参数（v1.3）</target>
        </trans-unit>
        <trans-unit id="2f9b8c50f1c8c820e6db1607e6e6745fc6ae1b90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;%&lt;/code&gt; (&lt;code&gt;&amp;lt;%=&lt;/code&gt; is allowed only in start expressions) (v1.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58ca1ae3a377183620422c237e986e4c5bfdee5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;%&lt;/code&gt; (&lt;code&gt;&amp;lt;%=&lt;/code&gt; is allowed only on start expressions) (v1.0)</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;%&lt;/code&gt; （仅在开始表达式上允许 &lt;code&gt;&amp;lt;%=&lt;/code&gt; ）（v1.0）</target>
        </trans-unit>
        <trans-unit id="ee94c06bb86bdaca513c3a62f49490454be42e9c" translate="yes" xml:space="preserve">
          <source>Use a map (v1.0)</source>
          <target state="translated">使用地图 (v1.0)</target>
        </trans-unit>
        <trans-unit id="4d74b43fbed5164c7d0cf7a52539703c48335b7c" translate="yes" xml:space="preserve">
          <source>Use an expression or explicitly return &lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">使用表达式或显式返回 &lt;code&gt;nil&lt;/code&gt; （v1.0）</target>
        </trans-unit>
        <trans-unit id="695acd02888c70a7bd24e240078a062e8cefd82c" translate="yes" xml:space="preserve">
          <source>Use cases for IO data</source>
          <target state="translated">IO数据的使用案例</target>
        </trans-unit>
        <trans-unit id="17ecf402c8b50a984590bda594e338082a23c4c0" translate="yes" xml:space="preserve">
          <source>Use direct message matching (v1.0)</source>
          <target state="translated">使用直接信息匹配(v1.0)</target>
        </trans-unit>
        <trans-unit id="7d7bc258dd57ccdb77c4d94fa239755b4e4dbe79" translate="yes" xml:space="preserve">
          <source>Use parentheses (v1.0)</source>
          <target state="translated">使用括号(v1.0)</target>
        </trans-unit>
        <trans-unit id="d1a132274b1eb6b7319062ced70e808cf7c404ca" translate="yes" xml:space="preserve">
          <source>Use processes only to model runtime properties, never for code organization. And even when you think something could be done in parallel with processes, often it is best to let the callers of your library decide how to parallelize, rather than impose a certain execution flow in users of your code.</source>
          <target state="translated">只用进程来模拟运行时的属性,千万不要用来组织代码。而且即使你认为有些事情可以用进程来并行完成,很多时候最好让你的库的调用者来决定如何并行,而不是把某种执行流程强加给你代码的使用者。</target>
        </trans-unit>
        <trans-unit id="72ac53e8279e1fbc4a4e474748dc78b85a97986e" translate="yes" xml:space="preserve">
          <source>Use public functions (v1.0)</source>
          <target state="translated">使用公共函数(v1.0)</target>
        </trans-unit>
        <trans-unit id="e7e9e97b63195c13fec074e748d6a1b624c2147f" translate="yes" xml:space="preserve">
          <source>Use single-letter aliases (v1.0)</source>
          <target state="translated">使用单字母别名(v1.0)</target>
        </trans-unit>
        <trans-unit id="5d5567686d3e6ae0d4956f84da54e7d67f04b834" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:since&lt;/code&gt; key in the documentation metadata to annotate whenever new functions or modules are added to your API.</source>
          <target state="translated">每当将新功能或模块添加到API时，请使用文档元数据中的 &lt;code&gt;:since&lt;/code&gt; 键进行注释。</target>
        </trans-unit>
        <trans-unit id="47f85339a5f0f7ba3fc69739fe71460337f1ced4" translate="yes" xml:space="preserve">
          <source>Use the pin operator &lt;code&gt;^&lt;/code&gt; when you want to pattern match against a variable&amp;rsquo;s &lt;em&gt;existing value&lt;/em&gt; rather than rebinding the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb9026bf683fe97be9805f8d4ee8da3a7030195" translate="yes" xml:space="preserve">
          <source>Use the pin operator &lt;code&gt;^&lt;/code&gt; when you want to pattern match against an existing variable&amp;rsquo;s value rather than rebinding the variable:</source>
          <target state="translated">当您想对现有变量的值进行模式匹配而不是重新绑定变量时，请使用pin运算符 &lt;code&gt;^&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0b63a0f2b65fabcf35daab1c96a88a9c4182865a" translate="yes" xml:space="preserve">
          <source>Use the singular form, such as: &lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, and so on (v1.4)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62760f6801ea132b87f52fc490f15e5c30ebb87" translate="yes" xml:space="preserve">
          <source>Use this only for debugging information.</source>
          <target state="translated">仅用于调试信息。</target>
        </trans-unit>
        <trans-unit id="654833a705a392b91db5fb486d867850f6f6d4da" translate="yes" xml:space="preserve">
          <source>Used by helpers and it has a default maximum cap of 80 chars.</source>
          <target state="translated">由助手使用,它的默认上限为80个字符。</target>
        </trans-unit>
        <trans-unit id="6f19f4b56cd4eb0479f604b05000a49967ca0779" translate="yes" xml:space="preserve">
          <source>Used by types and bitstrings to specify types.</source>
          <target state="translated">被类型和位串用来指定类型。</target>
        </trans-unit>
        <trans-unit id="27f134f77aed07ba771f04e70c26fcde14c293be" translate="yes" xml:space="preserve">
          <source>Used to combine matching clauses.</source>
          <target state="translated">用来组合匹配的分句。</target>
        </trans-unit>
        <trans-unit id="d3e14268db3616058b87c0710752c8757db571c3" translate="yes" xml:space="preserve">
          <source>Useful for adding side effects (like printing) to a stream.</source>
          <target state="translated">对在流中添加副作用(如打印)很有用。</target>
        </trans-unit>
        <trans-unit id="b4a25e416b54812cf786abc2853d57e8a5a5d837" translate="yes" xml:space="preserve">
          <source>Useful in umbrella applications to execute a command on each child app:</source>
          <target state="translated">在伞形应用程序中很有用,可以在每个子应用程序上执行一条命令。</target>
        </trans-unit>
        <trans-unit id="ccd0085c486cb23718479523b31aac167b10d224" translate="yes" xml:space="preserve">
          <source>Useful when dependencies need to be reloaded due to change of global state.</source>
          <target state="translated">当由于全局状态的改变而需要重新加载依赖关系时非常有用。</target>
        </trans-unit>
        <trans-unit id="52dd4a7101ad34727c991e5c7418caedb4c5ab1e" translate="yes" xml:space="preserve">
          <source>User home directory, exception on error.</source>
          <target state="translated">用户主目录,出错时异常。</target>
        </trans-unit>
        <trans-unit id="3b425e136b2a26688fb41476a54559087648780b" translate="yes" xml:space="preserve">
          <source>User home directory.</source>
          <target state="translated">用户主目录。</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">用户定义类型</target>
        </trans-unit>
        <trans-unit id="9718cbc91389f0a24d01843793c6b8f5bef22b1f" translate="yes" xml:space="preserve">
          <source>Users can read the documentation for public Mix tasks by running &lt;code&gt;mix help my_task&lt;/code&gt;. The documentation that will be shown is the &lt;code&gt;@moduledoc&lt;/code&gt; of the task's module.</source>
          <target state="translated">用户可以通过运行 &lt;code&gt;mix help my_task&lt;/code&gt; 阅读公共Mix任务的文档。将显示的文档是任务模块的 &lt;code&gt;@moduledoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30bca3fe935d22a9fb82d1874f535be3bcc5d54b" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数，这将在后面的部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="7504c890d2e677e3b9b91ddd28b0a2c13353b513" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数。如果键是一个函数，它将按照&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 中的&lt;/a&gt;指定进行调用。</target>
        </trans-unit>
        <trans-unit id="cb5ab22fadbe3ddb46c966e8ef4864a52c44d738" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; protocol to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;协议根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个函数。如果键是一个函数，它将按照&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 中的&lt;/a&gt;指定进行调用。</target>
        </trans-unit>
        <trans-unit id="b648c806a5b72ce2e22dd69f6650416bf9c513d5" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc9c406282a5ba917ce4d72d479e6ebb00bca8f" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649170178c35bb19e659a8d532a363cd019f5cd4" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; protocol to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef97952dc7c1cf9b1acf2d4929c04b260422cc0c" translate="yes" xml:space="preserve">
          <source>Uses the given module in the current context.</source>
          <target state="translated">在当前上下文中使用给定的模块。</target>
        </trans-unit>
        <trans-unit id="90cad9ec714dc9a102448582d410c612025f4e51" translate="yes" xml:space="preserve">
          <source>Uses the merge sort algorithm.</source>
          <target state="translated">使用合并排序算法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
