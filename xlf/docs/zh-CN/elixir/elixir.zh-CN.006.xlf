<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">如果你给一个模块起了别名,但你没有使用这个别名,Elixir就会发出一个警告,暗示这个别名没有被使用。</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">如果你连接到远程shell,在断开连接后,它仍然活着。</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">如果您对实施事件管理器感兴趣，请阅读下面的&amp;ldquo;替代方法&amp;rdquo;部分。如果必须实现事件处理程序以与现有系统集成，例如Elixir的Logger，请改用 &lt;code&gt;:gen_event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">如果您要寻找在生产中使用的分布式键值存储，则一定要考虑&lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;，它也可以在Erlang中运行</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">如果您使用的是Windows，则必须打开 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; ，在这里可以找到：</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">如果您打算编写第一个库供其他开发人员使用，请不要忘记阅读我们的&lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;库指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">如果要设置 &lt;code&gt;@moduletag&lt;/code&gt; ，则必须在调用后 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 设置，否则会看到编译错误。</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">如果您使用的是异步任务，则&lt;strong&gt;必须等待&lt;/strong&gt;答复，因为它们&lt;em&gt;总是&lt;/em&gt;被发送。如果您不希望得到答复，请考虑使用下面详述的&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">如果使用发行版，请参阅&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;，还有另一个名为 &lt;code&gt;config/releases.exs&lt;/code&gt; 的配置文件。尽管每当您运行Mix命令（包括在汇编发行版时）都会执行上一节中提到的 &lt;code&gt;config/config.exs&lt;/code&gt; 和朋友，但是每次在生产系统启动时都会执行 &lt;code&gt;config/releases.exs&lt;/code&gt; 。由于Mix在生产系统中不可用，因此 &lt;code&gt;config/releases.exs&lt;/code&gt; 不得使用Mix中的任何功能。</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">如果你正在使用一个给定模块中的几个函数,你可以导入这些函数,并将其作为本地函数引用,例如。</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">如果你试图定义一个已经存在的模块,你会得到一个警告,说一个模块已经被重新定义。</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">如果你再次连接到localhost并执行另一个请求,只要路由表包含正确的节点名称,现在一切都应该正常。优秀!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">如果您在诸如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之&lt;/a&gt;类的OTP行为中使用 &lt;code&gt;async_nolink&lt;/code&gt; 创建任务，则应该匹配&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调中来自该任务的消息。</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您希望在外壳内部执行受信任的命令（包括管道，重定向等），请检查&lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">如果您不关心计算结果，则可以使用&lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; &lt;/a&gt;运行流。还设置了 &lt;code&gt;ordered: false&lt;/code&gt; ，因为您也不关心结果的顺序：</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">如果您确实想解析未知开关，请记住Elixir会将开关转换为原子。由于原子不是垃圾收集的，所以OptionParser将仅解析转换为运行时使用的原子的开关，以避免泄漏原子。例如，下面的代码将丢弃 &lt;code&gt;--option-parser-example&lt;/code&gt; 开关，因为 &lt;code&gt;:option_parser_example&lt;/code&gt; 原子从未在任何地方使用：</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">如果您没有使用该错误，则无需提供该错误：</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">如果在定义结构时未指定默认键值，则将假定为 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">如果你不需要进程,那么你就不需要进程。只用进程来模拟运行时的属性,比如可突变的状态、并发和失败,而不是用于代码组织。</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">如果您不想从&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入函数或宏，请使用 &lt;code&gt;:except&lt;/code&gt; 选项，然后按Arity列出函数/宏：</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不想将调用者链接到任务，则必须将受监管的任务与&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;一起使用，并调用&lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">如果您不想删除与 &lt;code&gt;key&lt;/code&gt; 关联的所有条目，请使用&lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt;，该函数将仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您希望定义一个项目，即它是当前任务的要求，则应改为调用&lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">如果您在本教程或网站上发现任何错误，&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;请报告错误或将拉取请求发送到我们的问题跟踪器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">如果你发现自己处于这样的境地:你想在每个应用程序中为同一个依赖关系使用不同的配置,或者使用不同的依赖版本,那么很可能你的代码库的发展已经超出了保护伞所能提供的范围。</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">如果您发现自己正在陷阱出口以处理异步流中的出口，请考虑使用&lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt;来启动未链接到调用进程的任务。</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">如果你忘了转义,Elixir在编译代码时就会出错。</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">如果你有一个需要并行编译其他模块的文件,那么产生的进程需要知道编译器环境。这个函数可以让开发人员创建一个知道这些环境的任务。</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您有一个结构体，并且希望将一组键合并到该结构体中，请不要使用此功能，因为它将把右侧的所有键合并到该结构体中，即使该键不属于该结构体。而是使用&lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">如果你有一个内部依赖,Mix支持两种方法来处理它们。Git仓库或伞形项目。</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">如果您在同一网络上有一台同时安装了Erlang和Elixir的计算机，则可以在其上启动另一个外壳程序。如果不这样做，则可以在另一个终端中启动另一个IEx会话。在任何一种情况下，都给它简称 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">如果您对本指南有任何疑问或改进，请访问讨论渠道，例如&lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir论坛&lt;/a&gt;或&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;问题跟踪器&lt;/a&gt;。您的意见非常重要，有助于我们确保指南的可用性和最新性！</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">如果您有过编程经验，您可能会想：&amp;ldquo;我们是否可以保证铲斗首先不会崩溃？&amp;rdquo;。正如我们将看到的那样，Elixir开发人员倾向于将这些实践称为&amp;ldquo;防御性编程&amp;rdquo;。那是因为现场生产系统有很多不同的原因会导致错误。磁盘可能发生故障，内存可能损坏，错误，网络可能会停止运行一秒钟等等。如果我们要编写试图保护或避免所有这些错误的软件，那么与编写我们的错误相比，我们将花费更多的时间来处理错误自己的软件！</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">如果您已跳过入门指南或很早以前就读过它，请务必重新阅读&amp;ldquo; &lt;a href=&quot;../processes&quot;&gt;过程&amp;rdquo;&lt;/a&gt;一章。我们将以此为起点。</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">如果你必须这样做,你可以认为行为就像Java等面向对象语言中的接口:一组模块必须实现的函数签名。</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">如果您尚未安装Elixir，请访问我们的&lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;安装页面&lt;/a&gt;。完成后，您可以运行 &lt;code&gt;elixir --version&lt;/code&gt; 获得当前的Elixir版本。</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">如果你导入了一个模块,但你没有使用这个模块的任何导入函数或宏,Elixir就会发出警告,暗示没有使用导入的函数。</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">如果打算在 &lt;code&gt;timeout&lt;/code&gt; 毫秒内没有响应的情况下关闭任务，则应将其与&lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt;链接在一起，如下所示：</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">如果您知道您在与当前系统不同的系统上运行，并且正在使用正则表达式进行多次匹配，则可以手动调用&lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt;来执行运行时版本检查并重新编译正则表达式如有必要。</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要通用词典，请使用&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块。如果您需要操作关键字列表，请使用&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">如果需要将元组或模块子规范转换为映射或修改子规范，则可以使用&lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数。例如，以不同的 &lt;code&gt;:id&lt;/code&gt; 和 &lt;code&gt;:shutdown&lt;/code&gt; 值为10秒（10_000毫秒）运行堆栈：</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">如果您需要在使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;的同时将选项传递给Elixir可执行文件，则可以按照以下步骤进行操作：</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">如果打开 &lt;code&gt;rel/env.sh.eex&lt;/code&gt; ，则会看到：</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">如果在modes参数中传递 &lt;code&gt;:trim_bom&lt;/code&gt; ，则从文件读取时，流将修剪UTF-8，UTF-16和UTF-32字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">如果你喜欢只使用运算符或跳过运算符,你可以通过以下选项。</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">如果您重新访问 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 实现，您会记得它只是将选项传递给GenServer：</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">如果运行 &lt;code&gt;bin/foo start&lt;/code&gt; ，它将使用一个短名称（ &lt;code&gt;--sname&lt;/code&gt; ）来启动系统，该短名称与发行版名称相同，在本例中为 &lt;code&gt;foo&lt;/code&gt; 。下一步是启动一个名为 &lt;code&gt;bar&lt;/code&gt; 的系统，因此我们可以像上一章一样将 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 连接在一起。但是在实现这一目标之前，让我们先讨论一下发布的好处。</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">如果在 &lt;code&gt;foo&lt;/code&gt; 仍在运行时启动 &lt;code&gt;bar&lt;/code&gt; ，则在应用程序最终关闭之前，您将看到类似以下错误的错误发生5次：</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">如果您提供 &lt;code&gt;message&lt;/code&gt; ，则有关值的信息将自动添加到该消息。</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">如果您尝试运行我们的新宏，您会发现它甚至无法编译，并抱怨变量 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 不存在。这是因为存在歧义： &lt;code&gt;unquote(k)&lt;/code&gt; 可以像以前一样是unquote片段，也可以像 &lt;code&gt;unquote(kv)&lt;/code&gt; 中那样是常规unquote 。</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">如果尝试对&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;使用iodata_to_binary / 1，则将导致参数错误。例如，让我们尝试在IO数据中放置一个无法用一个字节表示的代码点，例如 &lt;code&gt;?&amp;pi;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">如果你希望任务总是被重新启动。</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">如果要从模块捕获功能，可以执行 &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的float直接转换为float，则可以使用&lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的整数直接转换为整数，则可以改用&lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在不保留模式的情况下将内容从IO设备复制到另一台设备或从源直接复制到目标，请选中&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">如果您想通过自定义格式器自定义格式，则可以传递 &lt;code&gt;{module, function}&lt;/code&gt; 元组作为 &lt;code&gt;pattern&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">如果要表示允许使用映射中先前未定义的键，则通常以 &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; 结束映射类型。</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">如果要保留自定义类型的私有性，可以使用 &lt;code&gt;@typep&lt;/code&gt; 指令代替 &lt;code&gt;@type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">如果要对现有变量进行模式匹配，则需要使用&lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt;运算符：</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">如果要对现有变量进行模式匹配，则需要使用 &lt;code&gt;^&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行ceil操作，请改用&lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行累加运算，请改用&lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行底整数除法（向负无穷大舍入），请改用&lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行截断的整数除法（向零舍入），请改用&lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">如果要清除来自名为 &lt;code&gt;:foo&lt;/code&gt; 的应用程序的所有日志调用，并仅保留 &lt;code&gt;Bar.foo/3&lt;/code&gt; 中的错误，则可以设置两个不同的匹配项：</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要重新编译现有模块，请改用&lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">如果要重新加载单个模块，请考虑改用 &lt;code&gt;r(ModuleName)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要删除所有重复的元素，无论顺序如何，请参阅&lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">如果要手动运行测试，可以将 &lt;code&gt;:autorun&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; ,并使用&lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt;运行测试。</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">如果要同时搜索 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.app&lt;/code&gt; 文件，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">如果你想指定多个变量,你可以用逗号将它们分开。</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">如果要&lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt;引用不是带引号的表达式的值（例如映射），则需要在之前调用Macro.escape / 1：</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">如果你想了解更多关于GenServers的信息,Elixir入门指南提供了一个类似教程的介绍。Erlang中的文档和链接也可以提供额外的见解。</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果希望对累加器使用另一个值，请使用&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要获取评估文件而不是其中定义的模块的结果，请参阅&lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">如果要在整个系统上启用它，则可以使用 &lt;code&gt;ERL_AFLAGS&lt;/code&gt; 环境变量，并确保在终端/外壳程序配置中对其进行了相应设置。</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">如果你的Git仓库需要认证,比如基本的用户名:密码HTTP认证通过URL,可以通过Git配置来实现,保持访问规则在源头控制之外。</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">如果您的应用程序没有监控树，则可以通过在 &lt;code&gt;mix.exs&lt;/code&gt; 内更改 &lt;code&gt;def application&lt;/code&gt; 来添加一个 &lt;code&gt;:mod&lt;/code&gt; 以应用程序回调名称包含：mod键：</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">如果您的实现通过选项，或者您正在基于该结构生成自定义代码，则还需要实现一个定义为 &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; 的宏，以获取已传递的选项。</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">如果您的用例完全需要GenEvent提供的内容，或者必须与基于 &lt;code&gt;:gen_event&lt;/code&gt; 的现有系统集成，则仍然可以使用&lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlang模块。</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">如果由于某种原因而无法检索当前工作目录，则此函数返回给定的 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">如果在你的日历中,新的一天从午夜开始,返回{0,1}。</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">如果在你的日历中,新的一天从中午开始,返回{1,2}。</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">如果在你的日历中,新的一天从日出开始,返回{1,4}。</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">如果在你的日历中,新的一天从日落开始,返回{3,4}。</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">如果以后将 &lt;code&gt;Bar&lt;/code&gt; 模块移到 &lt;code&gt;Foo&lt;/code&gt; 模块定义之外，则必须使用其全名（ &lt;code&gt;Foo.Bar&lt;/code&gt; ）对其进行引用，或者必须使用上面讨论的 &lt;code&gt;alias&lt;/code&gt; 指令设置别名。</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">如果在执行代码时更改系统时钟，则可能会报告在1秒内执行的某些代码花费了1个小时以上！为了解决此类问题，VM通过&lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt;提供单调时间，该时间不会减少也不会跳跃：</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">图片:底片。交换前景和背景。</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">图片:正。前景和背景正常。</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">想象一个模块使用在 &lt;code&gt;Math.List&lt;/code&gt; 中实现的专用列表。该 &lt;code&gt;alias&lt;/code&gt; 指令允许指 &lt;code&gt;Math.List&lt;/code&gt; 就像 &lt;code&gt;List&lt;/code&gt; 模块定义中：</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">假设有人实现了 &lt;code&gt;Calendar.Holocene&lt;/code&gt; ，这是一个基于公历的日历，该日历在当前公历年中正好增加了10,000年：</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">想象一下给定的 &quot;旧 &quot;代码。</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">想象一下,你有一个被引用的表达式,你想把它注入某个引用里面。第一个尝试是:</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">假设您有一个名为 &lt;code&gt;projects&lt;/code&gt; 的目录，其中包含三个Elixir项目： &lt;code&gt;elixir&lt;/code&gt; ， &lt;code&gt;ex_doc&lt;/code&gt; 和 &lt;code&gt;plug&lt;/code&gt; 。您可以在每个项目的 &lt;code&gt;ebin&lt;/code&gt; 目录中找到所有 &lt;code&gt;.beam&lt;/code&gt; 文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">假设你有以下结构。</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">立即停止Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">执行行为</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现诸如&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; 之&lt;/a&gt;类的功能是理解&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;强大功能的好练习。当操作不能由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的任何函数表示时，开发人员很可能会求助于&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">在不调用&lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt;（v1.0）的情况下显式增强行为</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">重要提示：千万&lt;strong&gt;不能&lt;/strong&gt;使用这个功能在Unicode模式IO设备，因为它会写入错误的数据。特别是，默认情况下，标准IO设备设置为Unicode，因此使用此功能写入stdio可能会导致错误的数据通过网络发送。</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">从给定文件中导入配置。</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">从其他模块导入函数和宏。</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">导入：新功能可能会添加到自动导入的&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块中。它们可能与您的模块中定义的局部功能冲突。可以使用 &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 以向后兼容的方式解决冲突，但以下情况除外：[...]列出了您不想从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的所有功能。我们保留进行此类添加的权利。</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">不适当的名单永远不会被视为charlists。</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">不正确的列表是不能打印的,即使只由ASCII字符组成。</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">在&amp;ldquo;基本类型&amp;rdquo;中，我们了解了字符串，并将 &lt;code&gt;is_binary/1&lt;/code&gt; 函数用于检查：</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">在&lt;a href=&quot;keywords-and-maps&quot;&gt;第7章中，&lt;/a&gt;我们了解了地图：</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">在Elixir中，我们将几个功能分组到模块中。我们已经用在前面的章节中许多不同的模块，如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;该 &lt;code&gt;String&lt;/code&gt; 模块&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">在Elixir中，将 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 定义为宏，以便可以将其用作防护。这意味着，为了调用 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; ，我们需要首先需要 &lt;code&gt;Integer&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">在Elixir中，可以抛出一个值，然后再捕获它。 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 保留用于除非使用 &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; 否则无法检索值的情况。</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">在Elixir中,所有代码都在进程中运行。进程之间相互隔离,彼此并发运行,并通过消息传递进行通信。进程不仅是Elixir中并发的基础,而且还为构建分布式和容错程序提供了手段。</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">在Elixir中，可枚举是实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的任何数据类型。&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;[1, 2, 3]&lt;/code&gt; ），&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ）和&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;1..3&lt;/code&gt; ）是常用的可枚举数据类型：</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在Elixir中，代码组织是由模块和功能完成的，过程不是必需的。例如，假设您正在实现一个计算器，然后决定将所有计算器操作放在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之后&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">在Elixir中,代码组织是由模块和函数来完成的,流程是不必要的。例如,想象一下,你正在实现一个计算器,你决定把所有的计算器操作放在GenServer后面。</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">在Elixir中,可以使用比较运算符对不同的数据类型进行比较。</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">在Elixir中，通常遍历一个Enumerable，通常会过滤掉一些结果并将值映射到另一个列表中。理解是此类构造的语法糖：它们将那些常见的任务归 &lt;code&gt;for&lt;/code&gt; 特殊形式。</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">在Elixir中,记录主要用于两种情况。</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">在Elixir中， &lt;code&gt;=&lt;/code&gt; 运算符实际上称为&lt;em&gt;match运算符&lt;/em&gt;。让我们看看为什么：</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">在Elixir中,这是由一个监督器完成的。Supervisor是一个监督其他进程并在它们崩溃时重新启动它们的进程。为此,Supervisors管理任何被监督进程的整个生命周期,包括启动和关闭。</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">在Elixir中，我们避免使用 &lt;code&gt;try/rescue&lt;/code&gt; ,因为&lt;strong&gt;我们没有在控制流中使用错误&lt;/strong&gt;。我们从字面上理解错误：它们是为意外和/或例外情况保留的。如果您实际上需要流控制构造，则应使用&lt;em&gt;throws&lt;/em&gt;。这就是我们接下来要看到的。</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">在Elixir中,我们可以比较两种不同的数据类型。</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">在Elixir中，我们有两个用于检查数据结构中有多少项的惯用法： &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;length&lt;/code&gt; 表示必须计算信息。例如， &lt;code&gt;length(list)&lt;/code&gt; 需要遍历整个列表以计算其长度。另一方面， &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 在数据结构中预先计算了大小信息，因此tuple_size（tuple）和 &lt;code&gt;byte_size(binary)&lt;/code&gt; 不依赖于tuple和二进制大小。</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">在Elixir中，我们有两个主要的关联数据结构：关键字列表和映射。是时候进一步了解它们了！</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">在Elixir中，我们有两个动词来检查数据结构中有多少个项： &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;length&lt;/code&gt; 表示必须计算信息。例如， &lt;code&gt;length(list)&lt;/code&gt; 需要遍历整个列表以计算其长度。另一方面， &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 在数据结构中预先计算了大小信息，因此tuple_size（tuple）和 &lt;code&gt;byte_size(binary)&lt;/code&gt; 不依赖于tuple和二进制大小。</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Elixir中，您可以使用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 定义二进制文件：</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">在Erlang中，此结构由 &lt;code&gt;:file_info&lt;/code&gt; 记录表示。因此，此模块还提供用于在Erlang记录和Elixir结构之间进行转换的功能。</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">在Mix项目中，可以通过 &lt;code&gt;config/config.exs&lt;/code&gt; 文件覆盖应用程序的环境及其依赖项。如果使用Mix启动应用程序，则该配置在编译时和运行时都可用，但要考虑到该配置未包含在生成的应用程序资源文件中，如果在没有Mix的情况下启动应用程序，则该配置不可用。</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">在类Unix系统中，更改修改时间可能要求您是 &lt;code&gt;root&lt;/code&gt; 用户或文件所有者。具有写访问权限可能还不够。在这种情况下，第一次触摸（创建）文件会成功，但是如果使用 &lt;code&gt;{:error, :eperm}&lt;/code&gt; 触摸现有文件会失败。</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">在GenServer中,上面的代码将是两个独立的函数,大致是这样的。</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">在具有多个节点的分布式设置中,接受匿名函数的API只有在调用者(客户端)和代理拥有相同版本的调用者模块时才会工作。</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">总而言之,一个版本用三个数字来表示。</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">简而言之，应用程序由 &lt;code&gt;.app&lt;/code&gt; 文件中定义的所有模块组成，包括 &lt;code&gt;.app&lt;/code&gt; 文件本身。一个应用程序通常只有两个目录： &lt;code&gt;ebin&lt;/code&gt; （用于 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.app&lt;/code&gt; 文件的Elixir人工制品）和 &lt;code&gt;priv&lt;/code&gt; （在应用程序中可能需要的任何其他人工制品或资产）。</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">总而言之,当你想跟踪系统处理的文件时,必须使用第一个,以避免同一个文件被多次编译。这在脚本中很常见。</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">在常规项目中，我们可以通过简单地运行 &lt;code&gt;mix release&lt;/code&gt; 来组合发布。但是，我们有一个总括项目，在这种情况下，Elixir需要我们提供一些额外的投入。让我们看看有什么必要：</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">除了Elixir文件扩展名 &lt;code&gt;.ex&lt;/code&gt; 之外，Elixir还支持 &lt;code&gt;.exs&lt;/code&gt; 文件进行脚本编写。Elixir对两个文件的处理方式完全相同，唯一的区别在于意图。 &lt;code&gt;.ex&lt;/code&gt; 文件用于编译，而 &lt;code&gt;.exs&lt;/code&gt; 文件用于编写脚本。尽管只有 &lt;code&gt;.ex&lt;/code&gt; 文件将其字节码以 &lt;code&gt;.beam&lt;/code&gt; 文件的格式写入磁盘，但两个扩展都在执行时将其模块编译并加载到内存中。</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">除了上面概述的内置属性之外，还可以添加自定义属性。定制属性使用&lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt;运算符表示，后跟有效的变量名。提供给custom属性的值必须是有效的Elixir值：</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">除了用户通过&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;提供的密钥外，以下附加密钥可用于 &lt;code&gt;:metadata&lt;/code&gt; 列表：</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">除此之外，还需要将双引号字符串内的双引号转义为 &lt;code&gt;\&quot;&lt;/code&gt; ，并且类似地，也需要将单引号字符列表内的单引号转义为 &lt;code&gt;\'&lt;/code&gt; 。不过，这是更好的样式如上所示更改定界符，而不是对其进行转义。</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">在以上所有示例中，我们在写入文件时都使用了二进制文件。在&lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;二进制，字符串和字符列表&amp;rdquo;&lt;/a&gt;一章中，我们提到了字符串是如何由字节组成的，而字符列表是具有Unicode代码点的列表。</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">在任何情况下,都要避免出现以下情况:</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">在这两种情况下，总是会调用 &lt;code&gt;Stack.start_link/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这两种情况下，脚本或表达式的命令行参数都可在&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; 中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">如果&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;:suspend&lt;/code&gt; 累加器，则它必须由调用方显式处理，并且永远不要泄漏。</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">如果&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;:suspend&lt;/code&gt; 累加器，则 &lt;code&gt;:suspended&lt;/code&gt; 元组必须由调用方显式处理，并且永远不要泄漏。实际上，这意味着常规枚举功能只需要关注 &lt;code&gt;:done&lt;/code&gt; 和 &lt;code&gt;:halted&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">如果找不到直接的相对路径,则返回原始路径。</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">在测试单个文件的情况下,可以通过一个或多个特定的行号,只运行这些给定的测试。</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">如果指定的开关 &lt;code&gt;SWITCH&lt;/code&gt; 具有类型 &lt;code&gt;:boolean&lt;/code&gt; ，则它也可以作为 &lt;code&gt;--no-SWITCH&lt;/code&gt; 传递，这会将选项设置为 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">如果任何条目返回 &lt;code&gt;nil&lt;/code&gt; ，则其键将被删除，删除将被视为成功。</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">在任何情况下，中间返回条目的 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; 将返回为每&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">如果中间的任何条目返回 &lt;code&gt;nil&lt;/code&gt; ，则在接下来尝试访问它时将引发错误。</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">万一它确实存在,那就不做了。否则,就建。</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">如果要访问原始&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;，可以通过访问 &lt;code&gt;Elixir&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">万一出了问题，您也可以&lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt;其他原因使用exit / 1：</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">如果别名是由一个宏自动生成的,Elixir不会发出任何警告,因为别名没有被明确定义。</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">如果转换失败，则会引发&lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt;。如果给出了字符串，它将返回字符串本身。</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">如果文件不存在,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">如果导入是由宏自动生成的,Elixir不会发出任何警告,因为没有明确定义导入。</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">如果任务进程死亡,当前进程将以与任务相同的理由退出。</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">如果测试崩溃,你会看到如下的报告。</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">如果在检查您的结构时发生错误，Elixir将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;错误，并将自动退回到原始表示形式以打印结构。</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">如果没有这样的消息,当前进程将挂起,直到消息到达或等待给定的超时值。</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">如果情况无法按预期进行，请在报告中包含尽可能多的信息，例如：Elixir版本，代码段和错误消息以及错误stacktrace。使用&lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist之类的&lt;/a&gt;网站粘贴此信息。</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">如果你需要配置一个进程,那么在启动该进程时应该传递这些选项。</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">如果需要使用字节，请查看&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您想自动加载&lt;strong&gt;并启动&lt;/strong&gt; &lt;code&gt;app&lt;/code&gt; 的所有依赖项，请参见&lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">如果您想为用户模块提供一些现有功能，请在相应导入的模块中定义它；例如，&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;在调用 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 的模块中未定义 &lt;code&gt;test/3&lt;/code&gt; 宏，但它定义了&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt;并在使用时将其导入到调用方中。</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">如果您正在使用&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中不推荐使用的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 策略，则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;几个步骤即可迁移到DynamicSupervisor。</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">与关键字列表相比,地图对模式匹配非常有用。当在模式中使用地图时,它总是在给定值的子集上进行匹配。</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">相反，被调用函数的值描述了这些函数，但是是在标记函数的上下文中。例如，最后一行表示 &lt;code&gt;Mod.called2/0&lt;/code&gt; 曾经调用过 &lt;code&gt;Mod.some_function/0&lt;/code&gt; ，在这种情况下，该函数所花费的总时间为50ms。</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">实际上，&lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;可用于挽救不是适当的Elixir错误的任何错误。例如，它也可以用于在转换之前挽救早期的 &lt;code&gt;:badarg&lt;/code&gt; 错误：</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">事实上,连接到远程shell是非常常见的,所以我们也提供了一个通过命令行的快捷方式。</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">实际上，让我们打开 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">实际上，每次需要将值插入引号时，建议使用 &lt;code&gt;:bind_quoted&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">实际上，这种模式非常普遍，以至于大多数时候您都希望将 &lt;code&gt;bind_quoted&lt;/code&gt; 选项与&lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; 结合使用&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">通常， &lt;code&gt;underscore&lt;/code&gt; 可以被认为是 &lt;code&gt;camelize&lt;/code&gt; 的反义词，但是，在某些情况下，格式可能会丢失：</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">一般来说,开发者应该在文件不存在的情况下使用前者。后者应该在开发者希望他们的软件在文件不能被读取的情况下失败时使用(即它实际上是一个异常)。</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">通常，开发人员将要在测试中使用常规的 &lt;code&gt;assert&lt;/code&gt; 宏。此宏会检查您的代码，并在发生故障时提供良好的报告。例如， &lt;code&gt;assert some_fun() == 10&lt;/code&gt; 将失败（假设 &lt;code&gt;some_fun()&lt;/code&gt; 返回 &lt;code&gt;13&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">一般来说,这个模块中的函数依赖于Unicode标准,但不包含任何特定于语言环境的行为。</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">一般来说,上述元组的结构是按照以下格式进行的。</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">一般来说,当关键字列表是函数的最后一个参数时,方括号是可选的。</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">在警卫中，当函数通常会引发异常时，它们会导致警卫失败。例如，&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;函数仅适用于列表。如果我们将其与其他任何东西一起使用，则会引发运行时错误：</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">根据这种观察，我们应该考虑采用另一种监督策略。另外两个候选对象是 &lt;code&gt;:one_for_all&lt;/code&gt; 和 &lt;code&gt;:rest_for_one&lt;/code&gt; 。使用 &lt;code&gt;:rest_for_one&lt;/code&gt; 策略的管理者将杀死并重启子进程，该子进程&lt;em&gt;在&lt;/em&gt;子进程崩溃&lt;em&gt;后&lt;/em&gt;启动。在这种情况下，我们希望 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 终止，如果 &lt;code&gt;KV.Registry&lt;/code&gt; 终止。这将要求将存储桶管理器放置在注册表之后，这违反了我们在上面建立的两个段落的排序约束。</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">在宏代码中，&lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt;上的爆炸声表示已放弃&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;宏卫生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">在许多情况下，将期望值传递给&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;并在&lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt;回调中生成消息更为方便：</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">在许多情况下，我们可以利用这一点。在上面的代码中，我们使用&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;既检查给定的事物是否是列表，&lt;em&gt;又&lt;/em&gt;检查其长度的某些属性（而不是使用 &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">在许多函数式编程语言中,通常使用一个2项元组的列表作为键值数据结构的表示。在Elixir中,当我们有一个元组列表,并且元组的第一项(即键)是一个原子时,我们称之为关键字列表。</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">在大多数情况下，&lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt;就足够了。&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;必须在极少数情况下使用，通常涉及需要调用模块以获取回调信息的宏。</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">为了使缓存机制起作用，创建的ETS表需要具有 &lt;code&gt;:protected&lt;/code&gt; 的访问权限（默认），以便所有客户端都可以从中读取内容，而只有 &lt;code&gt;KV.Registry&lt;/code&gt; 进程可以对其进行写入。我们还启动表时设置了 &lt;code&gt;read_concurrency: true&lt;/code&gt; ，针对并发读取操作的常见方案优化了表。</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">为了进行加载， &lt;code&gt;.app&lt;/code&gt; 文件必须位于加载路径中。所有的 &lt;code&gt;:included_applications&lt;/code&gt; 也将被加载。</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">为了更好地理解宏的工作原理，让我们在要实现的地方创建一个新模块， &lt;code&gt;unless&lt;/code&gt; ，它作为宏和函数与 &lt;code&gt;if&lt;/code&gt; 的作用相反：</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为了构建变量，需要一个上下文。在大多数情况下，为了保持卫生，上下文必须为&lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">为了构建我们的键值应用,我们将使用三个主要工具。</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">为了比较两个以上的子句，必须使用&lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">为了配置混合，该模块 &lt;code&gt;use&lt;/code&gt; 小号&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;应该导出 &lt;code&gt;project/0&lt;/code&gt; 函数，返回表示该项目配置的关键字列表。</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">为了在不引入重大更改的情况下继续发展语言，Elixir将依靠弃用降级某些做法并推广新的做法。&lt;a href=&quot;#deprecations&quot;&gt;&amp;ldquo;弃用&amp;rdquo;部分&lt;/a&gt;概述了我们的弃用策略。</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">为了应对开发中的代码加载,Elixir中的协议提供了专门针对开发的协议调度的缓慢实现。</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">为了在Elixir中创建我们自己的模块，我们使用 &lt;code&gt;defmodule&lt;/code&gt; 宏。我们使用 &lt;code&gt;def&lt;/code&gt; 宏在该模块中定义函数：</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">为了促进软件重用，Elixir提供了三个指令（ &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; ）以及一个名为 &lt;code&gt;use&lt;/code&gt; 的宏，概述如下：</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">为了完成我们的 &lt;code&gt;TestCase&lt;/code&gt; 实施，我们需要能够访问所有定义的测试用例。一种实现方法是通过 &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; 在运行时检索测试，该测试返回给定模块中所有函数的列表。但是，考虑到我们可能希望除了测试名称之外还存储有关每个测试的更多信息，因此需要一种更灵活的方法。</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">为了修复失败的测试，让我们在 &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; 中创建一个文件，内容如下。在 &lt;code&gt;KV.Bucket&lt;/code&gt; 下面的实现之前，可以尝试使用代理自行实现KV.Bucket模块。</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">为了修复这个bug,我们需要注册表监控它产生的每一个bucket。一旦我们设置了监控器,注册表就会在每次bucket进程退出时收到通知,让我们可以清理注册表。</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">为了启动你的第一个项目,Elixir提供了一个名为Mix的构建工具。你可以通过运行以下程序来启动你的新项目。</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">为了帮助 IEx 理解一个表达式由多行组成,我们可以将其包入括号中。</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">为了调用上面的回调，我们需要遍历相应的 &lt;code&gt;GenServer&lt;/code&gt; 函数。让我们启动一个注册表，创建一个命名桶，然后查找它：</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">为了使我们的服务器能够处理同步连接,我们需要有一个进程作为接受者,产生其他进程来服务请求。一个解决方案是改变。</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">为了操作关键字列表，Elixir提供&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;了 &lt;code&gt;Keyword&lt;/code&gt; 模块&lt;/a&gt;。但是请记住，关键字列表只是列表，因此它们提供与列表相同的线性性能特征。列表越长，找到键，计算项目数等的时间就越长。因此，在Elixir中，关键字列表主要用于传递可选值。如果您需要存储许多物品或保证一键关联的最大一值，则应改用地图。</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">为了运行分布式代码,我们需要先启动</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">为了运行第一个测试，我们需要运行两个节点。进入 &lt;code&gt;apps/kv&lt;/code&gt; ，让我们重新启动将要由测试使用的名为 &lt;code&gt;bar&lt;/code&gt; 的节点。</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">在生产环境中,所有的实现都是预先已知的,为了加快调度速度,Elixir提供了一种称为协议合并的功能。合并直接将协议与其实现联系起来,这样,从合并后的协议中调用一个函数就相当于调用两个远程函数。</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">为了启动一个监督者,我们需要首先定义一个将被监督的子进程。作为一个例子,我们将定义一个代表堆栈的GenServer。</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">为了理解底层代码，我们需要宏，因此我们将在元编程指南中重新访问此模式。但是，这里的重点是如何使用模块属性作为存储来允许开发人员创建DSL。</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">为了使用依赖关系，您需要在项目配置中添加 &lt;code&gt;:deps&lt;/code&gt; 键。我们经常将依赖项列表提取到其自己的函数中：</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">为了在我们的代码中使用应用程序环境，我们需要用以下定义替换 &lt;code&gt;KV.Router.table/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以 &lt;code&gt;:binary&lt;/code&gt; 模式打开，这需要函数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;中的所有其他功能都可用，因为它们直接处理Unicode数据。</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以二进制模式打开，这需要函数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后必须使用速度较慢的&lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt;函数，因为它们负责进行正确的转换并提供正确的数据保证。</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; 等效于 &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">换句话说， &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; 转换为：</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">换句话说，&lt;strong&gt;不要&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">换句话说，Elixir将仅解析运行时使用的选项，而忽略所有其他选项。如果您想解析所有开关，无论它们是否存在，都可以通过传递 &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; 作为选项来强制创建原子。请谨慎使用此选项。仅当您构建的命令行应用程序接收动态命名的参数并且在长时间运行的系统中必须避免使用时，此功能才有用。</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">换句话说,无论数据结构是微小还是巨大,名称中包含 &quot;size &quot;一词的函数所需时间都是一样的。相反,名称中带有 &quot;length &quot;的函数,随着数据结构大小的增加,所需的时间也会增加。</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">换句话说，如果在您的应用程序或监督树关闭时，一个进程必须自行清理很重要，则此进程必须陷阱退出，并且其子规范应指定适当的 &lt;code&gt;:shutdown&lt;/code&gt; 值，以确保在合理的间隔内终止。</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">换句话说,区分常规的Elixir值(如列表、映射、进程、引用等)和引用表达式是很重要的。有些值,如整数、原子和字符串,其引用的表达式等于值本身。其他的值,如地图,需要显式转换。最后,像函数和引用这样的值根本不能转换为引号表达式。</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">换句话说，原子 &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; 只能用代码点 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 编写。使用其他规范化形式将导致令牌生成器错误。另一方面， &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; 可以写为 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 或006A 006F &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; ，因为它被写在引号之间。</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">换句话说,上面的表述简单地翻译为:。</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">换句话说，此函数尝试从 &lt;code&gt;path&lt;/code&gt; 剥离 &lt;code&gt;from&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">换句话说，此模块期望通常在从外部源检索数据时在其他位置检测到无效数据。例如，从数据库读取字符串的驱动程序将负责检查编码的有效性。&lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt;可用于将字符串分为有效部分和无效部分。</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">换句话说，我们转换给每个表达 &lt;code&gt;case/2&lt;/code&gt; 如步骤 &lt;code&gt;with&lt;/code&gt; 。只要任何一个步骤返回的东西不符合 &lt;code&gt;{:ok, x}&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; 中止，并返回不匹配值。</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">换句话说，即使存储桶崩溃，我们也希望注册表继续运行。让我们编写一个新的注册表测试：</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">换句话说,当调用为。</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">换句话说</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">特别是,如果charlists只包含可打印的ASCII字符,则默认会以单引号打印回来。</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">实际上，字符列表通常在与Erlang接口时使用，特别是不接受二进制文件作为参数的旧库。您可以使用 &lt;code&gt;to_string/1&lt;/code&gt; 和 &lt;code&gt;to_charlist/1&lt;/code&gt; 函数将字符列表转换为字符串并返回：</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">然而，实际上，Elixir开发人员很少使用 &lt;code&gt;try/rescue&lt;/code&gt; 构造。例如，当文件无法成功打开时，许多语言都将迫使您挽救错误。相反，Elixir提供了 &lt;code&gt;File.read/1&lt;/code&gt; 函数，该函数返回一个元组，其中包含有关文件是否成功打开的信息：</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">在实践中，如果发现自己需要动态过程的过程注册表，则应使用Elixir随附&lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;的 &lt;code&gt;Registry&lt;/code&gt; 模块&lt;/a&gt;。它提供的功能类似于我们使用GenServer + &lt;code&gt;:ets&lt;/code&gt; 构建的功能，同时还能够同时执行写入和读取操作。&lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;它已经过基准测试，可以扩展到所有内核，甚至可以在具有40个内核的机器上进行扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">在实践中,通常将服务器和客户端功能放在同一个模块中。如果服务器和/或客户端的实现越来越复杂,你可能会希望将它们放在不同的模块中。</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">在实践中,你更有可能达到Erlang的</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">在实践中,我们并不期望作为桶工作的进程会失败。但是,如果它真的发生了,不管是什么原因,我们可以放心,我们的系统将继续按照预期的方式工作。</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">在实践中,你很少用手加载应用程序,因为那是启动过程的一部分,接下来会解释。</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">在极少数情况下，此功能在Unix上可能会失败。如果当前目录的父目录不存在读取权限，则可能会发生这种情况。因此，如果成功，则返回 &lt;code&gt;{:ok, cwd}&lt;/code&gt; ，否则返回{ &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">以设置符号表示： &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">以设置符号表示： &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">在某些情况下，为所有类型提供默认实现可能会很方便。这可以通过在协议定义 &lt;code&gt;@fallback_to_any&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">在某些情况下，可能有必要在列表中插入许多值。例如，假设您有一个包含 &lt;code&gt;[1, 2, 6]&lt;/code&gt; 的列表，而我们想向其中注入 &lt;code&gt;[3, 4, 5]&lt;/code&gt; 。使用 &lt;code&gt;unquote&lt;/code&gt; 不会产生预期的结果：</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">在某些情况下，这可能导致不希望的格式化。因此，&lt;strong&gt;格式化程序生成的某些代码在美学上可能并不令人满意，并且可能需要开发人员的明确干预&lt;/strong&gt;。这就是为什么我们不建议在现有代码库中盲目运行格式化程序的原因。相反，您应该格式化和检查每个格式化的文件。</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">在某些情况下，您不必关心模式中的特定值。通常将这些值绑定到下划线 &lt;code&gt;_&lt;/code&gt; 。例如，如果仅列表的开头对我们很重要，我们可以将结尾指定为下划线：</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">在某些情况下，您可能需要将这些&lt;em&gt;值&lt;/em&gt;插入带&lt;em&gt;引号的表达式中&lt;/em&gt;。为此，我们需要借助 &lt;code&gt;Macro.escape/1&lt;/code&gt; 首先将这些值转义为带引号的表达式：</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">在某些情况下，您想访问在调用方中定义的别名或模块。为此，您可以使用 &lt;code&gt;alias!&lt;/code&gt; 巨集：</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">在某些情况下,你可以使用formatter不生成优雅代码的事实作为重构的提示。以这段代码为例。</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，开发人员应改为直接导入或别名该模块，以便他们可以根据需要自定义模块，而无需&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt;后面的间接方法。</target>
        </trans-unit>
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="translated">总而言之,文档是与你的API的用户签订的合同,他们不一定能访问源代码;而代码注释是给那些直接与源代码交互的用户的。你可以通过分离这两个概念来了解和表达你的软件的不同保证。</target>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="translated">在 &quot;Mix.Task &quot;部分,我们已经定义了一个任务,它将对使用我们的项目作为依赖的每个人都可用。如果我们希望这个任务只对我们的项目可用呢?只需定义一个别名。</target>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="translated">在&lt;a href=&quot;agent&quot;&gt;上一章中&lt;/a&gt;，我们使用代理来代表我们的存储桶。在&lt;a href=&quot;introduction-to-mix&quot;&gt;mix&lt;/a&gt;的简介中，我们指定了要命名每个存储桶的名称，因此我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="translated">在&lt;a href=&quot;basic-types&quot;&gt;上一章中&lt;/a&gt;，我们看到Elixir提供 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 作为算术运算符，以及用于整数除法和余数的函数 &lt;code&gt;div/2&lt;/code&gt; 和 &lt;code&gt;rem/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="translated">在&lt;a href=&quot;structs&quot;&gt;上一章中&lt;/a&gt;，我们了解到，尽管结构是映射，但它们并不与映射共享协议实现。例如，&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;（基于地图的集合）被实现为结构。让我们尝试将 &lt;code&gt;Size&lt;/code&gt; 协议与 &lt;code&gt;MapSet&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="translated">在 &lt;code&gt;__using__/1&lt;/code&gt; 实现中，我们将名为 &lt;code&gt;@tests&lt;/code&gt; 的模块属性初始化为一个空列表，然后将每个已定义测试的名称存储在此属性中，以便可以从 &lt;code&gt;run&lt;/code&gt; 函数调用这些测试。</target>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="translated">在&amp;ldquo;应用程序&amp;rdquo;选项卡中，您将在其监视树旁边看到系统中当前正在运行的所有应用程序。您可以选择 &lt;code&gt;kv&lt;/code&gt; 应用程序以进一步探索它：</target>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="translated">上面的过程终止是指失败的终止，由 &lt;code&gt;:restart&lt;/code&gt; 选项决定。</target>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="translated">在调用匿名函数的情况下,具有点特殊形式的内元组只有一个参数,反映了运算符是单数的事实。</target>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于事件 &lt;code&gt;:flush&lt;/code&gt; 处理程序应该刷新所有未决的数据。此事件由&lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;flush/0&lt;/code&gt; &lt;/a&gt;触发。</target>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="translated">在上面的代码中，我们有一个过程，我们称之为&amp;ldquo;客户端&amp;rdquo;，向代理&amp;ldquo;服务器&amp;rdquo;发送请求。该请求包含一个匿名函数，必须由服务器执行。</target>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="translated">在环境中可以访问当前的文件名、行号、设置别名、当前函数等。</target>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="translated">在环境中,你可以访问文件名、行号、设置别名、函数等。</target>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">在上面的示例中，我们创建了别名 &lt;code&gt;some_alias&lt;/code&gt; ，它将运行任务 &lt;code&gt;mix hex.info&lt;/code&gt; ，然后&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;运行Elixir脚本，然后&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;执行命令行shell脚本。这显示了与Mix任务混合使用的强大别名。</target>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。这可以通过使用&lt;a href=&quot;#max_by/3&quot;&gt; &lt;code&gt;max_by/3&lt;/code&gt; &lt;/a&gt;并依靠最高有效数字在前的结构来解决。在这种情况下，我们可以使用&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;来获取具有年，月和日字段的元组表示形式：</target>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能，例如&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。这可以通过使用&lt;a href=&quot;#min_by/3&quot;&gt; &lt;code&gt;min_by/3&lt;/code&gt; &lt;/a&gt;并依靠最高有效数字在前的结构来解决。在这种情况下，我们可以使用&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;来获取具有年，月和日字段的元组表示形式：</target>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能，例如&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;将每个 &lt;code&gt;fun&lt;/code&gt; 的调用结果以相反的顺序累积到一个列表中，该列表在最后通过调用&lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt;正确地进行了排序。</target>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; 返回一个数据类型，即实际流，它表示范围为 &lt;code&gt;1..100_000&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 计算：</target>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="translated">在上面的示例中，即使宏显然将其设置为1 ， &lt;code&gt;a&lt;/code&gt; 也会返回10，因为在宏中定义的变量不会影响宏在其中执行的上下文。如果要在调用者的上下文中设置或获取变量，则可以可以在 &lt;code&gt;var!&lt;/code&gt; 的帮助下做到这一点！巨集：</target>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">在上面的示例中，如果 &lt;code&gt;foo&lt;/code&gt; 的值为真值（既不是 &lt;code&gt;false&lt;/code&gt; 也不是 &lt;code&gt;nil&lt;/code&gt; ），则将返回 &lt;code&gt;bar&lt;/code&gt; 。否则，将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;value&lt;/code&gt; 取决于 &lt;code&gt;lucky?&lt;/code&gt; 值是 &lt;code&gt;7&lt;/code&gt; 还是 &lt;code&gt;13&lt;/code&gt; 。。如果 &lt;code&gt;value&lt;/code&gt; 在case 之前没有先前的值，则没有显式绑定值的子句会将变量绑定到 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，由于 &lt;code&gt;x&lt;/code&gt; 是在 &lt;code&gt;try&lt;/code&gt; 子句中定义的，因此无法访问。解决此问题的一种常见做法是返回在 &lt;code&gt;try&lt;/code&gt; 内部定义的变量：</target>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="translated">在上面的示例中，定义了 &lt;code&gt;sum/2&lt;/code&gt; 函数；该函数接收两个参数并返回它们的和。</target>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="translated">在上面的示例中，将定义一组名为 &lt;code&gt;user&lt;/code&gt; 但具有不同Arity 的宏来操作基础记录。</target>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="translated">在上面的示例中，通过将监管结构传递给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;来启动监管器。但是，也可以通过显式定义监督模块来创建监督者：</target>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="translated">在上面的示例中，当我们在范围内进行映射时，在枚举过程中被枚举的元素是一一创建的。该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块我们可以映射范围，而不会触发其列举：</target>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="translated">在上面的示例中，通过使用 &lt;code&gt;TestCase&lt;/code&gt; ，我们可以使用 &lt;code&gt;test&lt;/code&gt; 宏编写测试，该宏定义了一个名为 &lt;code&gt;run&lt;/code&gt; 的函数来自动为我们运行所有测试。我们的原型将依靠match运算符（ &lt;code&gt;=&lt;/code&gt; ）作为执行断言的机制。</target>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，即使宏注入 &lt;code&gt;a = 1&lt;/code&gt; ，它也不会影响 &lt;code&gt;go&lt;/code&gt; 函数定义的变量 &lt;code&gt;a&lt;/code&gt; 。如果宏要显式影响上下文，则可以使用 &lt;code&gt;var!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，即使右列表中的条目比左列表中的条目更多，但解构工作正常。如果右边的列表较小，则将其余元素简单地设置为 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="translated">在上面的示例中，模式匹配之所以有效，是因为结构下方是具有固定字段集的裸露地图。作为地图，结构存储一个名为 &lt;code&gt;__struct__&lt;/code&gt; 的&amp;ldquo;特殊&amp;rdquo;字段，其中包含该结构的名称：</target>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="translated">在上面的示例中，由于我们要在 &lt;code&gt;plus/2&lt;/code&gt; 函数内调用 &lt;code&gt;alias&lt;/code&gt; ，因此该别名仅在 &lt;code&gt;plus/2&lt;/code&gt; 函数内有效。 &lt;code&gt;minus/2&lt;/code&gt; 将完全不受影响。</target>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;|&amp;gt;&lt;/code&gt; 管道是最右边的管道； &lt;code&gt;arg1&lt;/code&gt; 是 &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt; 的AST ，而 &lt;code&gt;arg2&lt;/code&gt; 是 &lt;code&gt;div(2)&lt;/code&gt; 的AST 。</target>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="translated">在上面的示例中，导入的 &lt;code&gt;List.duplicate/2&lt;/code&gt; 仅在该特定函数中可见。在该模块（或与此相关的任何其他模块）的任何其他功能中， &lt;code&gt;duplicate/2&lt;/code&gt; 将不可用。</target>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="translated">在上面的示例中，链接的进程因发送值为1 的 &lt;code&gt;exit&lt;/code&gt; 信号而死亡。Elixir Shell自动处理这些消息并将其打印到终端。</target>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">在上面的示例中，列表 &lt;code&gt;[1, [2], 3]&lt;/code&gt; 作为第一个参数传递给&lt;a href=&quot;list#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt;函数，然后将扁平化的列表作为第一个参数传递给&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;函数。将列表中的每个元素加倍。</target>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="translated">在上面的例子中,shell会期待更多的输入,直到它找到结束引号。有时并不清楚shell期待的是哪一个字符,用户可能会发现自己陷入了不完整表达的状态,除了退出shell之外,没有任何能力终止它。</target>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="translated">在上面的例子中,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="translated">在上面的例子中，两个模块- &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Foo.Bar&lt;/code&gt; -被创建。嵌套时，Elixir会自动为内部模块创建一个别名，从而允许第二个模块 &lt;code&gt;Foo.Bar&lt;/code&gt; 在其定义的相同词法范围（ &lt;code&gt;Foo&lt;/code&gt; 模块）中作为 &lt;code&gt;Bar&lt;/code&gt; 进行访问。仅当嵌套模块通过别名定义时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="translated">在上面的示例中，我们为该模块显式设置了version属性。 &lt;code&gt;@vsn&lt;/code&gt; 由Erlang中的代码重载机制使用</target>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">在上面的示例中，我们同时对数组和变量 &lt;code&gt;i&lt;/code&gt; 进行了变异。在Elixir中无法进行突变。相反，函数式语言依赖于递归：递归地调用函数，直到达到阻止递归操作继续进行的条件为止。在此过程中，没有数据发生突变。考虑下面的示例，该示例可任意多次打印字符串：</target>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="translated">在上面的示例中，我们可以使用 &lt;code&gt;@foo&lt;/code&gt; &lt;code&gt;assigns&lt;/code&gt; 的绑定下访问值 &lt;code&gt;foo&lt;/code&gt; 。这很有用，因为模板在编​​译后可以接收不同的赋值，并且不需要为每个变量集重新编译。</target>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">在上面的示例中，我们将&lt;a href=&quot;kernel#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt;捕获为匿名函数，然后调用了它。</target>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">在上面的示例中，我们创建了休眠时间从1到10秒的任务，并返回了他们睡过的秒数。如果您一次执行所有代码，则应该看到1到5的打印内容，因为这些是在给定时间内已完成的任务。所有其他任务将通过&lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;调用关闭。</target>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们定义了一个匿名函数，该函数接收两个参数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，并返回 &lt;code&gt;a + b&lt;/code&gt; 的结果。参数始终在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的左侧，要执行的代码在右侧。匿名函数存储在变量 &lt;code&gt;add&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="translated">在上面的例子中,我们定义了工人和主管的规格。这些规范(包括工人和主管)接受以下选项。</target>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">在上面的示例中，我们创建了一个新端口，用于执行程序 &lt;code&gt;cat&lt;/code&gt; 。 &lt;code&gt;cat&lt;/code&gt; 是UNIX系统上可用的程序，该程序从多个输入接收数据并将它们串联在输出中。</target>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="translated">在上面的示例中，我们定义了一个名为 &lt;code&gt;:cd&lt;/code&gt; 的标记，可以在设置回调中读取该标记，以配置测试将在其上运行的工作目录。</target>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="translated">在上面的示例中，我们定义了一个名为 &lt;code&gt;mix all&lt;/code&gt; 的别名，该别名打印&amp;ldquo; Hello world&amp;rdquo;，然后获取特定于当前环境的依赖项，并编译项目。</target>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">在上面的示例中，我们定义了两个别名。一个是 &lt;code&gt;mix c&lt;/code&gt; ，它是&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;的快捷方式。另一个名为 &lt;code&gt;mix hello&lt;/code&gt; ，与我们在&amp;ldquo; Mix.Task&amp;rdquo;部分中定义的 &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="translated">在上面的示例中，我们动态生成了函数 &lt;code&gt;foo/0&lt;/code&gt; 和 &lt;code&gt;bar/0&lt;/code&gt; 。现在，假设我们想将此功能转换为宏：</target>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;MyKeyword&lt;/code&gt; 设置为别名作为&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。因此，现在，任何对&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; 的&lt;/a&gt;引用都将被 &lt;code&gt;MyKeyword&lt;/code&gt; 自动替换。</target>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="translated">在上面的示例中，我们使用了 &lt;code&gt;plug/1&lt;/code&gt; 宏来连接将在存在Web请求时调用的函数。在内部，每次调用 &lt;code&gt;plug/1&lt;/code&gt; 时，插件库都会将给定参数存储在 &lt;code&gt;@plugs&lt;/code&gt; 属性中。在编译模块之前，Plug运行一个回调，该回调定义了一个处理HTTP请求的函数（ &lt;code&gt;call/2&lt;/code&gt; ）。此函数将按顺序运行 &lt;code&gt;@plugs&lt;/code&gt; 中的所有插件。</target>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">在上面的示例中，我们从 &lt;code&gt;MyMacros&lt;/code&gt; 导入了宏，在该特定函数中用我们自己的宏替换了原来的&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。该模块中的所有其他功能仍将能够使用原始功能。</target>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;thing&lt;/code&gt; 与每个子句&amp;ldquo; head&amp;rdquo; 匹配，并执行与匹配的第一个子句相对应的子句&amp;ldquo; body&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="translated">在上面的示例中，我们传递了一个 &lt;code&gt;\n&lt;/code&gt; 转义的字符串，并返回了一个未转义的版本。</target>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="translated">在上面的例子中,我们展示了如何在函数子句中使用守护。有几个结构允许使用guards,例如。</target>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="translated">在下面的例子中,我们注册当前进程,并询问注册表中的键数。</target>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="translated">在下面的例子中,我们注册当前进程,并从自身和其他进程中查找。</target>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="translated">在下面的例子中,我们在重复的注册表中用相同的键注册当前的进程,但数值不同。</target>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="translated">在下面的示例中，我们有一个宏，该宏生成一个带有名为 &lt;code&gt;name_length&lt;/code&gt; 的函数的模块，该函数返回模块名称的长度。该函数的值将在编译时而不是在运行时计算。</target>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="translated">在下面的示例中，我们将目录传递到&lt;a href=&quot;#c/2&quot;&gt; &lt;code&gt;c/2&lt;/code&gt; &lt;/a&gt;函数将已编译的 &lt;code&gt;.beam&lt;/code&gt; 文件写入的目录。该目录在Erlang / Elixir系统中通常称为&amp;ldquo; ebin&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">在下面的例子中,我们使用一个函数来获取一个列表内的所有地图。</target>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="translated">在上面的示例中，所有的理解都返回列表作为结果。但是，通过将 &lt;code&gt;:into&lt;/code&gt; 选项传递给理解，可以将理解的结果插入到不同的数据结构中。</target>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">在上面的示例中，理解返回的结果始终是一个列表。可以通过传递 &lt;code&gt;:into&lt;/code&gt; 选项来配置返回的结果，该选项可以接受任何结构，只要它实现了&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议即可。</target>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="translated">在上面的表达式中， &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; 是&lt;strong&gt;生成器&lt;/strong&gt;。它实际上是在生成用于理解的值。任何可枚举都可以在生成器表达式的右侧传递：</target>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="translated">在第一个例子中,重音在元音之前,所以它被认为是两个词素。但是,当你把它倒过来一次,你的元音后面是重音,这就变成了一个词素。再颠倒一次,就会保持为一个单音节。</target>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="translated">在以下各节中，我们的示例将变得更长，而在shell中键入它们可能很棘手。现在该是我们学习如何编译Elixir代码以及如何运行Elixir脚本的时候了。</target>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="translated">在下一章中，我们将通过使用match运算符 &lt;code&gt;=&lt;/code&gt; 来讨论模式匹配。</target>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="translated">在下一章中,我们将探讨GenServers,客户端和服务器之间的隔离更加明显。</target>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="translated">在下一章,我们将开始解析客户端请求并发送响应,完成我们的服务器。</target>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="translated">在下一章中，我们将探讨结构和协议，然后再转向异常处理和诸如信号和理解之类的其他结构。</target>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="translated">在有关 &lt;code&gt;GenServer&lt;/code&gt; 的上一章中，我们实现了 &lt;code&gt;KV.Registry&lt;/code&gt; 来管理存储桶。在某个时候，我们开始监视存储桶，以便能够在 &lt;code&gt;KV.Bucket&lt;/code&gt; 崩溃时采取措施。尽管变化相对较小，但它引入了一个问题，这是Elixir开发人员经常提出的问题：发生故障时会发生什么？</target>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="translated">在前面的章节中，我们始终直接启动流程。例如，我们将调用 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; ，它将返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，这将使我们能够通过其 &lt;code&gt;pid&lt;/code&gt; 与注册表进行交互。现在，流程由主管启动，我们必须直接询问主管其子级是谁，然后从返回的子级列表中获取pid。实际上，每次这样做都是非常昂贵的。为了解决这个问题，我们经常给进程起名字，使它们可以在一台机器上从代码中的任何地方唯一地标识出来。</target>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="translated">在前面的例子中,我们对将一个值关联到流程不感兴趣。</target>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="translated">在返回的结果中,键是变量名,值是对应的变量值。</target>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="translated">在失败的第二行中，在测试名称的正下方，有定义测试的位置。如果您完整复制测试位置（包括文件和行号），并将其附加到 &lt;code&gt;mix test&lt;/code&gt; ，则Mix将加载并运行该特定测试：</target>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="translated">在上面的会话中，我们与&amp;ldquo;购物&amp;rdquo;存储区进行了交互。</target>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="translated">在这种情况下,答案是肯定的:如果接受器崩溃,就没有必要崩溃现有的连接。另一方面,如果任务主管崩溃,也没有必要让接受器崩溃。</target>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="translated">在这种情况下，没有模块，因此我们选择了名称 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 。可能是其他任何名称。我们还选择了 &lt;code&gt;:one_for_one&lt;/code&gt; 策略，这是当前动态主管唯一可用的策略。</target>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">在这种情况下，我们仅从 &lt;code&gt;List&lt;/code&gt; 导入功能 &lt;code&gt;duplicate&lt;/code&gt; （含偶数2）。尽管 &lt;code&gt;:only&lt;/code&gt; 是可选的，但是建议使用它，以避免将给定模块的所有功能导入名称空间内。 &lt;code&gt;:except&lt;/code&gt; 也可以作为一个选项提供，以导入模块中&lt;em&gt;除&lt;/em&gt;功能列表&lt;em&gt;以外&lt;/em&gt;的所有内容。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="translated">在本章中,我们将进一步了解Elixir的基本类型:整数、浮点数、布尔运算、原子、字符串、列表和元组。一些基本类型是:</target>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="translated">在本章中，我们将探索信号，信号是语言提供的用于处理文本表示的机制之一。标记以波浪号（ &lt;code&gt;~&lt;/code&gt; ）字符开头，后跟字母（标识标记），然后是定界符；可选地，可以在最终定界符之后添加修饰符。</target>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="translated">在本章中，我们将学习如何使用&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang的 &lt;code&gt;:gen_tcp&lt;/code&gt; 模块&lt;/a&gt;来处理请求。这提供了探索Elixir &lt;code&gt;Task&lt;/code&gt; 模块的绝好机会。在以后的章节中，我们将扩展服务器，以便它可以实际服务命令。</target>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="translated">在本章中，我们了解了有关Mix依赖项和伞项目的更多信息。虽然我们可以在没有服务器的情况下运行 &lt;code&gt;kv&lt;/code&gt; ,但我们的 &lt;code&gt;kv_server&lt;/code&gt; 直接取决于 &lt;code&gt;kv&lt;/code&gt; 。通过将它们分解为单独的应用程序，我们可以更好地控制它们的开发和测试方式。</target>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="translated">在本章中,我们将使用Mix创建我们的第一个项目,并探索Mix中的不同功能。</target>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="translated">在本章中,我们将讨论如何在Mix中管理依赖关系。</target>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="translated">在本章中，我们将返回 &lt;code&gt;:kv&lt;/code&gt; 应用程序，并添加一个路由层，该路由层将允许我们根据存储桶名称在节点之间分配请求。</target>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="translated">在本章中,我们将实现解析我们在第一章中描述的命令的代码。</target>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="translated">在本章中,我们将学习ETS(Erlang Term Storage),以及如何将其作为一种缓存机制。</target>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="translated">在本章中，我们将学习 &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;cond&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt; 控制流结构。</target>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="translated">在本章中,我们将学习催生新进程的基本构造,以及在进程之间发送和接收消息。</target>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="translated">在本章中,我们将学习如何在多个实体之间保持和共享状态。如果你以前有编程经验,你可能会想到全局共享变量,但我们在这里将学习的模型是完全不同的。接下来的章节将对这里介绍的概念进行概括。</target>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="translated">在本章中，我们将学习如何通过监督 &lt;code&gt;KV.Registry&lt;/code&gt; 流程将这些概念付诸实践。毕竟，如果注册表出现问题，则整个注册表都会丢失，并且永远找不到存储桶！为了解决这个问题，我们将定义一个 &lt;code&gt;KV.Supervisor&lt;/code&gt; 模块，以确保我们的 &lt;code&gt;KV.Registry&lt;/code&gt; 在任何给定时刻启动并运行。</target>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="translated">在本章中，我们将展示Elixir中的 &lt;code&gt;=&lt;/code&gt; 运算符实际上是一个匹配运算符，以及如何使用它来对数据结构内部的模式进行匹配。最后，我们将了解用于访问先前绑定值的pin运算符 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="translated">在本章中，我们将了解二进制文件是什么，二进制文件如何与字符串相关联，以及单引号 &lt;code&gt;'like this'&lt;/code&gt; 在Elixir中的含义。</target>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">在上面的示例中，我们使用了 &lt;code&gt;.&lt;/code&gt; 调用&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;downcase&lt;/code&gt; ，并传递 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">在此示例中，以关键字列表 &lt;code&gt;[async: true]&lt;/code&gt; 作为参数调用了&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt; &lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt;转换为：</target>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="translated">在这个例子中,我们也会将分区的数量设置为在线的调度器数量,这将使注册表在高并发环境下的性能更强。</target>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="translated">在此功能中，创建电子邮件地址将复制 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;domain&lt;/code&gt; 二进制文件。现在，假设您想在另一个二进制文件中使用生成的电子邮件：</target>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="translated">在本指南中,我们将学习如何构建一个完整的Elixir应用程序,拥有自己的监督树、配置、测试等。</target>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="translated">在本简介中，我们为最终编写第一个宏奠定了基础，因此让我们进入下一章。</target>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="translated">在最后一章中,我们将对我们的分布式键值存储的路由表进行配置,最后对软件进行打包生产。</target>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="translated">在这个菜单中,开发者能够启动新的外壳并在它们之间交替使用。让我们试一试吧。</target>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="translated">在本节中,我们记录了编写库时要避免的常见反模式。</target>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="translated">在本节中,我们将实现解析功能,将其文档化,并确保我们的文档是最新的doctests。这有助于我们提供具有准确代码样本的文档。</target>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="translated">在此设置中，Elixir将转义以下内容： &lt;code&gt;\0&lt;/code&gt; ， &lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 。字节可以通过 &lt;code&gt;\xNN&lt;/code&gt; 和Unicode代码点以十六进制形式给出，而 &lt;code&gt;\uNNNN&lt;/code&gt; 转义。</target>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="translated">在本教程中，我们将向您介绍Elixir基础知识-语言语法，如何定义模块，如何操作常见数据结构的特性等等。本章将重点介绍确保已安装Elixir，并且您可以成功运行名为IEx的Elixir交互式Shell。</target>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="translated">在你的主管树中,你会写道。</target>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="translated">内存重装</target>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="translated">索引已标准化，这意味着将从末开始计算负索引（例如 &lt;code&gt;-1&lt;/code&gt; 表示 &lt;code&gt;enumerable&lt;/code&gt; 的最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="translated">表示当前任务是否为循环任务。</target>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的位与位。</target>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的bitwise OR。</target>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的位XOR。</target>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">Infix运算符;计算算术左位移位的结果。</target>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">Infix运算符;计算算术右位移位的结果。</target>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="translated">初始化、关机和重启逻辑(见于主管部门)</target>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="translated">将文件内容插入 &lt;code&gt;path&lt;/code&gt; 就像在外壳中键入文件一样。</target>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="translated">将流值作为一个副作用注入到给定的收集器中。</target>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="translated">由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="translated">输入将被消耗,直到按下Enter键。</target>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="translated">将这些更改插入代码中，现在您可以使用以下命令 &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt; 来启动应用程序，请注意我们如何将端口作为变量传递，但如果未给出则默认为4040。</target>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 到 &lt;code&gt;map_set&lt;/code&gt; 如果 &lt;code&gt;map_set&lt;/code&gt; 没有包含它。</target>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入给定 &lt;code&gt;index&lt;/code&gt; &lt;code&gt;tuple&lt;/code&gt; 中。如果 &lt;code&gt;index&lt;/code&gt; 为负或大于 &lt;code&gt;tuple&lt;/code&gt; 的长度，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="translated">在两个文件之间插入强制性的换行符。</target>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="translated">在两份文件之间插入一个强制性的单一空格。</target>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="translated">在元组的末尾插入一个元素。</target>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="translated">在元组中插入一个元素。</target>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="translated">根据转换函数将给定的 &lt;code&gt;enumerable&lt;/code&gt; 插入到 &lt;code&gt;collectable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="translated">将给定的 &lt;code&gt;enumerable&lt;/code&gt; 插入到 &lt;code&gt;collectable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">在&lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt;内部，您可以使用 &lt;code&gt;@protocol&lt;/code&gt; 访问正在实施的协议，并使用@for访问正在 &lt;code&gt;@for&lt;/code&gt; 定义的模块。</target>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="translated">里面 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块可能会引入其他的关键词，如 &lt;code&gt;else&lt;/code&gt; 在使用 &lt;code&gt;if&lt;/code&gt; 以上。 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 之间支持的关键字是静态的，并且是：</target>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="translated">在IEx内部， &lt;code&gt;Ctrl+C&lt;/code&gt; 将打开 &lt;code&gt;BREAK&lt;/code&gt; 菜单。在此菜单中，您可以退出外壳程序，查看进程和ETS表信息等等。</target>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="translated">在模块内部，我们可以使用 &lt;code&gt;def/2&lt;/code&gt; 定义函数，并使用 &lt;code&gt;defp/2&lt;/code&gt; 定义私有函数。可以从其他模块调用由 &lt;code&gt;def/2&lt;/code&gt; 定义的函数，而只能在本地调用私有函数。</target>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="translated">伞内。</target>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="translated">数字中不重要的数字将保持不变。然而,格式化程序总是为超过5位的十进制数字插入下划线,并将十六进制数字转换为大写字母。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">检查&lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Inspect.Error &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="translated">检查.检查 (2)</target>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="translated">Inspect.t (0)</target>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">使用IO &lt;code&gt;device&lt;/code&gt; 根据给定的选项检查 &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="translated">检查给定 &lt;code&gt;item&lt;/code&gt; 并将其写入设备。</target>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">根据&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议检查给定的参数。第二个参数是关键字列表，其中包含用于控制检查的选项。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">安装外部依赖项很简单。最常见的是，我们使用&lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;，通过在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中的deps函数中列出依赖项：</target>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">相反，&lt;strong&gt;这样做&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="translated">取而代之的 &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt; ， &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; 可以使用。</target>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="translated">代替 &lt;code&gt;spawn/1&lt;/code&gt; 和 &lt;code&gt;spawn_link/1&lt;/code&gt; ，我们使用 &lt;code&gt;Task.start/1&lt;/code&gt; 和 &lt;code&gt;Task.start_link/1&lt;/code&gt; 返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 而不是PID。这就是使任务可以在监督树中使用的原因。此外， &lt;code&gt;Task&lt;/code&gt; 提供了便利功能，例如 &lt;code&gt;Task.async/1&lt;/code&gt; 和 &lt;code&gt;Task.await/1&lt;/code&gt; ，以及简化分发的功能。</target>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="translated">我们将创建自己的&lt;em&gt;进程注册表&lt;/em&gt;，而不是使用内置名称工具，该&lt;em&gt;进程注册表&lt;/em&gt;将存储桶名称与存储桶进程相关联。</target>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="translated">与其问&amp;ldquo;如何在Elixir中做X&amp;rdquo;，不如问&amp;ldquo;如何在Elixir中解决Y&amp;rdquo;。换句话说，不要问如何实施特定的解决方案，而要描述眼前的问题。说明问题可以提供更多的背景信息，并减少对正确答案的偏见。</target>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="translated">流不生成中间列表，而是构建一系列计算，这些计算仅在将基础流传递给 &lt;code&gt;Enum&lt;/code&gt; 模块时才被调用。在处理大型（&lt;em&gt;可能无限&lt;/em&gt;）的集合时，流非常有用。</target>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="translated">结构不需要与映射共享协议实现，而是需要它们自己的协议实现。由于 &lt;code&gt;MapSet&lt;/code&gt; 具有预先计算的大小，可以通过 &lt;code&gt;MapSet.size/1&lt;/code&gt; 访问，因此我们可以为其定义 &lt;code&gt;Size&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="translated">相反，您可以存储 &lt;code&gt;try&lt;/code&gt; 表达式的值：</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="translated">整数码点</target>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="translated">Elixir中的整数（ &lt;code&gt;1234&lt;/code&gt; ）和浮点（ &lt;code&gt;123.4&lt;/code&gt; ）表示为数字序列，出于可读性目的，这些数字可以用下划线分隔，例如 &lt;code&gt;1_000_000&lt;/code&gt; 。整数在其表示中绝不包含点（ &lt;code&gt;.&lt;/code&gt; ）。浮点数包含一个点和该点之后的至少一位数字。浮点数也支持科学计数法，例如 &lt;code&gt;123.4e10&lt;/code&gt; 或 &lt;code&gt;123.4E10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">整数可以带 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; ，默认为 &lt;code&gt;unsigned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="translated">其他基数和Unicode码点中的整数。</target>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="translated">与Mix的整合</target>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="translated">与操作系统级别的&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;跟踪&lt;/a&gt;器（例如Linux Trace Toolkit，&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE&lt;/a&gt;和&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap）&lt;/a&gt;集成</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="translated">内部依赖性</target>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="translated">内部依赖关系是特定于您的项目的依赖关系。在您的项目/公司/组织范围之外，它们通常没有任何意义。大多数时候，无论出于技术，经济还是业务原因，您都希望对它们进行保密。</target>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="translated">块表达式的内部特殊形式。</target>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="translated">内部特殊表格,用于保存别名信息。</target>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">在内部，&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;的实现如下：</target>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">在内部，此功能使用&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;与外界进行交互。但是，如果您计划运行一个长时间运行的程序，则端口将确保关闭stdin / stdout设备，但不会自动终止该程序。&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;模块的文档在&amp;ldquo;僵尸进程&amp;rdquo;部分下描述了此问题以及可能的解决方案。</target>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="translated">符号中的插值和逃逸功能</target>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">将 &lt;code&gt;element&lt;/code&gt; 散布在枚举的每个元素之间。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="translated">搅拌器介绍</target>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="translated">无效(当setup_all失败时)</target>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用所需的回调&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="translated">在每次嵌套开始时调用。</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">为了访问给定术语 &lt;code&gt;term&lt;/code&gt; 中存储在 &lt;code&gt;key&lt;/code&gt; 下的值而调用。</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">为了访问 &lt;code&gt;key&lt;/code&gt; 下的值并同时更新它而调用。</target>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="translated">在某些情况&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用以获取GenServer状态的格式化版本。</target>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">调用以从给定的数据结构中&amp;ldquo;弹出&amp;rdquo; &lt;code&gt;key&lt;/code&gt; 下的值。</target>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="translated">当加载了不同版本的模块（热代码交换）并且应更改状态的术语结构时，调用此命令以更改&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的状态。</target>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="translated">调用以处理 &lt;code&gt;continue&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="translated">调用来处理所有其他信息。</target>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="translated">调用以处理异步&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;消息。</target>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="translated">调用以处理同步&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;消息。&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;将一直阻塞，直到收到答复为止（除非呼叫超时或节点断开连接）。</target>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="translated">初始化配置提供者时调用。</target>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="translated">当服务器即将退出时调用。它应该做任何必要的清理工作。</target>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="translated">启动服务器时调用。&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt;将阻塞直到返回。</target>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="translated">为累加器中 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="translated">在嵌套结束时调用。</target>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">为给定 &lt;code&gt;registry&lt;/code&gt; 在每个分区的 &lt;code&gt;key&lt;/code&gt; 下的所有条目调用回调。</target>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用给定的 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 列表调用给定的匿名函数 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 列表从 &lt;code&gt;module&lt;/code&gt; 调用给定函数。</target>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="translated">对 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用给定的函数，以将其简化为单个元素，同时保留一个累加器。</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">是与。</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="translated">它接受一个import_paths列表，如果尝试再次 &lt;code&gt;imported_paths&lt;/code&gt; 该列表应提高（以避免递归导入）。</target>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">它接受一组用于配置&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;options&lt;/code&gt; （&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt;接受的选项相同）。</target>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="translated">它接受与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;相同的选项，因为这两个函数都建立在此函数之上。该函数可能返回：</target>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="translated">它接受struct模块或结构本身，并从给定结构或从给定模块生成的新结构中删除 &lt;code&gt;__struct__&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="translated">它允许开发人员动态地添加、删除和注册属性,附加文档等。</target>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">它允许开发人员使用给定的密钥查找一个或多个进程。如果注册表具有 &lt;code&gt;:unique&lt;/code&gt; 键，则键指向0或1个进程。如果注册表允许 &lt;code&gt;:duplicate&lt;/code&gt; 键，则单个键可能指向任意数量的进程。在这两种情况下，不同的密钥可以标识相同的过程。</target>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它还接受其他选项，有关可用选项的列表，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="translated">它还接受格式为 &lt;code&gt;function/arity&lt;/code&gt; 和 &lt;code&gt;module.function/arity&lt;/code&gt; 的函数，例如：</target>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="translated">它还接受单个模块参数来列出所有可用的行为回调。</target>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="translated">它还会检查收件箱是否有匹配的输入信息。</target>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">它还可以与运算符和其他构造一起使用（尝试 &lt;code&gt;h +/2&lt;/code&gt; ）。不带参数调用 &lt;code&gt;h&lt;/code&gt; 将显示 &lt;code&gt;IEx.Helpers&lt;/code&gt; 的文档，这是定义 &lt;code&gt;h&lt;/code&gt; 和其他功能的位置。</target>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="translated">它可以是常规文件，目录，套接字，符号链接，命名管道或设备文件。对于指向不存在的目标的符号链接返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="translated">可以这样升级到DynamicSupervisor。</target>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="translated">它可以在 &lt;code&gt;mix.exs&lt;/code&gt; 中使用，以将新的编译器添加到Mix之前或之后：</target>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="translated">它包含以下领域:</target>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="translated">它包含这些领域。</target>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">也可以通过使用多个守卫来纠正,这样如果一个异常导致一个守卫失败,下一个守卫就会被评估。</target>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="translated">这取决于。只要我们仅依赖于该状态的非共享分区，就可以依靠共享状态。尽管多个注册表可以在共享存储桶管理器上启动存储桶，但是这些存储桶和注册表彼此隔离。如果使用诸如 &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; 之类的函数，该函数将计算所有注册表中的所有存储桶，并发运行时可能会得出不同的结果，这只会导致并发问题。</target>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="translated">区别在于，使用 &lt;code&gt;--only&lt;/code&gt; 选项时，如果不执行任何测试，则测试套件将失败。</target>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="translated">它似乎根本不起作用。那是因为我们在接受连接的同一过程中处理请求。连接一个客户端后，我们将无法接受另一个客户端。</target>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，它启用漂亮的打印，宽度为80个字符。可以通过显式传递 &lt;code&gt;:width&lt;/code&gt; 选项来更改宽度。</target>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="translated">为了方便起见而存在。例如，您可以在 &lt;code&gt;mix.exs&lt;/code&gt; 内部调用它以读取您决定移至配置文件的一些外部数据：</target>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="translated">它期望一个 &lt;code&gt;radius&lt;/code&gt; ，该半径选择我们应该在当前行之前和之后打印多少行。默认情况下， &lt;code&gt;radius&lt;/code&gt; 为两行：</target>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="translated">它需要一个子规范或模块，类似于为&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt;提供的规范。例如，如果您的应用程序通过运行以下内容启动监管树：</target>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="translated">它需要一个要编译的文件列表和一个可选的路径来写入编译后的代码。默认情况下,文件是在内存中编译的。要将编译后的文件写入当前目录,可以给一个空字符串。</target>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它需要一个时区来放置&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;。如果时区为&amp;ldquo; Etc / UTC&amp;rdquo;，则它总是成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查NaiveDateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它需要一个时区来放置NaiveDateTime。如果时区为&amp;ldquo; Etc / UTC&amp;rdquo;，则它总是成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查NaiveDateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">它期望一个累加器和一个函数来接收每个可枚举的元素，并且必须返回一个包含新的可枚举（通常是列表）的元组，并以新的累加器或以 &lt;code&gt;:halt&lt;/code&gt; 作为第一个元素，以累加器为第二个元组。</target>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">它需要一个累加器和一个函数来接收每个流元素和一个累加器，并且必须返回一个包含新流（通常是列表）的元组，其中包含新的累加器，或者以 &lt;code&gt;:halt&lt;/code&gt; 作为第一个元素，而将累加器作为第二个元组。</target>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="translated">碰巧我们也可以使用这种同样的语法来更新值。</target>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="translated">它必须被替换为:</target>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="translated">它包括分配（例如 &lt;code&gt;@foo&lt;/code&gt; ）以及将来可能的其他便利。</target>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="translated">它包括许多功能。</target>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="translated">这是应传递给&lt;a href=&quot;#to_argv/2&quot;&gt; &lt;code&gt;to_argv/2&lt;/code&gt; &lt;/a&gt;组相同的 &lt;code&gt;options&lt;/code&gt; 给&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;。只能使用 &lt;code&gt;:switches&lt;/code&gt; 信息正确地重构某些开关。</target>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="translated">也可以使用 &lt;code&gt;put_elem/3&lt;/code&gt; 在一个元组的特定索引处放置一个元素：</target>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="translated">还可以注册 &lt;code&gt;pid&lt;/code&gt; ，为其指定一个名称，并允许知道该名称的每个人向其发送消息：</target>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="translated">也可以在主管下生成任务。所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;模块实现&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;功能，这允许其被直接主管下通过使一个元组与运行功能开始：</target>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="translated">它在 &lt;code&gt;fn/end&lt;/code&gt; 之间也用于构建匿名函数：</target>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="translated">将 &lt;code&gt;IO.inspect/2&lt;/code&gt; 与&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;binding()&lt;/code&gt; &lt;/a&gt;一起使用也很常见，该方法返回所有变量名及其值：</target>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="translated">它是一个从1到366的整数。</target>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="translated">它是一个从1到4的整数。</target>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">它是1到7的整数,其中1是周一,7是周日。</target>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">它仅在&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;表达式的 &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;rescue&lt;/code&gt; 子句中可用。</target>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="translated">正是这种监督系统使Elixir中的 &lt;code&gt;try/catch&lt;/code&gt; 和 &lt;code&gt;try/rescue&lt;/code&gt; 之类的构造如此罕见。我们宁愿&amp;ldquo;快速失败&amp;rdquo;，也不愿挽救错误，因为监督树将确保我们的应用程序在错误发生后将返回已知的初始状态。</target>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="translated">&lt;strong&gt;格式化功能不要失败&lt;/strong&gt;非常重要，因为它会使特定的记录器实例关闭，从而导致系统暂时丢失消息。如有必要，请将函数包装在 &lt;code&gt;rescue&lt;/code&gt; 消息中，并记录一条默认消息：</target>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="translated">在使用宏之前定义宏非常重要。如果在宏调用之前未定义宏，则会在运行时引发错误，因为该宏将不会展开，并且会转换为函数调用：</target>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="translated">重要的是,你要选择一个不阻塞也不试图直接在终端中运行编辑器的编辑器命令。基于命令行的编辑器可能需要额外的配置,所以它们会在一个单独的窗口中打开给定的文件和行。</target>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="translated">重要的是要记住，在 &lt;code&gt;try/catch/rescue/after&lt;/code&gt; 块内定义的变量不会泄漏到外部上下文。这是因为 &lt;code&gt;try&lt;/code&gt; 块可能会失败，因此这些变量可能永远都不会被绑定。换句话说，此代码无效：</target>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="translated">重要的是要考虑分布式代理的局限性。代理提供了两个API,一个是与匿名函数一起工作的API,另一个是期望显式模块、函数和参数的API。</target>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="translated">重要的是要强调步骤2是阻塞性步骤。主管的终止触发子级终止的递归链，因此有序地关闭了所有后代进程。该&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;回调只是整个监督树终止后调用。</target>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="translated">需要注意的是,有几点很重要。</target>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">重要的是要注意一个没有 &lt;code&gt;!&lt;/code&gt; 并不意味着一个函数永远不会提高。例如，在参数错误的情况下，即使&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;也会失败：</target>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">重要的是要注意，读取属性会获取其当前值的快照。换句话说，该值是在编译时而不是在运行时读取的。检查&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;模块的其他功能，以操作模块属性。</target>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">重要的是要注意&lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;是词法的。这意味着您可以在特定的函数中导入特定的宏：</target>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不建议在OTP行为（例如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; )中&lt;/a&gt; &lt;code&gt;await&lt;/code&gt; 长时间运行的任务。相反，您应该匹配来自&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调内部任务的消息。有关消息格式的更多信息，请参见&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="translated">终止调用方时，不需要调用此函数，除非是由于 &lt;code&gt;:normal&lt;/code&gt; 退出或任务正在捕获而退出。如果调用方由于 &lt;code&gt;:normal&lt;/code&gt; 以外的原因而退出，并且任务未捕获退出，则调用方的退出信号将停止任务。调用者可以使用 &lt;code&gt;:shutdown&lt;/code&gt; 退出，以关闭其所有链接的进程，包括任务，这些进程不会捕获退出而不生成任何日志消息。</target>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="translated">可以通过在虚拟机中传递一些启用它的选项来获取shell历史记录。这可以在启动 IEx 时根据需要进行。</target>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="translated">它可以实现所有Elixir类型的协议。</target>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="translated">通过为IEx 提供 &lt;code&gt;--dot-iex&lt;/code&gt; 选项，可以加载另一个文件。请参阅 &lt;code&gt;iex --help&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="translated">它由格式员接收,包含以下字段:</target>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="translated">建议在你的应用程序的启动回调中调用这个函数,以防你想注册新的URI。</target>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="translated">建议后端至少支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="translated">建议处理程序忽略组长与安装处理程序的节点不同的消息。例如:</target>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="translated">建议定义结构的类型。按照惯例，这种类型称为 &lt;code&gt;t&lt;/code&gt; 。要在类型内部定义结构，请使用struct文字语法：</target>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="translated">建议仅在定义结构的类型时使用结构语法。当引用另一个结构时，最好使用 &lt;code&gt;User.t&lt;/code&gt; 代替 &lt;code&gt;%User{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 之间的 &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; 构造上可以看到：</target>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="translated">它是&lt;a href=&quot;#os_time/0&quot;&gt; &lt;code&gt;os_time/0&lt;/code&gt; &lt;/a&gt;的VM视图。在时间扭曲的情况下，它们可能不匹配，尽管VM会努力使其对齐。这次不是单调的。</target>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">它对于在初始化后执行工作,或者在回调中分步进行工作,沿途更新进程状态很有用。</target>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="translated">它通常被编译成一个原子。</target>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">值得一提的是，某些任务（例如上例中的 &lt;code&gt;format&lt;/code&gt; 命令）可以接受多个文件，因此可以将其重写为：</target>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">值得注意的是,IO流是有副作用的,每次复盘都可能得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="translated">但是,可以通过调用以下命令来自定义操作系统的退出信号。</target>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="translated">它主要包括:</target>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="translated">它也可以在位串中用来指定一个给定位段的类型。</target>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">它可以被&lt;em&gt;完成&lt;/em&gt;时，枚举由到达其端部结束，或者&lt;em&gt;停止&lt;/em&gt; / &lt;em&gt;暂停&lt;/em&gt;时枚举被终止或暂停的&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;的功能。</target>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">如果找不到别名或任务或该任务无效，则可能会引发异常。检查&lt;a href=&quot;#get!/1&quot;&gt; &lt;code&gt;get!/1&lt;/code&gt; &lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="translated">它仅记录了一个错误，但父进程仍在运行。那是因为流程是孤立的。如果我们希望一个过程中的故障传播到另一个过程中，则应将它们链接起来。这可以通过 &lt;code&gt;spawn_link/1&lt;/code&gt; 完成：</target>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="translated">它必须是一个带有以下 &quot;标签 &quot;的元组。</target>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="translated">它必须返回Elixir的引用表达式进行嵌套。</target>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="translated">它必须返回Elixir的模板的引用表达式。</target>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="translated">它必须返回仅在嵌套内部使用的新状态。嵌套终止后，将恢复当前 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="translated">它必须返回初始状态。</target>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="translated">它必须返回更新后的状态。</target>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="translated">它在比较字符串之前,对它们进行归一化形式正则分解(NFD)。这个功能相当于。</target>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 不是本地进程，则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">当index为负或超出tuple元素范围时，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="translated">如果定义中使用了不允许在守卫中使用的表达式,它就会在编译时引发,否则就会创建一个可以在守卫内部或外部使用的宏。</target>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="translated">如果定义中使用了不允许在守卫中使用的表达式,它就会在编译时引发,否则就会创建一个私有的宏,可以在当前模块的守卫内部或外部使用。</target>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">它接收当前 &lt;code&gt;config&lt;/code&gt; 和&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的 &lt;code&gt;state&lt;/code&gt; 。然后，通常您会从外部来源读取额外的配置，并将其合并到接收的 &lt;code&gt;config&lt;/code&gt; 。合并应使用&lt;a href=&quot;config.reader#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; 完成&lt;/a&gt;，因为它执行深度合并。它应该返回更新的配置。</target>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">它接受与&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt;相同的选项。返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="translated">它依靠&lt;a href=&quot;#format_banner/3&quot;&gt; &lt;code&gt;format_banner/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#format_stacktrace/1&quot;&gt; &lt;code&gt;format_stacktrace/1&lt;/code&gt; &lt;/a&gt;生成最终格式。</target>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="translated">它表示时间为一天的一部分（从午夜开始）。 &lt;code&gt;parts_in_day&lt;/code&gt; 指定一天中已经过了多少天，而 &lt;code&gt;parts_per_day&lt;/code&gt; 表示一天中可以容纳多少个零件。</target>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="translated">如果代理由于给定的原因终止，则返回 &lt;code&gt;:ok&lt;/code&gt; 。如果座席因其他原因终止，呼叫将退出。</target>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="translated">如果表达式有效，则返回 &lt;code&gt;:ok&lt;/code&gt; 。否则，它以 &lt;code&gt;{:error, remainder}&lt;/code&gt; 的形式返回一个元组，其中 &lt;code&gt;remainder&lt;/code&gt; 是引用表达式的无效部分。</target>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="translated">如果主管由于指定原因终止，则返回 &lt;code&gt;:ok&lt;/code&gt; 。如果由于其他原因终止，则呼叫退出。</target>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">它返回 &lt;code&gt;:ok&lt;/code&gt; ，如果有这样的监督过程 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;{:error, :not_found}&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">如果 &lt;code&gt;amount&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;start_index&lt;/code&gt; 超出范围，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="translated">它返回 &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; 或 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="translated">它返回 &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，它将返回 &lt;code&gt;{:ok, regex}&lt;/code&gt; ，否则返回{： &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">它像返回一个单引号字符串一样返回一个charlist,取消字符的封装并替换插值。</target>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="translated">它返回一个用空格分割的 &quot;单词 &quot;列表,不进行转义,也不解释插值。</target>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="translated">它返回一个以空格分割的 &quot;单词 &quot;列表。每一个字都会进行字符拆分和插值。</target>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="translated">它以 &lt;code&gt;[{name, arity}, ...]&lt;/code&gt; 的形式返回一个列表，其中包含所有已定义的函数和宏（公共和私有）。</target>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="translated">它返回一个正则表达式模式,不需要转义,也不需要解释插值。</target>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="translated">它返回了一个正则表达式模式,取消了字符的逃逸并替换了插值。</target>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">它像返回一个双引号字符串一样返回一个字符串,取消字符大小写并替换插值。</target>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="translated">它返回一个三元素元组，格式为 &lt;code&gt;{parsed, args, invalid}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">它返回形状为 &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; 的元组，其中 &lt;code&gt;module&lt;/code&gt; 是模块名称， &lt;code&gt;binary&lt;/code&gt; 是模块字节码， &lt;code&gt;term&lt;/code&gt; 是带 &lt;code&gt;quoted&lt;/code&gt; 的最后一个表达式的结果。</target>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">它返回一个元组，其中第一个元素是 &lt;code&gt;key&lt;/code&gt; 的第一个值，第二个元素是关键字列表，其中删除了与 &lt;code&gt;key&lt;/code&gt; 相关的所有条目。如果 &lt;code&gt;key&lt;/code&gt; 不在关键字列表中，则返回 &lt;code&gt;{default, keyword_list}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="translated">它返回一个包含配置和导入路径的元组。</target>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="translated">它返回一个包含两个元素列表的双元素元组。触发分割的元素是第二个列表的一部分。</target>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="translated">它返回 &lt;code&gt;mix.exs&lt;/code&gt; 文件，锁清单，并在所有配置文件 &lt;code&gt;config&lt;/code&gt; 目录不具有领先的周期开始（例如， &lt;code&gt;.my_config.exs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">如果成功，它将返回ast，否则将引发异常。如果缺少令牌（通常是因为表达式不完整），则异常是&lt;a href=&quot;tokenmissingerror&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt;，否则，则&lt;a href=&quot;syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="translated">它返回已删除的属性值（如果未设置，则返回 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="translated">它返回编译后的模块名称。</target>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="translated">它返回编译器选项的新地图。</target>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="translated">它返回日期之间的公历天数。这样只能比较遵循相同或兼容日历的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构。如果两个日历不兼容，它将升高。</target>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="translated">它返回的内容与内置的 &lt;code&gt;node()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="translated">它以&lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt;或 &lt;code&gt;{:error, reason}&lt;/code&gt; 定义的格式返回存储在文档块中的术语（如果该块不可用）。</target>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="translated">它返回协议字节码的更新版本。如果元组的第一个元素是 &lt;code&gt;:ok&lt;/code&gt; ，则表示协议已合并。</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">它返回。</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="translated">看来我们已经准备好了!我们将在接下来的章节中大量使用交互式shell。在接下来的章节中,我们将大量使用交互式shell,从下一章开始,我们将进一步熟悉语言结构和基本类型。</target>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">如果您可以使用&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;来检查 &lt;code&gt;enumerable&lt;/code&gt; 给定元素的成员资格而不遍历整个可枚举 &lt;code&gt;{:ok, boolean}&lt;/code&gt; 它应该返回{：ok，boolean}。</target>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果您可以计算 &lt;code&gt;enumerable&lt;/code&gt; 中的元素数量，则应返回 &lt;code&gt;{:ok, count}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="translated">如果 &lt;code&gt;enumerable&lt;/code&gt; 具有已知范围，并且可以访问该 &lt;code&gt;enumerable&lt;/code&gt; 的位置而无需遍历所有先前元素，则应返回 &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="translated">它只是简单地将信息打印到stdio和stderr。</target>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="translated">它只是返回一个没有转义字符和没有插值的charlist。</target>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="translated">它只是返回一个没有转义字符和没有插值的字符串。</target>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="translated">它只是运行在你的项目中注册的编译器,并返回一个包含编译状态和诊断程序列表的元组。</target>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="translated">它支持以下选项:</target>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="translated">它接受一个带有两个元素的元组的 &lt;code&gt;enumerable&lt;/code&gt; ，并返回一个包含两个列表的元组，每个列表分别由每个元组的第一个和第二个元素组成。</target>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="translated">它以 &lt;code&gt;catch&lt;/code&gt; 溢出的 &lt;code&gt;kind&lt;/code&gt; 作为参数，并且仅对 &lt;code&gt;:error&lt;/code&gt; 进行规范化，为其他用户返回未修改的有效负载。</target>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">它使用&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;检查是否不存在或不赞成使用任何远程调用，并在这种情况下发出警告。此任务不会显示已弃用的本地调用（在同一模块中对已弃用的函数或宏的调用），也不会在Elixir本身中显示对已弃用的功能的调用。</target>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="translated">它使用给定的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的文件作为周边和分离文件 &lt;code&gt;separator&lt;/code&gt; 到独立的项目 &lt;code&gt;docs&lt;/code&gt; 。如果集合中的所有条目都是简单的文档（文本或字符串），则此函数尝试将尽可能多的内容放在同一行上。如果它们不简单，则如果不合适，则每行仅显示一个条目。</target>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="translated">它根据《SIGPLAN'96编程语言设计与实现会议论文集》中 &quot;快速准确地打印浮点数 &quot;中描述的算法,使用最短的表示方法。</target>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">执行转换时，还将在&lt;a href=&quot;io.ansi#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt;附加IO.ANSI.reset / 0。如果您不希望这种行为，请使用&lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="translated">它还将卸载所有 &lt;code&gt;:included_applications&lt;/code&gt; 。请注意，该功能不会清除应用程序模块。</target>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">如果该结构不可用，它将引发&lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;，它将以给定的单位返回整数。</target>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="translated">它与不恰当的列表一起工作。</target>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="translated">可以为所有Elixir数据类型实现协议：</target>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="translated">也可以将一个块传递给&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;宏。上面的第一个示例将转换为：</target>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">重要的是要注意，它会不变地返回给定的 &lt;code&gt;item&lt;/code&gt; 。这样可以通过在代码中几乎任何地方（例如在管道中间）插入&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用来&amp;ldquo;监视&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="translated">将这样一个管道的AST作为一个函数应用的列表通常是很有用的。这个函数正是这样做的。</target>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="translated">斜体:上。未得到广泛支持。有时作为反义词处理。</target>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">遍历 &lt;code&gt;enumerable&lt;/code&gt; 并在每个元素上调用 &lt;code&gt;fun&lt;/code&gt; 。当 &lt;code&gt;fun&lt;/code&gt; 的调用返回 &lt;code&gt;false&lt;/code&gt; 值（false或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止并返回 &lt;code&gt;false&lt;/code&gt; 。在所有其他情况下，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">遍历 &lt;code&gt;enumerable&lt;/code&gt; 并在每个元素上调用 &lt;code&gt;fun&lt;/code&gt; 。当 &lt;code&gt;fun&lt;/code&gt; 的调用返回真值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止，并返回 &lt;code&gt;true&lt;/code&gt; 。在所有其他情况下，将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">它的领域是:</target>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="translated">加入一个路径列表。</target>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">使用 &lt;code&gt;joiner&lt;/code&gt; 器作为分隔符将给定的 &lt;code&gt;enumerable&lt;/code&gt; 连接到二进制文件中。</target>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="translated">连接两条路径。</target>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">就像&lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; 一样&lt;/a&gt;，除了接受主题或主题列表。例如，主题 &lt;code&gt;:applications&lt;/code&gt; 将列出已加载的应用程序。</target>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="translated">请记住， &lt;code&gt;@enforce_keys&lt;/code&gt; 是一个简单的编译时保证，可在构建结构时帮助开发人员。它不会在更新时强制执行，并且不提供任何类型的值验证。</target>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="translated">请记住,防护罩的错误不会泄露,而只是让防护罩失效。</target>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="translated">请记住,将同一个字符串反转两次不一定能得到原来的字符串。</target>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="translated">请记住,单引号和双引号的表示方式在Elixir中并不等同,因为它们由不同的类型表示。</target>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">请记住，&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;在调用者进程中运行，从而在评估周期中阻止了调用者。可以通过调用&lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt;释放调用者进程，这将启动一个新的IEx评估周期，让这一步继续进行：</target>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="translated">请记住， &lt;code&gt;assert&lt;/code&gt; 不会根据表达式更改其语义。换句话说，仍然需要该表达式返回真实值。例如，以下操作将失败：</target>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="translated">请记住， &lt;code&gt;filter&lt;/code&gt; 不能同时过滤和转换元素。如果您愿意，请考虑使用&lt;a href=&quot;#flat_map/2&quot;&gt; &lt;code&gt;flat_map/2&lt;/code&gt; &lt;/a&gt;。例如，如果要转换代表整数的所有字符串，并一次性放弃无效的字符串：</target>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="translated">请记住， &lt;code&gt;refute&lt;/code&gt; 不会改变给定表达式的语义。换句话说，以下操作将失败：</target>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="translated">请记住，默认情况下包括所有测试，因此除非首先将它们排除在外，否则 &lt;code&gt;include&lt;/code&gt; 选项将无效。</target>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="translated">请记住,您可以随时调用帮助任务来列出所有可用任务。</target>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="translated">请记住，按照约定，每当检查的值以 &lt;code&gt;#&lt;/code&gt; 开头时，它就以无效的Elixir语法表示数据结构。这意味着检查协议不可逆，因为在此过程中可能会丢失信息：</target>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="translated">请记住,为了知道一个元素是否唯一,这个函数需要存储流发出的所有唯一值。因此,如果流是无限的,存储的元素数量将无限增长,永远不会被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">请记住，无论使用 &lt;code&gt;async_nolink&lt;/code&gt; 创建的任务如何终止，调用者的进程将始终收到带有与任务结构相同的 &lt;code&gt;ref&lt;/code&gt; 值的 &lt;code&gt;:DOWN&lt;/code&gt; 消息。如果任务正常终止，则 &lt;code&gt;:DOWN&lt;/code&gt; 消息中的原因将是 &lt;code&gt;:normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">请记住，在撬入预编译的源代码（例如Elixir本身）时，&lt;a href=&quot;#open/0&quot;&gt; &lt;code&gt;open/0&lt;/code&gt; &lt;/a&gt;位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">请记住，在撬入预编译的源代码（例如Elixir本身）时，&lt;a href=&quot;#whereami/1&quot;&gt; &lt;code&gt;whereami/1&lt;/code&gt; &lt;/a&gt;位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="translated">请记住,当打开预编译的源代码时,该位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="translated">请记住，对代理执行&amp;ldquo;滚动升级&amp;rdquo;时也会出现此问题。通过滚动升级，我们意味着以下情况：您希望通过&lt;em&gt;关闭&lt;/em&gt;某些节点并将其替换为运行新版本软件的节点来部署新版本的软件。在此设置中，环境的一部分将具有给定模块的一个版本，另一部分将具有同一模块的另一个版本（较新的版本）。</target>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="translated">使文档的第一段简洁明了，通常为一行。诸如&lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt;之类的工具使用第一行来生成摘要。</target>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="translated">保持用户的格式化</target>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="translated">内核功能</target>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="translated">每个元组中的键和值将是二进制的,并且将被百分数取消编码。</target>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="translated">基于密钥的数据结构访问。</target>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="translated">地图中的键值对不遵循任何顺序(这就是为什么上面例子中打印的地图与创建的地图顺序不同的原因)。</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">KeyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">键和值可以是任何实现&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议的术语，但列表除外，列表是明确禁止的。</target>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="translated">钥匙的顺序,由开发商指定。</target>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="translated">钥匙可以给一次以上。</target>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 中没有条目的键将被忽略。</target>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="translated">关键词列表中没有条目的键将被忽略。</target>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">可以通过此模块中的某些功能（例如&lt;a href=&quot;map#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;map#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt;）或&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块提供的 &lt;code&gt;map[]&lt;/code&gt; 语法来访问地图中的键：</target>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="translated">结构中不存在的&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的键会被自动丢弃。请注意，键必须是原子，因为在定义结构时仅允许原子。</target>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="translated">钥匙必须是原子。</target>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">键必须是原子。丢弃值为 &lt;code&gt;nil&lt;/code&gt; 的键，将布尔值转换为 &lt;code&gt;--key&lt;/code&gt; 或 &lt;code&gt;--no-key&lt;/code&gt; （如果分别为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ），则使用&lt;a href=&quot;kernel#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt;转换所有其他值。</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="translated">关键字列表</target>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="translated">关键词列表和地图</target>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="translated">关键字列表总是被深度合并。</target>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="translated">关键字列表总是深度合并的。</target>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="translated">关键词列表之所以重要,是因为它们有三个特殊的特点。</target>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="translated">关键字列表在该语言中起着重要作用，并且在许多功能和宏中非常常见。在以后的章节中，我们将进一步探讨它们。现在该讨论&amp;ldquo;二进制文件，字符串和字符列表&amp;rdquo;了。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="translated">关键词作为最后的参数</target>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="translated">Elixir中的关键字是由两个元素组成的元组列表,其中第一个元素是一个原子。使用基础结构,它们将被表示为。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="translated">已知标签</target>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="translated">上次我们通过更换异步操作，一个固定的比赛条件 &lt;code&gt;cast&lt;/code&gt; ，由 &lt;code&gt;call&lt;/code&gt; ，这是同步的。不幸的是，我们用来接收 &lt;code&gt;:DOWN&lt;/code&gt; 消息并从ETS表中删除条目的 &lt;code&gt;handle_info/2&lt;/code&gt; 回调没有同步的等效项。这次，我们需要找到一种方法来确保注册表处理了存储桶进程终止时发送的 &lt;code&gt;:DOWN&lt;/code&gt; 通知。</target>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="translated">稍后，我们将学习如何编译Elixir代码（在&lt;a href=&quot;modules-and-functions&quot;&gt;第8章中&lt;/a&gt;）以及如何使用Mix构建工具（在&lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix＆OTP指南中&lt;/a&gt;）。现在，让我们继续&lt;a href=&quot;basic-types&quot;&gt;第二章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">在给定函数返回truthhy值的同时,懒惰地放弃枚举的元素。</target>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="translated">懒惰地删除可枚举中的下 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">懒惰地点缀 &lt;code&gt;intersperse_element&lt;/code&gt; 枚举的各元件之间。</target>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">懒惰地返回并删除与关键字列表中的 &lt;code&gt;key&lt;/code&gt; 关联的所有值。</target>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">懒洋洋地返回并删除相关联的价值 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">在给定函数返回truthhy值的同时,懒惰地获取枚举元素。</target>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="translated">懒惰地从可枚举中获取下一个 &lt;code&gt;count&lt;/code&gt; 元素，并停止枚举。</target>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="translated">闰秒不计入。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="translated">从左到右</target>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="translated">从左到右箭头</target>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="translated">我们还向 &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; 添加一个测试，以确保存储桶是临时的：</target>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="translated">让我们将该代码分开一下：</target>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="translated">让我们再次更改 &lt;code&gt;start/2&lt;/code&gt; ，以将监管者添加到我们的树中：</target>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="translated">让我们将 &lt;code&gt;KV.Registry&lt;/code&gt; 更改为使用ETS表。第一个更改是修改注册表以要求使用name参数，我们将使用它来命名ETS表和注册表进程本身。ETS名称和进程名称存储在不同的位置，因此不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="translated">让我们逐一检查每个案例。</target>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="translated">让我们创建一个新的Mix项目。我们将创造性地将其命名为 &lt;code&gt;kv_umbrella&lt;/code&gt; ，并且这个新项目将同时包含现有的 &lt;code&gt;kv&lt;/code&gt; 应用程序和新的 &lt;code&gt;kv_server&lt;/code&gt; 应用程序。目录结构如下所示：</target>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="translated">让我们在 &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; 中创建命令解析器，并从doctest开始：</target>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="translated">让我们通过从命令行调用 &lt;code&gt;mix new&lt;/code&gt; 来创建我们的第一个项目。我们将通过该项目的名称作为参数（ &lt;code&gt;kv&lt;/code&gt; ，在这种情况下），并告诉驴友，我们的主要模块应该是全大写的 &lt;code&gt;KV&lt;/code&gt; ，而不是默认的，这将有 &lt;code&gt;Kv&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="translated">让我们在此shell中定义一个名为 &lt;code&gt;Hello&lt;/code&gt; 的模块：</target>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="translated">通过在两个测试中的 &lt;code&gt;Agent.stop/2&lt;/code&gt; 之后创建一个&amp;ldquo;虚假&amp;rdquo;存储桶（这是一个同步请求）来进行操作：</target>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="translated">我们开工吧。</target>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">让我们首先通过使用 &lt;code&gt;iex -S mix&lt;/code&gt; 启动新控制台来与显示器一起玩：</target>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="translated">让我们开始吧！</target>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="translated">让我们通过运行 &lt;code&gt;iex kv.exs&lt;/code&gt; 来尝试一下：</target>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="translated">试一试吧。打开 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; ，然后将 &lt;code&gt;start/2&lt;/code&gt; 函数中的超级用户更改为以下内容：</target>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">让我们在 &lt;code&gt;iex -S mix&lt;/code&gt; 内尝试更新的主管：</target>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="translated">让我们回到前几章中定义的 &lt;code&gt;Math&lt;/code&gt; 模块，添加一些文档并将其保存到 &lt;code&gt;math.ex&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="translated">让我们在 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 中实现集成测试，如下所示：</target>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="translated">让我们实现这些步骤。移至 &lt;code&gt;apps/kv_server&lt;/code&gt; 应用程序，打开 &lt;code&gt;lib/kv_server.ex&lt;/code&gt; ，并添加以下功能：</target>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="translated">让我们学习如何做。</target>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="translated">让我们再举一个使用流的例子。由于 &lt;code&gt;IO&lt;/code&gt; 模块提供了流（既是 &lt;code&gt;Enumerable&lt;/code&gt; 还是 &lt;code&gt;Collectable&lt;/code&gt; ），因此可以使用以下理解实现一个回显终端，该终端回显所键入内容的大写版本：</target>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="translated">让我们进入apps目录并开始构建 &lt;code&gt;kv_server&lt;/code&gt; 。这次，我们将传递 &lt;code&gt;--sup&lt;/code&gt; 标志，它将告诉Mix为我们自动生成一个监督树，而不是像前面的章节中那样手动构建一个监督树：</target>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="translated">让我们进入下一章。最后，我们将通过添加存储桶路由机制来使我们的系统分布式。我们将利用这个机会来改善我们的测试印章。</target>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">现在让我们为 &lt;code&gt;:bar&lt;/code&gt; 定义一个发行版。第一步可能是在 &lt;code&gt;mix.exs&lt;/code&gt; 中定义一个与 &lt;code&gt;foo&lt;/code&gt; 完全相同的发行版：</target>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="translated">现在，让我们看一下如何使用递归的能力对数字列表求和：</target>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="translated">让我们放在一起，并在进程之间发送消息：</target>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">让我们回顾一下正在发生的事情。每当我们调用 &lt;code&gt;iex -S mix&lt;/code&gt; 时，它都会通过调用 &lt;code&gt;Application.start(:kv)&lt;/code&gt; 来自动启动应用程序，然后调用应用程序回调。应用程序回调工作是启动&lt;strong&gt;监督树&lt;/strong&gt;。现在，我们只有一个主管，但有时也要监督一个主管，使之像一棵树。到目前为止，我们的主管有一个独生子 &lt;code&gt;KV.Registry&lt;/code&gt; ，其名称为 &lt;code&gt;KV.Registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="translated">让我们重新实现服务器回调以修复错误并通过测试。首先，我们将GenServer状态修改为两个字典：一个包含name- &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; ，另一个包含ref- &lt;code&gt;ref -&amp;gt; name&lt;/code&gt; 。然后，我们需要监视 &lt;code&gt;handle_cast/2&lt;/code&gt; 上的存储桶，并实现 &lt;code&gt;handle_info/2&lt;/code&gt; 回调以处理监视消息。完整的服务器回调实现如下所示：</target>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="translated">让我们重写测试用例以使用回调：</target>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="translated">让我们再次运行测试。但是这次，我们将传递 &lt;code&gt;--trace&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="translated">让我们更详细地了解当您请求 &lt;code&gt;IO.write(pid, binary)&lt;/code&gt; 时会发生什么。在 &lt;code&gt;IO&lt;/code&gt; 模块将消息发送到由所标识的过程 &lt;code&gt;pid&lt;/code&gt; 与期望的操作。一个小的临时过程可以帮助我们看到它：</target>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="translated">让我们在实践中看一下。使用 &lt;code&gt;iex -S mix&lt;/code&gt; 启动控制台，然后尝试：</target>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="translated">让我们将子级定义（在 &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt; 中）稍微更改为一个元组列表，而不是原子列表：</target>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="translated">让我们从 &lt;code&gt;iex&lt;/code&gt; 的模块开始iex：</target>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="translated">让我们使用 &lt;code&gt;mix new&lt;/code&gt; 开始一个新项目。这个新项目将被命名为 &lt;code&gt;kv_umbrella&lt;/code&gt; ，我们需要在创建它时传递 &lt;code&gt;--umbrella&lt;/code&gt; 选项。不要在现有的 &lt;code&gt;kv&lt;/code&gt; 项目中创建这个新项目！</target>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="translated">让我们开始创建一个模块，该模块在使用时定义并导入 &lt;code&gt;test&lt;/code&gt; 宏：</target>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="translated">让我们从一个测试开始，该测试描述了在存储桶停止或崩溃时我们希望注册表如何运行：</target>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="translated">让我们简要看一下那些生成的文件。</target>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="translated">让我们更深入地研究 &lt;code&gt;Enumerable&lt;/code&gt; ,以及它们的懒惰对象 &lt;code&gt;Stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="translated">让我们来看看上司：</target>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="translated">让我们编写一个测试来验证我们的路由器是否正常工作。创建一个名为 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; 的文件，其中包含：</target>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="translated">让我们写一些代码！</target>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="translated">让我们建立一个流,然后列举它。</target>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="translated">让我们通过连接两个字符串并在它们之间断开来创建一个文档。</target>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="translated">让我们探索用于调试的&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块&lt;/a&gt;的基本功能：</target>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="translated">让我们解决我们的宏。</target>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="translated">我们来试一试。首先启动一个新的shell。</target>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="translated">让我们来看一个快速的案例分析:我们想检查一个函数参数是偶数还是奇数。使用模式匹配,这是不可能的,因为有无限的整数,因此我们不能在单个偶数/奇数上进行模式匹配。让我们把重点放在对偶数的检查上,因为对奇数的检查几乎是一样的。</target>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">让我们看一个简单的例子。试想一下，你实现打破两个部分基础上划线的第一次出现的字符串库 &lt;code&gt;-&lt;/code&gt; 性格：</target>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="translated">让我们来看看一个在函数子句中使用守护的例子。</target>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="translated">我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="translated">让我们看看如何使用这些函数来调试我们前面定义的栈服务器。</target>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="translated">我们来看看一些例子。下面的代码。</target>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="translated">让我们从一个代码示例开始,然后探索可用的回调。想象一下,我们想要一个像堆栈一样工作的GenServer,允许我们推送和弹出元素。</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">我们先来举个例子。</target>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">假设您在 &lt;code&gt;MyMacros&lt;/code&gt; 模块中创建了自己的&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。如果要调用它，首先需要明确要求 &lt;code&gt;MyMacros&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">假设您要研究某些特定功能的情况。通过从该函数调用&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，IEX将允许您访问其绑定（变量），验证其词法信息并访问过程信息。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="translated">让我们了解一下 &lt;code&gt;:shutdown&lt;/code&gt; 和 &lt;code&gt;:restart&lt;/code&gt; 选项所控制的内容。</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="translated">词汇范围</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="translated">图书馆指南</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">与&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;一样，此模块中的函数以线性时间运行。这意味着执行操作所花费的时间与列表的长度以相同的速率增长。这在&lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; 之类的&lt;/a&gt;操作上是预期的。毕竟，如果要遍历流中的每个元素，则流越长，需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="translated">限制某个时区的开始或结束时间。</target>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="translated">行 &lt;code&gt;0&lt;/code&gt; 和列 &lt;code&gt;0&lt;/code&gt; 将意味着左上角。</target>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="translated">也可以通过调用 &lt;code&gt;Process.link/1&lt;/code&gt; 手动完成链接。我们建议您查看&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;&amp;ldquo; &lt;code&gt;Process&lt;/code&gt; 模块&lt;/a&gt;，了解流程提供的其他功能。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="translated">链接是双向的。如果你链接了两个进程,其中一个进程崩溃了,另一边也会崩溃(除非它是陷阱退出)。监控器是单向的:只有监控进程才会收到关于被监控进程的通知。换句话说:当你想要链接崩溃时就使用链接,而当你只想得到崩溃、退出等通知时就使用监视器。</target>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="translated">链接是双向的,这意味着 bucket 的崩溃将使注册表崩溃。虽然我们现在有了监督器,保证了注册表的恢复和运行,但注册表的崩溃仍然意味着我们失去了所有将 bucket 名称与其各自进程关联的数据。</target>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">链接是双向的。可以使用&lt;a href=&quot;#unlink/1&quot;&gt; &lt;code&gt;unlink/1&lt;/code&gt; &lt;/a&gt;取消链接的进程。</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="translated">允许的表达方式列表</target>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="translated">关键字列表中支持的键列表。</target>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="translated">列表运算符从不修改现有列表。连接到列表或从列表中删除元素将返回一个新列表。我们说Elixir数据结构是&lt;em&gt;不可变的&lt;/em&gt;。不变性的一个优点是可以使代码更清晰。您可以自由传递数据，并保证没有人会在内存中对其进行突变-仅对其进行转换。</target>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">List.Chars &lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="translated">List.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="translated">List.Chars.to_charlist (1)</target>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="translated">侦听一个端口,直到该端口可用,并获得套接字。</target>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="translated">列出所有依赖关系及其状态。</target>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="translated">列出所有需要的文件。</target>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="translated">列出所有任务和别名,或打印指定任务或别名的文档。</target>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="translated">列表是逐元素比较的。</target>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="translated">列表以链接列表的形式存储在内存中,这意味着列表中的每个元素都会保持其值,并指向下一个元素,直到到达列表的末端。这意味着访问一个列表的长度是一个线性操作:我们需要遍历整个列表,才能算出它的大小。</target>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="translated">列出命令行参数。</target>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="translated">Elixir中的列表是有效的链接列表,这意味着它们在内部以包含列表头和尾的对来表示。</target>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="translated">Elixir中的列表是在方括号中指定的。</target>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="translated">列表还是元组?</target>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="translated">列表、元组和二进制</target>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="translated">列表、元组、位串、映射、结构和函数调用,如果在开头括号中跟了一个新行,在结尾括号中又跟了一个新行,那么它们将被分成多行。</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="translated">加载应用程序&lt;em&gt;不会&lt;/em&gt;加载其模块。</target>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="translated">加载应用程序</target>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="translated">加载应用程序不会启动它,也不会加载它的模块,但会加载它的环境。</target>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="translated">载入所有代码路径中的所有任务。</target>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">加载给定 &lt;code&gt;paths&lt;/code&gt; 中的所有任务。</target>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="translated">加载并坚持给定的配置。</target>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="translated">加载配置(通常在系统启动时)。</target>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">加载给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="translated">加载给定模块的BEAM代码(并确保之前的旧版本已被正确清除)。</target>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="translated">无需模块即可捕获局部或导入的函数，例如 &lt;code&gt;is_function/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="translated">定位系统中的一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="translated">日志采集</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="translated">Logger通过提供一个翻译器,允许开发人员将OTP应用程序提供的日志消息改写成与Elixir日志消息更兼容的格式。</target>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="translated">Logger还允许通过 &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; 选项（参见下文）完全删除日志命令。</target>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="translated">当系统中发生感兴趣的事件时,日志记录对跟踪非常有用。例如,每当有用户被删除时,进行记录可能会很有用。</target>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="translated">记录一个调试信息。</target>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="translated">动态地记录消息。</target>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">记录具有给定 &lt;code&gt;level&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="translated">记录一条警告信息。</target>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="translated">记录错误信息。</target>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="translated">记录信息消息。</target>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="translated">查询、派遣和注册是高效和即时的,但代价是延迟退订。例如,如果一个进程崩溃了,它的键会自动从注册表中删除,但变化可能不会立即传播。这意味着某些操作可能会返回已经死亡的进程。当这种情况可能发生时,将在函数文档中明确说明。</target>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="translated">通过递归循环</target>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="translated">解析一个选项的低级函数。</target>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">对我们来说幸运的是， &lt;code&gt;use GenServer&lt;/code&gt; 已经完全像上面一样定义了 &lt;code&gt;Stack.child_spec/1&lt;/code&gt; 。如果需要自定义&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则可以直接传递选项以 &lt;code&gt;use GenServer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="translated">幸运的是,Elixir自带的功能可以将我们到目前为止所写的所有代码打包到一个单一的目录中,这个目录也包括Elixir和Erlang虚拟机,它有一个简单的入口点,并且支持自定义配置。这个功能叫做发布,它还提供了很多其他的好处,我们接下来会看到。</target>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="translated">幸运的是，ExUnit附带了一种标记测试的功能，使我们能够运行特定的回调，甚至基于这些标记完全过滤测试。我们已经在上一章中使用了 &lt;code&gt;:capture_log&lt;/code&gt; 标记，它的语义由ExUnit本身指定。</target>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="translated">幸运的是，理解力还支持 &lt;code&gt;:reduce&lt;/code&gt; 选项，这使我们可以将上述两个步骤融合为一个步骤：</target>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="translated">幸运的是，由于服务器是由管理员监督的，因此管理员将自动使用初始堆栈 &lt;code&gt;[:hello]&lt;/code&gt; 启动一个新服务器：</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="translated">宏观卫生</target>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;的基于宏的快捷方式。</target>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="translated">宏(本地或远程)</target>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="translated">宏是一种强大的结构,Elixir提供了许多机制来确保它们得到负责任的使用。</target>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="translated">宏是显式的:如果不显式地调用一个宏,就不可能运行它。例如,一些语言允许开发人员在幕后完全重写函数,通常是通过解析变换或通过一些反射机制。在Elixir中,在编译时必须在调用者中显式调用宏。</target>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="translated">宏是卫生的:默认情况下,在宏内定义的变量不会影响用户代码。此外,在宏上下文中可用的函数调用和别名也不会泄露到用户上下文中。</target>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="translated">宏是词汇性的：不可能全局注入代码或宏。为了使用宏，您需要显式 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 定义宏的模块。</target>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="translated">宏不能被覆盖为函数,反之亦然。</target>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">由以上防护组成的任意组合构成的宏也是有效的防护，例如&lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见下面显示的&amp;ldquo;定义自定义保护表达式&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="translated">Elixir中的宏是通过 &lt;code&gt;defmacro/2&lt;/code&gt; 定义的。</target>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="translated">在使用前必须定义宏。</target>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="translated">宏接收引号表达式,必须返回引号表达式。但是,在执行宏的过程中,有时可能需要处理值,需要区分值和引号表达式。</target>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="translated">巨集的语言很明确：许多语言都提供了 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;unquote&lt;/code&gt; 的语法快捷方式。在Elixir中，我们希望将它们明确地拼写清楚，以便清楚地界定宏定义及其引用表达式的边界。</target>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="translated">同步调用 &lt;code&gt;server&lt;/code&gt; 并等待其回复。</target>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="translated">使 &lt;code&gt;module&lt;/code&gt; 的给定函数可重写。</target>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="translated">使当前模块中给定的函数可以被覆盖。</target>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">手动实现所有类型的协议会很快变得重复且乏味。在这种情况下，Elixir提供了两种选择：我们可以显式派生我们类型的协议实现，或自动实现所有类型的协议。在这两种情况下，我们都需要实现 &lt;code&gt;Any&lt;/code&gt; 的协议。</target>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="translated">手动可以启动为:</target>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">许多功能是成对出现的，例如&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;将返回成功或失败的元组，而&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;将返回纯值或引发异常：</target>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到许多实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的地图功能。此外，在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;可以找到以下地图功能：</target>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，对于任何其他时区都返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 模块中的许多函数接受任何可枚举的参数作为参数，并作为结果返回流。它还提供用于创建流的功能。例如， &lt;code&gt;Stream.cycle/1&lt;/code&gt; 可用于创建无限循环给定枚举的流。注意不要在此类流上调用像 &lt;code&gt;Enum.map/2&lt;/code&gt; 这样的函数，因为它们会永远循环：</target>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="translated">标准库中的许多函数都遵循具有引发异常的对象而不是返回要匹配的元组的模式。该公约是创建一个函数（ &lt;code&gt;foo&lt;/code&gt; ）返回 &lt;code&gt;{:ok, result}&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 元组和另一个函数（ &lt;code&gt;foo!&lt;/code&gt; ，名称相同，但后面有个 &lt;code&gt;!&lt;/code&gt; 是采用相同的参数）， &lt;code&gt;foo&lt;/code&gt; 但如果有错误，则会引发异常。 &lt;code&gt;foo!&lt;/code&gt; 如果一切正常，则应返回结果（不包装在元组中）。该&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; 模块&lt;/a&gt;是本公约的一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="translated">该模块中的许多功能都希望将IO设备作为参数。IO设备必须是PID或表示过程的原子。为了方便起见，Elixir提供了 &lt;code&gt;:stdio&lt;/code&gt; 和 &lt;code&gt;:stderr&lt;/code&gt; 作为Erlang的 &lt;code&gt;:standard_io&lt;/code&gt; 和 &lt;code&gt;:standard_error&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="translated">该模块中的许多功能都通过 &lt;code&gt;:capture&lt;/code&gt; 选项处理在正则表达式匹配中捕获的内容。支持的值为：</target>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">该模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，对于任何其他时区都返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">该模块中的许多功能都与模式一起使用。例如，&lt;a href=&quot;string#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt;可以将一个字符串分成给定模式的多个字符串。此模式可以是字符串，字符串列表或已编译模式：</target>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="translated">许多模块共享相同的公共API。看一下&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;，正如其描述所指出的那样，它是Web应用程序中可组合模块的&lt;strong&gt;规范&lt;/strong&gt;。每个&lt;em&gt;插件&lt;/em&gt;都是一个模块，&lt;strong&gt;必须&lt;/strong&gt;至少实现两个公共功能： &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块中定义的许多功能都在内部调用此功能。当使用方括号访问语法（ &lt;code&gt;structure[key]&lt;/code&gt; ）时，也会使用此函数：调用由定义 &lt;code&gt;structure&lt;/code&gt; struct 的模块实现的&lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt;回调，如果返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 则 &lt;code&gt;value&lt;/code&gt; 为返回，或者如果返回 &lt;code&gt;:error&lt;/code&gt; ,则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; 模块中的许多功能都需要一个环境。您可以&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;在 &lt;code&gt;Macro&lt;/code&gt; 模块的文档中&lt;/a&gt;阅读有关这些功能的更多信息，并在&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;文档中了解有关编译环境的更多信息。</target>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">在&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到为列表提供的许多实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的功能。</target>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="translated">通过使用 &lt;code&gt;-&lt;/code&gt; 作为分隔符，可以提供许多选项。顺序是任意的，因此以下各项都是等效的：</target>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">很多时候，可以根据现有实体的功能来执行结构检查。例如，这是&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">映射/字典作为&lt;a href=&quot;enum#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="translated">地图允许任何值作为键。</target>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="translated">映射还支持特定的更新语法来更新存储在&lt;em&gt;现有&lt;/em&gt;原子键下的值：</target>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="translated">一次映射并加入给定的 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="translated">地图和关键词列表</target>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="translated">映射并减少一个 &lt;code&gt;enumerable&lt;/code&gt; ，将给定的结果展平（仅深一层）。</target>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="translated">地图先按大小比较,然后按升项顺序比较键,再按键顺序比较值。在地图键排序的具体情况下,整数总是被认为小于浮点数。</target>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">映射是Elixir中的&amp;ldquo;转到&amp;rdquo;键值数据结构。可以使用 &lt;code&gt;%{}&lt;/code&gt; 语法创建映射，并且键值对可以表示为 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="translated">地图可以在上进行模式匹配。当地图在模式匹配的左侧时,如果右侧的地图包含了左侧的键,并且它们的值与左侧的键相匹配,那么该地图就会匹配。这意味着空地图会匹配每一张地图。</target>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">映射不对键类型施加任何限制：任何东西都可以是映射中的键。作为键值结构，映射不允许重复的键。使用精确相等运算符（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）比较密钥。如果在地图文字中定义了冲突键，则以最后一个为准。</target>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="translated">映射具有以下用于更新键值的语法：</target>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="translated">映射给定的 &lt;code&gt;fun&lt;/code&gt; 在 &lt;code&gt;enumerable&lt;/code&gt; 和变平的结果。</target>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="translated">地图使用 &lt;code&gt;%{...}&lt;/code&gt; 表示法，并且每个键值均由带有 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的标记对给出，例如 &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="translated">地图的键不遵循任何顺序。</target>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="translated">Markdown使用反引号（ &lt;code&gt;`&lt;/code&gt; ）引用代码。Elixir在此基础上构建，以在引用模块或函数名称时自动生成链接。因此，请始终使用完整的模块名称。如果您有一个名为 &lt;code&gt;MyApp.Hello&lt;/code&gt; 的模块，则始终将其引用为 &lt;code&gt;`MyApp.Hello`&lt;/code&gt; 而永远不要将其引用为 &lt;code&gt;`Hello`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标记 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 仅用于自定义EEx引擎，默认情况下未实现。在没有适当实现的情况下使用它们会引发&lt;a href=&quot;eex.syntaxerror&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="translated">标志着系统是否应该在ARGV处理结束时停止。</target>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="translated">掌握Markdown</target>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">MatchError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="translated">匹配或建立一个结构。</target>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="translated">将给定的表达式与给定的子句进行匹配。</target>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">匹配的术语 &lt;code&gt;left&lt;/code&gt; 反对对正则表达式或字符串 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="translated">将右边的数值与左边的图案进行匹配。</target>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="translated">处理行为的机制。</target>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">成员资格使用match（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）运算符进行测试。</target>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="translated">合并两个URI。</target>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="translated">合并两个配置。</target>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="translated">将两个关键词列表合并为一个。</target>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">将两张地图合并为一张，通过给定的 &lt;code&gt;fun&lt;/code&gt; 解决冲突。</target>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="translated">将两张地图合并为一张。</target>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="translated">消息和函数API</target>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="translated">信息格式</target>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="translated">元编程指南</target>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="translated">Elixir中的元编程</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="translated">元数据可以有任何键。文档工具经常使用元数据为读者提供更多数据,丰富用户体验。</target>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">可以使用&lt;a href=&quot;logger#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;函数读写要发送到记录器的元数据。例如，您可以设置 &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; 将user_id元数据添加到当前进程。用户可以配置后端以选择要打印的 &lt;code&gt;$metadata&lt;/code&gt; ，它将替换$ metadata值。</target>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="translated">微秒也可以给出一个精度,这个精度必须是0到6之间的整数。</target>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="translated">储存精度的微秒。</target>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;use Mix.Config&lt;/code&gt; 迁移</target>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="translated">从主管的:simple_one_for_one进行迁移。</target>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">缺少父目录已创建。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">没有创建丢失的父目录。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">混合任务</target>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="translated">当存储Mix 的内容和配置时，它还会回 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 和 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="translated">Mix还生成了一个名为 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 的文件，该文件负责设置测试框架：</target>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="translated">Mix还生成了用于运行我们的项目测试的适当结构。Mix项目通常遵循以下惯例：对于 &lt;code&gt;lib&lt;/code&gt; 目录中的每个文件，在 &lt;code&gt;test&lt;/code&gt; 目录中均具有 &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; 文件。因此，我们已经可以找到与我们的 &lt;code&gt;lib/kv.ex&lt;/code&gt; 文件相对应的 &lt;code&gt;test/kv_test.exs&lt;/code&gt; 。在这一点上，它并没有做很多事情：</target>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">Mix还在 &lt;code&gt;lib/kv.ex&lt;/code&gt; 处生成一个文件，该文件包含一个模块，该模块包含一个仅称为 &lt;code&gt;hello&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="translated">Mix还可以管理您的依赖项，并与&lt;a href=&quot;https://hex.pm&quot;&gt;Hex软件包管理器&lt;/a&gt;很好地集成。</target>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="translated">Mix还支持Git和路径依赖。</target>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="translated">混合和OTP</target>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="translated">混合和OTP指南</target>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mix可用于管理没有任何Elixir代码的Erlang项目。为了确保Mix任务对于Erlang项目正确运行， &lt;code&gt;language: :erlang&lt;/code&gt; 必须是 &lt;code&gt;project/0&lt;/code&gt; 返回的配置的一部分。此设置还确保不会将Elixir作为依赖项添加到生成的 &lt;code&gt;.app&lt;/code&gt; 文件或使用&lt;a href=&quot;mix.tasks.escript.build&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;生成的escript中，依此类推。</target>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="translated">Mix是一种构建工具，因此预计不会在生产中提供。因此，建议访问 &lt;code&gt;Mix.env&lt;/code&gt; 只在配置文件和内部 &lt;code&gt;mix.exs&lt;/code&gt; ，从来没有在应用程序代码（ &lt;code&gt;lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="translated">Mix是一个构建工具,它提供了创建、编译、测试Elixir项目、管理其依赖关系等任务。</target>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="translated">Mix是Elixir的项目管理和构建工具。从命令行调用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;将在每个文件中运行测试，这些文件与在项目的 &lt;code&gt;test&lt;/code&gt; 目录中找到的模式 &lt;code&gt;*_test.exs&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="translated">Mix区分项目和应用程序。根据 &lt;code&gt;mix.exs&lt;/code&gt; 文件的内容，我们可以说我们有一个Mix项目，它定义了 &lt;code&gt;:kv&lt;/code&gt; 应用程序。正如我们将在后面的章节中看到的，有些项目没有定义任何应用程序。</target>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="translated">Mix提供了许多处理依赖项的任务，可以在 &lt;code&gt;mix help&lt;/code&gt; 看到：</target>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="translated">Mix提供了&amp;ldquo;环境&amp;rdquo;的概念。它们允许开发人员针对特定情况自定义编译和其他选项。默认情况下，Mix了解三种环境：</target>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="translated">混合对以下变量作出反应:</target>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="translated">混合壳使用当前进程邮箱进行通信。</target>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="translated">Mix在 &lt;code&gt;profile&lt;/code&gt; 名称空间下附带了许多任务，例如 &lt;code&gt;cprof&lt;/code&gt; 和 &lt;code&gt;fprof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="translated">Mix支持不同的环境。环境允许开发人员针对不同的场景专门准备和组织他们的项目。默认情况下,Mix提供了三种环境。</target>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">混合任务只能运行一次。这样可以防止同一任务多次执行。例如，如果有多个任务取决于&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;，则代码将被编译一次。如果使用&lt;a href=&quot;mix.task#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; &lt;/a&gt;显式重新启用了任务，则可以再次执行任务：</target>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="translated">Mix将创建一个名为 &lt;code&gt;kv&lt;/code&gt; 的目录，其中包含一些文件：</target>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="translated">Mix将默认为 &lt;code&gt;:dev&lt;/code&gt; 环境，但 &lt;code&gt;test&lt;/code&gt; 任务将默认为 &lt;code&gt;:test&lt;/code&gt; 环境。可以通过 &lt;code&gt;MIX_ENV&lt;/code&gt; 环境变量来更改环境：</target>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在执行测试之前，Mix将加载 &lt;code&gt;test_helper.exs&lt;/code&gt; 文件。这是没有必要 &lt;code&gt;require&lt;/code&gt; 的 &lt;code&gt;test_helper.exs&lt;/code&gt; 在您的测试文件的文件。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;Mix.Tasks.Test&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.InvalidTaskError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoProjectError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoTaskError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Task &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="translated">修改命令行参数。</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">模块&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">模块属性</target>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="translated">模块和描述标签</target>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="translated">模块属性</target>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="translated">Elixir中的模块属性有三个用途。</target>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="translated">模块属性读取器（ &lt;code&gt;@foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="translated">模块嵌套</target>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="translated">用于处理、定义和导入记录的模块。</target>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="translated">基于模块的监督员</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">采用 &lt;code&gt;Parser&lt;/code&gt; 行为的模块将必须实现使用 &lt;code&gt;@callback&lt;/code&gt; 指令定义的所有功能。如您所见， &lt;code&gt;@callback&lt;/code&gt; 需要一个函数名称，但也需要一个函数规范，例如上面我们在 &lt;code&gt;@spec&lt;/code&gt; 指令中使用的函数规范。另请注意， &lt;code&gt;term&lt;/code&gt; 类型用于表示解析后的值。在Elixir中， &lt;code&gt;term&lt;/code&gt; 类型是表示任何类型的快捷方式。</target>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="translated">模块和功能</target>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="translated">用HiPE编译的模块不会调用这个钩子。</target>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="translated">尚未加载的模块将不会显示。如果要预加载所有任务，请检查&lt;a href=&quot;#load_all/0&quot;&gt; &lt;code&gt;load_all/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="translated">与基础系统接口的模块,如:</target>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="translated">监控器还是链接?</target>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="translated">监控节点的状态。</target>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="translated">如果提供 &lt;code&gt;--callers&lt;/code&gt; 和 &lt;code&gt;--details&lt;/code&gt; 选项，则返回更多详细信息。</target>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配对函数的更多示例：&lt;a href=&quot;base#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;base#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="translated">有关字素的更多信息，请参见&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode标准附件＃29&lt;/a&gt;。当前的Elixir版本实现了扩展字素簇算法。</target>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在&lt;a href=&quot;tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;模块中可以找到有关元组数据类型和操作元组的函数的更多信息。&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中还提供了一些用于元组的函数（例如&lt;a href=&quot;kernel#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期时间的更多信息，请参见&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期的更多信息，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关原始日期时间的更多信息，可以在&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关时间的更多信息，可以在&amp;ldquo; &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="translated">更有趣的是，我们可以匹配特定的值。下面的示例断言，仅当右侧是以原子 &lt;code&gt;:ok&lt;/code&gt; 开头的元组时，左侧才与右侧匹配：</target>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有更多选项可用；有关可用选项的完整列表，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="translated">而且，即使在退出陷阱时，如果任务已终止但未将其结果送回，则调用 &lt;code&gt;await&lt;/code&gt; 仍将退出。</target>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="translated">大多数Elixir代码都对其底层引用表达式进行了直接转换。我们建议您尝试不同的代码示例，看看结果如何。例如， &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; 扩展为什么？我们还了解到 &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; 与 &lt;code&gt;if true do :this else :that end&lt;/code&gt; 。这种肯定如何与带引号的表达式一起使用？</target>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="translated">大多数编辑器都提供了与格式化器的内置集成,允许在保存时或通过选定的键绑定对文件进行格式化。如果你正在学习Elixir,编辑器集成可以让你在学习Elixir语法时得到有用而快速的反馈。</target>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="translated">如果成功，此模块中的大多数功能将返回 &lt;code&gt;:ok&lt;/code&gt; 或 &lt;code&gt;{:ok, result}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。这些功能还有一个以 &lt;code&gt;!&lt;/code&gt; 结尾的变体！如果成功则返回结果（而不是 &lt;code&gt;{:ok, result}&lt;/code&gt; 元组），如果失败则抛出异常。例如：</target>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">该模块中的大多数功能都是线性工作的。这意味着执行操作所需的时间以与列表长度相同的速率增长。例如&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt;将在线性时间内运行，因为它们需要遍历列表中的每个元素，而&lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt;将在恒定时间内运行，因为它仅需要第一个元素。</target>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="translated">本模块中的大部分函数都是以线性时间工作的。这意味着,执行一个操作所需的时间与列表的长度以相同的速度增长。</target>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="translated">在捕捉函数时,可以看到大部分内联函数的效果。</target>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;中的大多数操作都是按照reduce来实现的。此函数应将给定的&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数应用于 &lt;code&gt;enumerable&lt;/code&gt; 每个元素，并按返回的累加器的预期进行。</target>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">在大多数情况下，将模块写入文件很方便，因此可以对其进行编译和重用。假设我们有一个名为 &lt;code&gt;math.ex&lt;/code&gt; 的文件，其中包含以下内容：</target>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="translated">大多数时候,在某个时区的某个日期和时间,只有一个有效的日期时间。</target>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="translated">大多数时候，Elixir会引导您做正确的事。例如，有一个 &lt;code&gt;elem/2&lt;/code&gt; 函数可以访问一个元组项，但是列表没有内置的等效项：</target>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="translated">将未记录的函数移至具有 &lt;code&gt;@moduledoc false&lt;/code&gt; 的模块（例如 &lt;code&gt;MyApp.Hidden&lt;/code&gt; )，以确保不会意外暴露或导入该函数。记住，您可以使用 &lt;code&gt;@moduledoc false&lt;/code&gt; 来隐藏整个模块，并仍然使用 &lt;code&gt;@doc&lt;/code&gt; 记录每个函数。工具仍将忽略该模块。</target>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="translated">好多了！ &lt;code&gt;with&lt;/code&gt; 将检索 &lt;code&gt;&amp;lt;-&lt;/code&gt; 右侧返回的值，并将其与左侧的模式匹配。如果值与模式匹配，则 &lt;code&gt;with&lt;/code&gt; 移至下一个表达式。如果没有匹配项，则返回不匹配的值。</target>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="translated">多重别名/进口/要求/使用。</target>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; 中的&lt;/a&gt;多字母别名</target>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="translated">多行字符列表用三个单引号（ &lt;code&gt;'''&lt;/code&gt; ）编写，与多行字符串相同。</target>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="translated">多行列表、地图、元组等。</target>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="translated">Elixir中的多行字符串用三个双引号引起来，并且其中可以包含未转义的引号。结果字符串将以换行符结尾。最后一个 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 缩进用于从内部字符串中去除缩进。例如：</target>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="translated">多个码点可能被读者认为是一个字符。</target>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="translated">多个生成器也可以用来计算两个列表的卡提斯积。</target>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="translated">同一条款中的多个卫士</target>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="translated">多重执行</target>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="translated">多个版本。你可以根据每个应用程序的不同配置来组合不同的版本,甚至可以将不同的应用程序完全组合在一起。</target>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; 的多种用法会累积而不是覆盖以前的用法。请参阅下面的&amp;ldquo;编译选项&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="translated">&lt;code&gt;@dialyzer&lt;/code&gt; 的多次使用将累积而不是覆盖以前的用途。</target>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="translated">可变状态和对共享资源(如ETS、文件等)的访问。</target>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="translated">我的计算机名为 &lt;code&gt;jv&lt;/code&gt; ，因此在上面的示例中看到 &lt;code&gt;foo@jv&lt;/code&gt; ，但是您将得到不同的结果。在以下示例中，我们将使用 &lt;code&gt;foo@computer-name&lt;/code&gt; ，并且在尝试代码时应相应地对其进行更新。</target>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="translated">可以通过键入 &lt;code&gt;ctrl + ]&lt;/code&gt; ，键入 &lt;code&gt;quit&lt;/code&gt; 并按 &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; 退出我特定的telnet客户端，但是您的客户端可能需要不同的步骤。</target>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="translated">姓名登记</target>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="translated">已命名的职能</target>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="translated">Elixir中的命名函数也支持默认参数。</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">命名惯例</target>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="translated">命名过程</target>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="translated">负极开关</target>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="translated">支持负的Unix时间,最高可达-62167219200秒,相当于 &quot;0000-01-01T00:00:00Z &quot;或0格里高利秒。</target>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="translated">负索引表示与 &lt;code&gt;list&lt;/code&gt; 末尾的偏移量。如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则返回原始 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="translated">嵌套数据结构</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="translated">将一个模块嵌套在另一个模块中会影响嵌套模块的名称。</target>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">将给定文档嵌套在给定 &lt;code&gt;level&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新版本在只读&lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;公告邮件列表中宣布&lt;/a&gt;。所有安全发行版&lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;都将标有 &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="translated">在某些运营商(如管道运营商)之前和其他运营商(如比较运营商)之前添加新行。</target>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="translated">块内的新行与输入中一样,除此之外。1)多行的表达式前后总是有一个空行 2)空行总是被挤在一起成为一个空行。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">今后的步骤</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="translated">接下来，让我们讨论外部和内部依赖性以及Mix如何帮助我们管理大型代码库。</target>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="translated">接下来，我们将看一下Elixir的核心功能Processes，它使我们能够以简单易懂的方式编写并发，并行和分布式程序。</target>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非我们调用&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;函数之一或&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; ,&lt;/a&gt;否则不会进行任何计算。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
