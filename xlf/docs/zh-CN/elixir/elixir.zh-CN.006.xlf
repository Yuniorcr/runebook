<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="f248a387f0f37e77ff666c2a85a59f7074c24d85" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;@deprecated&lt;/code&gt; only supports functions and macros. However you can use the &lt;code&gt;:deprecated&lt;/code&gt; key in the annotation metadata to annotate the docs of modules, types and callbacks too.</source>
          <target state="translated">当前 &lt;code&gt;@deprecated&lt;/code&gt; 仅支持函数和宏。但是，您也可以在注释元数据中使用 &lt;code&gt;:deprecated&lt;/code&gt; 键来注释模块，类型和回调的文档。</target>
        </trans-unit>
        <trans-unit id="51f90102aa9d37408ac2a331660c80b3de845ceb" translate="yes" xml:space="preserve">
          <source>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</source>
          <target state="translated">目前,它为Elixir中的日历行为定义了类型和最低限度的实现。Elixir中的日历功能的目标是为互操作性提供一个基础,而不是全功能的日期时间API。</target>
        </trans-unit>
        <trans-unit id="58e947fb9b58beb32c0020272eaa3d95ced9ee44" translate="yes" xml:space="preserve">
          <source>Currently the only accepted PID is &lt;code&gt;self()&lt;/code&gt;.</source>
          <target state="translated">当前唯一接受的PID是 &lt;code&gt;self()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63f26076c7ac35014e638bc9d9a7df511fa73b4d" translate="yes" xml:space="preserve">
          <source>Currently we have two tests tagged with &lt;code&gt;@tag :distributed&lt;/code&gt;. The &amp;ldquo;server interaction&amp;rdquo; test in &lt;code&gt;KVServerTest&lt;/code&gt;, and the &amp;ldquo;route requests across nodes&amp;rdquo; in &lt;code&gt;KV.RouterTest&lt;/code&gt;. Both tests are failing since they require a routing table, which is currently empty.</source>
          <target state="translated">目前，我们有两个标记为 &lt;code&gt;@tag :distributed&lt;/code&gt; 测试。 &lt;code&gt;KVServerTest&lt;/code&gt; 中的&amp;ldquo;服务器交互&amp;rdquo;测试，以及KV.RouterTest中的&amp;ldquo;跨节点的路由请求&amp;rdquo; &lt;code&gt;KV.RouterTest&lt;/code&gt; 。两项测试均失败，因为它们需要路由表，该路由表当前为空。</target>
        </trans-unit>
        <trans-unit id="fb478f5ec7bb7da049009c9e3df88349c2f53b74" translate="yes" xml:space="preserve">
          <source>Currently, there is no official way to cross-compile a release from one target triple to another, due to the complexities involved in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdaaebe2bbb603df00e4573b0900ccd99aa7d09" translate="yes" xml:space="preserve">
          <source>Custom Sigils</source>
          <target state="translated">自定义符号</target>
        </trans-unit>
        <trans-unit id="d797cab8a29cd6c10dc9372d1ab9213b989caf7f" translate="yes" xml:space="preserve">
          <source>Custom and overridden operators</source>
          <target state="translated">自定义和重写操作符</target>
        </trans-unit>
        <trans-unit id="00146f5b748062fe67c9600ecfcdf444284e0bcf" translate="yes" xml:space="preserve">
          <source>Custom attributes</source>
          <target state="translated">自定义属性</target>
        </trans-unit>
        <trans-unit id="e3fd71a31afaaf057b0fedc28ba72336f1780a64" translate="yes" xml:space="preserve">
          <source>Custom backends</source>
          <target state="translated">自定义后端</target>
        </trans-unit>
        <trans-unit id="abe70270d1f6e2920fe2d28c23289b5295fb962a" translate="yes" xml:space="preserve">
          <source>Custom configuration</source>
          <target state="translated">自定义配置</target>
        </trans-unit>
        <trans-unit id="170bc5dc5f750c41d4def27ed27eed6bf3c468fb" translate="yes" xml:space="preserve">
          <source>Custom editors are supported by using the &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; notations, for example:</source>
          <target state="translated">通过使用 &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 表示法支持自定义编辑器，例如：</target>
        </trans-unit>
        <trans-unit id="642fb7c499e4524f98e2922e90ae2a2b071cfd52" translate="yes" xml:space="preserve">
          <source>Custom formatting</source>
          <target state="translated">自定义格式</target>
        </trans-unit>
        <trans-unit id="cfa121c3915c8b4ef6e8270f4ee6bf76b09bdab9" translate="yes" xml:space="preserve">
          <source>Custom patterns and guards expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb31d3e78f5111c059041eed039c75877655487" translate="yes" xml:space="preserve">
          <source>Custom sigils</source>
          <target state="translated">定制标志</target>
        </trans-unit>
        <trans-unit id="39876974b7f78aa10c505abd0ccf4a46df612fca" translate="yes" xml:space="preserve">
          <source>Custom types defined through &lt;code&gt;@type&lt;/code&gt; are exported and are available outside the module they&amp;rsquo;re defined in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b447a4b2b4a5635d3f0dd6f81cbcc0d90e8e4a6d" translate="yes" xml:space="preserve">
          <source>Custom types defined through &lt;code&gt;@type&lt;/code&gt; are exported and available outside the module they&amp;rsquo;re defined in:</source>
          <target state="translated">通过 &lt;code&gt;@type&lt;/code&gt; 定义的自定义类型将被导出，并在定义于以下模块的模块之外可用：</target>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="a43ab69a51d511753170a537818f222e76faeaa7" translate="yes" xml:space="preserve">
          <source>Customization and configuration summary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b25d03b9dabe02b1fafe8ede605cce72a76c6c5" translate="yes" xml:space="preserve">
          <source>Customization per environment can be done by accessing &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;the &lt;code&gt;Mix.env&lt;/code&gt; function&lt;/a&gt; in your &lt;code&gt;mix.exs&lt;/code&gt; file, which returns the current environment as an atom. That&amp;rsquo;s what we have used in the &lt;code&gt;:start_permanent&lt;/code&gt; options:</source>
          <target state="translated">每环境定制可以通过访问来完成&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;的 &lt;code&gt;Mix.env&lt;/code&gt; 功能&lt;/a&gt;在 &lt;code&gt;mix.exs&lt;/code&gt; 文件，返回当前环境作为一个原子。这就是我们在 &lt;code&gt;:start_permanent&lt;/code&gt; 选项中使用的：</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="6908397a2d8b0784b2ec70f0d5374964dc182a77" translate="yes" xml:space="preserve">
          <source>Daemon mode (Unix-like)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303c85db56e6f90f1fcaafbed47e91067f22fbe9" translate="yes" xml:space="preserve">
          <source>Data structures</source>
          <target state="translated">数据结构</target>
        </trans-unit>
        <trans-unit id="696ae3d17016ea7046f1ce357ae0b1f6103499a3" translate="yes" xml:space="preserve">
          <source>Data structures such as lists, tuples, and binaries are marked respectively by the delimiters &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;{...}&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;. Each element is separated by comma. A trailing comma is also allowed, such as in &lt;code&gt;[1, 2, 3,]&lt;/code&gt;.</source>
          <target state="translated">列表，元组和二进制文件等数据结构分别由定界符 &lt;code&gt;[...]&lt;/code&gt; ， &lt;code&gt;{...}&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; 标记。每个元素都用逗号分隔。还可以使用尾部逗号，例如 &lt;code&gt;[1, 2, 3,]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">数据类型</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="904c0db9491168bf7b0f96a8127a1e2e956e54ec" translate="yes" xml:space="preserve">
          <source>Date.Range</source>
          <target state="translated">Date.Range</target>
        </trans-unit>
        <trans-unit id="f1e5baf5ecc3589631088c40cbdd43061976ed8f" translate="yes" xml:space="preserve">
          <source>DateTime</source>
          <target state="translated">DateTime</target>
        </trans-unit>
        <trans-unit id="067497ecd979a531adeb039b5c57048e6702a8f2" translate="yes" xml:space="preserve">
          <source>Day of the month</source>
          <target state="translated">月日</target>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="translated">一周中的一天</target>
        </trans-unit>
        <trans-unit id="7c9881c0cb27c6197626d060644aab99eb05aa54" translate="yes" xml:space="preserve">
          <source>Day of the year</source>
          <target state="translated">一年中的某一天</target>
        </trans-unit>
        <trans-unit id="d0c32ae37c8ec0c5b70c6fbada27ade3b4484def" translate="yes" xml:space="preserve">
          <source>Debug options supported by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 功能支持的调试选项</target>
        </trans-unit>
        <trans-unit id="3dea78e2b42ff6c53cdfe32a0caf66a693083f61" translate="yes" xml:space="preserve">
          <source>Debugger</source>
          <target state="translated">Debugger</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="4dbfbf2c1ca5c9cbf7ff86eebf9f1e60dfaae3c2" translate="yes" xml:space="preserve">
          <source>Debugging with the :sys module</source>
          <target state="translated">使用:sys模块进行调试</target>
        </trans-unit>
        <trans-unit id="49bac63211bb6e767f6bd201454a7033e302753a" translate="yes" xml:space="preserve">
          <source>Decodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">将 &lt;code&gt;string&lt;/code&gt; 解码为&amp;ldquo; x-www-form-urlencoded&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f7d7142bd19e1c0ea0198316fec06393f6cb0ea2" translate="yes" xml:space="preserve">
          <source>Decodes a base 16 encoded string into a binary string.</source>
          <target state="translated">将一个16进制编码的字符串解码为二进制字符串。</target>
        </trans-unit>
        <trans-unit id="fb034015ded81968d20fd5f7e210338ebd758879" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string into a binary string.</source>
          <target state="translated">将32基编码的字符串解码为二进制字符串。</target>
        </trans-unit>
        <trans-unit id="885c7e9658ad97e9a9af45bd4781416e206a6334" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string.</source>
          <target state="translated">将一个以32为基数的扩展十六进制字母编码的字符串解码为二进制字符串。</target>
        </trans-unit>
        <trans-unit id="4b608e75a46b84e1feb5de2f9f73f4f8523e9f1d" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string into a binary string.</source>
          <target state="translated">将一个64基编码的字符串解码为二进制字符串。</target>
        </trans-unit>
        <trans-unit id="b945eb1852da433ae69fcf285b6a56aed338e16f" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string.</source>
          <target state="translated">将带有URL和文件名安全字母的64基编码字符串解码为二进制字符串。</target>
        </trans-unit>
        <trans-unit id="12cd61b38813ead53840f88994a5a092cca61e7f" translate="yes" xml:space="preserve">
          <source>Decodes a query string into a map.</source>
          <target state="translated">将一个查询字符串解码为一个地图。</target>
        </trans-unit>
        <trans-unit id="624612278a208a23a0e8ccd36697aaa475bd3192" translate="yes" xml:space="preserve">
          <source>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</source>
          <target state="translated">将一个本地或远程调用分解为远程部分(如果提供的话)、函数名和参数列表。</target>
        </trans-unit>
        <trans-unit id="7151035c3114809bda0193c2a85fa1a470935213" translate="yes" xml:space="preserve">
          <source>Default Unit</source>
          <target state="translated">默认单位</target>
        </trans-unit>
        <trans-unit id="6bcca2541d3f4eb99df509a0ef05a98d2f536b6d" translate="yes" xml:space="preserve">
          <source>Default arguments</source>
          <target state="translated">默认参数</target>
        </trans-unit>
        <trans-unit id="6593ff7fb992a5e5072fa654c1b194d94010d120" translate="yes" xml:space="preserve">
          <source>Default background color.</source>
          <target state="translated">默认背景色。</target>
        </trans-unit>
        <trans-unit id="6e98c72a394abdbcd4b12051bb239d5b6259e9ce" translate="yes" xml:space="preserve">
          <source>Default text color.</source>
          <target state="translated">默认文本颜色。</target>
        </trans-unit>
        <trans-unit id="89487e7c33b83cf47b069ff9b1fec8587ba1c7a6" translate="yes" xml:space="preserve">
          <source>Default translation for Erlang log messages.</source>
          <target state="translated">Erlang日志信息的默认翻译。</target>
        </trans-unit>
        <trans-unit id="e19bd89011e61a7bb0e77dd718395ff863fa6b57" translate="yes" xml:space="preserve">
          <source>Default values and required keys</source>
          <target state="translated">默认值和所需键</target>
        </trans-unit>
        <trans-unit id="0b6846959c6ecef6294ea2738ab118ae06eb0104" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; for Elixir projects, &lt;code&gt;false&lt;/code&gt; for Erlang projects.</source>
          <target state="translated">对于Elixir项目，默认为 &lt;code&gt;true&lt;/code&gt; ；对于Erlang项目，默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86bc280a68c01f58573355e9cc73f727e31ec7ae" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; for Elixir projects, &lt;code&gt;false&lt;/code&gt; for Erlang projects. Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d69c2362401ce4e3ef9f4dba08bffc1bb4866" translate="yes" xml:space="preserve">
          <source>Define a function from a string (&lt;a href=&quot;#function_from_string/5&quot;&gt;&lt;code&gt;function_from_string/5&lt;/code&gt;&lt;/a&gt;) or a file (&lt;a href=&quot;#function_from_file/5&quot;&gt;&lt;code&gt;function_from_file/5&lt;/code&gt;&lt;/a&gt;). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3da7d067c0e2af23683cd3618963a0c016ef27c" translate="yes" xml:space="preserve">
          <source>Define a function from a string (&lt;code&gt;function_from_string&lt;/code&gt;) or a file (&lt;code&gt;function_from_file&lt;/code&gt;). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</source>
          <target state="translated">从字符串（ &lt;code&gt;function_from_string&lt;/code&gt; ）或文件（ &lt;code&gt;function_from_file&lt;/code&gt; ）定义函数。这使您可以将模板作为函数嵌入模块中，然后再对其进行编译。如果您可以在编译时访问模板，则这是首选的API。</target>
        </trans-unit>
        <trans-unit id="02454c3ef87373b5da454ba33a54d81ec93d84e1" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;@shortdoc&lt;/code&gt; attribute if you wish to make the task publicly visible on &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;. Omit this attribute if you do not want your task to be listed via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af570fa4ced5be1c1e832e70770e29cb3378f42" translate="yes" xml:space="preserve">
          <source>Define the function explicitly (v1.0)</source>
          <target state="translated">明确定义函数 (v1.0)</target>
        </trans-unit>
        <trans-unit id="bc125b89387e69b38c0b71432e6451758cd10e9b" translate="yes" xml:space="preserve">
          <source>Define the rollover moment for the given calendar.</source>
          <target state="translated">定义给定日历的翻转时刻。</target>
        </trans-unit>
        <trans-unit id="cdc8ce38051bdb795b598be018ffa7c0e1241cd3" translate="yes" xml:space="preserve">
          <source>Defined as</source>
          <target state="translated">定义为</target>
        </trans-unit>
        <trans-unit id="0e6d691613c83b20a4bdec6dda26151ba97d0294" translate="yes" xml:space="preserve">
          <source>Defines &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Shell&lt;/code&gt;&lt;/a&gt; contract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c159947b8552c14519d220c3a6ddfaa0e00eeec" translate="yes" xml:space="preserve">
          <source>Defines ExUnit callbacks.</source>
          <target state="translated">定义ExUnit回调。</target>
        </trans-unit>
        <trans-unit id="3fba28715c151409c38236ee7000eb4ed16c82f1" translate="yes" xml:space="preserve">
          <source>Defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">定义&lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="83a9409d00bd2dad95a1afabb5663ee3e1f46569" translate="yes" xml:space="preserve">
          <source>Defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718b6b621786a1acc4c26d42dbc485e26faf7eec" translate="yes" xml:space="preserve">
          <source>Defines a callback that runs once the test exits.</source>
          <target state="translated">定义测试退出后运行的回调。</target>
        </trans-unit>
        <trans-unit id="9200a3742bfb9e88c562c9f6f3ed2f69e18c6f67" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before all tests in a case.</source>
          <target state="translated">定义一个回调,在case的所有测试之前运行。</target>
        </trans-unit>
        <trans-unit id="4b6166591f75c5a4bf0202583ee95cba035668e8" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before each test in a case.</source>
          <target state="translated">定义一个回调,在案例中的每个测试之前运行。</target>
        </trans-unit>
        <trans-unit id="d5bc2aab7b6f9616afc524a405cb7757608452d9" translate="yes" xml:space="preserve">
          <source>Defines a function callback according to the given type specification.</source>
          <target state="translated">根据给定的类型规格定义一个函数回调。</target>
        </trans-unit>
        <trans-unit id="c5db38a50b427e41d0ad25365053a42c56f8a1f7" translate="yes" xml:space="preserve">
          <source>Defines a function that delegates to another module.</source>
          <target state="translated">定义一个委托给其他模块的函数。</target>
        </trans-unit>
        <trans-unit id="307e106c43982d5b12630cb72b848406b819c6c6" translate="yes" xml:space="preserve">
          <source>Defines a function with the given name and body.</source>
          <target state="translated">用给定的名称和主体定义一个函数。</target>
        </trans-unit>
        <trans-unit id="f063e0d1325de98da63498e5fe376536a4c88d2c" translate="yes" xml:space="preserve">
          <source>Defines a macro callback according to the given type specification.</source>
          <target state="translated">根据给定的类型规范定义一个宏回调。</target>
        </trans-unit>
        <trans-unit id="d1bdce6fb82524ea6dca239a6d1b4282ce120736" translate="yes" xml:space="preserve">
          <source>Defines a macro with the given name and body.</source>
          <target state="translated">用给定的名称和主体定义一个宏。</target>
        </trans-unit>
        <trans-unit id="45436ad823527d91893ee57c61d5208fd54f8f28" translate="yes" xml:space="preserve">
          <source>Defines a module given by name with the given contents.</source>
          <target state="translated">定义一个由名称赋予的模块,并赋予其内容。</target>
        </trans-unit>
        <trans-unit id="2b7b7c71d4c9f86dc9189095ea6eb365a7951119" translate="yes" xml:space="preserve">
          <source>Defines a module template to be used throughout your test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf550b43951705ff60d293e8451b26e72a1b3d68" translate="yes" xml:space="preserve">
          <source>Defines a new bitstring.</source>
          <target state="translated">定义一个新的位串。</target>
        </trans-unit>
        <trans-unit id="5e5448d0355663eca910a26c7f674b96bdfb1318" translate="yes" xml:space="preserve">
          <source>Defines a not implemented test with a string.</source>
          <target state="translated">用一个字符串定义一个未实现的测试。</target>
        </trans-unit>
        <trans-unit id="3c2d3289caf113cf07d04f07d984ecc30b13bea4" translate="yes" xml:space="preserve">
          <source>Defines a private function with the given name and body.</source>
          <target state="translated">定义一个给定名称和主体的私有函数。</target>
        </trans-unit>
        <trans-unit id="08a09270f00cde41495279c24131c417ef5be1db" translate="yes" xml:space="preserve">
          <source>Defines a private macro with the given name and body.</source>
          <target state="translated">定义一个给定名称和主体的私有宏。</target>
        </trans-unit>
        <trans-unit id="234e236e77f17928fa5de859398ddc5049a5ff60" translate="yes" xml:space="preserve">
          <source>Defines a protocol.</source>
          <target state="translated">定义一个协议。</target>
        </trans-unit>
        <trans-unit id="49de89ada1df4216656fd082e602510e9a3bfba6" translate="yes" xml:space="preserve">
          <source>Defines a public function with the given name and body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0c62dc473198ec220624054b59c8e5facbee00" translate="yes" xml:space="preserve">
          <source>Defines a public macro with the given name and body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0422852f7761d300210619550ed122f7749dee" translate="yes" xml:space="preserve">
          <source>Defines a range.</source>
          <target state="translated">定义一个范围。</target>
        </trans-unit>
        <trans-unit id="84d0bf0e5d21a052c34ad1cf8cc4fd2c0b2d922d" translate="yes" xml:space="preserve">
          <source>Defines a remote call, a call to an anonymous function, or an alias.</source>
          <target state="translated">定义了远程调用、对匿名函数的调用或别名。</target>
        </trans-unit>
        <trans-unit id="148ce01689924171178db559eb8519855c18cbf6" translate="yes" xml:space="preserve">
          <source>Defines a set of macros to create, access, and pattern match on a record.</source>
          <target state="translated">定义了一组宏,用于在记录上创建、访问和模式匹配。</target>
        </trans-unit>
        <trans-unit id="d43aa789386d3da190d548740ece58b49c1b5c28" translate="yes" xml:space="preserve">
          <source>Defines a struct.</source>
          <target state="translated">定义一个结构。</target>
        </trans-unit>
        <trans-unit id="e8fc9a0e945bdfdd9fe422d72e6867459e1dd52d" translate="yes" xml:space="preserve">
          <source>Defines a test with &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff008b3bfc5f520079685bb6518c7f8c263c332" translate="yes" xml:space="preserve">
          <source>Defines a test with a string.</source>
          <target state="translated">用一个字符串定义一个测试。</target>
        </trans-unit>
        <trans-unit id="e440b3cbec6e05424773317aba5a8cdb773dabba" translate="yes" xml:space="preserve">
          <source>Defines an &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#stream/2&quot;&gt;&lt;code&gt;IO.stream/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a4f177d77d4b3501935507c322bb13c914958e" translate="yes" xml:space="preserve">
          <source>Defines an &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;io#stream/2&quot;&gt;&lt;code&gt;IO.stream/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">定义&lt;a href=&quot;io#stream/2&quot;&gt; &lt;code&gt;IO.stream/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="61d9e7c667e3e371baebf26eb4a1e174baee751d" translate="yes" xml:space="preserve">
          <source>Defines an anonymous function.</source>
          <target state="translated">定义一个匿名函数。</target>
        </trans-unit>
        <trans-unit id="1f336908a8420d524aec43e1dfa0a8c9f56be6ac" translate="yes" xml:space="preserve">
          <source>Defines an exception.</source>
          <target state="translated">定义一个异常。</target>
        </trans-unit>
        <trans-unit id="47c4eab1a12c9a4e9e5bfc15095c4f5f1e7f8420" translate="yes" xml:space="preserve">
          <source>Defines an implementation for the given protocol.</source>
          <target state="translated">定义给定协议的实现。</target>
        </trans-unit>
        <trans-unit id="7574e6578cdcbcf5986b0221d662d60206450586" translate="yes" xml:space="preserve">
          <source>Defines and manipulates Mix projects.</source>
          <target state="translated">定义和操作Mix项目。</target>
        </trans-unit>
        <trans-unit id="c87324807b8cf7ca458804ea8ef4c07d69ba7fe6" translate="yes" xml:space="preserve">
          <source>Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools. For example:</source>
          <target state="translated">定义模块编译的选项。它用于配置Elixir和Erlang编译器,就像外部工具添加的任何其他编译通道一样。例如</target>
        </trans-unit>
        <trans-unit id="51d68b5790fad1de6d84cef24485698c5aa44718" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a supervisor which will be started with the given arguments.</source>
          <target state="translated">将给定的 &lt;code&gt;module&lt;/code&gt; 定义为管理者，它将以给定的参数开始。</target>
        </trans-unit>
        <trans-unit id="a74b181531a071dccf103975ef9b5f457594135a" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a worker which will be started with the given arguments.</source>
          <target state="translated">将给定的 &lt;code&gt;module&lt;/code&gt; 定义为将使用给定参数启动的工作程序。</target>
        </trans-unit>
        <trans-unit id="5ba739f06f65411df500be4fe361a087cd34108a" translate="yes" xml:space="preserve">
          <source>Defines the options used by the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7e7a56a0498c33eb4666ce267e88fdd0443785" translate="yes" xml:space="preserve">
          <source>Defines the options used by the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">定义&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议使用的选项。</target>
        </trans-unit>
        <trans-unit id="706e656786be6150857ba9d00e3f4736e1b09e1e" translate="yes" xml:space="preserve">
          <source>Defines the release structure and convenience for assembling releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f752321778df74391c3378581723efb4dca5e78b" translate="yes" xml:space="preserve">
          <source>Defines warnings to request or suppress when using a version of &lt;code&gt;:dialyzer&lt;/code&gt; that supports module attributes.</source>
          <target state="translated">定义警告 &lt;code&gt;:dialyzer&lt;/code&gt; 使用支持模块属性的：dialyzer版本时，请求或禁止显示警告。</target>
        </trans-unit>
        <trans-unit id="99cdfc3cbea74f1f4372e3c3f255ee42a2f77809" translate="yes" xml:space="preserve">
          <source>Defining a protocol automatically defines a type named &lt;code&gt;t&lt;/code&gt;, which can be used as follows:</source>
          <target state="translated">定义协议会自动定义一个名为 &lt;code&gt;t&lt;/code&gt; 的类型，可以如下使用：</target>
        </trans-unit>
        <trans-unit id="eed610b2a524f1fea8a5a11a6b90ab2b660a40c7" translate="yes" xml:space="preserve">
          <source>Defining a specification</source>
          <target state="translated">定义规格</target>
        </trans-unit>
        <trans-unit id="375bfa92ccfe2bd509e0a5a5c9ecb19ed5761bbc" translate="yes" xml:space="preserve">
          <source>Defining behaviours</source>
          <target state="translated">界定行为</target>
        </trans-unit>
        <trans-unit id="1ea27e7345dd55520e1c3fd955a1961190ab35d0" translate="yes" xml:space="preserve">
          <source>Defining custom guard expressions</source>
          <target state="translated">定义自定义保护表达式</target>
        </trans-unit>
        <trans-unit id="67ee31ce55d3432708e003e7896d5c65897de368" translate="yes" xml:space="preserve">
          <source>Defining custom operators</source>
          <target state="translated">定义自定义运算符</target>
        </trans-unit>
        <trans-unit id="88f1538130a6f0b0a36142a4e1e014b6b0b27ac0" translate="yes" xml:space="preserve">
          <source>Defining custom types</source>
          <target state="translated">定义自定义类型</target>
        </trans-unit>
        <trans-unit id="fbb6738813740f5989865f0caccc2aedd14ecd4c" translate="yes" xml:space="preserve">
          <source>Defining custom types can help communicate the intention of your code and increase its readability. Custom types can be defined within modules via the &lt;code&gt;@type&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da279c1a631ba36a0429ee2b6ef866ee7c040663" translate="yes" xml:space="preserve">
          <source>Defining extracted records with anonymous functions in the values</source>
          <target state="translated">在值中用匿名函数定义提取的记录。</target>
        </trans-unit>
        <trans-unit id="d271da3ed06fd6bd866bb6e79184abd537c3512e" translate="yes" xml:space="preserve">
          <source>Defining function specs this way works, but it quickly becomes annoying since we&amp;rsquo;re repeating the type &lt;code&gt;{number, String.t}&lt;/code&gt; over and over. We can use the &lt;code&gt;@type&lt;/code&gt; directive in order to declare our own custom type.</source>
          <target state="translated">以这种方式定义函数规范是可行的，但是由于我们一遍又一遍地重复类型 &lt;code&gt;{number, String.t}&lt;/code&gt; ，它很快变得令人讨厌。我们可以使用 &lt;code&gt;@type&lt;/code&gt; 指令来声明我们自己的自定义类型。</target>
        </trans-unit>
        <trans-unit id="0b772a8609651705eb8dde2b64b91c2000ee893a" translate="yes" xml:space="preserve">
          <source>Defining function specs this way works, but we end up repeating the type &lt;code&gt;{number, String.t}&lt;/code&gt; over and over. We can use the &lt;code&gt;@type&lt;/code&gt; attribute to declare our own custom type and cut down on the repetition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fec1dfeb38c397bddde90cce354ec968be3e685" translate="yes" xml:space="preserve">
          <source>Defining structs</source>
          <target state="translated">定义结构</target>
        </trans-unit>
        <trans-unit id="ac3516b411710c30e4cd006454c7f1994a4da34a" translate="yes" xml:space="preserve">
          <source>Delegation only works with functions; delegating macros is not supported.</source>
          <target state="translated">委托只适用于函数,不支持委托宏。</target>
        </trans-unit>
        <trans-unit id="e726a77011c0fe0cd388991d477e194ae9fd7af2" translate="yes" xml:space="preserve">
          <source>Deletes &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;map_set&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;map_set&lt;/code&gt; 中删除 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7197d992ec2d7887544bc401d08055b1f065eeeb" translate="yes" xml:space="preserve">
          <source>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">从 Erlang VM 代码路径列表中删除一个路径。这是 Erlang VM 用于查找模块代码的目录列表。</target>
        </trans-unit>
        <trans-unit id="23800ac90aacec2911367a4560daa8ed5fec9cb1" translate="yes" xml:space="preserve">
          <source>Deletes an environment variable.</source>
          <target state="translated">删除环境变量。</target>
        </trans-unit>
        <trans-unit id="28cada09dd4174a63836f40b25ecf14ff7e1c534" translate="yes" xml:space="preserve">
          <source>Deletes generated application files.</source>
          <target state="translated">删除生成的应用程序文件。</target>
        </trans-unit>
        <trans-unit id="e6a3899638112ac7460e060d887ef65128ba4bb0" translate="yes" xml:space="preserve">
          <source>Deletes logging level for all modules to primary level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51596caccd970cb4a08314add121664dd042408" translate="yes" xml:space="preserve">
          <source>Deletes logging level for given module to primary level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666b6e6f3ed57f226d5de485fc7c0243f6bedb5a" translate="yes" xml:space="preserve">
          <source>Deletes registry metadata for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6511b55cc1b351a9cd395e58f52ffa508ee0de39" translate="yes" xml:space="preserve">
          <source>Deletes the &lt;code&gt;key&lt;/code&gt; from the given &lt;code&gt;app&lt;/code&gt; environment.</source>
          <target state="translated">从给定的 &lt;code&gt;app&lt;/code&gt; 环境中删除 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cda458e47c2adb906a94c0b5117cdc3d628bc0de" translate="yes" xml:space="preserve">
          <source>Deletes the child specification identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">删除 &lt;code&gt;child_id&lt;/code&gt; 标识的子规范。</target>
        </trans-unit>
        <trans-unit id="06519f5a98d8a9576fa45c95f0c76ae133cbfd51" translate="yes" xml:space="preserve">
          <source>Deletes the element at the given &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;tuple&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than or equal to the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">从 &lt;code&gt;tuple&lt;/code&gt; 中删除给定 &lt;code&gt;index&lt;/code&gt; 处的元素。如果 &lt;code&gt;index&lt;/code&gt; 为负或大于或等于 &lt;code&gt;tuple&lt;/code&gt; 的长度，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="fd3c9b264d49ac26b30c967deba1cf019e912877" translate="yes" xml:space="preserve">
          <source>Deletes the element at the given &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;tuple&lt;/code&gt;. Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than or equal to the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768479db33c4ea83d038f3e75c0b46d08cfff3a1" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">删除关键字列表中的条目的 &lt;code&gt;key&lt;/code&gt; 与 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30f8ea2c4a41f9ff990549664a0c3e8cc979a2f3" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除关键字列表中特定 &lt;code&gt;key&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="e356fc985f5b4c45501dcdd4bf05b2d169dc820a" translate="yes" xml:space="preserve">
          <source>Deletes the entry in &lt;code&gt;map&lt;/code&gt; for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除 &lt;code&gt;map&lt;/code&gt; 中特定 &lt;code&gt;key&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="84bf7f6c44bf7d1a25fea2eb0b485822b94e4057" translate="yes" xml:space="preserve">
          <source>Deletes the first entry in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">删除关键字列表中特定 &lt;code&gt;key&lt;/code&gt; 的第一个条目。</target>
        </trans-unit>
        <trans-unit id="f8205134472497de5f123b07ed4ca04623561776" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;element&lt;/code&gt; from the &lt;code&gt;list&lt;/code&gt;. Returns a new list without the element.</source>
          <target state="translated">从 &lt;code&gt;list&lt;/code&gt; 删除给定的 &lt;code&gt;element&lt;/code&gt; 。返回不包含元素的新列表。</target>
        </trans-unit>
        <trans-unit id="6931640e5585d21423be80c31e8281e15f83ebe2" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;key&lt;/code&gt; from the process dictionary.</source>
          <target state="translated">从流程字典中删除给定的 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c74c6ec914e8875fe5447015216dd83996fdd6" translate="yes" xml:space="preserve">
          <source>Deletes the given dependencies' files, including build artifacts and fetched sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241d39fd9168ac37f5f1398b699e96cae08161ab" translate="yes" xml:space="preserve">
          <source>Deletes the module attribute that matches the given key.</source>
          <target state="translated">删除符合给定键的模块属性。</target>
        </trans-unit>
        <trans-unit id="a7699468279a4b12f6e55a5ad1b8c725c2c3ca8c" translate="yes" xml:space="preserve">
          <source>Demonitors the monitor identified by the given &lt;code&gt;reference&lt;/code&gt;.</source>
          <target state="translated">通过给定的 &lt;code&gt;reference&lt;/code&gt; 标识监视程序的监视器。</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="ca0bdefd221fdbfd10bc0f3013fa9c019ef6808e" translate="yes" xml:space="preserve">
          <source>Dependencies and umbrella projects</source>
          <target state="translated">依赖关系和总体项目</target>
        </trans-unit>
        <trans-unit id="a491fbe030b9498ae78cd8f4bbd75506aa4b23b5" translate="yes" xml:space="preserve">
          <source>Dependencies are loaded again, now with an updated env environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeab4e8a30c470967346544f8d2eeabc88b3b63" translate="yes" xml:space="preserve">
          <source>Dependencies between applications in an umbrella project must still be explicitly defined and Mix makes it easy to do so. Open up &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; and change the &lt;code&gt;deps/0&lt;/code&gt; function to the following:</source>
          <target state="translated">仍然必须明确定义伞形项目中应用程序之间的依赖关系，Mix使其易于实现。打开 &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; 并将 &lt;code&gt;deps/0&lt;/code&gt; 函数更改为以下内容：</target>
        </trans-unit>
        <trans-unit id="20c4e61613e0bb2759ad45cedce4f0b014181be0" translate="yes" xml:space="preserve">
          <source>Dependencies must be specified in the &lt;code&gt;mix.exs&lt;/code&gt; file in one of the following formats:</source>
          <target state="translated">必须在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中以下列格式之一指定依赖项：</target>
        </trans-unit>
        <trans-unit id="fc73fac5fc75582095a6f843e32787bf5448edd3" translate="yes" xml:space="preserve">
          <source>Dependencies types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1313d46d93e4456c33c34bdf877a2b31296e6f6b" translate="yes" xml:space="preserve">
          <source>Dependencies within an umbrella project</source>
          <target state="translated">伞形项目内的依赖性</target>
        </trans-unit>
        <trans-unit id="2ae4f4df59c1f88916b85e951202eefbff4c7b68" translate="yes" xml:space="preserve">
          <source>Dependency definition options</source>
          <target state="translated">依赖定义选项</target>
        </trans-unit>
        <trans-unit id="8ef7583b0e7ed117ec9a27cd09f5e8d10632bf4f" translate="yes" xml:space="preserve">
          <source>Depending on the accumulator value, the result returned by &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; will change. Please check the &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt; type documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1bc59655cdca7840ee9bf9d55721f13ebb7a55" translate="yes" xml:space="preserve">
          <source>Depending on the accumulator value, the result returned by &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; will change. Please check the &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt; type documentation for more information.</source>
          <target state="translated">根据累加器的值，由&lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt;返回的结果将改变。请查看&lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt;类型文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8d458ed0bd596292bbe634a9b96cac2cab2e4961" translate="yes" xml:space="preserve">
          <source>Deployments</source>
          <target state="translated">Deployments</target>
        </trans-unit>
        <trans-unit id="4962f760a0cc6ed936dcedffadba8733dd81e124" translate="yes" xml:space="preserve">
          <source>Deploys a given module's BEAM code to a list of nodes.</source>
          <target state="translated">将指定模块的BEAM代码部署到节点列表中。</target>
        </trans-unit>
        <trans-unit id="f6ef72731d9f2999dced5cdda829d282f60229ed" translate="yes" xml:space="preserve">
          <source>Deprecated feature</source>
          <target state="translated">废弃的功能</target>
        </trans-unit>
        <trans-unit id="e5135ac9aa0f3adf0ead688638a7cada98f65645" translate="yes" xml:space="preserve">
          <source>Deprecated function to retrieve old documentation format.</source>
          <target state="translated">废弃的功能,用于检索旧的文档格式。</target>
        </trans-unit>
        <trans-unit id="355cf2e1caeb8e5de974f3e0ee6f449e9a16967c" translate="yes" xml:space="preserve">
          <source>Deprecated mechanism to retrieve the last exception stacktrace.</source>
          <target state="translated">废弃的检索最后一次异常堆栈跟踪的机制。</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="8189415262d9b40fadd78cc759dd14fdb9868384" translate="yes" xml:space="preserve">
          <source>Deps task</source>
          <target state="translated">部门任务</target>
        </trans-unit>
        <trans-unit id="1751cb6240f8427862c44d9fda1a1acebc588f2b" translate="yes" xml:space="preserve">
          <source>Derives the &lt;code&gt;protocol&lt;/code&gt; for &lt;code&gt;module&lt;/code&gt; with the given options.</source>
          <target state="translated">导出 &lt;code&gt;protocol&lt;/code&gt; 对 &lt;code&gt;module&lt;/code&gt; 用给定的选项。</target>
        </trans-unit>
        <trans-unit id="b1f507cfab066377ebfd776c06ce8c6ae1d1dfae" translate="yes" xml:space="preserve">
          <source>Deriving</source>
          <target state="translated">Deriving</target>
        </trans-unit>
        <trans-unit id="469b2320b22b8de425b1224d561debab3b7e4eec" translate="yes" xml:space="preserve">
          <source>Describes tests together.</source>
          <target state="translated">一起描述测试。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="373b67a9ef6e15b48984d2e64ecfb18feb928f40" translate="yes" xml:space="preserve">
          <source>Design principles</source>
          <target state="translated">设计原则</target>
        </trans-unit>
        <trans-unit id="9c5959e7ab4938c2e1595e724f3e5f686f3d536b" translate="yes" xml:space="preserve">
          <source>Destructures two lists, assigning each term in the right one to the matching term in the left one.</source>
          <target state="translated">重构两个列表,将右边列表中的每个术语分配给左边列表中的匹配术语。</target>
        </trans-unit>
        <trans-unit id="55519a961a5691717096efcabf1914eee5dab5a5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;integer&lt;/code&gt; is odd.</source>
          <target state="translated">确定 &lt;code&gt;integer&lt;/code&gt; 是否为奇数。</target>
        </trans-unit>
        <trans-unit id="026e5ca0dfda1ad25fabda732fd35af3e32e25b5" translate="yes" xml:space="preserve">
          <source>Determines if an &lt;code&gt;integer&lt;/code&gt; is even.</source>
          <target state="translated">确定 &lt;code&gt;integer&lt;/code&gt; 是否为偶数。</target>
        </trans-unit>
        <trans-unit id="ada7ef5eac5cda7b071d8c84d536d21adaaabe11" translate="yes" xml:space="preserve">
          <source>Determines if the &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">确定 &lt;code&gt;enumerable&lt;/code&gt; 是否为空。</target>
        </trans-unit>
        <trans-unit id="240590c512304822fc6f9051f63c5097957b51d1" translate="yes" xml:space="preserve">
          <source>Determines if the date given is valid according to the proleptic Gregorian calendar.</source>
          <target state="translated">判断所给的日期是否在公历上有效。</target>
        </trans-unit>
        <trans-unit id="76efef7f9a49f47616dc673a59a2c3e837af4cb0" translate="yes" xml:space="preserve">
          <source>Determines whether a given file path (supplied to ExUnit/Mix as arguments on the command line) includes a line number filter, and if so returns the appropriate ExUnit configuration options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecb9b726f00ef60a6a7e35454782b134568f041" translate="yes" xml:space="preserve">
          <source>Developers can also use &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; to build &lt;strong&gt;releases&lt;/strong&gt;. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b906ed370d76a314f78611272f97a7c5324fbfb8" translate="yes" xml:space="preserve">
          <source>Developers can also use tools like &lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery&lt;/a&gt; that build &lt;strong&gt;releases&lt;/strong&gt;. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</source>
          <target state="translated">开发人员还可以使用诸如&lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery之类的&lt;/a&gt;工具来构建&lt;strong&gt;发行版&lt;/strong&gt;。版本可以将您的所有源代码以及Erlang VM打包到一个目录中。发行版还使您可以明确控制每个应用程序的启动方式和启动顺序。它们还为启动和停止系统，调试，日志记录以及系统监视提供了更简化的机制。</target>
        </trans-unit>
        <trans-unit id="17f25608342d4ab77bb1907f884cfe439bc54de0" translate="yes" xml:space="preserve">
          <source>Developers may also implement their own backends, an option that is explored in more detail below.</source>
          <target state="translated">开发者也可以实现自己的后端,下面将详细探讨这个选项。</target>
        </trans-unit>
        <trans-unit id="0f26c5755a434f3e16da5992d7fb7b82ce5cc7eb" translate="yes" xml:space="preserve">
          <source>Developers may also use umbrella projects to break large business domains apart. The caution here is to make sure the domains don&amp;rsquo;t depend on each other (also known as cyclic dependencies). If you run into such situations, it means those applications are not as isolated from each other as you originally thought, and you have architectural and design issues to solve.</source>
          <target state="translated">开发人员还可以使用总括项目将大型业务领域分开。这里的警告是要确保域之间不相互依赖（也称为循环依赖）。如果遇到这种情况，则意味着这些应用程序之间的相互隔离程度不如您最初想象的那样，并且您需要解决体系结构和设计问题。</target>
        </trans-unit>
        <trans-unit id="f8e1b365eba8e74b8bfe96cbfcdf64fb1b529aa8" translate="yes" xml:space="preserve">
          <source>Developers may want to customize the VM flags and environment variables given when the release starts. This is typically done by customizing two files inside your release: &lt;code&gt;releases/RELEASE_VSN/vm.args&lt;/code&gt; and &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (or &lt;code&gt;env.bat&lt;/code&gt; on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4df092ce16103b5263190978f954da4abebc038" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">开发人员应避免直接创建&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;结构，而应依赖于此模块提供的功能以及第三方日历库中的功能。</target>
        </trans-unit>
        <trans-unit id="9399f0af7289ccae2bbfba26b54d6beaa45eceaa" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">开发者应避免直接创建Date结构,而应依赖该模块提供的函数以及第三方日历库中的函数。</target>
        </trans-unit>
        <trans-unit id="372765583e2c62003b134d7cd14c816d752b1af8" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">开发者应该避免直接创建NaiveDateTime结构,而应该依赖该模块提供的函数以及第三方日历库中的函数。</target>
        </trans-unit>
        <trans-unit id="055215a2dc231830ec70e2ea3ed245f009feefc1" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">开发者应该避免直接创建时间结构,而应该依赖该模块提供的函数以及第三方日历库中的函数。</target>
        </trans-unit>
        <trans-unit id="9189bcb16b1c4a850379e209c0a8399dce99e6b1" translate="yes" xml:space="preserve">
          <source>Developers typically interact with the application environment and its callback module. Therefore those will be the topics we will cover first before jumping into details about the application resource file and life-cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b414f7b11d4d2f5dc034b2a293c66c101f5ce2" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49670694b8769b5d39822cc3c17e46c76506631f" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f9f33bf587fbe7754189054b93906eb196c38a" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">开发人员通常在其init回调的末尾调用&lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt;以返回适当的监督标志。</target>
        </trans-unit>
        <trans-unit id="c23ae07b94722ec4976e1fcb3346ba8a18a11515" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">开发人员通常在其init回调的末尾调用&lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt;以返回适当的监督标志。</target>
        </trans-unit>
        <trans-unit id="c943b3eb860130726114a82a12d17559028bcef9" translate="yes" xml:space="preserve">
          <source>Developing in Elixir does not make your code free of race conditions. However, Elixir&amp;rsquo;s abstractions where nothing is shared by default make it easier to spot a race condition&amp;rsquo;s root cause.</source>
          <target state="translated">使用Elixir进行开发并不能使您的代码脱离竞争条件。但是，默认情况下不共享任何内容的Elixir抽象概念使发现竞争状况的根本原因变得更加容易。</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">Development</target>
        </trans-unit>
        <trans-unit id="6b689de83c32738e6559500bab1e32306f72a975" translate="yes" xml:space="preserve">
          <source>Diagnostic information such as a warning or compilation error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="28a9d7ddb98e082ecef8831bdb74b74701f20d77" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;defmodule&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;defmodule&lt;/code&gt; 的区别</target>
        </trans-unit>
        <trans-unit id="951f149c561762e46794ae9088e9246ba02fb48d" translate="yes" xml:space="preserve">
          <source>Differences to &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">差异&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20542733f8e0c7eb21a37d3a9649be5cfd67f9" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows. You may call &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; to normalize the path before invoking this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7664bc212e56811cb62a63d951c16c5ee311e137" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows. You may call &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; to normalize the path before invoking this function.</source>
          <target state="translated">目录分隔符必须始终写为 &lt;code&gt;/&lt;/code&gt; ，即使在Windows上也是如此。您可以在调用此函数之前调用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt;以标准化路径。</target>
        </trans-unit>
        <trans-unit id="07461fdd8bbd77721cfe447edf9e4bd20cbd0023" translate="yes" xml:space="preserve">
          <source>Directory structure</source>
          <target state="translated">目录结构</target>
        </trans-unit>
        <trans-unit id="5095c2a8d43020f623949798775e0dea6df3427e" translate="yes" xml:space="preserve">
          <source>Disables logging for the current process.</source>
          <target state="translated">禁用当前进程的日志记录。</target>
        </trans-unit>
        <trans-unit id="3243542aa799d7700902fa9d17f21c898a51bd23" translate="yes" xml:space="preserve">
          <source>Dispatching happens in the process that calls &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; either serially or concurrently in case of multiple partitions (via spawned tasks). The registered processes are not involved in dispatching unless involving them is done explicitly (for example, by sending them a message in the callback).</source>
          <target state="translated">如果有多个分区（通过生成的任务），则在串行或同时调用&lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt;的过程中发生调度。除非显式完成已注册的进程（例如，通过在回调中向它们发送消息），否则它们不会参与调度。</target>
        </trans-unit>
        <trans-unit id="129dd56090745e370bed845813615f5c08f21b2a" translate="yes" xml:space="preserve">
          <source>Distributed tasks</source>
          <target state="translated">分布式任务</target>
        </trans-unit>
        <trans-unit id="aef0124ef44afd7de1feb0a9b09b0c6ee2798fe2" translate="yes" xml:space="preserve">
          <source>Distributed tasks and tags</source>
          <target state="translated">分布式任务和标签</target>
        </trans-unit>
        <trans-unit id="b4c7a18ac5c24ec1029c892a8a7fb3fbcc59af1d" translate="yes" xml:space="preserve">
          <source>Distributed tasks are exactly the same as supervised tasks. The only difference is that we pass the node name when spawning the task on the supervisor. Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; from the &lt;code&gt;:kv&lt;/code&gt; application. Let&amp;rsquo;s add a task supervisor as the last child of the tree:</source>
          <target state="translated">分布式任务与受监管任务完全相同。唯一的区别是，在主管上生成任务时，我们传递节点名称。从 &lt;code&gt;:kv&lt;/code&gt; 应用程序打开 &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 。让我们添加一个任务管理器作为树的最后一个子代：</target>
        </trans-unit>
        <trans-unit id="98348afa0d882c80ed7d05917265b30ff93c136a" translate="yes" xml:space="preserve">
          <source>Divides a string into parts based on a pattern.</source>
          <target state="translated">根据模式将一个字符串分成若干部分。</target>
        </trans-unit>
        <trans-unit id="4f19d3c5ba97dc473a0dd975ca453b2aa1eeca76" translate="yes" xml:space="preserve">
          <source>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</source>
          <target state="translated">在每个Unicode空白处将字符串分割成子串,忽略前面和后面的空白。空格组被视为一个单一的出现。分割不会发生在非断裂的空白处。</target>
        </trans-unit>
        <trans-unit id="d81ee0347de2d9ae77f2a442736c72a2f69253b7" translate="yes" xml:space="preserve">
          <source>Do not call this function at the tail of another function. Due to tail call optimization, a stacktrace entry would not be added and the stacktrace would be incorrectly trimmed. Therefore make sure at least one expression (or an atom such as &lt;code&gt;:ok&lt;/code&gt;) follows the &lt;a href=&quot;#warn/1&quot;&gt;&lt;code&gt;IO.warn/1&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4d17c0fddf7977be47a1ef9b14e7b1d0cef265" translate="yes" xml:space="preserve">
          <source>Do not rely on the particular format returned by the &lt;code&gt;format*&lt;/code&gt; functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.</source>
          <target state="translated">不要依赖此模块中 &lt;code&gt;format*&lt;/code&gt; 函数返回的特定格式。为了将来更好地适应Elixir的工具链，可能会对其进行更改。换句话说，通过使用此模块中的函数，可以确保您将格式化异常，就像正在使用的当前Elixir版本一样。</target>
        </trans-unit>
        <trans-unit id="7ed32458ab08d1762c48c121c3b7d606e8351db4" translate="yes" xml:space="preserve">
          <source>Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt; and the compiler to provide features like hygiene, better error messages, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7bc96b42e95f7c693c3ce91032568e412218c3" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt; to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4fd1f0a9baed4ec08ef8c1f9bda3731a7c9d57" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E=/2&quot;&gt;&lt;code&gt;&amp;gt;=/2&lt;/code&gt;&lt;/a&gt; and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be89a1272cff39c64911be3f9a33057d2a2263c" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt; to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</source>
          <target state="translated">不要使用&lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt;查找运行时配置。仅用于配置项目的各个方面（例如编译目录），而不能用于配置应用程序运行时。</target>
        </trans-unit>
        <trans-unit id="a8d3dcf5e3a5a8a9d6963913c532d9b07e33dbf9" translate="yes" xml:space="preserve">
          <source>Do not use special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because they might not work as expected.</source>
          <target state="translated">不要使用特殊的匹配变量 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 和 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; ，因为它们可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="9078c7f338a72de9ec9a277913417c733a31c6ad" translate="yes" xml:space="preserve">
          <source>Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; instead.</source>
          <target state="translated">不要使用此函数生成数字序列。如果不需要阻止调用者进程，请改用 &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c967365f49cb78e9480b70b6bc54898d3348c0d" translate="yes" xml:space="preserve">
          <source>Doctest will looking for a line starting with &lt;code&gt;** (&lt;/code&gt; and it will parse it accordingly to extract the exception name and message. The exception parser will consider all following lines part of the exception message until there is an empty line or there is a new expression prefixed with &lt;code&gt;iex&amp;gt;&lt;/code&gt;. Therefore, it is possible to match on multiline messages as long as there are no empty lines on the message itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="54cc8e778254d8263003ab87576a482705e9e652" translate="yes" xml:space="preserve">
          <source>Doctests allow us to generate tests from code examples found in &lt;code&gt;@moduledoc&lt;/code&gt; and &lt;code&gt;@doc&lt;/code&gt; attributes. To do this, invoke the &lt;a href=&quot;#doctest/1&quot;&gt;&lt;code&gt;doctest/1&lt;/code&gt;&lt;/a&gt; macro from within your test case and ensure your code examples are written according to the syntax and guidelines below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6f84b7484c0cf7709bebbb23583c23abf1b083" translate="yes" xml:space="preserve">
          <source>Doctests are specified by an indentation of four spaces followed by the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt in a documentation string. If a command spans multiple lines, you can use &lt;code&gt;...&amp;gt;&lt;/code&gt;, as in IEx. The expected result should start at the next line after &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and is terminated either by a newline or a new &lt;code&gt;iex&amp;gt;&lt;/code&gt; prefix.</source>
          <target state="translated">Doctest由缩进的四个空格指定，后跟文档字符串中的 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 提示。如果命令跨越多行，则可以像IEx一样使用 &lt;code&gt;...&amp;gt;&lt;/code&gt; 。预期结果应从 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 或 &lt;code&gt;...&amp;gt;&lt;/code&gt; 行之后的下一行开始，并以换行符或新的 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 前缀终止。</target>
        </trans-unit>
        <trans-unit id="acfc0021db2710ad6e5c5976444819b508e6a8e7" translate="yes" xml:space="preserve">
          <source>Doctests, patterns and with</source>
          <target state="translated">实验、模式和与</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="dbeb3b73b289a45968e86a1c4e28757eddbb7b21" translate="yes" xml:space="preserve">
          <source>Documentation != Code comments</source>
          <target state="translated">文档 !=代码注释</target>
        </trans-unit>
        <trans-unit id="dc66ec30a9e7992a7f99224cd60ef6a9e6f7c515" translate="yes" xml:space="preserve">
          <source>Documentation in Elixir is usually attached to module attributes. Let's see an example:</source>
          <target state="translated">Elixir中的文档通常附加在模块属性中。我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="d46677a0ad1e404b917f0ea8b3b31b80c34ffa5f" translate="yes" xml:space="preserve">
          <source>Documentation metadata</source>
          <target state="translated">文件元数据</target>
        </trans-unit>
        <trans-unit id="fcb85c951e6d656fcd603d110a64fcd8866200d9" translate="yes" xml:space="preserve">
          <source>Documents in a group are attempted to be rendered together to the best of the renderer ability.</source>
          <target state="translated">一组文档中的文档会在渲染者的能力范围内尝试一起渲染。</target>
        </trans-unit>
        <trans-unit id="e86919b582b64b77ec53c038e64ee362a74d9398" translate="yes" xml:space="preserve">
          <source>Does not include fractional seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd6d91ba0fc6656f3596671325c2a8e0bccb23f" translate="yes" xml:space="preserve">
          <source>Does not load any of the implementations.</source>
          <target state="translated">不加载任何的实现。</target>
        </trans-unit>
        <trans-unit id="e1c5568ff1b2696956a80de3fbdad95c454b1c9a" translate="yes" xml:space="preserve">
          <source>Does not load any of the protocols.</source>
          <target state="translated">不加载任何协议。</target>
        </trans-unit>
        <trans-unit id="c263be485f93e4de275853028d24c5388efd78f6" translate="yes" xml:space="preserve">
          <source>Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014, the result is 0.010000000000000002, and because this is not the closest representable number to 0.01, you'll get the wrong result for this operation</source>
          <target state="translated">做0.1*0.1应该返回0.01,但由于0.1实际上是0.1000000014,所以结果是0.010000000000000002,由于这不是最接近0.01的可表示数,所以你会得到这个操作的错误结果。</target>
        </trans-unit>
        <trans-unit id="576aa93d193455e3276b07f4cd2af71d8167c617" translate="yes" xml:space="preserve">
          <source>Doing it in reverse order will raise a syntax error:</source>
          <target state="translated">如果按相反的顺序进行,会引起语法错误。</target>
        </trans-unit>
        <trans-unit id="a56ad56b6280b6eca6747cdcbe707267d3443caf" translate="yes" xml:space="preserve">
          <source>Domain-specific languages</source>
          <target state="translated">特定领域的语言</target>
        </trans-unit>
        <trans-unit id="e6ab4e40cdc60406c301246d5709b2813b1c0221" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t drink the kool aid</source>
          <target state="translated">不要喝库尔援助</target>
        </trans-unit>
        <trans-unit id="bfd4ab20e5eed869032f79c7d0b2472213257269" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that you can also check the &lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;source code of Elixir itself&lt;/a&gt;, which is mostly written in Elixir (mainly the &lt;code&gt;lib&lt;/code&gt; directory), or &lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;explore Elixir&amp;rsquo;s documentation&lt;/a&gt;.</source>
          <target state="translated">别忘了，您还可以检查&lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;Elixir本身&lt;/a&gt;的源代码（主要用Elixir（主要是 &lt;code&gt;lib&lt;/code&gt; 目录）编写），或者&lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;浏览Elixir的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5db8bef0a01561d7d57f3c78471d1ef61330dd5e" translate="yes" xml:space="preserve">
          <source>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3dff4b81533f75ceec6a97ebb6191aa309061e" translate="yes" xml:space="preserve">
          <source>Drops elements at the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">在 &lt;code&gt;enumerable&lt;/code&gt; 的开头删除元素，而 &lt;code&gt;fun&lt;/code&gt; 返回真实值。</target>
        </trans-unit>
        <trans-unit id="594f287d9f0bd3fb9ea891584418c737436dd38e" translate="yes" xml:space="preserve">
          <source>Drops the &lt;code&gt;amount&lt;/code&gt; of elements from the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;enumerable&lt;/code&gt; 删除元素的 &lt;code&gt;amount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab32b2e5c71cd1c17d36b26a0d25edc63a27b074" translate="yes" xml:space="preserve">
          <source>Drops the given &lt;code&gt;keys&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;map&lt;/code&gt; 中删除给定的 &lt;code&gt;keys&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdb8b8343fe7d1adbf36b056e528d2571ea6a12c" translate="yes" xml:space="preserve">
          <source>Drops the given keys from the keyword list.</source>
          <target state="translated">从关键字列表中删除给定的键。</target>
        </trans-unit>
        <trans-unit id="69c0475e80c404bbdc2d49a7a643fb10c6ace760" translate="yes" xml:space="preserve">
          <source>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:</source>
          <target state="translated">由于不可变性,Elixir中的循环(与任何函数式编程语言一样)的写法与命令式语言不同。例如,在C语言这样的命令式语言中,人们会写:</target>
        </trans-unit>
        <trans-unit id="5cf07ff6fe7f2d796d09183c5eda29bcd66f1127" translate="yes" xml:space="preserve">
          <source>Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):</source>
          <target state="translated">由于它们基于cons单元格的表示方式,将一个元素预存入列表总是很快的(恒定时间),而随着列表大小的增加(线性时间),追加变得更慢。</target>
        </trans-unit>
        <trans-unit id="4f1ef09b3bb7845a809a8a0e2e38529155ed603e" translate="yes" xml:space="preserve">
          <source>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, intermediate lists are created, while &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; creates a recipe of computations that are executed at a later moment. Let's see another example:</source>
          <target state="translated">由于它们的惰性，在处理大型（甚至无限）集合时，流非常有用。当用&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;链接许多操作时，会创建中间列表，而&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;会创建稍后执行的计算配方。让我们看另一个例子：</target>
        </trans-unit>
        <trans-unit id="bb320794ee00a758f7983100b77521dd3b189d58" translate="yes" xml:space="preserve">
          <source>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, intermediate lists are created, while &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; creates a recipe of computations that are executed at a later moment. Let's see another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4a3188c65902a880f35052cd6e431c13b80b5a" translate="yes" xml:space="preserve">
          <source>Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the &lt;code&gt;__foo__&lt;/code&gt; format. For example, every module in Elixir has an &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9895fb241f7b45a9dc3e35cea835d242910bcea5" translate="yes" xml:space="preserve">
          <source>Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the &lt;code&gt;__foo__&lt;/code&gt; format. For example, every module in Elixir has an &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">由于此属性，Elixir依靠以下划线开头的函数将编译时元数据附加到模块。此类函数通常采用 &lt;code&gt;__foo__&lt;/code&gt; 格式。例如，Elixir中的每个模块都有一个&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="e98f40360712c64e6a04a39d7c38770f1fe9b496" translate="yes" xml:space="preserve">
          <source>Duplicate keys and ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d17d072820769c205a9be99134b8181cc1f8d63" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">重复的条目将被删除，以最新的为准。与 &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt; ， &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; 保证键是唯一的。</target>
        </trans-unit>
        <trans-unit id="076f63ae0f418e3862988b172f7c4cc5852450a8" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">重复的条目将被删除，以最新的为准。与 &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt; ， &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; 确保键是唯一的。</target>
        </trans-unit>
        <trans-unit id="64aa4fe0da505292ed7a57df0b239e0d4183ccec" translate="yes" xml:space="preserve">
          <source>Duplicated keys appear duplicated in the final list of keys.</source>
          <target state="translated">重复的键在最后的键列表中出现重复。</target>
        </trans-unit>
        <trans-unit id="efdd2fd6681b594f9b79a82e9b5aa48b4fbf5e9b" translate="yes" xml:space="preserve">
          <source>Duplicated keys are not removed.</source>
          <target state="translated">重复的钥匙不会被删除。</target>
        </trans-unit>
        <trans-unit id="ac53e68a8e0e729bf98aeec7ce7b6340de177d35" translate="yes" xml:space="preserve">
          <source>Duplicated keys are preserved in the new keyword list.</source>
          <target state="translated">重复的键在新的关键字列表中被保留。</target>
        </trans-unit>
        <trans-unit id="b3b6f1eeffe99ed90517ec6eae526962d142636d" translate="yes" xml:space="preserve">
          <source>Duplicated keys are removed; the latest one prevails.</source>
          <target state="translated">重复的钥匙被删除,以最新的钥匙为准。</target>
        </trans-unit>
        <trans-unit id="9ba8d07a9bc46aeb1c779fab12a8b4dd715ff170" translate="yes" xml:space="preserve">
          <source>Duplicates the given element &lt;code&gt;n&lt;/code&gt; times in a list.</source>
          <target state="translated">将给定元素在列表中复制 &lt;code&gt;n&lt;/code&gt; 次。</target>
        </trans-unit>
        <trans-unit id="612d35050e691a1a2b9f22fe6b8f2fde9cb8f9d1" translate="yes" xml:space="preserve">
          <source>Dynamic dispatch</source>
          <target state="translated">动态调度</target>
        </trans-unit>
        <trans-unit id="edd7dafc098b4b13db6ad466bd4e821198c0337f" translate="yes" xml:space="preserve">
          <source>Dynamic names</source>
          <target state="translated">动态名称</target>
        </trans-unit>
        <trans-unit id="46d2782a295d697a8b9e27c2d91c25f66bfd854d" translate="yes" xml:space="preserve">
          <source>Dynamic supervisors</source>
          <target state="translated">动态主管</target>
        </trans-unit>
        <trans-unit id="3aa9130077fcc44c7eb24ab3a909359998b572f0" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor</source>
          <target state="translated">DynamicSupervisor</target>
        </trans-unit>
        <trans-unit id="4981d257018e7d749e02934b79c0b6bdb94f8f95" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">DynamicSupervisor &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7ba279830cac8f3b7ac440b34f16c258d525250e" translate="yes" xml:space="preserve">
          <source>Dynamically adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">动态将子级规范添加到 &lt;code&gt;supervisor&lt;/code&gt; 并启动该子级。</target>
        </trans-unit>
        <trans-unit id="887cf55c60fc1c9af6689bd5e2a2c3b3766133c3" translate="yes" xml:space="preserve">
          <source>Dynamically supervised tasks</source>
          <target state="translated">动态监管的任务</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="5b16ec2483e166fe049f665c022763eabe66f30f" translate="yes" xml:space="preserve">
          <source>EEx</source>
          <target state="translated">EEx</target>
        </trans-unit>
        <trans-unit id="af3993684170f3f24c787f9d7ffb881775da9c68" translate="yes" xml:space="preserve">
          <source>EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file.</source>
          <target state="translated">EEx具有引擎的概念,它允许你修改或转换从给定字符串或文件中提取的代码。</target>
        </trans-unit>
        <trans-unit id="818fc332cfd248836c5442317677dfe04bdbbd73" translate="yes" xml:space="preserve">
          <source>EEx stands for Embedded Elixir. It allows you to embed Elixir code inside a string in a robust way.</source>
          <target state="translated">EEx是Embedded Elixir的缩写。它允许你以一种强大的方式将Elixir代码嵌入到字符串中。</target>
        </trans-unit>
        <trans-unit id="22a24f67ecb347cc9015ff6237454fdbf0669653" translate="yes" xml:space="preserve">
          <source>EEx.Engine &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">EEx.Engine &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eebf2acaee05e7c09c816457012d68bbfc96c6f3" translate="yes" xml:space="preserve">
          <source>EEx.SmartEngine</source>
          <target state="translated">EEx.SmartEngine</target>
        </trans-unit>
        <trans-unit id="674e9c18d21c34b87c83982cf9afa4d95159a4be" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError</source>
          <target state="translated">EEx.SyntaxError</target>
        </trans-unit>
        <trans-unit id="49bba56082c8e3c9fff304ab7864ed3cb3a25fb5" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">EEx.SyntaxError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="98d18c239604c617df6f8788536838fd25d8c03d" translate="yes" xml:space="preserve">
          <source>EEx: &lt;code&gt;&amp;lt;%=&lt;/code&gt; in middle and end expressions</source>
          <target state="translated">EEx：中间表达式和结尾表达式中的 &lt;code&gt;&amp;lt;%=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b4d835a11a6493d1e10defe1536a05fda39d532" translate="yes" xml:space="preserve">
          <source>ELixir tracks three types of dependencies between modules: compile, exports, and runtime. If a module has a compile time dependency on another module, the caller module has to be recompiled whenever the callee changes. Compile-time dependencies are typically added when using macros or when invoking functions in the module body (outside of functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eceb14d6ed554f3e39c3487db659c8d63e28acd" translate="yes" xml:space="preserve">
          <source>ETS</source>
          <target state="translated">ETS</target>
        </trans-unit>
        <trans-unit id="1500176ef8cc8bfbbaf08eb4c1316bcf890f3395" translate="yes" xml:space="preserve">
          <source>ETS (Erlang Term Storage)</source>
          <target state="translated">ETS (Erlang Term Storage)</target>
        </trans-unit>
        <trans-unit id="4f5a2cc3fa91eb59c67ada064593bcea69c5e3b4" translate="yes" xml:space="preserve">
          <source>ETS allows us to store any Elixir term in an in-memory table. Working with ETS tables is done via &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:ets&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">ETS允许我们将任何Elixir术语存储在内存表中。使用ETS表通过&lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang的 &lt;code&gt;:ets&lt;/code&gt; 模块完成&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8e8dd8378100a7f6cf535d73f581bb5835a296a0" translate="yes" xml:space="preserve">
          <source>ETS as a cache</source>
          <target state="translated">ETS作为一个缓存</target>
        </trans-unit>
        <trans-unit id="0c6b672feadc74b2fa303a786fd5682cec52505f" translate="yes" xml:space="preserve">
          <source>ETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.</source>
          <target state="translated">ETS可以让你创建一个包含元组的表。默认情况下,ETS表是受保护的,这意味着只有所有者进程可以向表写入,但任何其他进程都可以读取。ETS有一些功能,可以让表作为一个简单的数据库、一个键值存储或作为一个缓存机制使用。</target>
        </trans-unit>
        <trans-unit id="52adb6284390fce5741221672f061e71df403d05" translate="yes" xml:space="preserve">
          <source>ETS tables can also be named, allowing us to access them by a given name:</source>
          <target state="translated">ETS表也可以被命名,允许我们通过一个给定的名称来访问它们。</target>
        </trans-unit>
        <trans-unit id="362cea4d522d64f424e9ad3e438c8000b26fb5c9" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;enumerable&lt;/code&gt; element is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be linked to the current process, similarly to &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个 &lt;code&gt;enumerable&lt;/code&gt; 元素都作为参数传递给给定函数 &lt;code&gt;fun&lt;/code&gt; ，并由其自己的任务处理。任务将链接到当前进程，类似于&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c70223b508f5fb20c656733438516d9c4a38e207" translate="yes" xml:space="preserve">
          <source>Each application has an environment that stores the application&amp;rsquo;s specific configuration by key. For example, we could store the routing table in the &lt;code&gt;:kv&lt;/code&gt; application environment, giving it a default value and allowing other applications to change the table as needed.</source>
          <target state="translated">每个应用程序都有一个环境，该环境可以通过密钥存储应用程序的特定配置。例如，我们可以将路由表存储在 &lt;code&gt;:kv&lt;/code&gt; 应用程序环境中，为其指定默认值，并允许其他应用程序根据需要更改该表。</target>
        </trans-unit>
        <trans-unit id="3405035bc16c9169ba3e4eb3a0b15b99fd33b0e0" translate="yes" xml:space="preserve">
          <source>Each application has its own environment. The environment is a keyword list that maps atoms to terms. Note that this environment is unrelated to the operating system environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b77596010e1d94e168b64218473fa0c4476548" translate="yes" xml:space="preserve">
          <source>Each application in our system can be started and stopped. The rules for starting and stopping an application are also defined in the &lt;code&gt;.app&lt;/code&gt; file. When we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, Mix compiles our application and then starts it.</source>
          <target state="translated">我们系统中的每个应用程序都可以启动和停止。 &lt;code&gt;.app&lt;/code&gt; 文件中还定义了启动和停止应用程序的规则。当我们调用 &lt;code&gt;iex -S mix&lt;/code&gt; 时，Mix会编译我们的应用程序，然后启动它。</target>
        </trans-unit>
        <trans-unit id="6ee7cee4e35c13e97e0b113c7ad93de2b2e9f9ff" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/2&quot;&gt;&lt;code&gt;async/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 每个元素都作为参数传递给给定函数 &lt;code&gt;fun&lt;/code&gt; ，并由其自己的任务处理。任务将在给定的 &lt;code&gt;supervisor&lt;/code&gt; 下生成，并链接到当前进程，类似于&lt;a href=&quot;#async/2&quot;&gt; &lt;code&gt;async/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bff2b054449ef93f88ae378fceaa7c3773b512d" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 每个元素都作为参数传递给给定函数 &lt;code&gt;fun&lt;/code&gt; ，并由其自己的任务处理。任务将在给定的 &lt;code&gt;supervisor&lt;/code&gt; 下生成，并且不会链接到当前进程，类似于&lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8ff31374c6e0e1792073cfd7bf59921a2ee8196" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 每个元素都将放在给定的 &lt;code&gt;args&lt;/code&gt; 之前，并由其自己的任务处理。任务将在给定的 &lt;code&gt;supervisor&lt;/code&gt; 下生成，并且不会链接到当前进程，类似于&lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e074b39ec3a1ed372a909c0a3201829b19421e8" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be linked to an intermediate process that is then linked to the current process. This means a failure in a task terminates the current process and a failure in the current process terminates all tasks.</source>
          <target state="translated">每个 &lt;code&gt;enumerable&lt;/code&gt; 元素都将放在给定的 &lt;code&gt;args&lt;/code&gt; 之前，并由其自己的任务处理。任务将链接到中间流程，然后再链接到当前流程。这意味着任务中的失败会终止当前进程，而当前过程中的失败会终止所有任务。</target>
        </trans-unit>
        <trans-unit id="ea81b39bec07b5eca51e7cb8e73b08cc88b185e5" translate="yes" xml:space="preserve">
          <source>Each element will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/4&quot;&gt;&lt;code&gt;async/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个元素都将放在给定的 &lt;code&gt;args&lt;/code&gt; 之前，并由其自己的任务处理。任务将在给定的 &lt;code&gt;supervisor&lt;/code&gt; 下生成并链接到当前进程，类似于&lt;a href=&quot;#async/4&quot;&gt; &lt;code&gt;async/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6a3bdb3211b725603f1e420065f9f512a455e5f" translate="yes" xml:space="preserve">
          <source>Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77459e85ee4402d66fd92ef0b7844cafe8faeccd" translate="yes" xml:space="preserve">
          <source>Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">注册表中的每个条目都与已注册密钥的进程相关联。如果该进程崩溃，则与该进程关联的密钥将自动删除。注册表中的所有键比较都是使用match操作（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）完成的。</target>
        </trans-unit>
        <trans-unit id="f51dcc2b38618bcc3fe87f6cb31bfc9d58a91577" translate="yes" xml:space="preserve">
          <source>Each item in the list is a map with the following keys:</source>
          <target state="translated">列表中的每一个项目都是一张地图,其按键如下。</target>
        </trans-unit>
        <trans-unit id="532f0099dc0a59c8142722d964bd46289ef70cfc" translate="yes" xml:space="preserve">
          <source>Each key-value pair in the map is converted to a two-element tuple &lt;code&gt;{key, value}&lt;/code&gt; in the resulting list.</source>
          <target state="translated">映射中的每个键值对都将在结果列表中转换为包含两个元素的元组 &lt;code&gt;{key, value}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4934170f741619738531430df9405d17c3b39b24" translate="yes" xml:space="preserve">
          <source>Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:</source>
          <target state="translated">每个模块可以用一个或多个属性来装饰。目前Elixir定义的属性如下:</target>
        </trans-unit>
        <trans-unit id="9ac8e172618067a3e6bc12be54b49bfe15535ac3" translate="yes" xml:space="preserve">
          <source>Each module gets an &lt;code&gt;__info__/1&lt;/code&gt; function when it's compiled. The function takes one of the following items:</source>
          <target state="translated">每个模块在编译时都会获得 &lt;code&gt;__info__/1&lt;/code&gt; 函数。该函数采用以下项目之一：</target>
        </trans-unit>
        <trans-unit id="e4ebc93808a7013b1682e04607e3d5c0727d33dc" translate="yes" xml:space="preserve">
          <source>Each number given to a binary is meant to represent a byte and therefore must go up to 255. Binaries allow modifiers to be given to store numbers bigger than 255 or to convert a code point to its UTF-8 representation:</source>
          <target state="translated">给予二进制的每一个数字都是为了代表一个字节,因此必须达到255。二进制允许给出修饰符来存储大于255的数字,或将码点转换为UTF-8表示。</target>
        </trans-unit>
        <trans-unit id="86d9329e1ed2a43e214726a374900569c7bc6fae" translate="yes" xml:space="preserve">
          <source>Each process started with the application must be listed as a child under the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372725c1f82abeb98e09b054fcea454db1d9af25" translate="yes" xml:space="preserve">
          <source>Each process started with the application must be listed as a child under the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">从应用程序启动的每个过程都必须在上面的&amp;ldquo; &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;下列为子项。我们称它们为&amp;ldquo;静态过程&amp;rdquo;，因为它们是预先已知的。要处理动态流程，例如在请求和其他用户输入期间启动的动态流程，请查看&lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="b076bdb70baef474140c948c212f1de89050946f" translate="yes" xml:space="preserve">
          <source>Each registered SCM will be asked if they consume this dependency, receiving &lt;code&gt;[github: &quot;foo/bar&quot;]&lt;/code&gt; as argument. Since this option makes sense for the Git SCM, it will return an update list of options while other SCMs would simply return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c52364e96da340fb31c3249f2e8693baeb5686f" translate="yes" xml:space="preserve">
          <source>Each task has its own options and sometimes specific configuration to be defined in the &lt;code&gt;project/0&lt;/code&gt; function. You can use &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; to list all available tasks and &lt;code&gt;mix help NAME&lt;/code&gt; to show help for a particular task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a597396bbd78d869061e9cc988eca475a9257e" translate="yes" xml:space="preserve">
          <source>Each task has its own options and sometimes specific configuration to be defined in the &lt;code&gt;project/0&lt;/code&gt; function. You can use &lt;a href=&quot;mix.tasks.help&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; to list all available tasks and &lt;code&gt;mix help NAME&lt;/code&gt; to show help for a particular task.</source>
          <target state="translated">每个任务都有其自己的选项，有时还需要在 &lt;code&gt;project/0&lt;/code&gt; 函数中定义特定的配置。您可以使用&lt;a href=&quot;mix.tasks.help&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt;列出所有可用任务，并使用 &lt;code&gt;mix help NAME&lt;/code&gt; 显示特定任务的帮助。</target>
        </trans-unit>
        <trans-unit id="bcac1b6f9d120c9722086c7e508489b0226da684" translate="yes" xml:space="preserve">
          <source>Each variable is identified by a tuple of two elements, where the first element is the variable name as an atom and the second element is its context, which may be an atom or an integer.</source>
          <target state="translated">每个变量由两个元素组成的元组来标识,其中第一个元素是作为原子的变量名,第二个元素是它的上下文,可以是一个原子或一个整数。</target>
        </trans-unit>
        <trans-unit id="68310c7d97bd5e9d47967e9e9edcb285e94d70ff" translate="yes" xml:space="preserve">
          <source>Eager to learn more? Keep reading!</source>
          <target state="translated">急于了解更多?请继续阅读!</target>
        </trans-unit>
        <trans-unit id="773015863b8b24712e29c53fe98994b9728f6381" translate="yes" xml:space="preserve">
          <source>Eager vs Lazy</source>
          <target state="translated">渴望与懒惰</target>
        </trans-unit>
        <trans-unit id="28ac06af2cb7839cf14f9821c41dfad421032a0a" translate="yes" xml:space="preserve">
          <source>Echo server</source>
          <target state="translated">回音服务器</target>
        </trans-unit>
        <trans-unit id="eeccb169551120a3e6a633e63e844185e028c154" translate="yes" xml:space="preserve">
          <source>Edit the file at &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, filling in the blanks for the client API:</source>
          <target state="translated">在 &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 上编辑文件，填写客户端API的空白：</target>
        </trans-unit>
        <trans-unit id="ddd5726bf13c26ce5252aef42e6ba8f0c851bd53" translate="yes" xml:space="preserve">
          <source>Elements are compared using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25857c2157bff6e7a9f798c89b04873173125f2d" translate="yes" xml:space="preserve">
          <source>Elements are compared using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;比较元素。</target>
        </trans-unit>
        <trans-unit id="b1bc7fb1f226e6f6f3ef7ee47c49d49289229118" translate="yes" xml:space="preserve">
          <source>Elements are only emitted when &lt;code&gt;fun&lt;/code&gt; returns a new value or the &lt;code&gt;enum&lt;/code&gt; finishes.</source>
          <target state="translated">仅当 &lt;code&gt;fun&lt;/code&gt; 返回一个新值或 &lt;code&gt;enum&lt;/code&gt; 完成时才发出元素。</target>
        </trans-unit>
        <trans-unit id="a38ddcfce78b5b0835df229de1f7e325877919bd" translate="yes" xml:space="preserve">
          <source>Elements can be inserted using &lt;a href=&quot;#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9167aadfec3df02db420d4d2b50af0ffd51604f5" translate="yes" xml:space="preserve">
          <source>Elements in a set don't have to be of the same type and they can be populated from an &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#t:t/0&quot;&gt;enumerable&lt;/a&gt; using &lt;a href=&quot;#new/1&quot;&gt;&lt;code&gt;MapSet.new/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c7bf14304705b88f3bf9ecdfcf919293c76e53" translate="yes" xml:space="preserve">
          <source>Elixir</source>
          <target state="translated">Elixir</target>
        </trans-unit>
        <trans-unit id="e5c4daa79e73a93f8dc527746d72ef1e1f99e8dd" translate="yes" xml:space="preserve">
          <source>Elixir 1.5.0 onwards</source>
          <target state="translated">Elixir 1.5.0起。</target>
        </trans-unit>
        <trans-unit id="67dd209de0ff8f0eac333c13b028cb684c348812" translate="yes" xml:space="preserve">
          <source>Elixir 1.9.0 onwards</source>
          <target state="translated">Elixir 1.9.0起。</target>
        </trans-unit>
        <trans-unit id="bff9443fa7cf4ae0bab8d5c8f1f4dab57c2d5acf" translate="yes" xml:space="preserve">
          <source>Elixir Forum</source>
          <target state="translated">Elixir论坛</target>
        </trans-unit>
        <trans-unit id="de61752fa33c065b078b47c60fdefbfedf94b579" translate="yes" xml:space="preserve">
          <source>Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as &lt;code&gt;@moduledoc&lt;/code&gt;, &lt;code&gt;@typedoc&lt;/code&gt;, and &lt;code&gt;@doc&lt;/code&gt;). A commonly used metadata is &lt;code&gt;:since&lt;/code&gt;, which annotates in which version that particular module, function, type, or callback was added, as shown in the example above.</source>
          <target state="translated">Elixir允许开发人员将任意元数据附加到文档。这是通过将关键字列表传递到相关属性（例如 &lt;code&gt;@moduledoc&lt;/code&gt; ， &lt;code&gt;@typedoc&lt;/code&gt; 和 &lt;code&gt;@doc&lt;/code&gt; ）来完成的。常用的元数据是 &lt;code&gt;:since&lt;/code&gt; ，它注释在哪个版本中添加了特定的模块，函数，类型或回调，如上面的示例所示。</target>
        </trans-unit>
        <trans-unit id="3c0ee4efd422df64d926e1699ce27c5bdf0b25e6" translate="yes" xml:space="preserve">
          <source>Elixir allows integers to contain &lt;code&gt;_&lt;/code&gt; to separate digits and provides conveniences to represent integers in other bases:</source>
          <target state="translated">Elixir允许整数包含 &lt;code&gt;_&lt;/code&gt; 来分隔数字，并提供了方便的以其他基数表示整数的方法：</target>
        </trans-unit>
        <trans-unit id="f75c26877ef871217ff6769618e4b459e83b4aa9" translate="yes" xml:space="preserve">
          <source>Elixir allows us to derive a protocol implementation based on the &lt;code&gt;Any&lt;/code&gt; implementation. Let&amp;rsquo;s first implement &lt;code&gt;Any&lt;/code&gt; as follows:</source>
          <target state="translated">Elixir允许我们基于 &lt;code&gt;Any&lt;/code&gt; 实现派生协议实现。让我们首先实现 &lt;code&gt;Any&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="83c382416abbdb750f7a0b52274c72d3eeffa512" translate="yes" xml:space="preserve">
          <source>Elixir allows variables to be rebound via static single assignment:</source>
          <target state="translated">Elixir允许变量通过静态单次赋值进行反弹。</target>
        </trans-unit>
        <trans-unit id="0e0d77b67e657e2b9066c1ff6972927494c31617" translate="yes" xml:space="preserve">
          <source>Elixir allows you to skip the leading &lt;code&gt;:&lt;/code&gt; for the atoms &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">长生不老药允许您跳过引导 &lt;code&gt;:&lt;/code&gt; 对于原子 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="413742c1494e68731a98eab50395aa0ab07b3d83" translate="yes" xml:space="preserve">
          <source>Elixir allows you to skip the leading &lt;code&gt;:&lt;/code&gt; for the atoms &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ff842a6a4a3cf98a11fae4fd4498e3695c470e" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code.&lt;/strong&gt;</source>
          <target state="translated">Elixir已经提供了使用其数据结构和功能以简单易读的方式编写日常代码的机制。宏只能用作最后的手段。请记住，&lt;strong&gt;显式胜于隐式&lt;/strong&gt;。&lt;strong&gt;清晰的代码胜于简洁的代码。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c84bd869e800cf00a0f15faeb1fec6f09ff020" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code&lt;/strong&gt;.</source>
          <target state="translated">Elixir已经提供了使用其数据结构和功能以简单易读的方式编写日常代码的机制。宏只能用作最后的手段。请记住，&lt;strong&gt;显式胜于隐式&lt;/strong&gt;。&lt;strong&gt;清晰的代码胜于简洁的代码&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="04d508ddfa3159bfde64248d0cbc115d950cb551" translate="yes" xml:space="preserve">
          <source>Elixir also accepts by default the segment to be a literal string or a literal charlist, which are by default expanded to integers:</source>
          <target state="translated">Elixir 默认情况下也接受该段是一个字面字符串或字面字符表,默认情况下它们都被扩展为整数。</target>
        </trans-unit>
        <trans-unit id="738cbc7a97733fcad20b5d4c9dce828da97453d5" translate="yes" xml:space="preserve">
          <source>Elixir also allows developers to enforce certain keys must always be given when building the struct:</source>
          <target state="translated">Elixir还允许开发人员在构建结构体时强制执行某些键必须始终给出。</target>
        </trans-unit>
        <trans-unit id="b2aeb44fb689a73ee1106300bdf2d7f03241fd14" translate="yes" xml:space="preserve">
          <source>Elixir also contains an &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; function that is a superset of &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir还包含一个&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;函数，它是&lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt;的超集。</target>
        </trans-unit>
        <trans-unit id="1ca22ed394bb9b18d990dbe14484b3d50b19e9ce" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bac89af66dd6a427b4aa3efe3deb03cf5a1fe14" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;kernel.specialforms&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir还具有始终导入的特殊形式，不能跳过。这些在&lt;a href=&quot;kernel.specialforms&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; 中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="d27fae45dd0d77eb7585ffc475445da313d3682e" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6faa91bfb900d671613a6ab47e73da0ae09fa34" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="translated">药剂还包括下面的双下划线格式五个特殊形式：&lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;检索有关当前环境编译时的信息，而&lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt;检索堆栈跟踪当前异常。</target>
        </trans-unit>
        <trans-unit id="243375bae75a446726d90d677eb7c983b489e516" translate="yes" xml:space="preserve">
          <source>Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given.</source>
          <target state="translated">Elixir还利用函数子句中的模式匹配和防护措施,在给出无效参数时提供清晰的错误信息。</target>
        </trans-unit>
        <trans-unit id="e898bf471d8f0d3097ac913073c090b0a995d7eb" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; to manipulate lists:</source>
          <target state="translated">Elixir还提供 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 操作列表：</target>
        </trans-unit>
        <trans-unit id="ac31c787a75befbe1897dbbb6fdd942221f00c86" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; as comparison operators:</source>
          <target state="translated">Elixir还提供 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;===&lt;/code&gt; ， &lt;code&gt;!==&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 作为比较运算符：</target>
        </trans-unit>
        <trans-unit id="969c208849fcc11446141a26b255b57b75a2b0ba" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;Reference&lt;/code&gt;, and &lt;code&gt;PID&lt;/code&gt; as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let&amp;rsquo;s take a look at some of the basic operators that go with our basic types.</source>
          <target state="translated">Elixir还提供 &lt;code&gt;Port&lt;/code&gt; ， &lt;code&gt;Reference&lt;/code&gt; 和 &lt;code&gt;PID&lt;/code&gt; 作为数据类型（通常在过程通信中使用），在讨论过程时，我们将对其进行快速介绍。现在，让我们看一下与基本类型一起使用的一些基本运算符。</target>
        </trans-unit>
        <trans-unit id="dd8a8082108a2f1897c7e7583cc32113fdc162fe" translate="yes" xml:space="preserve">
          <source>Elixir also provides anonymous functions. Anonymous functions allow us to store and pass executable code around as if it was an integer or a string. They are delimited by the keywords &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">Elixir还提供匿名功能。匿名函数使我们能够存储和传递可执行代码，就好像它是整数或字符串一样。它们由关键字 &lt;code&gt;fn&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分隔：</target>
        </trans-unit>
        <trans-unit id="f6f4bfc221320e14428c9be4379f06c74f568d51" translate="yes" xml:space="preserve">
          <source>Elixir also provides other data types that are built on top of the types listed above. Some of them are:</source>
          <target state="translated">Elixir还提供了建立在上述类型之上的其他数据类型。其中一些类型是:</target>
        </trans-unit>
        <trans-unit id="9cf0686be60034d3cedafe5362a85407c3741f2a" translate="yes" xml:space="preserve">
          <source>Elixir also provides ranges:</source>
          <target state="translated">伊莱克斯还提供范围。</target>
        </trans-unit>
        <trans-unit id="5fcce84b0f48ff34d06fe32176864fe647eb61ef" translate="yes" xml:space="preserve">
          <source>Elixir also provides three boolean operators: &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;. These operators are strict in the sense that they expect something that evaluates to a boolean (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) as their first argument:</source>
          <target state="translated">Elixir还提供了三个布尔运算符： &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; 而 &lt;code&gt;not&lt;/code&gt; 。这些运算符是严格意义上的，因为它们期望将第一个参数评估为布尔值（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8d3fab2e2b3e4ed4bda1748059118a3b75cf1e13" translate="yes" xml:space="preserve">
          <source>Elixir also supports &lt;code&gt;left not in right&lt;/code&gt;, which evaluates to &lt;code&gt;not(left in right)&lt;/code&gt;:</source>
          <target state="translated">Elixir还支持 &lt;code&gt;left not in right&lt;/code&gt; ，其结果为 &lt;code&gt;not(left in right)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5a36737e425de601f0dbbe73bf7e68eed9cd0ed3" translate="yes" xml:space="preserve">
          <source>Elixir also supports Unicode in identifiers since Elixir v1.5, as defined in the &lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode Annex #31&lt;/a&gt;. The focus of this document is to describe how Elixir implements the requirements outlined in the Unicode Annex. These requirements are referred to as R1, R6 and so on.</source>
          <target state="translated">从Elixir v1.5开始，Elixir还支持标识符中的&lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode&lt;/a&gt;（如Unicode附件＃31中所定义）。本文档的重点是描述Elixir如何实现Unicode附件中概述的要求。这些要求称为R1，R6等。</target>
        </trans-unit>
        <trans-unit id="831831bd1adbcc4e3da08a8f57e2923a4e93799a" translate="yes" xml:space="preserve">
          <source>Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following:</source>
          <target state="translated">Elixir还支持一种语法,如果调用的最后一个参数是关键字列表,那么可以跳过方括号。这意味着,下面的。</target>
        </trans-unit>
        <trans-unit id="e5d64f0301ab6ac559b63f1c82cbf0dfd37dce82" translate="yes" xml:space="preserve">
          <source>Elixir also supports formatting Erlang reports using Elixir syntax. This can be controlled with two configurations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51de5cd58455d962f06640f299cca5e324e9a622" translate="yes" xml:space="preserve">
          <source>Elixir also supports private macros via &lt;code&gt;defmacrop&lt;/code&gt;. As private functions, these macros are only available inside the module that defines them, and only at compilation time.</source>
          <target state="translated">Elixir还通过 &lt;code&gt;defmacrop&lt;/code&gt; 支持私有宏。作为专用函数，这些宏仅在定义它们的模块内部可用，并且仅在编译时可用。</target>
        </trans-unit>
        <trans-unit id="f11824c210053777bec7ddf3a89c32be210d45f2" translate="yes" xml:space="preserve">
          <source>Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:</source>
          <target state="translated">Elixir还支持输入二进制、八进制和十六进制数字的快捷符号。</target>
        </trans-unit>
        <trans-unit id="6b48fb3c07925bbce80ec4c8c677ff0705ab892b" translate="yes" xml:space="preserve">
          <source>Elixir also supports string interpolation:</source>
          <target state="translated">Elixir还支持字符串插值。</target>
        </trans-unit>
        <trans-unit id="f27c2220090ae1ef4a23c356a5a485deee8ca35d" translate="yes" xml:space="preserve">
          <source>Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:</source>
          <target state="translated">Elixir只对最新的次要分支进行错误修复。最近5个次要分支都有安全补丁。</target>
        </trans-unit>
        <trans-unit id="cda5c07ad4a993425301fa7396f1616f92211ddb" translate="yes" xml:space="preserve">
          <source>Elixir backends can be configured directly under the &lt;code&gt;:logger&lt;/code&gt; application in your &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e561bb8baee392958755d80698909955398d5251" translate="yes" xml:space="preserve">
          <source>Elixir backends run in a separate process which comes with overload protection. However, because this process is a single GenEvent, any long running action should be avoided, as it can lead to bottlenecks in the system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1480fcb21427da507d41fe00e9730d3102cc1601" translate="yes" xml:space="preserve">
          <source>Elixir brings the concept of module attributes from Erlang. For example:</source>
          <target state="translated">Elixir从Erlang引入了模块属性的概念。例如:</target>
        </trans-unit>
        <trans-unit id="f52903a1f8e7fe32784dca96bfb06586e6419189" translate="yes" xml:space="preserve">
          <source>Elixir build information.</source>
          <target state="translated">Elixir构建信息。</target>
        </trans-unit>
        <trans-unit id="b2a6e08225deb1351d7c526d4a6fc2d20b9e7df8" translate="yes" xml:space="preserve">
          <source>Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:</source>
          <target state="translated">Elixir带有一个用于声明类型和规范的符号。Elixir是一种动态类型化的语言,因此,编译器从不使用类型规范来优化或修改代码。不过,使用类型规范还是很有用的,因为。</target>
        </trans-unit>
        <trans-unit id="93e98cb33410c274eb01c0b51b9f879f209f597d" translate="yes" xml:space="preserve">
          <source>Elixir converts switches to underscored atoms, so &lt;code&gt;--source-path&lt;/code&gt; becomes &lt;code&gt;:source_path&lt;/code&gt;. This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches.</source>
          <target state="translated">Elixir将开关转换为带下划线的原子，因此 &lt;code&gt;--source-path&lt;/code&gt; 变为 &lt;code&gt;:source_path&lt;/code&gt; 。这样做是为了更好地适应Elixir约定。但是，这意味着开关不能包含下划线，并且包含下划线的开关总是在无效开关列表中返回。</target>
        </trans-unit>
        <trans-unit id="0c34f7340cb61df5785bd5c3a3996417777eeba7" translate="yes" xml:space="preserve">
          <source>Elixir custom backends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515cdde695b80400042e85d03697fe8c3de3f321" translate="yes" xml:space="preserve">
          <source>Elixir deprecations happen in 3 steps:</source>
          <target state="translated">Elixir的废弃分三步走。</target>
        </trans-unit>
        <trans-unit id="408fc2d27b6f9604c990c32c8ff3bc032eba3849" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, and the like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea52283db054d97df43a259e29d9ebc73278a8f" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, etc.:</source>
          <target state="translated">Elixir开发人员在定义变量，函数名称，模块属性等时必须使用 &lt;code&gt;snake_case&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3fdde18bd0e2fa1e6f5b249dcbd96934a496c8e2" translate="yes" xml:space="preserve">
          <source>Elixir developers often use module attributes when they wish to make a value more visible or reusable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67460a48d2b2975fa71d28207c9deda3618cb78d" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;This blog post&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="translated">Elixir开发人员通常在使用 &lt;code&gt;Map&lt;/code&gt; 时更喜欢使用 &lt;code&gt;map.field&lt;/code&gt; 语法和模式匹配而不是Map模块中的函数，因为它们会导致断言的编程风格。&lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;这篇博客文章&lt;/a&gt;提供了有关如何通过在Elixir中编写断言代码来获得更简洁，更快的软件的见解和示例。</target>
        </trans-unit>
        <trans-unit id="a06f21bbf8d0fbad80b3654800782c5ec40cbcc7" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;https://dashbit.co/blog/writing-assertive-code-with-elixir&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ccd31147a48e978a78387a61b5eaefec5c15c1" translate="yes" xml:space="preserve">
          <source>Elixir developers will often use module attributes as constants:</source>
          <target state="translated">Elixir开发人员经常会将模块属性作为常量。</target>
        </trans-unit>
        <trans-unit id="7edf337af4809fac0491b9f969182b600dc4a216" translate="yes" xml:space="preserve">
          <source>Elixir discourages the use of the &lt;code&gt;string()&lt;/code&gt; type. The &lt;code&gt;string()&lt;/code&gt; type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type &lt;code&gt;string()&lt;/code&gt;, Elixir will emit a warning. You should use &lt;code&gt;charlist()&lt;/code&gt;, &lt;code&gt;nonempty_charlist()&lt;/code&gt;, &lt;code&gt;binary()&lt;/code&gt; or &lt;code&gt;String.t()&lt;/code&gt; accordingly, or any of the several literal representations for these types.</source>
          <target state="translated">Elixir不鼓励使用 &lt;code&gt;string()&lt;/code&gt; 类型。的 &lt;code&gt;string()&lt;/code&gt; 类型指的Erlang字符串，这被称为在药剂&amp;ldquo;charlists&amp;rdquo;。它们不引用Elixir字符串，后者是UTF-8编码的二进制文件。为避免混淆，如果尝试使用 &lt;code&gt;string()&lt;/code&gt; 类型，Elixir将发出警告。您应该相应地使用 &lt;code&gt;charlist()&lt;/code&gt; ， &lt;code&gt;nonempty_charlist()&lt;/code&gt; ， &lt;code&gt;binary()&lt;/code&gt; 或 &lt;code&gt;String.t()&lt;/code&gt; 或这些类型的几种文字表示形式中的任何一种。</target>
        </trans-unit>
        <trans-unit id="d6df36f3b70e0d4fb5ddb48d10dbf25423b1cc5a" translate="yes" xml:space="preserve">
          <source>Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are:</source>
          <target state="translated">Elixir文件还包括 &quot;页面 &quot;部分的辅助文件。这些文件是:</target>
        </trans-unit>
        <trans-unit id="dfbdabad266a6ed24abe7282e3054447cc34c95a" translate="yes" xml:space="preserve">
          <source>Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the ones available at GitHub as a getting started point:</source>
          <target state="translated">Elixir的文档是用Markdown编写的。网上有很多关于Markdown的指南,我们推荐GitHub上的指南作为入门点。</target>
        </trans-unit>
        <trans-unit id="b8ad464d7c3f98c28d6c1301d748b4474f625349" translate="yes" xml:space="preserve">
          <source>Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. R1b is guaranteed for backwards compatibility purposes.</source>
          <target state="translated">Elixir不允许在标识符中使用ZWJ或ZWNJ,因此没有实现R1a。为了向后兼容,保证R1b。</target>
        </trans-unit>
        <trans-unit id="d746cd61df3db6f2fe47fafb3741869cc1431ba6" translate="yes" xml:space="preserve">
          <source>Elixir does not contain a function similar to &lt;code&gt;printf&lt;/code&gt; found in C and other languages. Luckily, the Erlang standard library functions &lt;code&gt;:io.format/2&lt;/code&gt; and &lt;code&gt;:io_lib.format/2&lt;/code&gt; may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from &lt;code&gt;printf&lt;/code&gt;, &lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;refer to the Erlang documentation for details&lt;/a&gt;.</source>
          <target state="translated">Elixir不包含类似于用C和其他语言找到的 &lt;code&gt;printf&lt;/code&gt; 的功能。幸运的是，可以使用Erlang标准库函数 &lt;code&gt;:io.format/2&lt;/code&gt; 和 &lt;code&gt;:io_lib.format/2&lt;/code&gt; 。第一种格式为终端输出，第二种格式为iolist。格式说明符与 &lt;code&gt;printf&lt;/code&gt; 不同，&lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;有关详细信息&lt;/a&gt;，请参见Erlang文档。</target>
        </trans-unit>
        <trans-unit id="979dd9d85c61d8b521a5dc2ef6b2263883c16c08" translate="yes" xml:space="preserve">
          <source>Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:</source>
          <target state="translated">Elixir有少量的保留属性。下面是其中几个最常用的属性。</target>
        </trans-unit>
        <trans-unit id="da143eaa5f18150282df48049071c1cc1a0e242a" translate="yes" xml:space="preserve">
          <source>Elixir has functions, like &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, that &lt;em&gt;only&lt;/em&gt; work with booleans, but also functions that work with these truthy/falsy values, like &lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir具有像&lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; 之&lt;/a&gt;类的函数，该函数&lt;em&gt;仅&lt;/em&gt;适用于布尔值，还具有与这些真实/虚假值一起使用的函数，如&lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#!/1&quot;&gt; &lt;code&gt;!/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88f2b25faa45986049480c976c00dd5855a6e36c" translate="yes" xml:space="preserve">
          <source>Elixir has three error mechanisms: errors, throws, and exits. In this chapter, we will explore each of them and include remarks about when each should be used.</source>
          <target state="translated">Elixir有三种错误机制:错误、抛出和退出。在这一章中,我们将对它们中的每一种进行探讨,并包括关于何时应该使用每一种机制的备注。</target>
        </trans-unit>
        <trans-unit id="0713d95ea58614452d3bd4a78be0cb70359f5d00" translate="yes" xml:space="preserve">
          <source>Elixir has three options for endianness: &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, and &lt;code&gt;native&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;:</source>
          <target state="translated">Elixir的字节序有三种选择： &lt;code&gt;big&lt;/code&gt; ， &lt;code&gt;little&lt;/code&gt; 和 &lt;code&gt;native&lt;/code&gt; 。默认值为 &lt;code&gt;big&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe30cf194fcc420b9fc8698a6260db192b62dfe9" translate="yes" xml:space="preserve">
          <source>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</source>
          <target state="translated">Elixir有两种函数调用的语法。有parens和无parens。默认情况下,Elixir会给所有调用添加parens,但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="9c36cafc5f1778cc6d258e84e87e60d138fd12a4" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are checked at runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea9e99a9db02305c5b70e98171ae53976e93c92" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are inferred by the runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="translated">Elixir是一种动态类型化的语言，因此Elixir中的所有类型均由运行时推断。但是，Elixir带有&lt;strong&gt;typespecs&lt;/strong&gt;，这是一种用于以下目的的符号：</target>
        </trans-unit>
        <trans-unit id="e56a48282c5929f27448e4f74f02e189acbe3204" translate="yes" xml:space="preserve">
          <source>Elixir is an extensible and very customizable programming language thanks to its meta-programming support. Most meta-programming in Elixir is done through macros, which are very useful in several situations, especially for writing DSLs. We have written a short guide that explains the basic mechanisms behind macros, shows how to write macros, and how to use macros to create DSLs:</source>
          <target state="translated">Elixir是一种可扩展的、非常可定制的编程语言,这要归功于它的元编程支持。在Elixir中,大部分元编程都是通过宏来完成的,宏在一些情况下非常有用,特别是对于编写DSL来说。我们写了一个简短的指南,解释了宏背后的基本机制,展示了如何编写宏,以及如何使用宏来创建DSL。</target>
        </trans-unit>
        <trans-unit id="63771eaf5ff6c9a6bd6258b28e240e5f31e971be" translate="yes" xml:space="preserve">
          <source>Elixir is an immutable language where nothing is shared by default. If we want to share information, which can be read and modified from multiple places, we have two main options in Elixir:</source>
          <target state="translated">Elixir是一种不可改变的语言,默认情况下没有任何东西是可以共享的。如果我们想共享信息,可以从多个地方读取和修改信息,在Elixir中我们有两个主要选项。</target>
        </trans-unit>
        <trans-unit id="52c491dbf300477fadaef34d4fecd5fbbc6358fa" translate="yes" xml:space="preserve">
          <source>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are &lt;em&gt;used&lt;/em&gt; by Elixir: for example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are used by Elixir for addition and boolean &lt;em&gt;or&lt;/em&gt;, but &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; is not used (but valid).</source>
          <target state="translated">Elixir能够解析一组预定义的运算符；这意味着不可能定义新的运算符（例如，可以在Haskell中进行定义）。但是，并非Elixir &lt;em&gt;使用&lt;/em&gt; Elixir可以解析的所有运算符：例如 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 。由Elixir用于加法和boolean &lt;em&gt;或&lt;/em&gt;，但不使用 &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; （但有效）。</target>
        </trans-unit>
        <trans-unit id="119a6b69354b723a3119d7eb9b274e46b1a606de" translate="yes" xml:space="preserve">
          <source>Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.</source>
          <target state="translated">Elixir目前是主要版本v1,每6个月会发布一个新的向后兼容的次要版本。补丁的发布不在计划之内,只要有错误修复或安全补丁就会发布。</target>
        </trans-unit>
        <trans-unit id="5569a08dfbe33692762e6efedcb5c7ea0454136a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e6a9f7e2024169f36143b3110efa2bf4ec167a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="translated">Elixir足够聪明，可以将分辨率延迟到最新的时刻。因此，如果您在引号内调用 &lt;code&gt;length([1, 2, 3])&lt;/code&gt; ，但没有&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;函数可用，那么它将在调用方中扩展：</target>
        </trans-unit>
        <trans-unit id="94be6db8aa623aad96175d2a4f009eb3d49d1f72" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to recompile only files that have changed and their dependencies. This means if &lt;code&gt;lib/a.ex&lt;/code&gt; is invoking a function defined over &lt;code&gt;lib/b.ex&lt;/code&gt;, whenever &lt;code&gt;lib/b.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; is also recompiled.</source>
          <target state="translated">Elixir足够聪明，可以仅重新编译已更改的文件及其依赖项。这意味着，如果 &lt;code&gt;lib/a.ex&lt;/code&gt; 调用了通过 &lt;code&gt;lib/b.ex&lt;/code&gt; 定义的函数，则每当 &lt;code&gt;lib/b.ex&lt;/code&gt; 更改时，也会重新编译 &lt;code&gt;lib/a.ex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a352a9b0a3e5c7519c223a1075bc3428e61e0561" translate="yes" xml:space="preserve">
          <source>Elixir is versioned according to a vMAJOR.MINOR.PATCH schema.</source>
          <target state="translated">Elixir根据vMAJOR.MINOR.PATCH模式进行版本调整。</target>
        </trans-unit>
        <trans-unit id="d990d24327822ea7a421e913e80e0202d0dfa1bb" translate="yes" xml:space="preserve">
          <source>Elixir macros have late resolution. This guarantees that a variable defined inside a quote won&amp;rsquo;t conflict with a variable defined in the context where that macro is expanded. For example:</source>
          <target state="translated">Elixir宏的解析度较晚。这样可以保证在引号内定义的变量不会与在该宏展开的上下文中定义的变量冲突。例如：</target>
        </trans-unit>
        <trans-unit id="6c0929a451e1f448275dcbe066bf77535364105c" translate="yes" xml:space="preserve">
          <source>Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions.</source>
          <target state="translated">Elixir的次要版本和补丁版本是向后兼容的:在特定版本中定义良好的行为和文档化的API将继续在未来的版本中工作。</target>
        </trans-unit>
        <trans-unit id="f4a72643c7a8a6ed5341995de6e14044af2a034d" translate="yes" xml:space="preserve">
          <source>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</source>
          <target state="translated">Elixir模块名称可以动态生成。这在使用宏时非常有用。例如,我们可以写道</target>
        </trans-unit>
        <trans-unit id="3135e8d914a8aafb03877d33ea9a4b0de24e09f7" translate="yes" xml:space="preserve">
          <source>Elixir offers several sigils to deal with various flavors of times and dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e063af00bef300726332e4ffbf98de73c83bdc5a" translate="yes" xml:space="preserve">
          <source>Elixir on Discord</source>
          <target state="translated">Elixir on Discord</target>
        </trans-unit>
        <trans-unit id="005e7c25a3d3787c9fd9aad492021fe09a8bd012" translate="yes" xml:space="preserve">
          <source>Elixir on Slack</source>
          <target state="translated">Elixir在Slack上</target>
        </trans-unit>
        <trans-unit id="6ec353d0b43e8fcc2bae198d8d18d71fc59a96c0" translate="yes" xml:space="preserve">
          <source>Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library.</source>
          <target state="translated">Elixir程序应该更倾向于尽可能接近最终用户的数据验证,这样错误很容易定位和修复。这种做法也省去了在库的内部编写防御性代码。</target>
        </trans-unit>
        <trans-unit id="34badf132890db803056b8a329274a11ed6c00d4" translate="yes" xml:space="preserve">
          <source>Elixir projects are usually organized into three directories:</source>
          <target state="translated">Elixir项目通常分为三个目录。</target>
        </trans-unit>
        <trans-unit id="bd498b5c0b475852faf005a008b3295d3968391d" translate="yes" xml:space="preserve">
          <source>Elixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text. We can access the documentation of any compiled module directly from IEx:</source>
          <target state="translated">Elixir提倡使用Markdown与heredocs来编写可读文档。Heredocs是多行字符串,它们以三个双引号开头和结尾,保留了内文的格式。我们可以直接从IEx中访问任何编译模块的文档。</target>
        </trans-unit>
        <trans-unit id="8cd089c42b27bd178061d32f4f832a4a6ee4ad2d" translate="yes" xml:space="preserve">
          <source>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library. Regexes also support modifiers. For example, the &lt;code&gt;i&lt;/code&gt; modifier makes a regular expression case insensitive:</source>
          <target state="translated">Elixir提供了由&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;库实现的Perl兼容正则表达式（regexes）。正则表达式还支持修饰符。例如， &lt;code&gt;i&lt;/code&gt; 修饰符使正则表达式不区分大小写：</target>
        </trans-unit>
        <trans-unit id="ea04f299ea8e7d138416f7682d04dace2f8332f3" translate="yes" xml:space="preserve">
          <source>Elixir provides a bunch of predicate functions to check for a value type. For example, the &lt;code&gt;is_boolean/1&lt;/code&gt; function can be used to check if a value is a boolean or not:</source>
          <target state="translated">Elixir提供了一堆谓词函数来检查值类型。例如， &lt;code&gt;is_boolean/1&lt;/code&gt; 函数可用于检查值是否为布尔值：</target>
        </trans-unit>
        <trans-unit id="f9d0324f32083b4357effd55af42179e669e80ba" translate="yes" xml:space="preserve">
          <source>Elixir provides a special and more concise syntax for keyword lists that looks like this:</source>
          <target state="translated">Elixir为关键字列表提供了一种特殊的、更简洁的语法,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="3fb7d8bf0ef1942795033493f666d84321055fe3" translate="yes" xml:space="preserve">
          <source>Elixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.</source>
          <target state="translated">Elixir提供了与Erlang库的良好互操作性。事实上,Elixir不鼓励简单地包装Erlang库,而是直接与Erlang代码进行接口。在本节中,我们将介绍一些在Elixir中找不到的最常见、最有用的Erlang功能。</target>
        </trans-unit>
        <trans-unit id="b3b982e7fff9bd521206b036c548d296e906492a" translate="yes" xml:space="preserve">
          <source>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.</source>
          <target state="translated">Elixir提供了宏,作为元编程(编写生成代码的代码)的一种机制。宏在编译时被扩展。</target>
        </trans-unit>
        <trans-unit id="449df725d4d68a46665d86a115b480918573511c" translate="yes" xml:space="preserve">
          <source>Elixir provides many &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;built-in types&lt;/a&gt;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;pid&lt;/code&gt;, that can be used to document function signatures. For example, the &lt;code&gt;round/1&lt;/code&gt; function, which rounds a number to its nearest integer. As you can see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;in its documentation&lt;/a&gt;, &lt;code&gt;round/1&lt;/code&gt;&amp;rsquo;s typed signature is written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c38afe5476b8521de1ce73619db182fce82f5c4" translate="yes" xml:space="preserve">
          <source>Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below.</source>
          <target state="translated">Elixir 为使用 port 提供了许多便利,也有一些缺点。我们将在下文中探讨这些缺点。</target>
        </trans-unit>
        <trans-unit id="86797814ddc42c874f88a51b77e92d177f55b7bc" translate="yes" xml:space="preserve">
          <source>Elixir provides optional parentheses for non-qualified and qualified calls.</source>
          <target state="translated">Elixir为非限定和限定调用提供了可选的括号。</target>
        </trans-unit>
        <trans-unit id="1d9a8b35858a0497976075a187083dacc1314354" translate="yes" xml:space="preserve">
          <source>Elixir provides pattern matching, which allows us to assert on the shape or extract values from data-structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1e334b03a647f5918bb69c761fab411cd3e870" translate="yes" xml:space="preserve">
          <source>Elixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like &lt;code&gt;var!/2&lt;/code&gt; and &lt;code&gt;alias!/1&lt;/code&gt;, although one must be careful when using those as they directly change the user environment.</source>
          <target state="translated">Elixir也提供了类似的导入和别名机制。这保证了宏将按照其源模块指定的方式运行，而不与扩展该宏的目标模块发生冲突。在特定情况下，可以使用 &lt;code&gt;var!/2&lt;/code&gt; 和 &lt;code&gt;alias!/1&lt;/code&gt; 这样的宏来绕过卫生措施，尽管在使用它们时会特别注意，因为它们会直接更改用户环境。</target>
        </trans-unit>
        <trans-unit id="7ee83992e184ceb0497492aa46813f6e12944aa3" translate="yes" xml:space="preserve">
          <source>Elixir provides the concept of enumerables and &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;the &lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt; to work with them. We have already learned two enumerables: lists and maps.</source>
          <target state="translated">Elixir提供了可枚举的概念和用于它们&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;的 &lt;code&gt;Enum&lt;/code&gt; 模块&lt;/a&gt;。我们已经学习了两个可枚举的对象：列表和地图。</target>
        </trans-unit>
        <trans-unit id="56408c183550d2230f17bffa1fd59dd5a2aa2dd3" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators (all of which can be used in guards):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38b66bd0f1f07df9af68419dad5d7545d3eb5b0" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators:</source>
          <target state="translated">Elixir提供了以下内置比较运算符。</target>
        </trans-unit>
        <trans-unit id="a073541c1c4061c5b62e401a691e0182a896f380" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in operators that are defined as functions that can be overridden:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac046d5521e866f330d69759ab8c6306ded55946" translate="yes" xml:space="preserve">
          <source>Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</source>
          <target state="translated">Elixir引号/解引号机制提供了一种称为解引号片段的功能。取消引号片段提供了一种简单的方法来快速生成函数。请看这个例子。</target>
        </trans-unit>
        <trans-unit id="8d30f35ec7987f572743e95ef255bb1ce5bee72e" translate="yes" xml:space="preserve">
          <source>Elixir relies on underscores in different situations.</source>
          <target state="translated">Elixir在不同的情况下依靠下划线。</target>
        </trans-unit>
        <trans-unit id="ecffee7d986ded673e3f20c49d26acf93d1febaf" translate="yes" xml:space="preserve">
          <source>Elixir represents &lt;code&gt;Foo.Bar&lt;/code&gt; as &lt;code&gt;__aliases__&lt;/code&gt; so calls can be unambiguously identified by the operator &lt;code&gt;:.&lt;/code&gt;. For example:</source>
          <target state="translated">Elixir将 &lt;code&gt;Foo.Bar&lt;/code&gt; 表示为 &lt;code&gt;__aliases__&lt;/code&gt; ,因此操作员可以清楚地标识呼叫 &lt;code&gt;:.&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="e6bdbab87b861494b0b9df9b50e56bb5cc5d2563" translate="yes" xml:space="preserve">
          <source>Elixir requires all atoms and variables to be in NFC form. Any other form will fail with a relevant error message. Quoted-atoms and strings can, however, be in any form and are not verified by the parser.</source>
          <target state="translated">Elixir要求所有原子和变量都是NFC形式。任何其他形式的原子和变量都会以相关错误信息的形式出现。然而,被引用的原子和字符串可以是任何形式的,并且不会被解析器验证。</target>
        </trans-unit>
        <trans-unit id="edacc18f14ad696b0fd9cee85daa785d105406a3" translate="yes" xml:space="preserve">
          <source>Elixir reserves the following module names: &lt;code&gt;Elixir&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;BitString&lt;/code&gt;, &lt;code&gt;PID&lt;/code&gt;, and &lt;code&gt;Reference&lt;/code&gt;.</source>
          <target state="translated">Elixir保留以下模块名称： &lt;code&gt;Elixir&lt;/code&gt; ， &lt;code&gt;Any&lt;/code&gt; ， &lt;code&gt;BitString&lt;/code&gt; ， &lt;code&gt;PID&lt;/code&gt; 和 &lt;code&gt;Reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a2a631e623ec7dcc0aeb7c643dc24be890d814b" translate="yes" xml:space="preserve">
          <source>Elixir runs on the Erlang Virtual Machine and, sooner or later, an Elixir developer will want to interface with existing Erlang libraries. Here&amp;rsquo;s a list of online resources that cover Erlang&amp;rsquo;s fundamentals and its more advanced features:</source>
          <target state="translated">Elixir在Erlang虚拟机上运行，​​迟早Elixir开发人员将希望与现有的Erlang库进行交互。以下是涵盖Erlang基本知识及其更高级功能的在线资源列表：</target>
        </trans-unit>
        <trans-unit id="4a5fefa1f8798cec1647f9fe4a71993a0c63afa5" translate="yes" xml:space="preserve">
          <source>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</source>
          <target state="translated">Elixir 看到右侧是一个函数调用,就会用管道连接到它。这意味着,如果你想管道到匿名或捕获的函数,它也必须被显式调用。</target>
        </trans-unit>
        <trans-unit id="a8974a1be92f4c12c0a0c52c8b32e2ca1e35088a" translate="yes" xml:space="preserve">
          <source>Elixir ships with facilities to connect nodes and exchange information between them. In fact, we use the same concepts of processes, message passing and receiving messages when working in a distributed environment because Elixir processes are &lt;em&gt;location transparent&lt;/em&gt;. This means that when sending a message, it doesn&amp;rsquo;t matter if the recipient process is on the same node or on another node, the</source>
          <target state="translated">Elixir附带了用于连接节点并在节点之间交换信息的设施。实际上，由于Elixir进程是&lt;em&gt;位置透明的，&lt;/em&gt;因此在分布式环境中工作时，我们使用相同的过程概念，即消息传递和接收消息。这意味着在发送消息时，接收方进程是在同一节点还是在另一个节点上都没有关系，</target>
        </trans-unit>
        <trans-unit id="5c11d827abbb7cde35b0a581d6299d5d74cd7a62" translate="yes" xml:space="preserve">
          <source>Elixir ships with some built-in protocols. In previous chapters, we have discussed the &lt;code&gt;Enum&lt;/code&gt; module which provides many functions that work with any data structure that implements the &lt;code&gt;Enumerable&lt;/code&gt; protocol:</source>
          <target state="translated">Elixir附带了一些内置协议。在前面的章节中，我们讨论了 &lt;code&gt;Enum&lt;/code&gt; 模块，该模块提供了许多功能，可与实现 &lt;code&gt;Enumerable&lt;/code&gt; 协议的任何数据结构一起使用：</target>
        </trans-unit>
        <trans-unit id="dd2cbcbe1872ea6a04fdc11aaa0e830351ff7c7a" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) knows all of the output should be sent back to the original node!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3a064f8543389f89760aca91a7bf4bd3fe1730" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) still has the group leader of the current node (&lt;code&gt;bar&lt;/code&gt;). We have briefly talked about group leaders in the &lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO chapter&lt;/a&gt;.</source>
          <target state="translated">Elixir在另一个节点上生成了一个进程，并返回了它的pid。然后，该代码在存在 &lt;code&gt;Hello.world/0&lt;/code&gt; 函数的另一个节点上执行并调用该函数。注意，&amp;ldquo; hello world&amp;rdquo;的结果打印在当前节点 &lt;code&gt;bar&lt;/code&gt; 而不是 &lt;code&gt;foo&lt;/code&gt; 上。换句话说，要被打印的消息被发送从后 &lt;code&gt;foo&lt;/code&gt; 到 &lt;code&gt;bar&lt;/code&gt; 。发生这种情况是因为在另一个节点（ &lt;code&gt;foo&lt;/code&gt; ）上产生的进程仍具有当前节点（ &lt;code&gt;bar&lt;/code&gt; ）的组长。在&lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO章&lt;/a&gt;中，我们简要讨论了组长。</target>
        </trans-unit>
        <trans-unit id="cdde1bffc734f7ff0a1635ad03d752544e76408f" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="translated">Elixir将文档存储在字节码中的预定义块中。可以使用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;函数从Elixir进行访问。这也意味着仅在需要时访问文档，而在虚拟机加载模块时不访问文档。唯一的缺点是内存中定义的模块（如IEx中定义的模块）无法访问其文档，因为它们未将字节码写入磁盘。</target>
        </trans-unit>
        <trans-unit id="73308596a035e74f58128367e181ad0b11e8c767" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4784f8c761fcb64ca50be28ca3ee0726dd1e34" translate="yes" xml:space="preserve">
          <source>Elixir supports &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; as booleans:</source>
          <target state="translated">Elixir支持布尔值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c1fca4af1967c47f797a528ad384a0b6142eeed4" translate="yes" xml:space="preserve">
          <source>Elixir supports Unicode throughout the language.</source>
          <target state="translated">Elixir在整个语言中支持Unicode。</target>
        </trans-unit>
        <trans-unit id="6e32af56db37e615dec6eaffbd92d992d378d08f" translate="yes" xml:space="preserve">
          <source>Elixir supports compilation tracers, which allows modules to observe constructs handled by the Elixir compiler when compiling files. A tracer is a module that implements the &lt;code&gt;trace/2&lt;/code&gt; function. The function receives the event name as first argument and &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; as second and it must return &lt;code&gt;:ok&lt;/code&gt;. It is very important for a tracer to do as little work as possible synchronously and dispatch the bulk of the work to a separate process. &lt;strong&gt;Slow tracers will slow down compilation&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649a2834ec800cb52f399145f24bccb3f23afbc9" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;, or maps that define keys and types (see the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f173b2bc2f5965b36c7172e06c818c7bd04ae05" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;. You can see all the built-in types provided by Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;in the typespecs docs&lt;/a&gt;.</source>
          <target state="translated">Elixir也支持化合物类型。例如，整数列表的类型为 &lt;code&gt;[integer]&lt;/code&gt; 。您可以&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;在typespecs docs中查看&lt;/a&gt; Elixir提供的所有内置类型。</target>
        </trans-unit>
        <trans-unit id="96cc8eea24e4342cdb1b99a08ca9183edff74d45" translate="yes" xml:space="preserve">
          <source>Elixir supports conversions from charlists which contains any Unicode code point.</source>
          <target state="translated">Elixir支持从包含任何Unicode码点的字符表进行转换。</target>
        </trans-unit>
        <trans-unit id="c47342d7972fff0f119dd077cbc8a84f69c35e4d" translate="yes" xml:space="preserve">
          <source>Elixir supports only code points &lt;code&gt;\t&lt;/code&gt; (0009), &lt;code&gt;\n&lt;/code&gt; (000A), &lt;code&gt;\r&lt;/code&gt; (000D) and &lt;code&gt;\s&lt;/code&gt; (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.</source>
          <target state="translated">Elixir仅支持代码点 &lt;code&gt;\t&lt;/code&gt; （0009）， &lt;code&gt;\n&lt;/code&gt; （000A）， &lt;code&gt;\r&lt;/code&gt; （000D）和 &lt;code&gt;\s&lt;/code&gt; （0020）作为空白，因此不符合要求R3。R3需要支持更多种类的空格和语法字符。</target>
        </trans-unit>
        <trans-unit id="01176f0775592b687fb8331c0702b3ffd6028d87" translate="yes" xml:space="preserve">
          <source>Elixir supports some sigil variants to deal with escaping characters and interpolation. In particular, uppercase letters sigils do not perform interpolation nor escaping. For example, although both &lt;code&gt;~s&lt;/code&gt; and &lt;code&gt;~S&lt;/code&gt; will return strings, the former allows escape codes and interpolation while the latter does not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310bbc013224b7904b922e667f4bf7001bdc5fa3" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements:</source>
          <target state="translated">Elixir语法被设计成有一个直接转换为抽象语法树(AST)。Elixir的AST是一个常规的Elixir数据结构,由以下元素组成。</target>
        </trans-unit>
        <trans-unit id="ff71b1cca0c9586eb958681a7c3aaf58f79bc884" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms.</source>
          <target state="translated">Elixir语法被设计成可以直接转换为抽象语法树(AST)。这意味着Elixir语法大多是统一的,并有少量的 &quot;语法糖 &quot;结构,以减少Elixir常见习语中的噪音。</target>
        </trans-unit>
        <trans-unit id="ce4861615a3c3b43c097938810a51ecb7a613f3a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.</source>
          <target state="translated">Elixir将文档和代码注释视为不同的概念。文档是您和您的应用编程接口(API)用户之间的明确契约,无论是第三方开发者、同事还是您未来的自己。如果模块和函数是您的API的一部分,那么它们必须始终被记录下来。</target>
        </trans-unit>
        <trans-unit id="94ab78733fcffaa0c8d9d75151f47ea7434ea05a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation as a first-class citizen. This means documentation should be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices and doctests.</source>
          <target state="translated">Elixir将文档视为一等公民。这意味着文档应该易于编写和阅读。在本文档中,你将学习如何在Elixir中编写文档,包括模块属性、风格实践和doctests等结构。</target>
        </trans-unit>
        <trans-unit id="3977a0d710ac9b9b84f6c1288fefa9a0d84df520" translate="yes" xml:space="preserve">
          <source>Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a &lt;strong&gt;variable width&lt;/strong&gt; character encoding that uses one to four bytes to store each code point; it is capable of encoding all valid Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c067ad566a52ceb3738f6cd14c05e81b89ddb512" translate="yes" xml:space="preserve">
          <source>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:</source>
          <target state="translated">Elixir使用大括号来定义元组。像列表一样,元组可以容纳任何值。</target>
        </trans-unit>
        <trans-unit id="b7437bc89e4d7cd42e4777ca92ac246386afa15d" translate="yes" xml:space="preserve">
          <source>Elixir uses single quotes to define charlists:</source>
          <target state="translated">Elixir使用单引号来定义charlists。</target>
        </trans-unit>
        <trans-unit id="0a0c9ca226ff9075b8b4027dc040b09a7fc4c136" translate="yes" xml:space="preserve">
          <source>Elixir uses square brackets to specify a list of values. Values can be of any type:</source>
          <target state="translated">Elixir使用方括号来指定一个值的列表。值可以是任何类型。</target>
        </trans-unit>
        <trans-unit id="1ca97f233cf2ddf0b1c0bf0e2277569cae997e55" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7410ee1b8baed2ca63c0da7fbd59f8909583c454" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;code#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Elixir v1.7采用&lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt;，这是一种新的文档格式，可以在所有BEAM语言之间共享。&lt;a href=&quot;code#get_docs/2&quot;&gt; &lt;code&gt;Code.get_docs/2&lt;/code&gt; &lt;/a&gt;使用的旧格式不再可用，因此此函数始终返回 &lt;code&gt;nil&lt;/code&gt; 。请改用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2c8e7ddf395da597d9d7092789c372c5e9cb894" translate="yes" xml:space="preserve">
          <source>Elixir version</source>
          <target state="translated">Elixir版本</target>
        </trans-unit>
        <trans-unit id="3ef1a22d73c732ddfb0e37deb22c5920363b7ef9" translate="yes" xml:space="preserve">
          <source>Elixir version information.</source>
          <target state="translated">Elixir版本信息。</target>
        </trans-unit>
        <trans-unit id="2d1a3e13eeda4320739159e4214187b33436ad5e" translate="yes" xml:space="preserve">
          <source>Elixir will accept any module name as long as the expression passed as the first argument to &lt;a href=&quot;#defmodule/2&quot;&gt;&lt;code&gt;defmodule/2&lt;/code&gt;&lt;/a&gt; evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.</source>
          <target state="translated">只要将作为&lt;a href=&quot;#defmodule/2&quot;&gt; &lt;code&gt;defmodule/2&lt;/code&gt; &lt;/a&gt;的第一个参数传递的表达式求值为原子，Elixir就会接受任何模块名称。请注意，使用动态名称时，Elixir不会将名称嵌套在当前模块下，也不会自动设置别名。</target>
        </trans-unit>
        <trans-unit id="0c3a96ef15c7b10a131a32d7fe611882ee9f141c" translate="yes" xml:space="preserve">
          <source>Elixir will automatically wrap the function body in a &lt;code&gt;try&lt;/code&gt; whenever one of &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; is specified.</source>
          <target state="translated">只要指定了 &lt;code&gt;after&lt;/code&gt; ， &lt;code&gt;rescue&lt;/code&gt; 或 &lt;code&gt;catch&lt;/code&gt; 之一，Elixir就会自动 &lt;code&gt;try&lt;/code&gt; 包装功能主体。</target>
        </trans-unit>
        <trans-unit id="a85970e0faad243447c5114389dcdeb0a39d337f" translate="yes" xml:space="preserve">
          <source>Elixir&amp;rsquo;s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</source>
          <target state="translated">Elixir的进程不应与操作系统进程混淆。就内存和CPU而言，Elixir中的进程极为轻巧（即使与许多其他编程语言中使用的线程相比也是如此）。因此，同时运行成千上万的进程并不罕见。</target>
        </trans-unit>
        <trans-unit id="74afface970af5cae73731659047f9af84feb478" translate="yes" xml:space="preserve">
          <source>Elixir's AST (Abstract Syntax Tree)</source>
          <target state="translated">Elixir的AST(抽象语法树)。</target>
        </trans-unit>
        <trans-unit id="ce6d269d872319624d23c6d1f8a1436923e77f5d" translate="yes" xml:space="preserve">
          <source>Elixir's interactive shell.</source>
          <target state="translated">Elixir的交互式外壳。</target>
        </trans-unit>
        <trans-unit id="b500d25431abdc8af2398b8e041e9fe8f8aee8f4" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;application&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir的标准库包含一些常用的行为，例如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;application&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b38f6b406adad2c4ad9a3c750691827797402b8" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c075ef1bb96e78c3aeb788db6fdaa2ad6900d8" translate="yes" xml:space="preserve">
          <source>Else</source>
          <target state="translated">Else</target>
        </trans-unit>
        <trans-unit id="a956e2fd0a59819b9e171fd2f4db600228e545a0" translate="yes" xml:space="preserve">
          <source>Embeds a template given by &lt;code&gt;contents&lt;/code&gt; into the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fd52b24df6fd39026fb28f8524cf6ca06d78cf" translate="yes" xml:space="preserve">
          <source>Embeds a text given by &lt;code&gt;contents&lt;/code&gt; into the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3a40099a2074128eab39c61a99ee9cc8c97d42" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given accumulator.</source>
          <target state="translated">发出一个给定累加器的数值序列。</target>
        </trans-unit>
        <trans-unit id="13f5c3f168a677e832d55a71220e8084e5ebb435" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given resource.</source>
          <target state="translated">发出给定资源的值的序列。</target>
        </trans-unit>
        <trans-unit id="ee36a1b257d40c27de1319e9f52bd4df213a780a" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values, starting with &lt;code&gt;start_value&lt;/code&gt;. Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; on the previous value.</source>
          <target state="translated">发出一系列值，从 &lt;code&gt;start_value&lt;/code&gt; 开始。通过对前一个值调用 &lt;code&gt;next_fun&lt;/code&gt; 来生成连续值。</target>
        </trans-unit>
        <trans-unit id="c167634bd4b2e54cc64b0ca7da7acd698bd3f926" translate="yes" xml:space="preserve">
          <source>Empty list elements are discarded.</source>
          <target state="translated">空列表元素将被丢弃。</target>
        </trans-unit>
        <trans-unit id="2965dae66a63ca2f32957370b2d3c71d31f0404a" translate="yes" xml:space="preserve">
          <source>Empty list elements from &lt;code&gt;list&lt;/code&gt; are discarded, but not the ones from &lt;code&gt;tail&lt;/code&gt;.</source>
          <target state="translated">list中的空列表元素 &lt;code&gt;list&lt;/code&gt; 被丢弃，而 &lt;code&gt;tail&lt;/code&gt; 中的元素将不被丢弃。</target>
        </trans-unit>
        <trans-unit id="e62ffd3f17608b67830975574d7151f053f3b91e" translate="yes" xml:space="preserve">
          <source>Empty strings are only removed from the result if the &lt;code&gt;:trim&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;:trim&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ,则仅从结果中删除空字符串。</target>
        </trans-unit>
        <trans-unit id="55e69718479729085dd821e5465e25f44c0324fa" translate="yes" xml:space="preserve">
          <source>Enables logging for the current process.</source>
          <target state="translated">启用当前进程的日志记录。</target>
        </trans-unit>
        <trans-unit id="e2d19b78121686bc349ccaa09a8452830a7f9140" translate="yes" xml:space="preserve">
          <source>Encircled.</source>
          <target state="translated">Encircled.</target>
        </trans-unit>
        <trans-unit id="c616c5fe7020dabc2f93906e0a5f2e05bdc7d8a9" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">将 &lt;code&gt;string&lt;/code&gt; 编码为&amp;ldquo; x-www-form-urlencoded&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="89ea780eda521b71e81ed735656c9b61d9499afc" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 16 encoded string.</source>
          <target state="translated">将二进制字符串编码为16进制编码的字符串。</target>
        </trans-unit>
        <trans-unit id="b7e8311ecf9de60bb4c8128af17fdd4f6e19c5bd" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet.</source>
          <target state="translated">将一个二进制字符串编码成一个以扩展的十六进制字母为基础的32编码字符串。</target>
        </trans-unit>
        <trans-unit id="36e80d95ff066a33ec7f84aa78c9dbee7b1c006d" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string.</source>
          <target state="translated">将二进制字符串编码为32基编码的字符串。</target>
        </trans-unit>
        <trans-unit id="02f9836e91d8d8f20631bf25f980c01911623202" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet.</source>
          <target state="translated">将一个二进制字符串编码成基数为64的编码字符串,并使用URL和文件名安全字母。</target>
        </trans-unit>
        <trans-unit id="598559f4be54955449341d6458c6b1bc5c089d2a" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string.</source>
          <target state="translated">将二进制字符串编码为64基编码的字符串。</target>
        </trans-unit>
        <trans-unit id="669885d2c33e97774bece663078c5982ab0c0947" translate="yes" xml:space="preserve">
          <source>Encodes an enumerable into a query string.</source>
          <target state="translated">将一个数值编码为一个查询字符串。</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="322c5d3730703ae50125a473e7a7c3d0e9ef2301" translate="yes" xml:space="preserve">
          <source>Endianness</source>
          <target state="translated">Endianness</target>
        </trans-unit>
        <trans-unit id="2ea89f176d80e61e2fa991e7665230fc139bc40d" translate="yes" xml:space="preserve">
          <source>Enforcing keys</source>
          <target state="translated">强制执行钥匙</target>
        </trans-unit>
        <trans-unit id="c1f65ddb75ed7d97e701168af35171410be8f9e7" translate="yes" xml:space="preserve">
          <source>Engine</source>
          <target state="translated">Engine</target>
        </trans-unit>
        <trans-unit id="428bd921a8f300c3b20c8266821204a755c68434" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; and its applications are started.</source>
          <target state="translated">确保给定的 &lt;code&gt;app&lt;/code&gt; 及其应用程序已启动。</target>
        </trans-unit>
        <trans-unit id="555514beae7482d6d57cd04de49cfc7d3710c06c" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb7dedc1a9428584a4069438797a9ae78f66928" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is started.</source>
          <target state="translated">确保给定的 &lt;code&gt;app&lt;/code&gt; 已启动。</target>
        </trans-unit>
        <trans-unit id="23ee0124a924556d787c30d38fea8fafda3318c2" translate="yes" xml:space="preserve">
          <source>Ensures the given module is compiled and loaded.</source>
          <target state="translated">确保给定的模块被编译和加载。</target>
        </trans-unit>
        <trans-unit id="c639ba03accf3baf6f605c3c0a367752ac1ba4b8" translate="yes" xml:space="preserve">
          <source>Ensures the given module is loaded.</source>
          <target state="translated">确保给定的模块被加载。</target>
        </trans-unit>
        <trans-unit id="02d3338a85e66444166e14ec820ab3f756bc5765" translate="yes" xml:space="preserve">
          <source>Ensures the project structure for the given project exists.</source>
          <target state="translated">确保给定项目的项目结构存在。</target>
        </trans-unit>
        <trans-unit id="dd06dfc909fbc0c4ad3d2dc1fed376ba517fa970" translate="yes" xml:space="preserve">
          <source>Entries with duplicated keys end up in the same keyword list.</source>
          <target state="translated">有重复键的条目最终会出现在同一个关键词列表中。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="44a9d3cb7758b69424c29688d3733784f2d7beb8" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError</source>
          <target state="translated">Enum.EmptyError</target>
        </trans-unit>
        <trans-unit id="203f8ecd57ba73b4d911d61ce2b2e0bbecd88546" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.EmptyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92ff846ccb27bb1237f0fe73dffd1111a34febfd" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError</source>
          <target state="translated">Enum.OutOfBoundsError</target>
        </trans-unit>
        <trans-unit id="64fce429b4436d311f9ed265caf9dbd13748ca8e" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.OutOfBoundsError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="83df7a7ef8fa21dd3116045758d3e9407ca3149d" translate="yes" xml:space="preserve">
          <source>Enumerable</source>
          <target state="translated">Enumerable</target>
        </trans-unit>
        <trans-unit id="a8bd4b8016c41ed593121704b28a0f638927292f" translate="yes" xml:space="preserve">
          <source>Enumerable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">可数&lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d949b006b0cb6700716702ddad84d81584b294d8" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c0dbf914d64832e2d144e52e6254adb376dd46" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;map#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;map#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;map#drop/2&quot;&gt; &lt;code&gt;Map.drop/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;map#split/2&quot;&gt; &lt;code&gt;Map.split/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map#take/2&quot;&gt; &lt;code&gt;Map.take/2&lt;/code&gt; 中的&lt;/a&gt;可枚举键</target>
        </trans-unit>
        <trans-unit id="140efbf707d0a7d6c39e74eac70140aecd0e5c56" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块使用的可枚举协议。</target>
        </trans-unit>
        <trans-unit id="a08785570fea867f5f88ca2ee2af7ae3e1313ca0" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50ecedb47e87b1d9271881d5fe0a9349ed165af" translate="yes" xml:space="preserve">
          <source>Enumerable.acc (0)</source>
          <target state="translated">Enumerable.acc (0)</target>
        </trans-unit>
        <trans-unit id="165c38b0e896ed9f5159922dce36f171ef2320bb" translate="yes" xml:space="preserve">
          <source>Enumerable.continuation (0)</source>
          <target state="translated">Enumerable.continuation (0)</target>
        </trans-unit>
        <trans-unit id="ba612d94bc0277c74713f344be3f6d833e339b91" translate="yes" xml:space="preserve">
          <source>Enumerable.count (1)</source>
          <target state="translated">Enumerable.count (1)</target>
        </trans-unit>
        <trans-unit id="c8a16ef4893a246c5d44ffbd9b826395af284553" translate="yes" xml:space="preserve">
          <source>Enumerable.member? (2)</source>
          <target state="translated">Enumerable.成员? (2)</target>
        </trans-unit>
        <trans-unit id="a9bae250bd6ab01ed637153931cbca7969a9d2fd" translate="yes" xml:space="preserve">
          <source>Enumerable.reduce (3)</source>
          <target state="translated">Enumerable.reduce (3)</target>
        </trans-unit>
        <trans-unit id="ee6aa06bf997d33de46b0f36134133d251942cde" translate="yes" xml:space="preserve">
          <source>Enumerable.reducer (0)</source>
          <target state="translated">Enumerable.reducer (0)</target>
        </trans-unit>
        <trans-unit id="642806a29777279924e9371db22138badd652470" translate="yes" xml:space="preserve">
          <source>Enumerable.result (0)</source>
          <target state="translated">Enumerable.result (0)</target>
        </trans-unit>
        <trans-unit id="67feaa35a2d44a604538ef39106d006cede14270" translate="yes" xml:space="preserve">
          <source>Enumerable.slice (1)</source>
          <target state="translated">Enumerable.slice (1)</target>
        </trans-unit>
        <trans-unit id="976e95d4d549c47ec6aacfa3aeb87430d06ae485" translate="yes" xml:space="preserve">
          <source>Enumerable.slicing_fun (0)</source>
          <target state="translated">Enumerable.slicing_fun (0)</target>
        </trans-unit>
        <trans-unit id="8099438503374b0f111ad8c4312c5674efd4704f" translate="yes" xml:space="preserve">
          <source>Enumerable.t (0)</source>
          <target state="translated">Enumerable.t (0)</target>
        </trans-unit>
        <trans-unit id="7d2e28d9448f286359bfee7b46440bedbb9fdf58" translate="yes" xml:space="preserve">
          <source>Enumerables</source>
          <target state="translated">Enumerables</target>
        </trans-unit>
        <trans-unit id="1dc0acb1a8bb4c81550d3ac71c2122f2718c66f7" translate="yes" xml:space="preserve">
          <source>Enumerables and Streams</source>
          <target state="translated">枚举和串联</target>
        </trans-unit>
        <trans-unit id="30d600c6cc439356af01777f989e3d24add2e962" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, by removing the elements for which function &lt;code&gt;fun&lt;/code&gt; returned duplicate elements.</source>
          <target state="translated">通过删除函数 &lt;code&gt;fun&lt;/code&gt; 返回其重复元素的元素来枚举 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0710d3c7a9e2c2a7ab19f785bc7e4ac156c8c8ae" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, removing all duplicated elements.</source>
          <target state="translated">枚举 &lt;code&gt;enumerable&lt;/code&gt; ，删除所有重复的元素。</target>
        </trans-unit>
        <trans-unit id="d63d851ffe5d4b54e805b90b32ec2610b7cdc775" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, returning a list where all consecutive duplicated elements are collapsed to a single element.</source>
          <target state="translated">枚举 &lt;code&gt;enumerable&lt;/code&gt; ，返回一个列表，其中所有连续重复的元素都折叠为一个元素。</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="e22b06d69ee07489bc27f1054e5551d2fb3ffec1" translate="yes" xml:space="preserve">
          <source>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;, for example:</source>
          <target state="translated">不打算保留值（基本上充当标志）的环境变量应设置为 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;true&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="8263704ec4e031f9cd98ed43d056f7db9e2fa14d" translate="yes" xml:space="preserve">
          <source>Equal to operator. Returns &lt;code&gt;true&lt;/code&gt; if the two terms are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9ca98304ae0b29eb5edae09971f0cda610aca2" translate="yes" xml:space="preserve">
          <source>Erlang Term Storage</source>
          <target state="translated">Erlang术语存储</target>
        </trans-unit>
        <trans-unit id="873eaae56cb75c28c82e887676a81c9c926d3d76" translate="yes" xml:space="preserve">
          <source>Erlang VM process identifier.</source>
          <target state="translated">Erlang虚拟机进程标识符。</target>
        </trans-unit>
        <trans-unit id="0f56eeaacbf7d4f4fe215cd958650ad712192183" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode code points. Bytes (&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode code points (&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d81fb4bfd2d9c41c1a7ce9b604e0403471792c0" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode codepoints. Bytes (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode codepoints (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="translated">Erlang和Elixir也有&lt;a href=&quot;#t:chardata/0&quot;&gt; &lt;code&gt;chardata/0&lt;/code&gt; &lt;/a&gt;的想法。Chardata与IO数据非常相似：唯一的区别是IO数据中的整数表示字节，而chardata中的整数表示Unicode代码点。字节（&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;byte/0&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;0..255&lt;/code&gt; 范围内的整数，而Unicode代码点（&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;char/0&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;0..0x10FFFF&lt;/code&gt; 范围内的整数。在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块提供&lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt;为chardata作为的&amp;ldquo;计数器部分的&amp;rdquo;功能&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;功能IO的数据。</target>
        </trans-unit>
        <trans-unit id="257cd41d0a52105a1f464fecff0c7474573eaa0b" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir are sometimes known for the capability of upgrading a node that is running in production without shutting down that node. However, this feature is not supported out of the box by Elixir releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad841c6351d40f6ce14b1c3365f66f45cf90f9a" translate="yes" xml:space="preserve">
          <source>Erlang configuration - options that handle integration with Erlang's logging facilities</source>
          <target state="translated">Erlang配置-处理与Erlang日志设施集成的选项。</target>
        </trans-unit>
        <trans-unit id="dcdbc42e4590fc1cd5b2780008879d7043463df9" translate="yes" xml:space="preserve">
          <source>Erlang errors</source>
          <target state="translated">获取错误</target>
        </trans-unit>
        <trans-unit id="afd9042ead7605c46c0058e1b4e52ac063ec4da4" translate="yes" xml:space="preserve">
          <source>Erlang errors are transformed into Elixir ones when rescuing:</source>
          <target state="translated">救援时,Erlang的错误会转化为Elixir的错误。</target>
        </trans-unit>
        <trans-unit id="ef09a5110ea182804c30762b32ada9f7c5b439dd" translate="yes" xml:space="preserve">
          <source>Erlang handlers run in the same process as the process logging the message/event. This gives developers more flexibility but they should avoid performing any long running action in such handlers, as it may slow down the action being executed considerably. At the moment, there is no built-in overload protection for Erlang handlers, so it is your responsibility to implement it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e47b987c75aeed2cf56f80f3a45202d7a9cade" translate="yes" xml:space="preserve">
          <source>Erlang has two modes to load code: interactive and embedded.</source>
          <target state="translated">Erlang有两种加载代码的模式:交互式和嵌入式。</target>
        </trans-unit>
        <trans-unit id="c4aea0a9415c252cca77b12b8e68bf25c0600b44" translate="yes" xml:space="preserve">
          <source>Erlang libraries</source>
          <target state="translated">Erlang库</target>
        </trans-unit>
        <trans-unit id="947adf59db0f5074b68cab24e83d10f84084f65d" translate="yes" xml:space="preserve">
          <source>Erlang projects</source>
          <target state="translated">Erlang项目</target>
        </trans-unit>
        <trans-unit id="353a427c9c3948990fb1397e32a17449450dd341" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;tutorial&lt;/a&gt; with pictures that briefly describe Erlang&amp;rsquo;s primitives for concurrent programming.</source>
          <target state="translated">Erlang的官方网站上有一个简短的&lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;教程，&lt;/a&gt;其中包含图片，简要描述了Erlang用于并发编程的原语。</target>
        </trans-unit>
        <trans-unit id="2924249c9d3eeb99cc39153818164a0a08c129f2" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;https://www.erlang.org/course&quot;&gt;tutorial&lt;/a&gt;. There is chapter with pictures briefly describing Erlang&amp;rsquo;s primitives for &lt;a href=&quot;https://www.erlang.org/course/concurrent_programming.html&quot;&gt;concurrent programming&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b602b5d1c8c7cedbd11a4c46c7bec0f2ef6328" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 19 onwards</source>
          <target state="translated">Erlang/OTP 19以上</target>
        </trans-unit>
        <trans-unit id="9f3b0640f155508325d5fd627bb055c21f7b1145" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 20 onwards</source>
          <target state="translated">Erlang/OTP 20以上</target>
        </trans-unit>
        <trans-unit id="3c959257e030332549e20072b5db96d3e0320669" translate="yes" xml:space="preserve">
          <source>Erlang/OTP handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d3ba354eaa3fdf7c394b986d2d13ceb0a09b7f" translate="yes" xml:space="preserve">
          <source>Erlang/OTP handlers must be listed under your own application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20c6b34c6701bebbb6bc88a9d6f49d957b3f1ee" translate="yes" xml:space="preserve">
          <source>Erlang/OTP integration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0240f7d16642d7d18aa4135e9508d4430ca6ed28" translate="yes" xml:space="preserve">
          <source>Erlang/OTP versioning is independent from the versioning of Elixir. Each version of Elixir supports a specific range of Erlang/OTP versions. The compatibility table is shown below.</source>
          <target state="translated">Erlang/OTP的版本管理是独立于Elixir的版本管理的。Elixir的每个版本都支持特定范围的Erlang/OTP版本。兼容性表如下所示。</target>
        </trans-unit>
        <trans-unit id="95b539190ee1df5b25c9d30c7a60632c2c6242b6" translate="yes" xml:space="preserve">
          <source>ErlangError</source>
          <target state="translated">ErlangError</target>
        </trans-unit>
        <trans-unit id="eb887d05f639b63c61d49ed79af8fbf4426605b6" translate="yes" xml:space="preserve">
          <source>ErlangError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ErlangError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="6a37b79ee438a25b4b00f639862f12f01079bb8d" translate="yes" xml:space="preserve">
          <source>Error logger configuration</source>
          <target state="translated">错误记录器配置</target>
        </trans-unit>
        <trans-unit id="9497fa3a6a15769b096afdea76d16a9bb93c4394" translate="yes" xml:space="preserve">
          <source>Error reasons</source>
          <target state="translated">错误原因</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e4b51562d8691be50e95ec4d102a96ec94cfc7fc" translate="yes" xml:space="preserve">
          <source>Errors (or &lt;em&gt;exceptions&lt;/em&gt;) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number into an atom:</source>
          <target state="translated">当代码中发生异常情况时，将使用错误（或&lt;em&gt;异常&lt;/em&gt;）。可以通过尝试向原子中添加数字来检索示例错误：</target>
        </trans-unit>
        <trans-unit id="1e769d29496e91df4803194e858296cef49f583c" translate="yes" xml:space="preserve">
          <source>Errors can be &lt;strong&gt;rescued&lt;/strong&gt; using the &lt;code&gt;try/rescue&lt;/code&gt; construct:</source>
          <target state="translated">可以使用 &lt;code&gt;try/rescue&lt;/code&gt; 构造来&lt;strong&gt;挽救&lt;/strong&gt;错误：</target>
        </trans-unit>
        <trans-unit id="ace44333765fe041260545be00bfe6b34903e900" translate="yes" xml:space="preserve">
          <source>Errors in guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7f25adbd68385b52715a0e769e2e3468d082ed" translate="yes" xml:space="preserve">
          <source>Escape characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf06e4f5765ec1423667355b26bedd03532387d" translate="yes" xml:space="preserve">
          <source>Escapes a string to be literally matched in a regex.</source>
          <target state="translated">在regex中逃避一个字符串的字面匹配。</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="7e30234707fb1dda8ea3159dd78fbf5f465fb228" translate="yes" xml:space="preserve">
          <source>Escripts are installed at &lt;code&gt;~/.mix/escripts&lt;/code&gt;. Add that path to your &lt;code&gt;PATH&lt;/code&gt; environment variable to be able to run installed escripts from any directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfc5f1f3afc3241e14ccf2fda82512fad9553a23" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef08760354a34230fab73487dfba3c92eef3db07" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="translated">应将脚本用作开发人员之间共享脚本的机制，而不应将其用作部署机制。对于运行实时系统，请考虑使用&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;或构建发行版。有关系统生命周期的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9a5a63b505c94b9715c6cb22738effadf43970a2" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">建立到 &lt;code&gt;node&lt;/code&gt; 的连接。</target>
        </trans-unit>
        <trans-unit id="5197d13a701e91968e7385a64eaafa020ebb9b3e" translate="yes" xml:space="preserve">
          <source>Evals the given file.</source>
          <target state="translated">评估给定的文件。</target>
        </trans-unit>
        <trans-unit id="a80e33a10ee3ca88cd7700527b66fae439803baa" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt;) or a file (&lt;a href=&quot;#eval_file/3&quot;&gt;&lt;code&gt;eval_file/3&lt;/code&gt;&lt;/a&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61e6ac1811baae3135839c7b54f099f020838b7" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;code&gt;eval_string&lt;/code&gt;) or a file (&lt;code&gt;eval_file&lt;/code&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="translated">直接评估一个字符串（ &lt;code&gt;eval_string&lt;/code&gt; ）或一个文件（ &lt;code&gt;eval_file&lt;/code&gt; ）。这是最简单使用的API，但也是最慢的API，因为该代码之前是经过评估而不编译的。</target>
        </trans-unit>
        <trans-unit id="b6b73d4e37c0e2fc6bcd10607ad1cdb1b13313ab" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">评估板 &lt;code&gt;fun&lt;/code&gt; ，并将结果下 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; ，除非 &lt;code&gt;key&lt;/code&gt; 是已经存在。</target>
        </trans-unit>
        <trans-unit id="47fea9e50d94c5ba5334f9182ab4da272971ff69" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in keyword list unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">评估板 &lt;code&gt;fun&lt;/code&gt; ，并将结果下 &lt;code&gt;key&lt;/code&gt; 在关键字列表，除非 &lt;code&gt;key&lt;/code&gt; 是已经存在。</target>
        </trans-unit>
        <trans-unit id="378c49e24c10c27a713c2ca33d351716056ef24a" translate="yes" xml:space="preserve">
          <source>Evaluates and copy templates at &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a2755ea234063a3a9b34d6399df316742199aa" translate="yes" xml:space="preserve">
          <source>Evaluates the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; filters against the given &lt;code&gt;tags&lt;/code&gt; to determine if tests should be skipped or excluded.</source>
          <target state="translated">根据给定 &lt;code&gt;tags&lt;/code&gt; 评估 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 过滤器，以确定是否应跳过或排除测试。</target>
        </trans-unit>
        <trans-unit id="a872b79753ae8c15cc036688d28a6487ac1713c4" translate="yes" xml:space="preserve">
          <source>Evaluates the configuration &lt;code&gt;contents&lt;/code&gt; for the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">评估给定 &lt;code&gt;file&lt;/code&gt; 的配置 &lt;code&gt;contents&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d2ad4fd562a8770695759664566e68c79e896d7" translate="yes" xml:space="preserve">
          <source>Evaluates the contents given by &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;string&lt;/code&gt; 给出的内容。</target>
        </trans-unit>
        <trans-unit id="3f66e28bdcb030fa5267d28739b480d4ccf00895" translate="yes" xml:space="preserve">
          <source>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</source>
          <target state="translated">评估第一个子句对应的表达式,该表达式评估为truthhy值。</target>
        </trans-unit>
        <trans-unit id="1ba5f7241081077b03b80183e469003ca9d8656f" translate="yes" xml:space="preserve">
          <source>Evaluates the given configuration file.</source>
          <target state="translated">评估给定的配置文件。</target>
        </trans-unit>
        <trans-unit id="f9da9d74593adcfa13d94962a59c2dd76ee78247" translate="yes" xml:space="preserve">
          <source>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</source>
          <target state="translated">评估给定的表达式,并处理任何可能发生的错误、退出或抛出。</target>
        </trans-unit>
        <trans-unit id="8c971533ea3061f79d23aaa5efa90e539f841e09" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents in the given module's context.</source>
          <target state="translated">评估给定模块上下文中引用的内容。</target>
        </trans-unit>
        <trans-unit id="faed542c6d7a022474593aebff34b62313141b57" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents.</source>
          <target state="translated">对所引用的内容进行评估。</target>
        </trans-unit>
        <trans-unit id="211455d468ff468d1666caa77c6ea4a591130f77" translate="yes" xml:space="preserve">
          <source>Evaluating configuration</source>
          <target state="translated">评价配置</target>
        </trans-unit>
        <trans-unit id="af2f0cacf83a79f7f113163a613ddccc7608558d" translate="yes" xml:space="preserve">
          <source>Even a map is represented as a call to &lt;code&gt;%{}&lt;/code&gt;:</source>
          <target state="translated">甚至地图也表示为对 &lt;code&gt;%{}&lt;/code&gt; 的调用：</target>
        </trans-unit>
        <trans-unit id="9379ba740718a45c562052c55dae060f6e11aa7a" translate="yes" xml:space="preserve">
          <source>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</source>
          <target state="translated">即使定时器已经过期,消息已经发送,这个功能也不会告诉你超时消息是否已经到达目的地。</target>
        </trans-unit>
        <trans-unit id="27ed9c8d1ab5b1899cff5f812cb51b56f1af0736" translate="yes" xml:space="preserve">
          <source>Even if we have type-specific functions for getting the size built into Elixir (such as &lt;code&gt;tuple_size/1&lt;/code&gt;), we could implement a generic &lt;code&gt;Size&lt;/code&gt; protocol that all data structures for which size is pre-computed would implement.</source>
          <target state="translated">即使我们具有特定类型的函数来获取内置到Elixir中的大小（例如 &lt;code&gt;tuple_size/1&lt;/code&gt; ），我们也可以实现通用的 &lt;code&gt;Size&lt;/code&gt; 协议，该协议将为所有预先计算大小的数据结构实现。</target>
        </trans-unit>
        <trans-unit id="9d8348e73cb5ab059583fd7f108ed8a332dfe09b" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it&amp;rsquo;s considered to be bad style to use them when they&amp;rsquo;re not necessary. So write macros responsibly.</source>
          <target state="translated">即使Elixir尽最大努力为宏提供安全的环境，但使用宏编写干净的代码的主要责任仍落在开发人员身上。宏比普通的Elixir函数更难编写，并且在不需要它们时使用宏被认为是不好的样式。因此，负责任地编写宏。</target>
        </trans-unit>
        <trans-unit id="52a8ac08291fe93f3d696a3c45b1d1387494b7dc" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly.</source>
          <target state="translated">尽管Elixir尽力为宏提供一个安全的环境,但用宏写出干净的代码的主要责任还是落在开发人员身上。宏比普通的Elixir函数更难写,而且在没有必要的情况下使用宏被认为是一种不良风格。所以要负责任地写宏。</target>
        </trans-unit>
        <trans-unit id="b287135931c568aaa11f51a4123249a43f85f9eb" translate="yes" xml:space="preserve">
          <source>Even though lists preserve the user ordering, the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any ordering. For example, if you invoke &lt;code&gt;Keyword.put(opts, new_key, new_value)&lt;/code&gt;, there is no guarantee to where &lt;code&gt;new_key&lt;/code&gt; will be added (to the front, to the end, or anywhere else).</source>
          <target state="translated">即使列表保留了用户顺序，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;的功能也不保证任何顺序。例如，如果您调用 &lt;code&gt;Keyword.put(opts, new_key, new_value)&lt;/code&gt; ，则不能保证将 &lt;code&gt;new_key&lt;/code&gt; 添加到何处（在开头，结尾或其他位置）。</target>
        </trans-unit>
        <trans-unit id="028b9d4259c03a084cc43fe3d1014cc325f783d4" translate="yes" xml:space="preserve">
          <source>Even though the directory is empty and there is no &lt;code&gt;.app&lt;/code&gt; file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash &lt;code&gt;-&lt;/code&gt; which is considered to be the app version and it is removed for the lookup purposes:</source>
          <target state="translated">即使目录为空并且没有 &lt;code&gt;.app&lt;/code&gt; 文件，它也被视为基于名称&amp;ldquo; foo / ebin&amp;rdquo;的应用程序目录。名称中可能包含短划线 &lt;code&gt;-&lt;/code&gt; 它被认为是应用程序的版本，出于查找目的将其删除：</target>
        </trans-unit>
        <trans-unit id="c198b47773d307f8ee645f6d155cb12a7d81efef" translate="yes" xml:space="preserve">
          <source>Even though the head of the list is not &lt;code&gt;nil&lt;/code&gt;, the first clause for &lt;code&gt;not_nil_head?/1&lt;/code&gt; fails because the expression does not evaluate to &lt;code&gt;true&lt;/code&gt;, but to &lt;code&gt;&quot;some_value&quot;&lt;/code&gt;, therefore triggering the second clause which returns &lt;code&gt;false&lt;/code&gt;. To make the guard behave correctly, you must ensure that the guard evaluates to &lt;code&gt;true&lt;/code&gt;, like so:</source>
          <target state="translated">即使列表的头部不是 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;not_nil_head?/1&lt;/code&gt; 的第一个子句也会失败，因为表达式的计算结果不是 &lt;code&gt;true&lt;/code&gt; 而是 &lt;code&gt;&quot;some_value&quot;&lt;/code&gt; ，因此触发了第二个返回 &lt;code&gt;false&lt;/code&gt; 的子句。为了使防护措施正常运行，必须确保防护措施评估为 &lt;code&gt;true&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="0521395297ab7a58030d272e2c72be5c8cdef7df" translate="yes" xml:space="preserve">
          <source>Even though the match works, &lt;code&gt;assert&lt;/code&gt; still expects a truth value. In such cases, simply use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;Kernel.==/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">即使匹配成功， &lt;code&gt;assert&lt;/code&gt; 仍然期望真值。在这种情况下，只需使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;Kernel.==/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; 即可&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e115b0b23e56d703ace76f71257a63ef9824a34f" translate="yes" xml:space="preserve">
          <source>Even though the representation changed, the raw data does remain a list of numbers, which can be handled as such:</source>
          <target state="translated">尽管表示方式发生了变化,但原始数据确实仍然是一个数字列表,可以这样处理。</target>
        </trans-unit>
        <trans-unit id="84e3c9de2ccf9da0f358458d3784bc3f849f3c2c" translate="yes" xml:space="preserve">
          <source>Even though we haven't specified &lt;code&gt;--debug&lt;/code&gt; in the list of switches, it is part of the returned options. This would also work:</source>
          <target state="translated">即使我们没有在开关列表中指定 &lt;code&gt;--debug&lt;/code&gt; ，它也是返回的选项的一部分。这也将起作用：</target>
        </trans-unit>
        <trans-unit id="7cb4e4b7449c91102c58fcbb978127750613197b" translate="yes" xml:space="preserve">
          <source>Even with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:</source>
          <target state="translated">即使有这样的保证,开发者在负责任地编写宏时也起着很大的作用。如果你有信心需要借助宏,请记住,宏不是你的API。保持你的宏定义简短,包括其引用的内容。例如,不要写这样的宏。</target>
        </trans-unit>
        <trans-unit id="f153167a1bbb1f584f7f422c6cb126c95946d20e" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="translated">每个describe块都会收到一个名称，该名称将用作即将进行的测试的前缀。在一个块内，可以调用&lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt; &lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt; &lt;/a&gt;，它将定义仅在当前块上运行的安装回调。描述名称也作为标记添加，允许开发人员针对特定块运行测试。</target>
        </trans-unit>
        <trans-unit id="a46c9a7fca545c132d8df109dd8dcaca95a3c354" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="translated">每个describe块都会收到一个名称，该名称将用作即将进行的测试的前缀。在一个块内，可以调用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#setup/1&quot;&gt; &lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt; &lt;/a&gt;，它将定义一个设置回调仅针对当前块运行。描述名称也作为标签添加，允许开发人员针对特定块运行测试。</target>
        </trans-unit>
        <trans-unit id="6ef3d6f408824f6647a6e0d3de1a30549693b5c2" translate="yes" xml:space="preserve">
          <source>Every function clause dispatches the appropriate command to the &lt;code&gt;KV.Registry&lt;/code&gt; server that we registered during the &lt;code&gt;:kv&lt;/code&gt; application startup. Since our &lt;code&gt;:kv_server&lt;/code&gt; depends on the &lt;code&gt;:kv&lt;/code&gt; application, it is completely fine to depend on the services it provides.</source>
          <target state="translated">每个函数子句都会将适当的命令调度到我们在 &lt;code&gt;:kv&lt;/code&gt; 应用程序启动期间注册的 &lt;code&gt;KV.Registry&lt;/code&gt; 服务器。由于我们的 &lt;code&gt;:kv_server&lt;/code&gt; 依赖于 &lt;code&gt;:kv&lt;/code&gt; 应用程序，因此完全可以依赖它提供的服务。</target>
        </trans-unit>
        <trans-unit id="40baf8ceb490ed83843fc93e589192534f9511aa" translate="yes" xml:space="preserve">
          <source>Every new test starts on a new line, with an &lt;code&gt;iex&amp;gt;&lt;/code&gt; prefix. Multiline expressions can be used by prefixing subsequent lines with either &lt;code&gt;...&amp;gt;&lt;/code&gt; (recommended) or &lt;code&gt;iex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">每个新测试 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 前缀从新行开始。多行表达式可以通过在后面的行前面加上 &lt;code&gt;...&amp;gt;&lt;/code&gt; （推荐）或 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 来使用。</target>
        </trans-unit>
        <trans-unit id="76e353e9635feb9762b1896c7c1b95987d4b25d4" translate="yes" xml:space="preserve">
          <source>Every project has a &lt;code&gt;mix.exs&lt;/code&gt; file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a &lt;code&gt;lib&lt;/code&gt; directory, which includes Elixir source code, and a &lt;code&gt;test&lt;/code&gt; directory. A &lt;code&gt;src&lt;/code&gt; directory may also exist for Erlang sources.</source>
          <target state="translated">每个项目都有一个 &lt;code&gt;mix.exs&lt;/code&gt; 文件，其中包含有关如何构建，编译，运行测试等的说明。库通常具有一个 &lt;code&gt;lib&lt;/code&gt; 目录（其中包括Elixir源代码）和一个 &lt;code&gt;test&lt;/code&gt; 目录。一个 &lt;code&gt;src&lt;/code&gt; 目录中也可能存在Erlang的来源。</target>
        </trans-unit>
        <trans-unit id="02a22b2e5fd456a7ae0a76d486db20f724d54096" translate="yes" xml:space="preserve">
          <source>Every release contains an environment file, named &lt;code&gt;env.sh&lt;/code&gt; on Unix-like systems and &lt;code&gt;env.bat&lt;/code&gt; on Windows machines, that executes before the Elixir system starts. In this file, you can execute any OS-level code, such as invoke other applications, set environment variables and so on. Some of those environment variables can even configure how the release itself runs.</source>
          <target state="translated">每个发行版都包含一个环境文件，在类似Unix的系统上名为 &lt;code&gt;env.sh&lt;/code&gt; ，在Windows机器上名为 &lt;code&gt;env.bat&lt;/code&gt; ，该文件在Elixir系统启动之前执行。在此文件中，您可以执行任何操作系统级别的代码，例如调用其他应用程序，设置环境变量等。其中一些环境变量甚至可以配置发行版本身的运行方式。</target>
        </trans-unit>
        <trans-unit id="b3ec0c5ca215e236f63402da7cfee38e03a48ba1" translate="yes" xml:space="preserve">
          <source>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</source>
          <target state="translated">每次打开一个文件,Elixir都会生成一个新的进程。写入文件相当于向写入文件描述符的进程发送消息。</target>
        </trans-unit>
        <trans-unit id="d10c5b0b93979a90184cbb51fe0a0e036d577833" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful as storage during module compilation.</source>
          <target state="translated">每次在函数中读取一个属性时,都会采集其当前值的快照。换句话说,这个值是在编译时而不是在运行时读取的。正如我们将要看到的那样,这也使得属性在模块编译时作为存储空间非常有用。</target>
        </trans-unit>
        <trans-unit id="8195a151075d5ab9fbd9a600b260682c39388d0f" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful to be used as storage during module compilation.</source>
          <target state="translated">每次在函数中读取一个属性时,都会采集其当前值的快照。换句话说,这个值是在编译时而不是在运行时读取的。正如我们将要看到的那样,这也使得属性在模块编译时被用作存储。</target>
        </trans-unit>
        <trans-unit id="78b99dda1ab8cad5aa5dc088e4709cd8ffa9a689" translate="yes" xml:space="preserve">
          <source>Every time we need to look up a bucket, we need to send a message to the registry. In case our registry is being accessed concurrently by multiple processes, the registry may become a bottleneck!</source>
          <target state="translated">每当我们需要查询一个桶的时候,我们需要向注册表发送一条消息。万一我们的注册表被多个进程并发访问,注册表可能会成为一个瓶颈!</target>
        </trans-unit>
        <trans-unit id="62cee6babe5c5a8fa4e03c567fac109731766e5f" translate="yes" xml:space="preserve">
          <source>Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes. In this case, we are using &lt;code&gt;:one_for_one&lt;/code&gt; and the &lt;code&gt;KV.Registry&lt;/code&gt; is started before &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;.</source>
          <target state="translated">每次将新的子代添加到主管中时，重要的是要评估主管策略是否正确以及子进程的顺序。在这种情况下，我们使用 &lt;code&gt;:one_for_one&lt;/code&gt; ，并且 &lt;code&gt;KV.Registry&lt;/code&gt; 在 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 之前启动。</target>
        </trans-unit>
        <trans-unit id="b446cdb18e309af06e8229f9b0fda9244ac6da3e" translate="yes" xml:space="preserve">
          <source>Every time you concatenate binaries or use interpolation (&lt;code&gt;#{}&lt;/code&gt;) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data:</source>
          <target state="translated">每次串联二进制文件或使用插值（ &lt;code&gt;#{}&lt;/code&gt; ）时，您都在复制这些二进制文件。但是，在许多情况下，创建完整的二进制文件时并不需要完整的二进制文件，而只是在最后将其打印出来或发送到某个地方。在这种情况下，可以通过创建IO数据来构造二进制文件：</target>
        </trans-unit>
        <trans-unit id="ed798ff113b14474967cd268a8bbd91a2314f668" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每次执行&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;GenServer.call/3&lt;/code&gt; 时&lt;/a&gt;，客户端都会发送一条消息，该消息必须由GenServer中的&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;回调处理。甲&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;消息必须由处理&lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;时，将实现7种可能的回调。唯一需要的回调是&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="962675beca29d3a850376db901731b3eb3593d3c" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;genserver#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每次执行&lt;a href=&quot;genserver#call/3&quot;&gt; &lt;code&gt;GenServer.call/3&lt;/code&gt; 时&lt;/a&gt;，客户端都会发送一条消息，该消息必须由GenServer中的&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;回调处理。甲&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;消息必须由处理&lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;时，将实现7种可能的回调。唯一需要的回调是&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3205df423b3d81a662d949f234ea958bc947b117" translate="yes" xml:space="preserve">
          <source>Every value in the map is a string, and these are:</source>
          <target state="translated">地图中的每个值都是一个字符串,这些都是。</target>
        </trans-unit>
        <trans-unit id="bd021f13376bc32f27e40804859460a61c19bc80" translate="yes" xml:space="preserve">
          <source>Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.</source>
          <target state="translated">我们传递给代理的函数里面的一切都发生在代理进程中。在这种情况下,由于代理进程是接收和响应我们的消息的,我们说代理进程是服务器。函数之外的一切都发生在客户端。</target>
        </trans-unit>
        <trans-unit id="1cf46969c22298bcd54d98e6e2c526dc85b4471b" translate="yes" xml:space="preserve">
          <source>Everything we have done so far could have been implemented with an &lt;code&gt;Agent&lt;/code&gt;. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.</source>
          <target state="translated">到目前为止，我们所做的一切都可以通过 &lt;code&gt;Agent&lt;/code&gt; 来实现。在本节中，我们将介绍通过GenServer可以实现的许多功能之一，而代理则无法实现。</target>
        </trans-unit>
        <trans-unit id="76820f41cc3743792e89eb2f8f24b62c9538f00b" translate="yes" xml:space="preserve">
          <source>ExUnit</source>
          <target state="translated">ExUnit</target>
        </trans-unit>
        <trans-unit id="5c93a2b236252a89748bc06f469e33d5dc2f6a4b" translate="yes" xml:space="preserve">
          <source>ExUnit automatically creates a temporary directory for tests tagged with &lt;code&gt;:tmp_dir&lt;/code&gt; and puts the path to that directory into the test context. The directory is removed before being created to ensure we start with a blank slate.</source>
          <target state="translated">ExUnit会自动为使用 &lt;code&gt;:tmp_dir&lt;/code&gt; 标记的测试创建一个临时目录，并将该目录的路径放入测试上下文中。在创建目录之前，将其删除，以确保我们以空白开头。</target>
        </trans-unit>
        <trans-unit id="b0bdc79e9fc2af1de5a45467b3f1630138afbfe1" translate="yes" xml:space="preserve">
          <source>ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging.</source>
          <target state="translated">ExUnit可以选择抑制打印测试期间产生的日志信息。运行测试时产生的日志信息会被捕获,只有当测试失败时才会被打印出来以帮助调试。</target>
        </trans-unit>
        <trans-unit id="c48c9be568f6b4c0f2e197839d3d8f36c2515f00" translate="yes" xml:space="preserve">
          <source>ExUnit provides tags and filtering functionality that allow developers to select which tests to run. The most common functionality is to exclude some particular tests from running by default in your test helper file:</source>
          <target state="translated">ExUnit提供了标签和过滤功能,允许开发人员选择要运行的测试。最常见的功能是在你的测试帮助文件中默认排除一些特定的测试运行。</target>
        </trans-unit>
        <trans-unit id="745dfe2a60f037338c2fefadc9162188f364f731" translate="yes" xml:space="preserve">
          <source>ExUnit supports the following options:</source>
          <target state="translated">ExUnit支持以下选项。</target>
        </trans-unit>
        <trans-unit id="2a6345907bef5ae0698454dc9d06ee0ed677f2c2" translate="yes" xml:space="preserve">
          <source>ExUnit.AssertionError</source>
          <target state="translated">ExUnit.AssertionError</target>
        </trans-unit>
        <trans-unit id="7bca0a1e09b5a1e6a12113e9ce6109c131e65f8d" translate="yes" xml:space="preserve">
          <source>ExUnit.AssertionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.AssertionError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f25c6298726d908d1e5e794bcc788478aa5fad10" translate="yes" xml:space="preserve">
          <source>ExUnit.Assertions</source>
          <target state="translated">ExUnit.Assertions</target>
        </trans-unit>
        <trans-unit id="57cef9f68db32989085431b21b29a52b82750643" translate="yes" xml:space="preserve">
          <source>ExUnit.Callbacks</source>
          <target state="translated">ExUnit.Callbacks</target>
        </trans-unit>
        <trans-unit id="b3d66fa6516f4ac426d6095179546b33f36c0614" translate="yes" xml:space="preserve">
          <source>ExUnit.CaptureIO</source>
          <target state="translated">ExUnit.CaptureIO</target>
        </trans-unit>
        <trans-unit id="2ad208584040b9fe065269a5120b26089443ba8f" translate="yes" xml:space="preserve">
          <source>ExUnit.CaptureLog</source>
          <target state="translated">ExUnit.CaptureLog</target>
        </trans-unit>
        <trans-unit id="b2783ae3bb7e24c853deac54a917d583149053c2" translate="yes" xml:space="preserve">
          <source>ExUnit.Case</source>
          <target state="translated">ExUnit.Case</target>
        </trans-unit>
        <trans-unit id="987b4f38599b32760dd676508e3a70f39b41abee" translate="yes" xml:space="preserve">
          <source>ExUnit.CaseTemplate</source>
          <target state="translated">ExUnit.CaseTemplate</target>
        </trans-unit>
        <trans-unit id="53d1f918a06cc534372a86260796a2d4c309360f" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest</source>
          <target state="translated">ExUnit.DocTest</target>
        </trans-unit>
        <trans-unit id="d9999b4f8af1e866e1f0ea61762d5c1cc8ad2341" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest.Error</source>
          <target state="translated">ExUnit.DocTest.Error</target>
        </trans-unit>
        <trans-unit id="67f2a3042727823ccf7dbd9817c09cbbb8efa9a4" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DocTest.Error&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="704ab5cbebf8d2029c97c7f45718c1bb4afd3696" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateDescribeError</source>
          <target state="translated">ExUnit.DuplicateDescribeError</target>
        </trans-unit>
        <trans-unit id="aa1d2c3323c831aec609875e9f0efa265c871e03" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateDescribeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DuplicateDescribeError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1405ead3862a5cfca420a49f538bc241594f997e" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateTestError</source>
          <target state="translated">ExUnit.DuplicateTestError</target>
        </trans-unit>
        <trans-unit id="2a268d99fb56998619707be3b9214a541f86d7ab" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateTestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DuplicateTestError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d7bd9d677f0a9c6dc45310d081af8fcc4ca6e2ec" translate="yes" xml:space="preserve">
          <source>ExUnit.Filters</source>
          <target state="translated">ExUnit.Filters</target>
        </trans-unit>
        <trans-unit id="f8206f0d81a07fa8af2ac0840c2bae2ed2f08165" translate="yes" xml:space="preserve">
          <source>ExUnit.Formatter</source>
          <target state="translated">ExUnit.Formatter</target>
        </trans-unit>
        <trans-unit id="229fc09a3b8e6efa5ac9d2ca8a11a9f502333ec1" translate="yes" xml:space="preserve">
          <source>ExUnit.MultiError</source>
          <target state="translated">ExUnit.MultiError</target>
        </trans-unit>
        <trans-unit id="735227bd3ecbb542e7953b335de901a172e5d02e" translate="yes" xml:space="preserve">
          <source>ExUnit.MultiError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.MultiError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c5c72bd93dc7e3f0a7d2fffbd54cf9bb0f675038" translate="yes" xml:space="preserve">
          <source>ExUnit.Test</source>
          <target state="translated">ExUnit.Test</target>
        </trans-unit>
        <trans-unit id="97bb13a74b9a963a04a1d616ace7b7ad0af2e626" translate="yes" xml:space="preserve">
          <source>ExUnit.TestModule</source>
          <target state="translated">ExUnit.TestModule</target>
        </trans-unit>
        <trans-unit id="f755d37b9e89df3ed4f26779dc2f46df095cbb0b" translate="yes" xml:space="preserve">
          <source>ExUnit.TimeoutError</source>
          <target state="translated">ExUnit.TimeoutError</target>
        </trans-unit>
        <trans-unit id="0eb19ea70731acc4546a8736af6c56cc94e70fc3" translate="yes" xml:space="preserve">
          <source>ExUnit.TimeoutError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.TimeoutError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">产出示例:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d26b3d4470724ac05d7c9da540813fd9a38a03b8" translate="yes" xml:space="preserve">
          <source>Example: aggregating coverage reports from all umbrella children</source>
          <target state="translated">例子:汇总所有伞形儿童的承保报告。</target>
        </trans-unit>
        <trans-unit id="c74c91815529047b04fef7063d238333584897a5" translate="yes" xml:space="preserve">
          <source>Example: aggregating partitioned runs</source>
          <target state="translated">示例:聚合分区运行</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="25122b962e79de0ee8a27ce3b5647bd4c01ca409" translate="yes" xml:space="preserve">
          <source>Examples (in ISO)</source>
          <target state="translated">例子(ISO)</target>
        </trans-unit>
        <trans-unit id="0d3f1fb4ead37a9ebada8ba4792a85c60fc239e8" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_list/1&quot;&gt; &lt;code&gt;Kernel.is_list/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36164a25cdcc73cd1cf8d728f5b2f50878a4ec40" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c5fda773f78bb26a8e1303d5c85d69d871488af" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#map_size/1&quot;&gt; &lt;code&gt;Kernel.map_size/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad9928fd1db4bd5dbdaaf41bf03f0e344ec8d2e7" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实例：&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt; &lt;code&gt;Mix.debug?/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#contains?/2&quot;&gt; &lt;code&gt;String.contains?/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b67cde3e2893f45e1d2342cc89a6c494050168c1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#is_list/1&quot;&gt; &lt;code&gt;Kernel.is_list/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fba0066e54914f2c201f52bafe91a91ee882db71" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59e48be0f15bfe533102ec4eff7ccf70153ea050" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">示例：&lt;a href=&quot;kernel#map_size/1&quot;&gt; &lt;code&gt;Kernel.map_size/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8894d30453776d313609dc175c436a396fe228a1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实例：&lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt; &lt;code&gt;Mix.debug?/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;string#contains?/2&quot;&gt; &lt;code&gt;String.contains?/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80519cae3a2fe4f658e3d881595a3f1c8312fcf3" translate="yes" xml:space="preserve">
          <source>Excellent!</source>
          <target state="translated">Excellent!</target>
        </trans-unit>
        <trans-unit id="60ec7b5f4ed1c9f91fe92c8f85e12cb5b5d0e653" translate="yes" xml:space="preserve">
          <source>Excellent! A release was assembled in &lt;code&gt;_build/prod/rel/foo&lt;/code&gt;. Inside the release, there will be a &lt;code&gt;bin/foo&lt;/code&gt; file which is the entry point to your system. It supports multiple commands, such as:</source>
          <target state="translated">优秀的！在 &lt;code&gt;_build/prod/rel/foo&lt;/code&gt; 中组装了一个发行版。在发行版内部，将有一个 &lt;code&gt;bin/foo&lt;/code&gt; 文件，这是系统的入口点。它支持多个命令，例如：</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="44e97cbdae038c2c5424f2954134819fe68f1b89" translate="yes" xml:space="preserve">
          <source>Exception &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">异常&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="3d517d7c8883cc469bb6f0690fb53e26f6870d0a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="translated">异常是由实现&lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为的模块支持的结构。该&lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为需要中实现两个功能：</target>
        </trans-unit>
        <trans-unit id="8e51b2994e896de8ce300f36d4a22aa73a3be30a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="translated">异常是由实现&lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为的模块支持的结构。该&lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;行为需要中实现两个功能：</target>
        </trans-unit>
        <trans-unit id="f5f7c811b0be5635dd0fe494c23bb6038a54a491" translate="yes" xml:space="preserve">
          <source>Exceptions in the &lt;code&gt;else&lt;/code&gt; block are not caught. If no pattern inside the &lt;code&gt;else&lt;/code&gt; block matches, an exception will be raised; this exception is not caught by the current &lt;code&gt;try/catch/rescue/after&lt;/code&gt; block.</source>
          <target state="translated">不会捕获 &lt;code&gt;else&lt;/code&gt; 块中的异常。如果 &lt;code&gt;else&lt;/code&gt; 块中没有任何模式匹配，则将引发异常；否则，将引发异常。当前的 &lt;code&gt;try/catch/rescue/after&lt;/code&gt; 块未捕获此异常。</target>
        </trans-unit>
        <trans-unit id="ea74b62ed292a57db053839d4dd2cfb1e0f29152" translate="yes" xml:space="preserve">
          <source>Excluded (via :exclude filters)</source>
          <target state="translated">排除(通过:排除过滤器)</target>
        </trans-unit>
        <trans-unit id="3341b34959d98dd397fee5b24380ce422a7f718a" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; as a shell command and invokes the &lt;code&gt;callback&lt;/code&gt; for the streamed response.</source>
          <target state="translated">将给定 &lt;code&gt;command&lt;/code&gt; 作为shell命令执行，并为流式响应调用 &lt;code&gt;callback&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70a317365d7713ea507b0cb5d939c290a69f7da8" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;args&lt;/code&gt; 执行给定 &lt;code&gt;command&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8de8bb94364b91423f5a970361d0ca351b0ec3d4" translate="yes" xml:space="preserve">
          <source>Executes the given command and forwards its messages to the current process.</source>
          <target state="translated">执行给定的命令,并将其信息转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="c1372af04a9efd8163a10572859082b925f8dafa" translate="yes" xml:space="preserve">
          <source>Executes the given command and prints its output to stdout as it comes.</source>
          <target state="translated">执行给定的命令,并将其输出打印到stdout。</target>
        </trans-unit>
        <trans-unit id="a75d5012d51d09974229d69b19fd7d7622bdc109" translate="yes" xml:space="preserve">
          <source>Executes the given command and returns its exit status.</source>
          <target state="translated">执行给定的命令并返回其退出状态。</target>
        </trans-unit>
        <trans-unit id="7c07c6d426de3d265c77a3c160b7a3bafe862b2c" translate="yes" xml:space="preserve">
          <source>Executes the given command quietly without outputting anything.</source>
          <target state="translated">静静地执行指定的命令,不输出任何内容。</target>
        </trans-unit>
        <trans-unit id="4004d7a200a9edc8cf038043abae23d5809c733f" translate="yes" xml:space="preserve">
          <source>Executes the given command.</source>
          <target state="translated">执行给定的命令。</target>
        </trans-unit>
        <trans-unit id="55f164b4c64455051e302faf23d4842520137933" translate="yes" xml:space="preserve">
          <source>Executes the given function for each element.</source>
          <target state="translated">对每个元素执行给定的函数。</target>
        </trans-unit>
        <trans-unit id="b5ce416e76da997843fde479e97ac42967b3d692" translate="yes" xml:space="preserve">
          <source>Executes the tasks separated by comma.</source>
          <target state="translated">执行由逗号分隔的任务。</target>
        </trans-unit>
        <trans-unit id="7ac90140fbd596d3f7878d936c650ac9466a6ee5" translate="yes" xml:space="preserve">
          <source>Exit reasons and restarts</source>
          <target state="translated">退出原因和重新启动</target>
        </trans-unit>
        <trans-unit id="53b33039635fa494645e1b43b50ac67531129d6a" translate="yes" xml:space="preserve">
          <source>Exiting the shell</source>
          <target state="translated">退出外壳</target>
        </trans-unit>
        <trans-unit id="f45e71feb97fe698bfbbe5199dddf26ea61ae573" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, and so forth.</source>
          <target state="translated">以任何其他理由退出都会被认为是不正常的,并被视为崩溃。这意味着默认的主管行为启动,发出错误报告,等等。</target>
        </trans-unit>
        <trans-unit id="31a12820b55617ff15b68585a3da10bfbeb53dca" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</source>
          <target state="translated">以任何其他理由退出都被认为是不正常的,并被视为崩溃。这意味着默认的主管行为会启动,发出错误报告等。</target>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="7977d0a8642620960ce842afec7459a90da93ce6" translate="yes" xml:space="preserve">
          <source>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;:</source>
          <target state="translated">OTP使用退出来确定一个进程是否异常退出。下列退出被认为是 &quot;正常 &quot;的:</target>
        </trans-unit>
        <trans-unit id="d2a34bd07d0e86299a6bc287e4921ca1aef50681" translate="yes" xml:space="preserve">
          <source>Expands the path relative to the path given as the second argument expanding any &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; characters.</source>
          <target state="translated">相对于第二个参数any给出的路径扩展路径 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="56faca74d01072fe618cfc8860e3704b0f548536" translate="yes" xml:space="preserve">
          <source>Expands the struct given by &lt;code&gt;module&lt;/code&gt; in the given &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">扩展给定 &lt;code&gt;env&lt;/code&gt; 中 &lt;code&gt;module&lt;/code&gt; 的结构。</target>
        </trans-unit>
        <trans-unit id="a58d845ac21beded647c9679bfd179b6ae8af84c" translate="yes" xml:space="preserve">
          <source>Expands to something akin to:</source>
          <target state="translated">扩张到类似于的东西。</target>
        </trans-unit>
        <trans-unit id="4ae47f3ad3318c24412abe41c786c7c08970f0f5" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;date&lt;/code&gt; if each entry fits its appropriate range, raises if the date is invalid.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其合适的范围，则返回 &lt;code&gt;date&lt;/code&gt; 如果日期无效，则返回。</target>
        </trans-unit>
        <trans-unit id="13b37db6b572edb898a47a3bd0fb0e8a7a11988b" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;naive_datetime&lt;/code&gt; if each entry fits its appropriate range, raises if time or date is invalid.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当范围，则返回 &lt;code&gt;naive_datetime&lt;/code&gt; ；如果时间或日期无效，则返回。</target>
        </trans-unit>
        <trans-unit id="bcd459526f4b99811c8fbb63304ea87ace873e34" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;time&lt;/code&gt; if each entry fits its appropriate range, raises if the time is invalid.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;time&lt;/code&gt; 如果时间无效，则返回。</target>
        </trans-unit>
        <trans-unit id="91a8dae3c7e0a7461d109ccac314fd3b05583329" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, date}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="36147c4004a324e8f3e4b2ea0f84715a379f133f" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="b1f148de03b18e5985298d31921d5f1111620987" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">期望所有值都是整数。如果每个条目都适合其适当的范围，则返回 &lt;code&gt;{:ok, time}&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="1387b27163a391ef8f7a170807b6e12dfd7c742a" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">需要与&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;相同的命令行选项。</target>
        </trans-unit>
        <trans-unit id="6d58782f27892aec9906a2b37b517051b421e83e" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">需要与&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;相同的命令行选项。</target>
        </trans-unit>
        <trans-unit id="8185e179a98e4c14d7d2dc6601e54859946ed332" translate="yes" xml:space="preserve">
          <source>Explicit derivations can now be called via &lt;code&gt;__deriving__&lt;/code&gt;:</source>
          <target state="translated">现在可以通过 &lt;code&gt;__deriving__&lt;/code&gt; 调用显式派生：</target>
        </trans-unit>
        <trans-unit id="1af430d5daa7566a82be8754e90eab91a53418f6" translate="yes" xml:space="preserve">
          <source>Explicitly convert to string with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;（v1.0）明确转换为字符串</target>
        </trans-unit>
        <trans-unit id="a311e0f546569e17c6cb9a033783cc3c973c3f50" translate="yes" xml:space="preserve">
          <source>Exploring</source>
          <target state="translated">Exploring</target>
        </trans-unit>
        <trans-unit id="17144cbaf80b5556f57bcc08120468f882fb7da0" translate="yes" xml:space="preserve">
          <source>Exports dependencies are compile time dependencies on the module API, namely structs and its public definitions. For example, if you import a module but only use its functions, it is an export dependency. If you use a struct, it is an export dependency too. Export dependencies are only recompiled if the module API changes. Note, however, that compile time dependencies have higher precedence than exports. Therefore if you import a module and use its macros, it is a compile time dependency.</source>
          <target state="translated">Exports依赖是模块API的编译时依赖,即结构体和它的公共定义。例如,如果您导入一个模块,但只使用它的函数,这就是一个导出依赖。如果您使用一个结构体,它也是一个导出依赖。只有当模块的 API 发生变化时,才会重新编译导出依赖关系。但是请注意,编译时的依赖关系比导出时的依赖关系有更高的优先权。因此,如果您导入了一个模块并使用了它的宏,它就是一个编译时依赖。</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd636ca0127e991954457d5520bc826a5790bde1" translate="yes" xml:space="preserve">
          <source>Expressions in IEx</source>
          <target state="translated">IEx中的表达式</target>
        </trans-unit>
        <trans-unit id="ee1891c8d113531de2d0f468e0034dd1a97f49a7" translate="yes" xml:space="preserve">
          <source>Expressions on multiple lines are also supported:</source>
          <target state="translated">也支持多行的表达式。</target>
        </trans-unit>
        <trans-unit id="96e930ee8659a5428bf86a0d55155d9541ab8120" translate="yes" xml:space="preserve">
          <source>Extension point for precompiling dependencies.</source>
          <target state="translated">预编译依赖关系的扩展点。</target>
        </trans-unit>
        <trans-unit id="8fdb5d77c0ea69e962db331c0331d4ccd1f6e481" translate="yes" xml:space="preserve">
          <source>External dependencies</source>
          <target state="translated">外部依赖性</target>
        </trans-unit>
        <trans-unit id="ecfbef1298f91628d1f080163cdf6946c9def817" translate="yes" xml:space="preserve">
          <source>External dependencies are the ones not tied to your business domain. For example, if you need an HTTP API for your distributed KV application, you can use the &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; project as an external dependency.</source>
          <target state="translated">外部依赖关系是与您的业务领域无关的关系。例如，如果您的分布式KV应用程序需要HTTP API，则可以将&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;项目用作外部依赖项。</target>
        </trans-unit>
        <trans-unit id="c150e0ee17017b4793bcf0b0cc69d4046c404195" translate="yes" xml:space="preserve">
          <source>Extract test cases from the documentation.</source>
          <target state="translated">从文档中提取测试用例。</target>
        </trans-unit>
        <trans-unit id="95e8ae6e88b22e27a03f7d64d058e8d835494561" translate="yes" xml:space="preserve">
          <source>Extracts all protocols from the given paths.</source>
          <target state="translated">从给定路径中提取所有协议。</target>
        </trans-unit>
        <trans-unit id="6672f515f4795b7a00946cd73a72fe3b0d731698" translate="yes" xml:space="preserve">
          <source>Extracts all records information from an Erlang file.</source>
          <target state="translated">从Erlang文件中提取所有记录信息。</target>
        </trans-unit>
        <trans-unit id="0aa4ae6318b818f36730be7bf017b931ef4ea73b" translate="yes" xml:space="preserve">
          <source>Extracts all types implemented for the given protocol from the given paths.</source>
          <target state="translated">从给定的路径中提取所有给定协议的实现类型。</target>
        </trans-unit>
        <trans-unit id="fe0c75ba33dd78a4066417d5f149fc1b26fb8202" translate="yes" xml:space="preserve">
          <source>Extracts record information from an Erlang file.</source>
          <target state="translated">从Erlang文件中提取记录信息。</target>
        </trans-unit>
        <trans-unit id="574d59827e0eb28bc33410c7d28d8d1801cae6ee" translate="yes" xml:space="preserve">
          <source>Extracts the part of the binary starting at &lt;code&gt;start&lt;/code&gt; with length &lt;code&gt;length&lt;/code&gt;. Binaries are zero-indexed.</source>
          <target state="translated">从长度 &lt;code&gt;length&lt;/code&gt; 处 &lt;code&gt;start&lt;/code&gt; 提取二进制的部分。二进制文件是零索引的。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="09fef5d8d9a3c86b2523fef60d512606e7fe0003" translate="yes" xml:space="preserve">
          <source>Failed</source>
          <target state="translated">Failed</target>
        </trans-unit>
        <trans-unit id="96fff357d65451f89027b22467cd65b418ae720a" translate="yes" xml:space="preserve">
          <source>Failing guards</source>
          <target state="translated">失败的警卫</target>
        </trans-unit>
        <trans-unit id="1652d7e1326512444d5398f784563f91db27adf9" translate="yes" xml:space="preserve">
          <source>Failing to specify the size for the non-last causes compilation to fail:</source>
          <target state="translated">未指定非最后的大小会导致编译失败。</target>
        </trans-unit>
        <trans-unit id="a8f785f9330c1e75e28a2a7140d3aec99d182b95" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="translated">如果名称未注册到任何PID或端口，则失败，出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ccdf9c4d16331f9f9a7885177207e85c8dc38a3" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="translated">如果名称未注册到任何PID或端口，则失败，出现&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6d0b09e283994372eb19fd9e9acdd66b7d8a5ff" translate="yes" xml:space="preserve">
          <source>Fails with a message.</source>
          <target state="translated">失败的消息。</target>
        </trans-unit>
        <trans-unit id="d98c0b711b96d90c648aa1ba79214b16cf3c847f" translate="yes" xml:space="preserve">
          <source>Faint (decreased intensity). Not widely supported.</source>
          <target state="translated">微弱(强度降低)。未得到广泛支持。</target>
        </trans-unit>
        <trans-unit id="80eafe8c844b802892eae9dec9a932d3aae704a2" translate="yes" xml:space="preserve">
          <source>Fallback to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">后退到 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e83224357f427a57043b90f12511c5e7c2761fe6" translate="yes" xml:space="preserve">
          <source>Falsy values (of which there are exactly two):</source>
          <target state="translated">虚值(其中正好有两个)。</target>
        </trans-unit>
        <trans-unit id="84961cf65129825950c4fb505dbebfa0af3c33d5" translate="yes" xml:space="preserve">
          <source>Feel free to go ahead and do the changes above and write some unit tests. The idea is that your tests will start an instance of the &lt;code&gt;KV.Registry&lt;/code&gt; and pass it as an argument to &lt;code&gt;run/2&lt;/code&gt; instead of relying on the global &lt;code&gt;KV.Registry&lt;/code&gt;. This has the advantage of keeping our tests asynchronous as there is no shared state.</source>
          <target state="translated">请继续进行上述更改并编写一些单元测试。这个想法是，您的测试将启动 &lt;code&gt;KV.Registry&lt;/code&gt; 的实例并将其作为参数传递给 &lt;code&gt;run/2&lt;/code&gt; ,而不是依赖于全局 &lt;code&gt;KV.Registry&lt;/code&gt; 。由于没有共享状态，因此具有使测试保持异步的优势。</target>
        </trans-unit>
        <trans-unit id="4e9eab4f18f16e5a9faaa07931254d91146148ac" translate="yes" xml:space="preserve">
          <source>Fetches a copy of &lt;code&gt;rebar&lt;/code&gt; or &lt;code&gt;rebar3&lt;/code&gt; from the given path or URL.</source>
          <target state="translated">获取副本 &lt;code&gt;rebar&lt;/code&gt; 或 &lt;code&gt;rebar3&lt;/code&gt; 从给定的路径或URL。</target>
        </trans-unit>
        <trans-unit id="6ce2d20bef71f0063b999c8745340e3f56b5a4aa" translate="yes" xml:space="preserve">
          <source>Fetches the test supervisor for the current test.</source>
          <target state="translated">获取当前测试的测试主管。</target>
        </trans-unit>
        <trans-unit id="c0e97bf839fe5fe85207b4a9d492c885c7fec652" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; and returns it in a tuple.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值，并将其返回到元组。</target>
        </trans-unit>
        <trans-unit id="e51d5ee9800fb6a00e8f93feaec0009d2b77b447" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;, erroring out if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取给定 &lt;code&gt;map&lt;/code&gt; 特定 &lt;code&gt;key&lt;/code&gt; 的值，如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则会出错。</target>
        </trans-unit>
        <trans-unit id="a43e0afb7d744e48d3c341e4b08f1f780c55b575" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">获取给定 &lt;code&gt;map&lt;/code&gt; 特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e32be0757ce9c975d2425bacc76ae29c90d94cf3" translate="yes" xml:space="preserve">
          <source>Fetches the value for specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f5f8f513b41db299570bc23df8a5cd56d7a7348b" translate="yes" xml:space="preserve">
          <source>Fetches the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取容器中给定键的值（实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="31798ce3f2f936a238f0a2c5ab7cdb503c7ea839" translate="yes" xml:space="preserve">
          <source>File permissions are specified by adding together the following octal modes:</source>
          <target state="translated">文件权限通过将以下八进制模式相加来指定。</target>
        </trans-unit>
        <trans-unit id="e9762f0351951cf7ed47c0893d9de2c36796a05d" translate="yes" xml:space="preserve">
          <source>File.CopyError</source>
          <target state="translated">File.CopyError</target>
        </trans-unit>
        <trans-unit id="7b57f930765dd268a9cde88eaefc8e395b0beb29" translate="yes" xml:space="preserve">
          <source>File.CopyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.CopyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="27e1fc83e1258e80dfd4127d0a4ce93324162992" translate="yes" xml:space="preserve">
          <source>File.Error</source>
          <target state="translated">File.Error</target>
        </trans-unit>
        <trans-unit id="8354290eb6b6ea2cbcbaa3bd4c48c21f5649591a" translate="yes" xml:space="preserve">
          <source>File.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.Error &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5561cc6859be7830bb0219495771f2109757df2e" translate="yes" xml:space="preserve">
          <source>File.LinkError</source>
          <target state="translated">File.LinkError</target>
        </trans-unit>
        <trans-unit id="ff963e9e333fceee8593af446c12736218860d8a" translate="yes" xml:space="preserve">
          <source>File.LinkError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.LinkError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="34595af71c483f8de72a2abf0c30fcef3475a04a" translate="yes" xml:space="preserve">
          <source>File.RenameError</source>
          <target state="translated">File.RenameError</target>
        </trans-unit>
        <trans-unit id="918afebd70d1938336f0bcc22b61603501a5ef93" translate="yes" xml:space="preserve">
          <source>File.RenameError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.RenameError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="26a6590f983813e802ea4c694400ea32fe379883" translate="yes" xml:space="preserve">
          <source>File.Stat</source>
          <target state="translated">File.Stat</target>
        </trans-unit>
        <trans-unit id="665c1dadb9609c9481c5f8ebc57dca4f06031e23" translate="yes" xml:space="preserve">
          <source>File.Stream</source>
          <target state="translated">File.Stream</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="e4b01a2510691aed09a9f3e1dbbc4fcd455e3aee" translate="yes" xml:space="preserve">
          <source>Filters can also be given:</source>
          <target state="translated">也可以给过滤器。</target>
        </trans-unit>
        <trans-unit id="2503811e18a88c94424e3c46d73925ff58ba8899" translate="yes" xml:space="preserve">
          <source>Filters can either be a regular expression or any data structure that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol, which is invoked before comparing the filter with the &lt;code&gt;:tag&lt;/code&gt; value.</source>
          <target state="translated">过滤器可以是正则表达式，也可以是实现&lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议的任何数据结构，在将过滤器与 &lt;code&gt;:tag&lt;/code&gt; 值进行比较之前会调用该协议。</target>
        </trans-unit>
        <trans-unit id="8e53af0e96b0cc30e1acdc06f0e1e173375388aa" translate="yes" xml:space="preserve">
          <source>Filters the &lt;code&gt;enumerable&lt;/code&gt;, i.e. returns only those elements for which &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">过滤 &lt;code&gt;enumerable&lt;/code&gt; ，即仅返回 &lt;code&gt;fun&lt;/code&gt; 返回其真实值的那些元素。</target>
        </trans-unit>
        <trans-unit id="38e91ba97986e6ce700c58bdd7ad300d67734ab8" translate="yes" xml:space="preserve">
          <source>Final note</source>
          <target state="translated">最后说明</target>
        </trans-unit>
        <trans-unit id="35edd1c925c63232dc7f42b120954fad87230406" translate="yes" xml:space="preserve">
          <source>Finally note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it may be removed after consolidation.</source>
          <target state="translated">最后注意，所有协议都编译 &lt;code&gt;debug_info&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 的，不管选项集 &lt;code&gt;elixirc&lt;/code&gt; 编译器。调试信息用于合并，合并后可以将其删除。</target>
        </trans-unit>
        <trans-unit id="04fdf1c25fdd5f8a57c6967c66cfb3a7de5f847e" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;setup_all&lt;/code&gt; callbacks run in a separate process per module, while all &lt;code&gt;setup&lt;/code&gt; callbacks run in the same process as the test itself. &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt; callbacks always run in a separate process, as implied by their name. The test process always exits with reason &lt;code&gt;:shutdown&lt;/code&gt;, which means any process linked to the test process will also exit, although asynchronously. Therefore it is preferred to use &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; to guarantee synchronous termination.</source>
          <target state="translated">最后， &lt;code&gt;setup_all&lt;/code&gt; 回调在每个模块的单独进程中运行，而所有 &lt;code&gt;setup&lt;/code&gt; 回调在与测试本身相同的进程中运行。&lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt;回调始终如其名称所暗示的那样在单独的进程中运行。测试过程总是以 &lt;code&gt;:shutdown&lt;/code&gt; 原因退出，这意味着链接到测试过程的任何进程也将退出，尽管是异步的。因此，最好使用&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt;来保证同步终止。</target>
        </trans-unit>
        <trans-unit id="4a48b23e11b49db2f57e13074e7a2452579f61b9" translate="yes" xml:space="preserve">
          <source>Finally, Elixir has a construct called aliases which we will explore later. Aliases start in upper case and are also atoms:</source>
          <target state="translated">最后,Elixir有一个叫做别名的构造,我们将在后面探讨。别名以大写字母开头,也是原子。</target>
        </trans-unit>
        <trans-unit id="f1f7036035e55443b9fb00eab5b0f156761b7796" translate="yes" xml:space="preserve">
          <source>Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix help archive.build&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix help escript.build&lt;/code&gt;&lt;/a&gt; for more detail.</source>
          <target state="translated">最后，Elixir提供了诸如脚本和存档之类的工具，它们是打包应用程序的不同机制。通常在必须在开发人员之间共享工具而不是将其作为部署选项时使用。有关更多详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix help archive.build&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix help escript.build&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51f5f67bdc287fa28acb4c9223c262389c58e3ea" translate="yes" xml:space="preserve">
          <source>Finally, aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;mix.tasks.clean&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="translated">最后，别名也可以用于扩充现有任务。假设您想增加&lt;a href=&quot;mix.tasks.clean&quot;&gt; &lt;code&gt;mix clean&lt;/code&gt; &lt;/a&gt;来清理Mix不知道的另一个目录：</target>
        </trans-unit>
        <trans-unit id="191e1198a5b11d86c8e069a1379cf393ac7fbbc2" translate="yes" xml:space="preserve">
          <source>Finally, anonymous functions are also closures and as such they can access variables that are in scope when the function is defined. Let&amp;rsquo;s define a new anonymous function that uses the &lt;code&gt;add&lt;/code&gt; anonymous function we have previously defined:</source>
          <target state="translated">最后，匿名函数也是闭包，因此，它们可以访问定义函数时范围内的变量。让我们定义一个新的匿名函数，该函数使用我们先前定义的 &lt;code&gt;add&lt;/code&gt; 匿名函数：</target>
        </trans-unit>
        <trans-unit id="1877a861abfea57d3175dd4ec2545e64bd06b283" translate="yes" xml:space="preserve">
          <source>Finally, as discussed in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; documentation, remember that the initial context metadata can also be set via &lt;code&gt;@tag&lt;/code&gt;s, which can then be accessed in the &lt;code&gt;setup&lt;/code&gt; block:</source>
          <target state="translated">最后，如&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;文档中所述，请记住，初始上下文元数据也可以通过 &lt;code&gt;@tag&lt;/code&gt; 设置，然后可以在 &lt;code&gt;setup&lt;/code&gt; 块中对其进行访问：</target>
        </trans-unit>
        <trans-unit id="4f8f9ee80a4128eebbd8b8d0785f0bf4b51354e3" translate="yes" xml:space="preserve">
          <source>Finally, attributes can also be read inside functions:</source>
          <target state="translated">最后,属性也可以在函数里面读取。</target>
        </trans-unit>
        <trans-unit id="668fb656f73feadaab2b70bd66310c5a6a4ae07c" translate="yes" xml:space="preserve">
          <source>Finally, beware of redundant code comments, such as the ones describing the exact same that the code does:</source>
          <target state="translated">最后,要小心多余的代码注释,比如描述与代码完全相同的代码。</target>
        </trans-unit>
        <trans-unit id="7b06c2901c51b502cac134085935b1c4ea9f9da4" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="translated">最后，检查&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;以了解其他受支持的操作。</target>
        </trans-unit>
        <trans-unit id="1083a91a64ef83410037ffb35fd49e9fb40c270f" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="translated">最后，检查&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;以了解其他受支持的操作。</target>
        </trans-unit>
        <trans-unit id="f726a5d73225d60359e8c4f7a62c08247c5e3152" translate="yes" xml:space="preserve">
          <source>Finally, copy the &lt;code&gt;kv&lt;/code&gt; application we have built so far to the &lt;code&gt;apps&lt;/code&gt; directory in our new umbrella project. The final directory structure should match the structure we mentioned earlier:</source>
          <target state="translated">最后，将到目前为止已构建的 &lt;code&gt;kv&lt;/code&gt; 应用程序复制到新的伞项目中的 &lt;code&gt;apps&lt;/code&gt; 目录中。最终目录结构应与我们前面提到的结构匹配：</target>
        </trans-unit>
        <trans-unit id="fab90ae3564b828d174f4a1339c23b2f23ef10c1" translate="yes" xml:space="preserve">
          <source>Finally, developers should also avoid defining functions inside the &lt;code&gt;__using__/1&lt;/code&gt; callback, unless those functions are the default implementation of a previously defined &lt;code&gt;@callback&lt;/code&gt; or are functions meant to be overridden (see &lt;a href=&quot;#defoverridable/1&quot;&gt;&lt;code&gt;defoverridable/1&lt;/code&gt;&lt;/a&gt;). Even in these cases, defining functions should be seen as a &quot;last resort&quot;.</source>
          <target state="translated">最后，开发人员还应避免在 &lt;code&gt;__using__/1&lt;/code&gt; 回调中定义函数，除非这些函数是先前定义的 &lt;code&gt;@callback&lt;/code&gt; 的默认实现或要重写的函数（请参阅&lt;a href=&quot;#defoverridable/1&quot;&gt; &lt;code&gt;defoverridable/1&lt;/code&gt; &lt;/a&gt;）。即使在这些情况下，定义功能也应被视为&amp;ldquo;万不得已&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a5904f73dbbcd0930c32f8ef2421f6ebf86cef4" translate="yes" xml:space="preserve">
          <source>Finally, different from the other callbacks, we have defined a &amp;ldquo;catch-all&amp;rdquo; clause for &lt;code&gt;handle_info/2&lt;/code&gt; that discards any unknown message. To understand why, let&amp;rsquo;s move on to the next section.</source>
          <target state="translated">最后，与其他回调不同，我们为 &lt;code&gt;handle_info/2&lt;/code&gt; 定义了一个&amp;ldquo; catch-all&amp;rdquo;子句，该子句会丢弃所有未知消息。要了解原因，让我们继续下一节。</target>
        </trans-unit>
        <trans-unit id="2dca70c0e3d6a9acaabab7bc96177fe2d9c44844" translate="yes" xml:space="preserve">
          <source>Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">最后,不要在Unicode模式的IO设备上使用这个函数,因为它会返回错误的结果。</target>
        </trans-unit>
        <trans-unit id="5d1ed29b60633fb5430adba7b8757ea6539225e2" translate="yes" xml:space="preserve">
          <source>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</source>
          <target state="translated">最后,如果你不想在空枚举时加注,你可以通过空回退。</target>
        </trans-unit>
        <trans-unit id="8e8ca83f100555992c56e00e0551b89ee834e2cb" translate="yes" xml:space="preserve">
          <source>Finally, in order for runtime configuration to work properly (as well as any other &quot;Config provider&quot; as defined next), it needs to be able to persist the newly computed configuration to disk. The computed config file will be written to &quot;tmp&quot; directory inside the release every time the system boots. You can configure the &quot;tmp&quot; directory by setting the &lt;code&gt;RELEASE_TMP&lt;/code&gt; environment variable, either explicitly or inside your &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (or &lt;code&gt;env.bat&lt;/code&gt; on Windows).</source>
          <target state="translated">最后，为了使运行时配置正常工作（以及接下来定义的任何其他&amp;ldquo; Config provider&amp;rdquo;），它必须能够将新计算的配置持久保存到磁盘。每次系统引导时，计算出的配置文件将被写入发行版中的&amp;ldquo; tmp&amp;rdquo;目录。您可以通过显式或在 &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; （或Windows中的 &lt;code&gt;env.bat&lt;/code&gt; ）内部设置 &lt;code&gt;RELEASE_TMP&lt;/code&gt; 环境变量来配置&amp;ldquo; tmp&amp;rdquo;目录。</target>
        </trans-unit>
        <trans-unit id="b0a0fcc78d43cdb2d5efe08a2aa140520d91d3bf" translate="yes" xml:space="preserve">
          <source>Finally, it also documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="translated">最后，它还记录了两种特殊形式&lt;a href=&quot;#__block__/1&quot;&gt; &lt;code&gt;__block__/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt;，它们不希望开发人员直接调用，但它们出现在引用的内容中，因为它们在Elixir的构造中必不可少。</target>
        </trans-unit>
        <trans-unit id="f74f8991d0d3c9a479fe59d35b99b4abf4e6cf52" translate="yes" xml:space="preserve">
          <source>Finally, it's advised to profile your program with the &lt;code&gt;prod&lt;/code&gt; environment, since this should provide more realistic insights into bottlenecks.</source>
          <target state="translated">最后，建议您在 &lt;code&gt;prod&lt;/code&gt; 环境中分析您的程序，因为这样可以对瓶颈提供更实际的见解。</target>
        </trans-unit>
        <trans-unit id="e7d511ddfbac4fd8a034329e957061520ac4e991" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind it is not required for you to assemble the release from the umbrella root. You can also assemble the release from each child application individually. Doing it from the root, however, allows you to include two applications that do not depend on each other as part of the same release.</source>
          <target state="translated">最后,请记住,这并不是要求你从伞形根组装发布。你也可以从每个子应用程序中单独组装发布。然而,从根部进行组装,可以让您将两个互不依赖的应用程序作为同一版本的一部分。</target>
        </trans-unit>
        <trans-unit id="04258f441df3a0685acf7dc84f54350179d26c35" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that applications in an umbrella project all share the same configurations and dependencies. If two applications in your umbrella need to configure the same dependency in drastically different ways or even use different versions, you have probably outgrown the benefits brought by umbrellas. Remember you can break the umbrella and still leverage the benefits behind &amp;ldquo;mono-repos&amp;rdquo;.</source>
          <target state="translated">最后，请记住，伞项目中的应用程序都共享相同的配置和依赖项。如果您的保护伞中的两个应用程序需要以完全不同的方式甚至使用不同的版本来配置相同的依赖项，那么您可能已经超出了保护伞所带来的好处。请记住，您可以打起伞，仍然可以利用&amp;ldquo;单一回购协议&amp;rdquo;背后的好处。</target>
        </trans-unit>
        <trans-unit id="b17d2e9b41800db01905629d7c64202ebf54e9fc" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="translated">最后,请记住,在理解体内部的变量赋值,无论是在生成器、过滤器还是在块内部,都不会反映在理解体外部。</target>
        </trans-unit>
        <trans-unit id="7b0dc026cfea9e2e7b1becee88cabf1eed936967" translate="yes" xml:space="preserve">
          <source>Finally, note &lt;code&gt;cond&lt;/code&gt; considers any value besides &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to be true:</source>
          <target state="translated">最后，注意 &lt;code&gt;cond&lt;/code&gt; 认为除 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 之外的任何值都为true：</target>
        </trans-unit>
        <trans-unit id="1e8a25344ef8715d7cecfc3690b780ce1c60f07c" translate="yes" xml:space="preserve">
          <source>Finally, note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by the &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it is removed after consolidation unless globally set.</source>
          <target state="translated">最后，请注意所有协议编译 &lt;code&gt;debug_info&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 由，而不管选项集 &lt;code&gt;elixirc&lt;/code&gt; 编译器。调试信息用于合并，除非全局设置，否则合并后将删除该信息。</target>
        </trans-unit>
        <trans-unit id="7a86bfddfc1fd1f3cd3bcab92a5988d59aa4d019" translate="yes" xml:space="preserve">
          <source>Finally, note it is also possible to simply pass the &lt;code&gt;Stack&lt;/code&gt; module as a child:</source>
          <target state="translated">最后，请注意，也可以简单地将 &lt;code&gt;Stack&lt;/code&gt; 模块作为子代传递：</target>
        </trans-unit>
        <trans-unit id="b5e8ec2ca3602b6bc2810511f915ff11214b601b" translate="yes" xml:space="preserve">
          <source>Finally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator.</source>
          <target state="translated">最后,请注意模式中的映射键必须始终是与pin操作符相匹配的字元或先前绑定的变量。</target>
        </trans-unit>
        <trans-unit id="ddefd09be238de8fef0e43712279c903c785e333" translate="yes" xml:space="preserve">
          <source>Finally, note strings themselves are valid algebra documents that keep their formatting when pretty printed. This means your &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; implementation may simply return a string, although that will devoid it of any pretty-printing.</source>
          <target state="translated">最后，音符字符串本身是有效的代数文档，当漂亮地打印时便保持其格式。这意味着您的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;实现可能只返回一个字符串，尽管这样可以避免出现任何漂亮的字样。</target>
        </trans-unit>
        <trans-unit id="7e168ab8bcfeb48be21d768c678e77ae94e3845d" translate="yes" xml:space="preserve">
          <source>Finally, note that attributes can also be read inside functions:</source>
          <target state="translated">最后,请注意,属性也可以在函数内部读取。</target>
        </trans-unit>
        <trans-unit id="525d826b02e67b29a0d7a1fb2bd96144f8ca9ed8" translate="yes" xml:space="preserve">
          <source>Finally, note the coverage itself is not measured across the projects themselves. For example, if project B depends on A, and if there is code in A that is only executed from project B, those lines will not be marked as covered, which is important, as those projects should be developed and tested in isolation.</source>
          <target state="translated">最后,注意覆盖范围本身并不是以项目本身为单位来衡量的。例如,如果项目B依赖于A,如果A中的代码只从项目B中执行,那么这些行将不会被标记为覆盖,这一点很重要,因为这些项目应该是单独开发和测试的。</target>
        </trans-unit>
        <trans-unit id="d4f7dd24a40c84b2db68e974eaff07a24dba709d" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="translated">最后，请注意&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数很急切：它们将在调用后立即遍历可枚举。当使用无穷枚举时，这特别危险。在这种情况下，应使用&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块，该模块允许您懒散地表示计算，而无需遍历集合，并可以处理无限个集合。有关示例和文档，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="60bc3c90be2296af6dc74f8ac6ed31dee639afd7" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="translated">最后，请注意&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数急切：它们将在被调用后立即遍历可枚举。当使用无穷枚举时，这特别危险。在这种情况下，应使用&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块，该模块允许您懒散地表示计算而无需遍历集合，并可以处理无限个集合。有关示例和文档，请参见&lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="12f0160206d216529166c8634dc691e626760b5b" translate="yes" xml:space="preserve">
          <source>Finally, notice that attributes can also be read inside functions:</source>
          <target state="translated">最后,请注意,属性也可以在函数里面读取。</target>
        </trans-unit>
        <trans-unit id="989e69e0609a31b9b4fe9f32b562a703b9696c7b" translate="yes" xml:space="preserve">
          <source>Finally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">最后，请记住Elixir中的字符串是UTF-8编码的二进制文件。这意味着，与字符列表类似，二进制连接运算符（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/a&gt;）也可以对字符串进行前缀匹配：</target>
        </trans-unit>
        <trans-unit id="232829bb783ca862d2a7fbdd06c1982a8e6d4a55" translate="yes" xml:space="preserve">
          <source>Finally, remember you can also get a mini-overview of the runtime info by calling &lt;code&gt;runtime_info/0&lt;/code&gt; directly in IEx.</source>
          <target state="translated">最后，请记住，您还可以通过直接在IEx中调用 &lt;code&gt;runtime_info/0&lt;/code&gt; 来获得运行时信息的小型概述。</target>
        </trans-unit>
        <trans-unit id="3d4e093b24b7868fdbb88889dcf9d11e7ebbe5c8" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; will import other config files, based on the current Mix environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">最后，行 &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; 将基于当前Mix环境导入其他配置文件，例如 &lt;code&gt;config/dev.exs&lt;/code&gt; 和 &lt;code&gt;config/test.exs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6807f6f10cbe61d66aff585c4548460bfb9b94d" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{config_env()}.exs&quot;&lt;/code&gt; will import other config files based on the current configuration environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">最后，行 &lt;code&gt;import_config &quot;#{config_env()}.exs&quot;&lt;/code&gt; 将基于当前配置环境导入其他配置文件，例如 &lt;code&gt;config/dev.exs&lt;/code&gt; 和 &lt;code&gt;config/test.exs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="321ba25e566c212d784496c47ffc76a0ad896628" translate="yes" xml:space="preserve">
          <source>Finally, the stacktrace relates to the failure itself, giving information about the test and often the place the failure was generated from within the source files.</source>
          <target state="translated">最后,stacktrace与失败本身有关,给出了有关测试的信息,而且往往是失败从源文件中产生的地方。</target>
        </trans-unit>
        <trans-unit id="924ac30e08d7b545eac852afc656f22c82661634" translate="yes" xml:space="preserve">
          <source>Finally, these operators appear in the precedence table above but are only meaningful within certain constructs:</source>
          <target state="translated">最后,这些运算符出现在上面的优先表中,但只在某些构造中才有意义。</target>
        </trans-unit>
        <trans-unit id="3f56c580dd08d36a6b47e54333acfe9e1d8d30e4" translate="yes" xml:space="preserve">
          <source>Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as &lt;a href=&quot;#to_doc/2&quot;&gt;&lt;code&gt;to_doc/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最后，该模块还包含与Elixir相关的功能，与Elixir格式有点联系，例如&lt;a href=&quot;#to_doc/2&quot;&gt; &lt;code&gt;to_doc/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9005decc18b830a894ffeaad85db25d6cd8463cf" translate="yes" xml:space="preserve">
          <source>Finally, to convert a String into a list of integer code points, known as &quot;charlists&quot; in Elixir, you can call &lt;code&gt;String.to_charlist&lt;/code&gt;:</source>
          <target state="translated">最后，要将String转换为整数代码点列表（在Elixir中称为&amp;ldquo;字符列表&amp;rdquo;），可以调用 &lt;code&gt;String.to_charlist&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="29c7d0203ff19b759dff9a8dcf709329c059ef93" translate="yes" xml:space="preserve">
          <source>Finally, you may have observed that each doctest corresponds to a different test in our suite, which now reports a total of 7 doctests. That is because ExUnit considers the following to define two different doctests:</source>
          <target state="translated">最后,你可能已经观察到,在我们的套件中,每个doctest对应一个不同的测试,现在总共报告了7个doctests。这是因为ExUnit认为下面定义了两个不同的doctests。</target>
        </trans-unit>
        <trans-unit id="82318fe7e7a021f4fa35e9409276a28582c98da1" translate="yes" xml:space="preserve">
          <source>Find more about the pipe operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;by reading its documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;通过阅读其文档，&lt;/a&gt;找到有关管道操作员的更多信息。</target>
        </trans-unit>
        <trans-unit id="d473a61a8edc12c54afe46832414dc97879d0388" translate="yes" xml:space="preserve">
          <source>Finds a template path for the release.</source>
          <target state="translated">为发布找到一个模板路径。</target>
        </trans-unit>
        <trans-unit id="e44a6c20b46b4eb7ebeba1748cd0e7795b1fd20f" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;{pid, value}&lt;/code&gt; pair for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; in no particular order.</source>
          <target state="translated">发现 &lt;code&gt;{pid, value}&lt;/code&gt; 对，用于给定的 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;registry&lt;/code&gt; 中没有特定的顺序。</target>
        </trans-unit>
        <trans-unit id="d980122971e9d4fe80a33e7b799338a83929abd3" translate="yes" xml:space="preserve">
          <source>Finds the element at the given &lt;code&gt;index&lt;/code&gt; (zero-based).</source>
          <target state="translated">查找给定 &lt;code&gt;index&lt;/code&gt; 处的元素（从零开始）。</target>
        </trans-unit>
        <trans-unit id="fdbbbf2a367be4fcd9eca718811c5a61aea8c66b" translate="yes" xml:space="preserve">
          <source>First of all, since we generated this project inside &lt;code&gt;kv_umbrella/apps&lt;/code&gt;, Mix automatically detected the umbrella structure and added four lines to the project definition:</source>
          <target state="translated">首先，由于我们在 &lt;code&gt;kv_umbrella/apps&lt;/code&gt; 内部生成了此项目，因此Mix自动检测到了伞形结构，并在项目定义中添加了四行：</target>
        </trans-unit>
        <trans-unit id="21e0a6d768daca714108b3a36ec6e2151c3c1139" translate="yes" xml:space="preserve">
          <source>First this task guarantees that all dependencies are in place and that the current project has been compiled. Then the current application is started as a temporary application, unless &lt;code&gt;:start_permanent&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; in your project configuration or the &lt;code&gt;--permanent&lt;/code&gt; option is given, then it's started as permanent, which guarantees the node will shut down if the application crashes permanently.</source>
          <target state="translated">首先，此任务确保所有依赖项均已就位，并且当前项目已编译。然后，除非您在项目配置 &lt;code&gt;:start_permanent&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或指定了 &lt;code&gt;--permanent&lt;/code&gt; 选项，否则将当前应用程序作为临时应用程序启动，然后将其作为永久启动，这可以确保如果应用程序永久崩溃，该节点将关闭。</target>
        </trans-unit>
        <trans-unit id="0b225f4fd1da05fdbc3ee99a9f166606b1d95c47" translate="yes" xml:space="preserve">
          <source>First, if the routing tables are the opposite of each other, such as &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; in one node and &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; in the other, you can have a routing request that will run recursively in the cluster infinitely. This can be tackled at the application level by making sure you pass a list of seen nodes when we route, such as &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt;. Then by checking if the node being dispatched to was already visited, we can avoid the cycle. Implementing and testing this functionality will be left as an exercise.</source>
          <target state="translated">首先，如果路由表彼此相反，例如 &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; 在一个节点和 &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; 在另一方面，可以有一个路由请求，该请求将在群集中无限递归地运行。这可以在应用程序级别通过确保您在路由时传递可见节点列表来解决，例如 &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt; 。然后通过检查被调度到的节点是否已经被访问，我们可以避免周期。实施和测试此功能将作为练习。</target>
        </trans-unit>
        <trans-unit id="fe6a7fa579eecc0b0104d2aa94bc63bd9d9aa9d6" translate="yes" xml:space="preserve">
          <source>First, the &lt;code&gt;request&lt;/code&gt; is sent to every node in &lt;code&gt;nodes&lt;/code&gt;; then, the caller waits for the replies. This function returns a two-element tuple &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; where:</source>
          <target state="translated">首先， &lt;code&gt;request&lt;/code&gt; 被发送到节点中的每个 &lt;code&gt;nodes&lt;/code&gt; ；然后，呼叫者等待答复。此函数返回一个由两个元素组成的元组 &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="60398b803dd263be0dc63a6c96308aea282994d5" translate="yes" xml:space="preserve">
          <source>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. Optional behaviour, such as &lt;code&gt;:rename_deprecated_at&lt;/code&gt;, is allowed to break this guarantee.</source>
          <target state="translated">首先，格式化程序默认情况下不会更改代码的语义。这意味着输入AST和输出AST是等效的。允许使用可选行为，例如 &lt;code&gt;:rename_deprecated_at&lt;/code&gt; 来打破此保证。</target>
        </trans-unit>
        <trans-unit id="761d6955efc7722bb7c5e17c7ad9ae6eee0e3a82" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists.</source>
          <target state="translated">展平嵌套列表的给定 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="384278e07033851614565e0c9f8e0ea314279560" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists. The list &lt;code&gt;tail&lt;/code&gt; will be added at the end of the flattened list.</source>
          <target state="translated">展平嵌套列表的给定 &lt;code&gt;list&lt;/code&gt; 。列表 &lt;code&gt;tail&lt;/code&gt; 将添加到拼合列表的末尾。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="e0ed30f7614c69e32cbce2c9fd0bd8fcaa7586e6" translate="yes" xml:space="preserve">
          <source>Float numbers require a dot followed by at least one digit and also support &lt;code&gt;e&lt;/code&gt; for scientific notation:</source>
          <target state="translated">浮点数要求点号后跟至少一位数字，并且还支持 &lt;code&gt;e&lt;/code&gt; 表示科学计数法：</target>
        </trans-unit>
        <trans-unit id="a4495969af61f575a24ee4711fa76dfaafb26d0e" translate="yes" xml:space="preserve">
          <source>Floats in Elixir are 64-bit double precision.</source>
          <target state="translated">Elixir中的浮点数为64位双精度。</target>
        </trans-unit>
        <trans-unit id="9ee393efb1b19d0c371e21c8a5d6360e13a111b0" translate="yes" xml:space="preserve">
          <source>Flushes all &lt;code&gt;:mix_shell&lt;/code&gt; and &lt;code&gt;:mix_shell_input&lt;/code&gt; messages from the current process.</source>
          <target state="translated">刷新当前进程中的所有 &lt;code&gt;:mix_shell&lt;/code&gt; 和 &lt;code&gt;:mix_shell_input&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="1f37e32316ff57285093c07bcc6fa68a47a4a700" translate="yes" xml:space="preserve">
          <source>Flushes the logger.</source>
          <target state="translated">刷新记录仪。</target>
        </trans-unit>
        <trans-unit id="d44af71a2582a2b67261bbce0307838133bc552a" translate="yes" xml:space="preserve">
          <source>Flushes the output buffer and returns its current contents.</source>
          <target state="translated">刷新输出缓冲区并返回当前内容。</target>
        </trans-unit>
        <trans-unit id="1fd9c42d3180adcefdbd370b8adb9856f5a36877" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the left with a function. Requires an accumulator.</source>
          <target state="translated">用一个函数将给定的列表从左边折叠(减少)。需要一个累加器。</target>
        </trans-unit>
        <trans-unit id="569c663a35f673e18e4fd8649f95dd98dfc6e9c3" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the right with a function. Requires an accumulator.</source>
          <target state="translated">用一个函数将给定的列表从右边折叠(减少)。需要一个累加器。</target>
        </trans-unit>
        <trans-unit id="2fa0635488dcee65136d608f773cf5f9ef5e7acf" translate="yes" xml:space="preserve">
          <source>Folds a list of documents into a document using the given folder function.</source>
          <target state="translated">使用给定的文件夹功能将一个文档列表折叠成一个文档。</target>
        </trans-unit>
        <trans-unit id="708d44cdbbf26cc5087abdc9244c378da50e27f8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;call/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_call/3&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt;, the process from which we received the request (&lt;code&gt;_from&lt;/code&gt;), and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_call/3&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt;. The first element of the tuple, &lt;code&gt;:reply&lt;/code&gt;, indicates that the server should send a reply back to the client. The second element, &lt;code&gt;reply&lt;/code&gt;, is what will be sent to the client while the third, &lt;code&gt;new_state&lt;/code&gt; is the new server state.</source>
          <target state="translated">对于 &lt;code&gt;call/2&lt;/code&gt; 请求，我们实现了一个 &lt;code&gt;handle_call/3&lt;/code&gt; 回调 &lt;code&gt;_from&lt;/code&gt; ，该回调函数接收 &lt;code&gt;request&lt;/code&gt; ，接收请求的过程（_from）和当前服务器状态（ &lt;code&gt;names&lt;/code&gt; ）。所述 &lt;code&gt;handle_call/3&lt;/code&gt; 回调返回格式的元组 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 。元组的第一个元素 &lt;code&gt;:reply&lt;/code&gt; ，指示服务器应将回复发送回客户端。第二个元素 &lt;code&gt;reply&lt;/code&gt; 是将发送到客户端的内容，第三个元素 &lt;code&gt;new_state&lt;/code&gt; 是新服务器状态。</target>
        </trans-unit>
        <trans-unit id="85fe9a9b5eab6f7837fd7ce17f20db0e36c96d5e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cast/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_cast/2&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt; and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_cast/2&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:noreply, new_state}&lt;/code&gt;. Note that in a real application we would have probably implemented the callback for &lt;code&gt;:create&lt;/code&gt; with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.</source>
          <target state="translated">对于 &lt;code&gt;cast/2&lt;/code&gt; 请求，我们实现了 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调，该回调接收 &lt;code&gt;request&lt;/code&gt; 和当前服务器状态（ &lt;code&gt;names&lt;/code&gt; ）。所述 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调格式返回一个元组 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 。请注意，在实际的应用程序中，我们可能会使用同步调用而不是异步强制转换来实现 &lt;code&gt;:create&lt;/code&gt; 的回调。我们通过这种方式来说明如何实现强制转换回调。</target>
        </trans-unit>
        <trans-unit id="3c507ce5e858adfd9920b90e4c749fbfaa148e35" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt; &lt;code&gt;:compile.file/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b0f265cab36385ed743f3055c68d076ae6c612a" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;. The option &lt;code&gt;:debug_info&lt;/code&gt; is always added to the end of it. You can disable that using:</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt; &lt;code&gt;:compile.file/2&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;:debug_info&lt;/code&gt; 选项总是添加到它的末尾。您可以使用以下方式禁用该功能：</target>
        </trans-unit>
        <trans-unit id="40b1a5cb3bd304af286350dbfa2dd4e5a7bde159" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/leex.html#file-2&quot;&gt;&lt;code&gt;:leex.file/2&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/leex.html#file-2&quot;&gt; &lt;code&gt;:leex.file/2&lt;/code&gt; &lt;/a&gt;。注意 &lt;code&gt;:report&lt;/code&gt; ， &lt;code&gt;:return_errors&lt;/code&gt; 和 &lt;code&gt;:return_warnings&lt;/code&gt; 选项被此编译器覆盖，因此设置它们无效。</target>
        </trans-unit>
        <trans-unit id="3e1748b035236f7578aca77841e51909dcda09f3" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt;&lt;code&gt;:yecc.file/1&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="translated">有关选项的完整列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt; &lt;code&gt;:yecc.file/1&lt;/code&gt; &lt;/a&gt;。注意 &lt;code&gt;:report&lt;/code&gt; ， &lt;code&gt;:return_errors&lt;/code&gt; 和 &lt;code&gt;:return_warnings&lt;/code&gt; 选项被此编译器覆盖，因此设置它们无效。</target>
        </trans-unit>
        <trans-unit id="cbadcbaa533f681fcd43632a6b2da738e09b45d0" translate="yes" xml:space="preserve">
          <source>For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关所有选项的说明，请参见&lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5de5c09f365a342ca1f4adef5fcae8f98c944b89" translate="yes" xml:space="preserve">
          <source>For a detailed explanation it's worth reading the analysis in &lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;Erlang/OTP documentation for fprof&lt;/a&gt;.</source>
          <target state="translated">有关详细说明，值得阅读&lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;fprof的Erlang / OTP文档中的分析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b520e99e07d5ece73b44be8ccfff4f1b35fe3ab3" translate="yes" xml:space="preserve">
          <source>For a machine with 8 cores, the above will process 16 items instead of 10. The reason is that &lt;a href=&quot;#async_stream/5&quot;&gt;&lt;code&gt;async_stream/5&lt;/code&gt;&lt;/a&gt; always have 8 elements processing at once. So by the time &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; says it got all elements it needed, there are still 6 elements left to be processed.</source>
          <target state="translated">对于具有8个核心的计算机，以上内容将处理16个项目而不是10个项目。原因是&lt;a href=&quot;#async_stream/5&quot;&gt; &lt;code&gt;async_stream/5&lt;/code&gt; &lt;/a&gt;始终一次处理8个元素。因此，当&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;表示已获得所需的所有元素时，仍有6个元素需要处理。</target>
        </trans-unit>
        <trans-unit id="455bca35994e1d4d5c63a42b082bcc28685c8fab" translate="yes" xml:space="preserve">
          <source>For a more complete rundown on the VM support for different times, see the &lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;chapter on time and time correction&lt;/a&gt; in the Erlang docs.</source>
          <target state="translated">有关不同时间对VM支持的更全面的了解，请参阅Erlang文档中&lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;有关时间和时间校正&lt;/a&gt;的章节。</target>
        </trans-unit>
        <trans-unit id="2ad3bd05a62d0ba912c71da5b141b89b54b65bc7" translate="yes" xml:space="preserve">
          <source>For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section.</source>
          <target state="translated">要想更全面地了解退出原因及其影响,请参见 &quot;退出原因与重启 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="28d7d5e1dc06aba969a0b236e650a8f1ae4054d6" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更深入的说明，请阅读&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;关闭值（：shutdown）&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="282328027889720b4154eca4c4806b544bc3a754" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更深入的说明，请阅读&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;关闭值（：shutdown）&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="37b344bcdc0c7b8779f65785a14e8c7aa3e5ded0" translate="yes" xml:space="preserve">
          <source>For accessing atom keys, one may also &lt;code&gt;map.key&lt;/code&gt;. Note that while &lt;code&gt;map[key]&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;map.key&lt;/code&gt; will raise if &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;.</source>
          <target state="translated">为了访问原子密钥，还可以使用 &lt;code&gt;map.key&lt;/code&gt; 。请注意，如果 &lt;code&gt;map[key]&lt;/code&gt; 如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;map.key&lt;/code&gt; 如果 &lt;code&gt;map&lt;/code&gt; 不包含key &lt;code&gt;:key&lt;/code&gt; ，则map.key将引发。</target>
        </trans-unit>
        <trans-unit id="57b9d70004f10cc3b53d8d1fb3e515752a611d21" translate="yes" xml:space="preserve">
          <source>For all other time zones, it returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt;.</source>
          <target state="translated">对于所有其他时区，它返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f912dfac4d0836d413b5ac057a2a5efa533103ff" translate="yes" xml:space="preserve">
          <source>For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration.</source>
          <target state="translated">对于其余所有的场景,库不应该强迫用户使用应用环境进行配置。如果库的用户认为某些参数应该全局配置,那么他们可以用自己的应用环境配置来包装库的功能。</target>
        </trans-unit>
        <trans-unit id="5c0878fd6cedf49cadfbc1ce37dc2efcc64e9280" translate="yes" xml:space="preserve">
          <source>For anonymous functions, there is also information about any of the atoms &lt;code&gt;:index&lt;/code&gt;, &lt;code&gt;:new_index&lt;/code&gt;, &lt;code&gt;:new_uniq&lt;/code&gt;, &lt;code&gt;:uniq&lt;/code&gt;, and &lt;code&gt;:pid&lt;/code&gt;. For a named function, the value of any of these items is always the atom &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">对于匿名函数，还提供有关任何原子的信息 &lt;code&gt;:index&lt;/code&gt; ， &lt;code&gt;:new_index&lt;/code&gt; ， &lt;code&gt;:new_uniq&lt;/code&gt; ， &lt;code&gt;:uniq&lt;/code&gt; 和 &lt;code&gt;:pid&lt;/code&gt; 。对于命名函数，这些项目中任何一项的值始终为atom &lt;code&gt;:undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b4ad9d30cceadfeb05cba1ddc74ec23c371587e" translate="yes" xml:space="preserve">
          <source>For any function, the information asked for can be any of the atoms &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:name&lt;/code&gt;, &lt;code&gt;:arity&lt;/code&gt;, &lt;code&gt;:env&lt;/code&gt;, or &lt;code&gt;:type&lt;/code&gt;.</source>
          <target state="translated">对于任何功能，要求的信息可以是原子 &lt;code&gt;:module&lt;/code&gt; ， &lt;code&gt;:name&lt;/code&gt; ， &lt;code&gt;:arity&lt;/code&gt; ， &lt;code&gt;:env&lt;/code&gt; 或 &lt;code&gt;:type&lt;/code&gt; 中的任何一个。</target>
        </trans-unit>
        <trans-unit id="19051a75616b4ec98796f8226da734aa9dd4e72d" translate="yes" xml:space="preserve">
          <source>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</source>
          <target state="translated">对于二进制文件,默认是二进制文件的大小。只有匹配中的最后一个二进制文件可以使用默认大小。所有其他的二进制文件必须明确地指定它们的大小,即使匹配是毫不含糊的。例如</target>
        </trans-unit>
        <trans-unit id="b53d094e78539531bab25286f248fcbe76cc3712" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="translated">对于上述情况，&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bee446e092800012625413c21226bed4c6f88b01" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="translated">对于上述情况，&lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bcf46e59d6f52359a868d6e88a0b7c5725001a1" translate="yes" xml:space="preserve">
          <source>For companies and teams, we recommend developers to run &lt;code&gt;mix format --check-formatted&lt;/code&gt; on their continuous integration servers, ensuring all current and future code follows the standard.</source>
          <target state="translated">对于公司和团队，我们建议开发人员在其连续集成服务器上运行 &lt;code&gt;mix format --check-formatted&lt;/code&gt; ，以确保当前和将来的所有代码均符合标准。</target>
        </trans-unit>
        <trans-unit id="57326dd8df98d78d81aebf773cf3bf48a345cefe" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关同时编译许多文件的信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html#compile/2&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b735130a48640def7fafe41aafe71355bd32d99" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关同时编译许多文件的信息，请参见&lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22400dc268fe8a7d24bf1a85c2d093a54cf84f6d" translate="yes" xml:space="preserve">
          <source>For convenience, consider adding &lt;code&gt;~/.mix/escripts&lt;/code&gt; directory to your &lt;code&gt;PATH&lt;/code&gt; environment variable. For more information, check the wikipedia article on PATH: &lt;a href=&quot;https://en.wikipedia.org/wiki/PATH_(variable)&quot;&gt;https://en.wikipedia.org/wiki/PATH_(variable)&lt;/a&gt;</source>
          <target state="translated">为了方便起见，请考虑将 &lt;code&gt;~/.mix/escripts&lt;/code&gt; 目录添加到 &lt;code&gt;PATH&lt;/code&gt; 环境变量中。有关更多信息，请查看有关PATH的Wikipedia文章：&lt;a href=&quot;https://en.wikipedia.org/wiki/PATH_(variable)&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/PATH_（变量）</target>
        </trans-unit>
        <trans-unit id="dfd371e570b65e572a1bfac8fa45fb1789e4dcde" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="translated">为了方便起见，您可以传递&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，并且当前环境中定义的所有导入，需求和别名将自动保留：</target>
        </trans-unit>
        <trans-unit id="d8d23e5be0a4ca18d043f1de42dd2f9c986db30d" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="translated">为了方便起见，您可以传递&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，所有选项将自动从当前环境中提取：</target>
        </trans-unit>
        <trans-unit id="fc1c26fa0cb08e8439005305225bde72db303603" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="translated">为方便起见，您可以传递&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，并且当前环境中定义的所有导入，需求和别名将自动保留：</target>
        </trans-unit>
        <trans-unit id="98082b67d38ae575b213c7f51ae3f6f67492121c" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="translated">为了方便起见，您可以传递&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;opts&lt;/code&gt; 参数，所有选项将自动从当前环境中提取：</target>
        </trans-unit>
        <trans-unit id="44989465a60239ad9d5198d147baa434ebc38464" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="translated">为方便起见，您可以将任何&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;结构（例如&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;）作为第一个参数或选项。模块和所有选项都将自动从环境中提取：</target>
        </trans-unit>
        <trans-unit id="54af569b6a029610c5091d98fd6f8fdc1073fe13" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="translated">为了方便起见，您可以将任何&lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;结构（例如&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;）作为第一个参数或选项。模块和所有选项都将自动从环境中提取：</target>
        </trans-unit>
        <trans-unit id="74cba56f60db3c6914d9e9b93e9bb138f70a33f1" translate="yes" xml:space="preserve">
          <source>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's &lt;code&gt;:unicode&lt;/code&gt; module.</source>
          <target state="translated">有关将二进制文件转换为其他编码以及Unicode规范化机制的信息，请参见Erlang的 &lt;code&gt;:unicode&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="6add89b99abcbf70ca9badb7516b8595c553f524" translate="yes" xml:space="preserve">
          <source>For debugging complex systems, jumping at the code is not enough. It is necessary to have an understanding of the whole virtual machine, processes, applications, as well as set up tracing mechanisms. Luckily this can be achieved in Erlang with &lt;code&gt;:observer&lt;/code&gt;. In your application:</source>
          <target state="translated">对于调试复杂的系统，仅跳转代码是不够的。必须了解整个虚拟机，进程，应用程序以及设置跟踪机制。幸运的是，可以使用 &lt;code&gt;:observer&lt;/code&gt; 在Erlang中实现。在您的应用程序中：</target>
        </trans-unit>
        <trans-unit id="5a06afd6a1e3c7ee6cdc0611f593f11b1bb1243b" translate="yes" xml:space="preserve">
          <source>For defining your own guards, Elixir even provides conveniences in &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt;. Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical.</source>
          <target state="translated">为了定义自己的后卫，Elixir甚至在 &lt;code&gt;defguard&lt;/code&gt; 和 &lt;code&gt;defguardp&lt;/code&gt; 中提供了便利。让我们看一个快速的案例研究：我们要检查一个参数是一个偶数还是一个奇数整数。使用模式匹配时，这是不可能的，因为存在无限数量的整数，因此我们无法对每个整数进行模式匹配。因此，我们必须使用警卫。因为检查奇数几乎是相同的，所以我们仅关注检查偶数。</target>
        </trans-unit>
        <trans-unit id="cb347f81732d219e27a511b076553d17de737f2a" translate="yes" xml:space="preserve">
          <source>For detailed documentation, see the &lt;a href=&quot;typespecs&quot;&gt;typespec documentation&lt;/a&gt;.</source>
          <target state="translated">有关详细文档，请参见&lt;a href=&quot;typespecs&quot;&gt;typespec文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3a098e863f08842ff154a18684a91f2e51c3a25" translate="yes" xml:space="preserve">
          <source>For detailed documentation, see the &lt;a href=&quot;typespecs#behaviours&quot;&gt;behaviour typespec documentation&lt;/a&gt;.</source>
          <target state="translated">有关详细文档，请参见&lt;a href=&quot;typespecs#behaviours&quot;&gt;行为typespec文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="312205920e8b42c10300fdc1c0d355fb769ce4d0" translate="yes" xml:space="preserve">
          <source>For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">有关代码点和字素的详细信息，请参见&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块文档。</target>
        </trans-unit>
        <trans-unit id="0f4a8cd91cf5db5cd126fba13df45a267644abde" translate="yes" xml:space="preserve">
          <source>For duplicate registries:</source>
          <target state="translated">对于重复的登记册:</target>
        </trans-unit>
        <trans-unit id="72d0f0434fbcec9eb207f396a9fc529d7587b375" translate="yes" xml:space="preserve">
          <source>For dynamically logging messages, see &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt;. But note that &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; always evaluates its arguments (unless the argument is an anonymous function).</source>
          <target state="translated">有关动态记录消息的信息，请参见&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt;。但是请注意，&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt;始终评估其参数（除非该参数是匿名函数）。</target>
        </trans-unit>
        <trans-unit id="1a7f7d68ad358e0a245cd7d3ae221748af013919" translate="yes" xml:space="preserve">
          <source>For each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (rhs) of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">对于每次失败，ExUnit都会打印一份详细报告，其中包含带有测试用例的测试名称，失败的代码以及 &lt;code&gt;==&lt;/code&gt; 运算符的左侧和右侧（rhs）的值。</target>
        </trans-unit>
        <trans-unit id="9e3caa2dc1d9000c1cebb47a719b8e0066b5bd2d" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于 &lt;code&gt;@derive&lt;/code&gt; 列表中的每个协议，Elixir将断言该协议已针对 &lt;code&gt;Any&lt;/code&gt; 实施。如果 &lt;code&gt;Any&lt;/code&gt; 实现定义了 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调，则将调用该回调，并且应定义实现模块。否则，将自动派生仅指向 &lt;code&gt;Any&lt;/code&gt; 实现的实现。有关 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#derive/3&quot;&gt; &lt;code&gt;Protocol.derive/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0fb1546f77232688d241d37ca1d325018f6f776" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;protocol#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于 &lt;code&gt;@derive&lt;/code&gt; 列表中的每个协议，Elixir将断言该协议已针对 &lt;code&gt;Any&lt;/code&gt; 实施。如果 &lt;code&gt;Any&lt;/code&gt; 实现定义了 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调，则将调用该回调，并且应定义实现模块。否则，将自动派生仅指向 &lt;code&gt;Any&lt;/code&gt; 实现的实现。有关 &lt;code&gt;__deriving__/3&lt;/code&gt; 回调的更多信息，请参见&lt;a href=&quot;protocol#derive/3&quot;&gt; &lt;code&gt;Protocol.derive/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25c946451972c973e2251bc9392dd413447e547a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="translated">例如，随着输入的增加，&lt;a href=&quot;#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;将花费更长的时间。另一方面，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt;始终在恒定时间内运行（即，不管输入大小如何）。</target>
        </trans-unit>
        <trans-unit id="1ce575e007b24aad8c7c6a66939213cc21ace30a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;the Ecto library&lt;/a&gt; makes use of these features to provide an elegant DSL for writing database queries:</source>
          <target state="translated">例如，&lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;Ecto库&lt;/a&gt;利用这些功能为编写数据库查询提供了优雅的DSL：</target>
        </trans-unit>
        <trans-unit id="72de0d4d0cc3d700aee14fc5035d60936c6b125d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;keyword#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keyword#delete/3&quot;&gt;&lt;code&gt;Keyword.delete/3&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note that operations that require keys to be found in the keyword list (like &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt;) need to traverse the list in order to find keys, so these operations may be slower than their map counterparts.</source>
          <target state="translated">例如，&lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt;将获取与给定键匹配的第一个条目，而不管是否存在重复的条目。同样，&lt;a href=&quot;keyword#put/3&quot;&gt; &lt;code&gt;Keyword.put/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;keyword#delete/3&quot;&gt; &lt;code&gt;Keyword.delete/3&lt;/code&gt; &lt;/a&gt;确保在调用时删除给定键的所有重复条目。请注意，需要在关键字列表中找到键的操作（例如&lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt;）需要遍历列表才能找到键，因此这些操作可能比对应的地图操作慢。</target>
        </trans-unit>
        <trans-unit id="0e6838c5c681ffb29b6c7310ee5d238a1c820319" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="translated">例如，随着输入的增加，&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;将花费更长的时间。另一方面，&lt;a href=&quot;kernel#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt;始终在恒定时间内运行（即，不管输入大小如何）。</target>
        </trans-unit>
        <trans-unit id="26266e605a5c6ee91c1509624141ef8292746ecc" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt; then all &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:notice&lt;/code&gt; and above will be passed to backends. If your log level is set to &lt;code&gt;:alert&lt;/code&gt;, only &lt;code&gt;:alert&lt;/code&gt; and &lt;code&gt;:emergency&lt;/code&gt; will be printed.</source>
          <target state="translated">例如， &lt;code&gt;:info&lt;/code&gt; 优先于 &lt;code&gt;:debug&lt;/code&gt; 。如果您的日志级别设置为 &lt;code&gt;:info&lt;/code&gt; ,则所有 &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:notice&lt;/code&gt; 及更高版本都将传递给后端。如果您的日志级别设置为 &lt;code&gt;:alert&lt;/code&gt; ，则仅打印 &lt;code&gt;:alert&lt;/code&gt; 和 &lt;code&gt;:emergency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c117e3a1a342b1f8160acdddadbc25ed7792af" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, and &lt;code&gt;:error&lt;/code&gt; will be printed to the console. If your log level is set to &lt;code&gt;:warn&lt;/code&gt;, only &lt;code&gt;:warn&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt; will be printed.</source>
          <target state="translated">例如， &lt;code&gt;:info&lt;/code&gt; 优先于 &lt;code&gt;:debug&lt;/code&gt; 。如果您的日志级别设置为 &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:warn&lt;/code&gt; 和 &lt;code&gt;:error&lt;/code&gt; ,则会输出到控制台。如果您的日志级别设置为 &lt;code&gt;:warn&lt;/code&gt; ，则仅输出 &lt;code&gt;:warn&lt;/code&gt; 和 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="852751a1fe78b13274da6029c51675b7e90dcb56" translate="yes" xml:space="preserve">
          <source>For example, Nerves uses this function to force all dependencies to be reloaded after it updates the system environment. It goes roughly like this:</source>
          <target state="translated">例如,Nerves在更新系统环境后,用这个函数强制所有的依赖关系被重载。大致是这样的。</target>
        </trans-unit>
        <trans-unit id="4af1c4caff42157f9481064fecc0d437c1cbd415" translate="yes" xml:space="preserve">
          <source>For example, a bitstring generator can be used with the &lt;code&gt;:into&lt;/code&gt; option in order to easily remove all spaces in a string:</source>
          <target state="translated">例如，位串生成器可以与 &lt;code&gt;:into&lt;/code&gt; 选项一起使用，以便轻松删除字符串中的所有空格：</target>
        </trans-unit>
        <trans-unit id="e07fb9806a4d8ebf20cacc02e52f4a77448a86cc" translate="yes" xml:space="preserve">
          <source>For example, a value that is not meant to be used must be assigned to &lt;code&gt;_&lt;/code&gt; or to a variable starting with underscore:</source>
          <target state="translated">例如，必须将不希望使用的值分配给 &lt;code&gt;_&lt;/code&gt; 或下划线开头的变量：</target>
        </trans-unit>
        <trans-unit id="4d8801f0d497391a5a53cac45037cd40a678af92" translate="yes" xml:space="preserve">
          <source>For example, although the code point &quot;&amp;eacute;&quot; is a single character, its underlying representation uses two bytes:</source>
          <target state="translated">例如，尽管代码点&amp;ldquo;&amp;eacute;&amp;rdquo;是一个字符，但其基础表示使用两个字节：</target>
        </trans-unit>
        <trans-unit id="fc12bb8ea1c91096d68d9eef9815101e3f31bcef" translate="yes" xml:space="preserve">
          <source>For example, consider you have a project called &lt;code&gt;my_app&lt;/code&gt; that depends on another one called &lt;code&gt;my_dep&lt;/code&gt;. &lt;code&gt;my_dep&lt;/code&gt; wants to export some configuration, so &lt;code&gt;my_dep/.formatter.exs&lt;/code&gt; would look like this:</source>
          <target state="translated">例如，假设您有一个名为 &lt;code&gt;my_app&lt;/code&gt; 的项目，该项目依赖于另一个名为 &lt;code&gt;my_dep&lt;/code&gt; 的项目。 &lt;code&gt;my_dep&lt;/code&gt; 要导出一些配置，因此 &lt;code&gt;my_dep/.formatter.exs&lt;/code&gt; 看起来像这样：</target>
        </trans-unit>
        <trans-unit id="bafc7c87cc4324b3f378e1b55b1f860c335be286" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="translated">例如，对于&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，我们有：</target>
        </trans-unit>
        <trans-unit id="d0a61e8f663dab72d666aa99d7d8392df6e2866f" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="translated">例如，对于&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，我们有：</target>
        </trans-unit>
        <trans-unit id="10d10d9aafa7b7150f21f408c108aefffcb399e3" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;code&gt;MyBehaviour&lt;/code&gt; module defined in &quot;Optional callbacks&quot; above:</source>
          <target state="translated">例如，对于上面&amp;ldquo;可选回调&amp;rdquo;中定义的 &lt;code&gt;MyBehaviour&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="8cdbd82ecc31ecfa904887629dd77138df5f318e" translate="yes" xml:space="preserve">
          <source>For example, if the &lt;code&gt;args&lt;/code&gt; in the above &lt;code&gt;echo&lt;/code&gt; task were inspected, you might see something like this:</source>
          <target state="translated">例如，如果检查了上述 &lt;code&gt;echo&lt;/code&gt; 任务中的 &lt;code&gt;args&lt;/code&gt; ，则可能会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="8306be9b21cc2aa72f1fd185081e1e544776e5ce" translate="yes" xml:space="preserve">
          <source>For example, if we want to use the &lt;code&gt;duplicate/2&lt;/code&gt; function from the &lt;code&gt;List&lt;/code&gt; module several times, we can import it:</source>
          <target state="translated">例如，如果我们想多次使用 &lt;code&gt;List&lt;/code&gt; 模块中的 &lt;code&gt;duplicate/2&lt;/code&gt; 函数，可以将其导入：</target>
        </trans-unit>
        <trans-unit id="9f456eb16f2bcd93d7684bd1cc3f45a1a1b9a12d" translate="yes" xml:space="preserve">
          <source>For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages.</source>
          <target state="translated">例如,如果你正在等待一个进程执行某些动作,最好用消息来传达这种动作的进展。</target>
        </trans-unit>
        <trans-unit id="dcc71fade44be2f0b07fe15278a544d60b766461" translate="yes" xml:space="preserve">
          <source>For example, if you expect the target system to have a config file in an absolute path, you can configure your &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">例如，如果您希望目标系统在绝对路径中具有配置文件，则可以将&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;配置为：</target>
        </trans-unit>
        <trans-unit id="d7c6d734ff451f6956c6aacbeccd9d4fdd938f74" translate="yes" xml:space="preserve">
          <source>For example, if you have a release named &lt;code&gt;demo&lt;/code&gt;, you can install the service and then start it from the release root as follows:</source>
          <target state="translated">例如，如果您有一个名为 &lt;code&gt;demo&lt;/code&gt; 的发行版，则可以安装该服务，然后从发行版根目录启动它，如下所示：</target>
        </trans-unit>
        <trans-unit id="3fcebcea9fb6c7cf3c366b1c527f43067e4ff086" translate="yes" xml:space="preserve">
          <source>For example, if you push the &lt;code&gt;kv&lt;/code&gt; project to a Git repository, you&amp;rsquo;ll need to list it in your deps code in order to use it:</source>
          <target state="translated">例如，如果将 &lt;code&gt;kv&lt;/code&gt; 项目推送到Git存储库，则需要在deps代码中列出它才能使用它：</target>
        </trans-unit>
        <trans-unit id="f3f65aca3ddc3c99d917b0c1b11f664e45fbabf4" translate="yes" xml:space="preserve">
          <source>For example, imagine a function that checks that the head of a list is not &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">例如，假设有一个函数检查列表的头部是否不为 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="aa3f335cc98a4af2b77268595737e5b7b1ed0489" translate="yes" xml:space="preserve">
          <source>For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt;, we want to return the map &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt;.</source>
          <target state="translated">例如，假设您有一个带字母的二进制文件，您想计算每个小写字母出现的次数，而忽略所有大写字母。例如，对于字符串 &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt; ，我们想返回映射 &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8f71ae8328569a71678b0be29a48fd915491141" translate="yes" xml:space="preserve">
          <source>For example, imagine the following configuration:</source>
          <target state="translated">例如,想象以下配置。</target>
        </trans-unit>
        <trans-unit id="92738f48db6bf8520616d3f910c86cb70b6a91a2" translate="yes" xml:space="preserve">
          <source>For example, imagine we want to implement a Validator module which provides a data validation domain-specific language. We could implement it using data structures, functions or macros. Let&amp;rsquo;s see what those different DSLs would look like:</source>
          <target state="translated">例如，假设我们要实现一个Validator模块，该模块提供一种数据验证域特定的语言。我们可以使用数据结构，函数或宏来实现它。让我们看看那些不同的DSL是什么样的：</target>
        </trans-unit>
        <trans-unit id="2ea959d5faa9cf257e82d7007ec084b4f335c593" translate="yes" xml:space="preserve">
          <source>For example, imagine you have a variable &lt;code&gt;number&lt;/code&gt; which contains the number you want to inject inside a quoted expression.</source>
          <target state="translated">例如，假设您有一个可变 &lt;code&gt;number&lt;/code&gt; ，其中包含要插入带引号的表达式中的数字。</target>
        </trans-unit>
        <trans-unit id="a2be4f8e8e8f8a802e09e5114bdae52f10f3c768" translate="yes" xml:space="preserve">
          <source>For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this:</source>
          <target state="translated">例如,想象一下你有一个API,它接收一个二进制的文件名。在某些时候,你会想要向这个文件写入。你可以有一个这样的函数。</target>
        </trans-unit>
        <trans-unit id="36f70d74391e0cf5d436981e9565a03fd1f683a6" translate="yes" xml:space="preserve">
          <source>For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like:</source>
          <target state="translated">例如,想象一下,你需要从一个JSON文件中加载一些配置,并将其加载到系统中。所说的配置提供者会是这样的。</target>
        </trans-unit>
        <trans-unit id="e595982d4d16b2fed73877c7eb51c758ba09c9f8" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How do you often fix it? By restarting it. Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="translated">例如,想象一下你的电脑、路由器、打印机或其他什么设备不能正常工作。你经常如何修复它?通过重启它。一旦我们重启设备,我们就会将设备重置回初始状态,这是经得起考验的,并保证能正常工作。在Elixir中,我们将这种方法应用于软件:每当一个进程崩溃时,我们就会启动一个新的进程来执行与崩溃进程相同的工作。</target>
        </trans-unit>
        <trans-unit id="700e114b8e70a0f80ebb6154d773287b9067f337" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How often do you fix it by restarting it? Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="translated">例如,想象一下你的电脑、路由器、打印机或任何设备不能正常工作。你经常通过重启来修复它?一旦我们重启设备,我们就会将设备重置回初始状态,这是经得起考验的,并保证能正常工作。在Elixir中,我们将这种方法应用于软件:每当一个进程崩溃时,我们就会启动一个新的进程来执行与崩溃进程相同的工作。</target>
        </trans-unit>
        <trans-unit id="f3cd6f9b58acaa3e0524e83ef7217c631726de0e" translate="yes" xml:space="preserve">
          <source>For example, in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">例如， &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5132419edebfb5538ebf32de072ef747449be00a" translate="yes" xml:space="preserve">
          <source>For example, in order to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">例如，为了写测试用例使用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;设置有药剂框架，显影剂应该 &lt;code&gt;use&lt;/code&gt; 的&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="d7d72e926d93f3ca1c487388374604ee39ad35ad" translate="yes" xml:space="preserve">
          <source>For example, in order to write tests using the ExUnit framework, a developer should use the &lt;code&gt;ExUnit.Case&lt;/code&gt; module:</source>
          <target state="translated">例如，为了使用ExUnit框架编写测试，开发人员应使用 &lt;code&gt;ExUnit.Case&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="3a8a1f3ca0f4f6e6f52cd5c38c70ee3321a7257d" translate="yes" xml:space="preserve">
          <source>For example, setting the mode &lt;code&gt;0o755&lt;/code&gt; gives it write, read and execute permission to the owner and both read and execute permission to group and others.</source>
          <target state="translated">例如，将模式设置为 &lt;code&gt;0o755&lt;/code&gt; ,将其授予所有者的写，读和执行权限，同时授予组和其他用户的读和执行权限。</target>
        </trans-unit>
        <trans-unit id="aa476bb5aa4307e87b6892c3eef680e2a1027574" translate="yes" xml:space="preserve">
          <source>For example, someone using your application can override its &lt;code&gt;:redis_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">例如，某人使用您的应用程序可以覆盖其 &lt;code&gt;:redis_host&lt;/code&gt; 环境变量，如下所示：</target>
        </trans-unit>
        <trans-unit id="c1f9245784df422bc589c02556ded2ebe4df04fc" translate="yes" xml:space="preserve">
          <source>For example, take a group document represented as &lt;code&gt;[1, 2, 3]&lt;/code&gt; where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as:</source>
          <target state="translated">例如，以表示为 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 的组文档为例，其中每个逗号后的空格是一个分隔符。当以上文档不适合一行时，将启用所有分隔符，从而使文档呈现为：</target>
        </trans-unit>
        <trans-unit id="5d84b09dd24eed2b37c8292a1e28d040806e59c5" translate="yes" xml:space="preserve">
          <source>For example, take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，使用以下 &lt;code&gt;.iex.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="4d2ade3e7c04be9a767d2179941a1c0d02c356f6" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt; function only works with tuples. If we use it with anything else, an argument error is raised:</source>
          <target state="translated">例如，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt;函数仅适用于元组。如果我们将其与其他任何东西一起使用，则会引发参数错误：</target>
        </trans-unit>
        <trans-unit id="f77c979642e1a9533effb1fde71896e71b2b1b38" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/Record.html&quot;&gt;&lt;code&gt;Record&lt;/code&gt;&lt;/a&gt; module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation.</source>
          <target state="translated">例如，Elixir中的&lt;a href=&quot;https://hexdocs.pm/elixir/Record.html&quot;&gt; &lt;code&gt;Record&lt;/code&gt; &lt;/a&gt;模块提供了一系列在模式和防护中使用的宏，这些宏允许元组在编译期间具有命名字段。</target>
        </trans-unit>
        <trans-unit id="dabd9937e48a29e73846df5608de823548c08b1e" translate="yes" xml:space="preserve">
          <source>For example, the code point &quot;&amp;eacute;&quot; is two bytes:</source>
          <target state="translated">例如，代码点&amp;ldquo;&amp;eacute;&amp;rdquo;是两个字节：</target>
        </trans-unit>
        <trans-unit id="d6d855b74f3622b261e79dba8a4c6c84fa6807d2" translate="yes" xml:space="preserve">
          <source>For example, the decimal number &lt;code&gt;3&lt;/code&gt; when represented with 4 bits in base 2 would be &lt;code&gt;0011&lt;/code&gt;, which is equivalent to the values &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, each stored using 1 bit:</source>
          <target state="translated">例如，十进制数 &lt;code&gt;3&lt;/code&gt; 时，在基体2的4位表示的将是 &lt;code&gt;0011&lt;/code&gt; ，它是等效于值 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; ，每个所存储的使用1个比特：</target>
        </trans-unit>
        <trans-unit id="d5c30e8005c0c98d6e53ce8dd367db66742e7504" translate="yes" xml:space="preserve">
          <source>For example, the following agent implements a counter:</source>
          <target state="translated">例如,下面的代理实现了一个计数器。</target>
        </trans-unit>
        <trans-unit id="f261112170af791387e9b66db2c2a75a6ec23785" translate="yes" xml:space="preserve">
          <source>For example, the following is a keyword list:</source>
          <target state="translated">例如,以下是一个关键词列表。</target>
        </trans-unit>
        <trans-unit id="3df9b543906bfd5595a0cacf49aeb1e63c393e38" translate="yes" xml:space="preserve">
          <source>For example, the module implementing the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol for lists is &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.List.html&quot;&gt;&lt;code&gt;Enumerable.List&lt;/code&gt;&lt;/a&gt;. Therefore, we can invoke &lt;code&gt;__impl__/1&lt;/code&gt; on this module:</source>
          <target state="translated">例如，实现列表的&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的模块是&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.List.html&quot;&gt; &lt;code&gt;Enumerable.List&lt;/code&gt; &lt;/a&gt;。因此，我们可以在此模块上调用 &lt;code&gt;__impl__/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b821bcc62d19a98d61faaca345d43a31156e0565" translate="yes" xml:space="preserve">
          <source>For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:</source>
          <target state="translated">例如,数字0.1和0.01是其中的两个,什么意思是0.1的平方的结果不给0.01既不是最接近的代表。下面是这种情况下的情况。</target>
        </trans-unit>
        <trans-unit id="3780e894751fdee43da26866cc6af18a271859a8" translate="yes" xml:space="preserve">
          <source>For example, to add multiple backends to your application, modify your configuration:</source>
          <target state="translated">例如,要在应用程序中添加多个后端,请修改您的配置。</target>
        </trans-unit>
        <trans-unit id="4009f5a45e54514dcb5423e242c0ca43c71a40ed" translate="yes" xml:space="preserve">
          <source>For example, to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; to redirect all Erlang messages using a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;配置为使用 &lt;code&gt;config/config.exs&lt;/code&gt; 文件重定向所有Erlang消息：</target>
        </trans-unit>
        <trans-unit id="97810dcc8560ef61b772f3bdcad87ca93ff037d4" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:backends&lt;/code&gt; and purge all calls that happen at compile time with level lower than &lt;code&gt;:info&lt;/code&gt; in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，配置 &lt;code&gt;:backends&lt;/code&gt; 并清除与水平发生在编译时低于所有来电 &lt;code&gt;:info&lt;/code&gt; 在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="21a8e2abf86d2318a5a86e1829eeef5e5857c798" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:level&lt;/code&gt; and &lt;code&gt;:truncate&lt;/code&gt; options in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">例如，要在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:level&lt;/code&gt; 和 &lt;code&gt;:truncate&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="a0b9557028bd4e04dc9baddf4fcbc9b36f7fb55a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;erlc_options&lt;/code&gt; for your Erlang project you may run:</source>
          <target state="translated">例如，要为您的Erlang项目配置 &lt;code&gt;erlc_options&lt;/code&gt; ，可以运行：</target>
        </trans-unit>
        <trans-unit id="76a5d4e647864137abb48e20144e766fb0c89015" translate="yes" xml:space="preserve">
          <source>For example, to disable color, one may use the configuration:</source>
          <target state="translated">例如,要禁用颜色,可以使用配置。</target>
        </trans-unit>
        <trans-unit id="a765ecc41513328acb3598f8f52b46ee7deada9a" translate="yes" xml:space="preserve">
          <source>For example, to lookup a server process, monitor it and send a cast to it:</source>
          <target state="translated">例如,查找一个服务器进程,监控它并向它发送投。</target>
        </trans-unit>
        <trans-unit id="cabc9384ea2bf9af1b99579a392dfd97e82162f8" translate="yes" xml:space="preserve">
          <source>For example, to split a test suite into 4 partitions and run them, you would use the following commands:</source>
          <target state="translated">例如,要将一个测试套件分割成4个分区并运行它们,你可以使用以下命令。</target>
        </trans-unit>
        <trans-unit id="49838731982f45b819651e28face607e270a0d83" translate="yes" xml:space="preserve">
          <source>For example, to update a map inside another map:</source>
          <target state="translated">例如,要在另一张地图内更新地图。</target>
        </trans-unit>
        <trans-unit id="f8d6f1962522c5a74c0c716a39923ef1c094d4d7" translate="yes" xml:space="preserve">
          <source>For example, to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">例如，为了使用写测试用例&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;设置有药剂框架，显影剂应该 &lt;code&gt;use&lt;/code&gt; 的&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="16fe3a971c511fed7157a7e0a03e09bb51dcfcf2" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Just open &lt;code&gt;config/config.exs&lt;/code&gt; and add the following to the end:</source>
          <target state="translated">例如，我们可以将IEx默认提示配置为另一个值。只需打开 &lt;code&gt;config/config.exs&lt;/code&gt; 并添加以下内容：</target>
        </trans-unit>
        <trans-unit id="3ad4f120b95aba025295d32b32cd84c67c8c60d6" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Let&amp;rsquo;s create the &lt;code&gt;config/config.exs&lt;/code&gt; file with the following content:</source>
          <target state="translated">例如，我们可以将IEx默认提示配置为另一个值。让我们创建具有以下内容的 &lt;code&gt;config/config.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="65ea0a674f1ce41ff4c22e2d07ee72ff95421ac9" translate="yes" xml:space="preserve">
          <source>For example, we can map a list of integers into their squared values:</source>
          <target state="translated">例如,我们可以将整数列表映射成它们的平方值。</target>
        </trans-unit>
        <trans-unit id="ecebd23ebfe4f1d1acd8ff8a2d9a8722555dc40b" translate="yes" xml:space="preserve">
          <source>For example, we can use bitstring generators with the &lt;code&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:</source>
          <target state="translated">例如，我们可以使用带 &lt;code&gt;:into&lt;/code&gt; 选项的位串生成器来轻松删除字符串中的所有空格：</target>
        </trans-unit>
        <trans-unit id="825bc9fd2268ad4ced535baaab0a761647bf3261" translate="yes" xml:space="preserve">
          <source>For example, we could implement &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">例如，我们可以按照&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; 的方式&lt;/a&gt;实现&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，如下所示：</target>
        </trans-unit>
        <trans-unit id="678b43ac2ccf82f31c5e6153c0e2834d16a5b6ca" translate="yes" xml:space="preserve">
          <source>For example, we could start and register our &lt;code&gt;Stack&lt;/code&gt; server locally as follows:</source>
          <target state="translated">例如，我们可以在本地启动并注册我们的 &lt;code&gt;Stack&lt;/code&gt; 服务器，如下所示：</target>
        </trans-unit>
        <trans-unit id="9a4ed3f8957553e26e0d94986089ddb6888e33a8" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode characters, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="translated">例如，到目前为止，我们已经使用了4个计数函数： &lt;code&gt;byte_size/1&lt;/code&gt; （用于表示字符串中的字节数）， &lt;code&gt;tuple_size/1&lt;/code&gt; （用于表示元组大小）， &lt;code&gt;length/1&lt;/code&gt; （用于列表长度）和 &lt;code&gt;String.length/1&lt;/code&gt; （字符串中的字素数量）。我们使用 &lt;code&gt;byte_size&lt;/code&gt; 来获取字符串中的字节数&amp;ndash;一种廉价的操作。另一方面，检索Unicode字符的数目使用 &lt;code&gt;String.length&lt;/code&gt; ，并且由于它依赖于遍历整个字符串，因此可能很昂贵。</target>
        </trans-unit>
        <trans-unit id="a856e5ee06c9349ef31043c8ece70cd8e13f1483" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode graphemes, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="translated">例如，到目前为止，我们已经使用了4个计数函数： &lt;code&gt;byte_size/1&lt;/code&gt; （用于表示字符串中的字节数）， &lt;code&gt;tuple_size/1&lt;/code&gt; （用于表示元组大小）， &lt;code&gt;length/1&lt;/code&gt; （用于列表长度）和 &lt;code&gt;String.length/1&lt;/code&gt; （ （字符串中的字素数量）。我们使用 &lt;code&gt;byte_size&lt;/code&gt; 来获取字符串中的字节数&amp;ndash;一种廉价的操作。另一方面，检索Unicode字素的数量使用 &lt;code&gt;String.length&lt;/code&gt; ，并且由于它依赖于遍历整个字符串，因此可能很昂贵。</target>
        </trans-unit>
        <trans-unit id="8e82002b46a7bc98e04a53b8f0787d96d507b69d" translate="yes" xml:space="preserve">
          <source>For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt;. This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it.</source>
          <target state="translated">例如，我们建议开发人员始终在主管下启动任务。这提供了更大的可见性，并允许您控制节点关闭时如何终止这些任务。可能看起来像 &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt; 。这意味着，尽管您的代码是调用任务的代码，但任务的实际祖先是主管，因为主管是有效启动该任务的人。</target>
        </trans-unit>
        <trans-unit id="0dcb9a644dbae1acdb996808b23645d55e2f6941" translate="yes" xml:space="preserve">
          <source>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; is not validated against a time zone, such errors would go unnoticed.</source>
          <target state="translated">例如，当某个地区应用夏令时时，时钟通常向前或向后移动一小时。这意味着某些日期时间永远不会发生或可能会发生多次。由于未针对时区对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;进行验证，因此此类错误不会引起注意。</target>
        </trans-unit>
        <trans-unit id="0134d97aaa5f44efc896482193ec373596c0207e" translate="yes" xml:space="preserve">
          <source>For example, you could specify a &lt;code&gt;URI.Parser&lt;/code&gt; behaviour as follows:</source>
          <target state="translated">例如，您可以指定 &lt;code&gt;URI.Parser&lt;/code&gt; 行为，如下所示：</target>
        </trans-unit>
        <trans-unit id="80c725586e4c191211220e82dbb160afa5b6efb9" translate="yes" xml:space="preserve">
          <source>For example, you might wish to include a custom &lt;code&gt;:error_code&lt;/code&gt; metadata in your logs:</source>
          <target state="translated">例如，您可能希望在日志中包含自定义 &lt;code&gt;:error_code&lt;/code&gt; 元数据：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="4e3a66cb565ce65f19a6ff578510f5919a4c4a12" translate="yes" xml:space="preserve">
          <source>For examples on how to use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol and &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;into/1&lt;/code&gt;&lt;/a&gt; see the module documentation.</source>
          <target state="translated">有关如何使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议和&lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;into/1&lt;/code&gt; 的&lt;/a&gt;示例，请参见模块文档。</target>
        </trans-unit>
        <trans-unit id="e4c21cf1cac5889764a4444020c6074013f406cd" translate="yes" xml:space="preserve">
          <source>For floats, it is 64. For floats, &lt;code&gt;size * unit&lt;/code&gt; must result in 32 or 64, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32 and binary64, respectively.</source>
          <target state="translated">对于浮点数，它是64。对于浮点数， &lt;code&gt;size * unit&lt;/code&gt; 必须为32或64，分别对应于&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32和binary64。</target>
        </trans-unit>
        <trans-unit id="e0863812afa8bda24138da4ec3b1ecff0d4ecc46" translate="yes" xml:space="preserve">
          <source>For fun, let's define a simple module in this shell too:</source>
          <target state="translated">为了好玩,让我们在这个shell中也定义一个简单的模块。</target>
        </trans-unit>
        <trans-unit id="979ac34509c51f5dab54e261eec8b56be64ab620" translate="yes" xml:space="preserve">
          <source>For further details on applications please check the documentation of the &lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt;&lt;code&gt;application&lt;/code&gt;&lt;/a&gt; Erlang module, and the &lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;Applications&lt;/a&gt; section of the &lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP Design Principles User's Guide&lt;/a&gt;.</source>
          <target state="translated">有关应用程序的更多详细信息，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt; &lt;code&gt;application&lt;/code&gt; &lt;/a&gt; Erlang模块的文档以及《&lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP设计原则用户指南》的&amp;ldquo; &lt;/a&gt;&lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;应用程序&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="f91858e05de05b595ba22a40c6d98a7a27a8e926" translate="yes" xml:space="preserve">
          <source>For grouping tests together, see &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; in this module.</source>
          <target state="translated">要将测试分组在一起，请参阅本模块中的&lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77ab7e6ee8d58a006653e5dfc1bb9f58088937ba" translate="yes" xml:space="preserve">
          <source>For instance one period could be the summer of 2018 in &quot;Europe/London&quot; where summer time / daylight saving time is in effect and lasts from spring to autumn. At autumn the &lt;code&gt;std_offset&lt;/code&gt; changes along with the &lt;code&gt;zone_abbr&lt;/code&gt; so a different period is needed during winter.</source>
          <target state="translated">例如，一个时期可能是&amp;ldquo;欧洲/伦敦&amp;rdquo;的2018年夏季，夏令时/夏令时生效，持续时间从春季到秋季。在秋季 &lt;code&gt;std_offset&lt;/code&gt; 与变化一起 &lt;code&gt;zone_abbr&lt;/code&gt; 因此在冬季需要一个不同的时期。</target>
        </trans-unit>
        <trans-unit id="e51496febe42a068541cd5f1776cfef4dbdc9e31" translate="yes" xml:space="preserve">
          <source>For instance, given a user map with the &lt;code&gt;:name&lt;/code&gt; and &lt;code&gt;:languages&lt;/code&gt; keys, here is how to deeply traverse the map and convert all language names to uppercase:</source>
          <target state="translated">例如，给定一个带有 &lt;code&gt;:name&lt;/code&gt; 和 &lt;code&gt;:languages&lt;/code&gt; 键的用户映射，以下是如何深入遍历该映射并将所有语言名称转换为大写的方法：</target>
        </trans-unit>
        <trans-unit id="0fa8784dfc2e01f4f7777294a47b6dd71b0ca392" translate="yes" xml:space="preserve">
          <source>For instance, releases run using short-names (&lt;code&gt;--sname&lt;/code&gt;). However, if you want to actually run a distributed key-value store in production, you will need multiple nodes and start the release with the &lt;code&gt;--name&lt;/code&gt; option. We can achieve this by setting the &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; environment variable inside the &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; files. Mix already has a template for said files which we can customize, so let&amp;rsquo;s ask Mix to copy them to our application:</source>
          <target state="translated">例如，发布使用短名称（ &lt;code&gt;--sname&lt;/code&gt; ）运行。但是，如果要在生产环境中实际运行分布式键值存储，则将需要多个节点并使用 &lt;code&gt;--name&lt;/code&gt; 选项开始发布。我们可以通过在 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 文件中设置 &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; 环境变量来实现此目的。Mix已经有了一个可以自定义的上述文件的模板，所以让我们将Mix复制到我们的应用程序中：</target>
        </trans-unit>
        <trans-unit id="098abe87bcf54674f294a660fdeca753e3973228" translate="yes" xml:space="preserve">
          <source>For instance, we can create a file called &lt;code&gt;math.exs&lt;/code&gt;:</source>
          <target state="translated">例如，我们可以创建一个名为 &lt;code&gt;math.exs&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="915841eb2ae9437182185facdb407e9c03dade23" translate="yes" xml:space="preserve">
          <source>For intensive workloads, the registry may also be partitioned (by specifying the &lt;code&gt;:partitions&lt;/code&gt; option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available:</source>
          <target state="translated">对于繁重的工作负载，还可以对注册表进行分区（通过指定 &lt;code&gt;:partitions&lt;/code&gt; 选项）。如果需要分区，那么一个很好的默认设置是将分区数设置为可用的调度程序数：</target>
        </trans-unit>
        <trans-unit id="0be2313f13029f16466fa64d8d779bb84d194911" translate="yes" xml:space="preserve">
          <source>For maps, the first tuple element must be a &lt;code&gt;{key, value}&lt;/code&gt; tuple.</source>
          <target state="translated">对于地图，第一个元组元素必须是 &lt;code&gt;{key, value}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="9ef87b3ee1067750a0799faa766ca960ddec15e8" translate="yes" xml:space="preserve">
          <source>For maps, the function expects a key-value tuple.</source>
          <target state="translated">对于地图,函数期望一个键值元组。</target>
        </trans-unit>
        <trans-unit id="2006fc3ed297a859555ea878c9cf50cc043d6a81" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-2&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关监视所有节点的状态更改，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-2&quot;&gt; &lt;code&gt;:net_kernel.monitor_nodes/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f65055eecdf00696b65a9b430fcafe6f22952a12" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关监视所有节点的状态更改，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt; &lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a50d8c364812d16e018ab6d0f72a5d0030e8481" translate="yes" xml:space="preserve">
          <source>For more advanced options available when defining custom attributes, see &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关定义自定义属性时可用的更多高级选项，请参见&lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;register_attribute/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="095613a0c71daec41f22ebf762f9ec5144c17212" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt;&lt;code&gt;:file.read_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt; &lt;code&gt;:file.read_link/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c85e5081a17eac440f3c5a413306106ced5d9c19" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt;&lt;code&gt;:file.read_link_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt; &lt;code&gt;:file.read_link_info/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40801b427f30e76ede611926a90606441dd86a7c" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更多详细信息，请阅读&amp;ldquo;&lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;字符列表&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c734b39d3add7d597fc3e2a0a8f87e008c1a861a" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关更多详细信息，请阅读&amp;ldquo; &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;模块中的&amp;ldquo;字符列表 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="95147adb3177256a490cdad3827bcc51779e68e4" translate="yes" xml:space="preserve">
          <source>For more information about IO data, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">有关IO数据的更多信息，请参见模块文档中的&lt;a href=&quot;#module-io-data&quot;&gt;&amp;ldquo; IO数据&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="1c3a9dad7c543d1c63c29b6ca8ca500c85b4a2b7" translate="yes" xml:space="preserve">
          <source>For more information about chardata, see the &lt;a href=&quot;#module-chardata&quot;&gt;&quot;Chardata&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">有关chardata的更多信息，请参见模块文档中的&lt;a href=&quot;#module-chardata&quot;&gt;&amp;ldquo; Chardata&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0541321f88f511fe94f622a2cb19777c006436cc" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关结构的更多信息，请检查&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edd1a5e1d2ce7f216383d5f43648eb3d76f38089" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关结构的更多信息，请检查&lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59d3cf884555506ee92cff193a1929009e874d1e" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &quot;Aliasing&quot; section in the docs for &lt;a href=&quot;mix&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关任务别名的更多信息，请参阅&lt;a href=&quot;mix&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;文档中的&amp;ldquo;别名&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="78f8e40c63b458c9fad682e6d3b6666a0f62cf7b" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;&quot;Aliases&quot;&lt;/a&gt; section in the docs for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关任务别名的更多信息，请参阅&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;文档中的&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;&amp;ldquo;别名&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="da00729bbfd1619462b29a7b8fa0dab41f7868c6" translate="yes" xml:space="preserve">
          <source>For more information and the list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息和选项列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt; &lt;code&gt;:erlang.open_port/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc7ee954ed549f3663bd8fb004277a09d86223c0" translate="yes" xml:space="preserve">
          <source>For more information and to open any module or function, see &lt;a href=&quot;#open/1&quot;&gt;&lt;code&gt;open/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息以及要打开任何模块或功能，请参见&lt;a href=&quot;#open/1&quot;&gt; &lt;code&gt;open/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0b21c46bc07a705dfc9fb743eebf812b0cdc892" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;code&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">有关代码路径的更多信息，请检查Elixir中的&lt;a href=&quot;code&quot;&gt; &lt;code&gt;Code&lt;/code&gt; &lt;/a&gt;模块以及Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bd54480aa692a8df8b981b72aa444502ecc46ce" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">有关代码路径的更多信息，请检查Elixir中的&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html&quot;&gt; &lt;code&gt;Code&lt;/code&gt; &lt;/a&gt;模块以及Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bd6c86df060a9a0da50c17d815720a12995dd04" translate="yes" xml:space="preserve">
          <source>For more information on each of the possible returned values, see &lt;a href=&quot;#info/1&quot;&gt;&lt;code&gt;info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关每个可能的返回值的更多信息，请参见&lt;a href=&quot;#info/1&quot;&gt; &lt;code&gt;info/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a372c9bd101c94685e235eb649743902f58f48c" translate="yes" xml:space="preserve">
          <source>For more information on how the break is inserted, see &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关如何插入中断的更多信息，请参见&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65a28bc1907c5e0ff21b3bd1d4bbcdfcc5c5acaf" translate="yes" xml:space="preserve">
          <source>For more information on running your project, see the official &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix documentation&lt;/a&gt;.</source>
          <target state="translated">有关运行项目的更多信息，请参见《&lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix＆OTP&lt;/a&gt;官方指南》或《&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix文档》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eff11d18fedd9846c96b5c225d02a932e7b86b50" translate="yes" xml:space="preserve">
          <source>For more information read the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt; section in the Wikipedia article of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; standard.</source>
          <target state="translated">有关更多信息，请阅读&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;标准的Wikipedia文章中的&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="5b003e6f0d5f3ad23f1b90e810d0b8f11ff3028f" translate="yes" xml:space="preserve">
          <source>For more information, check &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SmartEngine.html&quot;&gt;&lt;code&gt;EEx.SmartEngine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请检查&lt;a href=&quot;https://hexdocs.pm/eex/EEx.SmartEngine.html&quot;&gt; &lt;code&gt;EEx.SmartEngine&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1311002c3a957f544a2fb2f22b854fa11815412" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt;&lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt; &lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cd3be4a21a8ffdb5484f382332800faea93a58f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt;&lt;code&gt;:erlang.halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt; &lt;code&gt;:erlang.halt/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48be8c3bec9fc07a6ce3cee60d8a8e670e70ad06" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt;&lt;code&gt;:erlang.monitor_node/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt; &lt;code&gt;:erlang.monitor_node/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb3eefbbccd2c205683a61d85dab5af738a1f1d7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt;&lt;code&gt;:erlang.monitor_node/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt; &lt;code&gt;:erlang.monitor_node/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c9d37564a53538860067ee2ce72a5278d51bbde" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt;&lt;code&gt;:erlang.nodes/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt; &lt;code&gt;:erlang.nodes/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb045622e309576ede0093587a78e27c6a80e60" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt;&lt;code&gt;:erlang.port_close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt; &lt;code&gt;:erlang.port_close/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74569ddc9dafdb010b29df91efd894806768f74c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt;&lt;code&gt;:erlang.port_command/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt; &lt;code&gt;:erlang.port_command/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db0e4c8249cd1b3c3788a38e7bf3c3b9d4b6ceab" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt;&lt;code&gt;:erlang.port_connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt; &lt;code&gt;:erlang.port_connect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ce86a1871484a9008f73d0c702d7521b667af6c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt;&lt;code&gt;:erlang.port_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt; &lt;code&gt;:erlang.port_info/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80edbd442183f322a586734d8b1f7c8a23af48b7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt;&lt;code&gt;:erlang.port_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt; &lt;code&gt;:erlang.port_info/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82424b64f3a822c3b698f3418f074d1a59050668" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt;&lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt; &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef58581a2fb238d3165babba36ae1b31c20add22" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt;&lt;code&gt;:os.getpid/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt; &lt;code&gt;:os.getpid/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed8b5928b9cd599d88e9ffccabb9856023defc53" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块，&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#t:child_spec/0&quot;&gt; &lt;code&gt;Supervisor.child_spec/0&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="9ba2f8e0812ba8129e28893614e39bd76a33546b" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块，&lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt; &lt;code&gt;Supervisor.child_spec/0&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="1c2459bba39c2a32218e800abed73a1b40251809" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: &lt;a href=&quot;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&quot;&gt;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;git config&lt;/code&gt; 文档：&lt;a href=&quot;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&quot;&gt;https&lt;/a&gt; : //git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</target>
        </trans-unit>
        <trans-unit id="3d95ccf97994d2d052649c07b5320d1f38bf9f6a" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;git config&lt;/code&gt; 文档：https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</target>
        </trans-unit>
        <trans-unit id="72d636c495936af4b6f2d13c4ec5f6492712b56a" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">有关更多选项，请关注有关单个Mix任务的文档。&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务和所有特定的编译器任务（例如&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt; &lt;/a&gt;）就是很好的例子。</target>
        </trans-unit>
        <trans-unit id="1db1a5e08950211f4efaa987901db5f4cb9b8017" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">有关更多选项，请关注有关单个Mix任务的文档。很好的例子是&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务和所有特定的编译器任务（例如&lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ab9291211cba201b17b9f64f55072345afbd7fc8" translate="yes" xml:space="preserve">
          <source>For most cases, use &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#now/2&quot;&gt;&lt;code&gt;DateTime.now/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/1&quot;&gt;&lt;code&gt;DateTime.utc_now/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">在大多数情况下，请改用&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#now/2&quot;&gt; &lt;code&gt;DateTime.now/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/1&quot;&gt; &lt;code&gt;DateTime.utc_now/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df72e64eacb9e3850dc8419637a02be86b270033" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s move on and explore the world of I/O in Elixir.</source>
          <target state="translated">现在，让我们继续探索Elixir中的I / O世界。</target>
        </trans-unit>
        <trans-unit id="9d92d262d1937649c7dcc6aa1826ed7218a816df" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows PowerShell, where &lt;code&gt;iex&lt;/code&gt; is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="translated">现在，让我们通过运行开始 &lt;code&gt;iex&lt;/code&gt; （或 &lt;code&gt;iex.bat&lt;/code&gt; 如果你在Windows PowerShell中，其中 &lt;code&gt;iex&lt;/code&gt; 是PowerShell命令），它代表互动药剂。在交互模式下，我们可以键入任何Elixir表达式并获取其结果。让我们用一些基本表达式进行热身。</target>
        </trans-unit>
        <trans-unit id="f53fcbcb4286cbc82f5367680ea1d01a64e91602" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="translated">现在，让我们开始运行代表Interactive Elixir的 &lt;code&gt;iex&lt;/code&gt; （如果在Windows上 &lt;code&gt;iex.bat&lt;/code&gt; ）。在交互模式下，我们可以键入任何Elixir表达式并获取其结果。让我们用一些基本表达式进行热身。</target>
        </trans-unit>
        <trans-unit id="8f7af079e462a2a151d8084f9a25584ba5fdb2e5" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s write some tests to guarantee our GenServer works as expected.</source>
          <target state="translated">现在，让我们编写一些测试以确保GenServer能够按预期工作。</target>
        </trans-unit>
        <trans-unit id="148e18f793d17b1f034ccd4f65b51bd7c72b46fe" translate="yes" xml:space="preserve">
          <source>For now, there is a more important bug we need to fix: what happens if our TCP acceptor crashes? Since there is no supervision, the server dies and we won&amp;rsquo;t be able to serve more requests, because it won&amp;rsquo;t be restarted. That&amp;rsquo;s why we must move our server to a supervision tree.</source>
          <target state="translated">目前，我们需要修复一个更重要的错误：如果TCP接收器崩溃，会发生什么？由于没有监督，服务器死了，我们将无法处理更多请求，因为它不会重新启动。这就是为什么我们必须将服务器移至监管树。</target>
        </trans-unit>
        <trans-unit id="87f6316211bcc19e1a9eaf598a9dc404f5c35c3f" translate="yes" xml:space="preserve">
          <source>For now, we don&amp;rsquo;t have a mechanism to run tests, but we know that a function named &amp;ldquo;test hello&amp;rdquo; was defined behind the scenes. When we invoke it, it should fail:</source>
          <target state="translated">目前，我们没有运行测试的机制，但是我们知道在幕后定义了一个名为&amp;ldquo; test hello&amp;rdquo;的函数。当我们调用它时，它应该失败：</target>
        </trans-unit>
        <trans-unit id="c1b2f8891476cbc97734acacb2637f18c16dc0b0" translate="yes" xml:space="preserve">
          <source>For now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.</source>
          <target state="translated">现在,我们将只为我们的 bucket 注册逻辑编写服务器回调,而不提供适当的 API,这一点我们将在后面做。</target>
        </trans-unit>
        <trans-unit id="dc972a5ae988c88cbdf8abf55ced2fc62781c361" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">对于网络中的其他节点，这与发生故障的节点相同。仅当节点以&lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;Node.start/3&lt;/code&gt; &lt;/a&gt;启动时才可能，否则返回 &lt;code&gt;{:error, :not_allowed}&lt;/code&gt; 。如果本地节点未处于活动状态 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 返回{：error，：not_found}。</target>
        </trans-unit>
        <trans-unit id="cdf1e2badff2fb623eee0d15afc921e9e14a706d" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;node#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">对于网络中的其他节点，这与发生故障的节点相同。仅当节点以&lt;a href=&quot;node#start/3&quot;&gt; &lt;code&gt;Node.start/3&lt;/code&gt; &lt;/a&gt;启动时才可能，否则返回 &lt;code&gt;{:error, :not_allowed}&lt;/code&gt; 。如果本地节点未处于活动状态 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 返回{：error，：not_found}。</target>
        </trans-unit>
        <trans-unit id="6dc55533805b090f117cb41ae2a4faf8a8f47746" translate="yes" xml:space="preserve">
          <source>For our routing layer, we are going to use tasks, but feel free to explore the other alternatives too.</source>
          <target state="translated">对于我们的路由层,我们将使用任务,但也可以自由探索其他选择。</target>
        </trans-unit>
        <trans-unit id="40e9bcfd5323b3ba76bb77edb0dbd378b076a7c8" translate="yes" xml:space="preserve">
          <source>For qualified calls, Elixir also allows the function name to be written between double- or single-quotes, allowing calls such as &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt;. Operators can be used as qualified calls without a need for quote, such as &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt;.</source>
          <target state="translated">对于合格的调用，Elixir还允许在双引号或单引号之间编写函数名称，从而允许进行诸如 &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt; 调用。运算符可以用作合格的调用而无需引用，例如 &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42f87f4978894da77ca58ac8711d1cc43114d9dc" translate="yes" xml:space="preserve">
          <source>For reference information about operators (and ordering), check the &lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;reference page on operators&lt;/a&gt;.</source>
          <target state="translated">有关操作员（和订购）的参考信息，请查看&lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;关于操作员&lt;/a&gt;的参考页。</target>
        </trans-unit>
        <trans-unit id="45c16b662757456a064165b8b1b3ab76da91cf9d" translate="yes" xml:space="preserve">
          <source>For runtime configuration, you can use the &lt;code&gt;config/runtime.exs&lt;/code&gt; file. It is executed right before applications start in both Mix and releases (assembled with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">对于运行时配置，可以使用 &lt;code&gt;config/runtime.exs&lt;/code&gt; 文件。它在应用程序同时在Mix和Releases中启动（与&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;组装在一起）之前执行。</target>
        </trans-unit>
        <trans-unit id="cf040e76c44787262309528d14284c46bf630986" translate="yes" xml:space="preserve">
          <source>For selecting a maximum value out of two consider using &lt;a href=&quot;kernel#max/2&quot;&gt;&lt;code&gt;Kernel.max/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#max/2&quot;&gt; &lt;code&gt;Kernel.max/2&lt;/code&gt; &lt;/a&gt;两个中选择一个最大值，请考虑使用Kernel.max / 2。</target>
        </trans-unit>
        <trans-unit id="1562be9dbea9e9ca6fb9c201080d343b056ee54f" translate="yes" xml:space="preserve">
          <source>For selecting a minimal value out of two consider using &lt;a href=&quot;kernel#min/2&quot;&gt;&lt;code&gt;Kernel.min/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#min/2&quot;&gt; &lt;code&gt;Kernel.min/2&lt;/code&gt; &lt;/a&gt;两个中选择一个最小值，请考虑使用Kernel.min / 2。</target>
        </trans-unit>
        <trans-unit id="a4f8060b8066310c46625a879a6c7a04a6546c32" translate="yes" xml:space="preserve">
          <source>For simplicity, we will define a routing table that always points to the current node. That&amp;rsquo;s the table we will use for development and most of our tests. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="translated">为简单起见，我们将定义一个始终指向当前节点的路由表。这就是我们将用于开发和大多数测试的表。返回 &lt;code&gt;config/config.exs&lt;/code&gt; ，添加以下行：</target>
        </trans-unit>
        <trans-unit id="57260814a626a0bc7ec7efb7558c4019fed8ea33" translate="yes" xml:space="preserve">
          <source>For such cases, there is a special break-trigger (&lt;code&gt;#iex:break&lt;/code&gt;) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</source>
          <target state="translated">在这种情况下，有一个特殊的break-trigger（ &lt;code&gt;#iex:break&lt;/code&gt; ），当它本身在一行上遇到时，将迫使shell脱离任何挂起的表达式并返回其正常状态：</target>
        </trans-unit>
        <trans-unit id="b2bcf831b712f7880bfa8b2d774584d0dac9e8fa" translate="yes" xml:space="preserve">
          <source>For such, you can explicitly pass the current module scope as argument:</source>
          <target state="translated">对于这种情况,你可以显式地传递当前模块范围作为参数。</target>
        </trans-unit>
        <trans-unit id="f5574a61794819cd12b11f08763b8c0faad5bbf7" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关实际的日期，时间和日期时间结构，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b01361fded820f92aa3d34dea84f82e83756a312" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关实际的日期，时间和日期时间结构，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd4507d56d8ae26835032192a96f8f942cf347e1" translate="yes" xml:space="preserve">
          <source>For the cases where you do expect a file to exist (and the lack of that file is truly an &lt;em&gt;error&lt;/em&gt;) you may use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="translated">对于确实希望文件存在的情况（缺少该文件确实是一个&lt;em&gt;错误&lt;/em&gt;），可以使用 &lt;code&gt;File.read!/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="feff331a64ed11f441e7848a674afa89ee8071f6" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt;&lt;code&gt;:erlang.spawn/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt; &lt;code&gt;:erlang.spawn/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6639a98f71e3255b9d9416659477b36d9f9e63f9" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt;&lt;code&gt;:erlang.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt; &lt;code&gt;:erlang.spawn/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d102dfda15fab2a12aecfca86ecdab6b9328f4c7" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt;&lt;code&gt;:erlang.spawn/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt; &lt;code&gt;:erlang.spawn/5&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="147c5308097c95403b6c3b710471092817aba390" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt;&lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用选项的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt; &lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad4e9a7fc7900bbb60654000287c4ad75fc0eadd" translate="yes" xml:space="preserve">
          <source>For the list of supported warnings, see &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;&lt;code&gt;:dialyzer&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">有关受支持的警告的列表，请参见&lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt; &lt;code&gt;:dialyzer&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a293fce2f70fe18d9d7bb3411509a1883ca74c72" translate="yes" xml:space="preserve">
          <source>For this chapter, we will be using files instead of running code samples in IEx. That&amp;rsquo;s because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a &lt;code&gt;macros.exs&lt;/code&gt; file and running it with &lt;code&gt;elixir macros.exs&lt;/code&gt; or &lt;code&gt;iex macros.exs&lt;/code&gt;.</source>
          <target state="translated">在本章中，我们将使用文件而不是在IEx中运行代码示例。这是因为代码示例将跨越多行代码，并且在IEx中键入它们都可能适得其反。您应该能够通过将代码示例保存到 &lt;code&gt;macros.exs&lt;/code&gt; 文件中并使用 &lt;code&gt;elixir macros.exs&lt;/code&gt; 或 &lt;code&gt;iex macros.exs&lt;/code&gt; 来运行它们。</target>
        </trans-unit>
        <trans-unit id="467f37cafc343b5dd34e43c5cc0cac653196e6ee" translate="yes" xml:space="preserve">
          <source>For this reason, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; supports partitioning the test files across different Elixir instances. This is done by setting the &lt;code&gt;--partitions&lt;/code&gt; option to an integer, with the number of partitions, and setting the &lt;code&gt;MIX_TEST_PARTITION&lt;/code&gt; environment variable to control which test partition that particular instance is running. This can also be useful if you want to distribute testing across multiple machines.</source>
          <target state="translated">因此，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;支持跨不同的Elixir实例对测试文件进行分区。这是通过将 &lt;code&gt;--partitions&lt;/code&gt; 选项设置为带有分区数量的整数，并设置 &lt;code&gt;MIX_TEST_PARTITION&lt;/code&gt; 环境变量来控制特定实例正在运行的测试分区来完成的。如果要在多台计算机上分布测试，这也很有用。</target>
        </trans-unit>
        <trans-unit id="945a8597b683042909912d13ab0af0f05f4a1912" translate="yes" xml:space="preserve">
          <source>For this reason, Mix also provides an &lt;code&gt;--only&lt;/code&gt; option that excludes all tests and includes only the given ones:</source>
          <target state="translated">因此，Mix还提供了 &lt;code&gt;--only&lt;/code&gt; 选项，该选项排除所有测试，仅包括给定的测试：</target>
        </trans-unit>
        <trans-unit id="5942291bf8303552448ccf23f92c1cc85a264e74" translate="yes" xml:space="preserve">
          <source>For this reason, Mix supports &amp;ldquo;umbrella projects&amp;rdquo;. Umbrella projects are used to build applications that run together in a single repository. That is exactly the style we are going to explore in the next sections.</source>
          <target state="translated">因此，Mix支持&amp;ldquo;伞项目&amp;rdquo;。伞项目用于构建在单个存储库中一起运行的应用程序。这正是我们将在下一部分中探讨的样式。</target>
        </trans-unit>
        <trans-unit id="c1c939e13c6bbd8a4d4a1a8b54e616c8009ed164" translate="yes" xml:space="preserve">
          <source>For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">因此，大多数结构都提供&amp;ldquo;比较&amp;rdquo;功能，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;，该函数接收两个结构并返回 &lt;code&gt;:lt&lt;/code&gt; （小于） &lt;code&gt;:eq&lt;/code&gt; （等于）和 &lt;code&gt;:gt&lt;/code&gt; （大于） 。如果将模块作为排序功能传递，Elixir将自动使用该模块的 &lt;code&gt;compare/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="db439eca1a575baf9e479914a743abe4e55ae0ad" translate="yes" xml:space="preserve">
          <source>For this reason, the task touches your &lt;code&gt;:compile_path&lt;/code&gt; directory and sets the modification time to the current time and date at the end of each compilation. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">出于这个原因，该任务触摸您的 &lt;code&gt;:compile_path&lt;/code&gt; 目录，并将修改时间设置为每次编译结束时的当前时间和日期。您可以通过传递 &lt;code&gt;--force&lt;/code&gt; 选项来强制编译，而不考虑修改时间。</target>
        </trans-unit>
        <trans-unit id="32446efaffd01773633a5c5b128367d85e1cc28b" translate="yes" xml:space="preserve">
          <source>For those reasons, reading the application environment at runtime should be the first choice. However, if you really have to read the application environment during compilation, we recommend you to use &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">由于这些原因，在运行时读取应用程序环境应该是首选。但是，如果在编译过程中确实必须阅读应用程序环境，建议您改用&lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c4c8e038c25d83bf6d852a971892fb340f9e2eff" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module in a file named &lt;code&gt;example.ex&lt;/code&gt;:</source>
          <target state="translated">对于那些喜欢断点但对可视调试器非常感兴趣的人，Erlang / OTP附带了一个图形调试器，命名为 &lt;code&gt;:debugger&lt;/code&gt; 。让我们在名为 &lt;code&gt;example.ex&lt;/code&gt; 的文件中定义一个模块：</target>
        </trans-unit>
        <trans-unit id="cfae34045d5d895009311d2a2a010463848d8c45" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module:</source>
          <target state="translated">对于那些喜欢断点但对可视调试器非常感兴趣的人，Erlang / OTP附带了一个图形调试器，命名为 &lt;code&gt;:debugger&lt;/code&gt; 。让我们定义一个模块：</target>
        </trans-unit>
        <trans-unit id="bc2d3f32f1c4138eee3831b35b324f9d5504e4b5" translate="yes" xml:space="preserve">
          <source>For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value.</source>
          <target state="translated">对于独特的注册表,它可以用来根据键是否与某一特定值相匹配而有条件地取消注册。</target>
        </trans-unit>
        <trans-unit id="14cd0b7637eff1b0c6bd870cfbdfa9301754b7b7" translate="yes" xml:space="preserve">
          <source>For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up.</source>
          <target state="translated">对于唯一的注册表,必须进行单一分区查询。对于重复的注册表,必须查找所有分区。</target>
        </trans-unit>
        <trans-unit id="a33570d2441921e7831b3c41af0473896917c621" translate="yes" xml:space="preserve">
          <source>For unique registries:</source>
          <target state="translated">对于独特的登记册:</target>
        </trans-unit>
        <trans-unit id="a494479b1595316138e63803f01b27c1d049ecb0" translate="yes" xml:space="preserve">
          <source>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</source>
          <target state="translated">对于变量来说,任何以下划线开头的标识符都表示一个未使用的变量。例如:</target>
        </trans-unit>
        <trans-unit id="c93842334df0e58537ff9e4564650c5a06d71f1b" translate="yes" xml:space="preserve">
          <source>Forces the current group to be unfit.</source>
          <target state="translated">强制当前组不适合。</target>
        </trans-unit>
        <trans-unit id="c5bf5789dde7373724874c65a12c156bc9c3ab1f" translate="yes" xml:space="preserve">
          <source>Forces the disconnection of a node.</source>
          <target state="translated">强制断开一个节点的连接。</target>
        </trans-unit>
        <trans-unit id="815a28d19a43ab21cf99300b9b2fd43fa459fe43" translate="yes" xml:space="preserve">
          <source>Forces the path to be a relative path.</source>
          <target state="translated">强制将路径设置为相对路径。</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="5c35ec0ad733522cc571cfec85232066d155794d" translate="yes" xml:space="preserve">
          <source>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</source>
          <target state="translated">通过将命名的ANSI序列转换为实际的ANSI代码,形成一个类似chardata的参数。</target>
        </trans-unit>
        <trans-unit id="2207193e5d684c4dc9f415ae14757dea81eca345" translate="yes" xml:space="preserve">
          <source>Formats a file.</source>
          <target state="translated">对文件进行格式化。</target>
        </trans-unit>
        <trans-unit id="cafa245a564712637537f38b69c740ea4dde1a5f" translate="yes" xml:space="preserve">
          <source>Formats a given document for a given width.</source>
          <target state="translated">对给定宽度的文档进行格式化。</target>
        </trans-unit>
        <trans-unit id="8dfa3afe7b66a75ca4db90cdffb1c56ec5f2cef4" translate="yes" xml:space="preserve">
          <source>Formats an exit. It returns a string.</source>
          <target state="translated">形成一个出口。它返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="6efb90c18f18ca530ad6f75b186ea9a0dab0abb7" translate="yes" xml:space="preserve">
          <source>Formats and truncates messages on the client to avoid clogging &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; backends.</source>
          <target state="translated">在客户端上格式化和截断消息，以避免阻塞&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;后端。</target>
        </trans-unit>
        <trans-unit id="56622496774bb19434d2ebee47141c996a87f22d" translate="yes" xml:space="preserve">
          <source>Formats date as chardata.</source>
          <target state="translated">格式化日期为chardata。</target>
        </trans-unit>
        <trans-unit id="027d7a70820717a59658836a98131d6522ec7975" translate="yes" xml:space="preserve">
          <source>Formats filters used to constrain cases to be run.</source>
          <target state="translated">格式化过滤器,用于限制要运行的案例。</target>
        </trans-unit>
        <trans-unit id="8c5df1d8fe3d3f335538a7bdda896042d42452a8" translate="yes" xml:space="preserve">
          <source>Formats received datetime into a string.</source>
          <target state="translated">将收到的日期时间格式化为一个字符串。</target>
        </trans-unit>
        <trans-unit id="aa53a753f568d1640d41923f79bf478cc8554997" translate="yes" xml:space="preserve">
          <source>Formats the error reason returned by &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;ensure_started/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unload/1&quot;&gt;&lt;code&gt;unload/1&lt;/code&gt;&lt;/a&gt;, returns a string.</source>
          <target state="translated">格式化由&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ensure_started/2&quot;&gt; &lt;code&gt;ensure_started/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unload/1&quot;&gt; &lt;code&gt;unload/1&lt;/code&gt; &lt;/a&gt;返回的错误原因，返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="e18bb89882580c7f86301b123f406d45a0f80a81" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces.</source>
          <target state="translated">格式化给定的 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; ，如stacktraces中所示。</target>
        </trans-unit>
        <trans-unit id="7f7ec50c392208c557864813c0cfdc9b2645d9c5" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces. If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">格式化给定的 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; ，如stacktraces中所示。如果任何值为 &lt;code&gt;nil&lt;/code&gt; ，则将其省略。</target>
        </trans-unit>
        <trans-unit id="aa90b5e3e8aaedcbfa1f49413d30ef681c6976ab" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, and &lt;code&gt;column&lt;/code&gt; as shown in stacktraces.</source>
          <target state="translated">格式化给定的 &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;line&lt;/code&gt; 和 &lt;code&gt;column&lt;/code&gt; ，如stacktraces所示。</target>
        </trans-unit>
        <trans-unit id="43daea1857449413e5d2961950390283bfbd89a9" translate="yes" xml:space="preserve">
          <source>Formats the given code &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">格式化给定的代码 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e9ff0af2c46ca0408f0eb37c63e3365599d3452" translate="yes" xml:space="preserve">
          <source>Formats the given files and patterns.</source>
          <target state="translated">对给定的文件和模式进行格式化。</target>
        </trans-unit>
        <trans-unit id="60cbeba6574b12f984495c88bbbacdd53f31a94a" translate="yes" xml:space="preserve">
          <source>Formats the location for &lt;a href=&quot;#whereami/3&quot;&gt;&lt;code&gt;whereami/3&lt;/code&gt;&lt;/a&gt; prying.</source>
          <target state="translated">格式化&lt;a href=&quot;#whereami/3&quot;&gt; &lt;code&gt;whereami/3&lt;/code&gt; &lt;/a&gt;撬动的位置。</target>
        </trans-unit>
        <trans-unit id="095114a79701908ee2dfdcd7beb556b92bb7fa82" translate="yes" xml:space="preserve">
          <source>Formats the stacktrace.</source>
          <target state="translated">形成堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bc17a3e28e6db9da82c06d3e64dd8f9133ab1362" translate="yes" xml:space="preserve">
          <source>Formats time as chardata.</source>
          <target state="translated">将时间格式化为chardata。</target>
        </trans-unit>
        <trans-unit id="5fe0bd39dac4ab949c5775de27530dde1ae6b8b7" translate="yes" xml:space="preserve">
          <source>Formats time taken running the test suite.</source>
          <target state="translated">格式化运行测试套件的时间。</target>
        </trans-unit>
        <trans-unit id="15bac6318ac5108c02b6ce4ab557e2ea1f9cdf7e" translate="yes" xml:space="preserve">
          <source>Formatted text output</source>
          <target state="translated">格式化文本输出</target>
        </trans-unit>
        <trans-unit id="c66bee8a4119b5327ef887f4d0279de0d7aa74f7" translate="yes" xml:space="preserve">
          <source>Formatters are &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s specified during ExUnit configuration that receive a series of events as casts.</source>
          <target state="translated">格式化是&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; ExUnit配置接收一系列事件的强制转换的过程中指定秒。</target>
        </trans-unit>
        <trans-unit id="c4eab01558e7f8dfc62c9bd7e738281bda6c0c43" translate="yes" xml:space="preserve">
          <source>Formatting options</source>
          <target state="translated">格式化选项</target>
        </trans-unit>
        <trans-unit id="d313dfa968201dd94ad67d87fc3344bb38c0890c" translate="yes" xml:space="preserve">
          <source>Formatting syntax</source>
          <target state="translated">格式化语法</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="8b2cd2532672c31ff20ceae8b0d526cd937086f0" translate="yes" xml:space="preserve">
          <source>Forwards the error to the current process.</source>
          <target state="translated">将错误转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="9fdf06a3445d03e7647fe9c67a18a17eb8735986" translate="yes" xml:space="preserve">
          <source>Forwards the message to the current process.</source>
          <target state="translated">将消息转发给当前进程。</target>
        </trans-unit>
        <trans-unit id="39a119adde6f197e8aa3e8c2dbd49285e486f01b" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">小&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html#add/2&quot;&gt; &lt;code&gt;NaiveDateTime.add/2&lt;/code&gt; &lt;/a&gt;精度与NaiveDateTime.add / 2相似，保持不变。</target>
        </trans-unit>
        <trans-unit id="addaa186164be6af6cfe3af8285a06cb4198e95d" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;naivedatetime#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">小&lt;a href=&quot;naivedatetime#add/2&quot;&gt; &lt;code&gt;NaiveDateTime.add/2&lt;/code&gt; &lt;/a&gt;精度与NaiveDateTime.add / 2相似，保持不变。</target>
        </trans-unit>
        <trans-unit id="4802179f7c5db9ab1d4360e530bc8c507bf436cc" translate="yes" xml:space="preserve">
          <source>Framed.</source>
          <target state="translated">Framed.</target>
        </trans-unit>
        <trans-unit id="61df51b01c40ba0a9247aa6363331261830b3b95" translate="yes" xml:space="preserve">
          <source>From Elixir v1.10, Elixir's Logger is fully integrated with Erlang's logger. They share the same &lt;a href=&quot;#level/0&quot;&gt;&lt;code&gt;Logger.level/0&lt;/code&gt;&lt;/a&gt;, any metadata set with &lt;a href=&quot;#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; applies to both, and so on.</source>
          <target state="translated">从Elixir v1.10开始，Elixir的Logger与Erlang的logger完全集成。它们共享相同的&lt;a href=&quot;#level/0&quot;&gt; &lt;code&gt;Logger.level/0&lt;/code&gt; &lt;/a&gt;，使用&lt;a href=&quot;#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;设置的任何元数据都适用于两者，依此类推。</target>
        </trans-unit>
        <trans-unit id="37cd4097eb3a24362095532952b9b30616bd33e9" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under &lt;code&gt;MyApp&lt;/code&gt;, you can alias the modules &lt;code&gt;MyApp.Foo&lt;/code&gt;, &lt;code&gt;MyApp.Bar&lt;/code&gt; and &lt;code&gt;MyApp.Baz&lt;/code&gt; at once as follows:</source>
          <target state="translated">从Elixir v1.2开始，可以一次别名，导入或需要多个模块。一旦我们开始嵌套模块，这将特别有用，这在构建Elixir应用程序时非常常见。例如，假设您有一个应用程序，其中所有模块都嵌套在 &lt;code&gt;MyApp&lt;/code&gt; 下，则可以一次对模块 &lt;code&gt;MyApp.Foo&lt;/code&gt; ， &lt;code&gt;MyApp.Bar&lt;/code&gt; 和 &lt;code&gt;MyApp.Baz&lt;/code&gt; 进行别名，如下所示：</target>
        </trans-unit>
        <trans-unit id="5f129d8dac3eb2b485d35cfaa8fcb065c8677f2f" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, protocol consolidation happens automatically for all projects. We will build our own project in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">从Elixir v1.2开始，所有项目都会自动进行协议合并。我们将在&lt;strong&gt;&lt;em&gt;Mix and OTP指南中&lt;/em&gt;&lt;/strong&gt;构建自己的项目。</target>
        </trans-unit>
        <trans-unit id="a9cab3793941ece60ffc8a0b775c34f6a348677a" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 21, &lt;code&gt;:handle_sasl_reports&lt;/code&gt; only has an effect if &lt;code&gt;:handle_otp_reports&lt;/code&gt; is true.</source>
          <target state="translated">从Erlang / OTP 21开始，只有 &lt;code&gt;:handle_otp_reports&lt;/code&gt; 为true时， &lt;code&gt;:handle_sasl_reports&lt;/code&gt; 才有效。</target>
        </trans-unit>
        <trans-unit id="1b5ac9d2f1ffaa0f16939a6691b3606f6f5495e8" translate="yes" xml:space="preserve">
          <source>From inside &lt;code&gt;bar@computer-name&lt;/code&gt;, we can now spawn a task directly on the other node via the supervisor:</source>
          <target state="translated">现在，在 &lt;code&gt;bar@computer-name&lt;/code&gt; 内部，我们可以通过主管在另一个节点上直接生成任务：</target>
        </trans-unit>
        <trans-unit id="cee07fcd21c8e4081421ab00fc5d8c03d08b554f" translate="yes" xml:space="preserve">
          <source>From now on, ExUnit will not run any test that has the &lt;code&gt;:external&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;. This behaviour can be reversed with the &lt;code&gt;:include&lt;/code&gt; option which is usually passed through the command line:</source>
          <target state="translated">从现在开始，ExUnit将不会运行任何将 &lt;code&gt;:external&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; 的测试。可以通过通常在命令行中传递的 &lt;code&gt;:include&lt;/code&gt; 选项来逆转此行为：</target>
        </trans-unit>
        <trans-unit id="3c26276a10f65beef569c18570dfcc2f42f56636" translate="yes" xml:space="preserve">
          <source>From now on, we will be using the term &quot;event handler&quot; to refer to your custom backend, as we head into implementation details.</source>
          <target state="translated">从现在开始,我们将使用术语 &quot;事件处理程序 &quot;来指代你的自定义后端,因为我们将进入实施细节。</target>
        </trans-unit>
        <trans-unit id="938617f06857d43f6a085cfd6bce09c1655cac4a" translate="yes" xml:space="preserve">
          <source>From our quick exploration, we could conclude that we should use &lt;code&gt;Node.spawn_link/2&lt;/code&gt; to spawn processes on a remote node every time we need to do a distributed computation. However, we have learned throughout this guide that spawning processes outside of supervision trees should be avoided if possible, so we need to look for other options.</source>
          <target state="translated">从我们的快速探索中，我们可以得出结论，每次需要进行分布式计算时，都应该使用 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 在远程节点上生成进程。但是，我们在整个指南中了解到，如果可能，应避免在监督树之外生成程序，因此我们需要寻找其他选择。</target>
        </trans-unit>
        <trans-unit id="4db16168eb1bd7c62518bc09890c1b7ba6baa6ce" translate="yes" xml:space="preserve">
          <source>From the printed information, we can see far fewer files are generated. The generated &lt;code&gt;mix.exs&lt;/code&gt; file is different too. Let&amp;rsquo;s take a look (comments have been removed):</source>
          <target state="translated">从打印的信息中，我们可以看到生成的文件要少得多。生成的 &lt;code&gt;mix.exs&lt;/code&gt; 文件也不同。让我们看一下（注释已删除）：</target>
        </trans-unit>
        <trans-unit id="d86c7074fa10260d3d9ae0cadb6b7bff099b2b69" translate="yes" xml:space="preserve">
          <source>Full month name</source>
          <target state="translated">全月名称</target>
        </trans-unit>
        <trans-unit id="2298064d1fda3e808dc04798e3aef0bd717a3cbf" translate="yes" xml:space="preserve">
          <source>Full name of day</source>
          <target state="translated">日的全称</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="8e40024a6b83dbe7056d1e4a40db12942b440d4e" translate="yes" xml:space="preserve">
          <source>Function Arguments</source>
          <target state="translated">函数参数</target>
        </trans-unit>
        <trans-unit id="bc1254dc5150511a2a061bfd2a8e778f130ed9a6" translate="yes" xml:space="preserve">
          <source>Function and variable names</source>
          <target state="translated">函数和变量名称</target>
        </trans-unit>
        <trans-unit id="83ade9ad4e94b4c5006286b88e8447b8a91c444a" translate="yes" xml:space="preserve">
          <source>Function and variable names have the following syntax: A &lt;em&gt;lowercase ASCII letter&lt;/em&gt; or an &lt;em&gt;underscore&lt;/em&gt;, followed by any number of &lt;em&gt;lowercase or uppercase ASCII letters&lt;/em&gt;, &lt;em&gt;numbers&lt;/em&gt;, or &lt;em&gt;underscores&lt;/em&gt;. Optionally they can end in either an &lt;em&gt;exclamation mark&lt;/em&gt; or a &lt;em&gt;question mark&lt;/em&gt;.</source>
          <target state="translated">函数和变量名称具有以下语法：&lt;em&gt;小写ASCII字母&lt;/em&gt;或&lt;em&gt;下划线&lt;/em&gt;，后跟任意数量的&lt;em&gt;小写或大写ASCII字母&lt;/em&gt;，&lt;em&gt;数字&lt;/em&gt;或&lt;em&gt;下划线&lt;/em&gt;。任选地，他们可以在任一个端&lt;em&gt;感叹号&lt;/em&gt;或&lt;em&gt;问号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="317d75f3496ca96594673f20ba1da34b938abdcd" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does (known as &quot;implicit try&quot;). For example, the following two functions are equivalent:</source>
          <target state="translated">功能团体支持 &lt;code&gt;rescue&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; ，和 &lt;code&gt;else&lt;/code&gt; 作为&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt;也（被称为&amp;ldquo;隐性试&amp;rdquo;）。例如，以下两个功能是等效的：</target>
        </trans-unit>
        <trans-unit id="23cced316c3006e2ae03dfcedc7e3c98513a344d" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does. For example, the following two functions are equivalent:</source>
          <target state="translated">功能主体像&lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt;一样支持 &lt;code&gt;rescue&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 功能。例如，以下两个功能是等效的：</target>
        </trans-unit>
        <trans-unit id="a06abcd236c2b1c30e0ad208ebb8f15fa6b429ec" translate="yes" xml:space="preserve">
          <source>Function capturing</source>
          <target state="translated">功能捕获</target>
        </trans-unit>
        <trans-unit id="f1329761aa64d73b0a0135229f12fe0d0ace1793" translate="yes" xml:space="preserve">
          <source>Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:</source>
          <target state="translated">函数声明还支持守护和多子句。如果一个函数有多个子句,Elixir会尝试每个子句,直到找到匹配的子句。下面是一个检查给定数字是否为零的函数的实现。</target>
        </trans-unit>
        <trans-unit id="2a8ac45592076c6753dc5eab45709c494a73fe32" translate="yes" xml:space="preserve">
          <source>Function names may also start with an underscore. Such functions are never imported by default:</source>
          <target state="translated">函数名称也可以以下划线开头。默认情况下,这些函数不会被导入。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
