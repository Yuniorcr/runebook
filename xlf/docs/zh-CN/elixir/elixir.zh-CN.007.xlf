<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="b6e83d3c9cef0e0783f020702595feef71f3f20e" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;uri#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">非映射作为&lt;a href=&quot;uri#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="071e8151474691189ee1733bdecf01a3f3e2cb81" translate="yes" xml:space="preserve">
          <source>Non-qualified calls (local calls)</source>
          <target state="translated">不合格电话(本地电话)</target>
        </trans-unit>
        <trans-unit id="53cb3754c560024cfd1bcc5260b860f30909000c" translate="yes" xml:space="preserve">
          <source>Non-qualified calls, such as &lt;code&gt;add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscore. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">非限定调用（例如 &lt;code&gt;add(1, 2)&lt;/code&gt; 必须以下划线或Unicode字母（大写或大写字母除外）开头。可以继续使用Unicode字母，数字和下划线序列进行呼叫。通话可能以 &lt;code&gt;?&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b40e406bdf08c15d5973db15d0796f73afa2bc3f" translate="yes" xml:space="preserve">
          <source>Normal color or intensity.</source>
          <target state="translated">正常的颜色或强度。</target>
        </trans-unit>
        <trans-unit id="16efb8f5278c1947b297b82bf3c74d4bdac2d0d7" translate="yes" xml:space="preserve">
          <source>Normalizes an exception, converting Erlang exceptions to Elixir exceptions.</source>
          <target state="translated">规范化异常,将 Erlang 异常转换为 Elixir 异常。</target>
        </trans-unit>
        <trans-unit id="ca65eca931881f00085a8c21384007ac72711fde" translate="yes" xml:space="preserve">
          <source>Normalizes and formats any throw/error/exit.</source>
          <target state="translated">规范和格式化任何抛出/错误/退出。</target>
        </trans-unit>
        <trans-unit id="d040545513c396d6f00a60b9e02e4a5efcfb1b55" translate="yes" xml:space="preserve">
          <source>Normalizes and formats throw/errors/exits and stacktraces.</source>
          <target state="translated">规范和格式化抛出/错误/退出和堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="343f0ad200dae1f7321bdbca2861d3e1cec1c9d9" translate="yes" xml:space="preserve">
          <source>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.</source>
          <target state="translated">并不是所有的表达方式都可以用在卫句中,而是只有少数几种。这是一个刻意的选择。这样一来,Elixir(和Erlang)可以确保在执行guards时不会发生任何不好的事情,也不会在任何地方发生突变。这也让编译器能够有效地优化与guards相关的代码。</target>
        </trans-unit>
        <trans-unit id="63cc6d4577351584189eae49ee593bacbcaa1a41" translate="yes" xml:space="preserve">
          <source>Not allowed in guard clauses.</source>
          <target state="translated">不允许在防护条款中使用。</target>
        </trans-unit>
        <trans-unit id="4f4ee146dc15494c81d4bd8a2a2759820080e7c5" translate="yes" xml:space="preserve">
          <source>Not framed or encircled.</source>
          <target state="translated">没有装裱或包围。</target>
        </trans-unit>
        <trans-unit id="91158d4ebf885b7c2cce115618384afcd3d60c6c" translate="yes" xml:space="preserve">
          <source>Not italic.</source>
          <target state="translated">不是斜体。</target>
        </trans-unit>
        <trans-unit id="e8cbaff7c13d97516b633b0d9d10f2ab0d66c800" translate="yes" xml:space="preserve">
          <source>Not only that, as you create new buckets on the terminal, you should see new processes spawned in the supervision tree shown in Observer:</source>
          <target state="translated">不仅如此,当你在终端上创建新的桶时,你应该会在Observer中显示的监督树中看到新的进程被催生出来。</target>
        </trans-unit>
        <trans-unit id="8ece420ef660602018d9d85c815c1206e83a9313" translate="yes" xml:space="preserve">
          <source>Not overlined.</source>
          <target state="translated">未划线。</target>
        </trans-unit>
        <trans-unit id="12d014121a6d98d766e19560d6f8af18c0e40cbc" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Process.monitor(pid)&lt;/code&gt; returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can &lt;code&gt;flush/0&lt;/code&gt; all messages and notice a &lt;code&gt;:DOWN&lt;/code&gt; message arrived, with the exact reference returned by &lt;code&gt;monitor&lt;/code&gt;, notifying that the bucket process exited with reason &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">注意 &lt;code&gt;Process.monitor(pid)&lt;/code&gt; 返回一个唯一引用，该引用使我们能够将即将出现的消息与该监视引用进行匹配。停止代理后，我们可以 &lt;code&gt;flush/0&lt;/code&gt; 所有消息并注意到 &lt;code&gt;:DOWN&lt;/code&gt; 消息到达，并且 &lt;code&gt;monitor&lt;/code&gt; 返回了确切的引用，通知存储桶进程退出的原因是 &lt;code&gt;:normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3f40b5039d7c318694befb342ce3f4c9f0f60a" translate="yes" xml:space="preserve">
          <source>Note a tag can be set in two different ways:</source>
          <target state="translated">请注意,一个标签可以有两种不同的设置方式。</target>
        </trans-unit>
        <trans-unit id="c3377b2b2eb71be892a3e682ccebe7f9b31d7572" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;:transient&lt;/code&gt; type is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;:shutdown&lt;/code&gt;, not &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">还应注意 &lt;code&gt;:transient&lt;/code&gt; 类型几乎没有实际用途，因为当监视树终止时，原因设置为 &lt;code&gt;:shutdown&lt;/code&gt; ，而不是 &lt;code&gt;:normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c528946c2af34a0e5a1e8d711f96487c6c795447" translate="yes" xml:space="preserve">
          <source>Note anonymous functions can also have multiple clauses and guards:</source>
          <target state="translated">请注意匿名函数也可以有多个子句和守卫。</target>
        </trans-unit>
        <trans-unit id="3d3adc9c8853ececa9befa7c8ce8ff49c5919675" translate="yes" xml:space="preserve">
          <source>Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example:</source>
          <target state="translated">注意描述块不能嵌套。开发者应该在命名设置的基础上进行构建,而不是依靠层次结构进行构成。例如</target>
        </trans-unit>
        <trans-unit id="a5ca0f4688d0116095aeec4a9d739e406b9afeec" translate="yes" xml:space="preserve">
          <source>Note each entry in the binary pattern is expected to match exactly 8 bits. If we want to match on a binary of unknown size, it is possible by using the binary modifier at the end of the pattern:</source>
          <target state="translated">请注意,二进制模式中的每个条目都要精确匹配8位。如果我们想在一个未知大小的二进制上进行匹配,可以在模式的最后使用二进制修饰符。</target>
        </trans-unit>
        <trans-unit id="e1393c185477299f5e854d4848419bacfa99c239" translate="yes" xml:space="preserve">
          <source>Note it is important to recompile a file's dependencies as there are often compile time dependencies between them.</source>
          <target state="translated">请注意,重新编译一个文件的依赖关系是很重要的,因为它们之间往往存在编译时的依赖关系。</target>
        </trans-unit>
        <trans-unit id="127cdeb36c75a2e9ea3ccb032068074d455163d3" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt; is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.</source>
          <target state="translated">请注意，通常在启动过程的早期就调用&lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt;，因此，如果需要在提供程序中使用应用程序，则有责任启动它。</target>
        </trans-unit>
        <trans-unit id="98fcc4c0b233355a84f821a3c513063ad4e24444" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt; can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the &lt;code&gt;from&lt;/code&gt; argument somehow).</source>
          <target state="translated">请注意，&lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt;可以从任何进程调用，而不仅仅是最初接收到该调用的GenServer（只要该GenServer 以某种方式传达了 &lt;code&gt;from&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="e1626fef0c1a33798d2c34dfc74515bf8d5c377d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">请注意， &lt;code&gt;String.t()&lt;/code&gt; 和 &lt;code&gt;binary()&lt;/code&gt; 等效于分析工具。尽管对于那些阅读文档的人， &lt;code&gt;String.t()&lt;/code&gt; 暗示它是UTF-8编码的二进制文件。</target>
        </trans-unit>
        <trans-unit id="8ceb120a9be7ed748230ca821c05f6918e48cd56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\\&lt;/code&gt; can't be used with anonymous functions because they can only have a sole arity.</source>
          <target state="translated">请注意， &lt;code&gt;\\&lt;/code&gt; 不能与匿名函数一起使用，因为它们只能具有唯一性。</target>
        </trans-unit>
        <trans-unit id="284b6400c5d9fc089c636125d995e2b0e56e6990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;^x&lt;/code&gt; always refers to the value of &lt;code&gt;x&lt;/code&gt; prior to the match. The following example will match:</source>
          <target state="translated">请注意， &lt;code&gt;^x&lt;/code&gt; 始终指匹配之前的 &lt;code&gt;x&lt;/code&gt; 值。以下示例将匹配：</target>
        </trans-unit>
        <trans-unit id="c1877a8124459f28213b53d05b5f96adf2e6ee0c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;alias&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt;, which allows you to set aliases inside specific functions:</source>
          <target state="translated">请注意， &lt;code&gt;alias&lt;/code&gt; 具有&lt;strong&gt;词法范围&lt;/strong&gt;，它允许您在特定函数内设置别名：</target>
        </trans-unit>
        <trans-unit id="5684572f42db95ac181baf9058ba1bcc12e51cad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cast&lt;/code&gt; returns &lt;code&gt;:ok&lt;/code&gt; immediately, regardless of whether &lt;code&gt;agent&lt;/code&gt; (or the node it should live on) exists.</source>
          <target state="translated">请注意，无论是否存在 &lt;code&gt;agent&lt;/code&gt; （或其应驻留的节点）， &lt;code&gt;cast&lt;/code&gt; 都会立即返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5c4acc72c847b14f34cef90da2dbdafe8c0f864" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;defines?&lt;/code&gt; returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling &lt;a href=&quot;#overridable?/2&quot;&gt;&lt;code&gt;overridable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意 &lt;code&gt;defines?&lt;/code&gt; 对于已定义但随后标记为可重写且未提供其他实现的函数和宏，返回false。您可以通过调用&lt;a href=&quot;#overridable?/2&quot;&gt; &lt;code&gt;overridable?/2&lt;/code&gt; &lt;/a&gt;来检查可覆盖状态。</target>
        </trans-unit>
        <trans-unit id="90f8221caf1663dc39261548c92a478da7147d51" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;do/end&lt;/code&gt; become delimiters. The second example would translate to:</source>
          <target state="translated">请注意， &lt;code&gt;do/end&lt;/code&gt; 成为分隔符。第二个示例将转换为：</target>
        </trans-unit>
        <trans-unit id="d9f98e56a6b073dedf21c4fd7053a53e9bd1aea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt; too. This means that we can import specific macros or functions inside function definitions:</source>
          <target state="translated">请注意， &lt;code&gt;import&lt;/code&gt; 也&lt;strong&gt;具有词法范围&lt;/strong&gt;。这意味着我们可以在函数定义中导入特定的宏或函数：</target>
        </trans-unit>
        <trans-unit id="7d91cdd66170ee21978845d99279b84980730cb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt;ing a module automatically &lt;code&gt;require&lt;/code&gt;s it.</source>
          <target state="translated">请注意， &lt;code&gt;import&lt;/code&gt; 模块会自动 &lt;code&gt;require&lt;/code&gt; 它。</target>
        </trans-unit>
        <trans-unit id="ab30e5a1bc4b404e7cb3f7adf25fbc460e6c3561" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;index&lt;/code&gt; is capped at the list length. Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;index&lt;/code&gt; 以列表长度为上限。负索引表示与 &lt;code&gt;list&lt;/code&gt; 末尾的偏移量。</target>
        </trans-unit>
        <trans-unit id="12525ea5b78a44ac5eef68af6cc8e0ed2ce006ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;serve/1&lt;/code&gt; is an infinite loop called sequentially inside &lt;code&gt;loop_acceptor/1&lt;/code&gt;, so the tail call to &lt;code&gt;loop_acceptor/1&lt;/code&gt; is never reached and could be avoided. However, as we shall see, we will need to execute &lt;code&gt;serve/1&lt;/code&gt; in a separate process, so we will need that tail call soon.</source>
          <target state="translated">请注意， &lt;code&gt;serve/1&lt;/code&gt; 是在 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 内部顺序调用的无限循环，因此永远不会到达 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 的尾部调用，因此可以避免。但是，正如我们将看到的那样，我们将需要在一个单独的进程中执行 &lt;code&gt;serve/1&lt;/code&gt; ，因此我们将需要尽快执行该tail调用。</target>
        </trans-unit>
        <trans-unit id="de063b80d08dcad20f96832929534bd43e718138" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; started with &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the &lt;code&gt;:normal&lt;/code&gt; reasons in case it is configured to trap exits in the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">请注意，以&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;已链接到父进程，如果父进程崩溃，它将退出。如果将GenServer 配置为在&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调中捕获出口，则由于 &lt;code&gt;:normal&lt;/code&gt; 原因，GenServer也将退出。</target>
        </trans-unit>
        <trans-unit id="08443544f9b5807d8ae2ca59e1cdfa2a987f5f51" translate="yes" xml:space="preserve">
          <source>Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with &lt;code&gt;:normal&lt;/code&gt; reason.</source>
          <target state="translated">请注意，以该功能启动的主管与父流程链接，不仅在崩溃时退出，而且在父流程出于 &lt;code&gt;:normal&lt;/code&gt; 原因退出时也会退出。</target>
        </trans-unit>
        <trans-unit id="954d4540ce99f199a6a0a382f7d567881ea15fd5" translate="yes" xml:space="preserve">
          <source>Note that all Elixir operators are also valid atoms. Therefore &lt;code&gt;:+&lt;/code&gt;, &lt;code&gt;:@&lt;/code&gt;, &lt;code&gt;:|&amp;gt;&lt;/code&gt;, and others are all valid atoms. The full description of valid atoms is available in the Syntax Reference, this document covers only the rules for identifier-based atoms.</source>
          <target state="translated">请注意，所有Elixir运算符也是有效原子。因此 &lt;code&gt;:+&lt;/code&gt; ， &lt;code&gt;:@&lt;/code&gt; ， &lt;code&gt;:|&amp;gt;&lt;/code&gt; ，和其他人都是有效的原子。有效原子的完整描述可在&amp;ldquo;语法参考&amp;rdquo;中找到，该文档仅涵盖基于标识符的原子的规则。</target>
        </trans-unit>
        <trans-unit id="ac0b3ec8f1db4589a8f8e1eb136c0f7227194b62" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:function&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;logger#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are extracted from Erlang/OTP crash reports and available only in those cases.</source>
          <target state="translated">请注意，所有元数据都是可选的，可能并不总是可用。的 &lt;code&gt;:module&lt;/code&gt; ， &lt;code&gt;:function&lt;/code&gt; ， &lt;code&gt;:line&lt;/code&gt; 使用时，和类似的元数据被自动包括&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;宏。&lt;a href=&quot;logger#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt;默认不包含 &lt;code&gt;:pid&lt;/code&gt; 以外的任何元数据。其他元数据，例如 &lt;code&gt;:crash_reason&lt;/code&gt; ， &lt;code&gt;:initial_call&lt;/code&gt; 和 &lt;code&gt;:registered_name&lt;/code&gt; 是从Erlang / OTP崩溃报告中提取的，仅在那些情况下可用。</target>
        </trans-unit>
        <trans-unit id="76c7fd844c6a4b97c6af78f0323e658a0263e3d7" translate="yes" xml:space="preserve">
          <source>Note that all tests are included by default, so unless they are excluded first (either in the test helper or via the &lt;code&gt;--exclude&lt;/code&gt; option) the &lt;code&gt;--include&lt;/code&gt; option has no effect.</source>
          <target state="translated">请注意，所有的测试都包括默认，因此除非他们首先排除了（无论是在测试助手或通过 &lt;code&gt;--exclude&lt;/code&gt; 选项）的 &lt;code&gt;--include&lt;/code&gt; 选项没有任何效果。</target>
        </trans-unit>
        <trans-unit id="764accc79b7e7fbac8971b738cd4bab00fe7637c" translate="yes" xml:space="preserve">
          <source>Note that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">注意,一个IO流是有副作用的,每一次你去看流,可能会得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="edad52b62a5c2594d2df1d229d1b57a6b8821bde" translate="yes" xml:space="preserve">
          <source>Note that both UTC and Standard offsets will be taken into account when comparison is done.</source>
          <target state="translated">请注意,在进行比较时,UTC和标准偏移量都将被考虑在内。</target>
        </trans-unit>
        <trans-unit id="406fc1b32b85677464e45a089ad7df7b494e5b86" translate="yes" xml:space="preserve">
          <source>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">需要注意的是,在低内存条件下监督大量孩子时,调用此函数可能会导致内存不足的异常。</target>
        </trans-unit>
        <trans-unit id="fabe66319df854999ff8cf0e3d6fa8aaf6d30285" translate="yes" xml:space="preserve">
          <source>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.</source>
          <target state="translated">请注意,在Elixir中以charlists形式给出的文件名总是以UTF-8编码处理。特别是,我们希望shell和操作系统被配置为使用UTF-8编码。二进制文件名被认为是原始文件名,并按原样传递给操作系统。</target>
        </trans-unit>
        <trans-unit id="103cdbd91afa6836ea7762204d98d6131437f8ac" translate="yes" xml:space="preserve">
          <source>Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions.</source>
          <target state="translated">请注意,对于有许多分区的大型注册表来说,这样做的成本很高,因为它是通过连接所有分区来建立结果的。</target>
        </trans-unit>
        <trans-unit id="f080d783bf0fd06342e1a61dcd384d6c89650c0e" translate="yes" xml:space="preserve">
          <source>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</source>
          <target state="translated">需要注意的是,对于临时子代,当子代终止时,子代规范会自动删除,因此无法重新启动此类子代。</target>
        </trans-unit>
        <trans-unit id="997a3967a5f4bb658a4ce5f677487cb8a5c8fec2" translate="yes" xml:space="preserve">
          <source>Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, &lt;a href=&quot;#alive?/1&quot;&gt;&lt;code&gt;alive?/1&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; but its PID will be part of the list of PIDs returned by this function.</source>
          <target state="translated">请注意，如果某个进程正在退出，则认为该进程已存在但尚未恢复。这意味着对于该过程，&lt;a href=&quot;#alive?/1&quot;&gt; &lt;code&gt;alive?/1&lt;/code&gt; &lt;/a&gt;将返回 &lt;code&gt;false&lt;/code&gt; ,但其PID将成为此函数返回的PID列表的一部分。</target>
        </trans-unit>
        <trans-unit id="a43e287fde89bfb0a88b95e0c986594cfaffdabd" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;:delayed_write&lt;/code&gt; was used when opening the file, &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; might return an old write error and not even try to close the file. See &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">请注意，如果在打开文件时使用了 &lt;code&gt;:delayed_write&lt;/code&gt; 选项，则&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt;可能会返回旧的写入错误，甚至不会尝试关闭文件。有关更多信息，请参见&lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f646c93d4eef7c70fd05d7240d6a69876a9baf5" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">请注意，如果您将&lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;结构作为第一个参数传递，同时还传递了 &lt;code&gt;opts&lt;/code&gt; ，则它们将与具有优先级的 &lt;code&gt;opts&lt;/code&gt; 合并。</target>
        </trans-unit>
        <trans-unit id="64b52ff72a460cecc390aabeeeee6af670211c1b" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check &lt;a href=&quot;#get_and_update_in/2&quot;&gt;&lt;code&gt;get_and_update_in/2&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">请注意，为了使此宏正常工作，完整的路径必须始终由该宏可见。有关支持的路径表达式的更多信息，请检查&lt;a href=&quot;#get_and_update_in/2&quot;&gt; &lt;code&gt;get_and_update_in/2&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9e49d404776bcbe0ae060a73286ea9c896eb6178" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</source>
          <target state="translated">请注意,为了使该宏工作,完整的路径必须始终为该宏所可见。请看下面的路径部分。</target>
        </trans-unit>
        <trans-unit id="bcf88d15a7510f97dbf0ab0147120a93a4cb3ae1" translate="yes" xml:space="preserve">
          <source>Note that in our macro implementation, the sentence was not printed, although it was printed in our function implementation. That&amp;rsquo;s because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our &lt;code&gt;unless&lt;/code&gt; macro to become an &lt;code&gt;if&lt;/code&gt; behind the scenes.</source>
          <target state="translated">注意在我们的宏实现中，虽然语句是在函数实现中打印的，但句子并未打印出来。这是因为在调用函数之前先评估函数调用的参数。但是，宏不评估其参数。相反，它们将参数作为带引号的表达式接收，然后转换为其他带引号的表达式。在这种情况下，我们重写了 &lt;code&gt;unless&lt;/code&gt; 宏，以使其成为幕后的 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="457d54652787a94a3f6b0231b5aed3d435010820" translate="yes" xml:space="preserve">
          <source>Note that inside this new IEx session, we cannot access &lt;code&gt;Hello.world/0&lt;/code&gt;:</source>
          <target state="translated">请注意，在这个新的IEx会话中，我们无法访问 &lt;code&gt;Hello.world/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="501337e40a037ada414b45561640d40bc9bd67c7" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to stop an application explicitly by calling &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;. Regardless of the type of the application, no other applications will be affected.</source>
          <target state="translated">请注意，始终可以通过调用&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;显式停止应用程序。无论应用程序的类型如何，都不会影响其他应用程序。</target>
        </trans-unit>
        <trans-unit id="ff7bd5f130ea7db15204ea66bfeb9aa5a7e91245" translate="yes" xml:space="preserve">
          <source>Note that like the &lt;code&gt;alias&lt;/code&gt; directive, &lt;code&gt;require&lt;/code&gt; is also lexically scoped. We will talk more about macros in a later chapter.</source>
          <target state="translated">请注意，就像 &lt;code&gt;alias&lt;/code&gt; 指令一样， &lt;code&gt;require&lt;/code&gt; 也在词法范围内。我们将在下一章中详细讨论宏。</target>
        </trans-unit>
        <trans-unit id="609fc4219e4f54367072ec4d02e01c554eb9955f" translate="yes" xml:space="preserve">
          <source>Note that on many platforms, only the status codes 0-255 are supported by the operating system.</source>
          <target state="translated">请注意,在许多平台上,操作系统只支持状态码0-255。</target>
        </trans-unit>
        <trans-unit id="058e024bfd4088c93bb70a9d4486efc9cfc43198" translate="yes" xml:space="preserve">
          <source>Note that only integers can be considered inside a range by &lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;in&lt;/code&gt; 范围内只能考虑整数。</target>
        </trans-unit>
        <trans-unit id="3610787e239696d5d39dc8faf6f13f31e98d9fd3" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;keyword#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">请注意，不建议将非空列表作为 &lt;code&gt;collectable&lt;/code&gt; 传递。如果您要收集到非空的关键字列表，请考虑使用&lt;a href=&quot;keyword#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; &lt;/a&gt;。如果要收集到非空列表中，请考虑使用诸如 &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; 东西。</target>
        </trans-unit>
        <trans-unit id="66a707c89c7a375b67feac5256ea470e5723f333" translate="yes" xml:space="preserve">
          <source>Note that popping elements out of tuples is not possible and raises an error.</source>
          <target state="translated">请注意,从元组中弹出元素是不可能的,并且会引起错误。</target>
        </trans-unit>
        <trans-unit id="dcdb0a0d3694177344abe742c5030d4133620456" translate="yes" xml:space="preserve">
          <source>Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: &lt;code&gt;:opaque&lt;/code&gt; and &lt;code&gt;:defaults&lt;/code&gt;.</source>
          <target state="translated">请注意，由于编译器还定义了一些其他元数据，因此有一些保留键将被忽略并在使用时发出警告。当前这些是：： &lt;code&gt;:opaque&lt;/code&gt; 和 &lt;code&gt;:defaults&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f7174f1e0891c9c315cf26472dfe8e8d467ed7d" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">请注意，有时文档中会针对不同的任务提到相同的配置选项。这只是因为它的常见的许多任务阅读和使用相同的配置选项（例如 &lt;code&gt;:erlc_paths&lt;/code&gt; 所使用的&lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt;和其他任务）。</target>
        </trans-unit>
        <trans-unit id="bb4e3794b5d058074ae9fb619182bee5deeb2d26" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">请注意，Elixir中的&lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt;仅在使用__STACKTRACE __ / 0变量进行捕获和救援期间可用。</target>
        </trans-unit>
        <trans-unit id="552be8eaba50f8b9cb5e15b8c46f2e1519134f1f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">请注意，&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议不一定会返回Elixir术语的有效表示形式。在这种情况下，检查结果必须以 &lt;code&gt;#&lt;/code&gt; 开头。例如，检查一个函数将返回：</target>
        </trans-unit>
        <trans-unit id="a210d5a52a6f0f763cbec85671fca9f2120de279" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;start_link&lt;/code&gt; function starts a new process that runs the &lt;code&gt;loop/1&lt;/code&gt; function, starting with an empty map. The &lt;code&gt;loop/1&lt;/code&gt; (private) function then waits for messages and performs the appropriate action for each message. We made &lt;code&gt;loop/1&lt;/code&gt; private by using &lt;code&gt;defp&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. In the case of a &lt;code&gt;:get&lt;/code&gt; message, it sends a message back to the caller and calls &lt;code&gt;loop/1&lt;/code&gt; again, to wait for a new message. While the &lt;code&gt;:put&lt;/code&gt; message actually invokes &lt;code&gt;loop/1&lt;/code&gt; with a new version of the map, with the given &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; stored.</source>
          <target state="translated">请注意， &lt;code&gt;start_link&lt;/code&gt; 函数从一个空映射开始，运行一个运行 &lt;code&gt;loop/1&lt;/code&gt; 函数的新进程。然后， &lt;code&gt;loop/1&lt;/code&gt; （专用）功能等待消息并为每条消息执行适当的操作。我们使用 &lt;code&gt;defp&lt;/code&gt; 而不是 &lt;code&gt;def&lt;/code&gt; 将 &lt;code&gt;loop/1&lt;/code&gt; 设为私有。在 &lt;code&gt;:get&lt;/code&gt; 消息的情况下，它将消息发送回调用者并再次调用 &lt;code&gt;loop/1&lt;/code&gt; ，以等待新消息。虽然 &lt;code&gt;:put&lt;/code&gt; 消息实际上调用 &lt;code&gt;loop/1&lt;/code&gt; 与地图新版本，与给定的 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 存储。</target>
        </trans-unit>
        <trans-unit id="d9f3b685f288df2ac141b75c4120d3ea4cba1aee" translate="yes" xml:space="preserve">
          <source>Note that the Erlang VM (and therefore this function) does not return the current stacktrace but rather the stacktrace of the latest exception. To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">请注意，Erlang VM（以及由此函数）不会返回当前的堆栈跟踪，而是返回最新异常的堆栈跟踪。要检索当前进程的堆栈跟踪，请改用 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61118c7f53d4bda89916029a3a51c482ae9250a8" translate="yes" xml:space="preserve">
          <source>Note that the functions in &lt;code&gt;:digraph&lt;/code&gt; alter the graph structure in-place, this is possible because they are implemented as ETS tables, explained next.</source>
          <target state="translated">注意 &lt;code&gt;:digraph&lt;/code&gt; 中的函数就地改变了图形结构，这是可能的，因为它们被实现为ETS表，下面将进行解释。</target>
        </trans-unit>
        <trans-unit id="642c83993efe9994a761915e7e921044f5f85c3c" translate="yes" xml:space="preserve">
          <source>Note that the purpose of the test is to check whether the registry processes the bucket&amp;rsquo;s shutdown message correctly. The fact that the &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sends us a valid bucket does not mean that the bucket is still alive by the time you call it. For example, it might have crashed for some reason. The following test depicts this situation:</source>
          <target state="translated">请注意，测试的目的是检查注册表是否正确处理了存储桶的关闭消息。该事实 &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 向我们提供有效的水桶并不意味着桶仍然是你怎么称呼它的时候还活着。例如，它可能由于某些原因而崩溃了。以下测试描述了这种情况：</target>
        </trans-unit>
        <trans-unit id="67d98e4f2d8bcb03260e0b9f2837377ff066ec7f" translate="yes" xml:space="preserve">
          <source>Note that the registry uses one ETS table plus two ETS tables per partition.</source>
          <target state="translated">请注意,注册表在每个分区中使用一个ETS表加两个ETS表。</target>
        </trans-unit>
        <trans-unit id="ec636350f4f8e5f34aed230627c7cf0452577a12" translate="yes" xml:space="preserve">
          <source>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</source>
          <target state="translated">请注意,被催生的进程并不与调用者相连,而只与上级相连。这个命令在任务需要执行副作用(比如I/O),而不需要向调用者汇报的情况下很有用。</target>
        </trans-unit>
        <trans-unit id="dd0116a55dff5f2bacdff852b6887f33db51d12e" translate="yes" xml:space="preserve">
          <source>Note that this applies only to the tuple itself, not its contents. For instance, when you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. In other words, tuples and lists in Elixir are capable of sharing their contents. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.</source>
          <target state="translated">注意,这只适用于元组本身,而不是它的内容。例如,当你更新一个元组时,除了被替换的条目外,所有条目都会在新旧元组之间共享。换句话说,Elixir中的元组和列表能够共享其内容。这就减少了语言需要执行的内存分配量,这要归功于语言的不可改变的语义。</target>
        </trans-unit>
        <trans-unit id="772fcfd84a5f9fd2ad0b735b0a19d01baa41c4ae" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;code#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">请注意，如果未加载该功能，则不会加载该模块。检查&lt;a href=&quot;code#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="3a93b64ce36dbd9e66bfd7a4794eac8913433ad9" translate="yes" xml:space="preserve">
          <source>Note that this function does not try to discover the file encoding basing on BOM.</source>
          <target state="translated">需要注意的是,这个函数并不尝试基于BOM来发现文件编码。</target>
        </trans-unit>
        <trans-unit id="fd7297e7a168339d862010e69cb4610a576f96e0" translate="yes" xml:space="preserve">
          <source>Note that this function treats a &lt;code&gt;path&lt;/code&gt; with a leading &lt;code&gt;~&lt;/code&gt; as an absolute one.</source>
          <target state="translated">请注意，此功能将以 &lt;code&gt;~&lt;/code&gt; 开头的 &lt;code&gt;path&lt;/code&gt; 视为绝对路径。</target>
        </trans-unit>
        <trans-unit id="1cfa9837195cf9c63349ac44a72cf8140752983a" translate="yes" xml:space="preserve">
          <source>Note that this not only works with single expressions but also with arbitrary code blocks.</source>
          <target state="translated">注意,这不仅适用于单一表达式,也适用于任意代码块。</target>
        </trans-unit>
        <trans-unit id="14ce19a4da0f58dcf26e71e7c820a5ec0bbf379f" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic. They not only convert charlists to strings, but also integers to strings, atoms to strings, and so on.</source>
          <target state="translated">请注意,这些函数是多态的。它们不仅可以将charlists转换为字符串,还可以将整数转换为字符串,将原子转换为字符串,等等。</target>
        </trans-unit>
        <trans-unit id="43c532218f4ed686a0d71d554c91a77ee3c049fb" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;regex#regex?/1&quot;&gt;&lt;code&gt;Regex.regex?/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">请注意，在保护子句中无效的类型检查不遵循此约定。实例：&lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;regex#regex?/1&quot;&gt; &lt;code&gt;Regex.regex?/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="174cbc748d572204ea1540b27cb5cc59e7b6deca" translate="yes" xml:space="preserve">
          <source>Note that values added to the front are the ones fetched on lookup:</source>
          <target state="translated">注意,添加到前面的值是查找时获取的值。</target>
        </trans-unit>
        <trans-unit id="7c321fccec9582dfce9477fe7768165a7a09b608" translate="yes" xml:space="preserve">
          <source>Note that we have also defined a private function named &lt;code&gt;lookup/2&lt;/code&gt; to help with the common functionality of looking up a bucket and returning its &lt;code&gt;pid&lt;/code&gt; if it exists, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">请注意，我们还定义了一个名为 &lt;code&gt;lookup/2&lt;/code&gt; 的私有函数，以帮助您查找存储桶并返回其 &lt;code&gt;pid&lt;/code&gt; (如果存在）的通用功能，否则返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9412a4887f881774fae5591b90049312660e64f3" translate="yes" xml:space="preserve">
          <source>Note that we need a mechanism to pass the &lt;code&gt;bucket&lt;/code&gt; pid from the callback to the test. We do so by using the &lt;em&gt;test context&lt;/em&gt;. When we return &lt;code&gt;%{bucket: bucket}&lt;/code&gt; from the callback, ExUnit will merge this map into the test context. Since the test context is a map itself, we can pattern match the bucket out of it, providing access to the bucket inside the test:</source>
          <target state="translated">请注意，我们需要一种将 &lt;code&gt;bucket&lt;/code&gt; pid从回调传递到测试的机制。我们通过使用&lt;em&gt;测试上下文来实现&lt;/em&gt;。当我们从回调返回 &lt;code&gt;%{bucket: bucket}&lt;/code&gt; ，ExUnit会将此映射合并到测试上下文中。由于测试上下文本身是一个映射，因此我们可以从中进行模式匹配存储桶，从而提供对测试内部存储桶的访问：</target>
        </trans-unit>
        <trans-unit id="3e819f2e65aae690b63c5af560e6444ef3c30ff3" translate="yes" xml:space="preserve">
          <source>Note that when creating this string representation, the &lt;code&gt;:authority&lt;/code&gt; value will be used if the &lt;code&gt;:host&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Otherwise, the &lt;code&gt;:userinfo&lt;/code&gt;, &lt;code&gt;:host&lt;/code&gt;, and &lt;code&gt;:port&lt;/code&gt; will be used.</source>
          <target state="translated">请注意，在创建此字符串表示形式时，如果 &lt;code&gt;:host&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ,则将使用 &lt;code&gt;:authority&lt;/code&gt; 值。否则，将使用 &lt;code&gt;:userinfo&lt;/code&gt; ， &lt;code&gt;:host&lt;/code&gt; 和 &lt;code&gt;:port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="059596cc4da0ec6ea079bfeb0987398e72e24193" translate="yes" xml:space="preserve">
          <source>Note that when keyword lists are passed as the last argument to a function, if the short-hand syntax is used then the square brackets around the keyword list can be omitted as well. For example, the following:</source>
          <target state="translated">需要注意的是,当关键字列表作为最后一个参数传递给函数时,如果使用了简写语法,那么关键字列表周围的方括号也可以省略。例如,如下。</target>
        </trans-unit>
        <trans-unit id="51593dd72717840f7fb2a715f89be6d7c2e52241" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times and datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir.</source>
          <target state="translated">请注意,虽然ISO 8601允许时间和日期时间指定24:00:00为第二天的零点,但Elixir不支持这种符号。</target>
        </trans-unit>
        <trans-unit id="10328798e18043813d96248d25cbd19fb081be9c" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Leap seconds are not supported as well by the built-in Calendar.ISO.</source>
          <target state="translated">需要注意的是,虽然ISO 8601允许将时间指定为24:00:00作为第二天的零点,但Elixir并不支持这种记法。内置的Calendar.ISO也不支持闰秒。</target>
        </trans-unit>
        <trans-unit id="674d928e8930fc373a1ecef037a0add8d70944ab" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">请注意，您只应提供 &lt;code&gt;:switches&lt;/code&gt; 或 &lt;code&gt;:strict&lt;/code&gt; 选项。如果同时提供两者，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="5618ec783469ef4c54ca8326a639f6727694278b" translate="yes" xml:space="preserve">
          <source>Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets.</source>
          <target state="translated">但请注意,结构体字段是私有的,不能直接访问,请使用本模块中的函数对集合进行操作。</target>
        </trans-unit>
        <trans-unit id="43d19607ee0a232b2886e30e288770f0a0223896" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">请注意，与&lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; &lt;/a&gt;不同，此运算符不仅将布尔值接受任何表达式作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="904787334ac92370c9a9993f8474d839a9d2466c" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#or/2&quot;&gt;&lt;code&gt;or/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">请注意，与&lt;a href=&quot;#or/2&quot;&gt; &lt;code&gt;or/2&lt;/code&gt; &lt;/a&gt;不同，此运算符不仅将布尔值接受任何表达式作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="08cd47820e470aeb0ed46fa6530b94a8d0d659ed" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;task.supervisor#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;task.supervisor#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">请注意，在处理分布式任务时，应使用需要显式模块，函数和参数的&lt;a href=&quot;task.supervisor#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt;函数，而不要使用与匿名函数一起使用的&lt;a href=&quot;task.supervisor#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; &lt;/a&gt;。这是因为匿名函数希望所有涉及的节点上都存在相同的模块版本。检查&lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;模块文档以获取有关分布式过程的更多信息，因为那里描述的限制适用于整个生态系统。</target>
        </trans-unit>
        <trans-unit id="f98570973aa7e2132e68496b2b9ad6d68c9748d2" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:deprecated&lt;/code&gt; key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the &lt;code&gt;@deprecated&lt;/code&gt; attribute:</source>
          <target state="translated">注意 &lt;code&gt;:deprecated&lt;/code&gt; 当开发人员调用功能时，：deprecated键不会发出警告。如果希望代码也发出警告，则可以使用 &lt;code&gt;@deprecated&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="fbe12959616fed170330064dc85549503954ef06" translate="yes" xml:space="preserve">
          <source>Note the British spelling!</source>
          <target state="translated">注意是英式拼法!</target>
        </trans-unit>
        <trans-unit id="b1c5d08584d148be13f621a2c51eacad30bf0769" translate="yes" xml:space="preserve">
          <source>Note the behaviour of those classes may change according to the Unicode and other modifiers:</source>
          <target state="translated">请注意,这些类的行为可能会根据Unicode和其他修改器而改变。</target>
        </trans-unit>
        <trans-unit id="79e188c7e768551ff604bcf40bceebdb7a51cda8" translate="yes" xml:space="preserve">
          <source>Note the capture syntax can also be used as a shortcut for creating functions:</source>
          <target state="translated">注意捕获语法也可以作为创建函数的快捷方式。</target>
        </trans-unit>
        <trans-unit id="bc7df408c1b6e9e0aa62f81ee99961007e92e471" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意药剂惯例是允许的命名与警卫功能/宏 &lt;code&gt;is_&lt;/code&gt; 前缀，如&lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt;。但是，如果函数/宏返回一个布尔值，并且在守卫中是不允许的，则它应该没有前缀，并以问号结尾，例如&lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02e568f28639d3d3cf9153ba1f47b6ffc7ed4a33" translate="yes" xml:space="preserve">
          <source>Note the environment is not returned as it can be accessed via &lt;a href=&quot;#fetch_env/2&quot;&gt;&lt;code&gt;fetch_env/2&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if the application is not loaded.</source>
          <target state="translated">请注意，不会返回该环境，因为可以通过&lt;a href=&quot;#fetch_env/2&quot;&gt; &lt;code&gt;fetch_env/2&lt;/code&gt; &lt;/a&gt;对其进行访问。如果未加载应用程序，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8291debf84c93cf7420e870a4723eb8919b7abde" translate="yes" xml:space="preserve">
          <source>Note the file is deleted even if in read-only mode.</source>
          <target state="translated">注意,即使在只读模式下,文件也会被删除。</target>
        </trans-unit>
        <trans-unit id="20b9a7e0e7cfbc515eb86ff67eaa5244b2827ea0" translate="yes" xml:space="preserve">
          <source>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</source>
          <target state="translated">请注意,本模块中的函数保证返回的是枚举式。由于枚举式可以有不同的形状(结构体,匿名函数等),本模块中的函数可以返回任何一种形状,并且可能随时改变。例如,今天返回匿名函数的函数在未来的版本中可能会返回一个结构。</target>
        </trans-unit>
        <trans-unit id="d438d99970ff0575f83b52d72a57ff8778a28621" translate="yes" xml:space="preserve">
          <source>Note the hook receives the quoted arguments and it is invoked before the function is stored in the module. So &lt;a href=&quot;module#defines?/2&quot;&gt;&lt;code&gt;Module.defines?/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; for the first clause of every function.</source>
          <target state="translated">请注意，该挂钩接收带引号的参数，并且在函数存储在模块中之前将其调用。因此，&lt;a href=&quot;module#defines?/2&quot;&gt; &lt;code&gt;Module.defines?/2&lt;/code&gt; &lt;/a&gt;将为每个函数的第一个子句返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc73248c724a3a7729fc783a9f3f7c1f0c33c3b" translate="yes" xml:space="preserve">
          <source>Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use &lt;a href=&quot;#remove_breaks/1&quot;&gt;&lt;code&gt;remove_breaks/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">请注意，模块在复位时仍处于&amp;ldquo;仪表&amp;rdquo;状态。如果您想有效地从模块中删除所有断点和检测代码，请改用&lt;a href=&quot;#remove_breaks/1&quot;&gt; &lt;code&gt;remove_breaks/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db9c44355a667468b5a8a0fc6d5bc95bf927d9a1" translate="yes" xml:space="preserve">
          <source>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</source>
          <target state="translated">注意,结果值代表的是一天的时间,也就是说它是循环的,比如对于ISO日历来说,它永远不会超过24小时。</target>
        </trans-unit>
        <trans-unit id="bcdf2418808bb9ad9b914fb25ca7111d444ec598" translate="yes" xml:space="preserve">
          <source>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">请注意，年，月，日等指定被过度指定（即整数，而不是月的 &lt;code&gt;1..12&lt;/code&gt; ），因为不同的日历可能每个月，每年的月等等具有不同的天数。</target>
        </trans-unit>
        <trans-unit id="3ccd699f8c48bd34a5a8a8648d6828c7250f9900" translate="yes" xml:space="preserve">
          <source>Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed.</source>
          <target state="translated">请注意,一旦项目被推送到堆栈上,这个配置就会被缓存。多次调用它不会导致它被重新计算。</target>
        </trans-unit>
        <trans-unit id="9d029ff8336c9288d7f18814c831f1d16b88a78a" translate="yes" xml:space="preserve">
          <source>Note this function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">注意这个函数并不遍历AST,只对根节点进行扩展。</target>
        </trans-unit>
        <trans-unit id="3f1cee9305c51b1d0d2373452f46efc36d69c692" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;uri#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">请注意，此函数需要格式正确的URI，并且不会执行任何验证。有关如何使用&lt;a href=&quot;uri#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt;解析大量URI的示例，请参见下面的&amp;ldquo;示例&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="a6f74ff98cf77b2a5593760e563d32600a4851c6" translate="yes" xml:space="preserve">
          <source>Note this function requires the task supervisor to have &lt;code&gt;:temporary&lt;/code&gt; as the &lt;code&gt;:restart&lt;/code&gt; option (the default), as &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt; keeps a direct reference to the task which is lost if the task is restarted.</source>
          <target state="translated">请注意，此功能要求任务管理器将 &lt;code&gt;:temporary&lt;/code&gt; 作为 &lt;code&gt;:restart&lt;/code&gt; 选项（默认值），因为&lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt;保留对任务的直接引用，如果重新启动该任务，该任务将丢失。</target>
        </trans-unit>
        <trans-unit id="aa4a640e0a030948b5a35ad9f1605a103aa1b3ef" translate="yes" xml:space="preserve">
          <source>Note we removed &lt;code&gt;async: true&lt;/code&gt; from &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Since the application environment is a global storage, tests that modify it cannot run concurrently. With all changes in place, all tests should pass, including the distributed one.</source>
          <target state="translated">请注意，我们从 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 删除了 &lt;code&gt;async: true&lt;/code&gt; 。由于应用程序环境是全局存储，因此修改它的测试不能同时运行。进行所有更改后，所有测试都应通过，包括分布式测试。</target>
        </trans-unit>
        <trans-unit id="eac2c1b3b01e930084b33fb0d5edbf4e23375457" translate="yes" xml:space="preserve">
          <source>Note you can also start it simply as &lt;code&gt;Stack&lt;/code&gt;, which is the same as &lt;code&gt;{Stack, []}&lt;/code&gt;:</source>
          <target state="translated">请注意，您也可以像 &lt;code&gt;Stack&lt;/code&gt; 一样简单地启动它，它与 &lt;code&gt;{Stack, []}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="002eb13193e06aa56b8ea00565416925c92cd1a9" translate="yes" xml:space="preserve">
          <source>Note you don&amp;rsquo;t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</source>
          <target state="translated">请注意，您无需定义行为即可动态分配给模块，但是这些功能通常是并行的。</target>
        </trans-unit>
        <trans-unit id="ccaa9177febc5965f3a6e9991d73e149b8c2b3d0" translate="yes" xml:space="preserve">
          <source>Note: All modules defined in Elixir are defined inside the main &lt;code&gt;Elixir&lt;/code&gt; namespace. However, for convenience, you can omit &amp;ldquo;Elixir.&amp;rdquo; when referencing them.</source>
          <target state="translated">注意：在Elixir中定义的所有模块都在主 &lt;code&gt;Elixir&lt;/code&gt; 名称空间中定义。但是，为方便起见，您可以省略&amp;ldquo; Elixir&amp;rdquo;。当引用它们时。</target>
        </trans-unit>
        <trans-unit id="f9375188837fda1326cbb4f55c2eddcde5896357" translate="yes" xml:space="preserve">
          <source>Note: An interesting note regarding &lt;code&gt;if/2&lt;/code&gt; and &lt;code&gt;unless/2&lt;/code&gt; is that they are implemented as macros in the language; they aren&amp;rsquo;t special language constructs as they would be in many languages. You can check the documentation and the source of &lt;code&gt;if/2&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;the &lt;code&gt;Kernel&lt;/code&gt; module docs&lt;/a&gt;. The &lt;code&gt;Kernel&lt;/code&gt; module is also where operators like &lt;code&gt;+/2&lt;/code&gt; and functions like &lt;code&gt;is_function/2&lt;/code&gt; are defined, all automatically imported and available in your code by default.</source>
          <target state="translated">注意：关于 &lt;code&gt;if/2&lt;/code&gt; 和 &lt;code&gt;unless/2&lt;/code&gt; 的有趣注释是它们在语言中被实现为宏。它们不是特殊的语言结构，就像许多语言中那样。您可以查看文档和源 &lt;code&gt;if/2&lt;/code&gt; 中&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;的 &lt;code&gt;Kernel&lt;/code&gt; 模块的文档&lt;/a&gt;。该 &lt;code&gt;Kernel&lt;/code&gt; 模块也是在那里运营商如 &lt;code&gt;+/2&lt;/code&gt; 及类似功能 &lt;code&gt;is_function/2&lt;/code&gt; 的定义，所有的自动导入，并在你的代码默认选项。</target>
        </trans-unit>
        <trans-unit id="333c3af19d66fc17e99fc5af70f1d710e9bfc88f" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;observer&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package. Alternatively, you can skip this section and continue the guide.</source>
          <target state="translated">注意：如果 &lt;code&gt;observer&lt;/code&gt; 没有启动，则可能是这件事发生了：一些软件包管理器默认安装没有GUI支持WX绑定的最小化Erlang。在某些软件包管理器中，您可以用更完整的软件包替换无头的Erlang（在Debian / Ubuntu / Arch上查找名为 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 的软件包）。在其他管理员中，您可能需要安装单独的 &lt;code&gt;erlang-wx&lt;/code&gt; （或类似名称）软件包。或者，您可以跳过本节并继续指南。</target>
        </trans-unit>
        <trans-unit id="1d918daa7b1094720a58030ddd5f21024965cb9a" translate="yes" xml:space="preserve">
          <source>Note: If you are an Erlang developer, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; in Elixir actually map to the &lt;code&gt;andalso&lt;/code&gt; and &lt;code&gt;orelse&lt;/code&gt; operators in Erlang.</source>
          <target state="translated">注意：如果你是一个Erlang开发， &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 在药剂实际上映射到 &lt;code&gt;andalso&lt;/code&gt; 和 &lt;code&gt;orelse&lt;/code&gt; 用Erlang运营商。</target>
        </trans-unit>
        <trans-unit id="ff9e17f09f7587478a4a85a5f5ba16eb3160272e" translate="yes" xml:space="preserve">
          <source>Note: Maps were recently introduced into the Erlang</source>
          <target state="translated">注:地图是最近被引入到Erlang的</target>
        </trans-unit>
        <trans-unit id="96f2bbaf73f21c5d620e6ce00661ef3a7f853b26" translate="yes" xml:space="preserve">
          <source>Note: Mix is an Elixir executable. This means that in order to run &lt;code&gt;mix&lt;/code&gt;, you need to have both &lt;code&gt;mix&lt;/code&gt; and &lt;code&gt;elixir&lt;/code&gt; executables in your PATH. That&amp;rsquo;s what happens when you install Elixir.</source>
          <target state="translated">注意：Mix是Elixir可执行文件。这意味着要运行 &lt;code&gt;mix&lt;/code&gt; ，您需要在PATH中同时具有 &lt;code&gt;mix&lt;/code&gt; 和 &lt;code&gt;elixir&lt;/code&gt; 可执行文件。这就是安装Elixir时发生的情况。</target>
        </trans-unit>
        <trans-unit id="ccb589e6f497a521acf64f009eba87d24abf9844" translate="yes" xml:space="preserve">
          <source>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the &lt;code&gt;time: :posix&lt;/code&gt; option.</source>
          <target state="translated">注意：由于文件时间在大多数操作系统上都以POSIX时间格式存储，因此使用 &lt;code&gt;time: :posix&lt;/code&gt; 选项检索文件信息更快。</target>
        </trans-unit>
        <trans-unit id="85c13b1aace1377737ca0a9ef86cd79955430879" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">注意：在Unix系统中，命令 &lt;code&gt;cp&lt;/code&gt; 的行为会有所不同，具体取决于 &lt;code&gt;destination&lt;/code&gt; 位置是否为现有目录。我们选择明确禁止这种行为。如果 &lt;code&gt;source&lt;/code&gt; 是 &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;destination&lt;/code&gt; 是目录，则将返回 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="587e5cfb89d0a03b03528404235c890650244b41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">注意：在Unix系统中，命令 &lt;code&gt;cp&lt;/code&gt; 的行为会有所不同，具体取决于目标位置是否为现有目录。我们选择显式禁止复制到目标目录，如果尝试复制，将返回错误。</target>
        </trans-unit>
        <trans-unit id="2412c082ee9452e0961827f93fc820b4560394ce" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">注意：在Unix系统中，命令 &lt;code&gt;mv&lt;/code&gt; 的行为会有所不同，具体取决于 &lt;code&gt;source&lt;/code&gt; 是文件还是 &lt;code&gt;destination&lt;/code&gt; 是现有目录。我们选择明确禁止这种行为。</target>
        </trans-unit>
        <trans-unit id="318ba01affa2cb83a445a4ffd6d8bf1dd6eb9f01" translate="yes" xml:space="preserve">
          <source>Note: Unlike Erlang, user defined attributes are not stored in the module by default. The value exists only during compilation time. A developer can configure an attribute to behave closer to Erlang by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：与Erlang不同，默认情况下，用户定义的属性不存储在模块中。该值仅在编译期间存在。开发人员可以通过调用&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将属性配置为更接近Erlang 。</target>
        </trans-unit>
        <trans-unit id="d6501e4eb8325e3aa1733c1d78f4786f805cb16e" translate="yes" xml:space="preserve">
          <source>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">注意:不要在Unicode模式的IO设备上使用这个函数,因为它会返回错误的结果。</target>
        </trans-unit>
        <trans-unit id="767ed77ecda9bec0c064d33f222982b4d00c82a3" translate="yes" xml:space="preserve">
          <source>Note: escripts do not support projects and dependencies that need to store or read artifacts from the priv directory.</source>
          <target state="translated">注意:escripts不支持需要从priv目录中存储或读取工件的项目和依赖关系。</target>
        </trans-unit>
        <trans-unit id="dc1575464df3ee39226b1eec5b01c029bb5c0bef" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex.bat --werl&lt;/code&gt; which may provide a better experience depending on which console you are using.</source>
          <target state="translated">注意：如果您使用的是Windows，则还可以尝试 &lt;code&gt;iex.bat --werl&lt;/code&gt; ，根据所使用的控制台，它可能会提供更好的体验。</target>
        </trans-unit>
        <trans-unit id="912e5c0c98d6ca0f341e5fc328517d2b1fabbcad" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering &lt;code&gt;iex&lt;/code&gt; (&lt;code&gt;iex.bat&lt;/code&gt;).</source>
          <target state="translated">注意：如果您在Windows上运行，则默认情况下您的终端有可能不使用UTF-8。您可以在输入 &lt;code&gt;iex&lt;/code&gt; （ &lt;code&gt;iex.bat&lt;/code&gt; ）之前运行 &lt;code&gt;chcp 65001&lt;/code&gt; 来更改当前会话的编码。</target>
        </trans-unit>
        <trans-unit id="f4dbeaf674e0eb7ea6925af7a2318ed6c85002a1" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering IEx.</source>
          <target state="translated">注意：如果您在Windows上运行，则默认情况下您的终端有可能不使用UTF-8。您可以在输入IEx之前通过运行 &lt;code&gt;chcp 65001&lt;/code&gt; 来更改当前会话的编码。</target>
        </trans-unit>
        <trans-unit id="8e6389ccfd4efe5ada7d55d154db6d0a4d03109a" translate="yes" xml:space="preserve">
          <source>Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="translated">注意：如果您为Elixir项目将此设置为 &lt;code&gt;false&lt;/code&gt; ，则在运行生成的escript脚本时，必须将Elixir的 &lt;code&gt;ebin&lt;/code&gt; 目录的路径添加到 &lt;code&gt;ERL_LIBS&lt;/code&gt; 环境变量中，以使代码加载器能够找到 &lt;code&gt;:elixir&lt;/code&gt; 应用程序及其子级应用程序（如果已使用）。</target>
        </trans-unit>
        <trans-unit id="8ccad6d1cb0c1e92a31e2fb1270a6789b9c4f735" translate="yes" xml:space="preserve">
          <source>Note: if you want to find and execute a given script in PATH so it will be loaded in &lt;code&gt;iex&lt;/code&gt; use: &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt;. Later you&amp;rsquo;ll learn about &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt;, Elixir&amp;rsquo;s build tool, and how you can compile and load entire applications with &lt;code&gt;iex -S mix run&lt;/code&gt;. See &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;Supervisor and application&lt;/a&gt; for more details.</source>
          <target state="translated">注意：如果要在PATH中查找并执行给定脚本，以便将其加载到 &lt;code&gt;iex&lt;/code&gt; 中,请使用： &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt; 。稍后，您将了解Elixir的构建工具&lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt;，以及如何使用 &lt;code&gt;iex -S mix run&lt;/code&gt; 编译和加载整个应用程序。有关更多详细信息，请参见&lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;主管和应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a2b2736d0228ed219724e9f93f70ec1ac8cd179" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注意：请记住，此函数在字素上拆分，因此必须线性遍历字符串。如果要根据字节数拆分字符串或二进制文件，请改用&lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57e11fb647c860e43cb9b2c5f6c254e9e56dfddb" translate="yes" xml:space="preserve">
          <source>Note: the Debugger snippet above was retrieved from &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;&amp;ldquo;Debugging techniques in Elixir&amp;rdquo; by Plataformatec&lt;/a&gt;.</source>
          <target state="translated">注意：上面的调试器片段是&lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;Plataformatec&lt;/a&gt;从&amp;ldquo; Elixir中的调试技术&amp;rdquo;中检索到的。</target>
        </trans-unit>
        <trans-unit id="92f2e22007c90b9cbb55bb29dc07138d25f25b5c" translate="yes" xml:space="preserve">
          <source>Note: this function is similar to &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt; except the latter returns both the flat list and accumulator, while this one returns only the stream.</source>
          <target state="translated">注意：此函数类似于&lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; ,&lt;/a&gt;但后者同时返回平面列表和累加器，而此函数仅返回流。</target>
        </trans-unit>
        <trans-unit id="1838e9e0c7c7ddb2da84c8c70085cf8301982628" translate="yes" xml:space="preserve">
          <source>Note: we will be using two nodes in the same machine throughout this chapter. You are free to use two (or more) different machines on the same network but you need to do some prep work. First of all, you need to ensure all machines have a &lt;code&gt;~/.erlang.cookie&lt;/code&gt; file with exactly the same value. Second, you need to guarantee &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; is running on a port that is not blocked (you can run &lt;code&gt;epmd -d&lt;/code&gt; for debug info). Third, if you want to learn more about distribution in general, we recommend &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;this great Distribunomicon chapter from Learn You Some Erlang&lt;/a&gt;.</source>
          <target state="translated">注意：在本章中，我们将在同一台计算机上使用两个节点。您可以随意在同一网络上使用两台（或更多）不同的计算机，但需要做一些准备工作。首先，您需要确保所有机器都有一个 &lt;code&gt;~/.erlang.cookie&lt;/code&gt; 文件，其值完全相同。其次，您需要确保&lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt;在未阻塞的端口上运行（可以运行 &lt;code&gt;epmd -d&lt;/code&gt; 获取调试信息）。第三，如果您想全面了解发行，我们建议&lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;您从Learn Your Some Erlang中找到出色的Distribunomicon一章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a1f1223d3d0c72df45c1e2b35a2ccf27e67399b" translate="yes" xml:space="preserve">
          <source>Note: you will likely get different process identifiers than the ones we are getting in this guide.</source>
          <target state="translated">注意:你可能会得到与我们在本指南中得到的不同的进程标识符。</target>
        </trans-unit>
        <trans-unit id="e501dc317df6513b552e6ef09f3d93b0d31cfc45" translate="yes" xml:space="preserve">
          <source>Nothing really exciting happens but it shows how we can control our application.</source>
          <target state="translated">没有什么真正令人兴奋的事情发生,但它显示了我们如何控制我们的应用程序。</target>
        </trans-unit>
        <trans-unit id="3f9f6ccaa3929763f1f8329a0cf42d1567c947e3" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;spawn/1&lt;/code&gt; returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:</source>
          <target state="translated">注意 &lt;code&gt;spawn/1&lt;/code&gt; 返回一个PID（进程标识符）。此时，您产生的进程很可能已经死了。产生的进程将执行给定的函数，并在函数完成后退出：</target>
        </trans-unit>
        <trans-unit id="28bdc086982ce6f35c77fe8c28e2ce539fb72e7b" translate="yes" xml:space="preserve">
          <source>Notice doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">注意doctest有局限性。当您无法对功能进行文档测试时，由于它依赖状态或副作用，因此我们建议开发人员直接在不包含 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 提示的情况下包含示例。</target>
        </trans-unit>
        <trans-unit id="a8b421e9b5a288fb270e5d94ac8ec254970e093c" translate="yes" xml:space="preserve">
          <source>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</source>
          <target state="translated">请注意 &quot;返回5 &quot;被打印了两次,而不是只有一次。这是因为宏接收的是一个表达式,而不是一个值(这正是我们在正则函数中所期望的)。这意味着。</target>
        </trans-unit>
        <trans-unit id="3892c7952171348da3fa8fc4e90871b3d046b9b8" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">请注意，即使未导入&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt;函数， &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; 如何返回 &lt;code&gt;3&lt;/code&gt; 。实际上，即使 &lt;code&gt;return_length/0&lt;/code&gt; 从另一个模块导入了具有相同名称和属性的函数，也不会影响该函数的结果：</target>
        </trans-unit>
        <trans-unit id="86cf6571366da66046772448d17be71c9b8bac4d" translate="yes" xml:space="preserve">
          <source>Notice how the example above has a comma between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;do:&lt;/code&gt;, that&amp;rsquo;s because it is using Elixir&amp;rsquo;s regular syntax where each argument is separated by a comma. We say this syntax is using &lt;em&gt;keyword lists&lt;/em&gt;. We can pass &lt;code&gt;else&lt;/code&gt; using keywords too:</source>
          <target state="translated">注意上面的示例在 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;do:&lt;/code&gt; 之间有一个逗号，这是因为它使用的是Elixir的常规语法，其中每个参数都用逗号分隔。我们说这种语法使用&lt;em&gt;关键字列表&lt;/em&gt;。我们也可以使用关键字传递 &lt;code&gt;else&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="089ef5aec5dcab204a4dde60fdae6b22199f9d60" translate="yes" xml:space="preserve">
          <source>Notice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the &lt;code&gt;pid&lt;/code&gt; above will be able to send it messages and manipulate the state.</source>
          <target state="translated">注意流程如何保持状态，我们可以通过发送流程消息来获取和更新此状态。实际上，任何知道上述 &lt;code&gt;pid&lt;/code&gt; 的进程都将能够向其发送消息并操纵状态。</target>
        </trans-unit>
        <trans-unit id="68d3a08b640aa9ec43f4df6e72697d747babcab8" translate="yes" xml:space="preserve">
          <source>Notice how the supervisor automatically started a new registry, with a new PID, in place of the first one once we caused it to crash due to a bad input.</source>
          <target state="translated">请注意,一旦我们由于输入错误导致注册表崩溃,主管如何自动启动一个新的注册表,用一个新的PID来代替第一个注册表。</target>
        </trans-unit>
        <trans-unit id="9a6c5a958a0495f608cd080595362cf8cc21a5de" translate="yes" xml:space="preserve">
          <source>Notice how we were able to elegantly parse the commands without adding a bunch of &lt;code&gt;if/else&lt;/code&gt; clauses that check the command name and number of arguments!</source>
          <target state="translated">注意，我们如何能够优雅地解析命令，而无需添加一堆 &lt;code&gt;if/else&lt;/code&gt; 子句来检查命令名称和参数数量！</target>
        </trans-unit>
        <trans-unit id="6dfab922fecade531cb4dec0d9405839ea8b9d8a" translate="yes" xml:space="preserve">
          <source>Notice in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;code&gt;c:init/1&lt;/code&gt; callback.</source>
          <target state="translated">请注意，在这种情况下，我们不必显式导入&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; ,&lt;/a&gt;因为 &lt;code&gt;use Supervisor&lt;/code&gt; 会自动导入。定义基于模块的管理器对于例如在 &lt;code&gt;c:init/1&lt;/code&gt; 回调中执行初始化任务很有用。</target>
        </trans-unit>
        <trans-unit id="c882f5ebb65100a3d2f1cd2368d20ea86c511dfc" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">注意 &lt;code&gt;.&lt;/code&gt; 也是运算符。远程调用将AST中的点与两个参数一起使用，其中第二个参数始终是一个原子：</target>
        </trans-unit>
        <trans-unit id="df067cb31b582b9b17b8ec8909cd436d56688f8e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;1 = x&lt;/code&gt; is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a &lt;code&gt;MatchError&lt;/code&gt; is raised.</source>
          <target state="translated">请注意， &lt;code&gt;1 = x&lt;/code&gt; 是有效表达式，并且之所以匹配，是因为左侧和右侧均等于1。如果两侧不匹配， &lt;code&gt;MatchError&lt;/code&gt; 引发MatchError。</target>
        </trans-unit>
        <trans-unit id="ea49ec32721d567bfbb9765cea3e755b4c4e02a9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;10 / 2&lt;/code&gt; returned a float &lt;code&gt;5.0&lt;/code&gt; instead of an integer &lt;code&gt;5&lt;/code&gt;. This is expected. In Elixir, the operator &lt;code&gt;/&lt;/code&gt; always returns a float. If you want to do integer division or get the division remainder, you can invoke the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; functions:</source>
          <target state="translated">请注意， &lt;code&gt;10 / 2&lt;/code&gt; 返回浮点数 &lt;code&gt;5.0&lt;/code&gt; ,而不是整数 &lt;code&gt;5&lt;/code&gt; 。这是预期的。在Elixir中，运算符 &lt;code&gt;/&lt;/code&gt; 始终返回浮点数。如果要进行整数除法或获取除法余数，可以调用 &lt;code&gt;div&lt;/code&gt; 和 &lt;code&gt;rem&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="887a696d47512286eb5278c149faaa334a09a281" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">请注意，可以在catch / rescue内部使用 &lt;code&gt;__STACKTRACE__&lt;/code&gt; 来检索当前的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="d8d5e7850b7bd8f241d8a1343704189a623bfa62" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;put_elem/3&lt;/code&gt; returned a new tuple. The original tuple stored in the &lt;code&gt;tuple&lt;/code&gt; variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.</source>
          <target state="translated">注意， &lt;code&gt;put_elem/3&lt;/code&gt; 返回了一个新的元组。存储在 &lt;code&gt;tuple&lt;/code&gt; 变量中的原始元组未修改。像列表一样，元组也是不可变的。元组上的每个操作都会返回一个新的元组，它永远不会更改给定的元组。</target>
        </trans-unit>
        <trans-unit id="5b802bfe2367dd2e9b70b08829bc0a53825dc5da" translate="yes" xml:space="preserve">
          <source>Notice that Elixir allows you to drop the parentheses when invoking named functions. This feature gives a cleaner syntax when writing declarations and control-flow constructs.</source>
          <target state="translated">请注意,Elixir允许你在调用命名函数时去掉括号。这一特性使我们在编写声明和控制流结构时的语法更加简洁。</target>
        </trans-unit>
        <trans-unit id="45ddeb0507e2941d4064cc4fd963a7f2bec2af71" translate="yes" xml:space="preserve">
          <source>Notice that before our changes &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That&amp;rsquo;s the main idea behind the cache mechanism we are implementing.</source>
          <target state="translated">请注意，在进行更改之前， &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 已向服务器发送了请求，但现在它直接从ETS表读取，该表在所有进程之间共享。这是我们正在实施的缓存机制背后的主要思想。</target>
        </trans-unit>
        <trans-unit id="6a0f0c1ec687f2ea0cd8655129747b9d7cd3f754" translate="yes" xml:space="preserve">
          <source>Notice that by running &lt;code&gt;mix test&lt;/code&gt;, Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.</source>
          <target state="translated">请注意，通过运行 &lt;code&gt;mix test&lt;/code&gt; ，Mix已编译源文件并再次生成了应用程序清单。发生这种情况是因为Mix支持多种环境，我们将在本章稍后讨论。</target>
        </trans-unit>
        <trans-unit id="57e1fb0b39317bc0fdf150c6ab3ed9709eedac00" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">请注意，不带 &lt;code&gt;:as&lt;/code&gt; 选项调用 &lt;code&gt;alias&lt;/code&gt; 将根据模块的最后一部分自动设置别名。例如：</target>
        </trans-unit>
        <trans-unit id="9daf8eefb4c15d859869ea5da53757de4d79f368" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">请注意，在先前声明的&lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;上，调用 &lt;code&gt;except&lt;/code&gt; 始终是唯一的。如果没有以前的导入，则它适用于模块中的所有函数和宏。例如：</target>
        </trans-unit>
        <trans-unit id="4d111052cc1acb6679f60941ac62aab89e4c9ddf" translate="yes" xml:space="preserve">
          <source>Notice that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">请注意,不同的引擎对每个标签可能有不同的规则。其他标签可能会在未来的版本中加入。</target>
        </trans-unit>
        <trans-unit id="347481b6b324efbcacea6f493fbe1e9b884fc181" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">请注意，如果&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;由不同的进程同时调用，则第一个调用&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; 的&lt;/a&gt;进程将获得一个锁，其余的锁将阻塞，直到文件可用为止。这意味着如果给定文件多次调用&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;，则该文件将仅编译一次。调用&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;的第一个进程将获取已加载模块的列表，其他进程将获取 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e78784f8ee1baee6a6b68c15d6d35bbd3682972" translate="yes" xml:space="preserve">
          <source>Notice that it defines the application callback function, &lt;code&gt;start/2&lt;/code&gt;, and instead of defining a supervisor named &lt;code&gt;KVServer.Supervisor&lt;/code&gt; that uses the &lt;code&gt;Supervisor&lt;/code&gt; module, it conveniently defined the supervisor inline! You can read more about such supervisors by reading &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;the Supervisor module documentation&lt;/a&gt;.</source>
          <target state="translated">注意，它定义了应用程序回调函数 &lt;code&gt;start/2&lt;/code&gt; ，而不是定义使用 &lt;code&gt;Supervisor&lt;/code&gt; 模块的名为 &lt;code&gt;KVServer.Supervisor&lt;/code&gt; 的超级用户，而是方便地定义了超级用户内联！您可以通过阅读&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor模块文档来&lt;/a&gt;了解有关此类Supervisor的更多信息。</target>
        </trans-unit>
        <trans-unit id="54b8e7a6900c64697dfb761c739ce312b8b3c54e" translate="yes" xml:space="preserve">
          <source>Notice that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">请注意，设置以上任何值都会覆盖Elixir的默认值。例如，将 &lt;code&gt;:requires&lt;/code&gt; 设置为 &lt;code&gt;[]&lt;/code&gt; 将不再自动需要&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块。以相同的方式设置 &lt;code&gt;:macros&lt;/code&gt; 将不再自动导入&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;宏，例如&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt;/2等。</target>
        </trans-unit>
        <trans-unit id="6e1f199b3af38598b79e950aaf97a0eca8c4b82c" translate="yes" xml:space="preserve">
          <source>Notice that string interpolation in Elixir calls the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">注意，Elixir中的字符串插值调用 &lt;code&gt;to_string&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="840aa4d2de3105a50a863883569231610137217c" translate="yes" xml:space="preserve">
          <source>Notice that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option is set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">请注意，达到最大重启强度的超级用户将以 &lt;code&gt;:shutdown&lt;/code&gt; 原因退出。在这种情况下，只有在将 &lt;code&gt;:restart&lt;/code&gt; 选项设置为 &lt;code&gt;:permanent&lt;/code&gt; （默认值）定义其子规范时，才可以重新启动超级用户。</target>
        </trans-unit>
        <trans-unit id="80888ed7f572f5d6e47653c01243b5f16e08dc6e" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;IO.puts/1&lt;/code&gt; function returns the atom &lt;code&gt;:ok&lt;/code&gt; after printing.</source>
          <target state="translated">请注意， &lt;code&gt;IO.puts/1&lt;/code&gt; 函数在打印后返回原子 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e928f1dda24dbbefd3436c4e0da759a5854ad46" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 characters. That&amp;rsquo;s because the character &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">请注意，即使该字符串有5个字符，该字符串中的字节数也为6。这是因为字符&amp;ldquo;&amp;ouml;&amp;rdquo;需要2个字节才能用UTF-8表示。通过使用 &lt;code&gt;String.length/1&lt;/code&gt; 函数，我们可以根据字符数获得字符串的实际长度：</target>
        </trans-unit>
        <trans-unit id="8942e3ca27cf75b423a37d9bfb02178064e23332" translate="yes" xml:space="preserve">
          <source>Notice that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">请注意，达到最大重启强度的超级用户将以 &lt;code&gt;:shutdown&lt;/code&gt; 原因退出。在这种情况下，只有在将其子规范指定为 &lt;code&gt;:restart&lt;/code&gt; 选项设置为 &lt;code&gt;:permanent&lt;/code&gt; （默认值）的情况下，才可以重新启动超级用户。</target>
        </trans-unit>
        <trans-unit id="46c8a4ba57727e7ee215c034d3fe51bd425fdf82" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">请注意， &lt;code&gt;map()&lt;/code&gt; 的语法表示形式为 &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; ，而不是 &lt;code&gt;%{}&lt;/code&gt; 。 &lt;code&gt;%{}&lt;/code&gt; 符号指定空映射的单例类型。</target>
        </trans-unit>
        <trans-unit id="bdf28662e920e08a018b921e52faac2f13427657" translate="yes" xml:space="preserve">
          <source>Notice that the third element in the quoted variable is the atom &lt;code&gt;Sample&lt;/code&gt;, instead of &lt;code&gt;nil&lt;/code&gt;, which marks the variable as coming from the &lt;code&gt;Sample&lt;/code&gt; module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.</source>
          <target state="translated">注意，引用的变量中的第三个元素是原子 &lt;code&gt;Sample&lt;/code&gt; ，而不是 &lt;code&gt;nil&lt;/code&gt; ，这将变量标记为来自 &lt;code&gt;Sample&lt;/code&gt; 模块。因此，Elixir认为这两个变量来自不同的上下文，并据此进行处理。</target>
        </trans-unit>
        <trans-unit id="6c70c0b543ddc39b4906e53100736219e7d916c9" translate="yes" xml:space="preserve">
          <source>Notice that the version with &lt;code&gt;!&lt;/code&gt; returns the contents of the file instead of a tuple, and if anything goes wrong the function raises an error.</source>
          <target state="translated">注意带 &lt;code&gt;!&lt;/code&gt; 的版本。返回文件的内容而不是元组，并且如果出现任何错误，该函数将引发错误。</target>
        </trans-unit>
        <trans-unit id="ac1edafa4a033fbb4dca78373c1cefb5a29180a1" translate="yes" xml:space="preserve">
          <source>Notice that this function expects a list of integers representing UTF-8 code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">请注意，此函数需要一个表示UTF-8代码点的整数列表。如果有字节列表，则必须使用&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cdf2f5ea01fa067c0fbde027a86184d517fa295" translate="yes" xml:space="preserve">
          <source>Notice that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">请注意，此函数将给定IO数据中的整数视为原始字节，并且不执行任何类型的编码转换。如果要从字符列表转换为UTF-8编码的字符串，请改用&lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt;。有关IO数据和chardata的更多信息，请参见模块文档中的&lt;a href=&quot;#module-io-data&quot;&gt;&amp;ldquo; IO数据&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="da2e36451104accdab1f135698969f5dbb62ea72" translate="yes" xml:space="preserve">
          <source>Notice that variables bound in a clause &quot;head&quot; do not leak to the outer context:</source>
          <target state="translated">请注意,在子句 &quot;head &quot;中绑定的变量不会泄漏到外部上下文。</target>
        </trans-unit>
        <trans-unit id="f18296fb1e15bf91d08f40da7cae0240a810e85c" translate="yes" xml:space="preserve">
          <source>Notice that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">请注意,我们首先打印列表中的每个元素,然后将每个元素乘以2,最后打印每个新的值。在这个例子中,列表被列举了三次。让我们看一个带流的例子。</target>
        </trans-unit>
        <trans-unit id="e80454db9add600d6dd12ebc0cf1ec2362e0064d" translate="yes" xml:space="preserve">
          <source>Notice that we referred to structs as &lt;strong&gt;bare&lt;/strong&gt; maps because none of the protocols implemented for maps are available for structs. For example, you can neither enumerate nor access a struct:</source>
          <target state="translated">请注意，我们将结构称为&lt;strong&gt;裸&lt;/strong&gt;图，因为为该图实现的协议都不适用于该结构。例如，您既不能枚举也不能访问结构：</target>
        </trans-unit>
        <trans-unit id="e7bd2d8499eb11634d1cac7e077fdc215c19c9e6" translate="yes" xml:space="preserve">
          <source>Notice that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">请注意，启动GenServer时，我们将其注册为名称 &lt;code&gt;Stack&lt;/code&gt; ，这使我们可以直接调用它并获取堆栈中的内容：</target>
        </trans-unit>
        <trans-unit id="57f35a2e632227e4c4fd62aa0253d676ce9ec766" translate="yes" xml:space="preserve">
          <source>Notice that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，即使别名 &lt;code&gt;M&lt;/code&gt; 在上下文中不可用，宏也已扩展，但上面的代码仍然有效，因为 &lt;code&gt;M&lt;/code&gt; 仍扩展为&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f6878fe98d8554fc9f432df2a9141f6399af678" translate="yes" xml:space="preserve">
          <source>Notice that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">请注意,虽然模式可以被赋予宏,但请记住,宏接收AST作为参数,而不是值。例如,如果你试图用下面的模式来打破一个宏。</target>
        </trans-unit>
        <trans-unit id="5cf97154e72e91b95ed319e84cacaa08b368821a" translate="yes" xml:space="preserve">
          <source>Notice the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">请注意,断点是按原样表示的,因为我们还没有达到行限。一旦我们达到了,它就会被一个新行代替。</target>
        </trans-unit>
        <trans-unit id="496f1449954afceaf9beb520372d8e05f415dd6b" translate="yes" xml:space="preserve">
          <source>Notice the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">请注意,中断是用给定的字符串来表示的,因为我们没有达到行的限制。一旦我们达到了,它就会被一个新行代替。</target>
        </trans-unit>
        <trans-unit id="3e4325519e924c99a829325af4cfbcadb94f2b5a" translate="yes" xml:space="preserve">
          <source>Notice the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意，用户提供的函数包装在&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数中。如&lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt;类型中所述，&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数必须在每个步骤之后返回带标签的元组。最后，&lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07069adb0c1e46329be40dc3e44e76edaef1ef62" translate="yes" xml:space="preserve">
          <source>Notice this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">注意，此函数将遍历整个 &lt;code&gt;enumerable&lt;/code&gt; 以获取随机子列表。</target>
        </trans-unit>
        <trans-unit id="89e0bc5cd464e7720b387f9becc6e78a50eb339c" translate="yes" xml:space="preserve">
          <source>Notice we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">注意，我们没有为列表实现它，因为我们没有列表上的 &lt;code&gt;size&lt;/code&gt; 信息，而是需要使用 &lt;code&gt;length&lt;/code&gt; 来计算其值。</target>
        </trans-unit>
        <trans-unit id="03afe8d614ca6b25d6bf98b3847bcf90d9034dfa" translate="yes" xml:space="preserve">
          <source>Notice we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole matched pattern in the replacement string.</source>
          <target state="translated">注意，我们必须转义反斜杠转义符（即，我们使用 &lt;code&gt;\\N&lt;/code&gt; 而不是仅 &lt;code&gt;\N&lt;/code&gt; 来转义反斜杠；对于 &lt;code&gt;\\g{N}&lt;/code&gt; ）。通过给 &lt;code&gt;\0&lt;/code&gt; ，可以将整个匹配的模式注入替换字符串中。</target>
        </trans-unit>
        <trans-unit id="f85b4b1b8fafa24d41295fda0f44252f687ca128" translate="yes" xml:space="preserve">
          <source>Notice we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">注意，我们有一个内部元组，其中包含原子 &lt;code&gt;:.&lt;/code&gt; 将点表示为第一个元素：</target>
        </trans-unit>
        <trans-unit id="6c69e6930b5bc92d057ccefe34bb93eda478134f" translate="yes" xml:space="preserve">
          <source>Notice we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">请注意，我们从一个范围开始，然后创建了一个流，该流用于将范围中的每个元素乘以2。这时，没有进行任何计算。仅当&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;时，我们才实际枚举范围内的每个元素，将其乘以2并加1。我们说&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;中的函数是&lt;em&gt;惰性的&lt;/em&gt;，而&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;中的函数是&lt;em&gt;eager的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ba47ef34cc51f70a00d9e0a27391c8b89cac3f5e" translate="yes" xml:space="preserve">
          <source>Now a struct can be created as follows:</source>
          <target state="translated">现在可以创建一个结构,如下所示。</target>
        </trans-unit>
        <trans-unit id="ac6a27b4457ccc07e2ad2cacdcc3e23c4356feaa" translate="yes" xml:space="preserve">
          <source>Now all data types (including structs) that have not implemented the &lt;code&gt;Size&lt;/code&gt; protocol will be considered to have a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">现在，所有尚未实现 &lt;code&gt;Size&lt;/code&gt; 协议的数据类型（包括结构）都将被视为大小为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89083d1bc146a648411e0ff3f2366a0deb9fa8b8" translate="yes" xml:space="preserve">
          <source>Now if you run the tests, you will see the test that checks the server interaction will fail, as it will attempt to use the routing table. To address this failure, add &lt;code&gt;@tag :distributed&lt;/code&gt; to this test too:</source>
          <target state="translated">现在，如果运行测试，您将看到检查服务器交互的测试将失败，因为它将尝试使用路由表。要解决此故障，请在此测试中也添加 &lt;code&gt;@tag :distributed&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="07a537a78322242c13cbe0fc9e189cb95c551f62" translate="yes" xml:space="preserve">
          <source>Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment:</source>
          <target state="translated">现在想象有人想把字符串分成三部分。你决定通过应用环境来配置部分的数量。</target>
        </trans-unit>
        <trans-unit id="0d4fb1978dc93bf23ded5fbfb72b901b0ff9b3c1" translate="yes" xml:space="preserve">
          <source>Now imagine that this code does not fit its line. The code formatter introduces breaks inside &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; and inside &lt;code&gt;%{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. Therefore the document would break as:</source>
          <target state="translated">现在想象一下这段代码不适合它。代码格式化程序在 &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 和 &lt;code&gt;%{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 内部引入了中断。因此，该文档将分解为：</target>
        </trans-unit>
        <trans-unit id="1776285a5ee5e0cd2e476a5e17548b25cf3e7965" translate="yes" xml:space="preserve">
          <source>Now instead of:</source>
          <target state="translated">现在代替。</target>
        </trans-unit>
        <trans-unit id="b2edaaf4e4c37a573a2f4175b7fb677e22086d38" translate="yes" xml:space="preserve">
          <source>Now invoking &lt;code&gt;squared(my_number.())&lt;/code&gt; as before will print the value just once.</source>
          <target state="translated">现在像以前一样调用 &lt;code&gt;squared(my_number.())&lt;/code&gt; 只会打印一次值。</target>
        </trans-unit>
        <trans-unit id="b50389659966a7555212a28c84596f8d8bad4035" translate="yes" xml:space="preserve">
          <source>Now it is your turn to write a test for the functionality above! Also, be sure to explore &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;the documentation for the &lt;code&gt;Agent&lt;/code&gt; module&lt;/a&gt; to learn more about them.</source>
          <target state="translated">现在轮到您为上述功能编写测试了！另外，请确保浏览&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&amp;ldquo; &lt;code&gt;Agent&lt;/code&gt; 模块的文档&lt;/a&gt;以了解有关它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="cac6639a99e22abeb99b7c1fe3b72525b3c0d41b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s make the doctest pass. Let&amp;rsquo;s implement the &lt;code&gt;parse/1&lt;/code&gt; function:</source>
          <target state="translated">现在，让doctest通过。让我们实现 &lt;code&gt;parse/1&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a06cdb0293b3c757aef93c1695a911a48f527d99" translate="yes" xml:space="preserve">
          <source>Now once the system boots, it will invoke the provider early in the boot process, save the merged configuration to the disk, and reboot the system with the new values in place.</source>
          <target state="translated">现在,一旦系统启动,它将在启动过程的早期调用提供者,将合并后的配置保存到磁盘上,并以新的值重新启动系统。</target>
        </trans-unit>
        <trans-unit id="f8e788006f30e3c08108a5e67aea31d230a97139" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;mix test&lt;/code&gt; again (notice this time there will be no compilation):</source>
          <target state="translated">现在再次运行 &lt;code&gt;mix test&lt;/code&gt; （注意这次不会进行编译）：</target>
        </trans-unit>
        <trans-unit id="19fa598d84faa6a938161fe34822951938d13086" translate="yes" xml:space="preserve">
          <source>Now run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">现在使用 &lt;code&gt;mix test&lt;/code&gt; 运行测试：</target>
        </trans-unit>
        <trans-unit id="edc3c0311fb8d8402744a5dc3b64fa6e7d3ee61a" translate="yes" xml:space="preserve">
          <source>Now run the shell:</source>
          <target state="translated">现在运行shell。</target>
        </trans-unit>
        <trans-unit id="19a25f5fcd5f38d10706db44b6313eed285f06df" translate="yes" xml:space="preserve">
          <source>Now that our buckets are properly linked and supervised, let&amp;rsquo;s see how we can speed things up.</source>
          <target state="translated">现在我们的存储桶已正确链接并受到监督，让我们看看如何加快处理速度。</target>
        </trans-unit>
        <trans-unit id="9e53f2ea82a2cf9a10ea7d3d3f281c742019f84a" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;KV.Bucket&lt;/code&gt; module has been defined, our test should pass! You can try it yourself by running: &lt;code&gt;mix test&lt;/code&gt;.</source>
          <target state="translated">现在已经定义了 &lt;code&gt;KV.Bucket&lt;/code&gt; 模块，我们的测试应该通过了！您可以运行以下命令自己尝试： &lt;code&gt;mix test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7df359bcf6fd7b6b53a7f0116a2c64cf244a918" translate="yes" xml:space="preserve">
          <source>Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:</source>
          <target state="translated">现在,协议可以为每一个数据结构实现,协议可能有一个符合的实现。</target>
        </trans-unit>
        <trans-unit id="08d686a4ce79ab4cc9d9c6a38ea87b99a5fd278a" translate="yes" xml:space="preserve">
          <source>Now that the server is part of the supervision tree, it should start automatically when we run the application. Start your server, now passing the port, and once again use the &lt;code&gt;telnet&lt;/code&gt; client to make sure that everything still works:</source>
          <target state="translated">现在，服务器已成为监督树的一部分，当我们运行应用程序时，它应该会自动启动。启动服务器，现在通过端口，然后再次使用 &lt;code&gt;telnet&lt;/code&gt; 客户端确保一切仍然正常：</target>
        </trans-unit>
        <trans-unit id="e7e80fb6ff6e247ded63d0bdc578c34f9a1551f2" translate="yes" xml:space="preserve">
          <source>Now that we have defined our supervision tree, it is a great opportunity to introduce the Observer tool that ships with Erlang. Start your application with &lt;code&gt;iex -S mix&lt;/code&gt; and key this in:</source>
          <target state="translated">既然我们已经定义了监督树，现在是引入Erlang附带的Observer工具的绝佳机会。使用 &lt;code&gt;iex -S mix&lt;/code&gt; 启动您的应用程序，然后输入以下内容：</target>
        </trans-unit>
        <trans-unit id="65521a82582c996b661e688c57efd31c9126bde0" translate="yes" xml:space="preserve">
          <source>Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:</source>
          <target state="translated">现在我们已经谈到了别名,我们可以谈谈嵌套以及它在Elixir中的工作原理。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="ac080018201e9a042de2521194aa2396dd3f6137" translate="yes" xml:space="preserve">
          <source>Now that you have defined an application callback which starts our supervisor, we expect the &lt;code&gt;KV.Registry&lt;/code&gt; process to be up and running as soon we start &lt;code&gt;iex -S mix&lt;/code&gt;. Let&amp;rsquo;s give it another try:</source>
          <target state="translated">既然您已经定义了一个启动我们的主管的应用程序回调，那么我们希望在启动 &lt;code&gt;iex -S mix&lt;/code&gt; 时就可以启动并运行 &lt;code&gt;KV.Registry&lt;/code&gt; 进程。让我们再试一次：</target>
        </trans-unit>
        <trans-unit id="328f3af23181b7aed869a7baf3feac133b09d35c" translate="yes" xml:space="preserve">
          <source>Now trying to build a struct without the name key will fail:</source>
          <target state="translated">现在试图建立一个没有名称键的结构将失败。</target>
        </trans-unit>
        <trans-unit id="f61f095187bf437534acdc98989a52599f7a57e0" translate="yes" xml:space="preserve">
          <source>Now type any string into the terminal and you will see that the same value will be printed in upper-case. Unfortunately, this example also got your IEx shell stuck in the comprehension, so you will need to hit &lt;code&gt;Ctrl+C&lt;/code&gt; twice to get out of it. :)</source>
          <target state="translated">现在，在终端中输入任何字符串，您将看到相同的值将以大写形式输出。不幸的是，此示例还使您的IEx shell陷入了困境，因此您将需要 &lt;code&gt;Ctrl+C&lt;/code&gt; 两次Ctrl + C才能退出。:)</target>
        </trans-unit>
        <trans-unit id="46bc283c29ce2ecc43ead7d1d61cfa31cca09a7d" translate="yes" xml:space="preserve">
          <source>Now users can configure your library in their &lt;code&gt;config/config.exs&lt;/code&gt; file as follows:</source>
          <target state="translated">现在，用户可以在其 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置您的库，如下所示：</target>
        </trans-unit>
        <trans-unit id="b17fce085e9d552d0a9af3234c3cdfba2da82bb3" translate="yes" xml:space="preserve">
          <source>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</source>
          <target state="translated">现在我们已经连接到远程节点中,如提示所示,我们可以访问那边定义的信息和模块。</target>
        </trans-unit>
        <trans-unit id="57fd8f624da2baf5d7aba96d024c13b21b6b8eeb" translate="yes" xml:space="preserve">
          <source>Now we can start our debugger:</source>
          <target state="translated">现在我们可以启动我们的调试器了。</target>
        </trans-unit>
        <trans-unit id="ff52cd0aed65a9dce91b318e1c1c0dbc4e09358d" translate="yes" xml:space="preserve">
          <source>Now we get an error because an application that &lt;code&gt;:kv&lt;/code&gt; depends on (&lt;code&gt;:logger&lt;/code&gt; in this case) isn&amp;rsquo;t started. We need to either start each application manually in the correct order or call &lt;code&gt;Application.ensure_all_started&lt;/code&gt; as follows:</source>
          <target state="translated">现在我们得到一个错误，因为 &lt;code&gt;:kv&lt;/code&gt; 依赖的应用程序（在这种情况下是 &lt;code&gt;:logger&lt;/code&gt; ）没有启动。我们需要按照正确的顺序手动启动每个应用程序，或者按如下所示调用 &lt;code&gt;Application.ensure_all_started&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce58c619fafb232c624235ba4ccf102d6952d45a" translate="yes" xml:space="preserve">
          <source>Now we need to change &lt;code&gt;loop_acceptor/1&lt;/code&gt; to use &lt;code&gt;Task.Supervisor&lt;/code&gt; to serve each request:</source>
          <target state="translated">现在我们需要更改 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 以使用 &lt;code&gt;Task.Supervisor&lt;/code&gt; 来服务每个请求：</target>
        </trans-unit>
        <trans-unit id="fdeab946c4d9329d156b88e77a2ec9ecfeddcfa0" translate="yes" xml:space="preserve">
          <source>Now we only need to make &lt;code&gt;KV.RouterTest&lt;/code&gt; pass once again. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">现在我们只需要再次通过 &lt;code&gt;KV.RouterTest&lt;/code&gt; 。为此，我们将编写一个安装块，该安装块在该文件中的所有测试之前运行。设置块将更改应用程序环境，并在完成后将其还原，如下所示：</target>
        </trans-unit>
        <trans-unit id="616d9118cd5824c6691d30e8ef906dec071996ec" translate="yes" xml:space="preserve">
          <source>Now with our routing system in place, let&amp;rsquo;s change &lt;code&gt;KVServer&lt;/code&gt; to use the router. Replace the &lt;code&gt;lookup/2&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt; by the following one:</source>
          <target state="translated">现在有了我们的路由系统，让我们将 &lt;code&gt;KVServer&lt;/code&gt; 更改为使用路由器。用以下命令替换 &lt;code&gt;KVServer.Command&lt;/code&gt; 中的 &lt;code&gt;lookup/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="473b17993b7eb7156690a660695f0604c4095a5c" translate="yes" xml:space="preserve">
          <source>Now with the protocol defined and implementations in hand, we can start using it:</source>
          <target state="translated">现在协议已经定义好了,实现也在手,我们可以开始使用了。</target>
        </trans-unit>
        <trans-unit id="8ac19fd0e99d45eb3bb8a29a0a874c8bc60bad1b" translate="yes" xml:space="preserve">
          <source>Now you can dynamically start supervised tasks:</source>
          <target state="translated">现在你可以动态地启动监管任务。</target>
        </trans-unit>
        <trans-unit id="32df2513a243e616c099ce25eeecd29f8971c442" translate="yes" xml:space="preserve">
          <source>Now you can run tests for both projects from the umbrella root with &lt;code&gt;mix test&lt;/code&gt;. Sweet!</source>
          <target state="translated">现在，您可以从带有 &lt;code&gt;mix test&lt;/code&gt; 的总目录中为这两个项目运行测试。甜！</target>
        </trans-unit>
        <trans-unit id="07b0131f4deaf329edfa37832794fd47dac09e81" translate="yes" xml:space="preserve">
          <source>Now you want to make the &lt;code&gt;heavy_fun()&lt;/code&gt; async:</source>
          <target state="translated">现在您要使 &lt;code&gt;heavy_fun()&lt;/code&gt; 异步：</target>
        </trans-unit>
        <trans-unit id="476ae1fa4f615cd4311df04dc7c8a801b6354a43" translate="yes" xml:space="preserve">
          <source>Now, an entity interested in dispatching events for a given key may call &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of &lt;code&gt;{pid, value}&lt;/code&gt; tuples. In our example, &lt;code&gt;value&lt;/code&gt; will be the &lt;code&gt;{module, function}&lt;/code&gt; tuple in the code above:</source>
          <target state="translated">现在，对分派给定键的事件感兴趣的实体可以调用&lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt;传入键和回调。将使用 &lt;code&gt;{pid, value}&lt;/code&gt; 元组的形式，使用在请求的键下注册的所有值的列表以及注册每个值的进程的PID调用此回调。在我们的示例中， &lt;code&gt;value&lt;/code&gt; 将是上面代码中的 &lt;code&gt;{module, function}&lt;/code&gt; 元组：</target>
        </trans-unit>
        <trans-unit id="d99570fbe4495eecd768739b59540e2e4e121132" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s start two named nodes again, but inside the &lt;code&gt;:kv&lt;/code&gt; application:</source>
          <target state="translated">现在，让我们再次启动两个命名节点，但在 &lt;code&gt;:kv&lt;/code&gt; 应用程序内部：</target>
        </trans-unit>
        <trans-unit id="7056385a9cb5c062d2f526a7af092bf8f6c98b17" translate="yes" xml:space="preserve">
          <source>Now, let's roll back to the first shell:</source>
          <target state="translated">现在,让我们回到第一个外壳。</target>
        </trans-unit>
        <trans-unit id="8883bbf72dbea8b7c2911dc4d03827a0ab88aa71" translate="yes" xml:space="preserve">
          <source>Now, let's start another shell, giving it a name as well:</source>
          <target state="translated">现在,让我们启动另一个shell,也给它起个名字。</target>
        </trans-unit>
        <trans-unit id="b8f14e00a9ee1de5622bfa894ce44aa7673c9977" translate="yes" xml:space="preserve">
          <source>Now, try to access the &lt;code&gt;hello&lt;/code&gt; variable again:</source>
          <target state="translated">现在，尝试再次访问 &lt;code&gt;hello&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="f02afe5290423ebf3ed89e90bd9b4662ee206e07" translate="yes" xml:space="preserve">
          <source>Now, we will get an error if we try to use this operator &quot;out of the box&quot;:</source>
          <target state="translated">现在,如果我们试图 &quot;脱离盒子 &quot;使用这个操作符,我们会得到一个错误。</target>
        </trans-unit>
        <trans-unit id="a053460549010159dc2b6fda3731de548204bf3f" translate="yes" xml:space="preserve">
          <source>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</source>
          <target state="translated">历史记录中要保存的表达式及其结果的数量。该值为整数。为负值时,历史记录不限。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="ff5e98caf48c434c6264af1a2c308ac24882bda5" translate="yes" xml:space="preserve">
          <source>OTP</source>
          <target state="translated">OTP</target>
        </trans-unit>
        <trans-unit id="fa8fe915548f0e22ce68e5cf32adf85a38cb0334" translate="yes" xml:space="preserve">
          <source>OTP exits</source>
          <target state="translated">OTP退出</target>
        </trans-unit>
        <trans-unit id="9ebb04f1d502294523ffc0d5654291733158f382" translate="yes" xml:space="preserve">
          <source>OWN - time spent in the function, excluding the time of called functions</source>
          <target state="translated">OWN-在函数中花费的时间,不包括被调用函数的时间。</target>
        </trans-unit>
        <trans-unit id="5170a26358c94cd0c4d86fad3a0f89ca90839e4e" translate="yes" xml:space="preserve">
          <source>Observe that we were able to considerably change the server implementation without changing any of the client API. That&amp;rsquo;s one of the benefits of explicitly segregating the server and the client.</source>
          <target state="translated">观察到我们能够在不更改任何客户端API的情况下极大地更改服务器实现。这是明确隔离服务器和客户端的好处之一。</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="c85a3d54e191da03c6d7794a838fbe85cdb51bc7" translate="yes" xml:space="preserve">
          <source>Of all the approaches above, the first is definitely the most flexible. If our domain rules can be encoded with data structures, they are by far the easiest to compose and implement, as Elixir&amp;rsquo;s standard library is filled with functions for manipulating different data types.</source>
          <target state="translated">在上述所有方法中，第一种绝对是最灵活的。如果我们的领域规则可以用数据结构进行编码，那么它们是迄今为止最容易编写和实现的，因为Elixir的标准库中包含了用于处理不同数据类型的函数。</target>
        </trans-unit>
        <trans-unit id="902cb7ed7bd72ac12ba23366c9ffb04891ee4dcb" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming system, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">当然,Elixir可用于的领域远不止分布式键值存储。嵌入式系统、数据处理和数据摄取、网络应用、流媒体系统等都是Elixir擅长的许多不同领域。我们希望本指南能让您做好准备,探索这些领域中的任何一个或您可能希望将Elixir引入的任何未来领域。</target>
        </trans-unit>
        <trans-unit id="c9c303f80906a94bd84edefa290936f6df4b3704" translate="yes" xml:space="preserve">
          <source>Official #elixir-lang on freenode IRC</source>
          <target state="translated">freenode IRC上的官方#elixir-lang</target>
        </trans-unit>
        <trans-unit id="5ad3a32fb5de6c096b01951e5ee3be528054408f" translate="yes" xml:space="preserve">
          <source>Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.</source>
          <target state="translated">在Elixir中,经常需要共享或存储必须从不同进程或由同一进程在不同时间点访问的状态。</target>
        </trans-unit>
        <trans-unit id="9f4e555dd4a0b214fc42c4fafafd47bf3b759ac6" translate="yes" xml:space="preserve">
          <source>Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.</source>
          <target state="translated">通常在退出中会出现错误/异常。退出常常被调用者包装,并提供堆栈跟踪。这个函数以一种很好地显示退出原因、调用者和堆栈跟踪的方式来格式化退出。</target>
        </trans-unit>
        <trans-unit id="9323e6675acdba059cc7528c84326fb722f7cf8a" translate="yes" xml:space="preserve">
          <source>Often they are used to express the state of an operation, by using values such as &lt;code&gt;:ok&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">通常，它们通过使用诸如 &lt;code&gt;:ok&lt;/code&gt; 和 &lt;code&gt;:error&lt;/code&gt; 之类的值来表示操作的状态。</target>
        </trans-unit>
        <trans-unit id="7c02ae25b9dec2dd8be94787202587f35da019d9" translate="yes" xml:space="preserve">
          <source>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the &lt;code&gt;put_in/2&lt;/code&gt;, &lt;code&gt;update_in/2&lt;/code&gt; and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</source>
          <target state="translated">通常，我们会在地图内部使用地图，甚至在地图内部使用关键字列表等等。Elixir通过 &lt;code&gt;put_in/2&lt;/code&gt; ， &lt;code&gt;update_in/2&lt;/code&gt; 和其他宏为操作嵌套数据结构提供了便利，从而提供了与命令式语言相同的便利，同时保留了语言的不变属性。</target>
        </trans-unit>
        <trans-unit id="a567fc96e505fa689fb781ec6b8b66b74eefd6f8" translate="yes" xml:space="preserve">
          <source>On Unix-like / Bash:</source>
          <target state="translated">在Unix-like/Bash上。</target>
        </trans-unit>
        <trans-unit id="74b298f2360ded6dbf3b3733dbfa18ae283fccd2" translate="yes" xml:space="preserve">
          <source>On Windows 10 / PowerShell:</source>
          <target state="translated">在Windows 10/PowerShell上。</target>
        </trans-unit>
        <trans-unit id="010a92ca285536db23a909835a24cc3bbd247a77" translate="yes" xml:space="preserve">
          <source>On Windows, path is split on both &quot;\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase.</source>
          <target state="translated">在Windows中,路径是以&quot;/&quot;和&quot;/&quot;两个分隔符来分割的,如果有驱动字母,则总是以小写的方式返回。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">在Windows上。</target>
        </trans-unit>
        <trans-unit id="2779b0cd51a2b5987b501d655bc5be3263bd37e4" translate="yes" xml:space="preserve">
          <source>On its turn, the port will send the connected process the following messages:</source>
          <target state="translated">轮到端口时,端口会向连接的进程发送以下消息。</target>
        </trans-unit>
        <trans-unit id="1c4b199ab2a5a87b093d5ef5b68e83e8d35a8454" translate="yes" xml:space="preserve">
          <source>On the language homepage, we mention that Elixir makes documentation a first-class citizen in the language. We have explored this concept many times throughout this guide, be it via &lt;code&gt;mix help&lt;/code&gt; or by typing &lt;code&gt;h Enum&lt;/code&gt; or another module in an IEx console.</source>
          <target state="translated">在语言首页上，我们提到Elixir使文档成为该语言的一等公民。在本指南中，我们已经通过 &lt;code&gt;mix help&lt;/code&gt; 或通过在IEx控制台中键入 &lt;code&gt;h Enum&lt;/code&gt; 或其他模块来探讨这一概念。</target>
        </trans-unit>
        <trans-unit id="de96232518520933630bd7c423b5ed4b701f263c" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;:stdio&lt;/code&gt; and files opened with &lt;code&gt;:utf8&lt;/code&gt; encoding work with the remaining functions in the &lt;code&gt;IO&lt;/code&gt; module. Those functions expect a &lt;code&gt;char_data&lt;/code&gt; as an argument, that is, a list of characters or strings.</source>
          <target state="translated">另一方面， &lt;code&gt;:stdio&lt;/code&gt; 和以 &lt;code&gt;:utf8&lt;/code&gt; 编码打开的文件可与 &lt;code&gt;IO&lt;/code&gt; 模块中的其余功能一起使用。这些函数期望使用 &lt;code&gt;char_data&lt;/code&gt; 作为参数，即字符或字符串的列表。</target>
        </trans-unit>
        <trans-unit id="df2f9b99e7ba432ec596beb6110247ffca71c5ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;Stream.unfold/2&lt;/code&gt; can be used to generate values from a given initial value:</source>
          <target state="translated">另一方面， &lt;code&gt;Stream.unfold/2&lt;/code&gt; 可用于从给定的初始值生成值：</target>
        </trans-unit>
        <trans-unit id="2b8b9378d09ed0fb2e04b62c07969de258d132e4" translate="yes" xml:space="preserve">
          <source>On the other hand, aliases hold some properties:</source>
          <target state="translated">另一方面,别名拥有一些特性。</target>
        </trans-unit>
        <trans-unit id="cde8a500ad1f4f8eca18ffea106e75b93a90386b" translate="yes" xml:space="preserve">
          <source>On the other hand, function calls without parens are always indented by the function call length itself, like this:</source>
          <target state="translated">另一方面,没有parens的函数调用总是由函数调用长度本身缩进,像这样。</target>
        </trans-unit>
        <trans-unit id="77e130342c984a0c62222639f83873c823bfc21f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;string#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">另一方面，如果要基于整数值动态切片字符串，则使用&lt;a href=&quot;string#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt;是最佳选择，因为它可以确保我们不会将有效的代码点错误地分成多个字节。</target>
        </trans-unit>
        <trans-unit id="96440900cf2787b3d188e44fb23cf1e92e8dffd8" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt; function in this protocol should be implemented whenever you can count the number of elements in the collection.</source>
          <target state="translated">另一方面，只要您可以计算集合中元素的数量，就应该实现此协议中的&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="423d94dfd3979b636b7fca2ef0b1fc6c8a58898a" translate="yes" xml:space="preserve">
          <source>Once a function or a macro is marked as overridable, it will no longer be listed under &lt;a href=&quot;#definitions_in/1&quot;&gt;&lt;code&gt;definitions_in/1&lt;/code&gt;&lt;/a&gt; or return true when given to &lt;a href=&quot;#defines?/2&quot;&gt;&lt;code&gt;defines?/2&lt;/code&gt;&lt;/a&gt; until another implementation is given.</source>
          <target state="translated">一旦将函数或宏标记为可重写，则将不再在&lt;a href=&quot;#definitions_in/1&quot;&gt; &lt;code&gt;definitions_in/1&lt;/code&gt; &lt;/a&gt;下列出该函数或宏，或者将其提供给&lt;a href=&quot;#defines?/2&quot;&gt; &lt;code&gt;defines?/2&lt;/code&gt; &lt;/a&gt;时返回true，直到给出另一个实现。</target>
        </trans-unit>
        <trans-unit id="4be2f449756ad52de4a6efae2bb582fc005c9362" translate="yes" xml:space="preserve">
          <source>Once again, uncomment the last two lines by removing the leading &lt;code&gt;rem &lt;/code&gt; to enable full distribution. And that&amp;rsquo;s all!</source>
          <target state="translated">再次，通过删除 &lt;code&gt;rem &lt;/code&gt; 取消注释最后两行以启用完整分发。就这样！</target>
        </trans-unit>
        <trans-unit id="cfc893eec70ab96edd7de58796885efa4ba9d8ca" translate="yes" xml:space="preserve">
          <source>Once everything was done, we closed the port.</source>
          <target state="translated">一切完成后,我们就关闭了港口。</target>
        </trans-unit>
        <trans-unit id="1621bce168937a18a32ac1d0bc7a6f51d70958e6" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle events in the following format:</source>
          <target state="translated">初始化后,处理程序应设计成以下格式来处理事件。</target>
        </trans-unit>
        <trans-unit id="290699e39f3ba4de6a466924dff98cd449d552b7" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;:logger&lt;/code&gt; application starts, it installs all event handlers listed under the &lt;code&gt;:backends&lt;/code&gt; configuration into the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; event manager. The event manager and all added event handlers are automatically supervised by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一旦 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动，它将在 &lt;code&gt;:backends&lt;/code&gt; 配置下列出的所有事件处理程序安装到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;事件管理器中。事件管理器和所有添加的事件处理程序将由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;自动监督。</target>
        </trans-unit>
        <trans-unit id="bba6866fbd0a67ef6097d91ded25789c9452b004" translate="yes" xml:space="preserve">
          <source>Once the agent is spawned, the given function &lt;code&gt;fun&lt;/code&gt; is invoked in the server process, and should return the initial agent state. Note that &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; does not return until the given function has returned.</source>
          <target state="translated">生成代理后，将在服务器进程中调用给定的函数 &lt;code&gt;fun&lt;/code&gt; ，并且应返回初始代理状态。请注意，直到返回给定的函数，&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;才返回。</target>
        </trans-unit>
        <trans-unit id="ef9558c468b285f17bba1e7f8e7c4f2000f27cc1" translate="yes" xml:space="preserve">
          <source>Once the code above is executed inside an &lt;code&gt;iex&lt;/code&gt; session, IEx will ask if we want to pry into the current code. If accepted, we will be able to access all variables, as well as imports and aliases from the code, directly From IEx. While pry is running, the code execution stops, until &lt;code&gt;continue&lt;/code&gt; is called. Remember you can always run &lt;code&gt;iex&lt;/code&gt; in the context of a project with &lt;code&gt;iex -S mix TASK&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;iex&lt;/code&gt; 会话中执行完以上代码后，IEx将询问我们是否要撬入当前代码。如果被接受，我们将能够直接从IEx访问所有变量以及代码中的导入和别名。虽然撬运行时，代码执行停止，直到 &lt;code&gt;continue&lt;/code&gt; 被调用。请记住，您始终可以使用 &lt;code&gt;iex -S mix TASK&lt;/code&gt; 在项目上下文中运行 &lt;code&gt;iex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="408c96ed6cd23c6d64030f673253fb9a91f2d8a7" translate="yes" xml:space="preserve">
          <source>Once the current application and its dependencies have been started, you can run a script in its context by passing a filename:</source>
          <target state="translated">一旦当前应用程序及其依赖关系被启动,你可以通过传递一个文件名在其上下文中运行一个脚本。</target>
        </trans-unit>
        <trans-unit id="e4b8a6b7ad11f7671cb5874e92543fc2ebfae2db" translate="yes" xml:space="preserve">
          <source>Once the dynamic supervisor is running, we can start children with &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;, which receives a child specification:</source>
          <target state="translated">动态主管运行后，我们可以使用&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;来启动子代，该子代收到子代规范：</target>
        </trans-unit>
        <trans-unit id="a1cbb39ac09f145cd85ea1aba9ba9ce063b8a462" translate="yes" xml:space="preserve">
          <source>Once the monitored port process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">一旦被监控的端口进程死亡,就会向监控进程传递一条消息,其形式为:。</target>
        </trans-unit>
        <trans-unit id="4f02c5f9ebc7bb88dcb63507719013ed2066f7bf" translate="yes" xml:space="preserve">
          <source>Once the monitored process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">一旦被监控的进程死亡,就会向监控进程传递一个消息,其形式为:。</target>
        </trans-unit>
        <trans-unit id="4605c758e24d4c33ee6d08e933b8102e776e5d52" translate="yes" xml:space="preserve">
          <source>Once the project is compiled, you can start an &lt;code&gt;iex&lt;/code&gt; session inside the project by running:</source>
          <target state="translated">编译项目后，您可以通过运行以下命令在项目内启动 &lt;code&gt;iex&lt;/code&gt; 会话：</target>
        </trans-unit>
        <trans-unit id="e867373ffe7847f2db5130572df5f531464178dc" translate="yes" xml:space="preserve">
          <source>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</source>
          <target state="translated">一旦定义了项目,一些默认的Mix任务可以直接从命令行运行。</target>
        </trans-unit>
        <trans-unit id="a6aa7b033fd85bf146e14a8c7160118f513bc8d6" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;registry#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">使用&lt;a href=&quot;registry#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; &lt;/a&gt;以给定名称启动注册表后，即可使用 &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; 元组将其用于注册和访问命名进程：</target>
        </trans-unit>
        <trans-unit id="3120d183e67a369d29bc150b0338b6b8abb5d5d0" translate="yes" xml:space="preserve">
          <source>Once the server is started, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function of the given &lt;code&gt;module&lt;/code&gt; is called with &lt;code&gt;init_arg&lt;/code&gt; as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; has returned.</source>
          <target state="translated">服务器启动后，将使用 &lt;code&gt;init_arg&lt;/code&gt; 作为其参数来调用给定 &lt;code&gt;module&lt;/code&gt; 的&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;函数，以初始化服务器。为确保启动过程同步，此函数直到返回&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;才返回。</target>
        </trans-unit>
        <trans-unit id="737b5a76c492695b1fb2a3499dcde47a6c323b7a" translate="yes" xml:space="preserve">
          <source>Once the server is started, the remaining functions in this module (&lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt;, and friends) will also accept an atom, or any &lt;code&gt;{:global, ...}&lt;/code&gt; or &lt;code&gt;{:via, ...}&lt;/code&gt; tuples. In general, the following formats are supported:</source>
          <target state="translated">服务器启动后，此模块中的其余功能（&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;和friends）也将接受原子或任何 &lt;code&gt;{:global, ...}&lt;/code&gt; 或 &lt;code&gt;{:via, ...}&lt;/code&gt; 元组。通常，支持以下格式：</target>
        </trans-unit>
        <trans-unit id="6cbe4f06fe95e311cfe10127074ff0ebc20f68e2" translate="yes" xml:space="preserve">
          <source>Once the supervisor starts, it will traverse the list of children and it will invoke the &lt;code&gt;child_spec/1&lt;/code&gt; function on each module.</source>
          <target state="translated">主管启动后，它将遍历子级列表，并将在每个模块上调用 &lt;code&gt;child_spec/1&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="1aa3fd67c8a0dadb7a1b2d1e3ee5265a0b531a76" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">编译此模块后，可通过&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;函数获得此信息。</target>
        </trans-unit>
        <trans-unit id="ddada7d31dcc026dad66a50326650a75cc9cbb38" translate="yes" xml:space="preserve">
          <source>Once we change &lt;code&gt;setup&lt;/code&gt;, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the &amp;ldquo;spawns buckets&amp;rdquo; test:</source>
          <target state="translated">更改 &lt;code&gt;setup&lt;/code&gt; ，某些测试将继续失败。您甚至可能会注意到测试在两次运行之间通过并不一致地失败。例如，&amp;ldquo; spawns buckets&amp;rdquo;测试：</target>
        </trans-unit>
        <trans-unit id="1fb2639015e7a539ce9fee1573b15649d727fb15" translate="yes" xml:space="preserve">
          <source>Once you exit the telnet client, you will likely see an error in the IEx session:</source>
          <target state="translated">一旦你退出telnet客户端,你可能会在IEx会话中看到一个错误。</target>
        </trans-unit>
        <trans-unit id="66b9a98849835ca0ccdcfc637fc20489cc149751" translate="yes" xml:space="preserve">
          <source>Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a &lt;code&gt;main&lt;/code&gt; procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic.</source>
          <target state="translated">编译完应用程序后，运行系统就是启动当前应用程序及其依赖项的问题。与其他语言不同，Elixir没有负责启动系统的 &lt;code&gt;main&lt;/code&gt; 过程。而是，您启动一​​个或多个应用程序，每个应用程序都有各自的初始化和终止逻辑。</target>
        </trans-unit>
        <trans-unit id="42b067f2517980dc4135d671302e4a77495e8c98" translate="yes" xml:space="preserve">
          <source>Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts.</source>
          <target state="translated">一旦你的库被配置,它将改变你的库的所有用户的行为。如果一个库希望它把字符串分成2部分,因为配置是全局的,现在它将把它分成3部分。</target>
        </trans-unit>
        <trans-unit id="818ac58ed024c39752c7d32f5237a41c15a038fb" translate="yes" xml:space="preserve">
          <source>One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; has more detailed information on this approach.</source>
          <target state="translated">GenEvent的一种替代方案是一种极小的解决方案，包括使用管理程序和在其下启动的多个GenServer。主管充当&amp;ldquo;事件管理器&amp;rdquo;，子级GenServer充当&amp;ldquo;事件处理程序&amp;rdquo;。这种方法有一些缺点（例如，它不提供背压），但仍然可以用GenEvent替代它的低调用法。&lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;Jos&amp;eacute;Valim的这篇博客文章&lt;/a&gt;提供了有关此方法的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="936a273dad718f4cb0bdcd05e022e88904985504" translate="yes" xml:space="preserve">
          <source>One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt;, which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling &lt;a href=&quot;#iodata_length/1&quot;&gt;&lt;code&gt;iodata_length/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">IO数据的一个缺点是，您无法像使用二进制文件那样在IO数据的第一部分上进行模式匹配之类的事情，因为您通常不知道IO数据的形状。在这种情况下，您可能需要通过调用&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;将其转换为二进制文件，这是相当有效的，因为它是在C语言中本地实现的。其他功能（如计算IO数据的长度）可以通过调用iodata直接计算&lt;a href=&quot;#iodata_length/1&quot;&gt; &lt;code&gt;iodata_length/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="959154f571cdda30a77c0e7157ebda7245e313d8" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;genserver#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir标准库中的可选回调的一个示例是&lt;a href=&quot;genserver#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="682598a408460f45c2b269ef31f62c8ef9525a00" translate="yes" xml:space="preserve">
          <source>One flaw that shows up right away is the ordering issue. Since &lt;code&gt;KV.Registry&lt;/code&gt; invokes &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;, then the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; must be started before &lt;code&gt;KV.Registry&lt;/code&gt;. Otherwise, it may happen that the registry attempts to reach the bucket supervisor before it has started.</source>
          <target state="translated">立即显示的一个缺陷是订购问题。由于 &lt;code&gt;KV.Registry&lt;/code&gt; 调用 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; ， &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 必须在 &lt;code&gt;KV.Registry&lt;/code&gt; 之前启动KV.BucketSupervisor。否则，注册表可能会在启动之前尝试到达存储桶管理程序。</target>
        </trans-unit>
        <trans-unit id="6e4f2997cd25bc613534eada98471130bd76e1d1" translate="yes" xml:space="preserve">
          <source>One may also consider passing the &lt;code&gt;:delayed_write&lt;/code&gt; option if the stream is meant to be written to under a tight loop.</source>
          <target state="translated">如果要在紧密循环中写入流，也可以考虑传递 &lt;code&gt;:delayed_write&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="cfde78399ed297a92cd58c53e350baeaf0f353fe" translate="yes" xml:space="preserve">
          <source>One may be tempted to write:</source>
          <target state="translated">人们可能会很想写。</target>
        </trans-unit>
        <trans-unit id="1781595a1670e5536e6aa5b4d9e3408ffa2c5bc3" translate="yes" xml:space="preserve">
          <source>One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above.</source>
          <target state="translated">人们可能期望它的上限是-12.52。这不是一个错误。大多数小数不能用二进制浮点数表示,因此上面的数字在内部表示为-12.51999999,这解释了上面的行为。</target>
        </trans-unit>
        <trans-unit id="243a9890c71db8191808f5cd66bd3e2313e581bb" translate="yes" xml:space="preserve">
          <source>One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above.</source>
          <target state="translated">人们可能期望它能下限到12.52。这不是一个错误。大多数小数不能用二进制浮点数表示,因此上面的数字在内部表示为12.51999999,这解释了上面的行为。</target>
        </trans-unit>
        <trans-unit id="35c338e7afb24d2e6ec4b29eabef0038bd79d2c7" translate="yes" xml:space="preserve">
          <source>One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay.</source>
          <target state="translated">人们可能会期望它能四舍五入到5.568的一半。这不是一个错误。大多数小数分数不能用二进制浮点数表示,因此上面的数字内部表示为5.567499999,这就解释了上面的行为。如果你想对小数进行精确的四舍五入,你必须使用小数库。上面的行为也符合参考实现,如David M.Gay的 &quot;正确四舍五入的二进制-十进制和十进制-二进制转换&quot;。</target>
        </trans-unit>
        <trans-unit id="75e244bba7b8a676a5ca57c1abcc6a33d031ea31" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle many fields as part of its core. Rather, our best bet is to make the language extensible, so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Elixir的目标之一是可扩展性：开发人员应该能够扩展该语言以适合任何特定领域。计算机科学已经成为一个广阔的领域，以至于一门语言不可能将许多领域作为其核心之一。相反，我们最好的选择是使该语言具有可扩展性，以便开发人员，公司和社区可以将该语言扩展到其相关领域。</target>
        </trans-unit>
        <trans-unit id="442f0d53f86c717b454c40ddbdea4b216903b62b" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">任务的常见用途之一是使用&lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;将顺序代码转换为并发代码，同时保留其语义。调用时，将由调用者创建，链接和监视新进程。任务操作完成后，将向结果发送一条消息给调用方。</target>
        </trans-unit>
        <trans-unit id="45e3c4f5c17e2b30b01adb9fc6c7523fd8a1551d" translate="yes" xml:space="preserve">
          <source>One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code:</source>
          <target state="translated">依靠系统时间的复杂性之一是,它们可能会被调整。例如,当你进入和离开夏令时时,系统时钟将被调整,通常会增加或删除一个小时。我们称这种变化为 &quot;时间扭曲&quot;。为了理解这种变化可能带来的危害,请想象一下下面的代码。</target>
        </trans-unit>
        <trans-unit id="70db34f5d258e3970e35422bd42e5f7aa8840920" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">在&lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 中&lt;/a&gt;可以接受的在监督树之外启动进程的次数很少。与&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;相反， &lt;code&gt;async/await&lt;/code&gt; 机制使您可以完全控制生成的进程生命周期-这也是为什么在使用&lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;启动任务之后必须始终调用&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 的&lt;/a&gt;原因。即使，如果您的应用程序产生了多个异步进程，您也应该考虑使用&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;来更好地了解和监视系统。</target>
        </trans-unit>
        <trans-unit id="50df693ec447426e4660f01fa52af9e0c7763ea8" translate="yes" xml:space="preserve">
          <source>One of the files generated by &lt;code&gt;mix new&lt;/code&gt; is the &lt;code&gt;.formatter.exs&lt;/code&gt;. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the &lt;code&gt;mix format&lt;/code&gt; task. The generated &lt;code&gt;.formatter.exs&lt;/code&gt; file configures which files should be formatted when &lt;code&gt;mix format&lt;/code&gt; runs.</source>
          <target state="translated">&lt;code&gt;mix new&lt;/code&gt; 生成的文件之一是 &lt;code&gt;.formatter.exs&lt;/code&gt; 。Elixir带有一个代码格式化程序，该代码格式化程序能够根据一致的样式自动格式化我们的代码库。格式化程序由 &lt;code&gt;mix format&lt;/code&gt; 任务触发。生成的 &lt;code&gt;.formatter.exs&lt;/code&gt; 文件配置运行 &lt;code&gt;mix format&lt;/code&gt; 时应格式化的文件。</target>
        </trans-unit>
        <trans-unit id="e9bea613040d7bfb9b683e8ec5d094125d04fc14" translate="yes" xml:space="preserve">
          <source>One of the projects in the Elixir organization is &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;the &lt;code&gt;Plug&lt;/code&gt; project&lt;/a&gt;, which is meant to be a common foundation for building web libraries and frameworks in Elixir.</source>
          <target state="translated">Elixir组织中&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;的 &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt;一个项目是Plug项目，该项目旨在成为在Elixir中构建Web库和框架的通用基础。</target>
        </trans-unit>
        <trans-unit id="8bc47161c9d9f59158e06bc671097821742b5b3c" translate="yes" xml:space="preserve">
          <source>One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as &lt;a href=&quot;#version/0&quot;&gt;&lt;code&gt;version/0&lt;/code&gt;&lt;/a&gt; to retrieve the Elixir version and &lt;a href=&quot;#otp_release/0&quot;&gt;&lt;code&gt;otp_release/0&lt;/code&gt;&lt;/a&gt; to retrieve the Erlang/OTP release.</source>
          <target state="translated">一个人不应该依赖于每个字段返回的特定格式。相反，应该使用专门的功能，例如&lt;a href=&quot;#version/0&quot;&gt; &lt;code&gt;version/0&lt;/code&gt; &lt;/a&gt;来获取Elixir版本，而&lt;a href=&quot;#otp_release/0&quot;&gt; &lt;code&gt;otp_release/0&lt;/code&gt; &lt;/a&gt;来获取Erlang / OTP版本。</target>
        </trans-unit>
        <trans-unit id="3debe928eb1b5c8e87fe15888723579e1f0c4c11" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the &lt;code&gt;kv&lt;/code&gt; representation into the tree. That's when the &lt;code&gt;:bind_quoted&lt;/code&gt; option comes to the rescue (again!). By using &lt;code&gt;:bind_quoted&lt;/code&gt;, we can automatically disable unquoting while still injecting the desired variables into the tree:</source>
          <target state="translated">解决此问题的一种方法是禁用宏中的取消引用，但是这样做将无法将 &lt;code&gt;kv&lt;/code&gt; 表示注入到树中。那时候 &lt;code&gt;:bind_quoted&lt;/code&gt; 选项来拯救（再次！）。通过使用 &lt;code&gt;:bind_quoted&lt;/code&gt; ，我们可以自动禁用取消引用，同时仍将所需的变量注入到树中：</target>
        </trans-unit>
        <trans-unit id="d34436b8b519d619492a7f6d60f8ee6b7577de85" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind when using &lt;code&gt;do/end&lt;/code&gt; blocks is they are always bound to the outermost function call. For example, the following expression:</source>
          <target state="translated">使用 &lt;code&gt;do/end&lt;/code&gt; 块时要记住的一件事是它们始终绑定到最外层的函数调用。例如，以下表达式：</target>
        </trans-unit>
        <trans-unit id="6e4d62621d7dc89fa232dc83ec13aa33f3a32463" translate="yes" xml:space="preserve">
          <source>One-liner examples</source>
          <target state="translated">一句话的例子</target>
        </trans-unit>
        <trans-unit id="76d560c48bdb5ca6e530c94b3e593f70eea7f4cf" translate="yes" xml:space="preserve">
          <source>Only a single break point can be set per function. So if you call &lt;code&gt;IEx.break!&lt;/code&gt; multiple times with different patterns, only the last pattern is kept.</source>
          <target state="translated">每个功能只能设置一个断点。因此，如果您致电 &lt;code&gt;IEx.break!&lt;/code&gt; 多次使用不同的模式，仅保留最后一个模式。</target>
        </trans-unit>
        <trans-unit id="91104ae4893712c54ab7b2c242913ddbdd74161a" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;agent#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">只有具有唯一键的注册表才能在 &lt;code&gt;:via&lt;/code&gt; 中使用。如果名称已被使用，则特定于大小写的 &lt;code&gt;start_link&lt;/code&gt; 函数（在上面的示例中为&lt;a href=&quot;agent#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt;）将返回 &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8370e504155b094c81379fca456a5fed9430a083" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仅支持转换ISO日历或其他日期也从午夜开始的日历中的日期。尝试从其他日历转换日期将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46f4e449cb60e2a60400c8cc32b9bd80531293a3" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</source>
          <target state="translated">只支持转换ISO日历中的日期,或其他日历中的日期也从午夜开始。试图转换其他日历中的日期会引发以下问题:</target>
        </trans-unit>
        <trans-unit id="9f0d1de9c28799182839cd339d3cb6bcc84675dc" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</source>
          <target state="translated">只支持转换ISO日历中的日期,或其他日历中的日期也从午夜开始。试图转换其他日历中的日期将返回一个错误元组。</target>
        </trans-unit>
        <trans-unit id="30f7e5d05978072f24365b5caff95955f0fd6ddc" translate="yes" xml:space="preserve">
          <source>Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise.</source>
          <target state="translated">只支持转换ISO日历中的日期时间,尝试转换其他日历中的日期时间会引发。</target>
        </trans-unit>
        <trans-unit id="22f0d29bfd1420b0788307cfc97c7fee840e6505" translate="yes" xml:space="preserve">
          <source>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</source>
          <target state="translated">只支持转换ISO日历中的天真日期时间,尝试转换其他日历中的天真日期时间会引发。</target>
        </trans-unit>
        <trans-unit id="332d85692072489eba14a228f056afbb7b36291a" translate="yes" xml:space="preserve">
          <source>Only the result of the tried expression falls down to the &lt;code&gt;else&lt;/code&gt; clause. If the &lt;code&gt;try&lt;/code&gt; ends up in the &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; clauses, their result will not fall down to &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">只有try表达式的结果才属于 &lt;code&gt;else&lt;/code&gt; 子句。如果 &lt;code&gt;try&lt;/code&gt; 以 &lt;code&gt;rescue&lt;/code&gt; 或 &lt;code&gt;catch&lt;/code&gt; 条款结束，则其结果将不会降为 &lt;code&gt;else&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6a0905b9fcc638e0a1fca8f76bccd9e9d7434ee" translate="yes" xml:space="preserve">
          <source>Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the &lt;code&gt;:{}&lt;/code&gt; special form.</source>
          <target state="translated">在Elixir中，只有两个元素的元组被视为文字，并且在引用时返回它们自己。因此，所有其他元组在AST中都表示为对 &lt;code&gt;:{}&lt;/code&gt; 特殊形式的调用。</target>
        </trans-unit>
        <trans-unit id="16aa064c9dc61340a6a7ced2fa58dff653a9081d" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix normally starts the whole hierarchy of applications defined in our project&amp;rsquo;s &lt;code&gt;mix.exs&lt;/code&gt; file and it does the same for all dependencies if they depend on other applications.</source>
          <target state="translated">糟糕，已经开始了。Mix通常会启动我们项目的 &lt;code&gt;mix.exs&lt;/code&gt; 文件中定义的应用程序的整个层次结构，并且如果依赖于其他应用程序，则对所有依赖项也是如此。</target>
        </trans-unit>
        <trans-unit id="626c544948c998858d0a89d08603d35b395d1a8e" translate="yes" xml:space="preserve">
          <source>Open mechanisms</source>
          <target state="translated">开放机制</target>
        </trans-unit>
        <trans-unit id="3f9c7fb45e8ae0a5da7732a25ef64d2dd5e2f563" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and change the &lt;code&gt;application/0&lt;/code&gt; function to return the following:</source>
          <target state="translated">打开 &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; 并更改 &lt;code&gt;application/0&lt;/code&gt; 函数以返回以下内容：</target>
        </trans-unit>
        <trans-unit id="11e01c21d7ba4061c620362e2623f958eae1be36" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;iex&lt;/code&gt; and type the following expressions:</source>
          <target state="translated">打开 &lt;code&gt;iex&lt;/code&gt; 并输入以下表达式：</target>
        </trans-unit>
        <trans-unit id="d7a32c8b909bef4e4cf763fd044d2d69bd11d7c1" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, and let&amp;rsquo;s change its implementation. We&amp;rsquo;ve added comments to the source code to highlight the changes we&amp;rsquo;ve made:</source>
          <target state="translated">打开 &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; ，让我们更改其实现。我们已经在源代码中添加了注释，以突出显示我们所做的更改：</target>
        </trans-unit>
        <trans-unit id="d182cf46ee852ebeb083e187ed597b6979eb7f37" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; and add the dynamic supervisor as a child as follows:</source>
          <target state="translated">打开 &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 并将动态主管作为子级添加，如下所示：</target>
        </trans-unit>
        <trans-unit id="27d3d6fb25a7f593cdb34dc77c7c498cc6061a34" translate="yes" xml:space="preserve">
          <source>Open up a file, replace all &lt;code&gt;#&lt;/code&gt; by &lt;code&gt;%&lt;/code&gt; and stream to another file without loading the whole file in memory:</source>
          <target state="translated">打开一个文件，将所有 &lt;code&gt;#&lt;/code&gt; 替换为 &lt;code&gt;%&lt;/code&gt; ,然后流式传输到另一个文件，而无需将整个文件加载到内存中：</target>
        </trans-unit>
        <trans-unit id="ece7b632859c06af3b4a35143bf4f0fa432ea01f" translate="yes" xml:space="preserve">
          <source>Opens a port given a tuple &lt;code&gt;name&lt;/code&gt; and a list of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">打开一个给出元组 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 列表的端口。</target>
        </trans-unit>
        <trans-unit id="3bf9b6c6020d1727c93ab3183dfda7cf9cd39780" translate="yes" xml:space="preserve">
          <source>Opens the current prying location.</source>
          <target state="translated">打开当前的窥探位置。</target>
        </trans-unit>
        <trans-unit id="7ac9350441fbbb582d3cc2a8956eb86730e74983" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;module.function/arity&lt;/code&gt;, or &lt;code&gt;{file, line}&lt;/code&gt;.</source>
          <target state="translated">打开给定的 &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;module.function/arity&lt;/code&gt; 或 &lt;code&gt;{file, line}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5014597cdb33f83d370a77bd5b4dfd1154807086" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">打开给定的 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11fb7a6db2170c9e59b49c5c2c758efde86398a0" translate="yes" xml:space="preserve">
          <source>Operating System environment configuration</source>
          <target state="translated">操作系统环境配置</target>
        </trans-unit>
        <trans-unit id="46f82301da497c0a0c802e4991b6eca2df33534d" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;file#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">由于与&lt;a href=&quot;file#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt;相同的原因，操作流在打开时可能会失败。请注意，每次开始流式传输时，文件都会自动打开。不需要通过 &lt;code&gt;:read&lt;/code&gt; 和 &lt;code&gt;:write&lt;/code&gt; 模式，因为Elixir会自动设置这些模式。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0c395ef963d75a809b690d9db937d93c13ee8b98" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
          <target state="translated">操作者优先和关联性</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e0733d98d125d129b916b0d8e46a91b56da34c0e" translate="yes" xml:space="preserve">
          <source>Operators are also represented as such tuples:</source>
          <target state="translated">操作符也是以这样的元组表示。</target>
        </trans-unit>
        <trans-unit id="15dcbf2455ba217cc0f09140af8c2a19b7a3afae" translate="yes" xml:space="preserve">
          <source>Operators are treated as non-qualified calls:</source>
          <target state="translated">操作人员按不合格电话处理。</target>
        </trans-unit>
        <trans-unit id="4a5600ebb83847e5cb5c012f92e0a86888c5caba" translate="yes" xml:space="preserve">
          <source>Opposite of &lt;a href=&quot;#zip/2&quot;&gt;&lt;code&gt;zip/2&lt;/code&gt;&lt;/a&gt;. Extracts two-element tuples from the given &lt;code&gt;enumerable&lt;/code&gt; and groups them together.</source>
          <target state="translated">与&lt;a href=&quot;#zip/2&quot;&gt; &lt;code&gt;zip/2&lt;/code&gt; &lt;/a&gt;相反。从给定的 &lt;code&gt;enumerable&lt;/code&gt; 提取两个元素的元组并将它们分组在一起。</target>
        </trans-unit>
        <trans-unit id="c4b9a19c8a84c9a632d32f40f93da320901bb185" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;#log/3&quot;&gt;&lt;code&gt;log/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and friends, the arguments given to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; are always evaluated. However, you can pass anonymous functions to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; and they will only be evaluated if there is something to be logged.</source>
          <target state="translated">与&lt;a href=&quot;#log/3&quot;&gt; &lt;code&gt;log/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt;，始终评估提供给bare_log / 3的参数。但是，您可以将匿名函数传递给&lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; ,&lt;/a&gt;并且只有在有记录的情况下才会对它们进行评估。</target>
        </trans-unit>
        <trans-unit id="ea31b9298bd98dc4502fbe718b66df80ca6668b5" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">与&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; 相对&lt;/a&gt;，Task具有默认的 &lt;code&gt;:restart&lt;/code&gt; 为 &lt;code&gt;:temporary&lt;/code&gt; 。这意味着该任务即使崩溃也不会重新启动。如果您希望针对失败的退出重新启动任务，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="9edd3623396f77bd089667c715207bed5bf71fe2" translate="yes" xml:space="preserve">
          <source>Opposite to compile, dependencies are not attempted to be automatically solved between files.</source>
          <target state="translated">与编译相反,文件之间不尝试自动解决依赖关系。</target>
        </trans-unit>
        <trans-unit id="e639bcdcf91aa8ac42e5d8553bb30970a11ad173" translate="yes" xml:space="preserve">
          <source>Option values used by &lt;code&gt;start_link&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 使用的选项值</target>
        </trans-unit>
        <trans-unit id="e4c508aa8815a1256a35a88886de2b38e1af4a2a" translate="yes" xml:space="preserve">
          <source>Option values used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 功能使用的选项值</target>
        </trans-unit>
        <trans-unit id="9c404768d955448d9b6f90547eff35b8e6696cf8" translate="yes" xml:space="preserve">
          <source>OptionParser</source>
          <target state="translated">OptionParser</target>
        </trans-unit>
        <trans-unit id="e0257ae00caf99998e2d72ed84d9c0a4e5e38be0" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError</source>
          <target state="translated">OptionParser.ParseError</target>
        </trans-unit>
        <trans-unit id="418ba9c55c2dcefb7a2a957a84d702de99023f76" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">OptionParser.ParseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="515bcb488bbc0e14192e6cad5140e9aea8b7fd33" translate="yes" xml:space="preserve">
          <source>Optional callbacks</source>
          <target state="translated">可选回调</target>
        </trans-unit>
        <trans-unit id="ac614b09920ca40871efbb0a82438a90f0dbe49b" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可选的回调是回调模块可以实现的回调，如果需要的话，但不是必需的。通常，行为模块知道是否应基于配置调用这些回调，或者检查是否使用&lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt;定义了回调。</target>
        </trans-unit>
        <trans-unit id="ec7e5f711e91c3eb5ab6694cb992141e2b1d0f09" translate="yes" xml:space="preserve">
          <source>Optional callbacks can be defined through the &lt;code&gt;@optional_callbacks&lt;/code&gt; module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example:</source>
          <target state="translated">可以通过 &lt;code&gt;@optional_callbacks&lt;/code&gt; 模块属性定义可选的回调，该属性必须是关键字列表，其功能或宏名称为键，arity为值。例如：</target>
        </trans-unit>
        <trans-unit id="f6499468fb5a027c6923e49d62405caa882b21c9" translate="yes" xml:space="preserve">
          <source>Optional parentheses</source>
          <target state="translated">可选括号</target>
        </trans-unit>
        <trans-unit id="1d0891bf09a71f28636a589d4b0d02b002898904" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">可选地，可以传递保护条件列表以进行更精确的匹配。每个保护都是一个元组，它描述应该由模式的指定部分通过的检查。例如， &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 保护条件将表示为 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 元组。请注意，警戒条件只会工作，像赋值的变量 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ， &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 等特殊的比赛变数避免使用 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 和 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; ，因为它可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="7a09f1485253101de1cd882c67ecfea3b7b67e2b" translate="yes" xml:space="preserve">
          <source>Options can be:</source>
          <target state="translated">选项可以是:</target>
        </trans-unit>
        <trans-unit id="efaa2b27718160760d18ba74e06c5819b7a4ab29" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 的选项&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eae55a87aa27e83c0b98f403b07f3b4076428b4" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; 的选项&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="058eb4cd0ba0f3ab247b93a59c7b6bffee0a4161" translate="yes" xml:space="preserve">
          <source>Options used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 功能使用的选项</target>
        </trans-unit>
        <trans-unit id="52f3f8106feac737e0576442e94ddc74fd873217" translate="yes" xml:space="preserve">
          <source>Or also on pattern matching to extract values out:</source>
          <target state="translated">或者也可以在模式匹配上提取值出来。</target>
        </trans-unit>
        <trans-unit id="110400c4fdb0f6e57b930554b0298f99e6f6579b" translate="yes" xml:space="preserve">
          <source>Or also via pattern matching:</source>
          <target state="translated">或者也可以通过模式匹配。</target>
        </trans-unit>
        <trans-unit id="2b8a5d79778b4d39ad8915654992a0b6572ea485" translate="yes" xml:space="preserve">
          <source>Or as a part of function definitions to pattern match:</source>
          <target state="translated">或者作为函数定义的一部分进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="81b6497bf8a349effd8966b9cdac67662ea19529" translate="yes" xml:space="preserve">
          <source>Or even use the async/await pattern:</source>
          <target state="translated">甚至使用async/await模式。</target>
        </trans-unit>
        <trans-unit id="df3698d69c7b1187df56c2f297fdade2ea595981" translate="yes" xml:space="preserve">
          <source>Or on Windows:</source>
          <target state="translated">或在Windows上。</target>
        </trans-unit>
        <trans-unit id="c55b30b404c72029dc39b6c0373f88b3c2117b45" translate="yes" xml:space="preserve">
          <source>Or perhaps you want to make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">或者，也许您想使 &lt;code&gt;KVServer&lt;/code&gt; 端口可配置，并且该端口的值仅在运行时给出：</target>
        </trans-unit>
        <trans-unit id="b3c1ba6ffcae31c642695b4056ca652b985d821d" translate="yes" xml:space="preserve">
          <source>Or simply use pattern matching:</source>
          <target state="translated">或者干脆使用模式匹配。</target>
        </trans-unit>
        <trans-unit id="2e2e0dde765341b0ca22014d3a7b90bc8ecdc978" translate="yes" xml:space="preserve">
          <source>Or to import all functions, you could write:</source>
          <target state="translated">或者要导入所有函数,你可以写。</target>
        </trans-unit>
        <trans-unit id="f146bf6e3a2ae8c150e0ba215da5069807c64480" translate="yes" xml:space="preserve">
          <source>Or to set a breakpoint that will stop 10 times:</source>
          <target state="translated">或者设置一个断点,停止10次。</target>
        </trans-unit>
        <trans-unit id="3d348d5449f71e35f5ea0982362377c8a421346b" translate="yes" xml:space="preserve">
          <source>Or to trigger it whenever the second argument is a map with more than one element:</source>
          <target state="translated">或者每当第二个参数是一个有多个元素的地图时,就触发它。</target>
        </trans-unit>
        <trans-unit id="8b5320509e4f05f8ea43bb4f458da443d14575a8" translate="yes" xml:space="preserve">
          <source>Or, even better:</source>
          <target state="translated">或者,甚至更好。</target>
        </trans-unit>
        <trans-unit id="7346db833d750efbcd6fcd51d602e24a6966464d" translate="yes" xml:space="preserve">
          <source>Or, using the capture syntax:</source>
          <target state="translated">或者,使用捕捉语法。</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="c45740924e5d354064b64521e5aaf12582061570" translate="yes" xml:space="preserve">
          <source>Other agent actions</source>
          <target state="translated">其他代理人行动</target>
        </trans-unit>
        <trans-unit id="cd6ecf7baf7f186954c254a45288721bbe3e452f" translate="yes" xml:space="preserve">
          <source>Other caveats are the impossibility to call count trace BIFs, since breakpoints can only be set on BEAM code; functions calls performed by &lt;code&gt;:cprof&lt;/code&gt; are not traced; the maximum size of a call counter is equal to the host machine's word size (for example, 2147483647 in a 32-bit host).</source>
          <target state="translated">其他注意事项是无法调用计数跟踪BIF，因为只能在BEAM代码上设置断点。 &lt;code&gt;:cprof&lt;/code&gt; 执行的函数调用不会被跟踪；呼叫计数器的最大大小等于主机的字大小（例如，在32位主机中为2147483647）。</target>
        </trans-unit>
        <trans-unit id="dbe1399abe277751b991272fda96ac3cb3827543" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &lt;code&gt;&quot;a&quot;&lt;/code&gt; will not match &lt;code&gt;&quot;A&quot;&lt;/code&gt;.</source>
          <target state="translated">其他字符代表自己。只有在相同位置具有完全相同字符的路径才会匹配。请注意，匹配区分大小写： &lt;code&gt;&quot;a&quot;&lt;/code&gt; 将不匹配 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ce1008fe24127bd6a35c9e94fa13e898855bf85" translate="yes" xml:space="preserve">
          <source>Other constructs are &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;try/rescue/catch/else&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;kernel#match?/2&quot;&gt;&lt;code&gt;match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">其他的结构是&lt;a href=&quot;kernel.specialforms#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;try/rescue/catch/else&lt;/code&gt; &lt;/a&gt;，而&lt;a href=&quot;kernel#match?/2&quot;&gt; &lt;code&gt;match?/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32b26031f2d4ec505f1490c8e029cbbddc736c20" translate="yes" xml:space="preserve">
          <source>Other errors can be raised with &lt;code&gt;raise/2&lt;/code&gt; passing the error name and a list of keyword arguments:</source>
          <target state="translated">可以通过 &lt;code&gt;raise/2&lt;/code&gt; 传递错误名称和关键字参数列表来引发其他错误：</target>
        </trans-unit>
        <trans-unit id="dd317e6d04c14a2ed23576c03ddc173b8001094a" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configure as default either via configuration:</source>
          <target state="translated">其他时区数据库(包括软件包提供的)可以通过配置配置为默认。</target>
        </trans-unit>
        <trans-unit id="3cad5a00eec7472c9a3591c446721f3e6c58c845" translate="yes" xml:space="preserve">
          <source>Other tools and community</source>
          <target state="translated">其他工具和社区</target>
        </trans-unit>
        <trans-unit id="d9b0ed607a935499601e4fd42e28be80554ff28b" translate="yes" xml:space="preserve">
          <source>Otherwise it should return &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; and a default algorithm built on top of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; that runs in linear time will be used.</source>
          <target state="translated">否则它将返回 &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; 并且将使用在&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;之上构建的默认算法，该算法以线性时间运行。</target>
        </trans-unit>
        <trans-unit id="1c81b36166b2eaba733a51d04e61d3fe880c8923" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;nil&lt;/code&gt; in case the module exists, but it isn't a task or cannot be found.</source>
          <target state="translated">否则，如果模块存在，则返回 &lt;code&gt;nil&lt;/code&gt; ，但它不是任务或无法找到。</target>
        </trans-unit>
        <trans-unit id="aa826b74ad8c081871b116d8c34cb3e95cd21b98" translate="yes" xml:space="preserve">
          <source>Otherwise the message is sent and &lt;code&gt;:ok&lt;/code&gt; is returned.</source>
          <target state="translated">否则，将发送该消息并返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cafb8b841614ef77e86d7299d3dbf34c38a0e86" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;KV.Registry&lt;/code&gt; process received a cast with &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; and a call with &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt;, in this sequence. &lt;code&gt;GenServer.cast&lt;/code&gt; will immediately return, as soon as the message is sent to the &lt;code&gt;registry&lt;/code&gt;. The &lt;code&gt;GenServer.call&lt;/code&gt; on the other hand, is where we would be waiting for an answer, provided by the above &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; callback.</source>
          <target state="translated">我们的 &lt;code&gt;KV.Registry&lt;/code&gt; 流程按此顺序接收到带有 &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; 的演员表和带有 &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt; }的电话。消息发送到 &lt;code&gt;registry&lt;/code&gt; 后， &lt;code&gt;GenServer.cast&lt;/code&gt; 将立即返回。该 &lt;code&gt;GenServer.call&lt;/code&gt; ，另一方面，是我们将等待一个答案，由上面提供 &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="32cb7dd97d5b5169235f629b257bf4b1bebebde0" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;kv&lt;/code&gt; application is complete, so it&amp;rsquo;s time to implement the server that will handle the requests we defined in the first chapter:</source>
          <target state="translated">我们的 &lt;code&gt;kv&lt;/code&gt; 应用程序已完成，因此是时候实现将处理我们在第一章中定义的请求的服务器了：</target>
        </trans-unit>
        <trans-unit id="fae76d2c8957b5d3f77fc1cdf6ba676bd9429aa5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;macro_unless&lt;/code&gt; macro received the following:</source>
          <target state="translated">我们的 &lt;code&gt;macro_unless&lt;/code&gt; 宏收到以下信息：</target>
        </trans-unit>
        <trans-unit id="d411cc3e34a79409af812e8a3926471d9c1101c5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;mix.exs&lt;/code&gt; defines two public functions: &lt;code&gt;project&lt;/code&gt;, which returns project configuration like the project name and version, and &lt;code&gt;application&lt;/code&gt;, which is used to generate an application file.</source>
          <target state="translated">我们的 &lt;code&gt;mix.exs&lt;/code&gt; 定义了两个公共函数： &lt;code&gt;project&lt;/code&gt; ，它返回项目配置（如项目名称和版本），而 &lt;code&gt;application&lt;/code&gt; 则用于生成应用程序文件。</target>
        </trans-unit>
        <trans-unit id="4263c0c28d87ce16526214a430448dce9d929e50" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;msg&lt;/code&gt; is printed and &lt;code&gt;print_multiple_times/2&lt;/code&gt; is called again, this time with the second argument set to &lt;code&gt;1&lt;/code&gt;. Because &lt;code&gt;n&lt;/code&gt; is now set to &lt;code&gt;1&lt;/code&gt;, the guard in our first definition of &lt;code&gt;print_multiple_times/2&lt;/code&gt; evaluates to true, and we execute this particular definition. The &lt;code&gt;msg&lt;/code&gt; is printed, and there is nothing left to execute.</source>
          <target state="translated">打印我们的 &lt;code&gt;msg&lt;/code&gt; ， &lt;code&gt;print_multiple_times/2&lt;/code&gt; 再次调用print_multiple_times / 2，这次将第二个参数设置为 &lt;code&gt;1&lt;/code&gt; 。因为 &lt;code&gt;n&lt;/code&gt; 现在设置为 &lt;code&gt;1&lt;/code&gt; ，所以我们在 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 的第一个定义中的守卫的评估结果为true，我们将执行此特定定义。在 &lt;code&gt;msg&lt;/code&gt; 被打印出来，并没有什么留下来执行。</target>
        </trans-unit>
        <trans-unit id="ade0f4f0153f3ee46feb17f06f5a697e3ea8100e" translate="yes" xml:space="preserve">
          <source>Our database engine used by &lt;code&gt;:my_app&lt;/code&gt; needs to know what databases exist, and what the database configurations are. The database engine can make a call to &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; and so forth to retrieve the configuration of each one.</source>
          <target state="translated">&lt;code&gt;:my_app&lt;/code&gt; 使用的数据库引擎需要知道存在哪些数据库以及数据库配置是什么。数据库引擎可以调用 &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; 来检索数据库列表（由模块名称指定）。然后，我们的数据库引擎可以遍历列表中的每个存储库，然后调用 &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; 等等，以检索每个存储库的配置。</target>
        </trans-unit>
        <trans-unit id="a2f6d0c933af7daca11ac7f7ad70a0c3c2249028" translate="yes" xml:space="preserve">
          <source>Our first distributed code</source>
          <target state="translated">我们的第一个分布式代码</target>
        </trans-unit>
        <trans-unit id="9e84809a7c397a309ce96164f5cacbbeaf21e474" translate="yes" xml:space="preserve">
          <source>Our first distributed task retrieves the name of the node the task is running on. Notice we have given an anonymous function to &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; but, in distributed cases, it is preferable to give the module, function, and arguments explicitly:</source>
          <target state="translated">我们的第一个分布式任务检索任务在其上运行的节点的名称。请注意，我们已经为 &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 提供了一个匿名函数，但是在分布式情况下，最好显式提供模块，函数和参数：</target>
        </trans-unit>
        <trans-unit id="87ced78c461b132d154e8f4cf702fd7438182b7f" translate="yes" xml:space="preserve">
          <source>Our first macro</source>
          <target state="translated">我们的第一个宏观</target>
        </trans-unit>
        <trans-unit id="a44749c5086277b1e9b2d47d74121d2d8219a432" translate="yes" xml:space="preserve">
          <source>Our first project</source>
          <target state="translated">我们的第一个项目</target>
        </trans-unit>
        <trans-unit id="b27267683384fbe26b34a46fe89e40b87ffb846e" translate="yes" xml:space="preserve">
          <source>Our first supervisor</source>
          <target state="translated">我们的第一任主管</target>
        </trans-unit>
        <trans-unit id="08203c924a4f2f9eb683fc56d049d3e81c8b3b3e" translate="yes" xml:space="preserve">
          <source>Our first test starts a new &lt;code&gt;KV.Bucket&lt;/code&gt; by calling the &lt;code&gt;start_link/1&lt;/code&gt; and passing an empty list of options. Then we perform some &lt;code&gt;get/2&lt;/code&gt; and &lt;code&gt;put/3&lt;/code&gt; operations on it, asserting the result.</source>
          <target state="translated">我们的第一个测试通过调用 &lt;code&gt;start_link/1&lt;/code&gt; 并传递一个空选项列表来启动一个新的 &lt;code&gt;KV.Bucket&lt;/code&gt; 。然后，我们对其执行一些 &lt;code&gt;get/2&lt;/code&gt; 和 &lt;code&gt;put/3&lt;/code&gt; 操作，并声明结果。</target>
        </trans-unit>
        <trans-unit id="219a6c3d5bbb168da4e01962d5ac3a3beba4fafe" translate="yes" xml:space="preserve">
          <source>Our implementation splits the line on whitespace and then matches the command against a list. Using &lt;code&gt;String.split/1&lt;/code&gt; means our commands will be whitespace-insensitive. Leading and trailing whitespace won&amp;rsquo;t matter, nor will consecutive spaces between words. Let&amp;rsquo;s add some new doctests to test this behaviour along with the other commands:</source>
          <target state="translated">我们的实现在空白处分割行，然后将命令与列表匹配。使用 &lt;code&gt;String.split/1&lt;/code&gt; 意味着我们的命令将对空格不敏感。开头和结尾的空格都无关紧要，单词之间的连续空格也无关紧要。让我们添加一些新的doctest来测试此行为以及其他命令：</target>
        </trans-unit>
        <trans-unit id="4bada33605b3d0085e74cd5e28e1db60fae2e0fd" translate="yes" xml:space="preserve">
          <source>Our integration test checks all server interaction, including unknown commands and not found errors. It is worth noting that, as with</source>
          <target state="translated">我们的集成测试会检查所有的服务器交互,包括未知命令和未发现的错误。值得注意的是,与</target>
        </trans-unit>
        <trans-unit id="34a1175408d05bc3f9db3276c1dc05ef2699c1bd" translate="yes" xml:space="preserve">
          <source>Our integration test will use a TCP client that sends commands to our server and assert we are getting the desired responses.</source>
          <target state="translated">我们的集成测试将使用一个TCP客户端向我们的服务器发送命令,并断言我们正在获得所需的响应。</target>
        </trans-unit>
        <trans-unit id="95fe1b352417a55c924d64b21f5c78849cba47c1" translate="yes" xml:space="preserve">
          <source>Our requirements are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">我们的要求是（请参见 &lt;code&gt;elixir -v&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="535edfb81d4d7fba2950c82c04bae85d9dfbc680" translate="yes" xml:space="preserve">
          <source>Our server functionality is almost complete. Only tests are missing. This time, we have left tests for last because there are some important considerations to be made.</source>
          <target state="translated">我们的服务器功能几乎已经完成。只差测试了。这次,我们把测试留到最后,因为有一些重要的考虑因素要做。</target>
        </trans-unit>
        <trans-unit id="0dd5b4064e68f8312097cf4592e8701596b6f591" translate="yes" xml:space="preserve">
          <source>Our supervisor has a single child so far: &lt;code&gt;KV.Registry&lt;/code&gt;. After we define a list of children, we call &lt;code&gt;Supervisor.init/2&lt;/code&gt;, passing the children and the supervision strategy.</source>
          <target state="translated">到目前为止，我们的主管有一个孩子： &lt;code&gt;KV.Registry&lt;/code&gt; 。定义子项列表后，我们调用 &lt;code&gt;Supervisor.init/2&lt;/code&gt; ，传递子项和监督策略。</target>
        </trans-unit>
        <trans-unit id="26dc3ca3dc381ac59a2d936b2680d93266f92db5" translate="yes" xml:space="preserve">
          <source>Our test case first asserts there&amp;rsquo;s no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.</source>
          <target state="translated">我们的测试用例首先断言注册表中没有存储桶，创建了一个命名存储桶，对其进行了查找，并断言它的行为就像一个存储桶。</target>
        </trans-unit>
        <trans-unit id="e4223734c95ebae3d84c8793615e9933ad56a2e5" translate="yes" xml:space="preserve">
          <source>Our test uses the &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; function to retrieve the child specification out of a module and then assert its restart value is &lt;code&gt;:temporary&lt;/code&gt;. At this point, you may be wondering why use a supervisor if it never restarts its children. It happens that supervisors provide more than restarts, they are also responsible for guaranteeing proper startup and shutdown, especially in case of crashes in a supervision tree.</source>
          <target state="translated">我们的测试使用 &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 函数从模块中检索子规范，然后断言其重新启动值为 &lt;code&gt;:temporary&lt;/code&gt; 。在这一点上，您可能想知道为什么如果从未重新启动其子级，就使用超级用户。监督者提供的不仅仅是重启，他们还负责保证正确的启动和关闭，尤其是在监督树崩溃的情况下。</target>
        </trans-unit>
        <trans-unit id="281569899b0bc371294904a4302b498cefdffdc9" translate="yes" xml:space="preserve">
          <source>Our tests should now (always) pass!</source>
          <target state="translated">我们的测试现在应该(总是)通过了!</target>
        </trans-unit>
        <trans-unit id="9355be26c14e0bdd29f4d7a6d45fdd30c549218b" translate="yes" xml:space="preserve">
          <source>Outdated functions for building child specifications.</source>
          <target state="translated">构建儿童规格的功能过时。</target>
        </trans-unit>
        <trans-unit id="68809f406eda501cceb8a0a76b54d32562163e04" translate="yes" xml:space="preserve">
          <source>Over the next section, we will explore many of Elixir syntax constructs alongside their AST representation.</source>
          <target state="translated">在下一节中,我们将探讨许多Elixir语法结构以及它们的AST表示。</target>
        </trans-unit>
        <trans-unit id="746205fc2b470e87484b958a27628c930425ad5e" translate="yes" xml:space="preserve">
          <source>Overall, the child specification can be one of the following:</source>
          <target state="translated">总的来说,孩子的规格可以是以下几种。</target>
        </trans-unit>
        <trans-unit id="c2d12ad6c158fff98834c1728a418fadd8e620d7" translate="yes" xml:space="preserve">
          <source>Overlined.</source>
          <target state="translated">Overlined.</target>
        </trans-unit>
        <trans-unit id="4678bc356cc17efccf9b8f5a4945bc7564b32a23" translate="yes" xml:space="preserve">
          <source>Parens and no parens in function calls</source>
          <target state="translated">在函数调用中,有parens和无parens。</target>
        </trans-unit>
        <trans-unit id="3e3d2061650e6bfafddfcb21f5627e4ae2f724ca" translate="yes" xml:space="preserve">
          <source>Parentheses are important to support multiple expressions. This:</source>
          <target state="translated">括号对支持多种表达方式很重要。这。</target>
        </trans-unit>
        <trans-unit id="67051571e99ef0293cfd4d98dce041f6d2d0079b" translate="yes" xml:space="preserve">
          <source>Parentheses for non-qualified calls are optional, except for zero-arity calls, which would then be ambiguous with variables. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;. For example, &lt;code&gt;add (1, 2)&lt;/code&gt; is a syntax error, since &lt;code&gt;(1, 2)&lt;/code&gt; is treated as an invalid block which is attempted to be given as a single argument to &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">非合格呼叫的括号是可选的，但零度呼叫除外，后者会与变量产生歧义。如果使用括号，则它们必须紧跟在函数名称后且&lt;em&gt;不能带空格&lt;/em&gt;。例如， &lt;code&gt;add (1, 2)&lt;/code&gt; 是语法错误，因为 &lt;code&gt;(1, 2)&lt;/code&gt; 被视为无效块，试图将其作为 &lt;code&gt;add&lt;/code&gt; 的单个参数给出。</target>
        </trans-unit>
        <trans-unit id="eaccd27612cf8e4c36fdcb2e213e4f30e8b614a2" translate="yes" xml:space="preserve">
          <source>Parentheses for qualified calls are optional. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;.</source>
          <target state="translated">限定呼叫的括号是可选的。如果使用了括号，则它们必须紧随函数名之后，&lt;em&gt;不能带空格&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5051b701bae8cfb193958fe123047596e7c8c957" translate="yes" xml:space="preserve">
          <source>Parenthesised arguments after the anonymous function indicate that we want the function to be evaluated, not just its definition returned. Note that a dot (&lt;code&gt;.&lt;/code&gt;) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling the anonymous function matched to a variable &lt;code&gt;add&lt;/code&gt; and a named function &lt;code&gt;add/2&lt;/code&gt;. We will explore named functions when dealing with &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions&lt;/a&gt;, since named functions can only be defined within a module. For now, just remember that Elixir makes a clear distinction between anonymous functions and named functions.</source>
          <target state="translated">匿名函数后面带括号的参数表示我们希望函数被求值，而不仅仅是返回其定义。请注意，变量和括号之间需要一个点（ &lt;code&gt;.&lt;/code&gt; ）才能调用匿名函数。点确保在调用与变量 &lt;code&gt;add&lt;/code&gt; 匹配的匿名函数与命名函数 &lt;code&gt;add/2&lt;/code&gt; 之间没有歧义。我们将在处理&lt;a href=&quot;modules-and-functions&quot;&gt;模块和&lt;/a&gt;函数时探索命名函数，因为命名函数只能在模块内定义。现在，请记住Elixir明确区分了匿名函数和命名函数。</target>
        </trans-unit>
        <trans-unit id="c6e0c54097c1addd54979adc1a31105e2aaa679a" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;argv&lt;/code&gt; into a keyword list.</source>
          <target state="translated">将 &lt;code&gt;argv&lt;/code&gt; 解析为关键字列表。</target>
        </trans-unit>
        <trans-unit id="7a373d2047627c546c74f485fe9ab21c42c1df91" translate="yes" xml:space="preserve">
          <source>Parses a binary into a float.</source>
          <target state="translated">将二进制解析为浮点数。</target>
        </trans-unit>
        <trans-unit id="9e7e6f51d7020e3f9b0b2f42aa838f86dc50638c" translate="yes" xml:space="preserve">
          <source>Parses a text representation of an integer.</source>
          <target state="translated">解析一个整数的文本表示。</target>
        </trans-unit>
        <trans-unit id="1305b49b9db63d6a1fa5dcb852df3de639b5f930" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;version.requirement&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">将版本需求字符串解析为&lt;a href=&quot;version.requirement&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="a6e9a74770159628fab2a719bf1edd0a31ffec3a" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">将版本字符串解析为&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="fe3857b9469595509888a047a6bc4d80e1165c97" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将版本字符串解析为&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9418b6ddc34fc34c1a8273ea4a0f4abcb6241047" translate="yes" xml:space="preserve">
          <source>Parses a well-formed URI reference into its components.</source>
          <target state="translated">将一个格式良好的URI引用解析为其组件。</target>
        </trans-unit>
        <trans-unit id="79bbadda560fc2696985637c3dcd5d5d75b852e1" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Date and time of day&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">解析&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601：2004&lt;/a&gt;描述的扩展的&amp;ldquo;日期和时间&amp;rdquo;格式。</target>
        </trans-unit>
        <trans-unit id="dea4a820a2ed56415d65f399d0de1e2f38a6464c" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Dates&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">解析&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601：2004&lt;/a&gt;描述的扩展&amp;ldquo;日期&amp;rdquo;格式。</target>
        </trans-unit>
        <trans-unit id="0c980fd66c48ae19c95734093b045d1485842675" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Local time&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">解析&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601：2004&lt;/a&gt;描述的扩展&amp;ldquo;本地时间&amp;rdquo;格式。</target>
        </trans-unit>
        <trans-unit id="4a7afa8fbef89e323ac662c4af9fe0a43a7660ee" translate="yes" xml:space="preserve">
          <source>Parsing unknown switches</source>
          <target state="translated">解析未知开关</target>
        </trans-unit>
        <trans-unit id="058a972530d049d8d1939ad7fe7fdd2aa895b37b" translate="yes" xml:space="preserve">
          <source>Passed (also represented by &lt;code&gt;nil&lt;/code&gt;)</source>
          <target state="translated">通过（也由 &lt;code&gt;nil&lt;/code&gt; 表示）</target>
        </trans-unit>
        <trans-unit id="6c66f210cd28e106c39212344286cce106c8d0d7" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;string#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将 &lt;code&gt;:insert_replaced&lt;/code&gt; 传递给&lt;a href=&quot;string#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89a8204a98999b2bee00cea4fbc5d899e83daf17" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">传递&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 会&lt;/a&gt;自动将其转换为&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;，并丢弃时区信息：</target>
        </trans-unit>
        <trans-unit id="4b3cf5e91c7ff130bc822fb2e1808168e930f058" translate="yes" xml:space="preserve">
          <source>Passing a data type that doesn&amp;rsquo;t implement the protocol raises an error:</source>
          <target state="translated">传递未实现协议的数据类型会引发错误：</target>
        </trans-unit>
        <trans-unit id="f791e277d4e887df822880f6ea245d3e768dd518" translate="yes" xml:space="preserve">
          <source>Passing a list of strings as &lt;code&gt;padding&lt;/code&gt; will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string &lt;code&gt;padding&lt;/code&gt; is equivalent to passing the list of graphemes in it. If no &lt;code&gt;padding&lt;/code&gt; is given, it defaults to whitespace.</source>
          <target state="translated">将字符串列表作为 &lt;code&gt;padding&lt;/code&gt; 传递将为每个缺少的条目占用列表的一个元素。如果列表短于插入数，则填充将从列表的开头重新开始。传递字符串 &lt;code&gt;padding&lt;/code&gt; 等效于传递其中的字素列表。如果未提供 &lt;code&gt;padding&lt;/code&gt; ，则默认为空白。</target>
        </trans-unit>
        <trans-unit id="5e3fd8ecb92634cc65268b6d4476c69ed28e51d4" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将非空列表传递给&lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc442b60927fa3cedca5b49645dcda347c68d43b" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">传递一个非空单 &lt;code&gt;:into&lt;/code&gt; 在 &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0e56540195473b76b76bc99aa7381097cd9285" translate="yes" xml:space="preserve">
          <source>Passing a string that does not represent an integer leads to an error:</source>
          <target state="translated">传递一个不代表整数的字符串会导致错误。</target>
        </trans-unit>
        <trans-unit id="dd3e8286d4953766dd3b3f6ceafaf9431e925e06" translate="yes" xml:space="preserve">
          <source>Pasting multiline expressions into IEx</source>
          <target state="translated">将多行表达式粘贴到 IEx 中</target>
        </trans-unit>
        <trans-unit id="91b58c214080204a7a5e383388a515d0a4b74b02" translate="yes" xml:space="preserve">
          <source>Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise.</source>
          <target state="translated">补丁段如果是字母数字,则按词法比较,否则按数字比较。</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c0c3abe147a53151f7b15d4fc13e0b6734b3694d" translate="yes" xml:space="preserve">
          <source>Path and in umbrella dependencies are automatically recompiled by the parent project whenever they change. While fetchable dependencies, like the ones using &lt;code&gt;:git&lt;/code&gt;, are recompiled only when fetched/updated.</source>
          <target state="translated">父项目在更改路径和伞形依赖关系时会自动对其进行重新编译。虽然可获取的依赖项（如使用 &lt;code&gt;:git&lt;/code&gt; 的依赖项）仅在获取/更新时才重新编译。</target>
        </trans-unit>
        <trans-unit id="8ed7d3defaf72b508bfd8cf537c7e823fe6bd6aa" translate="yes" xml:space="preserve">
          <source>Path options (&lt;code&gt;:path&lt;/code&gt;)</source>
          <target state="translated">路径选项（ &lt;code&gt;:path&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="13e7e11722f7d8309c367ea7823bd6cd32011ced" translate="yes" xml:space="preserve">
          <source>Paths</source>
          <target state="translated">Paths</target>
        </trans-unit>
        <trans-unit id="d5e92258ff6b2634e28eb6ffcaf62f5681cd01e9" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;path#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">在此模块中提供给函数的路径可以是相对于当前工作目录（由&lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt;返回）的路径，也可以是绝对路径。诸如 &lt;code&gt;~&lt;/code&gt; Shell约定不会自动展开。要使用 &lt;code&gt;~/Downloads&lt;/code&gt; 类的路径，可以使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;path#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; &lt;/a&gt;将路径扩展为绝对路径。</target>
        </trans-unit>
        <trans-unit id="1e99640fa7e7a52ff09113ed1f71e7b10259e02c" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;code&gt;_.._&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;_.._&lt;/code&gt; （v1.0）上的模式匹配</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">模式匹配</target>
        </trans-unit>
        <trans-unit id="762812440ca2ae94a95f89714b7b124251968b01" translate="yes" xml:space="preserve">
          <source>Pattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.</source>
          <target state="translated">模式匹配允许开发人员轻松地重构数据类型,如元组和列表。正如我们将在下面的章节中看到的那样,它是Elixir中递归的基础之一,也适用于其他类型,如地图和二进制文件。</target>
        </trans-unit>
        <trans-unit id="fdff00e56a789a8726c9da949b09dd98bd5ff2f6" translate="yes" xml:space="preserve">
          <source>Pattern matching on struct names</source>
          <target state="translated">结构名的模式匹配</target>
        </trans-unit>
        <trans-unit id="2a4de85389e0a217d14b9f1582fdf6651995191b" translate="yes" xml:space="preserve">
          <source>Pattern matching.</source>
          <target state="translated">模式匹配。</target>
        </trans-unit>
        <trans-unit id="d6028e13dbd229af93277e237b2c16fbf94be2cb" translate="yes" xml:space="preserve">
          <source>Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison.</source>
          <target state="translated">模式必须是与存储在注册表中的值的结构匹配的原子或元组。原子 &lt;code&gt;:_&lt;/code&gt; 可用于忽略给定的值或元组元素，而原子 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 可用于将部分模式临时分配给变量以进行后续比较。</target>
        </trans-unit>
        <trans-unit id="5137df8a74cffc5ca199358452463a9c6bfb9074" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/3&quot;&gt;&lt;code&gt;replace/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/2&quot;&gt;&lt;code&gt;split/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;#replace/3&quot;&gt; &lt;code&gt;replace/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#split/2&quot;&gt; &lt;code&gt;split/2&lt;/code&gt; &lt;/a&gt;等函数中使用的模式</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="d8f5c8436b5f5097fc1e0b09aadfb6092ac6af0f" translate="yes" xml:space="preserve">
          <source>Patterns and guards</source>
          <target state="translated">模式和警卫</target>
        </trans-unit>
        <trans-unit id="5c540b06ef6678db51d87771fe4d3939cf8a2687" translate="yes" xml:space="preserve">
          <source>Percent-escapes all characters that require escaping in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">百分号转义所有需要转义为 &lt;code&gt;string&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="0c2d8594907eb7e308e53ec4869ee6591cd32868" translate="yes" xml:space="preserve">
          <source>Percent-unescapes a URI.</source>
          <target state="translated">百分比-取消URI。</target>
        </trans-unit>
        <trans-unit id="e179944907d404a0c32e7b8b6d4faf26105d3528" translate="yes" xml:space="preserve">
          <source>Performance &amp;amp; Optimizations</source>
          <target state="translated">性能与优化</target>
        </trans-unit>
        <trans-unit id="c275fdf2e3e600505a75a54526cffcdd6b781bbb" translate="yes" xml:space="preserve">
          <source>Performs a cast (&lt;em&gt;fire and forget&lt;/em&gt;) operation on the agent state.</source>
          <target state="translated">在代理状态下执行强制转换（即&lt;em&gt;起火&lt;/em&gt;）操作。</target>
        </trans-unit>
        <trans-unit id="2dda6078e429a5da67f4d4b2be41fa1f081b1311" translate="yes" xml:space="preserve">
          <source>Performs a depth-first traversal of quoted expressions using an accumulator.</source>
          <target state="translated">使用累加器对引用的表达式进行深度优先遍历。</target>
        </trans-unit>
        <trans-unit id="4785eea6c091478238fb008cdd410304fdd8d0f0" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">使用累加器对引用的表达式进行深度优先、后序遍历。</target>
        </trans-unit>
        <trans-unit id="32814ff09b644963df4e222c005f1c731fb50119" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions.</source>
          <target state="translated">对引用的表达式进行深度优先、后序遍历。</target>
        </trans-unit>
        <trans-unit id="7b7923e80f9004780986d78cff2f797fee5928bf" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">使用累加器对引用的表达式进行深度优先的预排序遍历。</target>
        </trans-unit>
        <trans-unit id="53d43f5532c10b67e765cd88c0ddb300fe2d8aba" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions.</source>
          <target state="translated">对引用的表达式进行深度优先的预排序遍历。</target>
        </trans-unit>
        <trans-unit id="039534a957eec2fa34791db81532382c587d8245" translate="yes" xml:space="preserve">
          <source>Performs a floored integer division.</source>
          <target state="translated">执行浮动整数除法。</target>
        </trans-unit>
        <trans-unit id="458261426d9d27cb74c83066a9b390fab831f47c" translate="yes" xml:space="preserve">
          <source>Performs an integer division.</source>
          <target state="translated">执行整数除法。</target>
        </trans-unit>
        <trans-unit id="d5fa7b7265385a6a4338c08984b01ec783651ffb" translate="yes" xml:space="preserve">
          <source>Performs cross reference checks between modules.</source>
          <target state="translated">执行模块之间的交叉引用检查。</target>
        </trans-unit>
        <trans-unit id="11854d0712971b76c41b6ad9d5a606d865ee7453" translate="yes" xml:space="preserve">
          <source>Performs remote dispatch checking.</source>
          <target state="translated">进行远程调度检查。</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="0b7522b2ee55a89f041eb7221911aa0a0e32f37f" translate="yes" xml:space="preserve">
          <source>Pipe operator.</source>
          <target state="translated">管道操作员。</target>
        </trans-unit>
        <trans-unit id="3854cbad98a94ad36b9fbd34a9d7759251a83644" translate="yes" xml:space="preserve">
          <source>Pipes &lt;code&gt;expr&lt;/code&gt; into the &lt;code&gt;call_args&lt;/code&gt; at the given &lt;code&gt;position&lt;/code&gt;.</source>
          <target state="translated">将管道 &lt;code&gt;expr&lt;/code&gt; 插入给定 &lt;code&gt;position&lt;/code&gt; 的 &lt;code&gt;call_args&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8ef57d28e73677c96993fd2b8445c1eec249cdff" translate="yes" xml:space="preserve">
          <source>Pitfalls</source>
          <target state="translated">Pitfalls</target>
        </trans-unit>
        <trans-unit id="e5a7b226404fec963975ee16c6feacd0bed5537d" translate="yes" xml:space="preserve">
          <source>Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.</source>
          <target state="translated">将文档放在多句函数的第一个子句之前。文档总是按函数和属性,而不是按子句。</target>
        </trans-unit>
        <trans-unit id="225a7f9c31a9e433302718633fe4e93f7a51a743" translate="yes" xml:space="preserve">
          <source>Please note that all the modules defined in the same file as &lt;code&gt;module&lt;/code&gt; are recompiled and reloaded.</source>
          <target state="translated">请注意，与模块在同一文件中定义的所有 &lt;code&gt;module&lt;/code&gt; 都将重新编译并重新加载。</target>
        </trans-unit>
        <trans-unit id="39c9a395b7a75f7f91d5c9d082bddd97314589a3" translate="yes" xml:space="preserve">
          <source>Please note that by doing this, we are breaking the boilerplate test case which tested the &lt;code&gt;hello&lt;/code&gt; function in &lt;code&gt;KV&lt;/code&gt;. You can simply remove that test case.</source>
          <target state="translated">请注意，这样做将破坏测试 &lt;code&gt;KV&lt;/code&gt; 中 &lt;code&gt;hello&lt;/code&gt; 函数的样板测试用例。您可以简单地删除该测试用例。</target>
        </trans-unit>
        <trans-unit id="5389d292ea210e333906a47db99429702756329e" translate="yes" xml:space="preserve">
          <source>Please note that some details like version numbers may differ a bit in your session; that&amp;rsquo;s not important. From now on &lt;code&gt;iex&lt;/code&gt; sessions will be stripped down to focus on the code. To exit &lt;code&gt;iex&lt;/code&gt; press &lt;code&gt;Ctrl+C&lt;/code&gt; twice.</source>
          <target state="translated">请注意，某些细节，例如版本号，可能在您的会话中有所不同。那不重要。从现在开始， &lt;code&gt;iex&lt;/code&gt; 会话将被精简以专注于代码。要退出 &lt;code&gt;iex&lt;/code&gt; 按两次 &lt;code&gt;Ctrl+C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d11ad5116bd8c797fe89a4d35824e7ca4c61f131" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">请注意，在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; 中&lt;/a&gt;可以找到以下元组函数：</target>
        </trans-unit>
        <trans-unit id="3de0c7e157c52cc856a0f62d452060f6a5131f16" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;the GenServer module documentation&lt;/a&gt; for an overview if you haven&amp;rsquo;t yet. Once you do so, we are ready to proceed.</source>
          <target state="translated">如果尚未获得概述，请阅读&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer模块文档&lt;/a&gt;。一旦您这样做，我们就可以继续进行。</target>
        </trans-unit>
        <trans-unit id="34c26932c8bdaaf11dbb3279895024633d9ddf5b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt; to read more about other ways in which one could use this function. Also, in order to find a full list of other formatting options that one can use alongside &lt;code&gt;IO.inspect/2&lt;/code&gt;, see &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect / 2，&lt;/a&gt;以了解有关可以使用此功能的其他方式的更多信息。另外，为了找到可以与 &lt;code&gt;IO.inspect/2&lt;/code&gt; 一起使用的其他格式选项的完整列表，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e45979c3d32e2c27b3aeac1606c58bb2e6186e8" translate="yes" xml:space="preserve">
          <source>Plugs into Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; (from Erlang/OTP 21) to convert terms to Elixir syntax or wraps Erlang's &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt;&lt;code&gt;:error_logger&lt;/code&gt;&lt;/a&gt; in earlier Erlang/OTP versions to prevent it from overflowing.</source>
          <target state="translated">插入Erlang的&lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt;（来自Erlang / OTP 21）以将术语转换为Elixir语法，或将Erlang的&lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt; &lt;code&gt;:error_logger&lt;/code&gt; &lt;/a&gt;包装在早期的Erlang / OTP版本中以防止其溢出。</target>
        </trans-unit>
        <trans-unit id="22f9e4899d5a9f9e7d7ac5fc03923347cf0dd256" translate="yes" xml:space="preserve">
          <source>Plus a number of functions for working with binaries (bytes) in the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;</source>
          <target state="translated">加上&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; &lt;/a&gt;模块中的一些用于处理二进制文件（字节）的功能</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="5b184d613e5dc77792a5b77d4c71d9a8f5805d12" translate="yes" xml:space="preserve">
          <source>Pops a key from the given nested structure.</source>
          <target state="translated">从给定的嵌套结构中弹出一个键。</target>
        </trans-unit>
        <trans-unit id="f3dbd54145fe56b947320097710efe3fb212dea0" translate="yes" xml:space="preserve">
          <source>Pops a key from the nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">通过给定的 &lt;code&gt;path&lt;/code&gt; 从嵌套结构中弹出一个键。</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="b33456701a07c78fe5d71eef1faf59492a293d96" translate="yes" xml:space="preserve">
          <source>Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing.</source>
          <target state="translated">端口提供了一种机制,用于启动 Erlang 虚拟机外部的操作系统进程,并通过消息传递与之通信。</target>
        </trans-unit>
        <trans-unit id="49af11ce7ff963467dab9d145b8d28e88fbf86cb" translate="yes" xml:space="preserve">
          <source>Possible time zone periods for a certain time zone and wall clock date and time.</source>
          <target state="translated">某一时区可能的时区周期和挂钟日期和时间。</target>
        </trans-unit>
        <trans-unit id="9af262a428ebb097a2a816a84db97bdefe0b3f35" translate="yes" xml:space="preserve">
          <source>Pre-releases are strictly less than their corresponding release versions.</source>
          <target state="translated">预发布的版本严格低于其对应的发布版本。</target>
        </trans-unit>
        <trans-unit id="bda9c25c561aec987e1b78e68cb3669014cebe8e" translate="yes" xml:space="preserve">
          <source>Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens (&lt;code&gt;[0-9A-Za-z-]&lt;/code&gt;):</source>
          <target state="translated">通过在补丁程序版本之后立即添加连字符和一系列以句点分隔的标识符来支持预发行版本。标识符仅由ASCII字母数字字符和连字符（ &lt;code&gt;[0-9A-Za-z-]&lt;/code&gt; ）组成：</target>
        </trans-unit>
        <trans-unit id="1d2dd642b809a9afa37c5b34ef9ccae95e253485" translate="yes" xml:space="preserve">
          <source>Precompilation</source>
          <target state="translated">Precompilation</target>
        </trans-unit>
        <trans-unit id="0b8da57c3b77645c7f2cae0807da41d055f68ad1" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;datetime#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">尽可能使用&lt;a href=&quot;datetime#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; &lt;/a&gt;，因为与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;相反，它将保留时区信息。</target>
        </trans-unit>
        <trans-unit id="193093334a57781999b3ba39585e6cbf824ef0f0" translate="yes" xml:space="preserve">
          <source>Prefix (unary) operator; calculates the bitwise NOT of its argument.</source>
          <target state="translated">前缀(单数)运算符;计算其参数的位上NOT。</target>
        </trans-unit>
        <trans-unit id="eea84a143a5c43eba7121b69efd8599881cd4e88" translate="yes" xml:space="preserve">
          <source>Prepends a path to the beginning of the Erlang VM code path list.</source>
          <target state="translated">在Erlang VM代码路径列表的开头预置一个路径。</target>
        </trans-unit>
        <trans-unit id="ad7544451a00457faefe5c90802b235432b07208" translate="yes" xml:space="preserve">
          <source>Pries into the process environment.</source>
          <target state="translated">撬入流程环境。</target>
        </trans-unit>
        <trans-unit id="c650d1681f475d556e0741952be9bdbed39b594a" translate="yes" xml:space="preserve">
          <source>Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via &lt;a href=&quot;#runtime_info/1&quot;&gt;&lt;code&gt;runtime_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打印虚拟机/运行时信息，例如版本，内存使用情况和统计​​信息。其他主题可通过&lt;a href=&quot;#runtime_info/1&quot;&gt; &lt;code&gt;runtime_info/1&lt;/code&gt; 获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd2dbcf9bebb8d76fc78e7c60efbed06c652a712" translate="yes" xml:space="preserve">
          <source>Prints a file dependency graph where an edge from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt; indicates that &lt;code&gt;A&lt;/code&gt; (source) depends on &lt;code&gt;B&lt;/code&gt; (sink).</source>
          <target state="translated">打印文件依赖性图，其中从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;B&lt;/code&gt; 的边表示 &lt;code&gt;A&lt;/code&gt; （源）依赖于 &lt;code&gt;B&lt;/code&gt; （接收器）。</target>
        </trans-unit>
        <trans-unit id="f89b78f661ed94f4f3264cf20d49cfe3b2271d25" translate="yes" xml:space="preserve">
          <source>Prints a list of all the functions and macros exported by the given module.</source>
          <target state="translated">打印指定模块导出的所有函数和宏的列表。</target>
        </trans-unit>
        <trans-unit id="21cf1dbac4d05fa2e897c927750d4ec851dfdfa6" translate="yes" xml:space="preserve">
          <source>Prints a list of the given directory's contents.</source>
          <target state="translated">打印指定目录的内容列表。</target>
        </trans-unit>
        <trans-unit id="816fa4a9573b3d1eade5973479c5d434df6932d3" translate="yes" xml:space="preserve">
          <source>Prints a message and asks the user if they want to proceed.</source>
          <target state="translated">打印信息并询问用户是否要继续。</target>
        </trans-unit>
        <trans-unit id="e2ec3a4dfe86c240d136373ea35a884bf200c540" translate="yes" xml:space="preserve">
          <source>Prints a message and prompts the user for input.</source>
          <target state="translated">打印信息并提示用户输入。</target>
        </trans-unit>
        <trans-unit id="ddd0491656e97dc3bcc73b8c0fac99539b89b38e" translate="yes" xml:space="preserve">
          <source>Prints all breakpoints to the terminal.</source>
          <target state="translated">打印所有断点到终端。</target>
        </trans-unit>
        <trans-unit id="d45ac7d4540637c6fdc232c2b99937de0319a5e3" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;CALLEE&lt;/code&gt;, which can be one of: &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Module.function&lt;/code&gt;, or &lt;code&gt;Module.function/arity&lt;/code&gt;. Examples:</source>
          <target state="translated">打印给定 &lt;code&gt;CALLEE&lt;/code&gt; 的所有呼叫者，可以是以下之一：&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;Module.function&lt;/code&gt; 或 &lt;code&gt;Module.function/arity&lt;/code&gt; 。例子：</target>
        </trans-unit>
        <trans-unit id="fb7b5b8ff071f99cadfdd753b83a8dcfd047d61c" translate="yes" xml:space="preserve">
          <source>Prints all deprecated &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">打印所有过时的 &quot;file:line:module.function/arity &quot;条目。</target>
        </trans-unit>
        <trans-unit id="c1327228921868a454a53046edb632efd4b315a2" translate="yes" xml:space="preserve">
          <source>Prints all unreachable &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">打印所有无法到达的 &quot;file:line:module.function/arity &quot;条目。</target>
        </trans-unit>
        <trans-unit id="971f6a2d9c15e227f73c83c32352ffad4dff563e" translate="yes" xml:space="preserve">
          <source>Prints information about the data type of any given term.</source>
          <target state="translated">打印任何给定术语的数据类型信息。</target>
        </trans-unit>
        <trans-unit id="3d707a33372771d97f7c17fb4637c172eed3bdd3" translate="yes" xml:space="preserve">
          <source>Prints the current application if it was not printed yet.</source>
          <target state="translated">如果还没有打印,则打印当前的申请。</target>
        </trans-unit>
        <trans-unit id="f8ad915e9dada2c1aa7c7f28d88b5ad48d5e62fb" translate="yes" xml:space="preserve">
          <source>Prints the current application to the shell if it was not printed yet.</source>
          <target state="translated">如果尚未打印当前应用程序,则将其打印到shell中。</target>
        </trans-unit>
        <trans-unit id="b0cbd5cf2d2d3e1ca6d472dc9fce84b12f99639e" translate="yes" xml:space="preserve">
          <source>Prints the current location and stacktrace in a pry session.</source>
          <target state="translated">打印当前位置和pry会话中的stacktrace。</target>
        </trans-unit>
        <trans-unit id="b874478af7120eec5906930f8fa90e197ddb0f5c" translate="yes" xml:space="preserve">
          <source>Prints the current working directory.</source>
          <target state="translated">打印当前工作目录。</target>
        </trans-unit>
        <trans-unit id="f23662b711ee1f5d4b42e4d3962ce84c2e247563" translate="yes" xml:space="preserve">
          <source>Prints the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打印&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="7891ced35c9c114c80c5ffbd1f3c76e017520d37" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given callback function.</source>
          <target state="translated">打印指定回调函数的文档。</target>
        </trans-unit>
        <trans-unit id="435df0bab4049f4242469a352be410f6392ff49a" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given module or for the given &lt;code&gt;function/arity&lt;/code&gt; pair.</source>
          <target state="translated">打印给定模块或给定 &lt;code&gt;function/arity&lt;/code&gt; 对的文档。</target>
        </trans-unit>
        <trans-unit id="520d57f3ac5af5ff431571387cb13b8f42ac807d" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell followed by a newline.</source>
          <target state="translated">将给定的ANSI错误打印到shell中,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="1bafbf3ef8eb7159086bd97a24eb4f293f1a5373" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell followed by a newline.</source>
          <target state="translated">打印给定的ANSI信息到shell,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="499ef41bb785f746215b5a24160f51ee0f225759" translate="yes" xml:space="preserve">
          <source>Prints the types for the given module or for the given function/arity pair.</source>
          <target state="translated">打印给定模块或给定函数/原子对的类型。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="cb2a8bb0b4b97049a59dbbb6853799ec628b02bc" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;undefinedfunctionerror&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">只能从定义私有功能的模块内部访问它们。尝试从其定义的模块外部访问私有函数会导致&lt;a href=&quot;undefinedfunctionerror&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="1ca7456031219f8f2eeb5d52b9d37db3106da6e2" translate="yes" xml:space="preserve">
          <source>Private macros</source>
          <target state="translated">私人宏</target>
        </trans-unit>
        <trans-unit id="df9584791f632e79823605fbe6e78ca4839179b5" translate="yes" xml:space="preserve">
          <source>Private macros are only accessible from the same module in which they are defined.</source>
          <target state="translated">私人宏只能从定义它们的同一个模块中访问。</target>
        </trans-unit>
        <trans-unit id="46cd46eb7732031c3d6591214da75d5f59059290" translate="yes" xml:space="preserve">
          <source>Private macros must be defined before its usage.</source>
          <target state="translated">私人宏必须在使用前定义。</target>
        </trans-unit>
        <trans-unit id="12f4c13a6a06f999cc56eb966c94f71ef2658a3f" translate="yes" xml:space="preserve">
          <source>Process</source>
          <target state="translated">Process</target>
        </trans-unit>
        <trans-unit id="5eaa8e263e7efadbe9297d9c15fb6812d4c60c3a" translate="yes" xml:space="preserve">
          <source>Process-based and application-centric functionality</source>
          <target state="translated">基于流程和以应用为中心的功能</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="a808861bbe2c82040e69c3e43be934abe883b545" translate="yes" xml:space="preserve">
          <source>Processes and group leaders</source>
          <target state="translated">流程和小组长</target>
        </trans-unit>
        <trans-unit id="64cc2973345456132597091b2640ba2a85719adb" translate="yes" xml:space="preserve">
          <source>Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don&amp;rsquo;t share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.</source>
          <target state="translated">在构建容错系统时，过程和链接起着重要作用。Elixir进程是隔离的，默认情况下不共享任何内容。因此，一个进程中的故障将永远不会崩溃或破坏另一个进程的状态。但是，链接允许流程在发生故障的情况下建立关系。我们经常将流程链接到主管，主管将检测流程何时终止，并在其位置开始新流程。</target>
        </trans-unit>
        <trans-unit id="76f3f8bdca9664b89ee735acfb5e747a8d6c7222" translate="yes" xml:space="preserve">
          <source>Processes and raw files</source>
          <target state="translated">处理和原始文件</target>
        </trans-unit>
        <trans-unit id="23eeb001c70f95660b354880626576dbb1964408" translate="yes" xml:space="preserve">
          <source>Processes are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let&amp;rsquo;s write a module that starts new processes that work as a key-value store in a file named &lt;code&gt;kv.exs&lt;/code&gt;:</source>
          <target state="translated">流程是这个问题的最常见答案。我们可以编写无限循环，维护状态以及发送和接收消息的过程。例如，让我们编写一个模块来启动新过程，这些新过程将作为键值存储在名为 &lt;code&gt;kv.exs&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="098f80f89b609eb84c8d74bbd2be6927723c925d" translate="yes" xml:space="preserve">
          <source>Processes get much more interesting when we are able to send and receive messages.</source>
          <target state="translated">当我们能够发送和接收信息时,过程会变得更加有趣。</target>
        </trans-unit>
        <trans-unit id="1c4a0da5abc99ecc4244180ae622b35cf0c5d24f" translate="yes" xml:space="preserve">
          <source>Produces a new list by removing the value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">通过删除指定 &lt;code&gt;index&lt;/code&gt; 处的值来生成新列表。</target>
        </trans-unit>
        <trans-unit id="9e60eab60abd9957404c62c1a08f6416ba3bd550" translate="yes" xml:space="preserve">
          <source>Profile output</source>
          <target state="translated">剖面输出</target>
        </trans-unit>
        <trans-unit id="17a20ce2ecdf2e690491227f705d6a39b4f49280" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;cprof&lt;/code&gt; tool.</source>
          <target state="translated">使用Erlang的 &lt;code&gt;cprof&lt;/code&gt; 工具分析给定的文件或表达式。</target>
        </trans-unit>
        <trans-unit id="9e9508bf92bb3b0baebd12f499bb465caddb8d1d" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;eprof&lt;/code&gt; tool.</source>
          <target state="translated">使用Erlang的 &lt;code&gt;eprof&lt;/code&gt; 工具分析给定的文件或表达式。</target>
        </trans-unit>
        <trans-unit id="7f5a56d02582dfbf0f39138c52e7854843f56715" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;fprof&lt;/code&gt; tool.</source>
          <target state="translated">使用Erlang的 &lt;code&gt;fprof&lt;/code&gt; 工具分析给定的文件或表达式。</target>
        </trans-unit>
        <trans-unit id="a3eb4c5dc8ed98fadb3285836002a5d71bcb1221" translate="yes" xml:space="preserve">
          <source>Project compilation</source>
          <target state="translated">项目汇编</target>
        </trans-unit>
        <trans-unit id="c948166b923ec0b7f32efdb8807735735dd8fe86" translate="yes" xml:space="preserve">
          <source>Projects are often made available to other developers &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;by publishing a Hex package&lt;/a&gt;. Hex also &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;supports private packages for organizations&lt;/a&gt;. If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt;.</source>
          <target state="translated">通常，&lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;通过发布Hex包，&lt;/a&gt;可将项目提供给其他开发人员。Hex还&lt;a href=&quot;https://hex.pm/pricing&quot;&gt;支持组织的专用软件包&lt;/a&gt;。如果为Mix项目配置了ExDoc，则在Hex上发布程序包还将自动将生成的文档发布到&lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="928902bdb5cb34c32542be3d749f35a31372f0b9" translate="yes" xml:space="preserve">
          <source>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</source>
          <target state="translated">项目可以通过添加自己的任务来扩展Mix行为。例如,在您的项目中添加下面的任务,将使每个使用您项目的人都可以使用它。</target>
        </trans-unit>
        <trans-unit id="baaca8514e96b4b82b5f18247ed0611dd75c38c5" translate="yes" xml:space="preserve">
          <source>Projects or applications?</source>
          <target state="translated">项目或应用?</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="c95299144f537818ea4ffc62edc9baddb79ff9f1" translate="yes" xml:space="preserve">
          <source>Protocol consolidation</source>
          <target state="translated">礼宾合并</target>
        </trans-unit>
        <trans-unit id="4924211f292b499a01c2e195003fc6016713268f" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs:</source>
          <target state="translated">在编译过程中,协议合并默认应用于所有Mix项目。这在测试过程中可能会成为一个问题。例如,如果你想在测试期间实现一个协议,那么实现将不会有任何影响,因为协议已经被合并了。一个可能的解决方案是在mix.exs中包含特定于您的测试环境的编译目录。</target>
        </trans-unit>
        <trans-unit id="38f75fd9978f6b7ab60b40a58bd29ed87ef1c6c3" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError</source>
          <target state="translated">Protocol.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b22941c869e24046b71f5c52bd523b215a22df33" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Protocol.UndefinedError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="e4df956dc0223cfa164303e687c5a225641ae40e" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;#defprotocol/2&quot;&gt;&lt;code&gt;defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">协议将多态调度添加到Elixir。它们是可通过数据类型实现的合同。有关协议的更多信息，请参见&lt;a href=&quot;#defprotocol/2&quot;&gt; &lt;code&gt;defprotocol/2&lt;/code&gt; &lt;/a&gt;。Elixir在标准库中提供以下协议：</target>
        </trans-unit>
        <trans-unit id="36627e2d6127b7bd708517ebecfa2ad88acfd239" translate="yes" xml:space="preserve">
          <source>Protocols and Structs</source>
          <target state="translated">协议和结构</target>
        </trans-unit>
        <trans-unit id="bf8ab3000b321cfc5656321edcc2397588fbb0c7" translate="yes" xml:space="preserve">
          <source>Protocols and structs</source>
          <target state="translated">协议和结构</target>
        </trans-unit>
        <trans-unit id="8ae27a72345a1064a4d3cc2a284758812ffebfda" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol. Let&amp;rsquo;s see an example.</source>
          <target state="translated">协议是在Elixir中实现多态性的机制。只要协议实现协议，就可以对任何数据类型进行调度。让我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="77f08665fbb2d92871b41b859bb9813256bbb73a" translate="yes" xml:space="preserve">
          <source>Protocols can also be implemented for multiple types at once:</source>
          <target state="translated">也可以同时实现多种类型的协议。</target>
        </trans-unit>
        <trans-unit id="e0a4f154e26e2407d7bcfe638361358c2a738cf2" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print a &quot;Not implemented&quot; error message. The resulting test case is also tagged with &lt;code&gt;:not_implemented&lt;/code&gt;.</source>
          <target state="translated">提供一个方便的宏，该宏允许使用字符串定义测试，但尚未实现。结果测试将始终失败，并显示&amp;ldquo;未实现&amp;rdquo;错误消息。生成的测试用例也用 &lt;code&gt;:not_implemented&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="28a92a1009021c22f4256b929d5eb72a49f595b7" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string. This macro automatically inserts the atom &lt;code&gt;:ok&lt;/code&gt; as the last line of the test. That said, a passing test always returns &lt;code&gt;:ok&lt;/code&gt;, but, more importantly, it forces Elixir to not tail call optimize the test and therefore avoids hiding lines from the backtrace.</source>
          <target state="translated">提供一个方便的宏，该宏允许使用字符串定义测试。此宏会自动将原子 &lt;code&gt;:ok&lt;/code&gt; 插入到测试的最后一行。也就是说，通过的测试始终返回 &lt;code&gt;:ok&lt;/code&gt; ，但更重要的是，它强制Elixir不要对测试进行优化的尾部调用，因此避免了在回溯中隐藏行。</target>
        </trans-unit>
        <trans-unit id="f485c4915018382897d623e74fdf4c922f5ba9de" translate="yes" xml:space="preserve">
          <source>Provides a set of algorithms to work with enumerables.</source>
          <target state="translated">提供了一套处理可枚举数据的算法。</target>
        </trans-unit>
        <trans-unit id="f7babca163a5798352d200c29bbb4727f2713232" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">提供一个短路运算符，该运算符仅在第一个表达式的计算结果不为真值（即为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）时才计算并返回第二个表达式。否则返回第一个表达式。</target>
        </trans-unit>
        <trans-unit id="5c97af16a870f773f7d8298f32114ae521e291d7" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">提供一个短路运算符，该运算符仅在第一个表达式的计算结果为真值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）时才求值并返回第二个表达式。否则返回第一个表达式。</target>
        </trans-unit>
        <trans-unit id="bb1c1ada41fd138777281c5c60f4b0fbeb1252f7" translate="yes" xml:space="preserve">
          <source>Provides an &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">提供一个&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="7d7f5e01f31db2b96487f259d6815fc4f44d1641" translate="yes" xml:space="preserve">
          <source>Provides an &lt;code&gt;unless&lt;/code&gt; macro.</source>
          <target state="translated">提供一个 &lt;code&gt;unless&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="cc5d7dd7b7f78c70f93425bf23e7c1767df559e1" translate="yes" xml:space="preserve">
          <source>Provides debug, info, warn, and error levels.</source>
          <target state="translated">提供调试、信息、警告和错误级别。</target>
        </trans-unit>
        <trans-unit id="9d218d5f6be5831e733b2aadef5482b512cca16e" translate="yes" xml:space="preserve">
          <source>Provides documentation for the current module.</source>
          <target state="translated">提供当前模块的文档。</target>
        </trans-unit>
        <trans-unit id="da7b097fc28ffbab2557a5f2b082e76f4d69bde6" translate="yes" xml:space="preserve">
          <source>Provides documentation for the entity that follows the attribute. &lt;code&gt;@doc&lt;/code&gt; is to be used with a function, macro, callback, or macrocallback, while &lt;code&gt;@typedoc&lt;/code&gt; with a type (public or opaque).</source>
          <target state="translated">提供属性后的实体的文档。 &lt;code&gt;@doc&lt;/code&gt; 与函数，宏，回调或宏回调 &lt;code&gt;@typedoc&lt;/code&gt; 使用，而@typedoc具有类型（公共或不透明）。</target>
        </trans-unit>
        <trans-unit id="fdadc7bd29e445ef99b6104b5a2b2b038e10ffe9" translate="yes" xml:space="preserve">
          <source>Provides functions to deal with modules during compilation time.</source>
          <target state="translated">提供在编译时处理模块的功能。</target>
        </trans-unit>
        <trans-unit id="df51d0334cfd857e80339917423d4fb2e1cef1c7" translate="yes" xml:space="preserve">
          <source>Provides regular expressions for Elixir.</source>
          <target state="translated">为Elixir提供正则表达式。</target>
        </trans-unit>
        <trans-unit id="d02201797a586702284442194cb247908230a636" translate="yes" xml:space="preserve">
          <source>Provides runtime information about functions, macros, and other information defined by the module.</source>
          <target state="translated">提供模块定义的函数、宏和其他信息的运行时信息。</target>
        </trans-unit>
        <trans-unit id="cc9cbca5a4e02cf60536136ef9f3c6d625c70f6c" translate="yes" xml:space="preserve">
          <source>Provides the deprecation reason for a function. For example:</source>
          <target state="translated">提供一个函数的弃用原因。例如:</target>
        </trans-unit>
        <trans-unit id="eb509e3cef4b01a2055df90985ae11c420fddff2" translate="yes" xml:space="preserve">
          <source>Providing a non-boolean will raise an exception:</source>
          <target state="translated">提供一个非boolean将引发一个异常。</target>
        </trans-unit>
        <trans-unit id="fdaf9976e20d314713bf8ad08c1c0453b92492e1" translate="yes" xml:space="preserve">
          <source>Prunes non-valid UTF-8 code points.</source>
          <target state="translated">修剪无效的UTF-8点码。</target>
        </trans-unit>
        <trans-unit id="fb5dee80e4520a5f254d6238153c6dc561e1cf68" translate="yes" xml:space="preserve">
          <source>Pry and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">撬&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54ec660e29ebb5bec957ff2cb42e6a129ef66da9" translate="yes" xml:space="preserve">
          <source>Pry and macros</source>
          <target state="translated">撬动和宏</target>
        </trans-unit>
        <trans-unit id="1c9019872a4bbfd06ad7b17c0bee064d866590d1" translate="yes" xml:space="preserve">
          <source>Prying and breakpoints</source>
          <target state="translated">撬动和断点</target>
        </trans-unit>
        <trans-unit id="4b2535c1fee183c38427a7089cd2b388b925985a" translate="yes" xml:space="preserve">
          <source>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</source>
          <target state="translated">模块中的公共函数是全局可用的,但为了使用宏,你需要通过要求模块中定义它们来选择加入。</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="25d4b8eeccc56c0cd4a7d514c04c9c3ae243c619" translate="yes" xml:space="preserve">
          <source>Purge compiler modules.</source>
          <target state="translated">清理编译器模块。</target>
        </trans-unit>
        <trans-unit id="b90fc74c10d02d502db87680f321a47d69aa7a2c" translate="yes" xml:space="preserve">
          <source>Puts &lt;code&gt;value&lt;/code&gt; at the given zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 放在 &lt;code&gt;tuple&lt;/code&gt; 中从零开始的给定 &lt;code&gt;index&lt;/code&gt; 处。</target>
        </trans-unit>
        <trans-unit id="ec1e5d54e71eec9873cec8ecdadb097c2ae427d5" translate="yes" xml:space="preserve">
          <source>Puts a module attribute with &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; in the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">将具有 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 的模块属性放入给定 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4acfce1f0b23360b26c12b5e6c7bf2a6bf918d25" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">通过给定 &lt;code&gt;path&lt;/code&gt; 将值放入嵌套结构中。</target>
        </trans-unit>
        <trans-unit id="7c0b337e86b25912f1d42a657325dc6d8a9a7246" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure.</source>
          <target state="translated">将一个值放入嵌套结构中。</target>
        </trans-unit>
        <trans-unit id="48a23971095bfbe373d39b1f1c70ac23fcde2d47" translate="yes" xml:space="preserve">
          <source>Puts the &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 放在给定 &lt;code&gt;app&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="97d0f1caf6e213cd26ac881b852140f4d9d23037" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a &quot;hibernation&quot; state.</source>
          <target state="translated">使调用过程进入 &quot;休眠 &quot;状态。</target>
        </trans-unit>
        <trans-unit id="cadfddef2accc558bb07d494514e7ca1c284d964" translate="yes" xml:space="preserve">
          <source>Puts the environment for multiple apps at the same time.</source>
          <target state="translated">将多个应用程序的环境同时放入。</target>
        </trans-unit>
        <trans-unit id="b6ea1ba815fc83f69431f0cdd76f4213b86b1a54" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 放在 &lt;code&gt;map&lt;/code&gt; 中的 &lt;code&gt;key&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="de7749bbf077f512273bf8036b7cb8fc0deef364" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 放在 &lt;code&gt;key&lt;/code&gt; 下，除非输入 &lt;code&gt;key&lt;/code&gt; 已经存在于 &lt;code&gt;map&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9b4d02cfb162ff8a780c85d472f56775f06bd43e" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists.</source>
          <target state="translated">除非输入 &lt;code&gt;key&lt;/code&gt; 已存在，否则将给定 &lt;code&gt;value&lt;/code&gt; 放在 &lt;code&gt;key&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="801eb18f7c8ac7d16195e64a31d50b2a30aa8262" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 放在 &lt;code&gt;key&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="a87585b69b086c147f372f2e5a1d39fb50ad8a31" translate="yes" xml:space="preserve">
          <source>Qualified calls (remote calls)</source>
          <target state="translated">合格电话(远程电话)</target>
        </trans-unit>
        <trans-unit id="665a6bcf289c1518f036a63e86791885bb3d1c3f" translate="yes" xml:space="preserve">
          <source>Qualified calls, such as &lt;code&gt;Math.add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscores. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">合格的调用（例如 &lt;code&gt;Math.add(1, 2)&lt;/code&gt; 必须以下划线或Unicode字母（大写或大写字母除外）开头。可以使用一系列Unicode字母，数字和下划线继续进行呼叫。通话可能以 &lt;code&gt;?&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d47a22f953dc2b31cf6bc6440050b0aaf55f9649" translate="yes" xml:space="preserve">
          <source>Quote and macros</source>
          <target state="translated">报价和宏</target>
        </trans-unit>
        <trans-unit id="398f0ab8b840b28a0fd354d1c0d7a72c7d9d306e" translate="yes" xml:space="preserve">
          <source>Quote and unquote</source>
          <target state="translated">引用和不引用</target>
        </trans-unit>
        <trans-unit id="d94e69560e301502d99603fd94eaa70bde805275" translate="yes" xml:space="preserve">
          <source>Quote is about retrieving the inner representation of some particular chunk of code. However, sometimes it may be necessary to inject some other particular chunk of code inside the representation we want to retrieve.</source>
          <target state="translated">Quote是关于检索一些特定代码块的内部表示。然而,有时可能需要在我们要检索的表示法中注入一些其他特定的代码块。</target>
        </trans-unit>
        <trans-unit id="dc325775a37291e9e0f216be4d97c9b52b5046b9" translate="yes" xml:space="preserve">
          <source>Quoted and unquoted atoms with the same name are considered equivalent, so &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;:&quot;atom&quot;&lt;/code&gt;, and &lt;code&gt;:'atom'&lt;/code&gt; represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.</source>
          <target state="translated">报价，具有相同名称的未引用的原子被认为是等价的，因此 &lt;code&gt;:atom&lt;/code&gt; ， &lt;code&gt;:&quot;atom&quot;&lt;/code&gt; ，和 &lt;code&gt;:'atom'&lt;/code&gt; 代表相同的原子。唯一的问题是，当在不需要加引号的原子中使用引号时，编译器将发出警告。</target>
        </trans-unit>
        <trans-unit id="3a432aa09de3e72168ea6a4c0658a86a59f5a08d" translate="yes" xml:space="preserve">
          <source>Quoted expression</source>
          <target state="translated">引用的表述</target>
        </trans-unit>
        <trans-unit id="1d3b684c7214d0c281c4454aed5c04034ff88811" translate="yes" xml:space="preserve">
          <source>Quoted identifiers, such as strings (&lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt;) and charlists (&lt;code&gt;'ol&amp;aacute;'&lt;/code&gt;), support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.</source>
          <target state="translated">自Elixir v1.0起，带引号的标识符（例如字符串（ &lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt; ）和字符列表（ &lt;code&gt;'ol&amp;aacute;'&lt;/code&gt; ））就支持Unicode。字符串是UTF-8编码的。字符列表是Unicode代码点的列表。在这种情况下，内容将保持开发人员编写的形式，而无需进行任何转换。</target>
        </trans-unit>
        <trans-unit id="60fefb29eda0237f92306cb85899330ca8b230ee" translate="yes" xml:space="preserve">
          <source>Quoting</source>
          <target state="translated">Quoting</target>
        </trans-unit>
        <trans-unit id="db712921d6fecc09e09fab853318c381738ce114" translate="yes" xml:space="preserve">
          <source>R1. Default Identifiers</source>
          <target state="translated">R1.默认标识符</target>
        </trans-unit>
        <trans-unit id="26b991df92308f2a367c957c4d50b613aa415ed2" translate="yes" xml:space="preserve">
          <source>R3. Pattern_White_Space and Pattern_Syntax Characters</source>
          <target state="translated">R3.Pattern_White_Space和Pattern_Syntax字符。</target>
        </trans-unit>
        <trans-unit id="64f597518b8819e33beed326e0aef13663d12b03" translate="yes" xml:space="preserve">
          <source>R6. Filtered Normalized Identifiers</source>
          <target state="translated">R6.过滤后的标准化标识符</target>
        </trans-unit>
        <trans-unit id="6f4503a9f856bd401816cf9c9537b400021fea70" translate="yes" xml:space="preserve">
          <source>Race conditions?</source>
          <target state="translated">比赛条件?</target>
        </trans-unit>
        <trans-unit id="8fdd3d5744b14fe8df2f78525ff278b3980dcf70" translate="yes" xml:space="preserve">
          <source>Raised when a struct cannot be inspected.</source>
          <target state="translated">当一个结构不能被检查时,发生该事件。</target>
        </trans-unit>
        <trans-unit id="fa9e03b9a6f82b7dabd4d26d477bd23b2afc1a4f" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">如果给定的 &lt;code&gt;padding&lt;/code&gt; 包含非字符串元素，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af83d7d1086d026fc286f4645bae49fd7306d517" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">如果 &lt;code&gt;enumerable&lt;/code&gt; 包含非数字值，则引发&lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d76c0d9f487f5fbe07e874551d88d47fee0d896" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 为0或0.0，则引发&lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c67dbd468ad8055254ab3928808c3935464e4ce" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;enum.emptyerror&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">如果 &lt;code&gt;enumerable&lt;/code&gt; 为空，则引发&lt;a href=&quot;enum.emptyerror&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2d343a2295f4d5274dcbfd886a84ccb41642f80" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OutOfBoundsError&lt;/code&gt; if the given &lt;code&gt;index&lt;/code&gt; is outside the range of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果给定的 &lt;code&gt;index&lt;/code&gt; 超出了 &lt;code&gt;enumerable&lt;/code&gt; 的范围，则引发 &lt;code&gt;OutOfBoundsError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d62f9ebd9e34654105a0b6ae931724ee62a02cc0" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">如果两个给定版本中的任何一个都不可解析，则引发&lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt;异常。如果给出了已经解析的版本，则此函数不会提高。</target>
        </trans-unit>
        <trans-unit id="cab5e5df328b4ddb83cc91a4e5866b2d049b9bdc" translate="yes" xml:space="preserve">
          <source>Raises a Mix error that is nicely formatted.</source>
          <target state="translated">引发一个格式很好的Mix错误。</target>
        </trans-unit>
        <trans-unit id="c1c33aaefd8234c7625624d93eaccbd66022ca1e" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果参数之一不是整数，或者 &lt;code&gt;divisor&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则引发&lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="b9f054f51eef773e350ffd8e720d8ef1c2f7f1d3" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;base&lt;/code&gt; is less than 2 or more than 36.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 小于2或大于36，则引发错误。</target>
        </trans-unit>
        <trans-unit id="81fe4cb7e7c869e7a34bf872a48cb536514bff12" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;supervisor&lt;/code&gt; has reached the maximum number of children.</source>
          <target state="translated">如果 &lt;code&gt;supervisor&lt;/code&gt; 达到最大孩子数，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="f213a5266dc7fd081628bda995fed2c1460d6ab8" translate="yes" xml:space="preserve">
          <source>Raises an error if all conditions evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. For this reason, it may be necessary to add a final always-truthy condition (anything non-&lt;code&gt;false&lt;/code&gt; and non-&lt;code&gt;nil&lt;/code&gt;), which will always match.</source>
          <target state="translated">如果所有条件的评估结果均为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ,则会引发错误。出于这个原因，可能有必要添加最终总是truthy条件（任何非 &lt;code&gt;false&lt;/code&gt; 和非 &lt;code&gt;nil&lt;/code&gt; ），这将永远匹配。</target>
        </trans-unit>
        <trans-unit id="6807fc8ee18e17589e66f450694ceab675bbe0db" translate="yes" xml:space="preserve">
          <source>Raises an error if retrieving or changing the current directory fails.</source>
          <target state="translated">如果检索或更改当前目录失败,会引发错误。</target>
        </trans-unit>
        <trans-unit id="164b30096b2ea6dfc6e8c86db79c4ab887d2f1ec" translate="yes" xml:space="preserve">
          <source>Raises an error if the module was already compiled.</source>
          <target state="translated">如果该模块已经被编译,则引发错误。</target>
        </trans-unit>
        <trans-unit id="1ba05d6b0411d4457bd3803cd3e4d8649a31a71f" translate="yes" xml:space="preserve">
          <source>Raises an exception preserving a previous stacktrace.</source>
          <target state="translated">引发一个异常,保留之前的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="437ea54b50fe87d412f3bb3184bcdd4a6c352ece" translate="yes" xml:space="preserve">
          <source>Raises an exception.</source>
          <target state="translated">引发异常。</target>
        </trans-unit>
        <trans-unit id="a4d46f156dd7b4a5a2ee33034cfcad27d106e75f" translate="yes" xml:space="preserve">
          <source>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</source>
          <target state="translated">如果日期时间无效,则发出警报。试图转换一个无效的ISO日历日期将产生一个错误元组。</target>
        </trans-unit>
        <trans-unit id="71d1ef80cf35651a172132daf389ed313ef6e315" translate="yes" xml:space="preserve">
          <source>Raises if the format is invalid.</source>
          <target state="translated">如果格式无效,则发出警报。</target>
        </trans-unit>
        <trans-unit id="6519231f297c411772999cd1e8103552ac99be07" translate="yes" xml:space="preserve">
          <source>Raising exceptions</source>
          <target state="translated">提出例外情况</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="72464e74832155795bb0fc97baa40a95fbc7222b" translate="yes" xml:space="preserve">
          <source>Ranges can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). Ranges are also always inclusive.</source>
          <target state="translated">范围可以增加（ &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ）或减少（ &lt;code&gt;first &amp;gt; last&lt;/code&gt; ）。范围也总是包含在内的。</target>
        </trans-unit>
        <trans-unit id="cbd90679e7f8a9b39ae9a6c5d2cc092800f54ef9" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;date#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">必须使用&lt;a href=&quot;date#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt;函数创建范围。</target>
        </trans-unit>
        <trans-unit id="d488a3099ab1cce2c7739fdbf692916264525f0d" translate="yes" xml:space="preserve">
          <source>Ranges of dates can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). They are also always inclusive.</source>
          <target state="translated">日期范围可以增加（ &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ）或减少（ &lt;code&gt;first &amp;gt; last&lt;/code&gt; ）。它们也总是包容性的。</target>
        </trans-unit>
        <trans-unit id="8a225b1af2c34f53e990659786a3df7dde051221" translate="yes" xml:space="preserve">
          <source>Raw files</source>
          <target state="translated">原始文件</target>
        </trans-unit>
        <trans-unit id="43be5d1fec74173cc456fcdb989d79f3a6d61e9b" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module documentation for more information about the general usage of &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#async/3&quot;&gt;&lt;code&gt;async/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">阅读&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;模块文档以获取有关&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#async/3&quot;&gt; &lt;code&gt;async/3&lt;/code&gt; &lt;/a&gt;常规用法的更多信息。</target>
        </trans-unit>
        <trans-unit id="0788c3b600d4f3c0505743b96b49889736ec2d75" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">阅读 &lt;code&gt;Typespec&lt;/code&gt; 页面和&lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt;上的文档，以分别获取有关Typespec和位字符串的更多信息。</target>
        </trans-unit>
        <trans-unit id="a3889ae6a98ae0e53caf306c3aba6c242dcedd31" translate="yes" xml:space="preserve">
          <source>Reads a line from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">从IO &lt;code&gt;device&lt;/code&gt; 读取一条线。</target>
        </trans-unit>
        <trans-unit id="ed6358cfae9ed346de26368ca0c1a237b2160331" translate="yes" xml:space="preserve">
          <source>Reads a timer created by &lt;a href=&quot;#send_after/3&quot;&gt;&lt;code&gt;send_after/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">读取&lt;a href=&quot;#send_after/3&quot;&gt; &lt;code&gt;send_after/3&lt;/code&gt; &lt;/a&gt;创建的计时器。</target>
        </trans-unit>
        <trans-unit id="31e0122bb1cd5932aff410ddb26d3668b99408af" translate="yes" xml:space="preserve">
          <source>Reads and writes attributes of the current module.</source>
          <target state="translated">读取和写入当前模块的属性。</target>
        </trans-unit>
        <trans-unit id="e5909314d3283d89421e87193f2a66ac8fa016fa" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">从IO &lt;code&gt;device&lt;/code&gt; 读取。</target>
        </trans-unit>
        <trans-unit id="812e657f5b579f0750a1f48f3ac381f21e7e7a7d" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;. The operation is Unicode unsafe.</source>
          <target state="translated">从IO &lt;code&gt;device&lt;/code&gt; 读取。该操作是Unicode不安全的。</target>
        </trans-unit>
        <trans-unit id="a1e72b88bea14f6ca08acd272c7aa85760735eeb" translate="yes" xml:space="preserve">
          <source>Reads registry metadata given on &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">读取在&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;上给出的注册表元数据。</target>
        </trans-unit>
        <trans-unit id="6e4bfe8b8059fffe67509581ca8fd8bb5863a979" translate="yes" xml:space="preserve">
          <source>Reads the client request and writes a response back</source>
          <target state="translated">读取客户端请求并写回响应。</target>
        </trans-unit>
        <trans-unit id="d5eb24730d097e029875864fbd190d1f5f20b06f" translate="yes" xml:space="preserve">
          <source>Reads the configuration file.</source>
          <target state="translated">读取配置文件。</target>
        </trans-unit>
        <trans-unit id="dc12f308ba360c8064a3568dfa28b47e57204e51" translate="yes" xml:space="preserve">
          <source>Reads the current process metadata.</source>
          <target state="translated">读取当前进程元数据。</target>
        </trans-unit>
        <trans-unit id="c48fac6c8d1d06337a98d9b155bf84f8445d1d91" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file alongside its imports.</source>
          <target state="translated">读取给定的配置文件及其导入文件。</target>
        </trans-unit>
        <trans-unit id="6d834acb879e83f8d42700d86e86927b636c6aea" translate="yes" xml:space="preserve">
          <source>Reads the symbolic link at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">读取 &lt;code&gt;path&lt;/code&gt; 处的符号链接。</target>
        </trans-unit>
        <trans-unit id="9c1cdacc82e6db0a4e1b004d6bdbb8cec9ef88a1" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and deletes the first tuple where the element at &lt;code&gt;position&lt;/code&gt; matches the given &lt;code&gt;key&lt;/code&gt;. Returns the new list.</source>
          <target state="translated">接收元组 &lt;code&gt;list&lt;/code&gt; ，并删除 &lt;code&gt;position&lt;/code&gt; 上的元素与给定 &lt;code&gt;key&lt;/code&gt; 匹配的第一个元组。返回新列表。</target>
        </trans-unit>
        <trans-unit id="5c5edba47e63948282ba7aa49263dd69fdc08f5b" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and replaces the element identified by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">接收一个 &lt;code&gt;list&lt;/code&gt; 的元组和替换由标识的元素 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;position&lt;/code&gt; 与 &lt;code&gt;new_tuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52a2ed027070830b2b704b10a1ab579fee6aa05a" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;, as well as the &lt;code&gt;list&lt;/code&gt; without found tuple.</source>
          <target state="translated">接收元组 &lt;code&gt;list&lt;/code&gt; ，并返回第一个元组（该元组中位于 &lt;code&gt;position&lt;/code&gt; 的元素与给定 &lt;code&gt;key&lt;/code&gt; 匹配）以及没有找到元组的 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53639bc3bc3a88fb72d354e316fd411a08ad54fc" translate="yes" xml:space="preserve">
          <source>Receives a key-value enumerable and converts it to &lt;a href=&quot;#t:argv/0&quot;&gt;&lt;code&gt;argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接收可枚举的键值并将其转换为&lt;a href=&quot;#t:argv/0&quot;&gt; &lt;code&gt;argv/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8a8cddc4edd4b8cb647e915685f66b6aa81c4ae" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; (workers or supervisors) to supervise and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">接收要监督的 &lt;code&gt;children&lt;/code&gt; （工人或主管）的列表和一组 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe2e430f09d68bd297bf576261b80cdda5635920" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; to initialize and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">接收要初始化的 &lt;code&gt;children&lt;/code&gt; 列表和一组 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f56a4374996752d9c7b0d8cda70d77fc3e98719" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and if the identified element by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; exists, it is replaced with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">接收元组的列表，并且如果由标识的元素 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;position&lt;/code&gt; 存在，它会被替换 &lt;code&gt;new_tuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d1535576671aa2ff6cdb67db512b203dfc4edba" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns &lt;code&gt;true&lt;/code&gt; if there is a tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">接收元组和回报的名单 &lt;code&gt;true&lt;/code&gt; ，如果有一个地方在元元组 &lt;code&gt;position&lt;/code&gt; 的元组给定的匹配 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f773b7b4671a15478a78104b05a8ac1289c68e25" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">接收元组列表，并返回其中的元件中的第一元组 &lt;code&gt;position&lt;/code&gt; 的元组给定的匹配 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da55da43556e6c04aee3a123495216a662a853e8" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and sorts the elements at &lt;code&gt;position&lt;/code&gt; of the tuples. The sort is stable.</source>
          <target state="translated">接收元组列表并对元组 &lt;code&gt;position&lt;/code&gt; 处的元素进行排序。排序是稳定的。</target>
        </trans-unit>
        <trans-unit id="14e20d5c24dff9fd9fe9735cab3e8e1de2a2fe94" translate="yes" xml:space="preserve">
          <source>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">接收一个模块、fun和arity,并按照stacktraces中的格式化。arity也可以是一个参数列表。</target>
        </trans-unit>
        <trans-unit id="e687df4d6dc594b8acd5822458421f8788bb8599" translate="yes" xml:space="preserve">
          <source>Receives a protocol and a list of implementations and consolidates the given protocol.</source>
          <target state="translated">接收协议和实施清单,并合并给定协议。</target>
        </trans-unit>
        <trans-unit id="22210bb4fc25b4244ff90b5d68a7d14f3ce7571b" translate="yes" xml:space="preserve">
          <source>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement.</source>
          <target state="translated">接收一个regex,一个二进制和一个替换,返回一个新的二进制,所有的匹配都被替换。</target>
        </trans-unit>
        <trans-unit id="b61e49df8ff67a9ca03bd1b42a8bb519e4a1c105" translate="yes" xml:space="preserve">
          <source>Receives a set of &lt;code&gt;options&lt;/code&gt; that initializes a dynamic supervisor.</source>
          <target state="translated">接收一组用于初始化动态主管的 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9f6da4d53fe4ab814d14ca17ef2d1aa84915fba" translate="yes" xml:space="preserve">
          <source>Receives a stacktrace entry and formats it into a string.</source>
          <target state="translated">接收一个stacktrace条目并将其格式化为一个字符串。</target>
        </trans-unit>
        <trans-unit id="e7746187c8e8540596d6f16990c4f1faef1d5f41" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the task module.</source>
          <target state="translated">接收任务名称并检索任务模块。</target>
        </trans-unit>
        <trans-unit id="b879ac32fa8c2699d4481ef4abf60cb310c50593" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the task module if found.</source>
          <target state="translated">接收任务名称,如果找到,则返回任务模块。</target>
        </trans-unit>
        <trans-unit id="98d45f98af3936ac871d1b420e669aa3ba75d6f8" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it once.</source>
          <target state="translated">接收一个AST节点并将其展开一次。</target>
        </trans-unit>
        <trans-unit id="ed69a15b3b64f165dbfcf50544a8d1db805c1151" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it until it can no longer be expanded.</source>
          <target state="translated">接收一个AST节点,并扩展它,直到它不能再被扩展。</target>
        </trans-unit>
        <trans-unit id="157d1b07d7f33e05788480f92dab05c717cb2225" translate="yes" xml:space="preserve">
          <source>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">接收匿名函数和arity,并按照stacktraces中的格式化。arity也可以是一个参数列表。</target>
        </trans-unit>
        <trans-unit id="828e3869ea6e3d553f5eaefa42fd41690b88d620" translate="yes" xml:space="preserve">
          <source>Receives any argument (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if the argument is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">接收任何参数（不仅是布尔值），如果参数为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43850c741265049e669da2f26b793fdc8099376d" translate="yes" xml:space="preserve">
          <source>Receives two log levels and compares the &lt;code&gt;left&lt;/code&gt; level against the &lt;code&gt;right&lt;/code&gt; level and returns:</source>
          <target state="translated">接收两个日志级别，并将 &lt;code&gt;left&lt;/code&gt; 级别与 &lt;code&gt;right&lt;/code&gt; 级别进行比较并返回：</target>
        </trans-unit>
        <trans-unit id="95c9f8acfe3b80419501346e27b07cd7c2e9cb26" translate="yes" xml:space="preserve">
          <source>Receiving &quot;regular&quot; messages</source>
          <target state="translated">接收 &quot;常规 &quot;信息</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="874c8febf7705c239b56db21c6da13bb314c78a3" translate="yes" xml:space="preserve">
          <source>Recompiles and reloads the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">重新编译并重新加载给定的 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4fd4d9956d6c550135e0c055d986e451b87cd45" translate="yes" xml:space="preserve">
          <source>Recompiles the current Mix application.</source>
          <target state="translated">重新编译当前的Mix应用程序。</target>
        </trans-unit>
        <trans-unit id="2cbd52477e5a038bbc04e1ed928ac44c43841076" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;regex.compileerror&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">重新编译现有的正则表达式，并在出现错误的情况下引发&lt;a href=&quot;regex.compileerror&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9512d561ed1cc337da6646bba4a0fe0f82cc1019" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression if necessary.</source>
          <target state="translated">必要时重新编译现有的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="f92fd6b1074e6e79dfba76d8cd7647ef66632e5a" translate="yes" xml:space="preserve">
          <source>Records are simply tuples where the first element is an atom:</source>
          <target state="translated">记录是简单的元组,其中第一个元素是一个原子。</target>
        </trans-unit>
        <trans-unit id="8f1975a7def41720ec9c94792bc4fc65a7c012e4" translate="yes" xml:space="preserve">
          <source>Recursion</source>
          <target state="translated">Recursion</target>
        </trans-unit>
        <trans-unit id="1e9eb42c791ec696e90bc24ffe375c923de0f651" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call&lt;/a&gt; optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</source>
          <target state="translated">递归和&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;尾调用&lt;/a&gt;优化是Elixir的重要组成部分，通常用于创建循环。但是，在Elixir中进行编程时，您将很少使用上述递归来操纵列表。</target>
        </trans-unit>
        <trans-unit id="90e048b53959a81bc3861b57069e375346d404f4" translate="yes" xml:space="preserve">
          <source>Recursively escapes a value so it can be inserted into a syntax tree.</source>
          <target state="translated">递归地转义一个值,使其可以插入到语法树中。</target>
        </trans-unit>
        <trans-unit id="9aa5f460115ac32f0d34ca300a72820b95cfe5a4" translate="yes" xml:space="preserve">
          <source>Redefining existing operators</source>
          <target state="translated">重新定义现有运营商</target>
        </trans-unit>
        <trans-unit id="5ec592dbd43af61e2cbf6d03b3e9ee6ca088c0f2" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">减少（有时称为 &lt;code&gt;fold&lt;/code&gt; ）是函数编程中的基本构建块。&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的几乎所有功能都可以在reduce之上实现。这些功能通常依赖于其他操作，例如&lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt;，这些操作由运行时进行了优化。</target>
        </trans-unit>
        <trans-unit id="95a8f2e0d9b4cee6851a4ae983d29171ececc54e" translate="yes" xml:space="preserve">
          <source>Reduce and map algorithms</source>
          <target state="translated">减少和映射算法</target>
        </trans-unit>
        <trans-unit id="32ab9de27d58bcc7d4d54b8d17c7484a6d29e607" translate="yes" xml:space="preserve">
          <source>Reduce as a building block</source>
          <target state="translated">减少作为一个组成部分</target>
        </trans-unit>
        <trans-unit id="6b8baf4751a0c397c470aa1b489e04d78981d396" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;enumerable&lt;/code&gt; until &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, term}&lt;/code&gt;.</source>
          <target state="translated">减少 &lt;code&gt;enumerable&lt;/code&gt; 直到 &lt;code&gt;fun&lt;/code&gt; 返回 &lt;code&gt;{:halt, term}&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="f3fe1324757a1c4900c6719d6fc7cfb276e4826c" translate="yes" xml:space="preserve">
          <source>Reduces the &lt;code&gt;enumerable&lt;/code&gt; into an element.</source>
          <target state="translated">将 &lt;code&gt;enumerable&lt;/code&gt; 为一个元素。</target>
        </trans-unit>
        <trans-unit id="2dbe68b1eeba6b24ea1fba9cc612db280c6c2f67" translate="yes" xml:space="preserve">
          <source>Reenables a given task so it can be executed again down the stack.</source>
          <target state="translated">重新启用一个给定的任务,这样它就可以在堆栈中再次执行。</target>
        </trans-unit>
        <trans-unit id="3b03cbaefa850378932be35a87004bee63b000cd" translate="yes" xml:space="preserve">
          <source>Reference - a unique value in the runtime system, created with &lt;a href=&quot;#make_ref/0&quot;&gt;&lt;code&gt;make_ref/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">引用-运行时系统中的唯一值，使用&lt;a href=&quot;#make_ref/0&quot;&gt; &lt;code&gt;make_ref/0&lt;/code&gt; &lt;/a&gt;创建</target>
        </trans-unit>
        <trans-unit id="51ad2be02b9697cd310cca4ee9b8b7aa0b47c088" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@callback&lt;/code&gt; by prepending &lt;code&gt;c:&lt;/code&gt;, as in &lt;code&gt;`c:world/1`&lt;/code&gt;.</source>
          <target state="translated">引用 &lt;code&gt;@callback&lt;/code&gt; 通过预先计算 &lt;code&gt;c:&lt;/code&gt; ，如在 &lt;code&gt;`c:world/1`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbfb2cc2895149d87c5f4f6bbe82a4d53911ad9" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@type&lt;/code&gt; by prepending &lt;code&gt;t:&lt;/code&gt;, as in &lt;code&gt;`t:values/0`&lt;/code&gt;.</source>
          <target state="translated">通过在 &lt;code&gt;t:&lt;/code&gt; 前面引用 &lt;code&gt;@type&lt;/code&gt; ，如 &lt;code&gt;`t:values/0`&lt;/code&gt; 中所示。</target>
        </trans-unit>
        <trans-unit id="59cb3fcffb3799341188ccd1da595b261b4be7ab" translate="yes" xml:space="preserve">
          <source>Reference and functions for working with protocols.</source>
          <target state="translated">协议工作的参考和功能。</target>
        </trans-unit>
        <trans-unit id="98efd6e2a6b118bb5b50c8bbc16e0f5cd3315ce0" translate="yes" xml:space="preserve">
          <source>Reference functions by name and arity if they are local, as in &lt;code&gt;`world/1`&lt;/code&gt;, or by module, name and arity if pointing to an external module: &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt;.</source>
          <target state="translated">如果引用是本地名称（如在 &lt;code&gt;`world/1`&lt;/code&gt; ， &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt; 名称和Arity起作用；如果指向外部模块：MyApp.Hello.world/1，则按模块，名称和Arity起作用。</target>
        </trans-unit>
        <trans-unit id="26fa88e9bd1e552c7f736c12a86e4b0eb3d12567" translate="yes" xml:space="preserve">
          <source>Reference modules by their full name.</source>
          <target state="translated">按全名引用模块。</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="105376683ec11cee0e5b5973530213234a5fd201" translate="yes" xml:space="preserve">
          <source>Refute received with an explicit timeout:</source>
          <target state="translated">驳斥收到的明确超时。</target>
        </trans-unit>
        <trans-unit id="8fd8f41db359717b5f94a5befb85555200773286" translate="yes" xml:space="preserve">
          <source>Regardless of whether &lt;code&gt;=&amp;gt;&lt;/code&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:</source>
          <target state="translated">无论是否使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 或关键字语法，为简单起见，映射中的键值对始终在内部表示为两个元素的元组列表：</target>
        </trans-unit>
        <trans-unit id="6e681935761236016678d2656c1d667f0fe6fdac" translate="yes" xml:space="preserve">
          <source>Regex</source>
          <target state="translated">Regex</target>
        </trans-unit>
        <trans-unit id="ea0563594d23ed77538002a13830e067953e4a2b" translate="yes" xml:space="preserve">
          <source>Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's &lt;code&gt;:re&lt;/code&gt; module. More information can be found in the &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt;&lt;code&gt;:re&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">Regex基于PCRE（与Perl兼容的正则表达式），并基于Erlang的 &lt;code&gt;:re&lt;/code&gt; 模块构建。更多信息可以在&lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt; &lt;code&gt;:re&lt;/code&gt; 模块文档中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e7ac6184c6bddf346a5bb04f8cb4bb31ff3c577" translate="yes" xml:space="preserve">
          <source>Regex supports several built in named character classes. These are used by enclosing the class name in &lt;code&gt;[: :]&lt;/code&gt; inside a group. For example:</source>
          <target state="translated">正则表达式支持几种内置的命名字符类。通过将类名称包含在组内的 &lt;code&gt;[: :]&lt;/code&gt; 来使用这些名称。例如：</target>
        </trans-unit>
        <trans-unit id="8f4773b8001d2a236f1f42a57de7334762ef6a6f" translate="yes" xml:space="preserve">
          <source>Regex.CompileError</source>
          <target state="translated">Regex.CompileError</target>
        </trans-unit>
        <trans-unit id="2b2c167065a8849bc602af6807d29b6301a6af4e" translate="yes" xml:space="preserve">
          <source>Regex.CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Regex.CompileError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="921e80bd802450f0a54f55dc59c8a5c73048f3e4" translate="yes" xml:space="preserve">
          <source>Registering under a unique registry does not allow multiple entries:</source>
          <target state="translated">在一个独特的注册表下注册,不允许有多个条目。</target>
        </trans-unit>
        <trans-unit id="8b68501359664aa7e3f357030fc262fc752fa96a" translate="yes" xml:space="preserve">
          <source>Registers a &lt;code&gt;pluralization&lt;/code&gt; for &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;word&lt;/code&gt; 注册一个 &lt;code&gt;pluralization&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfbc6d24a7a7f0d56fb406aa6036b3e12ffb8353" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of program execution. Useful for invoking a hook in &quot;script&quot; mode.</source>
          <target state="translated">注册一个将在程序执行结束时被调用的函数。用于在 &quot;脚本 &quot;模式下调用钩子。</target>
        </trans-unit>
        <trans-unit id="2177c0410d7f5895415b852d1e80afeff722f655" translate="yes" xml:space="preserve">
          <source>Registers a function to be invoked after the IEx process is spawned.</source>
          <target state="translated">注册一个在IEx进程被生成后被调用的函数。</target>
        </trans-unit>
        <trans-unit id="b7cdc0be7757e71f965b3c7ad3fb440f76e506dd" translate="yes" xml:space="preserve">
          <source>Registers a function to run as part of this case.</source>
          <target state="translated">注册一个函数作为本例的一部分来运行。</target>
        </trans-unit>
        <trans-unit id="b973e327e3c021c877cc4d29399fa35fa83e3213" translate="yes" xml:space="preserve">
          <source>Registers a new attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">注册要在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;测试期间使用的新属性。</target>
        </trans-unit>
        <trans-unit id="0e8cf2b4cc8729f25da603ab355783aa05318c46" translate="yes" xml:space="preserve">
          <source>Registers a program exit handler function.</source>
          <target state="translated">注册一个程序退出处理功能。</target>
        </trans-unit>
        <trans-unit id="86f9550834cf29f2c28787220b59431f4c42e38c" translate="yes" xml:space="preserve">
          <source>Registers an attribute.</source>
          <target state="translated">注册一个属性。</target>
        </trans-unit>
        <trans-unit id="949e454436ebf7fa4a322e7a723b37231ac63ba1" translate="yes" xml:space="preserve">
          <source>Registers the current process under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;registry&lt;/code&gt; 的给定 &lt;code&gt;key&lt;/code&gt; 下注册当前进程。</target>
        </trans-unit>
        <trans-unit id="f5cea0af6cc948234d2b641ef218832cc68cbc8f" translate="yes" xml:space="preserve">
          <source>Registers the default &lt;code&gt;port&lt;/code&gt; for the given &lt;code&gt;scheme&lt;/code&gt;.</source>
          <target state="translated">为给定 &lt;code&gt;scheme&lt;/code&gt; 注册默认 &lt;code&gt;port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f29bbe119d2296da4e21436992a76df3eb6cb3e" translate="yes" xml:space="preserve">
          <source>Registers the given &lt;code&gt;pid_or_port&lt;/code&gt; under the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">以给定 &lt;code&gt;name&lt;/code&gt; 注册给定的 &lt;code&gt;pid_or_port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dddbe6429e016c47c4e1888ab89c26f58346135b" translate="yes" xml:space="preserve">
          <source>Registrations</source>
          <target state="translated">Registrations</target>
        </trans-unit>
        <trans-unit id="435305e548b36c7d783e828784397c394c2d994b" translate="yes" xml:space="preserve">
          <source>Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function.</source>
          <target state="translated">与上一节类似，也可以通过使用&lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt;函数来使用注册表来实现本地的，非分布式的，可伸缩的PubSub ，与上一节类似：但是，在这种情况下，我们将向每个关联的进程发送消息，而不是调用给定的模块功能。</target>
        </trans-unit>
        <trans-unit id="1fd6a805dae745c87a8b89f1be1a738e608a1668" translate="yes" xml:space="preserve">
          <source>Registry</source>
          <target state="translated">Registry</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">正则表达式</target>
        </trans-unit>
        <trans-unit id="dbb5498e44eab5d71617ba625dacbfc1473d84fe" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, OS and architecture as as the target.</source>
          <target state="translated">使用sigil构建的正则表达式将被预编译并存储在 &lt;code&gt;.beam&lt;/code&gt; 文件中。预编译的正则表达式将在运行时进行检查，并且在操作系统和OTP版本之间的运行可能会变慢。这很少有问题，因为在开发过程中共享的大多数Elixir代码都是在目标上编译的（例如依赖项，档案和脚本），并且在生产环境中运行时，代码必须在目标上&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;（通过混合编译或类似方法） ）或以匹配的OTP，操作系统和体系结构为目标在主机上 &lt;code&gt;mix releases&lt;/code&gt; （通过混合版本或类似版本）。</target>
        </trans-unit>
        <trans-unit id="75480c7e2a8cd4b557d0d4e69e47d2fba660d6e0" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Notice this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">通过sigils创建的正则表达式将被预编译并存储在 &lt;code&gt;.beam&lt;/code&gt; 文件中。请注意，如果您正在预编译Elixir，则这可能是一个问题，有关更多信息，请参见&amp;ldquo;预编译&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="662de58b3e1c7961e52834df747a357eb8207007" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">在药剂的正则表达式可以用印记被创建 &lt;code&gt;~r&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt;）或 &lt;code&gt;~R&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="8fa41d59c259d95cfaded10953d5a2f8e0b38bb4" translate="yes" xml:space="preserve">
          <source>Releases</source>
          <target state="translated">Releases</target>
        </trans-unit>
        <trans-unit id="da14bf586c00c0b2d6a162b461c2222bd3a8fda0" translate="yes" xml:space="preserve">
          <source>Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are:</source>
          <target state="translated">发布允许开发者将所有的代码和运行时预编译和打包成一个单元。发行版的好处是:</target>
        </trans-unit>
        <trans-unit id="c6e22d2a45a39c91d823d515c586ebf0bbb7339d" translate="yes" xml:space="preserve">
          <source>Releases also provide built-in hooks for configuring almost every need of the production system:</source>
          <target state="translated">版本还提供了内置的钩子,用于配置生产系统的几乎所有需求。</target>
        </trans-unit>
        <trans-unit id="c9ca4a52a1dd10eb55da61c20c8394066a84c979" translate="yes" xml:space="preserve">
          <source>Relevant Type(s)</source>
          <target state="translated">相关类型</target>
        </trans-unit>
        <trans-unit id="a5e5c7fbabf94e041bedf3cf78e00e95d579c10d" translate="yes" xml:space="preserve">
          <source>Remember Elixir makes a distinction between anonymous functions and named functions, where the former must be invoked with a dot (&lt;code&gt;.&lt;/code&gt;) between the variable name and parentheses. The capture operator bridges this gap by allowing named functions to be assigned to variables and passed as arguments in the same way we assign, invoke and pass anonymous functions.</source>
          <target state="translated">请记住，Elixir区分匿名函数和命名函数，其中前者必须在变量名和括号之间用点号（ &lt;code&gt;.&lt;/code&gt; ）调用。捕获运算符通过允许将命名函数分配给变量并以与我们分配，调用和传递匿名函数相同的方式作为参数传递来弥合这种差距。</target>
        </trans-unit>
        <trans-unit id="943e7d08a29ef9d83c317d0436320ee8105342c6" translate="yes" xml:space="preserve">
          <source>Remember however that our &lt;code&gt;KV.Registry&lt;/code&gt; is both linking (via &lt;code&gt;start_link&lt;/code&gt;) and monitoring (via &lt;code&gt;monitor&lt;/code&gt;) bucket processes in the &lt;code&gt;handle_cast/2&lt;/code&gt; callback:</source>
          <target state="translated">但是请记住，我们的 &lt;code&gt;KV.Registry&lt;/code&gt; 在 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调中既链接（通过 &lt;code&gt;start_link&lt;/code&gt; ）又监视（通过 &lt;code&gt;monitor&lt;/code&gt; ）存储桶过程：</target>
        </trans-unit>
        <trans-unit id="2339016231a3f611f706a0ff8268e0aeed0a9afe" translate="yes" xml:space="preserve">
          <source>Remember lists are literals, so they are represented as themselves in the AST:</source>
          <target state="translated">请记住列表是字面,所以它们在AST中表示为自己。</target>
        </trans-unit>
        <trans-unit id="a9201bbeed5d03751538444a9bdfa2b7a2f29888" translate="yes" xml:space="preserve">
          <source>Remember that the name of a process can be any atom. So far, we have named processes with the same name as the modules that define their implementation. For example, the process defined by &lt;code&gt;KV.Registry&lt;/code&gt; was given a process name of &lt;code&gt;KV.Registry&lt;/code&gt;. This is simply a convention: If later there is an error in your system that says, &amp;ldquo;process named KV.Registry crashed with reason&amp;rdquo;, we know exactly where to investigate.</source>
          <target state="translated">请记住，进程的名称可以是任何原子。到目前为止，我们已经使用与定义其实现的模块相同的名称来命名进程。例如，由 &lt;code&gt;KV.Registry&lt;/code&gt; 定义的进程的名称为 &lt;code&gt;KV.Registry&lt;/code&gt; 。这只是一个惯例：如果以后您的系统中出现错误，指出&amp;ldquo;名为KV.Registry的进程因原因而崩溃&amp;rdquo;，我们将确切知道要在哪里进行调查。</target>
        </trans-unit>
        <trans-unit id="a23460e1d638c5436d4d647608a0c43461b2bb03" translate="yes" xml:space="preserve">
          <source>Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals).</source>
          <target state="translated">请记住,因为列表和双元素元组是引文,所以根据定义,关键字也是字元(事实上,具有两个元素的元组是引文的唯一原因是支持关键字作为字元)。</target>
        </trans-unit>
        <trans-unit id="547521c843600e88d013eb66991d1b7a08d0987f" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">请记住，此函数适用于Unicode字素，并认为这些切片代表字素偏移。如果要拆分原始字节，请&lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="698cb20e961ee6d1a5f74b94b2a7a5aa2f31ae4b" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">请记住，在Elixir中使用&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt;和友人进行的比较是结构化的，并且基于DateTime结构域。为了正确地比较日期时间，请使用&lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="27bb052d1b6cca59f0d8b8e080407897e513da28" translate="yes" xml:space="preserve">
          <source>Remote shells</source>
          <target state="translated">遥控炮弹</target>
        </trans-unit>
        <trans-unit id="12e6e0a5538b479310c7704c6dff0686bcae2732" translate="yes" xml:space="preserve">
          <source>Remote types</source>
          <target state="translated">远程类型</target>
        </trans-unit>
        <trans-unit id="ad7183d89f1b9dc5b75d0fb7a74934c2fe82e722" translate="yes" xml:space="preserve">
          <source>Removes a backend.</source>
          <target state="translated">删除一个后台。</target>
        </trans-unit>
        <trans-unit id="6b3c529ef7158c6c64f36c40c48665d4b841a4dc" translate="yes" xml:space="preserve">
          <source>Removes a translator.</source>
          <target state="translated">移除一个翻译器。</target>
        </trans-unit>
        <trans-unit id="0e523878ea75291793b504604435509973416467" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;module&lt;/code&gt; 删除所有断点和检测。</target>
        </trans-unit>
        <trans-unit id="6f725a049c858ae90de002f7c340c653cf53f9e1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from all modules.</source>
          <target state="translated">移除所有模块的所有断点和仪器。</target>
        </trans-unit>
        <trans-unit id="5cde5498611d5dd73ab4c8f8109c899ca9bbce1f" translate="yes" xml:space="preserve">
          <source>Removes an element from a tuple.</source>
          <target state="translated">从元组中删除一个元素。</target>
        </trans-unit>
        <trans-unit id="e12499048521db44dd18f757b10e57bb80774e3b" translate="yes" xml:space="preserve">
          <source>Removes files and directories recursively at the given &lt;code&gt;path&lt;/code&gt;. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</source>
          <target state="translated">以给定 &lt;code&gt;path&lt;/code&gt; 递归删除文件和目录。符号链接不会被遵循，而是会被删除，不存在的文件将被忽略（即不会使此功能失败）。</target>
        </trans-unit>
        <trans-unit id="7baee7a478497d4737825218f8e15ac03e8c6030" translate="yes" xml:space="preserve">
          <source>Removes files from the required files list.</source>
          <target state="translated">从所需文件列表中删除文件。</target>
        </trans-unit>
        <trans-unit id="e097ba46638772c9b64fea773b1e61d5573174b4" translate="yes" xml:space="preserve">
          <source>Removes the entry with a given key from a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">从容器（实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）中删除具有给定键的条目。</target>
        </trans-unit>
        <trans-unit id="2ab0917eb6c0ad48d41081c9212ed112569e33de" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">移除左边列表中每个元素在右边列表中的第一次出现。</target>
        </trans-unit>
        <trans-unit id="2610a285dc9b1c68c5713f9aeb89d588d07b8d11" translate="yes" xml:space="preserve">
          <source>Removes the link between the calling process and the given item (process or port).</source>
          <target state="translated">删除调用过程和给定项目(过程或端口)之间的链接。</target>
        </trans-unit>
        <trans-unit id="f877e19fb1fb1b9f68495b6349dc80d7ef2d3e8e" translate="yes" xml:space="preserve">
          <source>Removes the registered &lt;code&gt;name&lt;/code&gt;, associated with a PID or a port identifier.</source>
          <target state="translated">删除与PID或端口标识符关联的注册 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e182592a215c0c2641cada9adb28ed54322e302f" translate="yes" xml:space="preserve">
          <source>Removes the variable &lt;code&gt;varname&lt;/code&gt; from the environment.</source>
          <target state="translated">从环境中删除变量 &lt;code&gt;varname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1b55c9888c715281f3275cbe5053ffaabe0430" translate="yes" xml:space="preserve">
          <source>Renames the &lt;code&gt;source&lt;/code&gt; file to &lt;code&gt;destination&lt;/code&gt; file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the &lt;code&gt;destination&lt;/code&gt; filename, it is not sufficient to simply specify its directory.</source>
          <target state="translated">将 &lt;code&gt;source&lt;/code&gt; 文件重命名为 &lt;code&gt;destination&lt;/code&gt; 文件。它可用于在目录之间移动文件（和目录）。如果要移动文件，则必须完全指定 &lt;code&gt;destination&lt;/code&gt; 文件名，仅指定其目录是不够的。</target>
        </trans-unit>
        <trans-unit id="a91f5880024e32c1ee837d1bf3b64cc8dc6671b0" translate="yes" xml:space="preserve">
          <source>Replaced by (available since)</source>
          <target state="translated">由(此后有)取代</target>
        </trans-unit>
        <trans-unit id="3ae5fd3a5401d1295a4c3679a829706f16163c68" translate="yes" xml:space="preserve">
          <source>Replaces all leading occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; of &lt;code&gt;match&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">替换的所有领先的出现 &lt;code&gt;match&lt;/code&gt; 的 &lt;code&gt;replacement&lt;/code&gt; 的 &lt;code&gt;match&lt;/code&gt; 中 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58f3e85bfde4f7a00e1a21674d997cd1b50094da" translate="yes" xml:space="preserve">
          <source>Replaces all trailing occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;string&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 的 &lt;code&gt;replacement&lt;/code&gt; 匹配的所有结尾匹配项。</target>
        </trans-unit>
        <trans-unit id="82d8aa6c1dd74b7f190708bea27805665c8cdf0e" translate="yes" xml:space="preserve">
          <source>Replaces prefix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">如果匹配 &lt;code&gt;match&lt;/code&gt; ,则通过 &lt;code&gt;replacement&lt;/code&gt; 替换 &lt;code&gt;string&lt;/code&gt; 的前缀。</target>
        </trans-unit>
        <trans-unit id="c08818204c69c938d93f26169b6a54dc9d5f052e" translate="yes" xml:space="preserve">
          <source>Replaces suffix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">如果匹配 &lt;code&gt;match&lt;/code&gt; ,则用 &lt;code&gt;replacement&lt;/code&gt; &lt;code&gt;string&lt;/code&gt; 替换字符串中的后缀。</target>
        </trans-unit>
        <trans-unit id="61b72516eacbd25292524ef703f00e3b0cd63290" translate="yes" xml:space="preserve">
          <source>Replies to a client.</source>
          <target state="translated">回复客户。</target>
        </trans-unit>
        <trans-unit id="167f6ac2dbfd0e8be970571e54087bdd8130f746" translate="yes" xml:space="preserve">
          <source>Represents expressions in the AST</source>
          <target state="translated">代表AST中的表达式</target>
        </trans-unit>
        <trans-unit id="9c6f57c3a5b6011834691a65157b80974d8047ca" translate="yes" xml:space="preserve">
          <source>Represents literals in the AST</source>
          <target state="translated">代表AST中的字数</target>
        </trans-unit>
        <trans-unit id="e9c366b4f3c3a1bf3449c6872aaeae5a0c5ecdf4" translate="yes" xml:space="preserve">
          <source>Requirement</source>
          <target state="translated">Requirement</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="412cfb34df55659000dc3fda9977411aa50f05bf" translate="yes" xml:space="preserve">
          <source>Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; that work as one would expect, and additionally the special operator &lt;code&gt;~&amp;gt;&lt;/code&gt; described in detail further below.</source>
          <target state="translated">需求允许您指定要使用的给定依赖项的哪个版本。需求支持常见的比较运算符，例如 &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ，它们可以像人们期望的那样工作，另外还需要在下面进一步详细描述的特殊运算符 &lt;code&gt;~&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffbcbcafa9cd3ab8fe7f3e0221d371de707c59bf" translate="yes" xml:space="preserve">
          <source>Requirements also support &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; for complex conditions:</source>
          <target state="translated">需求还支持 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 复杂条件：</target>
        </trans-unit>
        <trans-unit id="0a37ffbe744b3419c856886db8581bb258bdd52c" translate="yes" xml:space="preserve">
          <source>Requires a module in order to use its macros.</source>
          <target state="translated">需要一个模块才能使用其宏。</target>
        </trans-unit>
        <trans-unit id="bdc77107aca48a34c1255f765ae312ea22e9d590" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">由于短路，仅需要 &lt;code&gt;left&lt;/code&gt; 操作数为布尔值。如果 &lt;code&gt;left&lt;/code&gt; 操作数不是布尔值，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="3c1457fddb0ccb7c73dde9fb1360f8c49c8b2b74" translate="yes" xml:space="preserve">
          <source>Requires the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">需要给定的 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cda5e602ba0cf728e06b8efb2ddbc8599b5d662" translate="yes" xml:space="preserve">
          <source>Requires the given files in parallel.</source>
          <target state="translated">需要平行给定的文件。</target>
        </trans-unit>
        <trans-unit id="652877b192a4527170621aec011fcd58f4d804ea" translate="yes" xml:space="preserve">
          <source>Reruns &lt;code&gt;task&lt;/code&gt; with the given arguments.</source>
          <target state="translated">使用给定的参数重新运行 &lt;code&gt;task&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3303b4d51ecd1f3dd58871e5e01ec85056396381" translate="yes" xml:space="preserve">
          <source>Reserved module names</source>
          <target state="translated">保留模块名称</target>
        </trans-unit>
        <trans-unit id="98d53aa320bfa9f3ee95a18c9df1aa09adb7fddb" translate="yes" xml:space="preserve">
          <source>Reserved words</source>
          <target state="translated">保留字</target>
        </trans-unit>
        <trans-unit id="97f4d7e17f03d2ddae5b33b0691e0061a8d5b3a6" translate="yes" xml:space="preserve">
          <source>Resets all attributes.</source>
          <target state="translated">重置所有属性。</target>
        </trans-unit>
        <trans-unit id="20e3b7449f8050f7eb4cdaf37779f0265636b2bb" translate="yes" xml:space="preserve">
          <source>Resets the current process metadata to the given keyword list.</source>
          <target state="translated">将当前进程元数据重置为给定的关键字列表。</target>
        </trans-unit>
        <trans-unit id="49fdd1a2b23b0085e72c09b062efd4ecb9a18ed2" translate="yes" xml:space="preserve">
          <source>Resolves a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt; to an actual path.</source>
          <target state="translated">将&lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt;解析为实际路径。</target>
        </trans-unit>
        <trans-unit id="838ebc4a5cadbe62e4f28a82bbc20144b2308c44" translate="yes" xml:space="preserve">
          <source>Respawns the current shell by starting a new shell process.</source>
          <target state="translated">通过启动新的shell进程重启当前shell。</target>
        </trans-unit>
        <trans-unit id="d924949f461a2178615fa560be4fcb1a11adc482" translate="yes" xml:space="preserve">
          <source>Restart values (:restart)</source>
          <target state="translated">重启值 (:restart)</target>
        </trans-unit>
        <trans-unit id="6c1b23092774f1732bb40fd9217d2008cf95142c" translate="yes" xml:space="preserve">
          <source>Restarts a child process identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">重新启动 &lt;code&gt;child_id&lt;/code&gt; 标识的子进程。</target>
        </trans-unit>
        <trans-unit id="cdda01d4f5a4d17bef26c81b5fb2b202c9529bae" translate="yes" xml:space="preserve">
          <source>Restarts all applications in the Erlang runtime system.</source>
          <target state="translated">重新启动Erlang运行时系统中的所有应用程序。</target>
        </trans-unit>
        <trans-unit id="e9ef6fa952a1df9e86072dc44600b6f94a8e9045" translate="yes" xml:space="preserve">
          <source>Retrieves the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">检索&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;级别。</target>
        </trans-unit>
        <trans-unit id="9561c4c2ab77e3b4a8a77091d61310e40fe75523" translate="yes" xml:space="preserve">
          <source>Retrieves the current project if there is one.</source>
          <target state="translated">检索当前项目(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="8108bc75c4a7082e6ac6f1000b099b62cbb5c8b6" translate="yes" xml:space="preserve">
          <source>Retrieves the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">检索 &lt;code&gt;enumerable&lt;/code&gt; 中元素的数量。</target>
        </trans-unit>
        <trans-unit id="bd62dedad93356267e6352b4bd2959e6c3d4a64b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6)</source>
          <target state="translated">返回 &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; 或 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; （v1.6）</target>
        </trans-unit>
        <trans-unit id="9d42e2f739c476b4724ed40443cd1bdc8b0b0c31" translate="yes" xml:space="preserve">
          <source>Return values</source>
          <target state="translated">返回值</target>
        </trans-unit>
        <trans-unit id="1b92b78b25ceec1de641e02266e51c2ee955125b" translate="yes" xml:space="preserve">
          <source>Return values are the same as &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回值与&lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="6510848f34f0555d205bfb994f51d205f3d74823" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 函数的返回值</target>
        </trans-unit>
        <trans-unit id="9450659c5d952be2b0fe455eb08ad207bd303023" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_child&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_child&lt;/code&gt; 函数的返回值</target>
        </trans-unit>
        <trans-unit id="3e9dd619fd23cd606de770ea4c2cbd74b2aa99e4" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_link&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 函数的返回值</target>
        </trans-unit>
        <trans-unit id="71ad9db2f452d030849e70969695a7639a712f39" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">返回 &lt;code&gt;:ignore&lt;/code&gt; 将导致&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;:ignore&lt;/code&gt; ,并且该过程将正常退出，而无需进入循环或调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。如果在监视树的一部分中使用父监视程序，则父监视程序将不会启动也不会立即尝试重新启动&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。监视树的其余部分将启动，因此其他进程不应使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。以后可以使用&lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt;来启动它，因为子规范保存在父主管中。主要用途是：</target>
        </trans-unit>
        <trans-unit id="eb2f30a4d8bc7038c64e5d45423d1462692bb22a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ok&lt;/code&gt; leaves the context unchanged (in &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks).</source>
          <target state="translated">返回 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;setup_all&lt;/code&gt; 上下文保持不变（在 &lt;code&gt;setup&lt;/code&gt; 和setup_all回调中）。</target>
        </trans-unit>
        <trans-unit id="d4f04b1fc86d756470bf59ce20599e81fba3d31e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:error, reason}&lt;/code&gt; fails the code change with reason &lt;code&gt;reason&lt;/code&gt; and the state remains as the previous state.</source>
          <target state="translated">返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 导致代码更改失败，原因为 &lt;code&gt;reason&lt;/code&gt; ,并且该状态保持为先前的状态。</target>
        </trans-unit>
        <trans-unit id="0592eb111cc826c0b5dc41fef3d96850ddf2ed2a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except the process is hibernated before continuing the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; 与 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 相似，除了在继续循环之前使进程处于休眠状态。有关更多信息，请参见&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="545abab29816f45f903fc69a76d6d258e74019ea" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except a timeout, hibernation or continue occurs as with a &lt;code&gt;:reply&lt;/code&gt; tuple.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; 与 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 相似，除了超时，休眠或继续（如 &lt;code&gt;:reply&lt;/code&gt; 元组）外。</target>
        </trans-unit>
        <trans-unit id="0d632613338eb1516d1e171379de56d181565aa7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; 与 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 类似，除了它还设置了超时。有关更多信息，请参见模块文档中的&amp;ldquo;超时&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b0dc3e574638c9f3a3a2cb97268326892e9c0517" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; 与 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 相似，不同的是&lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt;将在值 &lt;code&gt;continue&lt;/code&gt; 作为第一个参数后立即被调用。</target>
        </trans-unit>
        <trans-unit id="7c2e4427bf9da87b7975511fa77c0aa083a93e56" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 以新状态 &lt;code&gt;new_state&lt;/code&gt; 继续循环。</target>
        </trans-unit>
        <trans-unit id="e0bcdf8d79ea91a9b75d45685f07008e6bb07b7a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; does not send a response to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;. The response must be sent with &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 不会将响应发送给调用方，而是以新状态 &lt;code&gt;new_state&lt;/code&gt; 继续循环。响应必须以&lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt;发送。</target>
        </trans-unit>
        <trans-unit id="4de3a02b60233fe036c0a08aa97987f8e91d073a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt;&lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;&lt;/a&gt;'s callback</source>
          <target state="translated">从&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt; &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt; &lt;/a&gt;的回调返回 &lt;code&gt;{:ok, contents}&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ce39defe2e667a1d9303cd7807fa9deb1f3dff7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, new_state}&lt;/code&gt; changes the state to &lt;code&gt;new_state&lt;/code&gt; and the code change is successful.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, new_state}&lt;/code&gt; 会将状态更改为 &lt;code&gt;new_state&lt;/code&gt; ，并且代码更改成功。</target>
        </trans-unit>
        <trans-unit id="dda86c57299291383ba12cacce3b8a61cd3aca15" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except the process is hibernated before entering the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information on hibernation.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; 类似于 &lt;code&gt;{:ok, state}&lt;/code&gt; 除了在进入循环之前使进程处于休眠状态。有关休眠的更多信息，请参见&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4f89c1f4a5e07f563900cfccc5421ff9a8161b2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt;, except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; 类似于 &lt;code&gt;{:ok, state}&lt;/code&gt; ，除了它还会设置超时。有关更多信息，请参见模块文档中的&amp;ldquo;超时&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="367f39392e443be5033fcc0ce46cb9c7191866d5" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; callback will be invoked with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; 与 &lt;code&gt;{:ok, state}&lt;/code&gt; 相似，除了在进入循环后立即调用&lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt;回调，并将值 &lt;code&gt;continue&lt;/code&gt; 作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="4e7d4ebacb2fe086ff03c74440ab13b1423c917e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, state}&lt;/code&gt; 将导致&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，并使进程进入其循环。</target>
        </trans-unit>
        <trans-unit id="2ac7990d3774239b03711f323b97327318be9091" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except the process is hibernated and will continue the loop once a message is in its message queue. If a message is already in the message queue this will be immediately. Hibernating a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</source>
          <target state="translated">返回 &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; 与 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 相似，不同之处在于该过程处于休眠状态，一旦消息进入其消息队列，它将继续循环。如果消息队列中已经有消息，则将立即发送。休眠&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;会导致垃圾回收，并留下一个连续的堆，从而使进程使用的内存最小化。</target>
        </trans-unit>
        <trans-unit id="3664827e00957d1361f076b6c6180a5288429b1e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">返回 &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; 与 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 类似，除了它还设置了超时时间。有关更多信息，请参见模块文档中的&amp;ldquo;超时&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="6f9c42293c17275b2da3909a5ac827406da8908f" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">返回 &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; 与 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 相似，不同的是&lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt;将在值 &lt;code&gt;continue&lt;/code&gt; 作为第一个参数后立即被调用。</target>
        </trans-unit>
        <trans-unit id="5d5e6464f7527865bd6d8be289ffe2a3685bee24" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; sends the response &lt;code&gt;reply&lt;/code&gt; to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 将响应 &lt;code&gt;reply&lt;/code&gt; 发送给调用方，并以新状态 &lt;code&gt;new_state&lt;/code&gt; 继续循环。</target>
        </trans-unit>
        <trans-unit id="534c77debf0badc9c25487b18a7948694707f4bb" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; is similar to &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; except a reply is not sent.</source>
          <target state="translated">返回 &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 与 &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 类似，不同之处在于未发送答复。</target>
        </trans-unit>
        <trans-unit id="25233abf67489667f36f12119719f8bf3ab79f10" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with the reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. The process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 停止循环，并使用reason &lt;code&gt;reason&lt;/code&gt; 和状态 &lt;code&gt;new_state&lt;/code&gt; 调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。该过程将退出原因 &lt;code&gt;reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9446727789d28494af33768c5dd1be490cb2c928" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. Then the &lt;code&gt;reply&lt;/code&gt; is sent as the response to call and the process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 停止循环，并以原因 &lt;code&gt;reason&lt;/code&gt; 和state &lt;code&gt;new_state&lt;/code&gt; 调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。然后，将 &lt;code&gt;reply&lt;/code&gt; 作为对呼叫的响应发送，并且过程由于 &lt;code&gt;reason&lt;/code&gt; 退出。</target>
        </trans-unit>
        <trans-unit id="45b0ba5a4f231122f32567afd5046aeac5ca341b" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回 &lt;code&gt;{:stop, reason}&lt;/code&gt; 会导致&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;{:error, reason}&lt;/code&gt; ，并且进程将以原因 &lt;code&gt;reason&lt;/code&gt; 退出而不进入循环或调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="201a82018e6ccab06f099ffcf6ad93f0589f0ac6" translate="yes" xml:space="preserve">
          <source>Returning anything else from &lt;code&gt;setup_all&lt;/code&gt; will force all tests to fail, while a bad response from &lt;code&gt;setup&lt;/code&gt; causes the current test to fail.</source>
          <target state="translated">从 &lt;code&gt;setup_all&lt;/code&gt; 返回任何其他内容将强制所有测试失败，而来自 &lt;code&gt;setup&lt;/code&gt; 的错误响应会导致当前测试失败。</target>
        </trans-unit>
        <trans-unit id="2ccc041e90cdcfa1031811c96f150b22c6b8ca9e" translate="yes" xml:space="preserve">
          <source>Returning to our &lt;code&gt;handle_cast/2&lt;/code&gt; implementation, you can see the registry is both linking and monitoring the buckets:</source>
          <target state="translated">返回到 &lt;code&gt;handle_cast/2&lt;/code&gt; 的实现，您可以看到注册表既链接又监视着存储桶：</target>
        </trans-unit>
        <trans-unit id="a86c48f96d918e08b84d079d9945718a4599bc5f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:error&lt;/code&gt; when an invalid call syntax is provided.</source>
          <target state="translated">提供无效的调用语法时，返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ab2b4bc1a0b6cdb37b00adb4f725958544c088b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first date is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two dates are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">如果第一个日期晚于第二个日期，则返回 &lt;code&gt;:gt&lt;/code&gt; ,反之则返回： &lt;code&gt;:lt&lt;/code&gt; 。如果两个日期相等，则返回 &lt;code&gt;:eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097e4060b0440fe77549d8b66e79f7bb6eb97a62" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two NaiveDateTime are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">如果第一个晚于第二个，则返回 &lt;code&gt;:gt&lt;/code&gt; ,反之则返回： &lt;code&gt;:lt&lt;/code&gt; 。如果两个NaiveDateTime相等，则返回 &lt;code&gt;:eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd2d674dc710366cef94fba09471c28e71a138f9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first time is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two times are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">如果第一次晚于第二次，则返回 &lt;code&gt;:gt&lt;/code&gt; ,反之则返回： &lt;code&gt;:lt&lt;/code&gt; 。如果两次相等，则返回 &lt;code&gt;:eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53c408a9bef219a6da93ad2df4fe55724f2cb32d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first datetime is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two datetimes are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">如果第一个日期时间晚于第二个日期时间，则返回 &lt;code&gt;:gt&lt;/code&gt; ,反之则返回： &lt;code&gt;:lt&lt;/code&gt; 。如果两个日期时间相等，则返回 &lt;code&gt;:eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e433c31c34feefdf2a0b8160341592f2285d40c9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first version is greater than the second one, and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two versions are equal, &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">如果第一个版本大于第二个，则返回 &lt;code&gt;:gt&lt;/code&gt; ,反之则返回： &lt;code&gt;:lt&lt;/code&gt; 。如果两个版本相等，则返回 &lt;code&gt;:eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49f62de8f752ac017916b11e0d5b0e6dfb4ee428" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果是，则返回 &lt;code&gt;:ok&lt;/code&gt; ，否则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c527276d77f46398aba41c7763a178e857f1629" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="84d6f7930e56db40dca6afbc716ff10cc17e68c7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support hard links, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。如果操作系统不支持硬链接，则返回 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9014518965fa93cf5189e6ffe93f29bdec10a9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support symlinks, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 否则返回{：error，reason}。如果操作系统不支持符号链接，则返回 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4bfe0e95851ad3e1857f64f97c1d1fb4f5d47b8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="8084f7f8c4483c73958f54a0f48dadd5344d6c20" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs. It returns &lt;code&gt;{:error, :eexist}&lt;/code&gt; if the directory is not empty.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。如果目录不为空，则返回 &lt;code&gt;{:error, :eexist}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab0c374d46ad2b15399e120024adf6936c21f68c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if there is such breakpoint ID. &lt;code&gt;:not_found&lt;/code&gt; otherwise.</source>
          <target state="translated">如果有这样的断点ID，则返回 &lt;code&gt;:ok&lt;/code&gt; 。 &lt;code&gt;:not_found&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="3e6eac431d9ebe34612817b0b267721c1695b386" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fccad904de868f3ee196d9c9da31a4d3a418edcf" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">如果成功则返回 &lt;code&gt;:ok&lt;/code&gt; ，如果失败则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4edb5e74e876c5531ce730345abbd7fb3d428f67" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; or an &lt;code&gt;{:error, reason}&lt;/code&gt; tuple.</source>
          <target state="translated">返回 &lt;code&gt;:ok&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="2811dc2871409b74c7634f3fe21b9cfad8e3426d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70a0cb56fb988edcefd7f57e57c953aed4c9f29d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:pang&lt;/code&gt; if it fails, or &lt;code&gt;:pong&lt;/code&gt; if it is successful.</source>
          <target state="translated">如果失败则返回 &lt;code&gt;:pang&lt;/code&gt; ,如果成功则返回： &lt;code&gt;:pong&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa4c892f8a51f6377453163a59366a24b8673154" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d21a89523dd182a1ba29c1ffb24f85507a56dc6f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;nil&lt;/code&gt; if none of the above are writable.</source>
          <target state="translated">如果以上都不是可写的，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="898fb5eb3ba6e23f0ccd7d7539ee54b65de26942" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;string&lt;/code&gt; escaped using the specified &lt;code&gt;color&lt;/code&gt;.</source>
          <target state="translated">返回使用指定 &lt;code&gt;color&lt;/code&gt; 转义的 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ac9182b080017ba693939798ee4b3253313dff7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;config&lt;/code&gt; is the configuration for an umbrella project.</source>
          <target state="translated">如果 &lt;code&gt;config&lt;/code&gt; 是伞项目的配置，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9962d949955102edf7d4c95bfcf26efb4913fef8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;enumerable&lt;/code&gt; 为空，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5674c2a52dea0e62c8659c4dd8c99131becc466" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;fun.(element)&lt;/code&gt; is truthy for all elements in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;fun.(element)&lt;/code&gt; 是truthy在所有元素 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f74f38a142de62e72e50fbadcb7c75b8d2b80e17" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;fun.(element)&lt;/code&gt; is truthy for at least one element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;fun.(element)&lt;/code&gt; 是truthy至少一个元素 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="514fe375f6bf375eaadfe6b59fe1fa8665022d7f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; matches &lt;code&gt;right&lt;/code&gt; (if it's a regular expression) or contains &lt;code&gt;right&lt;/code&gt; (if it's a string).</source>
          <target state="translated">如果 &lt;code&gt;left&lt;/code&gt; 匹配 &lt;code&gt;right&lt;/code&gt; （如果它是一个正则表达式）或包含 &lt;code&gt;right&lt;/code&gt; （如果它是一个字符串），则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea241259b8bf2bfa681b13e041e456b2a872afb0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is an improper list. Otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;list&lt;/code&gt; 是不正确的列表，则返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13bb0ccf3c3642db1839be80f4503b7d3328419c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; starts with the given &lt;code&gt;prefix&lt;/code&gt; list; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;list&lt;/code&gt; 以给定的 &lt;code&gt;prefix&lt;/code&gt; 列表开头，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30b6f388eb9b873621632a9225533fab3fd32015" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;module&lt;/code&gt; is loaded and contains a public &lt;code&gt;function&lt;/code&gt; with the given &lt;code&gt;arity&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;module&lt;/code&gt; 已加载并且包含具有给定 &lt;code&gt;arity&lt;/code&gt; 的公共 &lt;code&gt;function&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1ff647bff772fb3c27239fe80409991ad029c38" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;module&lt;/code&gt; is loaded and contains a public &lt;code&gt;macro&lt;/code&gt; with the given &lt;code&gt;arity&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;module&lt;/code&gt; 已加载并且包含具有给定 &lt;code&gt;arity&lt;/code&gt; 的公共 &lt;code&gt;macro&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98b09495aa1c8dc345b23e7149ef0c6a164db4ae" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string1&lt;/code&gt; is canonically equivalent to 'string2'.</source>
          <target state="translated">如果 &lt;code&gt;string1&lt;/code&gt; 规范上等于'string2'，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="315cea72c5e0f6161a3b846c3752c56b24a3948c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string&lt;/code&gt; ends with any of the suffixes given.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 以给定的任何后缀结尾，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5875290ab59e60512fe2c79091c539fa829d55d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string&lt;/code&gt; starts with any of the prefixes given.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 以给定的任何前缀开头，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b90e50f671b05dc996377d3785c4a6e0e543d9ff" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e0cec38e965cb1a7be0a1586c0c1e423e655e66" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a PID (process identifier); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是PID（进程标识符），则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回false。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc1ef9358f093fef465082c08cb4e7223756760e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a binary; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是二进制，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb68195b8efb7757981bf81f0fe6586be5d3de1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a bitstring (including a binary); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是位串（包括二进制），则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79b3d661830095f41c2c68053ed17e9b52d8a01f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a floating-point number; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是浮点数，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dfdb69c5aae41737cbd815e59c8f1871298087f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a function that can be applied with &lt;code&gt;arity&lt;/code&gt; number of arguments; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;term&lt;/code&gt; 是可以与应用功能 &lt;code&gt;arity&lt;/code&gt; 的参数的数目; 否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e89f73bf316fbcc1d6d52abc07e4cb1ed326b1b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a function; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是一个函数，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc10af9077eb74d82ee86a391efb59e0cd84b7b0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a keyword list; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是关键字列表，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回false。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e151da898f287d233b2078fa6ce5e9be52488e5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a list with zero or more elements; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是具有零个或多个元素的列表，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67b05b7c88321c7891dc98e1ad13a9b71be8ac91" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a map; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是地图，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ead0e61ee4b2af85c87450fd0aad9af3d5e78d5a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a port identifier; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是端口标识符，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc5a8e3d83346b723a1e98b79b03336e58e5997" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a reference; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是引用，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836dab30db9cebf9ce31984fd2d439fc70e98fae" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a tuple; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是一个元组，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd9eb92704a0ae5f8e88de02a6cf887bf2e96aca" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is an atom; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是一个原子，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b8986c4215419978baefd80231f45b3beba66ef" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is an integer; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是整数，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14d9412f32700bc4cbbf29f37ca9bcb0a10c90d8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is either an integer or a floating-point number; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是整数或浮点数，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a9f98e326f05651d287e6878b38e46a8be222b2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is either the atom &lt;code&gt;true&lt;/code&gt; or the atom &lt;code&gt;false&lt;/code&gt; (i.e., a boolean); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; （即boolean），则返回 &lt;code&gt;true&lt;/code&gt; ;否则，返回false。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f92792e4651577bb721731f8ac15665ae74573f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;tuple&lt;/code&gt; in &lt;code&gt;module&lt;/code&gt; is marked as overridable.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;tuple&lt;/code&gt; 的 &lt;code&gt;module&lt;/code&gt; 被标记为可重写的。</target>
        </trans-unit>
        <trans-unit id="3c6d2a9d4ac17e816f44f5c8d82e7d9189bc17b0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;version&lt;/code&gt; satisfies &lt;code&gt;requirement&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise. Raises a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; exception if &lt;code&gt;requirement&lt;/code&gt; is not parsable, or a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if &lt;code&gt;version&lt;/code&gt; is not parsable. If given an already parsed version and requirement this function won't raise.</source>
          <target state="translated">如果 &lt;code&gt;version&lt;/code&gt; 满足 &lt;code&gt;requirement&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;requirement&lt;/code&gt; 不可解析，则引发&lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt;异常；如果 &lt;code&gt;version&lt;/code&gt; 不可解析，则引发&lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt;异常。如果给出已经解析的版本和要求，则此功能不会提高。</target>
        </trans-unit>
        <trans-unit id="b102633aa65f0f78fd85e893465d9febbf820c32" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if IEx was started, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果启动了IEx，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78d65a702a5304adca7eb9dab5e18bc6ac1ece7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if Mix is in debug mode, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果Mix处于调试模式，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db763b2e2e218025c9bf3894db52d7ba51dfc882" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if given module is a task.</source>
          <target state="translated">如果给定模块是任务，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9105393990e5f4b49e81200562038a9b37a0983b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is less than or equal to right.</source>
          <target state="translated">如果left小于或等于right，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10d817cde0ccac57c3abe0e906618887d09b990f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is less than right.</source>
          <target state="translated">如果left小于right，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e3751787d81fb8270fa300c2ad1abeed3087881" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is more than or equal to right.</source>
          <target state="translated">如果left大于或等于right，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d3a72a03b6c80be9f6c0fd73128ebce147e5ab7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is more than right.</source>
          <target state="translated">如果left大于right，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ae8d1d3d77e5618d9d9149276c9cd506b6a50c2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; if not, and the atom &lt;code&gt;:ignored&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;true&lt;/code&gt; ;否则，则返回 &lt;code&gt;false&lt;/code&gt; ;如果本地节点未处于活动状态，则返回原子 &lt;code&gt;:ignored&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5569a7432c35dfe52f433263028783085945fdba" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;integer&lt;/code&gt; is an even number, otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; 如果给定的 &lt;code&gt;integer&lt;/code&gt; 为偶数，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96e3993e05bf18f75065b0a674e4abf8709186ea" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;integer&lt;/code&gt; is an odd number, otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; 如果给定的 &lt;code&gt;integer&lt;/code&gt; 为奇数，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73e3c10f82f542446d2c7d01a47b7b0bfb6361e2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;term&lt;/code&gt; is a regex. Otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定 &lt;code&gt;term&lt;/code&gt; 是正则表达式，则返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a75c9e8f261e40e0328fdfc1d1e450ebf79d0480" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;term&lt;/code&gt; is an exception.</source>
          <target state="translated">如果给定 &lt;code&gt;term&lt;/code&gt; 是异常，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cd92930de87a97665516f3e7c0ed77c0241d737" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given name and arity is a special form.</source>
          <target state="translated">如果给定名称和别名是一种特殊形式，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbbcb4829fb9912c3525baacd41622ceec30d952" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given name and arity is an operator.</source>
          <target state="translated">如果给定的名称和Arity是运算符，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52116aac5e28100d570d3cb42c4444a615786a50" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given path exists.</source>
          <target state="translated">如果给定路径存在，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5fc3ddeee6d05ca5c0842207c7f56323a1a6f14" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given path is a directory.</source>
          <target state="translated">如果给定路径是目录，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517323943306de393ed5a17a3debaae9a9fed99c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given quoted expression is an AST literal.</source>
          <target state="translated">如果给定的带引号的表达式是AST文字，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="070beb97acda30870921a2b5172f899e978ee793" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given year is a leap year.</source>
          <target state="translated">如果给定的年份是a年，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d291a7b2377eea8162c3c36aa1cd1e9a3a7a6551" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the local node is alive.</source>
          <target state="translated">如果本地节点处于活动状态，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="156b20d9c8ac68b8747fdeb1da0914a3b632fddb" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the path is a regular file.</source>
          <target state="translated">如果路径是常规文件，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d9b07689695541ab22ddfbd90213a8b9d2d0606" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the protocol was consolidated.</source>
          <target state="translated">如果协议已合并，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="881d186c21e4675ad58d6e30bbadb52783870ebd" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are equal.</source>
          <target state="translated">如果两个条件相等，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e22125544cf945bb28eba5fc390b3a027251780" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are exactly equal.</source>
          <target state="translated">如果两个术语完全相等，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f32dc56bc22b6598e27fc9e37220143e0f323c6" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are not equal.</source>
          <target state="translated">如果两个条件不相等，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="065ff8f9bd783f62860f90b7044cda8eab69fb25" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are not exactly equal.</source>
          <target state="translated">如果两个条件不完全相等，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="229c2393cba0014721bc6cce3f70d909956c53cb" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the year in the given &lt;code&gt;date&lt;/code&gt; is a leap year.</source>
          <target state="translated">如果给定 &lt;code&gt;date&lt;/code&gt; 中的年份是a 年，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a00c2b01cafb21f20aede0315828bc757af694" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if there is such a spec and it was copied as a callback. If the function associated to the spec has documentation defined prior to invoking this function, the docs are copied too.</source>
          <target state="translated">如果存在这样的规范并将其复制为回调，则返回 &lt;code&gt;true&lt;/code&gt; 。如果与规范关联的功能在调用此功能之前已定义文档，则文档也会被复制。</target>
        </trans-unit>
        <trans-unit id="baa3ca70dba967b0e62e4a45ae94ce224c5b50d1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if two calendars have the same moment of starting a new day, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果两个日历在同一天开始新的一天，则返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe1be0b98d40df3569dc29aeea771c28ce30865" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47f2f68842134b4ffc89dac515dace73b452b30e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:error, :nofile}&lt;/code&gt; if the object code (i.e. &quot;.beam&quot; file) for the module could not be found locally.</source>
          <target state="translated">如果无法在本地找到模块的目标代码（即&amp;ldquo; .beam&amp;rdquo;文件），则返回 &lt;code&gt;{:error, :nofile}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f710f35d60c6b707ea291cad4605f95090d8c8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, binary}&lt;/code&gt;, where &lt;code&gt;binary&lt;/code&gt; is a binary data object that contains the contents of &lt;code&gt;path&lt;/code&gt;, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, binary}&lt;/code&gt; ，其中 &lt;code&gt;binary&lt;/code&gt; 是包含的内容的二进制数据对象 &lt;code&gt;path&lt;/code&gt; ，或 &lt;code&gt;{:error, reason}&lt;/code&gt; 如果发生错误。</target>
        </trans-unit>
        <trans-unit id="25e0d60989d049e604d74bc930f296684099ec4b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, bytes_copied}&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{:ok, bytes_copied}&lt;/code&gt; 返回{： &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f3b14d34e951b96b9a67a82034916e33ca9318" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if the calendars are compatible, or &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; if they are not.</source>
          <target state="translated">如果日历兼容，则返回 &lt;code&gt;{:ok, date}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6057594582ceb37532b2d7e625f688602918826" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, element}&lt;/code&gt; if found, otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果找到，则返回 &lt;code&gt;{:ok, element}&lt;/code&gt; ，否则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8465f6ff407bdb0c564ac803b1f00a18b0d13256" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; with all files and directories removed in no specific order, &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; 其中所有文件和目录均以不特定的顺序删除，否则返回{： &lt;code&gt;{:error, reason, file}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19f842e2bafa50ff26925ccf6b987eee1f2ba2de" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, files}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{:ok, files}&lt;/code&gt; ，否则返回{： &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc3733718dbca9b65f2fc1faa8f991cc16a2e70" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, function_result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{:ok, function_result}&lt;/code&gt; ，否则返回{： &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98db4c3fa0a1a28efa6e85fa145c623de0fb6e8e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, quoted_form}&lt;/code&gt; if it succeeds, &lt;code&gt;{:error, {line, error, token}}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{:ok, quoted_form}&lt;/code&gt; 返回{： &lt;code&gt;{:error, {line, error, token}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c62985686c63d161efb90844fcc11aa585deb21" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, reply}&lt;/code&gt; if the reply is received while shutting down the task, &lt;code&gt;{:exit, reason}&lt;/code&gt; if the task died, otherwise &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果在关闭任务时收到回复，则返回 &lt;code&gt;{:ok, reply}&lt;/code&gt; 如果任务死了，则返回 &lt;code&gt;{:exit, reason}&lt;/code&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7721fcaadf1867ccdb0ee8fabd46fbe4697b0e3b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, reply}&lt;/code&gt; if the reply is received, &lt;code&gt;nil&lt;/code&gt; if no reply has arrived, or &lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return &lt;code&gt;{:exit, reason}&lt;/code&gt; only if</source>
          <target state="translated">如果收到答复，则返回 &lt;code&gt;{:ok, reply}&lt;/code&gt; ，如果没有答复则返回 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;{:exit, reason}&lt;/code&gt; 如果任务已经退出，则返回{：exit，原因}。请记住，通常任务失败也会导致拥有该任务的进程退出。因此 &lt;code&gt;{:exit, reason}&lt;/code&gt; 仅当</target>
        </trans-unit>
        <trans-unit id="42c38d3829fadb64161c3356c163c581ae817e29" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if the conversion was successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if it was not, for some reason.</source>
          <target state="translated">如果转换成功，则返回 &lt;code&gt;{:ok, time}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; ，由于某种原因。</target>
        </trans-unit>
        <trans-unit id="154aaa63b2577dee11cda9665444466fcb0b0d8a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if there is such a key, or &lt;code&gt;:error&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not found.</source>
          <target state="translated">返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 其中 &lt;code&gt;value&lt;/code&gt; 是根据价值 &lt;code&gt;key&lt;/code&gt; ，如果有这样一个键，或者 &lt;code&gt;:error&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 是找不到的。</target>
        </trans-unit>
        <trans-unit id="fa7e955fa1d334a3f092f415c81243abd2e6e73b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{pid, value}&lt;/code&gt; pairs under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;registry&lt;/code&gt; 中与 &lt;code&gt;pattern&lt;/code&gt; 匹配的给定 &lt;code&gt;key&lt;/code&gt; 下返回 &lt;code&gt;{pid, value}&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="85343a2e2d448cdb8c68e2a769e6043640f27d33" translate="yes" xml:space="preserve">
          <source>Returns Elixir's version as binary.</source>
          <target state="translated">返回Elixir的二进制版本。</target>
        </trans-unit>
        <trans-unit id="c8327a48eb3d8b0888d21e8643d31dbfd61ce65e" translate="yes" xml:space="preserve">
          <source>Returns ExUnit configuration.</source>
          <target state="translated">返回ExUnit配置。</target>
        </trans-unit>
        <trans-unit id="e45ed402a1aef0911bf0539790a9e21d296ec8d5" translate="yes" xml:space="preserve">
          <source>Returns IEx configuration.</source>
          <target state="translated">返回IEx配置。</target>
        </trans-unit>
        <trans-unit id="d8ddd6d989fce705f0bd075a07a2e07b8419b81a" translate="yes" xml:space="preserve">
          <source>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</source>
          <target state="translated">按照Extended Grapheme Cluster算法返回字符串中的Unicode字词。</target>
        </trans-unit>
        <trans-unit id="a879d2b042e9ebf3e77966bf7fa720eb5fe03d58" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point in time, but instead at the time zone provided. It assumes that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is valid and exists in the given time zone and calendar.</source>
          <target state="translated">返回相同时间点的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，而不是提供的时区。它假定&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;有效，并且存在于给定的时区和日历中。</target>
        </trans-unit>
        <trans-unit id="68a4b55af4634a3e875518186464c1a14a8382cb" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; in the match context.</source>
          <target state="translated">在匹配上下文中返回&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6eec35892f7539fb9be61cf27410a2e47b62417d" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;file.stream&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; for the given &lt;code&gt;path&lt;/code&gt; with the given &lt;code&gt;modes&lt;/code&gt;.</source>
          <target state="translated">返回具有给定 &lt;code&gt;modes&lt;/code&gt; 的给定 &lt;code&gt;path&lt;/code&gt; 的&lt;a href=&quot;file.stream&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8144be8098e36dc7446a14e943dc98ccaeb4c84" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;{new_value, old_value}&lt;/code&gt; tuple or &lt;code&gt;:error&lt;/code&gt; if there is no such key assigned to the current process.</source>
          <target state="translated">如果没有分配给当前进程的键 &lt;code&gt;{new_value, old_value}&lt;/code&gt; 返回一个{new_value，old_value}元组或 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed9d70afa84c2d6c400dd032dc85829ad3b83b52" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt; in the given &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">返回一个二进制，它对应于给定 &lt;code&gt;base&lt;/code&gt; 中 &lt;code&gt;integer&lt;/code&gt; 的文本表示形式。</target>
        </trans-unit>
        <trans-unit id="3fe6fea6c77a74fd7aefea1b6360d798d95ece81" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">返回对应于 &lt;code&gt;integer&lt;/code&gt; 的文本表示形式的二进制。</target>
        </trans-unit>
        <trans-unit id="fb6a545975b068b3aecc7914d1615a7f44705a51" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of the given float.</source>
          <target state="translated">返回对应于给定浮点数的文本表示的二进制。</target>
        </trans-unit>
        <trans-unit id="e9ee2af2fefcd231b751de3abbbb4367e4a017d5" translate="yes" xml:space="preserve">
          <source>Returns a binary with the contents of the given filename, or raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if an error occurs.</source>
          <target state="translated">返回具有给定文件名内容的二进制文件，如果发生错误，则引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="120b1743f1c9682c89a8ee1edeecbdcde083f3e9" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether there was a match or not.</source>
          <target state="translated">返回一个布尔值,表示是否有匹配。</target>
        </trans-unit>
        <trans-unit id="b5dce3473d3544c2ba77aa5170f30e27f43d3523" translate="yes" xml:space="preserve">
          <source>Returns a break document based on the given &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">根据给定的 &lt;code&gt;string&lt;/code&gt; 返回中断文档。</target>
        </trans-unit>
        <trans-unit id="148f06e99adcd7ca106331bc4f679ef4533da0a3" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt; in the given &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">返回一个字符列表，该字符列表对应于给定 &lt;code&gt;base&lt;/code&gt; 中 &lt;code&gt;integer&lt;/code&gt; 的文本表示形式。</target>
        </trans-unit>
        <trans-unit id="1503e8fafb0830e350373d283f11c7581b3c38f8" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of the given &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">返回与给定 &lt;code&gt;integer&lt;/code&gt; 的文本表示形式对应的字符列表。</target>
        </trans-unit>
        <trans-unit id="43b18b9794e48a6db989f7ec557071f9c475c477" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of the given float.</source>
          <target state="translated">返回对应于给定浮点数的文本表示的charlist。</target>
        </trans-unit>
        <trans-unit id="a66b98e04f0ea2a62e2fb6e6de98289cd67c3736" translate="yes" xml:space="preserve">
          <source>Returns a document entity used to represent nothingness.</source>
          <target state="translated">返回一个用于表示虚无的文档实体。</target>
        </trans-unit>
        <trans-unit id="a1bfd05f736e844750b386b1c01e973ef52bc4ca" translate="yes" xml:space="preserve">
          <source>Returns a flex break document based on the given &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">根据给定的 &lt;code&gt;string&lt;/code&gt; 返回flex break文档。</target>
        </trans-unit>
        <trans-unit id="0c47e20aaea8620c53179f6fb170bdceaf383d8a" translate="yes" xml:space="preserve">
          <source>Returns a float value between 0 and 1 representing the bag distance between &lt;code&gt;string1&lt;/code&gt; and &lt;code&gt;string2&lt;/code&gt;.</source>
          <target state="translated">返回介于0和1之间的浮点值，表示 &lt;code&gt;string1&lt;/code&gt; 和 &lt;code&gt;string2&lt;/code&gt; 之间的袋子距离。</target>
        </trans-unit>
        <trans-unit id="998bf1dee48191c100b29bb8870dc0bfd94436f0" translate="yes" xml:space="preserve">
          <source>Returns a float value between &lt;code&gt;0.0&lt;/code&gt; (equates to no similarity) and &lt;code&gt;1.0&lt;/code&gt; (is an exact match) representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Jaro-Winkler_distance&quot;&gt;Jaro&lt;/a&gt; distance between &lt;code&gt;string1&lt;/code&gt; and &lt;code&gt;string2&lt;/code&gt;.</source>
          <target state="translated">返回介于 &lt;code&gt;0.0&lt;/code&gt; （等于无相似性）和 &lt;code&gt;1.0&lt;/code&gt; （完全匹配）之间的float值，表示 &lt;code&gt;string1&lt;/code&gt; 和 &lt;code&gt;string2&lt;/code&gt; 之间的&lt;a href=&quot;https://en.wikipedia.org/wiki/Jaro-Winkler_distance&quot;&gt;Jaro&lt;/a&gt;距离。</target>
        </trans-unit>
        <trans-unit id="e9f8bf09a9f34d4aa9970244bb6b08137539aa70" translate="yes" xml:space="preserve">
          <source>Returns a float whose text representation is &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">返回其文本表示形式为 &lt;code&gt;string&lt;/code&gt; 的float 。</target>
        </trans-unit>
        <trans-unit id="31dfe0ef9ec0fedde587f2c8b1e43ddb330410d1" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses all elements of a list that match the provided predicate.</source>
          <target state="translated">返回一个访问列表中所有符合所提供的谓词的元素的函数。</target>
        </trans-unit>
        <trans-unit id="b2e7a33fe2eca022933ae3188c0bec0da1284381" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses all the elements in a list.</source>
          <target state="translated">返回一个访问列表中所有元素的函数。</target>
        </trans-unit>
        <trans-unit id="cfd1c05d413a490f8c760724f59340db6b61354f" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the element at &lt;code&gt;index&lt;/code&gt; (zero based) of a list.</source>
          <target state="translated">返回一个函数，该函数访问列表的 &lt;code&gt;index&lt;/code&gt; （从零开始）处的元素。</target>
        </trans-unit>
        <trans-unit id="ea1bb2d03634b86a0bbf62fe40a739bf0c9036dd" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the element at the given index in a tuple.</source>
          <target state="translated">返回一个访问元组中给定索引的元素的函数。</target>
        </trans-unit>
        <trans-unit id="1b5bb78552cf299e3751c2c8eda6479ac9f7282f" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the given key in a map/struct.</source>
          <target state="translated">返回访问map/struct中给定键的函数。</target>
        </trans-unit>
        <trans-unit id="55f8b9bb8e42ffaf566f7f747a4ca7567d68281b" translate="yes" xml:space="preserve">
          <source>Returns a function that slices the data structure contiguously.</source>
          <target state="translated">返回一个连续切割数据结构的函数。</target>
        </trans-unit>
        <trans-unit id="2f00d7a399dbc354afa8c2290b54636c57247f20" translate="yes" xml:space="preserve">
          <source>Returns a group containing the specified document &lt;code&gt;doc&lt;/code&gt;.</source>
          <target state="translated">返回包含指定文档 &lt;code&gt;doc&lt;/code&gt; 的组。</target>
        </trans-unit>
        <trans-unit id="8c5398d8391a0259d1ccb3c8a1e4048bcef9effb" translate="yes" xml:space="preserve">
          <source>Returns a keyword list containing the file and line information as keys.</source>
          <target state="translated">返回一个包含文件和行信息的关键字列表。</target>
        </trans-unit>
        <trans-unit id="648bd9570648164795082b3f1c9c78a01e804e98" translate="yes" xml:space="preserve">
          <source>Returns a keyword list of &lt;code&gt;{record_name, fields}&lt;/code&gt; tuples where &lt;code&gt;record_name&lt;/code&gt; is the name of an extracted record and &lt;code&gt;fields&lt;/code&gt; is a list of &lt;code&gt;{field, value}&lt;/code&gt; tuples representing the fields for that record.</source>
          <target state="translated">返回 &lt;code&gt;{record_name, fields}&lt;/code&gt; 元组的关键字列表，其中 &lt;code&gt;record_name&lt;/code&gt; 是提取的记录的名称， &lt;code&gt;fields&lt;/code&gt; 是 &lt;code&gt;{field, value}&lt;/code&gt; 元组的列表，代表该记录的字段。</target>
        </trans-unit>
        <trans-unit id="8337c1a71b4665b5929e7d32d232482d86ee48e9" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an &lt;em&gt;edit script&lt;/em&gt; with nested diffs.</source>
          <target state="translated">返回一个关键字列表，该列表表示带有嵌套差异的&lt;em&gt;编辑脚本&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8a26e224d0b8b71dece8f5e916d84049523f0979" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an &lt;em&gt;edit script&lt;/em&gt;.</source>
          <target state="translated">返回表示&lt;em&gt;编辑脚本&lt;/em&gt;的关键字列表。</target>
        </trans-unit>
        <trans-unit id="cb34012caf25d7194cf4d1bc9c046b1e42666795" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an edit script.</source>
          <target state="translated">返回一个代表编辑脚本的关键字列表。</target>
        </trans-unit>
        <trans-unit id="eedf848148ad7204be333289f9f16e13b3fc0697" translate="yes" xml:space="preserve">
          <source>Returns a keyword list with information about a function.</source>
          <target state="translated">返回一个包含函数信息的关键字列表。</target>
        </trans-unit>
        <trans-unit id="a294c106358f5929d6a933ceb72092fc4e91db19" translate="yes" xml:space="preserve">
          <source>Returns a list of PIDs corresponding to all the processes currently existing on the local node.</source>
          <target state="translated">返回本地节点上当前存在的所有进程对应的PID列表。</target>
        </trans-unit>
        <trans-unit id="d8906cc4706b054f3a0871dd9d0310a0ffd4a655" translate="yes" xml:space="preserve">
          <source>Returns a list of all ports in the current node.</source>
          <target state="translated">返回当前节点中所有端口的列表。</target>
        </trans-unit>
        <trans-unit id="442155f6918bffcbda71b7032acfad2eca666df5" translate="yes" xml:space="preserve">
          <source>Returns a list of all visible nodes in the system, excluding the local node.</source>
          <target state="translated">返回系统中所有可见节点的列表,不包括本地节点。</target>
        </trans-unit>
        <trans-unit id="f8eb0a24f0941de92ece10ea21ea0c9bd87f18fc" translate="yes" xml:space="preserve">
          <source>Returns a list of binaries each of which contains only one kind of characters.</source>
          <target state="translated">返回一个二进制文件的列表,每个二进制文件只包含一种字符。</target>
        </trans-unit>
        <trans-unit id="41dabd7ef6701ee8f9c03c392f544c0830be2893" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in &lt;code&gt;enumerable&lt;/code&gt; excluding those for which the function &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">返回 &lt;code&gt;enumerable&lt;/code&gt; 的元素列表，但 &lt;code&gt;fun&lt;/code&gt; 函数返回其真实值的元素除外。</target>
        </trans-unit>
        <trans-unit id="08000c5f7be9ad33a6570c782818808e7f042883" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in &lt;code&gt;enumerable&lt;/code&gt; in reverse order.</source>
          <target state="translated">以相反的顺序返回 &lt;code&gt;enumerable&lt;/code&gt; 的元素列表。</target>
        </trans-unit>
        <trans-unit id="c4d08a398f8c15dbdfe83b1a89d1c9a457b9a84f" translate="yes" xml:space="preserve">
          <source>Returns a list of every &lt;code&gt;nth&lt;/code&gt; element in the &lt;code&gt;enumerable&lt;/code&gt; dropped, starting with the first element.</source>
          <target state="translated">返回从第一个元素开始的 &lt;code&gt;enumerable&lt;/code&gt; 放置的 &lt;code&gt;nth&lt;/code&gt; 元素的列表。</target>
        </trans-unit>
        <trans-unit id="4b51f0df81b5ca5b56cb57f91725427bb75c7424" translate="yes" xml:space="preserve">
          <source>Returns a list of every &lt;code&gt;nth&lt;/code&gt; element in the &lt;code&gt;enumerable&lt;/code&gt;, starting with the first element.</source>
          <target state="translated">从第一个元素开始，返回 &lt;code&gt;enumerable&lt;/code&gt; 中每个 &lt;code&gt;nth&lt;/code&gt; 元素的列表。</target>
        </trans-unit>
        <trans-unit id="b454366f7b3d78cbfc941bae8df22ee9fbb4a118" translate="yes" xml:space="preserve">
          <source>Returns a list of information of all the function calls in the project.</source>
          <target state="translated">返回项目中所有函数调用的信息列表。</target>
        </trans-unit>
        <trans-unit id="543f883da41aab298162970e26e0991542c23a78" translate="yes" xml:space="preserve">
          <source>Returns a list of lists.</source>
          <target state="translated">返回一个列表。</target>
        </trans-unit>
        <trans-unit id="c263c9ad704887b94b7128901687e89cfa0d788f" translate="yes" xml:space="preserve">
          <source>Returns a list of names in the regex.</source>
          <target state="translated">返回regex中的名称列表。</target>
        </trans-unit>
        <trans-unit id="0e24c8386f4a72d5dc84fefa837a24b53df43bca" translate="yes" xml:space="preserve">
          <source>Returns a list of names which have been registered using &lt;a href=&quot;#register/2&quot;&gt;&lt;code&gt;register/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回已使用&lt;a href=&quot;#register/2&quot;&gt; &lt;code&gt;register/2&lt;/code&gt; &lt;/a&gt;注册的名称的列表。</target>
        </trans-unit>
        <trans-unit id="e8470e68b35ac3b3b896cdb54a7773a9a2458a74" translate="yes" xml:space="preserve">
          <source>Returns a list of nodes according to argument given.</source>
          <target state="translated">根据给定的参数返回一个节点列表。</target>
        </trans-unit>
        <trans-unit id="f3ec5a571b567053b25abfcf409e5640616ed510" translate="yes" xml:space="preserve">
          <source>Returns a list of project configuration files for this project.</source>
          <target state="translated">返回本项目的项目配置文件列表。</target>
        </trans-unit>
        <trans-unit id="62f88ef397b63230e48736e2ce2545ec58ddb020" translate="yes" xml:space="preserve">
          <source>Returns a list of results of invoking &lt;code&gt;fun&lt;/code&gt; on every &lt;code&gt;nth&lt;/code&gt; element of &lt;code&gt;enumerable&lt;/code&gt;, starting with the first element.</source>
          <target state="translated">从第一个元素开始，返回对 &lt;code&gt;enumerable&lt;/code&gt; 的每个 &lt;code&gt;nth&lt;/code&gt; 元素调用 &lt;code&gt;fun&lt;/code&gt; 的结果的列表。</target>
        </trans-unit>
        <trans-unit id="fccd605cb6dc280f4d9624edc25a5e8af076d5e8" translate="yes" xml:space="preserve">
          <source>Returns a list of these parts. The pattern can be a string, a list of strings, a regular expression, or a compiled pattern.</source>
          <target state="translated">返回这些部件的列表。模式可以是一个字符串、一个字符串列表、一个正则表达式或一个编译模式。</target>
        </trans-unit>
        <trans-unit id="8244ce7e7962dc18e63cc6bb50b0981feb2b847c" translate="yes" xml:space="preserve">
          <source>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A &lt;code&gt;file&lt;/code&gt; can be given as second argument which will be used for reporting warnings and errors.</source>
          <target state="translated">返回一个元组列表，其中第一个元素是模块名称，第二个元素是其字节码（二进制）。一个 &lt;code&gt;file&lt;/code&gt; 可以作为将被用于报告警告和错误的第二个参数。</target>
        </trans-unit>
        <trans-unit id="8030ddd5e1a6c45acf4116b3a1cb2af7216011a1" translate="yes" xml:space="preserve">
          <source>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). Opposite to &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt;, it does not track the filename of the compiled file.</source>
          <target state="translated">返回一个元组列表，其中第一个元素是模块名称，第二个元素是其字节码（二进制）。与&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;相反，它不跟踪已编译文件的文件名。</target>
        </trans-unit>
        <trans-unit id="7b04fc71c3bba89d65fc90b112e21df50106a3bc" translate="yes" xml:space="preserve">
          <source>Returns a list of variables in the current environment.</source>
          <target state="translated">返回当前环境中的变量列表。</target>
        </trans-unit>
        <trans-unit id="a435441f15be08b7ff15b579018abecdc00bc602" translate="yes" xml:space="preserve">
          <source>Returns a list where each element is the result of invoking &lt;code&gt;fun&lt;/code&gt; on each corresponding element of &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回一个列表，其中每个元素都是对 &lt;code&gt;enumerable&lt;/code&gt; 的每个对应元素调用 &lt;code&gt;fun&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="ec27903f5ae78dc874c9df5818a4b29f8aa65266" translate="yes" xml:space="preserve">
          <source>Returns a list with &lt;code&gt;value&lt;/code&gt; inserted at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">返回在指定 &lt;code&gt;index&lt;/code&gt; 处插入 &lt;code&gt;value&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="7f2ea00fcc82bbc6b6dcd711a2adc16be411dabf" translate="yes" xml:space="preserve">
          <source>Returns a list with a replaced value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">返回在指定 &lt;code&gt;index&lt;/code&gt; 处具有替换值的列表。</target>
        </trans-unit>
        <trans-unit id="194e44d56acccbecc0953b596c47bacb2836f1fa" translate="yes" xml:space="preserve">
          <source>Returns a list with an updated value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">返回具有指定 &lt;code&gt;index&lt;/code&gt; 处的更新值的列表。</target>
        </trans-unit>
        <trans-unit id="cac6cb2d5b65cec2cebc7f98c8e676a52e8a12e5" translate="yes" xml:space="preserve">
          <source>Returns a list with information about all children of the given supervisor.</source>
          <target state="translated">返回一个包含给定主管的所有子女信息的列表。</target>
        </trans-unit>
        <trans-unit id="8be9be340deaec39cff95b3d58502fb1f32311d0" translate="yes" xml:space="preserve">
          <source>Returns a list with information about all children.</source>
          <target state="translated">返回一个包含所有儿童信息的列表。</target>
        </trans-unit>
        <trans-unit id="ae5b3e7b9544d246ab2ddf253fc4625df3b3fad2" translate="yes" xml:space="preserve">
          <source>Returns a list with information about the applications which are currently running.</source>
          <target state="translated">返回当前正在运行的应用程序信息的列表。</target>
        </trans-unit>
        <trans-unit id="9556f6608ac48363049e28e2254897ca4d3d6bbe" translate="yes" xml:space="preserve">
          <source>Returns a list with information about the applications which have been loaded.</source>
          <target state="translated">返回包含已加载的应用程序信息的列表。</target>
        </trans-unit>
        <trans-unit id="9dc40e627344f95c93e4ec9b038b5d04b7dabe06" translate="yes" xml:space="preserve">
          <source>Returns a list with the available compiler options.</source>
          <target state="translated">返回一个包含可用编译器选项的列表。</target>
        </trans-unit>
        <trans-unit id="caa61a915d0b0a3954d25228367b76a55e8c46b5" translate="yes" xml:space="preserve">
          <source>Returns a list with the elements of &lt;code&gt;enumerable&lt;/code&gt; shuffled.</source>
          <target state="translated">返回带有 &lt;code&gt;enumerable&lt;/code&gt; 元素的列表。</target>
        </trans-unit>
        <trans-unit id="75e31c70d49c501aa570c31218e633b38b9cac15" translate="yes" xml:space="preserve">
          <source>Returns a map containing count values for the given supervisor.</source>
          <target state="translated">返回一个包含给定主管的计数值的地图。</target>
        </trans-unit>
        <trans-unit id="6aa62c1653283a212e8297ca294f4114c48e5453" translate="yes" xml:space="preserve">
          <source>Returns a map containing count values for the supervisor.</source>
          <target state="translated">返回一个包含主管的计数值的地图。</target>
        </trans-unit>
        <trans-unit id="f64f0a2526f951c2cc84f1d137432fe69495d9aa" translate="yes" xml:space="preserve">
          <source>Returns a map containing the total number of tests, the number of failures, the number of excluded tests and the number of skipped tests.</source>
          <target state="translated">Returns a map containing the total number of tests,number of failures,number of excluded tests and number of skipped tests。</target>
        </trans-unit>
        <trans-unit id="e48947a95d8a72816f9cddcba983270eb4a365c9" translate="yes" xml:space="preserve">
          <source>Returns a map with the Elixir version, the Erlang/OTP release it was compiled with, a short Git revision hash and the date and time it was built.</source>
          <target state="translated">返回包含Elixir版本、编译时使用的Erlang/OTP版本、简短的Git修订版哈希以及构建日期和时间的地图。</target>
        </trans-unit>
        <trans-unit id="4cbfdcfd806b8b2dd63bdb3d7952ca6be2cb7883" translate="yes" xml:space="preserve">
          <source>Returns a map with the umbrella child applications paths.</source>
          <target state="translated">返回包含保护伞子应用程序路径的地图。</target>
        </trans-unit>
        <trans-unit id="577b259579425fb15446d410225cd83d09c11ab4" translate="yes" xml:space="preserve">
          <source>Returns a microsecond tuple truncated to a given precision (&lt;code&gt;:microsecond&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:second&lt;/code&gt;).</source>
          <target state="translated">返回被截断为给定精度的微秒元组（ &lt;code&gt;:microsecond&lt;/code&gt; ， &lt;code&gt;:millisecond&lt;/code&gt; 或 &lt;code&gt;:second&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="456254db671e7211f8cf975ebc7a01fd2d4e0998" translate="yes" xml:space="preserve">
          <source>Returns a new empty map.</source>
          <target state="translated">返回一个新的空地图。</target>
        </trans-unit>
        <trans-unit id="1de9e80d913162895ee668db73d628ac36f3f1be" translate="yes" xml:space="preserve">
          <source>Returns a new list with all the tuple elements.</source>
          <target state="translated">返回一个包含所有元组元素的新列表。</target>
        </trans-unit>
        <trans-unit id="f1eabd6cd97a0e9ba88d32a0847a516f885aa149" translate="yes" xml:space="preserve">
          <source>Returns a new map with all the key-value pairs in &lt;code&gt;map&lt;/code&gt; where the key is in &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">返回与所有的键值对新地图 &lt;code&gt;map&lt;/code&gt; ，其中关键是在 &lt;code&gt;keys&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af29913ee55ab14a28ffeef5c6463f0e6a27de67" translate="yes" xml:space="preserve">
          <source>Returns a new set which is a copy of &lt;code&gt;map_set&lt;/code&gt; but without &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">返回一个新集合，该集合是 &lt;code&gt;map_set&lt;/code&gt; 的副本，但没有 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d89b807379e6e83302850820787d6e2455a9be49" translate="yes" xml:space="preserve">
          <source>Returns a new set.</source>
          <target state="translated">返回一个新的集合。</target>
        </trans-unit>
        <trans-unit id="593aa885fd57e21ecae557eeb33661b2357bb26c" translate="yes" xml:space="preserve">
          <source>Returns a new string created by replacing occurrences of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;subject&lt;/code&gt; with &lt;code&gt;replacement&lt;/code&gt;.</source>
          <target state="translated">返回替换的出现创造了一个新的字符串 &lt;code&gt;pattern&lt;/code&gt; 在 &lt;code&gt;subject&lt;/code&gt; 与 &lt;code&gt;replacement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5083144141615836b53ba33e2622989da2341885" translate="yes" xml:space="preserve">
          <source>Returns a new string padded with a leading filler which is made of elements from the &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">返回一个新的字符串，该字符串用前导填充符填充，该填充符由 &lt;code&gt;padding&lt;/code&gt; 中的元素组成。</target>
        </trans-unit>
        <trans-unit id="f5f12166c88991612389eebd8f5e894dc39963de" translate="yes" xml:space="preserve">
          <source>Returns a new string padded with a trailing filler which is made of elements from the &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">返回一个新的字符串，该字符串由 &lt;code&gt;padding&lt;/code&gt; 元素组成的尾随填充符填充。</target>
        </trans-unit>
        <trans-unit id="3b79ec9067cac0c611785cc80d52ec1f184545e0" translate="yes" xml:space="preserve">
          <source>Returns a new tuple with the element appended at the end, and contains the elements in &lt;code&gt;tuple&lt;/code&gt; followed by &lt;code&gt;value&lt;/code&gt; as the last element.</source>
          <target state="translated">返回一个新的元组，该元组的末尾附加元素，并包含 &lt;code&gt;tuple&lt;/code&gt; 中的元素，后跟 &lt;code&gt;value&lt;/code&gt; 作为最后一个元素。</target>
        </trans-unit>
        <trans-unit id="1fd950ec684b5f58c716702cc6515ef2732cc35c" translate="yes" xml:space="preserve">
          <source>Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.</source>
          <target state="translated">返回一对整数,其比值恰好等于原来的浮点数,且分母为正数。</target>
        </trans-unit>
        <trans-unit id="ebb93599cfaa3e0a101538db0f72f4e659111549" translate="yes" xml:space="preserve">
          <source>Returns a quoted expression containing the fields as a list of tuples.</source>
          <target state="translated">返回一个包含字段的引用表达式,作为一个元组列表。</target>
        </trans-unit>
        <trans-unit id="0258ae812e9738eccffc25af4f511a4696661e12" translate="yes" xml:space="preserve">
          <source>Returns a random element of an &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;enumerable&lt;/code&gt; 的随机元素。</target>
        </trans-unit>
        <trans-unit id="68311a4d355d1a1367604d1a97e1ec72781c2627" translate="yes" xml:space="preserve">
          <source>Returns a range of dates.</source>
          <target state="translated">返回一个日期范围。</target>
        </trans-unit>
        <trans-unit id="fb20084f202d63d2e087bd5b253825ad1541cba1" translate="yes" xml:space="preserve">
          <source>Returns a range with the specified &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; integers.</source>
          <target state="translated">返回具有指定的 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 整数的范围。</target>
        </trans-unit>
        <trans-unit id="0cfb3ee91f1e7803aeeae50c9afdbd58c4a0494f" translate="yes" xml:space="preserve">
          <source>Returns a set containing all members of &lt;code&gt;map_set1&lt;/code&gt; and &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">返回一个包含 &lt;code&gt;map_set1&lt;/code&gt; 和 &lt;code&gt;map_set2&lt;/code&gt; 的所有成员的集合。</target>
        </trans-unit>
        <trans-unit id="c7e140698da2797ab90228cb1fe2e4daf4bf7bd0" translate="yes" xml:space="preserve">
          <source>Returns a set containing only members that &lt;code&gt;map_set1&lt;/code&gt; and &lt;code&gt;map_set2&lt;/code&gt; have in common.</source>
          <target state="translated">返回仅包含 &lt;code&gt;map_set1&lt;/code&gt; 和 &lt;code&gt;map_set2&lt;/code&gt; 有共同点的成员的集合。</target>
        </trans-unit>
        <trans-unit id="77d801b91285762b7c58364cfd1b23fdf545bf37" translate="yes" xml:space="preserve">
          <source>Returns a set that is &lt;code&gt;map_set1&lt;/code&gt; without the members of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">返回一组是 &lt;code&gt;map_set1&lt;/code&gt; 没有成员 &lt;code&gt;map_set2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd8e89ddc96087c4845355b2bc3ed2ac6bca08b8" translate="yes" xml:space="preserve">
          <source>Returns a specific information about the function.</source>
          <target state="translated">返回函数的具体信息。</target>
        </trans-unit>
        <trans-unit id="ade53d26fd49c96742f8c2f9ec1c19ff5f585daa" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a dynamic supervisor under a supervisor.</source>
          <target state="translated">返回一个规范,以启动一个主管下的动态主管。</target>
        </trans-unit>
        <trans-unit id="688104702b513d9e2a5c6b446efa4fff4350efd8" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a registry under a supervisor.</source>
          <target state="translated">返回在主管下启动注册表的规范。</target>
        </trans-unit>
        <trans-unit id="39726169845a0007a11ac1c1802741f412dc9a02" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a task under a supervisor.</source>
          <target state="translated">返回在主管下启动任务的规范。</target>
        </trans-unit>
        <trans-unit id="a971d06295628f307553b8532333fe53b2d6db9e" translate="yes" xml:space="preserve">
          <source>Returns a specification to start an agent under a supervisor.</source>
          <target state="translated">返回在主管下启动代理的规范。</target>
        </trans-unit>
        <trans-unit id="3b59fc82f7ced9ba4e9462febb3a349db49c4788" translate="yes" xml:space="preserve">
          <source>Returns a specification to start this module under a supervisor.</source>
          <target state="translated">Returns a specification to start this module under a supervisor.</target>
        </trans-unit>
        <trans-unit id="37a637ecd014943420fb395fff88ce0640ba2b2f" translate="yes" xml:space="preserve">
          <source>Returns a stream generated by calling &lt;code&gt;generator_fun&lt;/code&gt; repeatedly.</source>
          <target state="translated">返回通过重复调用 &lt;code&gt;generator_fun&lt;/code&gt; 生成的流。</target>
        </trans-unit>
        <trans-unit id="2ce10d4439c9ded520a2ceb914ab4aa7920dd279" translate="yes" xml:space="preserve">
          <source>Returns a stream of two-element tuples representing key-value pairs in the given &lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">返回表示给定 &lt;code&gt;query&lt;/code&gt; 键值对的两个元素的元组流。</target>
        </trans-unit>
        <trans-unit id="8c408cbe5adb568e4c29e0c46a4da3160a6a82b7" translate="yes" xml:space="preserve">
          <source>Returns a stream that runs the given &lt;code&gt;function&lt;/code&gt; concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回在 &lt;code&gt;enumerable&lt;/code&gt; 中的每个元素上同时运行给定 &lt;code&gt;function&lt;/code&gt; 的流。</target>
        </trans-unit>
        <trans-unit id="6e496b0f2924747071bd9a07cac7da5f78b00d7c" translate="yes" xml:space="preserve">
          <source>Returns a stream that runs the given function &lt;code&gt;fun&lt;/code&gt; concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回在 &lt;code&gt;enumerable&lt;/code&gt; 中的每个元素上同时运行给定功能 &lt;code&gt;fun&lt;/code&gt; 的流。</target>
        </trans-unit>
        <trans-unit id="a0abd42595135eb6e6bc02e83c1dc3bb49aa88b3" translate="yes" xml:space="preserve">
          <source>Returns a stream where the given function (&lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;) is mapped concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回一个流，在该流中，给定函数（ &lt;code&gt;module&lt;/code&gt; 和 &lt;code&gt;function&lt;/code&gt; ）在 &lt;code&gt;enumerable&lt;/code&gt; 中的每个元素上同时映射。</target>
        </trans-unit>
        <trans-unit id="5678b516f871306c06a41b4392d2b5b139efdac5" translate="yes" xml:space="preserve">
          <source>Returns a stream where the given function (&lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function_name&lt;/code&gt;) is mapped concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">返回一个流，其中给定的函数（ &lt;code&gt;module&lt;/code&gt; 和 &lt;code&gt;function_name&lt;/code&gt; ）在 &lt;code&gt;enumerable&lt;/code&gt; 中同时映射到每个元素上。</target>
        </trans-unit>
        <trans-unit id="180fc15b92792093769a25c20115b5e9872ea17f" translate="yes" xml:space="preserve">
          <source>Returns a string &lt;code&gt;subject&lt;/code&gt; duplicated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">返回重复 &lt;code&gt;n&lt;/code&gt; 次的字符串 &lt;code&gt;subject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be4ae560047bcef41ff0b28a347e27a66f4e0f8" translate="yes" xml:space="preserve">
          <source>Returns a string containing the (usually) numerical identifier for a process. On UNIX, this is typically the return value of the &lt;code&gt;getpid()&lt;/code&gt; system call. On Windows, the process ID as returned by the &lt;code&gt;GetCurrentProcessId()&lt;/code&gt; system call is used.</source>
          <target state="translated">返回一个字符串，其中包含进程的（通常）数字标识符。在UNIX上，这通常是 &lt;code&gt;getpid()&lt;/code&gt; 系统调用的返回值。在Windows上，使用由 &lt;code&gt;GetCurrentProcessId()&lt;/code&gt; 系统调用返回的进程ID 。</target>
        </trans-unit>
        <trans-unit id="e2a419178bbb940b05880a5915a9ca05120adc14" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">返回一个字符串，其中所有前导 &lt;code&gt;to_trim&lt;/code&gt; 字符均已删除。</target>
        </trans-unit>
        <trans-unit id="9ce1c2a880865790d64e30f1e06470b38e182bfd" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading Unicode whitespaces have been removed.</source>
          <target state="translated">返回一个已删除所有Unicode前导空格的字符串。</target>
        </trans-unit>
        <trans-unit id="5863b021d35f8bce6c99b63c41facc6909ca977c" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading and trailing &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">返回一个字符串，其中所有 &lt;code&gt;to_trim&lt;/code&gt; 开头和结尾字符均已删除。</target>
        </trans-unit>
        <trans-unit id="f3acd17e8deabf16e78c4e5d3cd435340469c166" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading and trailing Unicode whitespaces have been removed.</source>
          <target state="translated">返回一个字符串,其中所有前导和尾部的Unicode空格都已被删除。</target>
        </trans-unit>
        <trans-unit id="77037d4de2ee207efdb679f3991444eaf4bfb6d8" translate="yes" xml:space="preserve">
          <source>Returns a string where all trailing &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">返回一个字符串，其中所有结尾的 &lt;code&gt;to_trim&lt;/code&gt; 字符均已删除。</target>
        </trans-unit>
        <trans-unit id="b44e9f329fffddee85ee207a2880ca69a73d5432" translate="yes" xml:space="preserve">
          <source>Returns a string where all trailing Unicode whitespaces has been removed.</source>
          <target state="translated">返回一个删除了所有Unicode尾部空格的字符串。</target>
        </trans-unit>
        <trans-unit id="59755cc1b2bcebeacfa9d917bc55e49814c2c282" translate="yes" xml:space="preserve">
          <source>Returns a subset list of the given &lt;code&gt;enumerable&lt;/code&gt; by &lt;code&gt;index_range&lt;/code&gt;.</source>
          <target state="translated">返回给定的 &lt;code&gt;index_range&lt;/code&gt; &lt;code&gt;enumerable&lt;/code&gt; 的子集列表。</target>
        </trans-unit>
        <trans-unit id="f01588f322f3a6c48ef0b1142d4af450e450f7de" translate="yes" xml:space="preserve">
          <source>Returns a subset list of the given &lt;code&gt;enumerable&lt;/code&gt;, from &lt;code&gt;start_index&lt;/code&gt; (zero-based) with &lt;code&gt;amount&lt;/code&gt; number of elements if available.</source>
          <target state="translated">返回给定的子集列表 &lt;code&gt;enumerable&lt;/code&gt; ，从 &lt;code&gt;start_index&lt;/code&gt; 与（从零开始） &lt;code&gt;amount&lt;/code&gt; 如果可用元素的数目。</target>
        </trans-unit>
        <trans-unit id="db1fa0efe5f563fd77fbd770ee5847604d12fb0c" translate="yes" xml:space="preserve">
          <source>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</source>
          <target state="translated">返回一个从范围开始给定的偏移量到范围结束给定的偏移量的子串。</target>
        </trans-unit>
        <trans-unit id="d5a014df4d2914afff26758db84313e7b53629c2" translate="yes" xml:space="preserve">
          <source>Returns a substring starting at the offset &lt;code&gt;start&lt;/code&gt;, and of length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">返回一个从偏移量 &lt;code&gt;start&lt;/code&gt; 开始且长度为 &lt;code&gt;len&lt;/code&gt; 的子字符串。</target>
        </trans-unit>
        <trans-unit id="6ec101f14dc34f334988903f882113db6c75107c" translate="yes" xml:space="preserve">
          <source>Returns a tuple &lt;code&gt;{day, era}&lt;/code&gt; representing the day within the era and the era number.</source>
          <target state="translated">返回一个元组 &lt;code&gt;{day, era}&lt;/code&gt; 代表该时代中的日期和时代号。</target>
        </trans-unit>
        <trans-unit id="8e67509fba3335899cfadcaef1653695ee755861" translate="yes" xml:space="preserve">
          <source>Returns a tuple &lt;code&gt;{year, era}&lt;/code&gt; representing the year within the era and the era number.</source>
          <target state="translated">返回一个元组 &lt;code&gt;{year, era}&lt;/code&gt; 代表该时代中的年份和时代编号。</target>
        </trans-unit>
        <trans-unit id="fdd9f6699ef007d5bcfc4921c7b71d74906d67f2" translate="yes" xml:space="preserve">
          <source>Returns a tuple containing the supervisor specification. This tuple can be used as the return value of the &lt;code&gt;c:init/1&lt;/code&gt; callback when implementing a module-based supervisor.</source>
          <target state="translated">返回包含主管规范的元组。在实现基于模块的管理器时，该元组可用作 &lt;code&gt;c:init/1&lt;/code&gt; 回调的返回值。</target>
        </trans-unit>
        <trans-unit id="7f0996b39345ea9e7c9060c1426d24e1a14d175c" translate="yes" xml:space="preserve">
          <source>Returns a tuple containing the value associated with the key and the updated container. &lt;code&gt;nil&lt;/code&gt; is returned for the value if the key isn't in the container.</source>
          <target state="translated">返回一个元组，其中包含与键和更新后的容器关联的值。如果键不在容器中，则返回 &lt;code&gt;nil&lt;/code&gt; 作为值。</target>
        </trans-unit>
        <trans-unit id="ff054a062909831fae54faf25f69066b049f0472" translate="yes" xml:space="preserve">
          <source>Returns a tuple of the form &lt;code&gt;{value, binding}&lt;/code&gt;, where &lt;code&gt;value&lt;/code&gt; is the value returned from evaluating &lt;code&gt;string&lt;/code&gt;. If an error occurs while evaluating &lt;code&gt;string&lt;/code&gt; an exception will be raised.</source>
          <target state="translated">返回形式为 &lt;code&gt;{value, binding}&lt;/code&gt; 的元组，其中 &lt;code&gt;value&lt;/code&gt; 是从评估 &lt;code&gt;string&lt;/code&gt; 返回的值。如果在评估 &lt;code&gt;string&lt;/code&gt; 时发生错误，将引发异常。</target>
        </trans-unit>
        <trans-unit id="9e1d2c960241a00096afd91bf252ac31507af671" translate="yes" xml:space="preserve">
          <source>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</source>
          <target state="translated">返回一个元组,其中第一个元素是映射的枚举,第二个元素是最终的累加器。</target>
        </trans-unit>
        <trans-unit id="9b9e1bdb527e70cc179683a4fe2a7521e95d2a67" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</source>
          <target state="translated">根据Erlang的项排序,返回一个包含枚举中最小和最大元素的元组。</target>
        </trans-unit>
        <trans-unit id="9289a49fc0b517d3d38226831426fdffeb900f0b" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</source>
          <target state="translated">返回一个由给定函数计算出的包含枚举中最小和最大元素的元组。</target>
        </trans-unit>
        <trans-unit id="78bc10df51b7a09f0be40994df79a6b72b67f2c3" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the new list and the old list with removed keys.</source>
          <target state="translated">返回一个包含新列表和旧列表的元组,其中包含删除的键。</target>
        </trans-unit>
        <trans-unit id="49a58596d4c32840c588fba7e77c85318bcb2968" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the new map and the old map with removed keys.</source>
          <target state="translated">返回一个包含新地图和旧地图的删除键的元组。</target>
        </trans-unit>
        <trans-unit id="ed72d4b56f51e8613ab1dfc371169fca9e518330" translate="yes" xml:space="preserve">
          <source>Returns a writable temporary directory. Searches for directories in the following order:</source>
          <target state="translated">返回一个可写的临时目录。按以下顺序搜索目录。</target>
        </trans-unit>
        <trans-unit id="e713a513acbdedf0dda43d90f08d107eb1c0c63b" translate="yes" xml:space="preserve">
          <source>Returns all children PIDs.</source>
          <target state="translated">Returns all children PIDs.</target>
        </trans-unit>
        <trans-unit id="e6a21f48135285b8b5bb30d5ad65b3b47e26f561" translate="yes" xml:space="preserve">
          <source>Returns all code points in the string.</source>
          <target state="translated">返回字符串中的所有代码点。</target>
        </trans-unit>
        <trans-unit id="e3cf44631bb390e7d2badb9d7470fae3253dc5ba" translate="yes" xml:space="preserve">
          <source>Returns all compilers.</source>
          <target state="translated">返回所有编译器。</target>
        </trans-unit>
        <trans-unit id="14b145390a9ebf308c4b373dc11333b017df30f2" translate="yes" xml:space="preserve">
          <source>Returns all functions and macros defined in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;module&lt;/code&gt; 定义的所有函数和宏。</target>
        </trans-unit>
        <trans-unit id="ad3bb32900d7c344e494107abf9c4c7326be59e8" translate="yes" xml:space="preserve">
          <source>Returns all functions defined in &lt;code&gt;module&lt;/code&gt;, according to its kind.</source>
          <target state="translated">根据类型返回 &lt;code&gt;module&lt;/code&gt; 定义的所有函数。</target>
        </trans-unit>
        <trans-unit id="b5df146a1464140be99d57b6a49844f0f5e9e584" translate="yes" xml:space="preserve">
          <source>Returns all key-value pairs for &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;app&lt;/code&gt; 的所有键值对。</target>
        </trans-unit>
        <trans-unit id="156e3a5fb38c335ce430ccbdf832347b21177bd7" translate="yes" xml:space="preserve">
          <source>Returns all key-value pairs in the process dictionary.</source>
          <target state="translated">返回过程字典中的所有键值对。</target>
        </trans-unit>
        <trans-unit id="406cf177f03a1fe2a55cb14779e3af7a09489d14" translate="yes" xml:space="preserve">
          <source>Returns all keys from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;map&lt;/code&gt; 中的所有键。</target>
        </trans-unit>
        <trans-unit id="556358f0f53235e5674d035cdcc5f6968be35f2c" translate="yes" xml:space="preserve">
          <source>Returns all keys from the keyword list.</source>
          <target state="translated">返回关键字列表中的所有键。</target>
        </trans-unit>
        <trans-unit id="6d7122282aecdbcfa075a5e668d5f2c21f2161d1" translate="yes" xml:space="preserve">
          <source>Returns all keys in the process dictionary that have the given &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">返回流程字典中具有给定 &lt;code&gt;value&lt;/code&gt; 所有键。</target>
        </trans-unit>
        <trans-unit id="042b9c023d06dd909ce950f350535dbfb0777cec" translate="yes" xml:space="preserve">
          <source>Returns all keys in the process dictionary.</source>
          <target state="translated">返回进程字典中的所有键。</target>
        </trans-unit>
        <trans-unit id="e94b9dcfc2e9dac51c4ac8484e5dfd70f3e9b33b" translate="yes" xml:space="preserve">
          <source>Returns all loaded task modules.</source>
          <target state="translated">返回所有加载的任务模块。</target>
        </trans-unit>
        <trans-unit id="71787f9010554f94575f9522f1c99c44b60cb2e4" translate="yes" xml:space="preserve">
          <source>Returns all system environment variables.</source>
          <target state="translated">返回所有系统环境变量。</target>
        </trans-unit>
        <trans-unit id="e569da60b7ca186199784958ba9d2b81bb1397d9" translate="yes" xml:space="preserve">
          <source>Returns all values from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;map&lt;/code&gt; 的所有值。</target>
        </trans-unit>
        <trans-unit id="1e7a0349730cbf3f3bafb2a0c0cb3cc28bea70d5" translate="yes" xml:space="preserve">
          <source>Returns all values from the keyword list.</source>
          <target state="translated">返回关键字列表中的所有值。</target>
        </trans-unit>
        <trans-unit id="d96004909e4ad7c64db0522497fe2d3b803021f3" translate="yes" xml:space="preserve">
          <source>Returns an almost unique reference.</source>
          <target state="translated">返回一个几乎唯一的引用。</target>
        </trans-unit>
        <trans-unit id="a1ca941f10bbc2a839f82df74e5a66de383248c6" translate="yes" xml:space="preserve">
          <source>Returns an atom representing the name of the local node. If the node is not alive, &lt;code&gt;:nonode@nohost&lt;/code&gt; is returned instead.</source>
          <target state="translated">返回表示本地节点名称的原子。如果节点不是活动的，则返回 &lt;code&gt;:nonode@nohost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bca5cf89834f191f0b7d25cb60600751e2192dc" translate="yes" xml:space="preserve">
          <source>Returns an empty keyword list, i.e. an empty list.</source>
          <target state="translated">返回一个空关键字列表,即一个空列表。</target>
        </trans-unit>
        <trans-unit id="9336405d72004e8204acc026354f638b5932365d" translate="yes" xml:space="preserve">
          <source>Returns an enumerable that splits a string on demand.</source>
          <target state="translated">返回一个按需分割字符串的枚举。</target>
        </trans-unit>
        <trans-unit id="c23eeb7a803311ef05d76bc46b75ead9502cb701" translate="yes" xml:space="preserve">
          <source>Returns an inclusive range between dates.</source>
          <target state="translated">返回日期之间的包含范围。</target>
        </trans-unit>
        <trans-unit id="36ea821a1bd58beb41a35815684e5f6dd46947c7" translate="yes" xml:space="preserve">
          <source>Returns an initial accumulator and a &quot;collector&quot; function.</source>
          <target state="translated">返回一个初始累加器和一个 &quot;收集器 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="790893bc81d3d485385a9efd616205fa2997b5ed" translate="yes" xml:space="preserve">
          <source>Returns an integer or float which is the arithmetical absolute value of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">返回一个整数或浮点数，它是 &lt;code&gt;number&lt;/code&gt; 的算术绝对值。</target>
        </trans-unit>
        <trans-unit id="5ed4feca62654761a5cba1c5468578f70dd1f1a9" translate="yes" xml:space="preserve">
          <source>Returns an integer which is the size in bits of &lt;code&gt;bitstring&lt;/code&gt;.</source>
          <target state="translated">返回一个整数，该整数是 &lt;code&gt;bitstring&lt;/code&gt; 的大小（以位为单位）。</target>
        </trans-unit>
        <trans-unit id="ff9f7b86de9e03f6280fece12d53e95bb81fce12" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;charlist&lt;/code&gt; in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">返回一个整数，其文本表示形式为base &lt;code&gt;base&lt;/code&gt; 中的 &lt;code&gt;charlist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7844d0ca3375055eb41de872777bcf4aa843366e" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;charlist&lt;/code&gt;.</source>
          <target state="translated">返回一个整数，其文本表示形式为 &lt;code&gt;charlist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f2895d4e76b96a85b5b1d6745d2f5eacc89e7d4" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;string&lt;/code&gt; in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">返回一个整数，其文本表示形式为base &lt;code&gt;base&lt;/code&gt; 中的 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9d71ba16fbf453d9081568d72974d94e2e8747e" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">返回一个整数，其文本表示形式为 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d427036e767479c0ab88861dea125a1bc02a46f" translate="yes" xml:space="preserve">
          <source>Returns and removes the first value associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">返回并删除与关键字列表中的 &lt;code&gt;key&lt;/code&gt; 关联的第一个值。</target>
        </trans-unit>
        <trans-unit id="095f100d342a14917373097117de47a712bc7df4" translate="yes" xml:space="preserve">
          <source>Returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">返回和删除与相关联的价值 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71815281c0754fe990acff24c0fb1c1b90c930ef" translate="yes" xml:space="preserve">
          <source>Returns and removes the value at the specified &lt;code&gt;index&lt;/code&gt; in the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">返回和删除指定的值 &lt;code&gt;index&lt;/code&gt; 的 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab602893bed93a1e176fdba47312a8d6bb5af3b7" translate="yes" xml:space="preserve">
          <source>Returns environment (for example, &lt;code&gt;:test&lt;/code&gt;, or &lt;code&gt;:prod&lt;/code&gt;), or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">返回环境（例如 &lt;code&gt;:test&lt;/code&gt; 或 &lt;code&gt;:prod&lt;/code&gt; ）或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b69fcc9982e69bd0bf87f18dd2d92acb6b8e942" translate="yes" xml:space="preserve">
          <source>Returns how many days there are in the given year-month.</source>
          <target state="translated">返回给定年月中的天数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
