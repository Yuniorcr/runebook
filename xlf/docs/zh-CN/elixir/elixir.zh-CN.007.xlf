<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="1ac07c5c5d769c317e4ee149161ad79dd547886a" translate="yes" xml:space="preserve">
          <source>Function specifications</source>
          <target state="translated">功能规格</target>
        </trans-unit>
        <trans-unit id="b1d1d233c6e9151086e11b68520f3c88ddfbfd71" translate="yes" xml:space="preserve">
          <source>FunctionClauseError</source>
          <target state="translated">FunctionClauseError</target>
        </trans-unit>
        <trans-unit id="59d46903ce38ffaa562b785d06c23f1fe1bd7e8e" translate="yes" xml:space="preserve">
          <source>FunctionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">FunctionClauseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92264e6f77844330da044c87077edfa8088c62f8" translate="yes" xml:space="preserve">
          <source>Functionality to capture IO for testing.</source>
          <target state="translated">采集IO的功能,用于测试。</target>
        </trans-unit>
        <trans-unit id="cd8664fa33698f4f620c47642dfd3e7413d9d1ec" translate="yes" xml:space="preserve">
          <source>Functionality to capture logs for testing.</source>
          <target state="translated">采集测试用日志的功能。</target>
        </trans-unit>
        <trans-unit id="981f29fc45464a2117ff8d90e767ed44d91b4bb6" translate="yes" xml:space="preserve">
          <source>Functionality to render ANSI escape sequences.</source>
          <target state="translated">具有渲染ANSI转义序列的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="e331cf0e4275fe631ca417060a2f8f10e15a256d" translate="yes" xml:space="preserve">
          <source>Functions as keys</source>
          <target state="translated">功能键</target>
        </trans-unit>
        <trans-unit id="89eb4f89d38ca8beda2b5a23ae39ddc79a7e20dc" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">用&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;定义的函数是公共的，可以从定义它们的模块外部调用，就好像它们是使用&lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt;定义的一样。因此，&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;与扩展当前模块的公共API有关。如果要在不使用模块的完整模块名称的情况下调用另一个模块中定义的函数，则可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;来缩短模块名称，或者使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;来完全在不使用模块名称的情况下调用该函数。</target>
        </trans-unit>
        <trans-unit id="5b08dda4461297f97d2d935f4b6c312c57879282" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">用&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;定义的函数是公共的，可以从定义它们的模块外部调用，就好像它们是使用&lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt;定义的一样。因此，&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt;与扩展当前模块的公共API有关。如果要在不使用其完整模块名的情况下调用另一个模块中定义的函数，请使用&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;缩短模块名，或使用&lt;a href=&quot;kernel.specialforms#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;来在不使用模块名的情况下调用该函数。</target>
        </trans-unit>
        <trans-unit id="5339f05867719070151c5f9212ec9691343c3dfd" translate="yes" xml:space="preserve">
          <source>Functions for creating and composing streams.</source>
          <target state="translated">用于创建和组成流的功能。</target>
        </trans-unit>
        <trans-unit id="a92a126ef94a3c0fc6addeadb2500f9ae863a5be" translate="yes" xml:space="preserve">
          <source>Functions for interacting with the external world through ports.</source>
          <target state="translated">通过端口与外部世界交互的功能。</target>
        </trans-unit>
        <trans-unit id="595e959d0a21e0d09abbd2c4fba3e39601ca613b" translate="yes" xml:space="preserve">
          <source>Functions for parsing and matching versions against requirements.</source>
          <target state="translated">用于解析和匹配版本与需求的函数。</target>
        </trans-unit>
        <trans-unit id="3f33806c59ce33f63b6d6eac23d2c5c308d0f02e" translate="yes" xml:space="preserve">
          <source>Functions for parsing command line arguments.</source>
          <target state="translated">用于解析命令行参数的函数。</target>
        </trans-unit>
        <trans-unit id="be344dfaebcc716a7113914fb8d65d65aad9cdfb" translate="yes" xml:space="preserve">
          <source>Functions for working with floating-point numbers.</source>
          <target state="translated">用于处理浮点数的函数。</target>
        </trans-unit>
        <trans-unit id="4581129055260f253b0f9a10ce8940c3ae082007" translate="yes" xml:space="preserve">
          <source>Functions for working with integers.</source>
          <target state="translated">用于处理整数的函数。</target>
        </trans-unit>
        <trans-unit id="ac038c429b16ac4da6a1c54de055fde121e86832" translate="yes" xml:space="preserve">
          <source>Functions for working with tuples.</source>
          <target state="translated">用于处理元组的函数。</target>
        </trans-unit>
        <trans-unit id="b012c35607b405f40246b484e5594c562e5fd7b1" translate="yes" xml:space="preserve">
          <source>Functions handling input/output (IO).</source>
          <target state="translated">处理输入/输出(IO)的函数。</target>
        </trans-unit>
        <trans-unit id="120d9dcde7287a0528aec2f3d5f7e2e3f5cd376a" translate="yes" xml:space="preserve">
          <source>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. &lt;code&gt;round/1&lt;/code&gt; identifies the function which is named &lt;code&gt;round&lt;/code&gt; and takes &lt;code&gt;1&lt;/code&gt; argument, whereas &lt;code&gt;round/2&lt;/code&gt; identifies a different (nonexistent) function with the same name but with an arity of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Elixir中的功能通过名称和名称进行标识。函数的多样性描述了函数采用的参数数量。从这一点开始，我们将在整个文档中使用函数名称及其辅助性来描述函数。 &lt;code&gt;round/1&lt;/code&gt; 标识名为 &lt;code&gt;round&lt;/code&gt; 并带有 &lt;code&gt;1&lt;/code&gt; 个参数的函数，而 &lt;code&gt;round/2&lt;/code&gt; 标识具有相同名称但Arity为 &lt;code&gt;2&lt;/code&gt; 的另一个（不存在）函数。</target>
        </trans-unit>
        <trans-unit id="25a36a956214e3716b0faa690578d88a7316d2d1" translate="yes" xml:space="preserve">
          <source>Functions may be called when defining a module attribute, e.g.</source>
          <target state="translated">当定义一个模块属性时,可以调用函数,如</target>
        </trans-unit>
        <trans-unit id="18780274d7513230569a4133845253288a279bc6" translate="yes" xml:space="preserve">
          <source>Functions related to VM nodes.</source>
          <target state="translated">与VM节点相关的功能。</target>
        </trans-unit>
        <trans-unit id="2ecc259041cce0328acd0d9abf2a78e6d378235f" translate="yes" xml:space="preserve">
          <source>Functions that return a boolean are named with a trailing question mark.</source>
          <target state="translated">返回布尔函数的函数用尾部的问号命名。</target>
        </trans-unit>
        <trans-unit id="3abac8dc3938de4ae338c2914b66903b6d6216cf" translate="yes" xml:space="preserve">
          <source>Functions that work on (linked) lists.</source>
          <target state="translated">在(链接)列表上工作的函数。</target>
        </trans-unit>
        <trans-unit id="d6d5cb54b94547b27cdb53ea8f156b69b0e891a7" translate="yes" xml:space="preserve">
          <source>Functions that work on sets.</source>
          <target state="translated">在套路上起作用的功能。</target>
        </trans-unit>
        <trans-unit id="c2171b2fcb9b756c41905c9675c92ab582aa67f4" translate="yes" xml:space="preserve">
          <source>Functions to format throw/catch/exit and exceptions.</source>
          <target state="translated">用于格式化抛出/捕获/退出和异常的函数。</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">更多信息</target>
        </trans-unit>
        <trans-unit id="5d853e3f857a73da9a233be532bd545c49917d50" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">此外，&lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;可能由于以下POSIX原因之一而失败：</target>
        </trans-unit>
        <trans-unit id="287db3c111ae0a4e9243da5209d0af176dba1c2f" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此外，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;允许Erlang发送的消息通过翻译器转换为Elixir格式。可以随时使用&lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; API添加翻译器。检查&lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt;以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="6d6208ba2074c10f21b8ca78cfba95b5238a4367" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;logger.translator&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此外，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;允许Erlang发送的消息通过翻译器转换为Elixir格式。可以随时使用&lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; API 添加翻译器。检查&lt;a href=&quot;logger.translator&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f484c5ceae64ae91667e53e8fabec77fcc0eab91" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">此外，&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;可能由于以下POSIX原因之一而失败：</target>
        </trans-unit>
        <trans-unit id="186edc3e57a9d838cd0ada8549562af323cf60a5" translate="yes" xml:space="preserve">
          <source>Furthermore, a &lt;code&gt;:suspend&lt;/code&gt; call must always be followed by another call, eventually halting or continuing until the end.</source>
          <target state="translated">此外， &lt;code&gt;:suspend&lt;/code&gt; 调用必须始终跟随另一个调用，最终停止或继续直到结束。</target>
        </trans-unit>
        <trans-unit id="c260bcd5ae1bdde9983d663eb92d5fcd82188b68" translate="yes" xml:space="preserve">
          <source>Furthermore, all applications listed in the &lt;code&gt;:applications&lt;/code&gt; key must be explicitly started before this application is. If not, &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; is returned, where &lt;code&gt;app&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">此外， &lt;code&gt;:applications&lt;/code&gt; 项中列出的所有应用程序必须在此应用程序之前被明确启动。如果不是，则返回 &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; ，其中 &lt;code&gt;app&lt;/code&gt; 是缺少的应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="26e72ab288d2e99c66734f21d67d33280ac839df" translate="yes" xml:space="preserve">
          <source>Furthermore, backends can be configured via the &lt;a href=&quot;#configure_backend/2&quot;&gt;&lt;code&gt;configure_backend/2&lt;/code&gt;&lt;/a&gt; function which requires event handlers to handle calls of the following format:</source>
          <target state="translated">此外，可以通过&lt;a href=&quot;#configure_backend/2&quot;&gt; &lt;code&gt;configure_backend/2&lt;/code&gt; &lt;/a&gt;函数配置后端，该函数需要事件处理程序来处理以下格式的调用：</target>
        </trans-unit>
        <trans-unit id="03045b903b2a4efd2fad95378e0e7416cbdc8700" translate="yes" xml:space="preserve">
          <source>Furthermore, because the state returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.</source>
          <target state="translated">此外，由于可以将&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的状态写入基于文本的配置文件，因此应仅将其限制为简单的数据类型，例如整数，字符串，原子，元组，映射和列表。PID，引用和函数等条目无法序列化。</target>
        </trans-unit>
        <trans-unit id="e12a025bc34e52444d91865482fafd1b4bcb1476" translate="yes" xml:space="preserve">
          <source>Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors:</source>
          <target state="translated">另外,如果在调度时,由于注册不好,出现了故障,调度总是会失败,注册的流程也不会被通知。因此,我们至少要确保我们对这些错误进行包装和报告。</target>
        </trans-unit>
        <trans-unit id="3528255d6bac578fd573ffc86dde48159bf06389" translate="yes" xml:space="preserve">
          <source>Furthermore, metadata can be set per process with &lt;a href=&quot;#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此外，可以使用&lt;a href=&quot;#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;为每个进程设置元数据。</target>
        </trans-unit>
        <trans-unit id="42529d32de08bd15f27eb4312be9cc48b68c13b2" translate="yes" xml:space="preserve">
          <source>Furthermore, they are composable because we can pipe many stream operations:</source>
          <target state="translated">此外,它们是可以组合的,因为我们可以管很多流操作。</target>
        </trans-unit>
        <trans-unit id="3381a6c76f92b142faec11ca6cffe41f63f7d1f2" translate="yes" xml:space="preserve">
          <source>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;&amp;eacute;&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points):</source>
          <target state="translated">此外，该模块还提出了字素簇的概念（从现在开始称为字素）。字素可以由多个代码点组成，读者可以将其视为一个字符。例如，&amp;ldquo;&amp;eacute;&amp;rdquo;可以表示为单个&amp;ldquo; e与尖音&amp;rdquo;代码点，也可以表示为字母&amp;ldquo; e&amp;rdquo;，后跟&amp;ldquo;组合重音符号&amp;rdquo;（两个代码点）：</target>
        </trans-unit>
        <trans-unit id="e25c00dc3897c6883dc4fe0f27096add3cc899e4" translate="yes" xml:space="preserve">
          <source>Furthermore, while &lt;code&gt;vm.args&lt;/code&gt; is static, you can use &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to dynamically set VM options. For example, if you want to make sure the Erlang Distribution listens only on a given port known at runtime, you can set the following:</source>
          <target state="translated">此外，虽然 &lt;code&gt;vm.args&lt;/code&gt; 是静态的，但您可以使用 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 动态设置VM选项。例如，如果要确保Erlang发行版仅在运行时已知的给定端口上侦听，则可以设置以下内容：</target>
        </trans-unit>
        <trans-unit id="5c727a56b05e846df29f24d1daf2419df88964fa" translate="yes" xml:space="preserve">
          <source>Furthermore, with &lt;code&gt;@impl&lt;/code&gt; you can also make sure that you are implementing the &lt;strong&gt;correct&lt;/strong&gt; callbacks from the given behaviour in an explicit manner. For example, the following parser implements both &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt;, however thanks to a typo, &lt;code&gt;BADParser&lt;/code&gt; is implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;.</source>
          <target state="translated">此外，使用 &lt;code&gt;@impl&lt;/code&gt; 还可以确保以显式方式从给定的行为实现&lt;strong&gt;正确的&lt;/strong&gt;回调。例如，以下解析器同时实现了 &lt;code&gt;parse&lt;/code&gt; 和 &lt;code&gt;extensions&lt;/code&gt; ，但是由于输入错误， &lt;code&gt;BADParser&lt;/code&gt; 实现了 &lt;code&gt;parse/0&lt;/code&gt; 而不是 &lt;code&gt;parse/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae57bdba0f435d58b5575a45dc3b5fb6eb566cf8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let&amp;rsquo;s make the test fail on purpose and see what happens.</source>
          <target state="translated">此外，您可以看到ExUnit为每个成功的测试打印一个点，并且也会自动将测试随机化。让我们故意使测试失败，看看会发生什么。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="26e2a4f823a98eca42ddcd53fd08f4fc5631d231" translate="yes" xml:space="preserve">
          <source>GenEvent</source>
          <target state="translated">GenEvent</target>
        </trans-unit>
        <trans-unit id="52f5451d0a005c032b5bd9e0f39e525431bee3e4" translate="yes" xml:space="preserve">
          <source>GenEvent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenEvent &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f1f7460d4b0df6c99ec51f3b8a78fab0ab241364" translate="yes" xml:space="preserve">
          <source>GenServer</source>
          <target state="translated">GenServer</target>
        </trans-unit>
        <trans-unit id="c41a8053324929c4122055404c6f497f28026d3e" translate="yes" xml:space="preserve">
          <source>GenServer - Elixir's Getting Started Guide</source>
          <target state="translated">GenServer-Elixir入门指南</target>
        </trans-unit>
        <trans-unit id="eca82733cdfcb3649b72cda06a30a922552032d8" translate="yes" xml:space="preserve">
          <source>GenServer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenServer &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6b938fbce44ec15ef7cf28460d3d3a0b7b6e45c7" translate="yes" xml:space="preserve">
          <source>GenServer callbacks</source>
          <target state="translated">GenServer回调</target>
        </trans-unit>
        <trans-unit id="60a02fde0f842f29309800909cd00e720e3567d0" translate="yes" xml:space="preserve">
          <source>GenServers, as &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;special processes&lt;/a&gt;, can be debugged using the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt;. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</source>
          <target state="translated">GenServers作为&lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;特殊进程&lt;/a&gt;，可以使用&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块&lt;/a&gt;进行调试。通过各种挂钩，该模块使开发人员可以对流程的状态进行自省，并跟踪流程执行期间发生的系统事件，例如接收到的消息，发送的答复和状态更改。</target>
        </trans-unit>
        <trans-unit id="8e2323fdcd5a3410a0abfe44a2176b41a6905683" translate="yes" xml:space="preserve">
          <source>GenStage</source>
          <target state="translated">GenStage</target>
        </trans-unit>
        <trans-unit id="92fde6e5cdcf695869dd7ece8642757211b43eff" translate="yes" xml:space="preserve">
          <source>General operators</source>
          <target state="translated">一般操作员</target>
        </trans-unit>
        <trans-unit id="26811be9b4758ef85d12185318d245ac23863706" translate="yes" xml:space="preserve">
          <source>Generally speaking, filenames follow the &lt;code&gt;snake_case&lt;/code&gt; convention of the module they define. For example, &lt;code&gt;MyApp&lt;/code&gt; should be defined inside the &lt;code&gt;my_app.ex&lt;/code&gt; file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.</source>
          <target state="translated">一般来说，文件名遵循它们定义的模块的 &lt;code&gt;snake_case&lt;/code&gt; 约定。例如，应在 &lt;code&gt;my_app.ex&lt;/code&gt; 文件中定义 &lt;code&gt;MyApp&lt;/code&gt; 。但是，这只是一个约定。在一天结束时，可以使用任何文件名，因为它们不会以任何方式影响编译后的代码。</target>
        </trans-unit>
        <trans-unit id="c4e59b7746a9b324c29c497d15613e18d32b2ec0" translate="yes" xml:space="preserve">
          <source>Generally speaking, the VM provides three time measurements:</source>
          <target state="translated">一般来说,虚拟机提供三种时间测量。</target>
        </trans-unit>
        <trans-unit id="ca8af8a9659e59f74154d217723284164924d905" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following files are available for customizing and configuring the running system:</source>
          <target state="translated">一般来说,以下文件可以用来定制和配置运行系统。</target>
        </trans-unit>
        <trans-unit id="3853e87a8cfcd1a2826b60877e31dac6ddc354ee" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following module:</source>
          <target state="translated">一般来说,以下模块:</target>
        </trans-unit>
        <trans-unit id="061ef8a9ec07ec601a5d20eb32a7f1c44a8e42be" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt;为给定数量的必需参数变量生成AST节点。</target>
        </trans-unit>
        <trans-unit id="bc78aa7ca2c1bb33572b17a7f6a38317ada6e607" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;macro#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;macro#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt;为给定数量的必需参数变量生成AST节点。</target>
        </trans-unit>
        <trans-unit id="7914afeb7e94d7ae59d1fa355821ee7cf902a612" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the file contents.</source>
          <target state="translated">从文件内容中生成一个函数定义。</target>
        </trans-unit>
        <trans-unit id="6f28a47721aec6c56f1e4f3f4b046459fb2d421f" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the string.</source>
          <target state="translated">从字符串中生成一个函数定义。</target>
        </trans-unit>
        <trans-unit id="3ed0a940ace5bee6a5a44c402162f201a0b4df48" translate="yes" xml:space="preserve">
          <source>Generates a macro suitable for use in guard expressions.</source>
          <target state="translated">生成一个适合在防护表达式中使用的宏。</target>
        </trans-unit>
        <trans-unit id="f89a805aedce9f9ff7961406995dc39283b2ba6f" translate="yes" xml:space="preserve">
          <source>Generates a private macro suitable for use in guard expressions.</source>
          <target state="translated">生成一个适合在防护表达式中使用的私有宏。</target>
        </trans-unit>
        <trans-unit id="d022a23ab156502d4cd22511016df2db248a08d8" translate="yes" xml:space="preserve">
          <source>Generates an AST node representing the variable given by the atoms &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">生成一个AST节点，表示由 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;context&lt;/code&gt; 原子给定的变量。</target>
        </trans-unit>
        <trans-unit id="39399ecc6eafac75945962b0e75d0ddca1662821" translate="yes" xml:space="preserve">
          <source>Generates and returns an integer that is unique in the current runtime instance.</source>
          <target state="translated">生成并返回一个在当前运行时实例中唯一的整数。</target>
        </trans-unit>
        <trans-unit id="1ad2ad1cc4377f21a03bdbb978029bcfeb4b2be2" translate="yes" xml:space="preserve">
          <source>Generates sample files for releases.</source>
          <target state="translated">生成用于发布的样本文件。</target>
        </trans-unit>
        <trans-unit id="5539e5b1ece965094ab6defc81d9ab18e23afa6b" translate="yes" xml:space="preserve">
          <source>Generator expressions also support pattern matching on their left-hand side; all non-matching patterns are &lt;em&gt;ignored&lt;/em&gt;. Imagine that, instead of a range, we have a keyword list where the key is the atom &lt;code&gt;:good&lt;/code&gt; or &lt;code&gt;:bad&lt;/code&gt; and we only want to compute the square of the &lt;code&gt;:good&lt;/code&gt; values:</source>
          <target state="translated">生成器表达式的左侧也支持模式匹配；所有不匹配的模式都将&lt;em&gt;被忽略&lt;/em&gt;。想象一下，我们有一个关键字列表，而不是一个范围，其中关键字是原子 &lt;code&gt;:good&lt;/code&gt; 或 &lt;code&gt;:bad&lt;/code&gt; ,而我们只想计算 &lt;code&gt;:good&lt;/code&gt; 值的平方：</target>
        </trans-unit>
        <trans-unit id="191fe63ca19d74852f4f8e0438c53a7c9f2fad58" translate="yes" xml:space="preserve">
          <source>Generators and filters</source>
          <target state="translated">发电机和过滤器</target>
        </trans-unit>
        <trans-unit id="b0f6dc9f4ecd590c4554fad6675925837bd4c03b" translate="yes" xml:space="preserve">
          <source>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">生成器还可以用于过滤，因为它会删除与 &lt;code&gt;&amp;lt;-&lt;/code&gt; 左侧的模式不匹配的任何值：</target>
        </trans-unit>
        <trans-unit id="6a24751485eed378e568d03e0c111b00b1ca2106" translate="yes" xml:space="preserve">
          <source>Generic API for dictionaries.</source>
          <target state="translated">字典的通用API。</target>
        </trans-unit>
        <trans-unit id="f74ee225a82269c197985a3a933abeea994529f8" translate="yes" xml:space="preserve">
          <source>Generic API for sets.</source>
          <target state="translated">集的通用API。</target>
        </trans-unit>
        <trans-unit id="342a929853c668da7bea5b8678d33654ddad6c44" translate="yes" xml:space="preserve">
          <source>Get all keys in the registry.</source>
          <target state="translated">获取注册表中的所有键。</target>
        </trans-unit>
        <trans-unit id="15d4328951079f5b0c0d666980c03b21bfcda99d" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;filename&lt;/code&gt; 并使用 &lt;code&gt;bindings&lt;/code&gt; 评估值。</target>
        </trans-unit>
        <trans-unit id="e09423213d70047599b0fbcfb55a1d216ed0bceb" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">获取 &lt;code&gt;filename&lt;/code&gt; 并生成带引号的表达式，该表达式可由Elixir评估或编译为函数。</target>
        </trans-unit>
        <trans-unit id="11ce297c5b4ae23b4a6d01356ff4f29ad16e92ef" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from IO device &lt;code&gt;:stdio&lt;/code&gt;.</source>
          <target state="translated">从IO设备 &lt;code&gt;:stdio&lt;/code&gt; 获取多个字节。</target>
        </trans-unit>
        <trans-unit id="aef78a3cc35c0eec4a213bb06eb18783344f5a30" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">从IO &lt;code&gt;device&lt;/code&gt; 获取多个字节。</target>
        </trans-unit>
        <trans-unit id="464c10475e938f50f88715c59eebddca575584e5" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">获取字符串 &lt;code&gt;source&lt;/code&gt; 并使用 &lt;code&gt;bindings&lt;/code&gt; 评估值。</target>
        </trans-unit>
        <trans-unit id="dce9c015f4c3caacfed76da20580dc567b349125" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">获取字符串 &lt;code&gt;source&lt;/code&gt; 并生成带引号的表达式，该表达式可以由Elixir评估或编译为函数。</target>
        </trans-unit>
        <trans-unit id="77a47a00f7c2dc7431f1fd26f1f6a07c0721fc92" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested data structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">获取值并通过给定 &lt;code&gt;path&lt;/code&gt; 更新嵌套的数据结构。</target>
        </trans-unit>
        <trans-unit id="197bee8d14aabe7ecd2c0b8cae48772622a49701" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested structure.</source>
          <target state="translated">获取一个值并更新一个嵌套结构。</target>
        </trans-unit>
        <trans-unit id="24fc43c308b364700a4a6b0c3e1ab5a6e0a34321" translate="yes" xml:space="preserve">
          <source>Gets a value from a nested structure.</source>
          <target state="translated">从嵌套结构中获取一个值。</target>
        </trans-unit>
        <trans-unit id="d58fdd9b7ac3d94d847bf7aa9396d3dd171627fa" translate="yes" xml:space="preserve">
          <source>Gets all compilation options from the code server.</source>
          <target state="translated">从代码服务器获取所有编译选项。</target>
        </trans-unit>
        <trans-unit id="9024c31b7473f5071a19da2642c254ca64dc5dcc" translate="yes" xml:space="preserve">
          <source>Gets all out of date dependencies, i.e. dependencies that are not available or have an invalid lock.</source>
          <target state="translated">获取所有过期的依赖关系,即不可用或锁无效的依赖关系。</target>
        </trans-unit>
        <trans-unit id="234783729be10591273a98e34996adf814d0af2b" translate="yes" xml:space="preserve">
          <source>Gets all values for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 所有值。</target>
        </trans-unit>
        <trans-unit id="337ee14d7455079870c96913a5344151625e3a44" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数获取一个代理值。</target>
        </trans-unit>
        <trans-unit id="cc4728d1ab03bf9e6b17772b1edd930d1db3e60f" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given function.</source>
          <target state="translated">通过给定的函数获得一个代理值。</target>
        </trans-unit>
        <trans-unit id="7ccc56cd7cf9a38cdbce42e3b62827d91b072aca" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given anonymous function.</source>
          <target state="translated">通过给定的匿名函数在一次操作中获取并更新代理状态。</target>
        </trans-unit>
        <trans-unit id="8e2c80c38d6dbae8b378d7ea7441399c6dccc722" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given function.</source>
          <target state="translated">通过给定的函数在一次操作中获取并更新代理状态。</target>
        </trans-unit>
        <trans-unit id="096ecee5005ebff9401bca63004bd1e4271d321f" translate="yes" xml:space="preserve">
          <source>Gets and updates the given key in a &lt;code&gt;container&lt;/code&gt; (a map, a keyword list, a struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取并更新 &lt;code&gt;container&lt;/code&gt; 的给定键（映射，关键字列表，实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的结构）。</target>
        </trans-unit>
        <trans-unit id="3045c9e659f40b430ef7ec7c9aeaf689166b9794" translate="yes" xml:space="preserve">
          <source>Gets logging level for given module.</source>
          <target state="translated">获取指定模块的日志级别。</target>
        </trans-unit>
        <trans-unit id="87f10d7ccf1593e9cf40f6046fb73ed64260d10f" translate="yes" xml:space="preserve">
          <source>Gets preferred CLI environment for the task.</source>
          <target state="translated">获取任务的首选CLI环境。</target>
        </trans-unit>
        <trans-unit id="7ae776c4b4f195b1f36b2be173094733049a81b3" translate="yes" xml:space="preserve">
          <source>Gets the application for the given module.</source>
          <target state="translated">获取指定模块的应用程序。</target>
        </trans-unit>
        <trans-unit id="a3186207a243a3a8619e9edb98a5c2ef194e1cbc" translate="yes" xml:space="preserve">
          <source>Gets the compilation options from the code server.</source>
          <target state="translated">从代码服务器获取编译选项。</target>
        </trans-unit>
        <trans-unit id="224e4a732cfad5d058a4b2c327797e2a8a3c70d9" translate="yes" xml:space="preserve">
          <source>Gets the current time zone database.</source>
          <target state="translated">获取当前时区数据库。</target>
        </trans-unit>
        <trans-unit id="1f02096a4a7d41ef362ad56dd8a049be60b3048f" translate="yes" xml:space="preserve">
          <source>Gets the current working directory.</source>
          <target state="translated">获取当前工作目录。</target>
        </trans-unit>
        <trans-unit id="8890fe17865bc33bcf4596b3f99ac374608009ec" translate="yes" xml:space="preserve">
          <source>Gets the directory for app.</source>
          <target state="translated">获取app的目录。</target>
        </trans-unit>
        <trans-unit id="a0d384aa0e95a00ba787ac060a94eb0ed4d124ec" translate="yes" xml:space="preserve">
          <source>Gets the element at the zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;tuple&lt;/code&gt; 中从零开始的 &lt;code&gt;index&lt;/code&gt; 处获取元素。</target>
        </trans-unit>
        <trans-unit id="ff598d3e96b472f599f3428af98b3592d274ed04" translate="yes" xml:space="preserve">
          <source>Gets the given attribute from a module.</source>
          <target state="translated">从模块中获取给定属性。</target>
        </trans-unit>
        <trans-unit id="c8c63585e58950af32a8c183dc234c637dbaf32b" translate="yes" xml:space="preserve">
          <source>Gets the list of requirements for the given task.</source>
          <target state="translated">获取指定任务的需求列表。</target>
        </trans-unit>
        <trans-unit id="d86f7fa0e05aedae7d11fde1051d7047e16a9a64" translate="yes" xml:space="preserve">
          <source>Gets the message for an &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">获取有关 &lt;code&gt;exception&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="d01b62b32cf43c3c1a84005842e75a1a8e58e56a" translate="yes" xml:space="preserve">
          <source>Gets the moduledoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">获取给定任务 &lt;code&gt;module&lt;/code&gt; 的moduledoc 。</target>
        </trans-unit>
        <trans-unit id="b0dee9f2cb9d3796fb7a48d547b0b2fb9dd7e266" translate="yes" xml:space="preserve">
          <source>Gets the representation of any expression.</source>
          <target state="translated">获取任何表达式的表示。</target>
        </trans-unit>
        <trans-unit id="aacf11051abfff1af3276a82387ff290a1040ef2" translate="yes" xml:space="preserve">
          <source>Gets the shortdoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">获取给定任务 &lt;code&gt;module&lt;/code&gt; 的shortdoc 。</target>
        </trans-unit>
        <trans-unit id="985fa8a31c64d1abf929750e6b62fcffb66d5d21" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">获取特定的价值 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2670bc6c3a1d135ba35e9b1dd103fad35687d05" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">获取特定 &lt;code&gt;key&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="cd6a6dd9113df059c87999c56f37603a31759691" translate="yes" xml:space="preserve">
          <source>Gets the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">获取容器中给定键的值（实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="8bbd7b83737713a8cdf97c7e1c36926c053390c6" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass.</source>
          <target state="translated">一 &lt;code&gt;key&lt;/code&gt; 获取键值并进行更新。</target>
        </trans-unit>
        <trans-unit id="fb3ccba9209e0ea1faa8f2431f64136954cd5182" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">一 &lt;code&gt;key&lt;/code&gt; 获取键值并进行更新。如果没有 &lt;code&gt;key&lt;/code&gt; ，则引发。</target>
        </trans-unit>
        <trans-unit id="eb0a567720e720098dfad63e9f3f00ec9b4e381f" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;key&lt;/code&gt; 获取值并更新它。如果没有 &lt;code&gt;key&lt;/code&gt; ，则引发。</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="efe79cf11081ba631fe2c7b862ea12b5382475d7" translate="yes" xml:space="preserve">
          <source>Getting started guide</source>
          <target state="translated">入门指南</target>
        </trans-unit>
        <trans-unit id="621916a4cc49b2e7a0bda3364f0574a16aa3088a" translate="yes" xml:space="preserve">
          <source>Getting the head or the tail of an empty list throws an error:</source>
          <target state="translated">获取空列表的头或尾会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="e8fbc4cd9319e626e1ccf7f2fcd4c822c8a5bcbe" translate="yes" xml:space="preserve">
          <source>Git options (&lt;code&gt;:git&lt;/code&gt;)</source>
          <target state="translated">Git选项（ &lt;code&gt;:git&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="37a8f2d730b24d981ab8fef7024613f2ad9ff494" translate="yes" xml:space="preserve">
          <source>Given a query string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt;, this function inserts each key-value pair in the query string as one entry in the given &lt;code&gt;map&lt;/code&gt;. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</source>
          <target state="translated">给定形式为 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 的查询字符串，此函数将查询字符串中的每个键值对作为给定 &lt;code&gt;map&lt;/code&gt; 中的一个条目插入。结果映射中的键和值将是二进制的。键和值将转义百分号。</target>
        </trans-unit>
        <trans-unit id="681fb9c4d5bed925cb73d7a24ad5b09e42d58e91" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements right before element &lt;code&gt;start_index&lt;/code&gt;, then takes &lt;code&gt;amount&lt;/code&gt; of elements, returning as many elements as possible if there are not enough elements.</source>
          <target state="translated">给定一个 &lt;code&gt;enumerable&lt;/code&gt; ，它会在元素 &lt;code&gt;start_index&lt;/code&gt; 之前放下元素，然后获取元素 &lt;code&gt;amount&lt;/code&gt; ，如果没有足够的元素，则返回尽可能多的元素。</target>
        </trans-unit>
        <trans-unit id="9abc0837abc465b4295e2cadea49184fb4cb4c6a" translate="yes" xml:space="preserve">
          <source>Given an enumerable of enumerables, concatenates the &lt;code&gt;enumerables&lt;/code&gt; into a single list.</source>
          <target state="translated">给定可枚举的枚举，将 &lt;code&gt;enumerables&lt;/code&gt; 枚举串联到单个列表中。</target>
        </trans-unit>
        <trans-unit id="bae6dae6fe4dd518a111019522e41b9338d8da6a" translate="yes" xml:space="preserve">
          <source>Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">给定字符列表表示为整数列表，也可以使用列表串联运算符（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;++&lt;/code&gt; &lt;/a&gt;）对字符列表执行前缀匹配：</target>
        </trans-unit>
        <trans-unit id="318c3f40bcb691337e3daedb3433d603c4f8eada" translate="yes" xml:space="preserve">
          <source>Given items in an async stream are processed concurrently, doing &lt;code&gt;async_stream&lt;/code&gt; followed by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt;&lt;code&gt;Enum.take/2&lt;/code&gt;&lt;/a&gt; may cause more items than requested to be processed. Let's see an example:</source>
          <target state="translated">给定异步流中的项目并发处理，在执行 &lt;code&gt;async_stream&lt;/code&gt; 和&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt; &lt;code&gt;Enum.take/2&lt;/code&gt; 之后&lt;/a&gt;可能会导致处理的项目多于请求的数量。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="6c7afd283b9c25ebdc6e3a55a4b68a33a103e346" translate="yes" xml:space="preserve">
          <source>Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</source>
          <target state="translated">鉴于排序没有保证,也不建议在关键词列表上进行模式匹配。例如,一个函数如:</target>
        </trans-unit>
        <trans-unit id="b078a81a2e280f99fedc2be9c6836b96581c1c0d" translate="yes" xml:space="preserve">
          <source>Given that strings are binaries, we can also pattern match on strings:</source>
          <target state="translated">鉴于字符串是二进制的,我们也可以对字符串进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="f3677630682772650b101e7db35f800ba5311f07" translate="yes" xml:space="preserve">
          <source>Given the anonymous function:</source>
          <target state="translated">鉴于匿名函数:</target>
        </trans-unit>
        <trans-unit id="36db5dd9f19115507b73ab3e8430b31b4965279c" translate="yes" xml:space="preserve">
          <source>Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not.</source>
          <target state="translated">鉴于该函数会停止编译,请谨慎使用。特别是避免用它来猜测系统中的哪些模块。过度使用这个函数也会导致死锁,即两个模块同时检查另一个模块是否被编译。这将返回一个特定的不可用的错误代码,我们无法成功验证一个模块是否可用。</target>
        </trans-unit>
        <trans-unit id="41535529b54e3895b904cb50fa535652b69f1b5f" translate="yes" xml:space="preserve">
          <source>Given this is the default calendar used by Elixir, it has one difference compared to the ISO8601 specification in that it allows a whitespace instead of &lt;code&gt;T&lt;/code&gt; as a seperator between date and times both when parsing and formatting. Strict formatting can be done by using the &lt;code&gt;to_iso8601&lt;/code&gt; found in &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">鉴于这是Elixir使用的默认日历，因此与ISO8601规范相比，它有一个区别，即在解析和格式化时，它允许在日期和时间之间使用空格而不是 &lt;code&gt;T&lt;/code&gt; 作为分隔符。严格的格式可以通过使用来完成 &lt;code&gt;to_iso8601&lt;/code&gt; 中发现的&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd1d5229cdbf0e79ed32d47a41c7e0424cb85df8" translate="yes" xml:space="preserve">
          <source>Given three vertices, find the shortest path from the first to the last.</source>
          <target state="translated">给定三个顶点,找出从第一个顶点到最后一个顶点的最短路径。</target>
        </trans-unit>
        <trans-unit id="6e14f8c349b7ea44c21dc9a2bb0f69f3be68850a" translate="yes" xml:space="preserve">
          <source>Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.</source>
          <target state="translated">给出路径很有用,可以让Elixir知道,在一个大型配置中,只有某些路径是依赖于编译时的。</target>
        </trans-unit>
        <trans-unit id="eb698f945d96926994811a109269c63fcc2c2588" translate="yes" xml:space="preserve">
          <source>Giving an argument that does not match any of the clauses raises an error.</source>
          <target state="translated">给出一个不符合任何一个子句的论点会引起错误。</target>
        </trans-unit>
        <trans-unit id="6962fecddec56252c7eb488f5a99ecedf3c0d3ff" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting a &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; given by &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">&lt;code&gt;doc2&lt;/code&gt; 两个文档（ &lt;code&gt;doc1&lt;/code&gt; 和doc2），在它们之间插入由 &lt;code&gt;break_string&lt;/code&gt; 给出的&lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a76459e82605f9a2f2ab9a4295c080bd4d42cf0" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting the given break &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">粘贴两个文档（ &lt;code&gt;doc1&lt;/code&gt; 和 &lt;code&gt;doc2&lt;/code&gt; ），在它们之间插入给定的break &lt;code&gt;break_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c91ff6d61d31b9a76a19683905991f494f51c9d2" translate="yes" xml:space="preserve">
          <source>Good! Now &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests are all routed to the approriate node. Let&amp;rsquo;s also make sure that when a new bucket is created it ends up on the correct node. Replace the &lt;code&gt;run/1&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt;, the one that matches the &lt;code&gt;:create&lt;/code&gt; command, with the following:</source>
          <target state="translated">好！现在， &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;PUT&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 请求都被路由到适当的节点。我们还要确保在创建新存储桶时，该存储桶会在正确的节点上结束。将 &lt;code&gt;KVServer.Command&lt;/code&gt; 中的 &lt;code&gt;run/1&lt;/code&gt; 函数（与 &lt;code&gt;:create&lt;/code&gt; 命令匹配的函数）替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="8bb7c805f7de70037ed1803ff9f5f16721be43e5" translate="yes" xml:space="preserve">
          <source>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module.</source>
          <target state="translated">字词也可以是两个字符,但有些语言将其解释为一个字符。例如,有些语言可能将 &quot;ch &quot;视为一个字符。然而,由于这一信息取决于当地语言,本模块没有考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="e786d50d22654cd173f8d3b62a2460772b2e8c56" translate="yes" xml:space="preserve">
          <source>Greater-than operator.</source>
          <target state="translated">大于运算符。</target>
        </trans-unit>
        <trans-unit id="7dae2a91a27873b3eab21af62f86fd6dd15e3eeb" translate="yes" xml:space="preserve">
          <source>Greater-than or equal to operator.</source>
          <target state="translated">大于或等于运算符。</target>
        </trans-unit>
        <trans-unit id="d6bc40a0f5a48e1cfea2b0fd464f5f6f31570bd2" translate="yes" xml:space="preserve">
          <source>Guard clauses can also be given to the match:</source>
          <target state="translated">守护条款也可以给比赛。</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="142ddd2f53edae494acde2b741cff19a0327b789" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.</source>
          <target state="translated">守护是用更复杂的检查来增强模式匹配的一种方式。它们被允许在预先定义的一组允许模式匹配的结构中使用,如函数定义、case子句等。</target>
        </trans-unit>
        <trans-unit id="cd32950893cbba732683c916fdaa3f7721bfbc75" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed.</source>
          <target state="translated">守护是用更复杂的检查来增强模式匹配的一种方式。它们被允许在预先定义的一组允许模式匹配的构造中使用。</target>
        </trans-unit>
        <trans-unit id="f51e7c885b3316cf13c1a89511ab0220e376f9ff" translate="yes" xml:space="preserve">
          <source>Guards can be used in patterns as well:</source>
          <target state="translated">护栏也可以用在图案中。</target>
        </trans-unit>
        <trans-unit id="da2c059bdbc9e50988efa18e14c41ef3278c8017" translate="yes" xml:space="preserve">
          <source>Guards can be used to restrict type variables given as arguments to the function.</source>
          <target state="translated">守卫可以用来限制作为函数参数的类型变量。</target>
        </trans-unit>
        <trans-unit id="3d4e06fce5066ed597d68206744c09c068cc26cf" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; keyword, which is followed by a boolean expression (we will define the grammar of guards more formally later on).</source>
          <target state="translated">警卫队以 &lt;code&gt;when&lt;/code&gt; 关键字开头，后跟一个布尔表达式（稍后我们将更正式地定义警卫队的语法）。</target>
        </trans-unit>
        <trans-unit id="00d836e676cdbf32c1fff6bdfc1dd47899a371d2" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns &lt;code&gt;true&lt;/code&gt;. Multiple boolean conditions can be combined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; operators.</source>
          <target state="translated">防护以 &lt;code&gt;when&lt;/code&gt; 运算符开头，后跟防护表达式。仅当保护表达式返回 &lt;code&gt;true&lt;/code&gt; 时,该子句才会执行。多个布尔条件可以与&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt;运算符组合。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="d645d6ef806b49668fa2c86b98204a1d0cbd439f" translate="yes" xml:space="preserve">
          <source>Guide: Metaprogramming</source>
          <target state="translated">指南:元编程</target>
        </trans-unit>
        <trans-unit id="fc6d12560c986e5d173ff3f215b4fdc7dd78c449" translate="yes" xml:space="preserve">
          <source>Guide: Mix &amp;amp; OTP</source>
          <target state="translated">指南：混合和OTP</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="1e562d47149e19ed5cad18f5c03b2789d427f02b" translate="yes" xml:space="preserve">
          <source>Handles assigns in quoted expressions.</source>
          <target state="translated">处理引号表达式中的赋值。</target>
        </trans-unit>
        <trans-unit id="ddf833f3c5194a503cfbad70c99e1db7094771aa" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~C&lt;/code&gt; for charlists.</source>
          <target state="translated">处理印记 &lt;code&gt;~C&lt;/code&gt; 为charlists。</target>
        </trans-unit>
        <trans-unit id="fb3ba3c1a95dbc32cd091a7bf8625e909b666103" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~D&lt;/code&gt; for dates.</source>
          <target state="translated">处理印记 &lt;code&gt;~D&lt;/code&gt; 的日期。</target>
        </trans-unit>
        <trans-unit id="982325391ef0142622780269edf1546f73b262a3" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~N&lt;/code&gt; for naive date times.</source>
          <target state="translated">处理印记 &lt;code&gt;~N&lt;/code&gt; 幼稚日期倍。</target>
        </trans-unit>
        <trans-unit id="61bcb2084c564ad8723451ec89fc1bbe6d5b39d6" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~R&lt;/code&gt; for regular expressions.</source>
          <target state="translated">处理印记 &lt;code&gt;~R&lt;/code&gt; 为正则表达式。</target>
        </trans-unit>
        <trans-unit id="ee65de02481e36f7795050fdcbac43c76b0097f0" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~S&lt;/code&gt; for strings.</source>
          <target state="translated">处理印记 &lt;code&gt;~S&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="021700491c061be385dd02126ab31483e68097c1" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~T&lt;/code&gt; for times.</source>
          <target state="translated">处理印记 &lt;code&gt;~T&lt;/code&gt; 的时间。</target>
        </trans-unit>
        <trans-unit id="2b0a2c1b8e946dd36ec07ae3f98021a22faab492" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">处理印记 &lt;code&gt;~U&lt;/code&gt; 创建UTC &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edea9c3c145eb520a4b09a9b6e8ef37e6cb7464e" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">处理印记 &lt;code&gt;~U&lt;/code&gt; 创建UTC&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f52b59decaffdf3dbd50c018dec832cff60ddfc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~W&lt;/code&gt; for list of words.</source>
          <target state="translated">处理印记 &lt;code&gt;~W&lt;/code&gt; 单词的列表。</target>
        </trans-unit>
        <trans-unit id="3f9e6bb6b9375b71e2dd3e6c31781d8b7de4f2bc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~c&lt;/code&gt; for charlists.</source>
          <target state="translated">处理印记 &lt;code&gt;~c&lt;/code&gt; 为charlists。</target>
        </trans-unit>
        <trans-unit id="e93b408b9addb240b0d8fec06f1cc6fd6483cad8" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~r&lt;/code&gt; for regular expressions.</source>
          <target state="translated">处理印记 &lt;code&gt;~r&lt;/code&gt; 为正则表达式。</target>
        </trans-unit>
        <trans-unit id="5c8529f6bd35c204f46a458ef8fe33f88fe57b75" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~s&lt;/code&gt; for strings.</source>
          <target state="translated">处理印记 &lt;code&gt;~s&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="812d965b782f5a4cdb2aa6ca4e03193e8426a888" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~w&lt;/code&gt; for list of words.</source>
          <target state="translated">处理印记 &lt;code&gt;~w&lt;/code&gt; 单词的列表。</target>
        </trans-unit>
        <trans-unit id="7849ebf167a97ce455aff4c671cafc34086c2adc" translate="yes" xml:space="preserve">
          <source>Happy coding!</source>
          <target state="translated">编码快乐!</target>
        </trans-unit>
        <trans-unit id="e74fbc6484fa15dc5415ec3ea61b85c17ae16042" translate="yes" xml:space="preserve">
          <source>HashDict</source>
          <target state="translated">HashDict</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b4f9c2553efc8e434d9a14c06152b8e6c5d5f2d5" translate="yes" xml:space="preserve">
          <source>Help for all of those functions can be consulted directly from the command line using the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; helper itself. Try:</source>
          <target state="translated">可以使用&lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt;帮助器本身直接从命令行中查询所有这些功能的帮助。尝试：</target>
        </trans-unit>
        <trans-unit id="3dc137e03814f2f8c65320b0dffc705dd74522ae" translate="yes" xml:space="preserve">
          <source>Helper functions for formatting and the formatting protocols.</source>
          <target state="translated">格式化和格式化协议的辅助功能。</target>
        </trans-unit>
        <trans-unit id="6807f0882791439924cfe88b4665c74673dc2b7c" translate="yes" xml:space="preserve">
          <source>Helper module</source>
          <target state="translated">辅助模块</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="c42a25368aea44b1d8b6e2caeca032b5ca554730" translate="yes" xml:space="preserve">
          <source>Helpers for defining test cases.</source>
          <target state="translated">定义测试用例的助手。</target>
        </trans-unit>
        <trans-unit id="d5c884b844c2ebd809f20b51b9edc72b238135da" translate="yes" xml:space="preserve">
          <source>Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated.</source>
          <target state="translated">因此被称为 &quot;柔性&quot;,它们在文件装配时更加灵活。另一方面,它们的价格比较昂贵,因为每次断裂都需要重新评估。</target>
        </trans-unit>
        <trans-unit id="b1aef6d0ceaad34efbe32b0b7338abfa12a31756" translate="yes" xml:space="preserve">
          <source>Here are some examples of working with different types and modifiers:</source>
          <target state="translated">下面是一些使用不同类型和修饰符的例子。</target>
        </trans-unit>
        <trans-unit id="42db1d3d86baee9f18579aec4c71f6475b37d168" translate="yes" xml:space="preserve">
          <source>Here are some invalid ones:</source>
          <target state="translated">下面是一些无效的。</target>
        </trans-unit>
        <trans-unit id="11442cf4a8b2c1cb2e42c80414e3bc9baaa0cb80" translate="yes" xml:space="preserve">
          <source>Here are some valid paths:</source>
          <target state="translated">以下是一些有效的路径。</target>
        </trans-unit>
        <trans-unit id="352db02f68b7960ade3f7f5b302deb2325291825" translate="yes" xml:space="preserve">
          <source>Here is a better implementation of our Stack module:</source>
          <target state="translated">下面是我们Stack模块的一个比较好的实现。</target>
        </trans-unit>
        <trans-unit id="d3dfbcd6177f2eeaaed92da7d1fa4ce5d577524c" translate="yes" xml:space="preserve">
          <source>Here is a rundown of the life-cycle of the test process:</source>
          <target state="translated">下面是测试过程的生命周期的简要介绍。</target>
        </trans-unit>
        <trans-unit id="8b69e6d654ffc481049b79c6ad68ac13e993788a" translate="yes" xml:space="preserve">
          <source>Here is an example of a &lt;code&gt;.formatter.exs&lt;/code&gt; file that works as a starting point:</source>
          <target state="translated">这是一个作为起点的 &lt;code&gt;.formatter.exs&lt;/code&gt; 文件的示例：</target>
        </trans-unit>
        <trans-unit id="b7fa9405686c3918f67bf3e27b8a6096e14cbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">这是如何在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:console&lt;/code&gt; 后端的示例：</target>
        </trans-unit>
        <trans-unit id="b3a43eba555f0c13a34172cd9439caffcb152633" translate="yes" xml:space="preserve">
          <source>Here is an example on how we mimic an echo server from the command line:</source>
          <target state="translated">下面是一个关于如何从命令行模拟回音服务器的例子。</target>
        </trans-unit>
        <trans-unit id="3edae206369380098d80617af169ddbd0abfffd5" translate="yes" xml:space="preserve">
          <source>Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2:</source>
          <target state="translated">下面是一个遍历列表中的偶数和奇数乘以2的例子。</target>
        </trans-unit>
        <trans-unit id="719c74f661d33fc8656d2bb7f5d2aed1ea13f147" translate="yes" xml:space="preserve">
          <source>Here is an example where all keys match:</source>
          <target state="translated">下面是一个所有键都匹配的例子。</target>
        </trans-unit>
        <trans-unit id="050a27ec30c2a26d404808ec75322f708750e58e" translate="yes" xml:space="preserve">
          <source>Here is the full echo server implementation:</source>
          <target state="translated">这里是完整的echo服务器实现。</target>
        </trans-unit>
        <trans-unit id="6f777b3d9caee14d91c8f30553a83cea3e2dc561" translate="yes" xml:space="preserve">
          <source>Here is the updated code for the &lt;code&gt;TestCase&lt;/code&gt; module:</source>
          <target state="translated">这是 &lt;code&gt;TestCase&lt;/code&gt; 模块的更新代码：</target>
        </trans-unit>
        <trans-unit id="a22b63cc9c9e1b1cf8079d3829c10b45935571fc" translate="yes" xml:space="preserve">
          <source>Here is when a subset of the keys match:</source>
          <target state="translated">这里是当键的子集匹配。</target>
        </trans-unit>
        <trans-unit id="84bb9c9b475cb5ae8d6aa130c97b79761a44437b" translate="yes" xml:space="preserve">
          <source>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and &lt;em&gt;mapping&lt;/em&gt; over it is known as a &lt;em&gt;map algorithm&lt;/em&gt;.</source>
          <target state="translated">在这里，我们使用了递归遍历一个列表，将每个元素加倍并返回一个新列表。获取列表并对其进行&lt;em&gt;映射&lt;/em&gt;的过程称为&lt;em&gt;映射算法&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5c22f5f67bc89de4473d36dd5d40a24915681d3c" translate="yes" xml:space="preserve">
          <source>Here we will use Agents, and create a module named &lt;code&gt;KV.Bucket&lt;/code&gt;, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.</source>
          <target state="translated">在这里，我们将使用代理，并创建一个名为 &lt;code&gt;KV.Bucket&lt;/code&gt; 的模块，该模块负责存储键值条目，使键值条目可以被其他进程读取和修改。</target>
        </trans-unit>
        <trans-unit id="3e5a3bc41bc733073ea1b7c356d6fc16ff9a31eb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we could write the same &lt;code&gt;Utility.type/1&lt;/code&gt; functionality as a protocol:</source>
          <target state="translated">这是我们编写与协议相同的 &lt;code&gt;Utility.type/1&lt;/code&gt; 功能的方法：</target>
        </trans-unit>
        <trans-unit id="4a4f491539740358c0862f6ed0caff8dd3eb4c91" translate="yes" xml:space="preserve">
          <source>Here, 257 in base 2 would be represented as &lt;code&gt;100000001&lt;/code&gt;, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to &lt;code&gt;00000001&lt;/code&gt;, or simply &lt;code&gt;1&lt;/code&gt; in decimal.</source>
          <target state="translated">在这里，以2为底的257将被表示为 &lt;code&gt;100000001&lt;/code&gt; ，但是由于我们仅保留了8位用于表示（默认情况下），因此最左边的位将被忽略并且该值将被截断为 &lt;code&gt;00000001&lt;/code&gt; 或十进制中的 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbd25c9ac39901e5a89af9e9cc14cd5e96101d55" translate="yes" xml:space="preserve">
          <source>Here, the arrow (&lt;code&gt;&amp;lt;--&lt;/code&gt;) indicates the &lt;strong&gt;marked&lt;/strong&gt; function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below).</source>
          <target state="translated">在此，箭头（ &lt;code&gt;&amp;lt;--&lt;/code&gt; ）表示&lt;strong&gt;标记的&lt;/strong&gt;功能-本段描述的功能。您还将看到其直接调用方（上方）和被调用函数（下方）。</target>
        </trans-unit>
        <trans-unit id="f90a2dd87f0e0e5b3fc18bbdd374ab3f255b75b6" translate="yes" xml:space="preserve">
          <source>Hex options (&lt;code&gt;:hex&lt;/code&gt;)</source>
          <target state="translated">十六进制选项（ &lt;code&gt;:hex&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="778ad2f9bcae03814f9abdf00cda4d6b0dd5b58c" translate="yes" xml:space="preserve">
          <source>Hexadecimals and Unicode code points will be escaped if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?x&lt;/code&gt;. Unicode code points if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?u&lt;/code&gt;.</source>
          <target state="translated">如果map函数对 &lt;code&gt;?x&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则十六进制和Unicode代码点将被转义。如果map函数对 &lt;code&gt;?u&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则Unicode代码指向。</target>
        </trans-unit>
        <trans-unit id="26e85f63826bec68a04b03d81896950af6108f8b" translate="yes" xml:space="preserve">
          <source>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</source>
          <target state="translated">不应激进地使用休眠,因为太多的时间可能会花在垃圾收集上。一般来说,只有在不希望很快收到消息的时候才使用休眠,而且尽量减少进程的内存是有益的。</target>
        </trans-unit>
        <trans-unit id="86c45c0195b718d67c0a438292af56b71a044d2f" translate="yes" xml:space="preserve">
          <source>Hiding Internal Modules and Functions</source>
          <target state="translated">隐藏内部模块和函数</target>
        </trans-unit>
        <trans-unit id="0ea7288fabe36d1374b87e85268bd81849d9bced" translate="yes" xml:space="preserve">
          <source>History size</source>
          <target state="translated">历史尺寸</target>
        </trans-unit>
        <trans-unit id="d5f481ffbf704bd71ae3b341524ffae254c4f8b3" translate="yes" xml:space="preserve">
          <source>Hot Code Upgrades</source>
          <target state="translated">热门代码升级</target>
        </trans-unit>
        <trans-unit id="fc314201ff6cdd49c00bb54c2d3a38dc7360de1d" translate="yes" xml:space="preserve">
          <source>Hot code swapping</source>
          <target state="translated">热代码交换</target>
        </trans-unit>
        <trans-unit id="5a2b9c570ab736a0a992067e06ddc44051493496" translate="yes" xml:space="preserve">
          <source>Hour using a 12-hour clock</source>
          <target state="translated">使用12小时钟的小时</target>
        </trans-unit>
        <trans-unit id="0b231acab966b52e86353b589bad7d81125cc30e" translate="yes" xml:space="preserve">
          <source>Hour using a 24-hour clock</source>
          <target state="translated">使用24小时钟的小时</target>
        </trans-unit>
        <trans-unit id="3935f3cf215c2daeec7c25cef51c0a03f6190f58" translate="yes" xml:space="preserve">
          <source>How can this line fail if we just created the bucket in the previous line?</source>
          <target state="translated">如果我们刚刚在上一行创建了bucket,这一行怎么会失败呢?</target>
        </trans-unit>
        <trans-unit id="04ccc44e58210facfedf9edfba2604fce3cfc2e4" translate="yes" xml:space="preserve">
          <source>How to supervise</source>
          <target state="translated">如何监督</target>
        </trans-unit>
        <trans-unit id="7cdfd34c64026a6f64366847c32473d397480980" translate="yes" xml:space="preserve">
          <source>However Elixir introduces a syntax sugar where the keywords above may be written as follows:</source>
          <target state="translated">然而Elixir引入了一个语法糖,上面的关键词可以写成如下。</target>
        </trans-unit>
        <trans-unit id="7d4e3b65932901a80bd0c8daa5e66bd16aedca07" translate="yes" xml:space="preserve">
          <source>However, a quoted variable is represented as:</source>
          <target state="translated">然而,引用的变量表示为:。</target>
        </trans-unit>
        <trans-unit id="057b67626d2f5f52a384b7c48714343f2812737b" translate="yes" xml:space="preserve">
          <source>However, after our project is compiled using a tool like Mix, we know all modules that have been defined, including protocols and their implementations. This way, the protocol can be consolidated into a very simple and fast dispatch module.</source>
          <target state="translated">但是,当我们的项目使用Mix这样的工具进行编译之后,我们就知道所有已经定义好的模块,包括协议及其实现。这样一来,协议就可以整合成一个非常简单快速的调度模块。</target>
        </trans-unit>
        <trans-unit id="30b8c9087b77b2def4f60524eab486ec77b7882f" translate="yes" xml:space="preserve">
          <source>However, do not provide &lt;code&gt;__using__/1&lt;/code&gt; if all it does is to import, alias or require the module itself. For example, avoid this:</source>
          <target state="translated">但是，如果仅用于导入，别名或需要模块本身，则不要提供 &lt;code&gt;__using__/1&lt;/code&gt; 。例如，避免这种情况：</target>
        </trans-unit>
        <trans-unit id="ca0de7a0e18a5854d7abeb96c012e778937c81fc" translate="yes" xml:space="preserve">
          <source>However, for the tests in &lt;code&gt;KV.RouterTest&lt;/code&gt;, we effectively need two nodes in our routing table. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">但是，对于 &lt;code&gt;KV.RouterTest&lt;/code&gt; 中的测试，我们实际上在路由表中需要两个节点。为此，我们将编写一个安装块，该安装块在该文件中的所有测试之前运行。设置块将更改应用程序环境，并在完成后将其还原，如下所示：</target>
        </trans-unit>
        <trans-unit id="82776ff5a87946e16cbe8e021db6c7eca6df82eb" translate="yes" xml:space="preserve">
          <source>However, functions that return booleans and are valid in guards follow another convention, described next.</source>
          <target state="translated">然而,返回booleans并在guards中有效的函数遵循另一个惯例,接下来将介绍。</target>
        </trans-unit>
        <trans-unit id="e2f8333bf85aa3e6557d871123f4e54aa89129c2" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">但是，如果用单个字符&amp;ldquo;带有急性&amp;rdquo;重音的&amp;ldquo; e&amp;rdquo;表示&amp;ldquo;&amp;eacute;&amp;rdquo;，则它将返回 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dea6b01d6679272ba037abafc94d5ec1f3a1e91" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part:</source>
          <target state="translated">但是，如果用单个字符&amp;ldquo;具有尖锐的&amp;rdquo;重音符号表示&amp;ldquo;&amp;eacute;&amp;rdquo;，则它将字符串拆分成一个部分：</target>
        </trans-unit>
        <trans-unit id="43d541b3bc1e148da1c64ef9ffa0bbfd2e7364f7" translate="yes" xml:space="preserve">
          <source>However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as:</source>
          <target state="translated">但是,如果使用了弹性断点,那么每个断点在渲染时都会被重新评估,所以文档可能会被渲染成:。</target>
        </trans-unit>
        <trans-unit id="e59920d8100c9a8114a12d93422f9d86a0ab473f" translate="yes" xml:space="preserve">
          <source>However, if there is a need to access the user variable, nil can be given:</source>
          <target state="translated">但是,如果需要访问用户变量,可以给出nil。</target>
        </trans-unit>
        <trans-unit id="ebac26b5b96f39c6c425c9f7338b33aa11d33d44" translate="yes" xml:space="preserve">
          <source>However, if we use &lt;code&gt;string&lt;/code&gt;, then the string length is used, instead of byte size, correctly fitting:</source>
          <target state="translated">但是，如果我们使用 &lt;code&gt;string&lt;/code&gt; ，那么将使用字符串长度而不是字节大小来正确拟合：</target>
        </trans-unit>
        <trans-unit id="163ec0dc8d44d05de91c4d5e307d82258afc33ad" translate="yes" xml:space="preserve">
          <source>However, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:</source>
          <target state="translated">然而,如果你期望文件在那里,砰的变化更有用,因为它提出了一个有意义的错误信息。避免写。</target>
        </trans-unit>
        <trans-unit id="b26ef74513acb14878e64cf7d06f11768d520400" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (e.g. if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">然而,如果你期望结果总是成功的(例如,如果你期望文件总是存在的),bang变体可以更方便,并且会在失败时提出一个更有用的错误信息(比模式匹配失败)。</target>
        </trans-unit>
        <trans-unit id="f76bd9d28fa6001b9c29fd594f3da25de0125efb" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">然而,如果你期望结果总是成功的(例如,如果你期望文件总是存在的),bang变体可以更方便,并且会在失败时提出一个更有用的错误信息(比模式匹配失败)。</target>
        </trans-unit>
        <trans-unit id="12f2ae0ce38b2739810767448aba2df24da58505" translate="yes" xml:space="preserve">
          <source>However, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.</source>
          <target state="translated">然而,如果你把每一个应用都作为一个单独的项目推送到Git仓库中,你的项目可能会变得非常难以维护,因为你会花费大量的时间来管理这些Git仓库,而不是编写你的代码。</target>
        </trans-unit>
        <trans-unit id="c4db01e79b2e5a22ecea1d3f50d5983cb25a53b4" translate="yes" xml:space="preserve">
          <source>However, if you want to invoke a specific module, function and arguments, or give the task process a name, you need to define the task in its own module:</source>
          <target state="translated">但是,如果你想调用特定的模块、函数和参数,或者给任务进程命名,你需要在自己的模块中定义任务。</target>
        </trans-unit>
        <trans-unit id="d300780723b1e1d9cb8cf90e34f684379371fda8" translate="yes" xml:space="preserve">
          <source>However, if you want to re-use the sigil character itself on the string, you need to escape it:</source>
          <target state="translated">但是,如果你想在字符串上重复使用符号字符本身,你需要对其进行转义。</target>
        </trans-unit>
        <trans-unit id="9832e5845d5128f4155ac9809559b224c95909bd" translate="yes" xml:space="preserve">
          <source>However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt;&lt;code&gt;is_tuple/1&lt;/code&gt;&lt;/a&gt; before &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt;, otherwise the whole guard will fail if a tuple is not given. Alternatively your function clause can use multiple guards as shown in the following section.</source>
          <target state="translated">但是，如果您的后卫有多个条件，例如检查元组或映射，则最好在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt; &lt;code&gt;is_tuple/1&lt;/code&gt; &lt;/a&gt;之前&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt;类的类型检查函数，否则，如果不给出元组，则整个后卫将失败。另外，您的function子句可以使用多个保护，如下节所示。</target>
        </trans-unit>
        <trans-unit id="bbb15fb0156049fcce5c409f89352f9b00a36988" translate="yes" xml:space="preserve">
          <source>However, implementation-wise, they have the following differences:</source>
          <target state="translated">但在实施上,它们有以下区别。</target>
        </trans-unit>
        <trans-unit id="ab714719ee8f889dd923393f22c68b77c2b16ffe" translate="yes" xml:space="preserve">
          <source>However, in some cases it may be desired to associate a value to the process using the alternate &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; tuple:</source>
          <target state="translated">但是，在某些情况下，可能希望使用备用 &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; 元组将值与流程相关联：</target>
        </trans-unit>
        <trans-unit id="d4761ed59b0d1afa93377c7f7b363dfb8fb4fda3" translate="yes" xml:space="preserve">
          <source>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the &lt;code&gt;^&lt;/code&gt; special form, colloquially known as the pin operator:</source>
          <target state="translated">但是，在某些情况下，与现有值匹配而不是重新绑定很有用。可以使用 &lt;code&gt;^&lt;/code&gt; 特殊形式来完成此操作，通常称为pin运算符：</target>
        </trans-unit>
        <trans-unit id="96e149dd0b884d4a6fa96fb42e3515395245b191" translate="yes" xml:space="preserve">
          <source>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</source>
          <target state="translated">然而,在大多数情况下,您希望将任务监督员添加到您的监督树中。</target>
        </trans-unit>
        <trans-unit id="dba0c307e5ca681865cce6227a859a96ae9a11f3" translate="yes" xml:space="preserve">
          <source>However, instead of adding more code to the &lt;code&gt;kv&lt;/code&gt; application, we are going to build the TCP server as another application that is a client of the &lt;code&gt;kv&lt;/code&gt; application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.</source>
          <target state="translated">但是，我们没有向 &lt;code&gt;kv&lt;/code&gt; 应用程序添加更多代码，而是将TCP服务器构建为作为 &lt;code&gt;kv&lt;/code&gt; 应用程序客户端的另一个应用程序。由于整个运行时和Elixir生态系统都面向应用程序，因此将我们的项目分解为可以协同工作的较小应用程序是有意义的，而不是构建大型的整体应用程序。</target>
        </trans-unit>
        <trans-unit id="d0b1ff55d618bd8bbea3c57925ed60e856baa189" translate="yes" xml:space="preserve">
          <source>However, instead of modifying those files after the release is built, the simplest way to customize those files is by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt;&lt;code&gt;mix release.init&lt;/code&gt;&lt;/a&gt;. The Mix task will copy custom &lt;code&gt;rel/vm.args.eex&lt;/code&gt;, &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; files to your project root. You can modify those files and they will be evaluated every time you perform a new release. Those files are regular EEx templates and they have a single assign, called &lt;code&gt;@release&lt;/code&gt;, with the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">但是，不是在构建发行版之后修改这些文件，而是自定义&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt; &lt;code&gt;mix release.init&lt;/code&gt; &lt;/a&gt;这些文件的最简单方法是运行mix release.init。 Mix任务会将自定义的 &lt;code&gt;rel/vm.args.eex&lt;/code&gt; ， &lt;code&gt;rel/env.sh.eex&lt;/code&gt; 和 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; 文件复制到项目根目录。您可以修改这些文件，并且每次执行新发行版时都会对其进行评估。这些文件是常规的EEx模板，并且具有带有&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt;结构的单个分配，称为 &lt;code&gt;@release&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f2acb719b57d971a999b6feb20a4c47ae5bfcf5" translate="yes" xml:space="preserve">
          <source>However, keep in mind that adding &lt;code&gt;@doc false&lt;/code&gt; does not make the function private. The function above can still be invoked as &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt;. Not only that, if &lt;code&gt;MyApp.Sample&lt;/code&gt; is imported, the &lt;code&gt;add/2&lt;/code&gt; function will also be imported into the caller. For those reasons, be cautious when adding &lt;code&gt;@doc false&lt;/code&gt; to functions, instead use one of these two options:</source>
          <target state="translated">但是，请记住，添加 &lt;code&gt;@doc false&lt;/code&gt; 不会使函数私有。上面的函数仍然可以作为 &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt; 调用。不仅如此，如果导入 &lt;code&gt;MyApp.Sample&lt;/code&gt; ，则 &lt;code&gt;add/2&lt;/code&gt; 函数也将导入到调用方中。由于这些原因，在向函数添加 &lt;code&gt;@doc false&lt;/code&gt; 时要谨慎，而请使用以下两个选项之一：</target>
        </trans-unit>
        <trans-unit id="ce1e4503150dc2f3049f826f979cbe9905825d87" translate="yes" xml:space="preserve">
          <source>However, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run.</source>
          <target state="translated">然而,请记住,通过使测试分布式,我们可能会减少运行频率,因为我们可能不会在每次测试运行时都进行分布式设置。</target>
        </trans-unit>
        <trans-unit id="3693f464a1590f76c7a514020cc3b6b0e554bf8d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">但是，请记住，这些情况通常不是问题。毕竟，PID引用的过程可能随时崩溃，包括从注册表获取值和向其发送消息之间。标准库的许多部分都为解决这一问题而设计，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;，如果受监视的进程已经死机，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;立即传递 &lt;code&gt;:DOWN&lt;/code&gt; 消息；而Kernel.send / 2充当死机的无操作流程。</target>
        </trans-unit>
        <trans-unit id="f5ae69f63821cec3eb4f2016854327b6c5df477d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">但是，请记住，这些情况通常不是问题。毕竟，PID引用的过程可能随时崩溃，包括从注册表获取值和向其发送消息之间。标准库的许多部分都为解决这一问题而设计，例如&lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;，如果受监视的进程已经死机，&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;立即传递 &lt;code&gt;:DOWN&lt;/code&gt; 消息；而Kernel.send / 2则充当死机的无操作。流程。</target>
        </trans-unit>
        <trans-unit id="ea02d735a03ee13559ceb754eeca6008810c2c76" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">但是，该语言还存在许多其他可枚举的内容，例如&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt;返回的数据类型，它允许遍历文件，就好像它是可枚举的一样。</target>
        </trans-unit>
        <trans-unit id="9a395466f1651904a7d0044a0e96b1a814183371" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">但是，该语言还存在许多其他可枚举的内容，例如&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt;返回的数据类型，它允许遍历文件，就好像它是可枚举的一样。</target>
        </trans-unit>
        <trans-unit id="1b496aae43041f07a94c194092a1ee0cf80d4eec" translate="yes" xml:space="preserve">
          <source>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and &lt;strong&gt;we should never convert user input to atoms&lt;/strong&gt;. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</source>
          <target state="translated">但是，用原子命名动态过程是一个可怕的想法！如果使用原子，则需要将存储桶名称（通常是从外部客户端接收到的存储桶）&lt;strong&gt;转换&lt;/strong&gt;为原子，并且&lt;strong&gt;永远不要将用户输入转换为原子&lt;/strong&gt;。这是因为原子不是垃圾收集的。一旦创建了原子，就永远不会对其进行回收。根据用户输入生成原子意味着用户可以注入足够多的不同名称来耗尽我们的系统内存！</target>
        </trans-unit>
        <trans-unit id="df3b6ab895dd3f7bd985857fc1933851a28e562b" translate="yes" xml:space="preserve">
          <source>However, remember that binary pattern matching works on &lt;em&gt;bytes&lt;/em&gt;, so matching on the string like &amp;ldquo;&amp;uuml;ber&amp;rdquo; with multibyte characters won&amp;rsquo;t match on the &lt;em&gt;character&lt;/em&gt;, it will match on the &lt;em&gt;first byte of that character&lt;/em&gt;:</source>
          <target state="translated">但是，请记住，二进制模式匹配适用于&lt;em&gt;字节&lt;/em&gt;，因此与&amp;ldquo;&amp;uuml;ber&amp;rdquo;之类的字符串与多字节字符的匹配不会与&lt;em&gt;字符&lt;/em&gt;匹配，它将与该&lt;em&gt;字符&lt;/em&gt;的&lt;em&gt;第一个字节&lt;/em&gt;匹配：</target>
        </trans-unit>
        <trans-unit id="77afe59f2cf778e4ba45a1656955754632ba1dec" translate="yes" xml:space="preserve">
          <source>However, should we be fine with the implementation for &lt;code&gt;Any&lt;/code&gt;, in order to use such implementation we would need to tell our struct to explicitly derive the &lt;code&gt;Size&lt;/code&gt; protocol:</source>
          <target state="translated">但是，如果我们对 &lt;code&gt;Any&lt;/code&gt; 的实现感到满意，为了使用这种实现，我们需要告诉我们的结构显式派生 &lt;code&gt;Size&lt;/code&gt; 协议：</target>
        </trans-unit>
        <trans-unit id="1f35366701d4be066fddfcbe4789ab0e44ff649f" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;KV.Registry.create/2&lt;/code&gt; is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</source>
          <target state="translated">但是，由于 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 是强制转换操作，因此该命令将在我们实际写入表之前返回！换句话说，这正在发生：</target>
        </trans-unit>
        <trans-unit id="b607bf41eed0b7acedbf1d601f4e6081a4cb7cfb" translate="yes" xml:space="preserve">
          <source>However, since structs are just maps, they work with the functions from the &lt;code&gt;Map&lt;/code&gt; module:</source>
          <target state="translated">但是，由于结构只是映射，因此它们可以使用 &lt;code&gt;Map&lt;/code&gt; 模块中的函数：</target>
        </trans-unit>
        <trans-unit id="e7b768f9063dad4bbd7d785c035b8dad45c243ae" translate="yes" xml:space="preserve">
          <source>However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the &lt;code&gt;start_link&lt;/code&gt; argument instead of the specification:</source>
          <target state="translated">但是，将每个子项的子项规范指定为映射可能会很容易出错，因为我们可能会更改Stack实现并忘记更新其规范。这就是Elixir允许您传递带有模块名称和 &lt;code&gt;start_link&lt;/code&gt; 参数而不是规范的元组的原因：</target>
        </trans-unit>
        <trans-unit id="496f233e2f16ce1ec282e5a3228096d9e60212a4" translate="yes" xml:space="preserve">
          <source>However, strings are just part of the story. If a string is a binary, and we have used the &lt;code&gt;is_binary/1&lt;/code&gt; function, Elixir must have an underlying type empowering strings. And it does! Let&amp;rsquo;s talk about binaries.</source>
          <target state="translated">但是，字符串只是故事的一部分。如果字符串是二进制的，并且我们使用了 &lt;code&gt;is_binary/1&lt;/code&gt; 函数，则Elixir必须具有底层类型来授权字符串。确实如此！让我们谈谈二进制文件。</target>
        </trans-unit>
        <trans-unit id="dd71889ec3595479588d8ca1a2ca3333e184a132" translate="yes" xml:space="preserve">
          <source>However, the capturing of any other named device, such as &lt;code&gt;:stderr&lt;/code&gt;, happens globally and persists until the function has ended. While this means it is safe to run your tests with &lt;code&gt;async: true&lt;/code&gt; in many cases, captured output may include output from a different test and care must be taken when using &lt;code&gt;capture_io&lt;/code&gt; with a named process asynchronously.</source>
          <target state="translated">但是，任何其他命名设备（例如 &lt;code&gt;:stderr&lt;/code&gt; )的捕获都是全局发生的，并且一直持续到该函数结束。虽然这意味着可以安全地使用 &lt;code&gt;async: true&lt;/code&gt; 运行测试：在许多情况下为true，但捕获的输出可能包含来自其他测试的输出，并且当异步将 &lt;code&gt;capture_io&lt;/code&gt; 与命名进程一起使用时，必须格外小心。</target>
        </trans-unit>
        <trans-unit id="82b09700b9bf9936f190f1106abb6ccb1f220f41" translate="yes" xml:space="preserve">
          <source>However, the code below would work as long as &lt;code&gt;:option_parser_example&lt;/code&gt; atom is used at some point later (or earlier) &lt;strong&gt;in the same module&lt;/strong&gt;. For example:</source>
          <target state="translated">但是，只要稍后&lt;strong&gt;在同一模块中&lt;/strong&gt;（或更早）使用 &lt;code&gt;:option_parser_example&lt;/code&gt; 原子，以下代码就可以工作。例如：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b357c81b8f132fc24fbf479211e75b269f8fae9b" translate="yes" xml:space="preserve">
          <source>However, the size cannot be defined in the match outside the binary/bitstring match:</source>
          <target state="translated">但是,在二进制/位串匹配之外的匹配中不能定义大小。</target>
        </trans-unit>
        <trans-unit id="c0f50242052626c017e46fce09925693cd1c9dd3" translate="yes" xml:space="preserve">
          <source>However, there are times when we don&amp;rsquo;t want variables to be rebound.</source>
          <target state="translated">但是，有时候我们不希望变量反弹。</target>
        </trans-unit>
        <trans-unit id="88399305a4f17930e312791fc1d3a07b6c89a0a2" translate="yes" xml:space="preserve">
          <source>However, there is a bug in our stack server. If we call &lt;code&gt;:pop&lt;/code&gt; and the stack is empty, it is going to crash because no clause matches:</source>
          <target state="translated">但是，我们的堆栈服务器中有一个错误。如果我们调用 &lt;code&gt;:pop&lt;/code&gt; 并且堆栈为空，则它将崩溃，因为没有子句匹配：</target>
        </trans-unit>
        <trans-unit id="6b30a9e6e90f8ae42f6ce5f8d5d4ee4d68edc7af" translate="yes" xml:space="preserve">
          <source>However, there is still one concern left, which are the restart strategies. Tasks, by default, have the &lt;code&gt;:restart&lt;/code&gt; value set to &lt;code&gt;:temporary&lt;/code&gt;, which means they are not restarted. This is an excellent default for the connections started via the &lt;code&gt;Task.Supervisor&lt;/code&gt;, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.</source>
          <target state="translated">但是，仍然存在一个问题，那就是重启策略。默认情况下，任务的 &lt;code&gt;:restart&lt;/code&gt; 值设置为 &lt;code&gt;:temporary&lt;/code&gt; ，这意味着它们不会重新启动。对于通过 &lt;code&gt;Task.Supervisor&lt;/code&gt; 启动的连接，这是一个很好的默认设置，因为重新启动失败的连接没有任何意义，但是对于接受者来说，这是一个糟糕的选择。如果受体崩溃，我们希望使受体重新启动并运行。</target>
        </trans-unit>
        <trans-unit id="2654066a02c149d51e371eeaac885d94072a55a8" translate="yes" xml:space="preserve">
          <source>However, this module returns the proper length:</source>
          <target state="translated">然而,这个模块返回的是适当的长度。</target>
        </trans-unit>
        <trans-unit id="0458a5b82cdaf306b947332bf064e36f033492d1" translate="yes" xml:space="preserve">
          <source>However, this option can be expensive if you have multiple production nodes or if the release assembling process is a long one, as each node needs to individually assemble the release.</source>
          <target state="translated">然而,如果你有多个生产节点,或者如果版本组装过程很漫长,这种选择可能会很昂贵,因为每个节点都需要单独组装版本。</target>
        </trans-unit>
        <trans-unit id="41d8fdc77d8f21adeb6b27918df1a329fe13ff18" translate="yes" xml:space="preserve">
          <source>However, using lists in IO operations requires some attention. A list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the &lt;code&gt;IO&lt;/code&gt; module starting with &lt;code&gt;bin*&lt;/code&gt; must be used. Those functions expect an &lt;code&gt;iodata&lt;/code&gt; as an argument; i.e., they expect a list of integers representing bytes or binaries to be given.</source>
          <target state="translated">但是，在IO操作中使用列表需要引起注意。列表可以表示一堆字节或一堆字符，要使用哪个列表取决于IO设备的编码。如果打开文件时未进行编码，则文件应处于原始模式，并且必须使用 &lt;code&gt;IO&lt;/code&gt; 模块中以 &lt;code&gt;bin*&lt;/code&gt; 开头的功能。这些函数期望使用 &lt;code&gt;iodata&lt;/code&gt; 作为参数。即，他们期望给出代表字节或二进制数的整数列表。</target>
        </trans-unit>
        <trans-unit id="b77af23f35c905af8889b972cb68357936576822" translate="yes" xml:space="preserve">
          <source>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the &lt;code&gt;=&lt;/code&gt; operator):</source>
          <target state="translated">但是，在匹配中分配的变量在函数调用之外将不可用（与使用 &lt;code&gt;=&lt;/code&gt; 运算符进行常规模式匹配不同）：</target>
        </trans-unit>
        <trans-unit id="5c24fd6169426183241dcc9a0bdf50f1c21b8290" translate="yes" xml:space="preserve">
          <source>However, variables explicitly bound in the clause &quot;body&quot; are accessible from the outer context:</source>
          <target state="translated">但是,在子句 &quot;body &quot;中明确绑定的变量可以从外部上下文中访问。</target>
        </trans-unit>
        <trans-unit id="a2b5a965ef9a419fe17594f66438c5b71c746d05" translate="yes" xml:space="preserve">
          <source>However, we can connect to the other shell remotely. Open up the &lt;code&gt;User switch command&lt;/code&gt; prompt (Ctrl+G) and type:</source>
          <target state="translated">但是，我们可以远程连接到另一个外壳。打开 &lt;code&gt;User switch command&lt;/code&gt; 提示符（Ctrl + G）并键入：</target>
        </trans-unit>
        <trans-unit id="b76f1491e39a30e4f05d47d9af534982461917de" translate="yes" xml:space="preserve">
          <source>However, we can spawn a new process on &lt;code&gt;foo@computer-name&lt;/code&gt; from &lt;code&gt;bar@computer-name&lt;/code&gt;! Let&amp;rsquo;s give it a try (where &lt;code&gt;@computer-name&lt;/code&gt; is the one you see locally):</source>
          <target state="translated">然而，我们可以产生新的进程 &lt;code&gt;foo@computer-name&lt;/code&gt; 从 &lt;code&gt;bar@computer-name&lt;/code&gt; ！让我们尝试一下（其中 &lt;code&gt;@computer-name&lt;/code&gt; 是您在本地看到的名称）：</target>
        </trans-unit>
        <trans-unit id="f37bd2760f0cfed52b63715c0c0ee324352998b9" translate="yes" xml:space="preserve">
          <source>However, we can't invoke it as follows:</source>
          <target state="translated">但是,我们不能按以下方式调用它。</target>
        </trans-unit>
        <trans-unit id="693f31cc1e3b5ed02531511f77198af8ecfd7ceb" translate="yes" xml:space="preserve">
          <source>However, when an &lt;code&gt;else&lt;/code&gt; clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;rescue&lt;/code&gt; in the same &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">但是，当存在 &lt;code&gt;else&lt;/code&gt; 子句但表达式的结果与任何模式都不匹配时，将引发异常。在同一 &lt;code&gt;try&lt;/code&gt; 中，此异常不会被捕获或 &lt;code&gt;rescue&lt;/code&gt; &lt;code&gt;catch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4c77097fa9973bf214463e34dd009d5f8b620b4e" translate="yes" xml:space="preserve">
          <source>However, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.</source>
          <target state="translated">但是,当主管重启新的桶时,注册表并不知道它的存在。所以,我们会在主管中出现一个无人可以访问的空桶! 为了解决这个问题,我们想说的是,桶其实是暂时的。如果它们崩溃了,不管是什么原因,都不应该重新启动它们。</target>
        </trans-unit>
        <trans-unit id="aaa0ec2494f85dbc09c2cf136ebd0615520b8aec" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause simply fails to match:</source>
          <target state="translated">但是,如果用在卫士中,对应的子句根本无法匹配。</target>
        </trans-unit>
        <trans-unit id="194ca3b5d1e99777f19c355cce6d59f573e1d740" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause will fail to match instead of raising an error:</source>
          <target state="translated">但是,当在守卫中使用时,相应的子句将无法匹配,而不是引发错误。</target>
        </trans-unit>
        <trans-unit id="659be2322a62899199e6224a02bca5b99ed29e51" translate="yes" xml:space="preserve">
          <source>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in &lt;code&gt;:raw&lt;/code&gt; mode. The options &lt;code&gt;:read_ahead&lt;/code&gt; and &lt;code&gt;:delayed_write&lt;/code&gt; are also useful when operating on large files or working with files in tight loops.</source>
          <target state="translated">但是，您可能并不总是希望为此抽象付出代价。在这种情况下，可以使用 &lt;code&gt;:raw&lt;/code&gt; 模式打开文件。 &lt;code&gt;:read_ahead&lt;/code&gt; 和 &lt;code&gt;:delayed_write&lt;/code&gt; 选项在处理大型文件或紧密循环使用文件时也很有用。</target>
        </trans-unit>
        <trans-unit id="f893640c0df5ffde8dd2c6fee00f09a1846f23f1" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could do:</source>
          <target state="translated">但是，您的生产环境可能有特定的需求。例如，现在我们正在对路由表进行硬编码，但是在生产中，您可能需要从磁盘，另一服务中读取路由表，甚至需要联系Kubernetes等编排工具。这可以通过添加 &lt;code&gt;config/releases.exs&lt;/code&gt; 来完成。顾名思义，此文件在每次发行版开始时运行。例如，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="edea2ca00218d63cdd854e8d487aa95dfd59b53c" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">但是，您的生产环境可能有特定的需求。例如，现在我们正在对路由表进行硬编码，但是在生产中，您可能需要从磁盘，另一个服务中读取路由表，甚至需要联系Kubernetes等编排工具。这可以通过添加 &lt;code&gt;config/releases.exs&lt;/code&gt; 来完成。顾名思义，此文件在每次发行版开始时运行。例如，您可以使 &lt;code&gt;KVServer&lt;/code&gt; 端口可配置，并且仅在运行时给出该端口的值：</target>
        </trans-unit>
        <trans-unit id="5ff8ae7f9913820c4cc328c8f087e28f17634493" translate="yes" xml:space="preserve">
          <source>Hygiene in aliases</source>
          <target state="translated">别名中的卫生问题</target>
        </trans-unit>
        <trans-unit id="93c4bc3fa55a161e49f6a7b16214db78fe9e8cb2" translate="yes" xml:space="preserve">
          <source>Hygiene in imports</source>
          <target state="translated">进口产品的卫生问题</target>
        </trans-unit>
        <trans-unit id="2569893e8a4ee578273b8aabe0ac087b41daa61c" translate="yes" xml:space="preserve">
          <source>Hygiene in variables</source>
          <target state="translated">变量中的卫生</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="a8882cab0a9a900efc9a6181ff8e693783509bb4" translate="yes" xml:space="preserve">
          <source>IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.</source>
          <target state="translated">IANA提供的时区数据包括不同的UTC偏移量和时区标准偏移量的数据。</target>
        </trans-unit>
        <trans-unit id="c31397c072d7bdb4a10bd53b1d1d02f67a9c1ce2" translate="yes" xml:space="preserve">
          <source>ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus &lt;code&gt;Other_ID_Continue&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points.</source>
          <target state="translated">ID_Start字符，再加上具有非间距标记，间隔组合标记，十进制数，连接器标点符号，加的Unicode普通类字符 &lt;code&gt;Other_ID_Continue&lt;/code&gt; ，减去 &lt;code&gt;Pattern_Syntax&lt;/code&gt; 和 &lt;code&gt;Pattern_White_Space&lt;/code&gt; 代码点。</target>
        </trans-unit>
        <trans-unit id="c2ad7abf6ecd35c09ec969d6e5c5f626d2f547e0" translate="yes" xml:space="preserve">
          <source>IEx</source>
          <target state="translated">IEx</target>
        </trans-unit>
        <trans-unit id="bfd7d496a0b2c2b60b82d2300407f3ae22ad37d7" translate="yes" xml:space="preserve">
          <source>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</source>
          <target state="translated">IEx允许你以两种方式连接到另一个节点。首先,我们只有同时给当前的shell和我们想要连接的shell命名,才能连接到一个shell。</target>
        </trans-unit>
        <trans-unit id="8d4f60e469c0e609dec1269dbd88a28be0de6f53" translate="yes" xml:space="preserve">
          <source>IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function.</source>
          <target state="translated">IEx还能够在Elixir代码上设置断点,并 &quot;窥探 &quot;到正在运行的进程。这允许开发人员在给定的函数中运行一个 IEx 会话。</target>
        </trans-unit>
        <trans-unit id="de2b6b57cb35a438bfce75b9ed0826e918fad577" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx以一种热切的方式逐行评估其输入，这意味着，如果在一行的末尾看到的代码是一个完整的表达式，IEX将在那一点进行评估。此行为可能会导致已跨多行格式化的表达式产生错误，这通常是管道表达式的情况。考虑使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt;运算符的以下表达式：</target>
        </trans-unit>
        <trans-unit id="33ef030b61ea454aec0cec73bb460dee37b9c1bf" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx以一种热切的方式逐行评估其输入，这意味着，如果在一行的末尾看到的代码是一个完整的表达式，IEX将在那一点进行评估。此行为可能会导致已跨多行格式化的表达式产生错误，这通常是管道表达式的情况。考虑使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt;运算符的以下表达式：</target>
        </trans-unit>
        <trans-unit id="54729610ac51af0b9971d9467c379b62a1eb9d65" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">IEx助手包括许多与断点有关的便利。在下面它们列出了完整的模块，例如&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt;，但请记住，可以在IEx内部将其直接称为 &lt;code&gt;breaks()&lt;/code&gt; 。他们是：</target>
        </trans-unit>
        <trans-unit id="64c5dfd453f493f03e877d65639ce61fedbb37bc" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">IEx助手包括许多与断点有关的便利。在下面它们列出了完整的模块，例如&lt;a href=&quot;iex.helpers#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt;，但是请记住，可以在IEx内部将它们直接称为 &lt;code&gt;breaks()&lt;/code&gt; 。他们是：</target>
        </trans-unit>
        <trans-unit id="8f54609a357af7036d3341f02f1a23c3b68eda40" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx提供了很多帮手。可以通过在外壳中键入 &lt;code&gt;h()&lt;/code&gt; 或作为&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块的文档来访问它们。</target>
        </trans-unit>
        <trans-unit id="0c364f03a852b53d4a7a502b57654a110b1cce03" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;iex.helpers&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx提供了很多帮手。可以通过在外壳中键入 &lt;code&gt;h()&lt;/code&gt; 或作为&lt;a href=&quot;iex.helpers&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块的文档来访问它们。</target>
        </trans-unit>
        <trans-unit id="9fbe836e228d1004a30dd6875de1a22111586f81" translate="yes" xml:space="preserve">
          <source>IEx will also color inspected expressions using the &lt;code&gt;:syntax_colors&lt;/code&gt; option. Such can be disabled with:</source>
          <target state="translated">IEx还将使用 &lt;code&gt;:syntax_colors&lt;/code&gt; 选项为检查的表达式着色。可以通过以下方式禁用此功能：</target>
        </trans-unit>
        <trans-unit id="f04ddcbeb347ea8a966dd445a3b79f8b70364e41" translate="yes" xml:space="preserve">
          <source>IEx.Helpers</source>
          <target state="translated">IEx.Helpers</target>
        </trans-unit>
        <trans-unit id="c73133afe4ab05b736cba2f1d5c857bb84e93876" translate="yes" xml:space="preserve">
          <source>IEx.Info</source>
          <target state="translated">IEx.Info</target>
        </trans-unit>
        <trans-unit id="569138c9005aad9a2a791088d7d0e2cc45e36512" translate="yes" xml:space="preserve">
          <source>IEx.Info &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">IEx.Info&lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40b4a890c64ba73558ed867016246c3ef597f257" translate="yes" xml:space="preserve">
          <source>IEx.Info.info (1)</source>
          <target state="translated">IEx.Info.info (1)</target>
        </trans-unit>
        <trans-unit id="5cbc0090e36bb601365004561eedb21e95b78b48" translate="yes" xml:space="preserve">
          <source>IEx.Info.t (0)</source>
          <target state="translated">IEx.Info.t (0)</target>
        </trans-unit>
        <trans-unit id="17bd8ed5133e3af7e767eaf3cc19dbec1b565da7" translate="yes" xml:space="preserve">
          <source>IEx.Pry</source>
          <target state="translated">IEx.Pry</target>
        </trans-unit>
        <trans-unit id="785a031a616ad88bcb1b2cd5dbbc60681be53958" translate="yes" xml:space="preserve">
          <source>IEx.Server</source>
          <target state="translated">IEx.Server</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="5b2f49f5a657a5ef736fa25eed6851c434d0dac3" translate="yes" xml:space="preserve">
          <source>IO and the file system</source>
          <target state="translated">IO和文件系统</target>
        </trans-unit>
        <trans-unit id="bbc4e8881ad6a75f10bb6ea9bff4b74783ee6ecc" translate="yes" xml:space="preserve">
          <source>IO data</source>
          <target state="translated">IO数据</target>
        </trans-unit>
        <trans-unit id="ec099c7a428e418929af391ebb305d925a77dc9c" translate="yes" xml:space="preserve">
          <source>IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.</source>
          <target state="translated">IO数据之所以存在,是因为经常需要对较小块的二进制文件进行许多追加操作,以便创建一个更大的二进制文件。然而,在Erlang和Elixir中,连接二进制文件会将连接后的二进制文件复制到一个新的二进制文件中。</target>
        </trans-unit>
        <trans-unit id="9d9b6408eac92df9305226b9c32fd45d1762d634" translate="yes" xml:space="preserve">
          <source>IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.</source>
          <target state="translated">IO数据是一种数据类型,在某些情况下可以作为二进制数据更有效的替代。</target>
        </trans-unit>
        <trans-unit id="370428fc749a05dd70935487b7d4064e7d83c3fb" translate="yes" xml:space="preserve">
          <source>IO devices</source>
          <target state="translated">IO设备</target>
        </trans-unit>
        <trans-unit id="d2ef1a7a2a7b43d0fc955e96e915a7dad9160987" translate="yes" xml:space="preserve">
          <source>IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt;&lt;code&gt;:file.position/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">IO设备保持其位置，这意味着随后对任何读取或写入功能的调用将从上次访问该设备的位置开始。可以使用&lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt; &lt;code&gt;:file.position/2&lt;/code&gt; &lt;/a&gt;函数更改文件的位置。</target>
        </trans-unit>
        <trans-unit id="b5cbeaffeb75ad57a2191d67bc818e573faa6d01" translate="yes" xml:space="preserve">
          <source>IO.ANSI</source>
          <target state="translated">IO.ANSI</target>
        </trans-unit>
        <trans-unit id="0089fd381dd7dfd8d488c15134d255be01885915" translate="yes" xml:space="preserve">
          <source>IO.Stream</source>
          <target state="translated">IO.Stream</target>
        </trans-unit>
        <trans-unit id="8139a358a2645d3cf610141a9bce4c7312be5781" translate="yes" xml:space="preserve">
          <source>IO.StreamError</source>
          <target state="translated">IO.StreamError</target>
        </trans-unit>
        <trans-unit id="3d7d3441a8eff66aaa0f0faa36a8a05b3a785de8" translate="yes" xml:space="preserve">
          <source>IO.StreamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">IO.StreamError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="77802d65267b1d073f6e93dafd03f4d02d064153" translate="yes" xml:space="preserve">
          <source>IO.inspect/2</source>
          <target state="translated">IO.inspect/2</target>
        </trans-unit>
        <trans-unit id="c1f9284c3367b68f5c96129104a3a9d0f4c9d187" translate="yes" xml:space="preserve">
          <source>Identifiers in Elixir are case sensitive.</source>
          <target state="translated">Elixir中的标识符是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="057deff008e9d8f83cd686c8b17c3d4c02169546" translate="yes" xml:space="preserve">
          <source>Identifying functions and documentation</source>
          <target state="translated">确定职能和文件</target>
        </trans-unit>
        <trans-unit id="537a4055c25749aea0df46647a3ecdd449be90bb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.</source>
          <target state="translated">如果&lt;a href=&quot;#after_suite/1&quot;&gt; &lt;code&gt;after_suite/1&lt;/code&gt; &lt;/a&gt;被多次调用，则回调将以相反的顺序被调用。换句话说，最后一个回调集将是第一个被调用的集。</target>
        </trans-unit>
        <trans-unit id="c2d101d3a59aa29536cff11d9f78612ab949d729" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:code_change/3&quot;&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/a&gt; raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</source>
          <target state="translated">如果&lt;a href=&quot;#c:code_change/3&quot;&gt; &lt;code&gt;code_change/3&lt;/code&gt; &lt;/a&gt;引发代码更改失败，则循环将继续其先前的状态。因此，此回调通常不包含副作用。</target>
        </trans-unit>
        <trans-unit id="50441c2fc5e3f35b8a96fa96c6320ab57738cfc1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; is invoked and there are no names, a release using the application name and default values is assembled.</source>
          <target state="translated">如果调用了&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;且没有名称，则使用应用程序名称和默认值的发行版将被汇编。</target>
        </trans-unit>
        <trans-unit id="eea2e17ca11f5963667c13624c09484704b91de8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, without a name, is invoked and there are multiple names, an error will be raised unless you set &lt;code&gt;default_release: NAME&lt;/code&gt; at the root of your project configuration.</source>
          <target state="translated">如果调用了没有名称的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;，并且有多个名称，除非您在项目配置的根目录中设置 &lt;code&gt;default_release: NAME&lt;/code&gt; ，否则将引发错误。</target>
        </trans-unit>
        <trans-unit id="1f1a0f874c702790d228021c47f6f58e4a98062d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt; is called before the application is loaded, the application environment values specified in the &lt;code&gt;.app&lt;/code&gt; file will override the ones previously set.</source>
          <target state="translated">如果在加载应用程序之前调用&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;.app&lt;/code&gt; 文件中指定的应用程序环境值将覆盖先前设置的值。</target>
        </trans-unit>
        <trans-unit id="9f537d260ef97992e561be1422ea408f4c00b527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:abort&lt;/code&gt;, the runtime system aborts producing a core dump, if that is enabled in the operating system.</source>
          <target state="translated">如果 &lt;code&gt;:abort&lt;/code&gt; ，则运行时系统将中止生成核心转储（如果在操作系统中启用了该核心转储）。</target>
        </trans-unit>
        <trans-unit id="e351673ad711ca575120b265bcb522e29ffb1ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:all&lt;/code&gt; is given, &lt;code&gt;:eof&lt;/code&gt; is never returned, but an empty string in case the device has reached EOF.</source>
          <target state="translated">如果给定 &lt;code&gt;:all&lt;/code&gt; ，则 &lt;code&gt;:eof&lt;/code&gt; 将永远不会返回，但如果设备已到达EOF，则为空字符串。</target>
        </trans-unit>
        <trans-unit id="664fc2657c2121b52010aad0e4fd4b13a3191a1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:build_per_environment&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it will create a new build per environment:</source>
          <target state="translated">如果 &lt;code&gt;:build_per_environment&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，它将根据环境创建一个新的构建：</target>
        </trans-unit>
        <trans-unit id="1cd0a5e0adcba1255cdaf72cd16d9cb0159c0426" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:discard&lt;/code&gt; is given in &lt;code&gt;leftover&lt;/code&gt;, the last chunk is discarded unless it has exactly &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果 &lt;code&gt;:discard&lt;/code&gt; 在 &lt;code&gt;leftover&lt;/code&gt; 部分中给出，则最后一个块将被丢弃，除非它具有完全 &lt;code&gt;count&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4ad666f68aa0c1c3e9b90d4547788465ffe950b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:stdio&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">如果 &lt;code&gt;:stdio&lt;/code&gt; 是Unicode设备，则 &lt;code&gt;count&lt;/code&gt; 表示要检索的Unicode代码点的数量。否则， &lt;code&gt;count&lt;/code&gt; 是要检索的原始字节数。</target>
        </trans-unit>
        <trans-unit id="1c37a0fde2ecc757cae6c2a1e1d8b99469865d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@behaviour&lt;/code&gt; has been defined, &lt;code&gt;defoverridable&lt;/code&gt; can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to &lt;code&gt;defoverridable&lt;/code&gt; will be marked as overridable.</source>
          <target state="translated">如果 &lt;code&gt;@behaviour&lt;/code&gt; 已定义， &lt;code&gt;defoverridable&lt;/code&gt; 也可以与一个模块作为参数来调用。从调用之上的行为到 &lt;code&gt;defoverridable&lt;/code&gt; 的所有已实现的回调将被标记为可重写。</target>
        </trans-unit>
        <trans-unit id="0535dd7868286893881566e917783949810a614d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is a negative number, it starts counting from the back to the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 是一个负数，则从 &lt;code&gt;enumerable&lt;/code&gt; 开始计数。</target>
        </trans-unit>
        <trans-unit id="128e0031d4c1374c0210ba717199fde5a91caf98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is greater than the size of the rest of the &lt;code&gt;enumerable&lt;/code&gt;, then this function will reverse the rest of the enumerable.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 大于其余 &lt;code&gt;enumerable&lt;/code&gt; 的大小，则此函数将反转其余可枚举的大小。</target>
        </trans-unit>
        <trans-unit id="64a4a2dc00ee57596c01d8e55272d16ee1731764" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is not provided, &lt;code&gt;nil&lt;/code&gt; is used.</source>
          <target state="translated">如果未提供 &lt;code&gt;default&lt;/code&gt; ，则使用 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4804fe88251de4efebed7a3b7f7ec9b900a0c7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is a PID, it must be the PID of a local process, dead or alive. If &lt;code&gt;dest&lt;/code&gt; is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</source>
          <target state="translated">如果 &lt;code&gt;dest&lt;/code&gt; 是PID，则它必须是本地进程的PID，无论该进程是死的还是活动的。如果 &lt;code&gt;dest&lt;/code&gt; 是原子，则它必须是在交付时查找的注册过程的名称。如果名称不涉及进程，则不会产生错误。</target>
        </trans-unit>
        <trans-unit id="2650eb70496be023811483cdbe9dcf267336d48b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">如果 &lt;code&gt;flag&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则打开监视。如果 &lt;code&gt;flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则关闭监视。</target>
        </trans-unit>
        <trans-unit id="f1c832ccf95731edf1d63b91b33e2d1fe522cd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, acc}&lt;/code&gt; the reduction is halted and the function returns &lt;code&gt;acc&lt;/code&gt;. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;fun&lt;/code&gt; 返回 &lt;code&gt;{:halt, acc}&lt;/code&gt; 则减少停止，函数返回 &lt;code&gt;acc&lt;/code&gt; 。否则，如果可枚举已用尽，该函数将返回最后一个 &lt;code&gt;{:cont, acc}&lt;/code&gt; 的累加器。</target>
        </trans-unit>
        <trans-unit id="448b014151f38127b8e5f6db3c5223d75cfbeb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index_range.last&lt;/code&gt; is out of bounds, then it is assigned as the index of the last element.</source>
          <target state="translated">如果 &lt;code&gt;index_range.last&lt;/code&gt; 超出范围，则将其指定为最后一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="f65e2abd74ff7207f89b8e63ffae32b6537b7ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty string.</source>
          <target state="translated">如果完全没有传递 &lt;code&gt;joiner&lt;/code&gt; ，则默认为空字符串。</target>
        </trans-unit>
        <trans-unit id="44dafce589cc2560c530b258260863b84a7ad4e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to the empty binary.</source>
          <target state="translated">如果完全没有传递 &lt;code&gt;joiner&lt;/code&gt; ，则默认为空二进制。</target>
        </trans-unit>
        <trans-unit id="3055a00c41cda5c6ac1a36cb205d2baa4d5b0fc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a91338d96953ddc227939bd5311d00c34a7770ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则会引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e25538be406057a69443efa5940b2d432b4b6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, lazily evaluates &lt;code&gt;fun&lt;/code&gt; and returns its result.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则懒惰地评估 &lt;code&gt;fun&lt;/code&gt; 并返回其结果。</target>
        </trans-unit>
        <trans-unit id="0a81a69a6fcff94ffbea2c950485431c58d11511" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, return the default value (&lt;code&gt;nil&lt;/code&gt; if no default value).</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回默认值（如果没有默认值，则返回 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="670e493657f6e1800d6af7018ec7631dafc42777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是不存在 &lt;code&gt;keywords&lt;/code&gt; ，一个&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="ab5d096dab446f6e25ac353134ecfc0c4cc20f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是不存在 &lt;code&gt;keywords&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="0aa66d148b2ac7a0571085f5d2ee7a7853bca2a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="b02bea90648629b86487eddfaee7cd58979250c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="0ec4f9859acc852c12bc2e32bac9f65f8ba4fa9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在 &lt;code&gt;map&lt;/code&gt; ，然后它的价值 &lt;code&gt;value&lt;/code&gt; 返回。否则，返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0f7c37563cdb97d23ddfed9427894d235eabfd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在 &lt;code&gt;map&lt;/code&gt; ，然后它的价值 &lt;code&gt;value&lt;/code&gt; 返回。否则，将评估 &lt;code&gt;fun&lt;/code&gt; 并返回其结果。</target>
        </trans-unit>
        <trans-unit id="fb8ab7d4cb46594f50af6648151d0e98d320b934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The default value will not be passed through the update function.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 中存在 &lt;code&gt;key&lt;/code&gt; ，则将现有值传递给 &lt;code&gt;fun&lt;/code&gt; ,并将其结果用作 &lt;code&gt;key&lt;/code&gt; 的更新值。如果 &lt;code&gt;map&lt;/code&gt; 中不存在 &lt;code&gt;key&lt;/code&gt; ，则 &lt;code&gt;default&lt;/code&gt; 插入为 &lt;code&gt;key&lt;/code&gt; 的值。默认值不会通过更新函数传递。</target>
        </trans-unit>
        <trans-unit id="d36aa454c42946e2c34ba9f399b287cb43ac6ce3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 中存在 &lt;code&gt;key&lt;/code&gt; ，则将现有值传递给 &lt;code&gt;fun&lt;/code&gt; ,并将其结果用作 &lt;code&gt;key&lt;/code&gt; 的更新值。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="d4150f660167317dcaba9e8183ce3412c0294207" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The initial value will not be passed through the update function.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在具有值 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; ，则 &lt;code&gt;fun&lt;/code&gt; 以参数 &lt;code&gt;value&lt;/code&gt; 调用，其结果用作 &lt;code&gt;key&lt;/code&gt; 的新值。如果 &lt;code&gt;map&lt;/code&gt; 中不存在 &lt;code&gt;key&lt;/code&gt; ，则将 &lt;code&gt;initial&lt;/code&gt; 作为 &lt;code&gt;key&lt;/code&gt; 的值插入。初始值将不会通过更新函数传递。</target>
        </trans-unit>
        <trans-unit id="75a038e3ca604bf73652a1d5909bc26acc1aa307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 出现在具有值 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; ，则会使用参数 &lt;code&gt;value&lt;/code&gt; 调用 &lt;code&gt;fun&lt;/code&gt; ，并且将其结果用作 &lt;code&gt;key&lt;/code&gt; 的新值。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ，一个&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 异常&lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="15c9a821a2b57a999e05676dbebd003979e0547e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是存在于 &lt;code&gt;map&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;{value, new_map}&lt;/code&gt; 返回其中 &lt;code&gt;new_map&lt;/code&gt; 是去除的结果 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;map&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{default, map}&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="9a0d4a917aec182ae2652ab6e3733862784d7df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 是存在于 &lt;code&gt;map&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;{value, new_map}&lt;/code&gt; 返回其中 &lt;code&gt;new_map&lt;/code&gt; 是去除的结果 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;map&lt;/code&gt; 。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{fun_result, map}&lt;/code&gt; 返回，其中 &lt;code&gt;fun_result&lt;/code&gt; 是应用的结果 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be3edc2b3eeca76a785d6024f2cdb09fb2dfde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 存在于 &lt;code&gt;map&lt;/code&gt; 中，值为 &lt;code&gt;value&lt;/code&gt; ，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57db7be79a09b897065af1bdf410edac419b10e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 存在于 &lt;code&gt;map&lt;/code&gt; 中，值为 &lt;code&gt;value&lt;/code&gt; ，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，将评估 &lt;code&gt;fun&lt;/code&gt; 并返回其结果。</target>
        </trans-unit>
        <trans-unit id="bd7fdb0ce9bd64671ab1efe4609aaa8d9539ced9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 中存在 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;{value, new_map}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是key的值， &lt;code&gt;new_map&lt;/code&gt; 是从 &lt;code&gt;map&lt;/code&gt; 中删除 &lt;code&gt;key&lt;/code&gt; 的结果。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{default, map}&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="6833696c36f33582651db81f8d535239158d24e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 中存在 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;{value, new_map}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是key的值， &lt;code&gt;new_map&lt;/code&gt; 是从 &lt;code&gt;map&lt;/code&gt; 中删除 &lt;code&gt;key&lt;/code&gt; 的结果。如果 &lt;code&gt;key&lt;/code&gt; 不存在于 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;{fun_result, map}&lt;/code&gt; 返回，其中 &lt;code&gt;fun_result&lt;/code&gt; 是应用的结果 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="022b1446733b2fda7810ec19631252125e1aa84b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keys&lt;/code&gt; contains keys that are not in &lt;code&gt;map&lt;/code&gt;, they're simply ignored.</source>
          <target state="translated">如果 &lt;code&gt;keys&lt;/code&gt; 包含不在 &lt;code&gt;map&lt;/code&gt; 中的键，则将它们简单地忽略。</target>
        </trans-unit>
        <trans-unit id="9ec06751513a7783f95f06711b8c297f9eb8290a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keywords2&lt;/code&gt; has duplicate keys, the given function will be invoked for each matching pair in &lt;code&gt;keywords1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;keywords2&lt;/code&gt; 有重复的键，给定的功能将被调用用于每个匹配对 &lt;code&gt;keywords1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cda0fc7deb1f2ca2778dbdfbc7cd47a0b34753a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;{:EXIT, pid}&lt;/code&gt;, it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.</source>
          <target state="translated">如果 &lt;code&gt;kind&lt;/code&gt; 为 &lt;code&gt;{:EXIT, pid}&lt;/code&gt; ，则不会生成堆栈跟踪，因为此类退出将作为没有堆栈跟踪的消息检索。</target>
        </trans-unit>
        <trans-unit id="bfc34d2fd024a4826aee6c45876a01c2984997a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; ；否则为false。否则返回 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bbd966d4ee1229ab0c4a3f43a8067bf69d0b551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;left&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ；否则为false。否则返回 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e10ea7dbc53bb25e7807935c07de908ca7820b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is an integer, that's the indentation appended to line breaks whenever they occur. If the level is &lt;code&gt;:cursor&lt;/code&gt;, the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is &lt;code&gt;:reset&lt;/code&gt;, it is set back to 0.</source>
          <target state="translated">如果 &lt;code&gt;level&lt;/code&gt; 是一个整数，则是每当换行符出现时缩进的缩进。如果级别为 &lt;code&gt;:cursor&lt;/code&gt; ，则文档中&amp;ldquo;光标&amp;rdquo;的当前位置将成为嵌套。如果级别为 &lt;code&gt;:reset&lt;/code&gt; ，则将其设置回0。</target>
        </trans-unit>
        <trans-unit id="b432fb4f2fd1db528a9d6842cc318272507dcd19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含 &lt;code&gt;key&lt;/code&gt; ，则返回相应的值。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="1bef2ee214360ef957032a298b1eb3e6a4177ceb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; then its value is returned in the shape of &lt;code&gt;{:ok, value}&lt;/code&gt;. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含给定 &lt;code&gt;key&lt;/code&gt; 则其值将以 &lt;code&gt;{:ok, value}&lt;/code&gt; 。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="167313c87cdf050139328eaa55e0c8e46388fa2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含具有值 &lt;code&gt;value&lt;/code&gt; 的给定 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6733d65c27213cccbcddb83b9fc95fccaae0b10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;map&lt;/code&gt; 包含给定的 &lt;code&gt;key&lt;/code&gt; ，则返回相应的值。如果 &lt;code&gt;map&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则会引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="35d7fd154ea4c9faf69570f99b8c5aa4a3ac9ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 之初 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9b141a234955b46f94cdff6fb97f75b39d6831d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 在结束 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0185f097241d680d296e419b968e47a3c5201c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 之初 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e72270cb672e9e4c9f071af85be8440eb64c674" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;match&lt;/code&gt; 是 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，此功能将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常：出现这种情况是因为这个函数替换&lt;strong&gt;所有&lt;/strong&gt;的出现 &lt;code&gt;match&lt;/code&gt; 在结束 &lt;code&gt;string&lt;/code&gt; ，这是不可能取代&amp;ldquo;多&amp;rdquo;的出现 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9bdc0c8aedc4a0581ea9ca9cb9ad9a4fe54a0d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modifiers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</source>
          <target state="translated">如果 &lt;code&gt;modifiers&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，则返回唯一的整数（可以是正数或负数）。可以传递其他修饰符来更改返回整数的属性：</target>
        </trans-unit>
        <trans-unit id="ad9eab2323c428de698fefc4bfc22b40c45681ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is an Erlang module (as opposed to an Elixir module), this function always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;module&lt;/code&gt; 是Erlang模块（而不是Elixir模块），则此函数始终返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de03926a3208aa38b1bdc68fa4dd867a9992c7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;monitor_ref&lt;/code&gt; is a reference which the calling process obtained by calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;monitor/1&lt;/code&gt;&lt;/a&gt;, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">如果 &lt;code&gt;monitor_ref&lt;/code&gt; 是通过调用&lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;monitor/1&lt;/code&gt; &lt;/a&gt;获得的调用过程的引用，则该监视将关闭。如果监视已关闭，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="a32f1f48118a9d4a2686cda59499e6684c476f2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an atom, it just calls &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; with the atom as the first argument and &lt;code&gt;[]&lt;/code&gt; as the second argument.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是一个原子，则只调用&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;，并将该原子作为第一个参数，将 &lt;code&gt;[]&lt;/code&gt; 作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="e2591f3e8296742e9e675974bb3bfcb35d27b411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an exception struct, it is raised as is.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是异常结构，则按原样引发它。</target>
        </trans-unit>
        <trans-unit id="cefdb1ca1740aca5f5451a4dad984640e42d15f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是其他任何东西，则 &lt;code&gt;raise&lt;/code&gt; 将失败，并出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="2f440776b416dcca31a3b5404a0ec8e4143798ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">如果 &lt;code&gt;msg&lt;/code&gt; 是其他任何东西，则 &lt;code&gt;raise&lt;/code&gt; 将失败，并出现&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="737a631e71f8710e641fef02c56115e74ed17ea3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="bc62758814a2f1d1d281641eed97d732d6ff6ae5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned.</source>
          <target state="translated">如果 &lt;code&gt;node&lt;/code&gt; 不存在，则返回无用的PID。</target>
        </trans-unit>
        <trans-unit id="63d9a61082e21b3845e40428cb3a08f3ea73ce2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;enumerable&lt;/code&gt; is directly converted to a list, without &lt;code&gt;fun&lt;/code&gt; being ever applied.</source>
          <target state="translated">如果 &lt;code&gt;nth&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，然后 &lt;code&gt;enumerable&lt;/code&gt; 直接转换到一个列表，没有 &lt;code&gt;fun&lt;/code&gt; 被采用过。</target>
        </trans-unit>
        <trans-unit id="2840ae873ffd42facf8e147450543acef64559c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; exists and is a symlink, returns &lt;code&gt;{:ok, target}&lt;/code&gt;, otherwise returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 存在并且是符号链接，则返回 &lt;code&gt;{:ok, target}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f340b85ba7c5a6e0ec3e07ae4245f7c6097e6db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是字符串，则它将用作&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; 中&lt;/a&gt;的路径。如果 &lt;code&gt;path&lt;/code&gt; 是字符串的列表，它将被接合（参见&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt;），并且结果将被用作内部的路径&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c154c595d1b4a01fb083386caa6ace778641f9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;path#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是字符串，则它将用作&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; 中&lt;/a&gt;的路径。如果 &lt;code&gt;path&lt;/code&gt; 是字符串的列表，它将被接合（参见&lt;a href=&quot;path#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt;），并且结果将被用作内部的路径&lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30981afdf653766b4f2d8e17a8e76f8900fd6c71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored. See also &lt;a href=&quot;#relative_to/2&quot;&gt;&lt;code&gt;relative_to/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 已经是绝对路径，则 &lt;code&gt;relative_to&lt;/code&gt; 将被忽略。另请参见&lt;a href=&quot;#relative_to/2&quot;&gt; &lt;code&gt;relative_to/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4964bfcbfec35a641632c64af60eb6aaa93a561b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; points to a file, prints its full path.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 指向文件，则打印其完整路径。</target>
        </trans-unit>
        <trans-unit id="4b1a93e9b2e0e773dda7a088ec139c68425c9cc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_wildcard&lt;/code&gt; is a wildcard, then all the files matching that wildcard will be imported; if no file matches the wildcard, no errors are raised. If &lt;code&gt;path_or_wildcard&lt;/code&gt; is not a wildcard but a path to a single file, then that file is imported; in case the file doesn't exist, an error is raised.</source>
          <target state="translated">如果 &lt;code&gt;path_or_wildcard&lt;/code&gt; 是通配符，则将导入与该通配符匹配的所有文件；否则，将导入该通配符。如果没有文件与通配符匹配，则不会引发任何错误。如果 &lt;code&gt;path_or_wildcard&lt;/code&gt; 不是通配符而是单个文件的路径，则将导入该文件；否则，将导入该文件。如果文件不存在，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="4ed36549216e7c96c0405d66d46c768efd40ee4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is not trapping exits, &lt;code&gt;pid&lt;/code&gt; will exit with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 未捕获，则 &lt;code&gt;pid&lt;/code&gt; 将以给定的 &lt;code&gt;reason&lt;/code&gt; 退出。</target>
        </trans-unit>
        <trans-unit id="633950331a76abae7c27012953c6b5ce717504f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; 并传递到 &lt;code&gt;pid&lt;/code&gt; 的消息队列。</target>
        </trans-unit>
        <trans-unit id="edb5e8ad174fd02444bbcb56b3f2079cf73580c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix&lt;/code&gt; is an empty list, it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;prefix&lt;/code&gt; 是一个空列表，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26bd0886bea64b0650f1573c9fd139f06c9e5d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is neither &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, nor &lt;code&gt;{:shutdown, term}&lt;/code&gt; an error is logged.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 既不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 也不是 &lt;code&gt;{:shutdown, term}&lt;/code&gt; ，则将记录错误。</target>
        </trans-unit>
        <trans-unit id="5c120fe241858b080c2215e59c9d1dfe3c97d43f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:kill&lt;/code&gt;, that is if &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;pid&lt;/code&gt; which will unconditionally exit with reason &lt;code&gt;:killed&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是原子 &lt;code&gt;:kill&lt;/code&gt; ，即调用 &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; ，则将不可陷阱的退出信号发送到 &lt;code&gt;pid&lt;/code&gt; ，该信号将无条件退出，原因为 &lt;code&gt;:killed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72ae981d0ae09b809a5b5a5aa46cd4ec885a9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;pid&lt;/code&gt; will not exit (unless &lt;code&gt;pid&lt;/code&gt; is the calling process, in which case it will exit with the reason &lt;code&gt;:normal&lt;/code&gt;). If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是原子 &lt;code&gt;:normal&lt;/code&gt; ，则 &lt;code&gt;pid&lt;/code&gt; 将不会退出（除非 &lt;code&gt;pid&lt;/code&gt; 是调用进程，在这种情况下，它将以原因 &lt;code&gt;:normal&lt;/code&gt; 退出）。如果正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; 并传递到其消息队列。</target>
        </trans-unit>
        <trans-unit id="0983db92616650bea49a21e4bb3960c0964601e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a regular expression, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; matches right.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 是一个正则表达式，则在 &lt;code&gt;left&lt;/code&gt; 与right匹配时返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d39df5af32cb5fb2bbe1045964270d68e1f1f5a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a string, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; contains &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 是一个字符串，则在 &lt;code&gt;left&lt;/code&gt; 包含 &lt;code&gt;right&lt;/code&gt; 时返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="def9dbc5ab56f1b825b6729ff4b5f2b1cf2751f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or &lt;code&gt;{:ok, keywords | map}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">如果 &lt;code&gt;setup_all&lt;/code&gt; 或 &lt;code&gt;setup&lt;/code&gt; 返回关键字列表，地图或 &lt;code&gt;{:ok, keywords | map}&lt;/code&gt; ，关键字列表或映射将合并到当前上下文中，并将在所有后续 &lt;code&gt;setup_all&lt;/code&gt; ， &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 本身中可用。</target>
        </trans-unit>
        <trans-unit id="427abb795faa00170a2a73c64fef9d4e09adf4d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or a tuple in the shape of &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">如果 &lt;code&gt;setup_all&lt;/code&gt; 或 &lt;code&gt;setup&lt;/code&gt; 以 &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt; 的形式返回关键字列表，映射或元组。map（）}，关键字列表或映射将合并到当前上下文中，并将在所有后续 &lt;code&gt;setup_all&lt;/code&gt; ， &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 本身中可用。</target>
        </trans-unit>
        <trans-unit id="977e9939903f7075b75909cc132a74bc274c1bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a directory, or a symbolic link to it, then &lt;code&gt;destination&lt;/code&gt; must be an existent &lt;code&gt;directory&lt;/code&gt; or a symbolic link to one, or a path to a non-existent directory.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 是目录，或指向该目录的符号链接，则 &lt;code&gt;destination&lt;/code&gt; 必须是一个存在的 &lt;code&gt;directory&lt;/code&gt; 或者是指向该目录的符号链接，或者是一个不存在的目录的路径。</target>
        </trans-unit>
        <trans-unit id="1031bcdd561dcecee641f002ce883c7af7e61139" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a file or a symbolic link to it, &lt;code&gt;destination&lt;/code&gt; must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 是文件或指向它的符号链接，则 &lt;code&gt;destination&lt;/code&gt; 必须是到现有文件的路径，到一个文件的符号链接或到不存在的文件的路径。</target>
        </trans-unit>
        <trans-unit id="e57c5ea9358fe4a917bdf2d9fa6f002a7ca491dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果以二进制以外的任何方式引用了 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;length&lt;/code&gt; 引用，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="fc6be87bc2a88ec11feb6fb3046cd38c5b7a4a35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果以二进制以外的任何方式引用了 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;length&lt;/code&gt; ，则引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="148baaf20a5501cf402aa842127aa44f861d748c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效要求，则引发&lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd707d6ea9c236adf3d2d26891903697d910f532" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效要求，则会引发&lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8f525d0b692b55f071ed6b31ea8e88fb78dc738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效版本，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f9f03b1dcc9dbff5dcc7644074dd977a2959ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;string&lt;/code&gt; 是无效版本，则会引发&lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a1f85d96ca473515ee41dccc4b5c470d6806e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">如果 &lt;code&gt;target&lt;/code&gt; 已经存在并且内容不相同，则要求用户确认。</target>
        </trans-unit>
        <trans-unit id="ae363da5635ac26a38468a274fa68594bffd7223" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is already a list, it returns the list. If &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns an empty list.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 已经是列表，则返回列表。如果 &lt;code&gt;term&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="c189d5b72f733627440a207910c642f9ff77e60b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;%URI{}&lt;/code&gt; struct is given to this function, this function returns it unmodified.</source>
          <target state="translated">如果将 &lt;code&gt;%URI{}&lt;/code&gt; 结构给予此函数，则此函数将其返回为未经修改的结构。</target>
        </trans-unit>
        <trans-unit id="abcc9ba322766c6ecd47929cf37e2de456cad2b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;:skip&lt;/code&gt; tag is found in &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;{:skipped, message}&lt;/code&gt; is returned if the test has been left after the &lt;code&gt;exclude&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt; filters. Otherwise &lt;code&gt;{:exclude, message}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;:skip&lt;/code&gt; 中发现标签 &lt;code&gt;tags&lt;/code&gt; ， &lt;code&gt;{:skipped, message}&lt;/code&gt; 如果测试已经离开后，返回 &lt;code&gt;exclude&lt;/code&gt; 和 &lt;code&gt;include&lt;/code&gt; 过滤器。否则返回 &lt;code&gt;{:exclude, message}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae7e1652eb18779b4dcf4919c203ef71000bcfb9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;config/runtime.exs&lt;/code&gt; exists, it will be copied to your release and executed early in the boot process, when only Elixir and Erlang's main applications have been started. Once the configuration is loaded, the Erlang system will be restarted (within the same Operating System process) and the new configuration will take place.</source>
          <target state="translated">如果存在 &lt;code&gt;config/runtime.exs&lt;/code&gt; ，则仅当Elixir和Erlang的主要应用程序已启动时，它将被复制到您的发行版中并在引导过程的早期执行。加载配置后，将重新启动Erlang系统（在相同的操作系统过程中），然后进行新配置。</target>
        </trans-unit>
        <trans-unit id="9cb5769774bfa8aa4c65da1e51375f078f53a47d" translate="yes" xml:space="preserve">
          <source>If a byte has 8 bits, what happens if we pass a size of 1 bit?</source>
          <target state="translated">如果一个字节有8位,如果我们传递一个大小为1位的字节会怎样?</target>
        </trans-unit>
        <trans-unit id="0ac581e270299e95270be44edc11d5d78635bdbb" translate="yes" xml:space="preserve">
          <source>If a callback is given, it is invoked for each received message.</source>
          <target state="translated">如果给定了一个回调,那么每收到一个消息就会调用它。</target>
        </trans-unit>
        <trans-unit id="9510d4ce0d205517cf9f92994b15bfbfe1510aa1" translate="yes" xml:space="preserve">
          <source>If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen).</source>
          <target state="translated">如果一个实现给定行为的回调模块没有导出该行为定义的所有函数和宏,在编译过程中会通过警告通知用户(不会发生错误)。</target>
        </trans-unit>
        <trans-unit id="69b52804cd17d7f8a0689854f3222713a2e4c149" translate="yes" xml:space="preserve">
          <source>If a child specification with the specified ID already exists, &lt;code&gt;child_spec&lt;/code&gt; is discarded and this function returns an error with &lt;code&gt;:already_started&lt;/code&gt; or &lt;code&gt;:already_present&lt;/code&gt; if the corresponding child process is running or not, respectively.</source>
          <target state="translated">如果具有指定ID的子规范已经存在， &lt;code&gt;child_spec&lt;/code&gt; 废弃child_spec，并且如果相应的子进程正在运行或未运行，则此函数分别返回带有 &lt;code&gt;:already_started&lt;/code&gt; 或 &lt;code&gt;:already_present&lt;/code&gt; 的错误。</target>
        </trans-unit>
        <trans-unit id="624738a0046889600ef5bfdcc03d5da8090ab0e9" translate="yes" xml:space="preserve">
          <source>If a cookie option was given, we compare it with the contents of the file (if any), and ask the user if they want to override.</source>
          <target state="translated">如果给了一个cookie选项,我们会将其与文件内容(如果有的话)进行比较,并询问用户是否要覆盖。</target>
        </trans-unit>
        <trans-unit id="4e2890f26410463009016ad753f613992362cbef" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes &lt;code&gt;callback&lt;/code&gt;. &lt;code&gt;callback&lt;/code&gt; must be a function that takes two arguments: &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;. The callback should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果目标中已经存在一个文件，它将调用 &lt;code&gt;callback&lt;/code&gt; 。 &lt;code&gt;callback&lt;/code&gt; 必须是一个带有两个参数的函数： &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 。如果现有文件应被覆盖，则回调应返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cabdc7b8c3d548d6762d990a45e3c0db4093b48f" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes a callback which should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten, &lt;code&gt;false&lt;/code&gt; otherwise. The callback defaults to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果目标中已存在文件，则它将调用一个回调，如果应覆盖现有文件，则该回调应返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。回调默认返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f5282b08680f8cf98b1cf98c1763e902d8a8cf1" translate="yes" xml:space="preserve">
          <source>If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">如果提供了功能，则将创建设备并将其发送到该功能。函数返回时，设备将关闭。最终结果将是带有 &lt;code&gt;:ok&lt;/code&gt; 的元组和函数的结果。</target>
        </trans-unit>
        <trans-unit id="d38f06a2f29af4b9a58ad54b574b4b65c78e3313" translate="yes" xml:space="preserve">
          <source>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</source>
          <target state="translated">如果一个具有缺省值的函数有多个子句,则需要创建一个函数头(没有实际的主体)来声明缺省值。</target>
        </trans-unit>
        <trans-unit id="000c898cfeca7c250248fbd1fa1ca561171bdc1f" translate="yes" xml:space="preserve">
          <source>If a given line starts a &lt;code&gt;describe&lt;/code&gt; block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number.</source>
          <target state="translated">如果给定的行开始了 &lt;code&gt;describe&lt;/code&gt; 块，则该行过滤器将在其中运行所有测试。否则，它将在给定的行号上或之前运行最接近的测试。</target>
        </trans-unit>
        <trans-unit id="d537fdd4d0b14a07a0a04df5203e5b0b7c078fd6" translate="yes" xml:space="preserve">
          <source>If a key in the pattern is not available in the map, then they won't match:</source>
          <target state="translated">如果图案中的某个键在地图中没有,那么它们就不会匹配。</target>
        </trans-unit>
        <trans-unit id="79925800db01e377c0a45bd22e7acc683fbfbe07" translate="yes" xml:space="preserve">
          <source>If a key is a function, the function will be invoked passing three arguments:</source>
          <target state="translated">如果一个键是一个函数,那么该函数将通过三个参数被调用。</target>
        </trans-unit>
        <trans-unit id="29fd70a945f925cf23cc7e6f8035b1a44027a7d0" translate="yes" xml:space="preserve">
          <source>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</source>
          <target state="translated">如果一个列表是由非负整数组成,其中每个整数代表一个Unicode码点,那么这个列表也可以称为charlist。这些整数必须:</target>
        </trans-unit>
        <trans-unit id="459ad8c7d2d4dfeac7cad82c1512116c71e69047" translate="yes" xml:space="preserve">
          <source>If a list of dependencies is given, Mix will attempt to compile them as is. For example, if project &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt;, calling &lt;code&gt;mix deps.compile a&lt;/code&gt; will compile &lt;code&gt;a&lt;/code&gt; even if &lt;code&gt;b&lt;/code&gt; is out of date. This is to allow parts of the dependency tree to be recompiled without propagating those changes upstream. To ensure &lt;code&gt;b&lt;/code&gt; is included in the compilation step, pass &lt;code&gt;--include-children&lt;/code&gt;.</source>
          <target state="translated">如果给出了依赖项列表，则Mix将尝试按原样对其进行编译。例如，如果项目 &lt;code&gt;a&lt;/code&gt; 依赖于 &lt;code&gt;b&lt;/code&gt; ，则调用 &lt;code&gt;mix deps.compile a&lt;/code&gt; 将编译 &lt;code&gt;a&lt;/code&gt; ,即使 &lt;code&gt;b&lt;/code&gt; 已过期。这是为了允许重新编译部分依赖树，而无需在上游传播这些更改。为了确保 &lt;code&gt;b&lt;/code&gt; 包含在编译步骤中，请传递 &lt;code&gt;--include-children&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b421abd37694bae36c7d25d86ffa518fdbbea4dd" translate="yes" xml:space="preserve">
          <source>If a module adopting a given behaviour doesn&amp;rsquo;t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</source>
          <target state="translated">如果采用给定行为的模块未实现该行为所需的回调之一，则将生成编译时警告。</target>
        </trans-unit>
        <trans-unit id="883d15353620b14cbb9c9d5a06e95f6b6c4d20b6" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of elements will be taken from the end. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">如果得到否定的 &lt;code&gt;amount&lt;/code&gt; 已定，那么 &lt;code&gt;amount&lt;/code&gt; 元件将从端作出。该 &lt;code&gt;enumerable&lt;/code&gt; 将被枚举一次检索正确的索引和剩余的计算是从端部执行。</target>
        </trans-unit>
        <trans-unit id="6cc671d5a37ef968ded5582cc81fb0522d873170" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of last values will be dropped. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">如果得到否定的 &lt;code&gt;amount&lt;/code&gt; 已定，那么 &lt;code&gt;amount&lt;/code&gt; 最后的值将被丢弃。该 &lt;code&gt;enumerable&lt;/code&gt; 将被枚举一次检索正确的索引和剩余的计算是从端部执行。</target>
        </trans-unit>
        <trans-unit id="59caaee16729c3dbee5fe847e2d7d4842c9c683a" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;count&lt;/code&gt; is given, the last &lt;code&gt;count&lt;/code&gt; values will be taken. For such, the collection is fully enumerated keeping up to &lt;code&gt;2 * count&lt;/code&gt; elements in memory. Once the end of the collection is reached, the last &lt;code&gt;count&lt;/code&gt; elements will be executed. Therefore, using a negative &lt;code&gt;count&lt;/code&gt; on an infinite collection will never return.</source>
          <target state="translated">如果给出负 &lt;code&gt;count&lt;/code&gt; ，将取最后一个 &lt;code&gt;count&lt;/code&gt; 数值。为此，将充分枚举该集合，并在内存中最多保留 &lt;code&gt;2 * count&lt;/code&gt; 元素。一旦到达集合的末尾，将执行最后一个 &lt;code&gt;count&lt;/code&gt; 元素。因此，对无限集合使用负 &lt;code&gt;count&lt;/code&gt; 将永远不会返回。</target>
        </trans-unit>
        <trans-unit id="f69e4dbe00c1ada199c059c775f25efeb8310586" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;n&lt;/code&gt; is given, it will drop the last &lt;code&gt;n&lt;/code&gt; elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until &lt;code&gt;n&lt;/code&gt; additional elements have been emitted by the enum.</source>
          <target state="translated">如果给定一个负数 &lt;code&gt;n&lt;/code&gt; ，它将删除集合中的最后 &lt;code&gt;n&lt;/code&gt; 个元素。注意，实现该机制的机制将延迟任何元素的发射，直到枚举发射了 &lt;code&gt;n&lt;/code&gt; 个其他元素为止。</target>
        </trans-unit>
        <trans-unit id="1945f4f47fb811a9fdec36bceacc04e13f4b23dd" translate="yes" xml:space="preserve">
          <source>If a non-unique registry is given, an error is raised.</source>
          <target state="translated">如果给出了一个非唯一的注册表,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="7fe100a04f7f3c2228565ba1dad4a516ece48f3e" translate="yes" xml:space="preserve">
          <source>If a positive &lt;code&gt;amount&lt;/code&gt; is given, it takes the &lt;code&gt;amount&lt;/code&gt; elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果给出正 &lt;code&gt;amount&lt;/code&gt; ，则从 &lt;code&gt;enumerable&lt;/code&gt; 的开头开始取 &lt;code&gt;amount&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="273c42e7694ef6f6a0ae619fbbe7e5dc6c7edfb5" translate="yes" xml:space="preserve">
          <source>If a previous value is already stored, all entries are removed and the value is overridden.</source>
          <target state="translated">如果之前的值已经存储,则删除所有条目并覆盖该值。</target>
        </trans-unit>
        <trans-unit id="44015a59f9f7a33ffc75deedd1425577f41943be" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">如果找不到给定类型的协议实现，则调用该协议将会增加，除非配置为回退为 &lt;code&gt;Any&lt;/code&gt; 。也可以在现有的基础上构建实现的便利，请&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;以获取有关派生协议的更多信息。</target>
        </trans-unit>
        <trans-unit id="43fc3383844fcfe72ece54d10710bd0bd9f25337" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">如果找不到给定类型的协议实现，则除非将协议配置为回退为 &lt;code&gt;Any&lt;/code&gt; ,否则将调用该协议。也可以在现有的基础上构建实现的便利，请&lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;以获取有关派生协议的更多信息。</target>
        </trans-unit>
        <trans-unit id="a016d1410ce73603f7d41b32703713ab6681b5cb" translate="yes" xml:space="preserve">
          <source>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</source>
          <target state="translated">如果将一个范围传递到函数中,这个函数将在范围限制之间选取一个随机值,而不遍历整个范围(因此在恒定时间和恒定内存中执行)。</target>
        </trans-unit>
        <trans-unit id="4e6fe5e08b24cf20a9c0798353e64ac83dfa14b4" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">如果记录在默认值中定义了匿名函数，则将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。从使用匿名函数作为默认值的Erlang库中提取记录后定义记录时，可能会无意间发生这种情况。</target>
        </trans-unit>
        <trans-unit id="7d5db183ff92e0f2a4bace49c1074a0f1a8e87bc" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">如果记录在默认值中定义了匿名函数，则将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。从使用匿名函数作为默认值的Erlang库中提取记录后定义记录时，可能会无意间发生这种情况。</target>
        </trans-unit>
        <trans-unit id="a6abb6313f6cc1303f397ef517fbdc8da84732e6" translate="yes" xml:space="preserve">
          <source>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1.</source>
          <target state="translated">如果是字符串,则会产生一个以状态为口号的Erlang崩溃转储,然后运行时系统以状态码1退出。</target>
        </trans-unit>
        <trans-unit id="126afd1abf58596ead958f3fd3541d1004b086cc" translate="yes" xml:space="preserve">
          <source>If a switch can't be parsed according to the given type, it is returned in the invalid options list.</source>
          <target state="translated">如果一个开关不能根据给定的类型进行解析,则会在无效选项列表中返回。</target>
        </trans-unit>
        <trans-unit id="2b1173f30bab1103a16e4d18afe172d1cf1918aa" translate="yes" xml:space="preserve">
          <source>If a tag is given more than once, the last value wins.</source>
          <target state="translated">如果一个标签被赋予多于一次,则最后一个值获胜。</target>
        </trans-unit>
        <trans-unit id="25bcdf5eebbd3c58586886d967dc6654eabd51f6" translate="yes" xml:space="preserve">
          <source>If a task crashes, the callers field is included as part of the log message metadata under the &lt;code&gt;:callers&lt;/code&gt; key.</source>
          <target state="translated">如果任务崩溃，则 &lt;code&gt;:callers&lt;/code&gt; 项下的callers字段将作为日志消息元数据的一部分包含在内。</target>
        </trans-unit>
        <trans-unit id="83f25a0e999e5079ecb734e6ae102d4bb2431a7f" translate="yes" xml:space="preserve">
          <source>If a task has requirements, they can be listed using the &lt;code&gt;@requirements&lt;/code&gt; attribute. For example:</source>
          <target state="translated">如果任务有要求，则可以使用 &lt;code&gt;@requirements&lt;/code&gt; 属性将其列出。例如：</target>
        </trans-unit>
        <trans-unit id="05107c81774e13529708289068c52809a60e340f" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">如果任务需要定义项目或需要访问项目中的特殊功能，则该任务可以调用&lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; &lt;/a&gt;，如果未定义项目，则失败，并带有&lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30a9473b0d912205c959737a706b0e7ee4a0ec9d" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;mix.project#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">如果任务需要定义一个项目或需要在项目内访问一个特殊的功能，任务可以调用&lt;a href=&quot;mix.project#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; &lt;/a&gt;，其失败&lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;在项目没有定义的情况下。</target>
        </trans-unit>
        <trans-unit id="c67bc32edf1527e959986e52e98d4224edd81679" translate="yes" xml:space="preserve">
          <source>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return &lt;code&gt;{:exit, :noproc}&lt;/code&gt; as the result or exit reason can not be determined.</source>
          <target state="translated">如果已经监视或接收了任务的监视器，并且消息队列中没有等待响应，则此函数将返回 &lt;code&gt;{:exit, :noproc}&lt;/code&gt; 因为无法确定结果或退出原因。</target>
        </trans-unit>
        <trans-unit id="1a77a9db2807ea258346d1c8035a43bea2a0103f" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same pattern:</source>
          <target state="translated">如果一个变量在一个模式中被多次提及,那么所有的引用都应该绑定到同一个模式。</target>
        </trans-unit>
        <trans-unit id="8341a6ce2bd527f498f269d473191d8c74061cd6" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same value:</source>
          <target state="translated">如果一个变量在一个模式中被提到不止一次,所有的引用都应该绑定到同一个值。</target>
        </trans-unit>
        <trans-unit id="2d5176a6bc70715553073a28b4fe06e7f78373b7" translate="yes" xml:space="preserve">
          <source>If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</source>
          <target state="translated">如果所有子句都匹配，则执行 &lt;code&gt;do&lt;/code&gt; 块，并返回其结果。否则，链中止，并返回不匹配的值：</target>
        </trans-unit>
        <trans-unit id="e9c4638272580cddbbaefbc10d002d4b066670b8" translate="yes" xml:space="preserve">
          <source>If all of the conditions return &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, an error (&lt;code&gt;CondClauseError&lt;/code&gt;) is raised. For this reason, it may be necessary to add a final condition, equal to &lt;code&gt;true&lt;/code&gt;, which will always match:</source>
          <target state="translated">如果所有条件都返回 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，则会引发错误（ &lt;code&gt;CondClauseError&lt;/code&gt; ）。出于这个原因，可能有必要添加一个最终条件，该条件等于 &lt;code&gt;true&lt;/code&gt; ，它将始终匹配：</target>
        </trans-unit>
        <trans-unit id="1ce3955a535274dbe7df8b09ce910f413bd1bd52" translate="yes" xml:space="preserve">
          <source>If amount is &lt;code&gt;0&lt;/code&gt;, it returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果数量为 &lt;code&gt;0&lt;/code&gt; ，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195d921f30b7ca6822ad57816fd9a2da342da9c2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is present, it will match on the results of the &lt;code&gt;try&lt;/code&gt; block whenever the &lt;code&gt;try&lt;/code&gt; block finishes without a throw or an error.</source>
          <target state="translated">如果存在 &lt;code&gt;else&lt;/code&gt; 块，则只要 &lt;code&gt;try&lt;/code&gt; 块完成而没有抛出或错误，它将与 &lt;code&gt;try&lt;/code&gt; 块的结果匹配。</target>
        </trans-unit>
        <trans-unit id="678b2cde87bb40ee90e01daea6daabd5a152129d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果使用 &lt;code&gt;else&lt;/code&gt; 块并且没有匹配子句，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="570f497970d66b8882cf83a80169ce5e7a3f4622" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;withclauseerror&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果使用 &lt;code&gt;else&lt;/code&gt; 块且没有匹配子句，则会引发&lt;a href=&quot;withclauseerror&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="de3cca2420a70cac7a0a92d8ce5ec9857a32f5c0" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; clause is not present and no exceptions are raised, the result of the expression will be returned:</source>
          <target state="translated">如果 &lt;code&gt;else&lt;/code&gt; 子句不存在并且没有引发异常，则将返回表达式的结果：</target>
        </trans-unit>
        <trans-unit id="e2d3671c086be455d33d12466d3540943c7f121c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;offset&lt;/code&gt; is given, we will index from the given offset instead of from zero.</source>
          <target state="translated">如果给出了 &lt;code&gt;offset&lt;/code&gt; ，我们将从给定的偏移量而不是从零开始索引。</target>
        </trans-unit>
        <trans-unit id="0a648b7fb5579eaba477422e6520374ab96f3bbc" translate="yes" xml:space="preserve">
          <source>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</source>
          <target state="translated">如果一个应用程序有包含的应用程序,它们也会被加载。而如果它们又有包含的应用,那么这个过程就会反复出现。包含的应用程序与Mix伞形项目中的应用程序无关,它们是一个与协调启动有关的Erlang/OTP概念。</target>
        </trans-unit>
        <trans-unit id="c19cd9003fb6605f04e0b314c975e08d6865c82c" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt archive, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">如果提供了一个参数,它应该是一个预建归档、Git 仓库、GitHub 仓库或 Hex 软件包的本地路径。</target>
        </trans-unit>
        <trans-unit id="8777f1d4410c11fe781472a9996f7abc7e9d0ee1" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt escript, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">如果提供了一个参数,它应该是一个预制的escript、Git仓库、GitHub仓库或Hex包的本地路径。</target>
        </trans-unit>
        <trans-unit id="346e510adb982fcdef487692a01e3558f4f43dd0" translate="yes" xml:space="preserve">
          <source>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</source>
          <target state="translated">如果给定了一个原子,则假定它是一个Elixir模块,所以将其转换为二进制,然后进行处理。</target>
        </trans-unit>
        <trans-unit id="1dd9c12e4c69c00fd419e79703f50c2f1eb25bbf" translate="yes" xml:space="preserve">
          <source>If an empty string is given, returns an empty list.</source>
          <target state="translated">如果给定一个空字符串,返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="b8c7e22d59114292a3302ce7be80d94101c6ff48" translate="yes" xml:space="preserve">
          <source>If an integer, the runtime system exits with the integer value which is returned to the operating system.</source>
          <target state="translated">如果是整数,则运行时系统退出时的整数值将返回给操作系统。</target>
        </trans-unit>
        <trans-unit id="7d3f5440412ded7562694390034be201abb74a66" translate="yes" xml:space="preserve">
          <source>If an umbrella project reenables a task, it is reenabled for all child projects.</source>
          <target state="translated">如果一个伞形项目重新启用了一个任务,它就会对所有子项目重新启用。</target>
        </trans-unit>
        <trans-unit id="a96ebc73b0c26a7d76054b4183ec0b8df86f83ca" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;--check-*&lt;/code&gt; options are given and a check fails, the formatted contents won't be written to disk nor printed to standard output.</source>
          <target state="translated">如果给出了 &lt;code&gt;--check-*&lt;/code&gt; 选项中的任何一个，并且检查失败，则格式化的内容将不会写入磁盘或打印到标准输出。</target>
        </trans-unit>
        <trans-unit id="642cb4f6ac7d478befb880a0aa0031be148b3d13" translate="yes" xml:space="preserve">
          <source>If any of the files is &lt;code&gt;-&lt;/code&gt;, then the output is read from stdin and written to stdout.</source>
          <target state="translated">如果任何文件是 &lt;code&gt;-&lt;/code&gt; ，则从stdin读取输出并将其写入stdout。</target>
        </trans-unit>
        <trans-unit id="f55410e6ca8aea2aa1012bcfa7157dec87ff1c3f" translate="yes" xml:space="preserve">
          <source>If any of the task processes dies, the current process will exit with the same reason as that task.</source>
          <target state="translated">如果任何一个任务进程死亡,当前进程将以与该任务相同的理由退出。</target>
        </trans-unit>
        <trans-unit id="ea3148cc3562102872f247d7ecd3f95cbb26a611" translate="yes" xml:space="preserve">
          <source>If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">如果任何值为 &lt;code&gt;nil&lt;/code&gt; ，则将其省略。</target>
        </trans-unit>
        <trans-unit id="033137dbcc6d7e358cdff1f234f1f034d23cee4d" translate="yes" xml:space="preserve">
          <source>If anything had to be compiled, you see some informative text, and get the &lt;code&gt;:ok&lt;/code&gt; atom back, otherwise the function is silent, and returns &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">如果必须编译任何内容，则会看到一些有用的文本，并返回 &lt;code&gt;:ok&lt;/code&gt; 原子，否则该函数为无提示，并返回 &lt;code&gt;:noop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9330902fc087c329eff5fc5f2a0eba15cfef47c" translate="yes" xml:space="preserve">
          <source>If both options are set, &lt;code&gt;--force&lt;/code&gt; takes precedence.</source>
          <target state="translated">如果同时设置了两个选项，则 &lt;code&gt;--force&lt;/code&gt; 优先。</target>
        </trans-unit>
        <trans-unit id="7b4dc8078aeab160f01342b984c42012d0bb7fb7" translate="yes" xml:space="preserve">
          <source>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</source>
          <target state="translated">如果数据以无法转换为UTF-8的格式发送至文件,或者数据被函数读取,而返回的数据格式无法应对数据的字符范围,则会发生错误,文件将被关闭。</target>
        </trans-unit>
        <trans-unit id="9cb11ee612f8a6fa1dc16b1180f3c60b5d1e6218" translate="yes" xml:space="preserve">
          <source>If desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as &lt;code&gt;Enumerable&lt;/code&gt; and possibly &lt;code&gt;Size&lt;/code&gt;, for this data type.</source>
          <target state="translated">如果需要，您可以针对结构的大小提出自己的语义。不仅如此，您还可以使用结构来构建更健壮的数据类型（例如队列），并为此数据类型实现所有相关协议，例如 &lt;code&gt;Enumerable&lt;/code&gt; 以及可能的 &lt;code&gt;Size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea1cd1f61403fdf9495800bfd2ea11cb562ca0b5" translate="yes" xml:space="preserve">
          <source>If duplicated entries exist, the first one is returned. Use &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; to retrieve all entries.</source>
          <target state="translated">如果存在重复的条目，则返回第一个。使用&lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt;检索所有条目。</target>
        </trans-unit>
        <trans-unit id="0b592a69d9d8fd53bf0bd9cbfc055db4e81ec7c8" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. So this function will not detect empty tuples:</source>
          <target state="translated">如果每个守卫表达式总是返回一个布尔值,那么这两种形式是等价的。然而,请记住,如果一个守卫中的任何函数调用引发异常,整个守卫就会失败。所以这个函数不会检测空的元组。</target>
        </trans-unit>
        <trans-unit id="5c3eed1e3cb4bd53836b71d67f974f0d1ba37310" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples:</source>
          <target state="translated">如果每个守卫表达式总是返回一个布尔值,那么这两种形式是等价的。然而,请记住,如果一个守卫中的任何函数调用引发异常,整个守卫就会失败。为了说明这一点,下面的函数将不会检测空的元组。</target>
        </trans-unit>
        <trans-unit id="dbe27cd775ccec3c6324b3d4efb95e206746dc7f" translate="yes" xml:space="preserve">
          <source>If file &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten by the contents in &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">如果文件 &lt;code&gt;destination&lt;/code&gt; 已经存在，则将被 &lt;code&gt;source&lt;/code&gt; 中的内容覆盖。</target>
        </trans-unit>
        <trans-unit id="fdc28a9b8dcfe0a11c8bac1e062e822f6767ef47" translate="yes" xml:space="preserve">
          <source>If file is a relative, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">如果文件是相对的,则会相对扩展到当前配置文件所在的目录。</target>
        </trans-unit>
        <trans-unit id="42ddc2f0c1e4117e2bba8be8a09c43a0ea2ed1bd" translate="yes" xml:space="preserve">
          <source>If for some reason the application needs to be configured before it is started, the &lt;code&gt;--no-start&lt;/code&gt; option can be used and you are then responsible for starting all applications by using functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. For more information about the application life-cycle and dynamically configuring applications, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">如果出于某种原因需要在启动之前配置应用程序，则可以使用 &lt;code&gt;--no-start&lt;/code&gt; 选项，然后您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt; &lt;code&gt;Application.ensure_all_started/1&lt;/code&gt; 之类的&lt;/a&gt;功能来启动所有应用程序。有关应用程序生命周期和动态配置应用程序的更多信息，请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="52856e4d7670b4aabed44c6b796ec0f3b6c2451e" translate="yes" xml:space="preserve">
          <source>If for some reason you cannot take the elements before hand, you can use &lt;code&gt;:max_concurrency&lt;/code&gt; to limit how many elements may be over processed at the cost of reducing concurrency.</source>
          <target state="translated">如果由于某种原因您不能事先使用元素，则可以使用 &lt;code&gt;:max_concurrency&lt;/code&gt; 来限制可能要处理的元素数量，以减少并发为代价。</target>
        </trans-unit>
        <trans-unit id="8fe39f85acaae7d9c0b9ede161359eb45dcac7a2" translate="yes" xml:space="preserve">
          <source>If injection is suddenly interrupted, &lt;code&gt;:halt&lt;/code&gt; is passed and the function can return any value as it won't be used.</source>
          <target state="translated">如果注入突然中断，则 &lt;code&gt;:halt&lt;/code&gt; 将被传递，该函数可以返回任何值，因为它将不被使用。</target>
        </trans-unit>
        <trans-unit id="2208d456a668339c9192b6d6af5ff93f1cbc3d73" translate="yes" xml:space="preserve">
          <source>If installing a precompiled Hex does not work, you can compile and install Hex directly with this command:</source>
          <target state="translated">如果安装预编译的Hex不能正常工作,可以用这个命令直接编译和安装Hex。</target>
        </trans-unit>
        <trans-unit id="e605c80e2a0c34a8e797284924c7ad11db4e6147" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">如果相反，您希望在不同时区中的同一点时间使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt;函数，该函数会将哥本哈根的2018-08-24 10:00:00转换为2018-08-24 08:00:00在UTC。</target>
        </trans-unit>
        <trans-unit id="6ef0c2aa8f05db2c984cf1df62ac6db58c68621a" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;datetime#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">如果相反，您希望在不同时区中的同一点时间使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，请参见&lt;a href=&quot;datetime#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt;函数，该函数会将哥本哈根的2018-08-24 10:00:00转换为2018-08-24 08:00:00在UTC。</target>
        </trans-unit>
        <trans-unit id="d54c8e6a4382ff70ea26a411e39ab67c3f015ec3" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">如果给出了无效的参数，则&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;由&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;引发。&lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;还期望一组严格的选项，如果给出未知或无效的选项，则会提高。</target>
        </trans-unit>
        <trans-unit id="f63070ccfff8927ca91b04ed194217d21f1511af" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">如果给出了无效的参数，则&lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt;还期望一组严格的选项，如果给出未知或无效的选项，则会提高。</target>
        </trans-unit>
        <trans-unit id="d184a96a7452ebbaa15d901cdfcd5646962e673b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则返回 &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="bf2413d6f2f1077cec728a8783f14bba8e944a5b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则会引发ArgumentError。</target>
        </trans-unit>
        <trans-unit id="ecfddb3c801b4fad8012305968cb8bcbecf6fa13" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则返回 &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="87471401848a097556118fe83e0d5466a1656985" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">如果无法在日历之间进行明确转换（请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt;），则会引发ArgumentError。</target>
        </trans-unit>
        <trans-unit id="1b73ba22cd3093f832e74a316d5262bd0f987e0a" translate="yes" xml:space="preserve">
          <source>If it succeeds in loading the module, it returns &lt;code&gt;{:module, module}&lt;/code&gt;. If not, returns &lt;code&gt;{:error, reason}&lt;/code&gt; with the error reason.</source>
          <target state="translated">如果成功加载模块，则返回 &lt;code&gt;{:module, module}&lt;/code&gt; 。如果不是，则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 以及错误原因。</target>
        </trans-unit>
        <trans-unit id="375e4e6baa78eec72e85f76cd1b054d6bf11d173" translate="yes" xml:space="preserve">
          <source>If it succeeds opening the file, it returns the &lt;code&gt;function&lt;/code&gt; result on the IO device.</source>
          <target state="translated">如果成功打开文件，它将在IO设备上返回 &lt;code&gt;function&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="f34822921b36640bca1582de43cfc049c94f2bdc" translate="yes" xml:space="preserve">
          <source>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</source>
          <target state="translated">如果最后一个大于第一个,范围将从第一个到最后一个增加。如果first大于last,范围将从第一个到最后一个递减。如果第一个等于最后一个,范围将包含一个元素,也就是数字本身。</target>
        </trans-unit>
        <trans-unit id="235b771916ee54b0bdf0b8ac1f7f9a8b762d39f4" translate="yes" xml:space="preserve">
          <source>If module has &lt;code&gt;@compile {:autoload, false}&lt;/code&gt;, &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; will not be used.</source>
          <target state="translated">如果模块具有 &lt;code&gt;@compile {:autoload, false}&lt;/code&gt; ，则将不使用 &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73ef68acbf89df4484fb1238776c874300f89fd7" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal or minimal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最大或最小的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="1368a6e71ce1bea12a85b30b7509f054b5bc170d" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最大的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="c6a9685a98347f5efadc0b8611df565d7f389d71" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered minimal, the first one that was found is returned.</source>
          <target state="translated">如果多个元素被认为是最小的,则返回找到的第一个元素。</target>
        </trans-unit>
        <trans-unit id="24628e265ef0842d90b32f3fc25fbf2867904597" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;rebar&lt;/code&gt; or &lt;code&gt;rebar3&lt;/code&gt; are specified, both versions will be fetched.</source>
          <target state="translated">如果没有 &lt;code&gt;rebar&lt;/code&gt; 或 &lt;code&gt;rebar3&lt;/code&gt; 指定，两个版本将是牵强。</target>
        </trans-unit>
        <trans-unit id="3bba7183a7cbe4b26185332d90ef3cedae8fff5f" translate="yes" xml:space="preserve">
          <source>If nil is returned, it means no lock information is available.</source>
          <target state="translated">如果返回nil,表示没有锁的信息。</target>
        </trans-unit>
        <trans-unit id="038bfba61cc7a83ddd7d63b5a01873632ce42b48" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; exists, returns the keyword list unchanged.</source>
          <target state="translated">如果不存在带有 &lt;code&gt;value&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; ，则返回不变的关键字列表。</target>
        </trans-unit>
        <trans-unit id="f84d674ad0c66434da7d8901f73f91feb00f3a76" translate="yes" xml:space="preserve">
          <source>If no application is given, it uses the current application defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">如果没有给出任何应用程序，它将使用 &lt;code&gt;mix.exs&lt;/code&gt; 文件中定义的当前应用程序。</target>
        </trans-unit>
        <trans-unit id="7c893bf9fd681a7f7a6fb13527c0cc5dfde15e8a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the value of the previous expression is used.</source>
          <target state="translated">如果没有给出参数,则使用前一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="44e1f09935bd0cbe5978c5fb2f1f11d782328422" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an archive in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix archive.build&lt;/code&gt;&lt;/a&gt;), then the archive will be installed locally. For example:</source>
          <target state="translated">如果未提供任何参数，但是在项目的根目录中（使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix archive.build&lt;/code&gt; &lt;/a&gt;创建），则将在本地安装该归档文件。例如：</target>
        </trans-unit>
        <trans-unit id="1e6b21b04e9206b421a7dd9fd273e8d10651e36e" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an escript in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;), then the escript will be installed locally. For example:</source>
          <target state="translated">如果未提供任何参数，但项目的根目录中存在一个escript（使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;创建），则该escript将在本地安装。例如：</target>
        </trans-unit>
        <trans-unit id="1b6cea41585ef2678e551c971ce31fe417d9dd88" translate="yes" xml:space="preserve">
          <source>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like &lt;code&gt;_&lt;/code&gt;) which will always match.</source>
          <target state="translated">如果没有子句匹配，则会引发错误。出于这个原因，可能有必要添加一个最终匹配的最终子句（例如 &lt;code&gt;_&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fc7cd6fb4c53519f3c55037a05bd9ecc868e4492" translate="yes" xml:space="preserve">
          <source>If no configuration file is given, it loads the project's configuration file, &quot;config/config.exs&quot;, if it exists. Keep in mind that the &quot;config/config.exs&quot; file is always loaded by the CLI and invoking it is only required in cases you are starting Mix manually.</source>
          <target state="translated">如果没有给定配置文件,它会加载项目的配置文件 &quot;config/config.exs&quot;(如果存在)。请记住,&quot;config/config.exe &quot;文件总是由CLI加载的,只有当你手动启动Mix时才需要调用它。</target>
        </trans-unit>
        <trans-unit id="b7eed02542b79da944224ca91fcc920777715fa8" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project is used.</source>
          <target state="translated">如果没有给出配置,则使用当前项目的配置。</target>
        </trans-unit>
        <trans-unit id="87546bcf9e4f94845bd9b4719319d8f898876f32" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project will be used.</source>
          <target state="translated">如果没有给出配置,将使用当前项目的配置。</target>
        </trans-unit>
        <trans-unit id="7b738bcb5763933041a695931c6cb78b2d2ed70e" translate="yes" xml:space="preserve">
          <source>If no dependency is given, it uses the tree defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">如果没有给出依赖关系，它将使用 &lt;code&gt;mix.exs&lt;/code&gt; 文件中定义的树。</target>
        </trans-unit>
        <trans-unit id="8420e9f0ced4b5e2305fa85af7c948aac181698b" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有给出功能，则在迭代过程中检查每个元素的真实性。当一个元素的值为 &lt;code&gt;false&lt;/code&gt; （false或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止并返回 &lt;code&gt;false&lt;/code&gt; 。在所有其他情况下，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af73d9c2f1028c805fc39df68dad67f7b564dd8d" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有给出功能，则在迭代过程中检查每个元素的真实性。当一个元素的值为真时（既不是 &lt;code&gt;false&lt;/code&gt; 也不是 &lt;code&gt;nil&lt;/code&gt; ），迭代会立即停止并返回 &lt;code&gt;true&lt;/code&gt; 。在所有其他情况下，将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99cc65b0a766a1d7c750735c04a6ce040c2ecd5f" translate="yes" xml:space="preserve">
          <source>If no matching tuple is found, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到匹配的元组，则返回 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db86456e3e6a45125baab8b1b669e7d382cc2ad8" translate="yes" xml:space="preserve">
          <source>If none of the clauses match, an error is raised:</source>
          <target state="translated">如果没有一个子句匹配,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="e2a4d7b7ce6ed34ac382f69616d43a496e285e59" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果不存在，则将终止，因为没有提供任何Shell进程输入。 &lt;code&gt;value&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b534d3078a1eaf21555f5ec72f4135c6d9a40dd" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be a string.</source>
          <target state="translated">如果不存在，则将终止，因为没有提供任何Shell进程输入。 &lt;code&gt;value&lt;/code&gt; 必须是字符串。</target>
        </trans-unit>
        <trans-unit id="bccd76edbf5bdad5646dc98c00f42c25e3b6a1a0" translate="yes" xml:space="preserve">
          <source>If one is already registered, it is replaced.</source>
          <target state="translated">如果已经注册了,就会被替换。</target>
        </trans-unit>
        <trans-unit id="6d6821d80cd7273e1c9f60ea9b9bf87af913648b" translate="yes" xml:space="preserve">
          <source>If one is not registered, returns the word appended with an &quot;s&quot;.</source>
          <target state="translated">如果没有注册,则返回带 &quot;s &quot;后缀的单词。</target>
        </trans-unit>
        <trans-unit id="2a2ad82fe5366a9ffae6d450da5ae29fe95a85f3" translate="yes" xml:space="preserve">
          <source>If options are provided, the result will be &lt;code&gt;{:ok, pid}&lt;/code&gt;, returning the IO device created. The option &lt;code&gt;:capture_prompt&lt;/code&gt;, when set to &lt;code&gt;true&lt;/code&gt;, causes prompts (which are specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) to be included in the device's output.</source>
          <target state="translated">如果提供了选项，则结果为 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，返回创建的IO设备。选项 &lt;code&gt;:capture_prompt&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，会导致提示（指定为 &lt;code&gt;IO.get*&lt;/code&gt; 函数的参数）包含在设备的输出中。</target>
        </trans-unit>
        <trans-unit id="3b66a164bf9c0ed9cfb3107b0900a5b27ed87c86" translate="yes" xml:space="preserve">
          <source>If part of a supervision tree, a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</source>
          <target state="translated">如果属于监督树，则关闭该树时，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;会收到退出信号。退出信号基于儿童规范中的关闭策略，该值可以是：</target>
        </trans-unit>
        <trans-unit id="c9b86f1b45462784068301d1b6133eb9cbdf0f18" translate="yes" xml:space="preserve">
          <source>If partitioning is enabled and &lt;code&gt;--cover&lt;/code&gt; is used, no cover reports are generated, as they only contain a subset of the coverage data. Instead, the coverage data is exported to files such as &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt;. Once you have the results of all partitions inside &lt;code&gt;cover/&lt;/code&gt;, you can run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; to get the unified report.</source>
          <target state="translated">如果启用了分区并且使用了 &lt;code&gt;--cover&lt;/code&gt; ，则不会生成涵盖报告，因为它们仅包含涵盖数据的一部分。相反，coverage数据将导出到诸如 &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt; 之类的文件。一旦将所有分区的结果都包含在 &lt;code&gt;cover/&lt;/code&gt; ，就可以运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; &lt;/a&gt;以获得统一报告。</target>
        </trans-unit>
        <trans-unit id="ee772fad171fd1b86c1fbf91441e33291245e16b" translate="yes" xml:space="preserve">
          <source>If path/wildcard is a relative path/wildcard, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">如果path/wildcard是相对路径/wildcard,则会相对于当前配置文件所在的目录展开。</target>
        </trans-unit>
        <trans-unit id="2c9a282865b6fe4119e199b1b0847cbb6040e103" translate="yes" xml:space="preserve">
          <source>If present, invoke the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在，则调用可选的回调&lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f857961c6609ab2fd7dcb4f431f75616d71eb634" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt;; when the binary cannot be coerced into a valid float, the atom &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt; 形式的元组；当二进制文件不能强制转换为有效的float时，将返回atom &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b120927e219fe332092528639b692b8090eba7eb" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt;. Otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果成功，则以 &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt; 的形式返回一个元组。否则 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b18774208db640d57cda0a230752786cd8f12b4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no child specification for the given child ID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果没有给定子ID的子规范，则此函数返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f06ad98d27407a8302c766c4bf1a51ac8c90c4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no process with the given PID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果没有使用给定PID的进程，则此函数返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b49684fdd544a95c54cc6ece8ce5787754e9bca3" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。如果未找到 &lt;code&gt;child_id&lt;/code&gt; ，或者当前进程正在运行或正在重新启动，则此函数可能返回带有适当错误元组的错误。</target>
        </trans-unit>
        <trans-unit id="94de3ea42072866e8652cd6fca38378bad81898f" translate="yes" xml:space="preserve">
          <source>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</source>
          <target state="translated">如果这样的链接已经存在,这个函数什么也不做,因为两个给定的进程之间只能有一个链接。如果一个进程试图创建一个与自己的链接,则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="82ad4a438a65f14d6cc2e31d27dc219d76d8743c" translate="yes" xml:space="preserve">
          <source>If such a tuple is not found, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">如果找不到这样的元组，则将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="481e39df28a67eb2b33dd5d88bf3b6bd30ab02a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback fails with &lt;code&gt;reason&lt;/code&gt;, this function returns &lt;code&gt;{:error, reason}&lt;/code&gt;. Otherwise, if it returns &lt;code&gt;{:stop, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;{:error, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">如果&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调由于 &lt;code&gt;reason&lt;/code&gt; 失败，则此函数返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。否则，如果返回 &lt;code&gt;{:stop, reason}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; ，则进程终止，此函数分别返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbcf489afc8a98baffdf14a35b5948b139352b97" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback returns &lt;code&gt;:ignore&lt;/code&gt;, this function returns &lt;code&gt;:ignore&lt;/code&gt; as well and the supervisor terminates with reason &lt;code&gt;:normal&lt;/code&gt;. If it fails or returns an incorrect value, this function returns &lt;code&gt;{:error, term}&lt;/code&gt; where &lt;code&gt;term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调返回 &lt;code&gt;:ignore&lt;/code&gt; ，则此函数也返回 &lt;code&gt;:ignore&lt;/code&gt; ，并且主管终止于原因 &lt;code&gt;:normal&lt;/code&gt; 。如果失败或返回不正确的值，则此函数返回 &lt;code&gt;{:error, term}&lt;/code&gt; ，其中 &lt;code&gt;term&lt;/code&gt; 是具有有关错误信息的术语，而主管则以原因 &lt;code&gt;term&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="71d6d6b5b64b37312988e1b6e5df55a665e7fb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; receives an exit signal (that is not &lt;code&gt;:normal&lt;/code&gt;) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. Note that a process does &lt;em&gt;NOT&lt;/em&gt; trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</source>
          <target state="translated">如果&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;在未捕获退出时从任何进程接收到退出信号（不是 &lt;code&gt;:normal&lt;/code&gt; ），则它将以相同的原因突然退出，因此不要调用&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。请注意，一个过程确实&lt;em&gt;NOT&lt;/em&gt;默认陷阱退出，并且当链接的过程退出或它的节点断开发送一个退出信号。</target>
        </trans-unit>
        <trans-unit id="6f9052b50ac29d05b6aa3acc2ac9400b5beedce0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--label compile&lt;/code&gt; flag is given with &lt;code&gt;--sink&lt;/code&gt;, then &lt;code&gt;lib/c.ex&lt;/code&gt; won't be shown, because no module has a compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; but &lt;code&gt;lib/a.ex&lt;/code&gt; still has an indirect compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; via &lt;code&gt;lib/b.ex&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;--label compile&lt;/code&gt; 标志与给出 &lt;code&gt;--sink&lt;/code&gt; ，然后 &lt;code&gt;lib/c.ex&lt;/code&gt; 将不会显示，因为没有模块在编译时依赖 &lt;code&gt;lib/c.ex&lt;/code&gt; 但 &lt;code&gt;lib/a.ex&lt;/code&gt; 仍具有间接通过 &lt;code&gt;lib/b.ex&lt;/code&gt; 编译对 &lt;code&gt;lib/c.ex&lt;/code&gt; 的时间依赖性：</target>
        </trans-unit>
        <trans-unit id="f3eabf6d5616bb794992bd7e46ea46c1c3f02463" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:capture_prompt&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, prompts (specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) are captured in the output.</source>
          <target state="translated">如果 &lt;code&gt;:capture_prompt&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则在输出中捕获提示（指定为 &lt;code&gt;IO.get*&lt;/code&gt; 函数的参数）。</target>
        </trans-unit>
        <trans-unit id="e863cbc73eabe13e90d2206b9738ad4d5bc8e2e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:debug&lt;/code&gt; option is present, the corresponding function in the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; will be invoked.</source>
          <target state="translated">如果存在 &lt;code&gt;:debug&lt;/code&gt; 选项，则将调用&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块中&lt;/a&gt;的相应功能。</target>
        </trans-unit>
        <trans-unit id="20dea358c75a21f536924752c1d8661c6611e5a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;:spawn_opt&lt;/code&gt; 选项，则其值将作为选项传递给基础进程，如&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; 所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cc9742b5fac276e3c5db68eba998892b5d16666" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;:spawn_opt&lt;/code&gt; 选项，则其值将作为选项传递给基础进程，如&lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; 所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a17a9b3957177b112bf526bb40068d405551156b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:timeout&lt;/code&gt; option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;:timeout&lt;/code&gt; 选项，则允许该代理最多花费给定的毫秒数进行初始化，否则它将终止，并且启动功能将返回 &lt;code&gt;{:error, :timeout}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb098adf69499ff7a9f9cec625ec93553830b541" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;Foo.Bar&lt;/code&gt; 模块移动到其他地方，则需要将 &lt;code&gt;Foo&lt;/code&gt; 模块中对 &lt;code&gt;Bar&lt;/code&gt; 的引用更新为完全限定的名称（ &lt;code&gt;Foo.Bar&lt;/code&gt; ），或者必须在 &lt;code&gt;Foo&lt;/code&gt; 模块的帮助下显式设置别名。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14ac11fca560d2d149b007098ce38791dba90a1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;Foo.Bar&lt;/code&gt; 模块移动到其他地方，则需要将 &lt;code&gt;Foo&lt;/code&gt; 模块中对 &lt;code&gt;Bar&lt;/code&gt; 的引用更新为完全限定的名称（ &lt;code&gt;Foo.Bar&lt;/code&gt; ），或者必须在 &lt;code&gt;Foo&lt;/code&gt; 模块的帮助下显式设置别名。&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a6368961da467df03a853267f8beaa74f1276b2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; is not loaded, the application will first be loaded using &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt;. Any included application, defined in the &lt;code&gt;:included_applications&lt;/code&gt; key of the &lt;code&gt;.app&lt;/code&gt; file will also be loaded, but they won't be started.</source>
          <target state="translated">如果 &lt;code&gt;app&lt;/code&gt; 没有被加载，则应用程序将首先使用加载&lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;.app&lt;/code&gt; 文件的 &lt;code&gt;:included_applications&lt;/code&gt; 项中定义的所有包含的应用程序也将被加载，但不会启动。</target>
        </trans-unit>
        <trans-unit id="0c322faf190500e641ef7c48d9a94611219b9f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;debugger&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package.</source>
          <target state="translated">如果 &lt;code&gt;debugger&lt;/code&gt; 未启动，则可能发生了以下情况：一些程序包管理器默认安装没有GUI支持WX绑定的最小化Erlang。在某些软件包管理器中，您可以用更完整的软件包替换无头的Erlang（在Debian / Ubuntu / Arch上查找名为 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 的软件包）。在其他管理员中，您可能需要安装单独的 &lt;code&gt;erlang-wx&lt;/code&gt; （或类似名称）软件包。</target>
        </trans-unit>
        <trans-unit id="cbb1dfcd54340620db2a4b1be8a4677dcef95965" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;element&lt;/code&gt; occurs more than once in the &lt;code&gt;list&lt;/code&gt;, just the first occurrence is removed.</source>
          <target state="translated">如果该 &lt;code&gt;element&lt;/code&gt; 在 &lt;code&gt;list&lt;/code&gt; 出现多次，则仅删除第一次出现的元素。</target>
        </trans-unit>
        <trans-unit id="c08aca5a16d9dc35535dd8000df0a013cccceba1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, inserts the given &lt;code&gt;initial&lt;/code&gt; value.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则插入给定的 &lt;code&gt;initial&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="51a63ed6ff743b76fcc933f16622e3ae8d826e4a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, it inserts the given &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，它将插入给定的 &lt;code&gt;default&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8ce0dac723ef05f760f8c9731a754923353ba4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则引发&lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b90b4077be865683040b57e9dd5a794351c1f57" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则引发&lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bce3fad01881435afa04eb9438e26f3f17ad50a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbc4c11a6c23bf2afb4e21b6579dc04b19c27e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;map&lt;/code&gt; unchanged.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;map&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="f3debd0c004b80e32f0db2e8ec25052d54f08cfa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回关键字列表不变。</target>
        </trans-unit>
        <trans-unit id="62f2f316a709eec98605c56cf7264dcfb2bde687" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged. Use &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; to delete just the first entry in case of duplicated keys.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回不变的关键字列表。如果键重复，则使用&lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt;仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="d0667a096bf26c8f0e621f049599d4e22e6ac8ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;module&lt;/code&gt; is not instrumented or if the given &lt;code&gt;function&lt;/code&gt; does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">如果未安装该 &lt;code&gt;module&lt;/code&gt; 或者给定的 &lt;code&gt;function&lt;/code&gt; 没有断点，则为无操作，并返回 &lt;code&gt;:not_found&lt;/code&gt; 。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03691d0408ebea241da0941314a2772b60f2370b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 操作数不是正确的列表，则返回不正确的列表。如果 &lt;code&gt;left&lt;/code&gt; 操作数不是正确的列表，则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6016e2f55c427f96fc5e301fda4f933dcb7f84cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;right&lt;/code&gt; 操作数不是正确的列表，则返回不正确的列表。如果 &lt;code&gt;left&lt;/code&gt; 操作数不是正确的列表，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37bfbc1115f3a777b2fb554294a534e238eccc25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unescape_map/1&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt;, the char is not escaped and the backslash is kept in the string.</source>
          <target state="translated">如果 &lt;code&gt;unescape_map/1&lt;/code&gt; 函数返回 &lt;code&gt;false&lt;/code&gt; ，则不会转义char并将反斜杠保留在字符串中。</target>
        </trans-unit>
        <trans-unit id="001e53accbd81c0682a50b72be746960fd2af2c9" translate="yes" xml:space="preserve">
          <source>If the IO &lt;code&gt;device&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">如果IO &lt;code&gt;device&lt;/code&gt; 是Unicode设备，则 &lt;code&gt;count&lt;/code&gt; 意味着要检索的Unicode代码点的数量。否则， &lt;code&gt;count&lt;/code&gt; 是要检索的原始字节数。</target>
        </trans-unit>
        <trans-unit id="8bc76fe61e905f5e8cd97c93427f5f8a0776bded" translate="yes" xml:space="preserve">
          <source>If the VM terminates programmatically, via &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;System.stop/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;System.halt/1&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#at_exit/1&quot;&gt;&lt;code&gt;at_exit/1&lt;/code&gt;&lt;/a&gt; callbacks are not executed.</source>
          <target state="translated">如果VM终止编程，经由&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;System.stop/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;System.halt/1&lt;/code&gt; &lt;/a&gt;时，&lt;a href=&quot;#at_exit/1&quot;&gt; &lt;code&gt;at_exit/1&lt;/code&gt; &lt;/a&gt;回调不会执行。</target>
        </trans-unit>
        <trans-unit id="00f4455df1d117303f7b4dec1a8e7c59907ae6e0" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">如果尚未引用别名，则失败，并出现&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。它处理字符列表，二进制文件和原子。</target>
        </trans-unit>
        <trans-unit id="75f023f5a8fb5579a176722fb1ddcce792e96e4e" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">如果尚未引用别名，则失败，并显示&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。它处理字符列表，二进制文件和原子。</target>
        </trans-unit>
        <trans-unit id="066a1698eac217d09441d2b5fb8b66f936f99de7" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">如果应用程序未配置回调模块，则此时开始。否则，调用其&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调。此函数返回的顶级主管的PID由运行时存储，以供以后使用，并且返回的应用程序状态也将保存（如果有）。</target>
        </trans-unit>
        <trans-unit id="e0a3a0af1299b136f054ee1bd9b8c1968e181e7d" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback is invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">如果应用程序未配置回调模块，则此时开始。否则，将调用其&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调。该函数返回的顶级主管的PID由运行时存储，以供以后使用，并且返回的应用程序状态也将保存（如果有）。</target>
        </trans-unit>
        <trans-unit id="562962b2b4cc24713b05513158139365a944c86f" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">如果参数 &lt;code&gt;msg&lt;/code&gt; 是二进制，它将使用给定参数作为消息引发&lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="df94a702176ed26ed614862093d3a9baa0557531" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">如果参数 &lt;code&gt;msg&lt;/code&gt; 是二进制文件，则使用给定参数作为消息会引发&lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="7fd89e207521cfe8f1ffff76704430fa5d151c3b" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">如果使用&lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将属性标记为 &lt;code&gt;accumulate&lt;/code&gt; ，则始终返回一个列表。如果未使用 &lt;code&gt;accumulate&lt;/code&gt; 标记属性并且未将其设置为任何值，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71a4ad2c3571e6dc0648a7ce18db0a118f1fca6f" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">如果使用&lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;将属性标记为 &lt;code&gt;accumulate&lt;/code&gt; ，则始终返回一个列表。如果未使用 &lt;code&gt;accumulate&lt;/code&gt; 标记该属性并且未将其设置为任何值，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adaf0c8947d55853c9d373e226af8475042db2c9" translate="yes" xml:space="preserve">
          <source>If the behaviour changes or &lt;code&gt;URI.HTTP&lt;/code&gt; does not implement one of the callbacks, a warning will be raised.</source>
          <target state="translated">如果行为更改或 &lt;code&gt;URI.HTTP&lt;/code&gt; 未实现回调之一，则将发出警告。</target>
        </trans-unit>
        <trans-unit id="99a1391ef43bb72cc7d48f8ee9698b12d1d27ff4" translate="yes" xml:space="preserve">
          <source>If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the &lt;code&gt;terminate&lt;/code&gt; callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor.</source>
          <target state="translated">如果子进程没有捕获出口，它将在收到第一个出口信号后立即关闭。如果子进程正在捕获退出，则将调用 &lt;code&gt;terminate&lt;/code&gt; 回调，并且子进程必须在合理的时间间隔内终止，然后由主管突然终止。</target>
        </trans-unit>
        <trans-unit id="05268b70bba2052aa1ccd1488036cae6ea1aa300" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the PID remains set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则PID保持设置为 &lt;code&gt;:undefined&lt;/code&gt; ,并且此函数返回 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c9cb2d2a33379f64c647839b2a1ab4dbc13e8f" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the child specification is added to the supervisor, the PID is set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则将子规范添加到主管中，PID设置为 &lt;code&gt;:undefined&lt;/code&gt; ,并且此函数返回 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef45b4e1f4c05bc44ee03bd5bad1f5e5a9ba93ef" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, then no child is added to the supervision tree and this function returns &lt;code&gt;:ignore&lt;/code&gt; too.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;:ignore&lt;/code&gt; ，则没有任何子级添加到监视树，并且该函数也返回 &lt;code&gt;:ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93487fcca765523c971b5da517cfe6d46d7ca27a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, the PID is added to the supervisor and this function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; 或 &lt;code&gt;{:ok, child, info}&lt;/code&gt; ，则将PID添加到主管，并且此函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="92f41de707f645e7e03c7c77ffbddced905df221" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, then child specification and PID are added to the supervisor and this function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; 或 &lt;code&gt;{:ok, child, info}&lt;/code&gt; ，则将子规范和PID添加到主管，并且此函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="8a7852d163c87ef12689fc28578feaecfcacfb9c" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，该函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; ，其中 &lt;code&gt;error&lt;/code&gt; 是一个包含有关错误和子规范的信息的术语。</target>
        </trans-unit>
        <trans-unit id="971c2677787cebeaf5076ea02ea7abe46523d9e1" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is the error or erroneous value returned from child process start function, or failure reason if it fails.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，此函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; ，其中 &lt;code&gt;error&lt;/code&gt; 是从子进程启动函数返回的错误或错误值，或失败原因（如果失败）。</target>
        </trans-unit>
        <trans-unit id="4ed3068726af85a0584fbeb7b657ccca120db122" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns &lt;code&gt;{:error, error}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则该函数返回 &lt;code&gt;{:error, error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e556a251ad20ce02002d9e36048516e94aeb978" translate="yes" xml:space="preserve">
          <source>If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as &lt;code&gt;:'🌢 Elixir'&lt;/code&gt;, &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt;, and &lt;code&gt;:&quot;123&quot;&lt;/code&gt;.</source>
          <target state="translated">如果冒号后面紧跟着原子名称周围的一对双引号或单引号，则该原子被认为是被引号。在具有无引号原子相反，这一个可以由任何Unicode字符（不仅字母），如 &lt;code&gt;:'🌢 Elixir'&lt;/code&gt; ， &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt; ，和 &lt;code&gt;:&quot;123&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8941e9716f24149ae17a893ee971b4de7ba5c0c1" translate="yes" xml:space="preserve">
          <source>If the compiler uses manifest files to track stale sources, it should define &lt;code&gt;manifests/0&lt;/code&gt;, and if it writes any output to disk it should also define &lt;code&gt;clean/0&lt;/code&gt;.</source>
          <target state="translated">如果编译器使用清单文件跟踪过时的源，则应定义 &lt;code&gt;manifests/0&lt;/code&gt; ，如果将任何输出写入磁盘，则还应定义 &lt;code&gt;clean/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56beff3afd9994ddacaef88c1f904aa35af05474" translate="yes" xml:space="preserve">
          <source>If the condition given to &lt;code&gt;if/2&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, the body given between &lt;code&gt;do/end&lt;/code&gt; is not executed and instead it returns &lt;code&gt;nil&lt;/code&gt;. The opposite happens with &lt;code&gt;unless/2&lt;/code&gt;.</source>
          <target state="translated">如果给 &lt;code&gt;if/2&lt;/code&gt; 的条件返回 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，则不会执行在 &lt;code&gt;do/end&lt;/code&gt; 之间给出的主体，而是返回 &lt;code&gt;nil&lt;/code&gt; 。相反的情况是， &lt;code&gt;unless/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b59e29ecc1dff1755220f8555df92bd2b4fe3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果配置参数不存在，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90ee89304a582019b79109925a1ae106da1b349f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果配置参数不存在，则引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b800c2816d5b5f752096a4e8e30fb37f2f59391" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">如果配置参数不存在，则该函数返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a592ffaee07d8c5f17b9ba6b9f33ed8e98c54d6f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns the &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">如果配置参数不存在，该函数将返回 &lt;code&gt;default&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="6759e47fd880f62f176d9957b609a75b5cf78194" translate="yes" xml:space="preserve">
          <source>If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">如果该天已经是一周的第一天，它将返回该天本身。对于内置的ISO日历，星期从星期一开始。一个工作日而不是 &lt;code&gt;:default&lt;/code&gt; 可以被指定为 &lt;code&gt;starting_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7fc25fab05e3574194267d1e7b17bc5554868b2" translate="yes" xml:space="preserve">
          <source>If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">如果该天已经是一周的最后一天，它将返回该天本身。对于内置的ISO日历，星期在星期日结束。一个工作日而不是 &lt;code&gt;:default&lt;/code&gt; 可以被指定为 &lt;code&gt;starting_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3cb9f3017a3cd59ff39001a965e946f4fe46ba2" translate="yes" xml:space="preserve">
          <source>If the dependency is locked, a lock is received in &lt;code&gt;opts&lt;/code&gt; and the repository must be check out at the lock. Otherwise, no lock is given and the repository can be checked out to the latest version.</source>
          <target state="translated">如果依赖项被锁定，则 &lt;code&gt;opts&lt;/code&gt; 中会收到一个锁，并且必须在该锁处检出存储库。否则，将不提供任何锁定，并且可以将存储库检出到最新版本。</target>
        </trans-unit>
        <trans-unit id="8f7a6151093f7c2a971f2852905fc785857fff18" translate="yes" xml:space="preserve">
          <source>If the element does not exist, it is added to the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果该元素不存在，则将其添加到 &lt;code&gt;list&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="3834eb098b76c8c7be976a57156c5a8c5b9abc11" translate="yes" xml:space="preserve">
          <source>If the enumerable is empty, the provided &lt;code&gt;empty_fallback&lt;/code&gt; is called. The default &lt;code&gt;empty_fallback&lt;/code&gt; raises &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果可枚举为空，则调用提供的 &lt;code&gt;empty_fallback&lt;/code&gt; 。默认的 &lt;code&gt;empty_fallback&lt;/code&gt; 引发&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a1b44730d66c61b1f7aa74b49b7cfff54912615" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;varname&lt;/code&gt; is set, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned where &lt;code&gt;value&lt;/code&gt; is a string. If &lt;code&gt;varname&lt;/code&gt; is not set, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">如果设置了环境变量 &lt;code&gt;varname&lt;/code&gt; ，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是一个字符串。如果未设置 &lt;code&gt;varname&lt;/code&gt; ，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea743105c28535da020399869c10ba09ded50b63" translate="yes" xml:space="preserve">
          <source>If the exception module implements the optional &lt;a href=&quot;#c:blame/2&quot;&gt;&lt;code&gt;blame/2&lt;/code&gt;&lt;/a&gt; callback, it will be invoked to perform the computation.</source>
          <target state="translated">如果异常模块实现了可选的&lt;a href=&quot;#c:blame/2&quot;&gt; &lt;code&gt;blame/2&lt;/code&gt; &lt;/a&gt;回调，则将调用它执行计算。</target>
        </trans-unit>
        <trans-unit id="6ba3395fcc44d77deb4fad259828439fe83f301c" translate="yes" xml:space="preserve">
          <source>If the exit reason is not &lt;code&gt;:normal&lt;/code&gt;, all the processes linked to the process that exited will crash (unless they are trapping exits).</source>
          <target state="translated">如果退出原因不是 &lt;code&gt;:normal&lt;/code&gt; ，则所有链接到已退出进程的进程都将崩溃（除非它们正在捕获退出）。</target>
        </trans-unit>
        <trans-unit id="69bc5d1890437acbe1c535fa849ec2779651267d" translate="yes" xml:space="preserve">
          <source>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">如果不能展开表达式,则返回表达式本身。这个函数不遍历AST,只对根节点进行展开。</target>
        </trans-unit>
        <trans-unit id="1d5138f099eddbd71facd7cd878f3e30168acb4c" translate="yes" xml:space="preserve">
          <source>If the external resource does not exist, the module still has a dependency on it, causing the module be recompiled as soon as the file is added.</source>
          <target state="translated">如果外部资源不存在,模块仍然对其有依赖性,导致模块在添加文件后立即重新编译。</target>
        </trans-unit>
        <trans-unit id="9daaa1fc9c23e088e0d8755d3c8c12ee8baa78ff" translate="yes" xml:space="preserve">
          <source>If the file already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">如果文件已经存在且内容不一样,则要求用户确认。</target>
        </trans-unit>
        <trans-unit id="dd469ee5a62e6b5a80b7c5e501b5ee43bbcd856c" translate="yes" xml:space="preserve">
          <source>If the file does exists, and if write is not combined with read, the file will be truncated.</source>
          <target state="translated">如果文件确实存在,并且如果写与读不结合,文件将被截断。</target>
        </trans-unit>
        <trans-unit id="4a926f33aaf552a1fcd49d45cc93ae59488a7d3e" translate="yes" xml:space="preserve">
          <source>If the file has been required, it returns &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">如果需要该文件，则返回 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d5c19fb123316598a0d9b3638a762db6e8c9b35b" translate="yes" xml:space="preserve">
          <source>If the file has not been required, it returns the list of modules:</source>
          <target state="translated">如果该文件没有被要求,则返回模块列表。</target>
        </trans-unit>
        <trans-unit id="f8fd33f5966315da13c7c5967bb4b7033821bc3d" translate="yes" xml:space="preserve">
          <source>If the function does not return &lt;code&gt;true&lt;/code&gt; for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</source>
          <target state="translated">如果函数对于相等的值未返回 &lt;code&gt;true&lt;/code&gt; ，则排序不稳定，并且相等项的顺序可能会被打乱。例如：</target>
        </trans-unit>
        <trans-unit id="46872c4f6b3b3d53e570bd775f9872272859aad0" translate="yes" xml:space="preserve">
          <source>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</source>
          <target state="translated">如果正在定义的函数/宏有多个子句,则会为每个子句调用钩子。</target>
        </trans-unit>
        <trans-unit id="49c229dbf0034a08eae6f9a0c1010fd39f336907" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;context&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (by default it is), the binding for the current context is returned.</source>
          <target state="translated">如果给定 &lt;code&gt;context&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; （默认为nil），则返回当前上下文的绑定。</target>
        </trans-unit>
        <trans-unit id="6978259d37eaf03d5b3cc55b25024a1b3148e5a5" translate="yes" xml:space="preserve">
          <source>If the given function callback fails, the function returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果给定的函数回调失败，则该函数返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ebfab2382584c9b3958f6f2fa9de700377fed5" translate="yes" xml:space="preserve">
          <source>If the given name does not exist, an error is raised.</source>
          <target state="translated">如果给定的名字不存在,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="3af8970b7302792aa5fbcf15bf7d3816a9358c60" translate="yes" xml:space="preserve">
          <source>If the given project configuration does not identify an umbrella project, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">如果给定的项目配置未标识总体项目，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46533ec867c9435d899cb6828abb727c8f1630e2" translate="yes" xml:space="preserve">
          <source>If the given project configuration identifies an umbrella project, the return value is a map of &lt;code&gt;app =&amp;gt; path&lt;/code&gt; where &lt;code&gt;app&lt;/code&gt; is a child app of the umbrella and &lt;code&gt;path&lt;/code&gt; is its path relative to the root of the umbrella project.</source>
          <target state="translated">如果给定的项目配置标识了伞项目，则返回值是 &lt;code&gt;app =&amp;gt; path&lt;/code&gt; 的映射，其中 &lt;code&gt;app&lt;/code&gt; 是伞的子应用，而 &lt;code&gt;path&lt;/code&gt; 是相对于伞项目根的路径。</target>
        </trans-unit>
        <trans-unit id="1a1e4f0e379f9bd60165b52c832ccce09165194e" translate="yes" xml:space="preserve">
          <source>If the given string is empty, an empty list is returned.</source>
          <target state="translated">如果给定的字符串为空,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="b5fa7671aa9ac1c4f631b6b91cdd66f8be6d72c5" translate="yes" xml:space="preserve">
          <source>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</source>
          <target state="translated">如果最后一个参数是一个数据结构,比如地图和列表,而且数据结构的开头与函数调用适合在同一行,那么就不会发生缩进,这就允许这样的代码。</target>
        </trans-unit>
        <trans-unit id="78f6031137384aa25684e5873b8f78717fddd500" translate="yes" xml:space="preserve">
          <source>If the last chunk does not have &lt;code&gt;count&lt;/code&gt; elements to fill the chunk, elements are taken from &lt;code&gt;leftover&lt;/code&gt; to fill in the chunk. If &lt;code&gt;leftover&lt;/code&gt; does not have enough elements to fill the chunk, then a partial chunk is returned with less than &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果最后一块没有 &lt;code&gt;count&lt;/code&gt; 元素来填充该块，则从 &lt;code&gt;leftover&lt;/code&gt; 部分中取出元素以填充该块。如果 &lt;code&gt;leftover&lt;/code&gt; 元素不足以填满该块，则将返回部分块，其中包含少于 &lt;code&gt;count&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="6d2f647fee30ac3b21a14f06f704594c6fc607f3" translate="yes" xml:space="preserve">
          <source>If the matching entry points to the node evaluating the request, then we&amp;rsquo;ve finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we&amp;rsquo;ll pass the request to this node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.</source>
          <target state="translated">如果匹配的条目指向评估请求的节点，则表明路由已完成，并且该节点将执行请求的操作。如果匹配的条目指向另一个节点，则将请求传递给该节点，该节点将查看其自己的路由表（可能与第一个节点中的路由表不同）并采取相应的措施。如果没有条目匹配，将引发错误。</target>
        </trans-unit>
        <trans-unit id="0e8da94808be345264b3caf7126393ed8c8b9f07" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this function returns &lt;code&gt;{:error, :unavailable}&lt;/code&gt;. Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future.</source>
          <target state="translated">如果正在检查的模块当前处于编译器死锁中，则此函数返回 &lt;code&gt;{:error, :unavailable}&lt;/code&gt; 。不可用并不一定意味着该模块不存在，只是该模块当前不可用，但将来（或将来可能）不可用。</target>
        </trans-unit>
        <trans-unit id="52158ebe3b1b3c65fb9901ffb1a952d081b6bc67" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this functions returns &lt;code&gt;{:error, :nofile}&lt;/code&gt;.</source>
          <target state="translated">如果正在检查的模块当前处于编译器死锁中，则此函数返回 &lt;code&gt;{:error, :nofile}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d2912dbde0fc1cf3c15e41a6a7b770a6ace8e7a" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not compiled yet, &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; halts the compilation of the caller until the module given to &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</source>
          <target state="translated">如果模块已加载，则它可以作为无操作。如果尚未编译该模块，则&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;停止调用方的编译，直到指定给&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;的模块可用或当前项目的所有文件都已编译为止。如果编译完成且模块不可用，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="4057f0905e6629307a032b9c000b6e956f9d35d4" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</source>
          <target state="translated">如果模块已经被加载,它就会以no-op的方式工作,如果模块还没有被加载,它就会检查是否需要先编译,然后再尝试加载。如果模块还没有加载,它检查是否需要先编译,然后再尝试加载。</target>
        </trans-unit>
        <trans-unit id="e5e8ed6a3a6371fcd484a0f8c9f4271b4ee45925" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</source>
          <target state="translated">如果模块已经被加载,这将作为no-op工作。如果模块还没有加载,则尝试加载它。</target>
        </trans-unit>
        <trans-unit id="a53b9d6b0418ab1b2e4ace2c2f0d58e6dbe324b3" translate="yes" xml:space="preserve">
          <source>If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">如果未安装该模块，或者给定的函数没有断点，则为无操作，并返回 &lt;code&gt;:not_found&lt;/code&gt; 。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b54c97a0a75e51befdfd85bfe55c94a87325400a" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">如果要在其上调用函数的模块有一个长名称，例如 &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; ，并且发现它很冗长，则可以利用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;特殊形式并将模块仍称为 &lt;code&gt;MyLib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3287b87c75de3c7f69ccf215597988b7b4d5d83" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">如果要在其上调用函数的模块有一个长名称，例如 &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; ，并且发现它很冗长，则可以利用&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt;特殊形式并将模块仍称为 &lt;code&gt;MyLib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80bfedd28d224208419788d64b48145856d28f2e" translate="yes" xml:space="preserve">
          <source>If the normalized &lt;code&gt;index_range.first&lt;/code&gt; is out of bounds of the given &lt;code&gt;enumerable&lt;/code&gt;, or this one is greater than the normalized &lt;code&gt;index_range.last&lt;/code&gt;, then &lt;code&gt;[]&lt;/code&gt; is returned.</source>
          <target state="translated">如果规范化的 &lt;code&gt;index_range.first&lt;/code&gt; 超出给定的 &lt;code&gt;enumerable&lt;/code&gt; 的范围，或者该值大于规范化的 &lt;code&gt;index_range.last&lt;/code&gt; ，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08e33554a9805c7015a58e968e41eb7b15679006" translate="yes" xml:space="preserve">
          <source>If the number is equidistant to the two nearest integers, rounds away from zero.</source>
          <target state="translated">如果数字与最接近的两个整数等距,则从零开始舍去。</target>
        </trans-unit>
        <trans-unit id="1ada57e8ed2825b579416e3a51bc87db286561fd" translate="yes" xml:space="preserve">
          <source>If the offset is greater than string length, then it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果偏移量大于字符串长度，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;:pop&lt;/code&gt; ，则此回调的返回值必须为 &lt;code&gt;{value, new_data}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;key&lt;/code&gt; 下的值（如果不存在，则为 &lt;code&gt;nil&lt;/code&gt; ），而 &lt;code&gt;new_data&lt;/code&gt; 是没有 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; ，则此回调的返回值应为 &lt;code&gt;{get_value, new_data}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="f3dea051cec0438020d90f4862f83ccd43c6add8" translate="yes" xml:space="preserve">
          <source>If the path given to &lt;code&gt;File.read/1&lt;/code&gt; exists, it returns a tuple with the atom &lt;code&gt;:ok&lt;/code&gt; as the first element and the file contents as the second. Otherwise, it returns a tuple with &lt;code&gt;:error&lt;/code&gt; and the error description.</source>
          <target state="translated">如果给定 &lt;code&gt;File.read/1&lt;/code&gt; 的路径存在，它将返回一个以原子 &lt;code&gt;:ok&lt;/code&gt; 作为第一个元素，而将文件内容作为第二个元素的元组。否则，它将返回带有 &lt;code&gt;:error&lt;/code&gt; 和错误描述的元组。</target>
        </trans-unit>
        <trans-unit id="53bd7b87b61d322c4fd45f7642221fa6272a8869" translate="yes" xml:space="preserve">
          <source>If the path is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored.</source>
          <target state="translated">如果该路径已经是绝对路径，则将忽略 &lt;code&gt;relative_to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4146f9776d17822883d0a24f1d05b48694b8cdc9" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly (be it by failing or providing a sane default).</source>
          <target state="translated">如果调用该函数之前的先前值为 &lt;code&gt;nil&lt;/code&gt; ，则该函数&lt;em&gt;将&lt;/em&gt;接收 &lt;code&gt;nil&lt;/code&gt; 作为值，并且必须进行相应处理（通过失败或提供合理的默认值）。</target>
        </trans-unit>
        <trans-unit id="4dbd652e27d03f3eda58f1454adbcc277b1cf2a2" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly.</source>
          <target state="translated">如果调用该函数之前的前一个值为 &lt;code&gt;nil&lt;/code&gt; ，则该函数&lt;em&gt;将&lt;/em&gt;接收 &lt;code&gt;nil&lt;/code&gt; 作为值，并且必须进行相应处理。</target>
        </trans-unit>
        <trans-unit id="c374c88228928cded93b273d043b81d7a9e4db50" translate="yes" xml:space="preserve">
          <source>If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then &lt;code&gt;handle_info/2&lt;/code&gt; will be called with &lt;code&gt;:timeout&lt;/code&gt; as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout.</source>
          <target state="translated">如果在设置超时时进程没有等待消息，并且经过指定的毫秒数而没有消息到达，则将以 &lt;code&gt;:timeout&lt;/code&gt; 作为第一个参数来调用 &lt;code&gt;handle_info/2&lt;/code&gt; 。如果有任何消息正在等待或在给定超时之前到达，则清除超时。</target>
        </trans-unit>
        <trans-unit id="029b68fe64722c4e17e93dd0458f45ae756acd0b" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;pid&lt;/code&gt; is alive (that is, it's not exiting and has not exited yet) than this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;pid&lt;/code&gt; 标识的进程仍处于活动状态（也就是说，它尚未退出并且尚未退出），则此函数将返回 &lt;code&gt;true&lt;/code&gt; 。否则，它返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f04e984ddcea311ccb003e5103d4ca1f57a069c" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;时进程已死，则立即发送 &lt;code&gt;:DOWN&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="69f0fc29573a8d218a644c814446337651d8b2a1" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">如果在调用&lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt;时进程已死，则立即发送 &lt;code&gt;:DOWN&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="25b64d8d09022ae8fa6be42d0e689d9f55f93a0d" translate="yes" xml:space="preserve">
          <source>If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed.</source>
          <target state="translated">如果登记处有重复的键,则允许在同一键下从当前进程进行多次登记。</target>
        </trans-unit>
        <trans-unit id="296325dc97cde1334962459eb9c5ec5273a16093" translate="yes" xml:space="preserve">
          <source>If the registry has unique keys, it will return &lt;code&gt;{:ok, owner}&lt;/code&gt; unless the key is already associated to a PID, in which case it returns &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt;.</source>
          <target state="translated">如果注册表具有唯一键，除非键已经与PID关联，否则它将返回 &lt;code&gt;{:ok, owner}&lt;/code&gt; ，在这种情况下，它将返回 &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86406b94fdf6d0355c113c51cd4e50d8ab966009" translate="yes" xml:space="preserve">
          <source>If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and &lt;code&gt;parallel: true&lt;/code&gt; is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition.</source>
          <target state="translated">如果注册表已分区，则每个分区将多次调用该回调。如果注册表是分区且 &lt;code&gt;parallel: true&lt;/code&gt; 作为选项提供，则调度是并行进行的。在这两种情况下，仅当该分区有条目时才调用回调。</target>
        </trans-unit>
        <trans-unit id="ee4f792d4247d36f7519cbe4df3f7c9194b0d6d3" translate="yes" xml:space="preserve">
          <source>If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry.</source>
          <target state="translated">如果登记处是唯一的,则键是唯一的。否则,如果进程多次在同一键下注册,它们可能包含重复。如果进程已死或在该注册表中没有键,则列表为空。</target>
        </trans-unit>
        <trans-unit id="cc9c622905709241fd4a039cba6efcb68b163916" translate="yes" xml:space="preserve">
          <source>If the repository is private though, you may need to specify the private URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt;. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.</source>
          <target state="translated">如果存储库是私有的，则可能需要指定私有URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt; 。无论如何，只要您具有适当的凭据，Mix就能为您获取它。</target>
        </trans-unit>
        <trans-unit id="8f88ca4263ab5c36582e4eb171ede7757f5a8977" translate="yes" xml:space="preserve">
          <source>If the running process terminates, a new IEx session is started.</source>
          <target state="translated">如果正在运行的进程终止,则会启动一个新的 IEx 会话。</target>
        </trans-unit>
        <trans-unit id="85e3fc96a9666ea6c8e81e1cf2be2da940abf807" translate="yes" xml:space="preserve">
          <source>If the same key is set via &lt;code&gt;@tag&lt;/code&gt;, the &lt;code&gt;@tag&lt;/code&gt; value has higher precedence.</source>
          <target state="translated">如果通过 &lt;code&gt;@tag&lt;/code&gt; 设置了相同的键，则 &lt;code&gt;@tag&lt;/code&gt; 值具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="bba8e4c316db50e3c886fad2f7191375910352b7" translate="yes" xml:space="preserve">
          <source>If the same variable appears twice in the same pattern, then they must be bound to the same value:</source>
          <target state="translated">如果同一个变量在同一个模式中出现两次,那么它们必须绑定在同一个值上。</target>
        </trans-unit>
        <trans-unit id="c381bd34f0f516da0adf5a6559d1022816298c76" translate="yes" xml:space="preserve">
          <source>If the scheme is unknown to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module, this function returns &lt;code&gt;nil&lt;/code&gt;. The default port for any scheme can be configured globally via &lt;a href=&quot;#default_port/2&quot;&gt;&lt;code&gt;default_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;模块不知道该方案，则此函数返回 &lt;code&gt;nil&lt;/code&gt; 。可以通过&lt;a href=&quot;#default_port/2&quot;&gt; &lt;code&gt;default_port/2&lt;/code&gt; &lt;/a&gt;全局配置任何方案的默认端口。</target>
        </trans-unit>
        <trans-unit id="1cf20abb00a9c7eb91eeec27cb0a3c2044ccf845" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, the function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If an agent with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">如果成功创建和初始化服务器，则该函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是服务器的PID。如果已经存在具有指定名称的代理，则该函数将使用该进程的PID 返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ae18b173fd4f257f191d68374b82b3609576f9a" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If a process with the specified server name already exists, this function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">如果成功创建和初始化服务器，则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是服务器的PID。如果已经存在具有指定服务器名称的进程，则此函数将返回带有该进程的PID的 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c79dacc73fa9835dcb970cb3bd153402ac7a2c0" translate="yes" xml:space="preserve">
          <source>If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:</source>
          <target state="translated">如果标示字母是大写的,则标示中不允许插值,否则其内容可能是动态的。比较下面的符码结果,以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="f0d8fa47818ba024a0ca6635125390659b191c06" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果浮体的大小超过最大大小 &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; ，所述&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="afe9e25d91e6b6ca076f9ab983498ce202d449f4" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果浮体的大小超过最大大小 &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; ，所述&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="1f18c5146917295cd360116e64980d6814f74742" translate="yes" xml:space="preserve">
          <source>If the source is a file, it copies &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;. If the &lt;code&gt;source&lt;/code&gt; is a directory, it copies the contents inside source into the &lt;code&gt;destination&lt;/code&gt; directory.</source>
          <target state="translated">如果源是文件，它将 &lt;code&gt;source&lt;/code&gt; 复制到 &lt;code&gt;destination&lt;/code&gt; 。如果 &lt;code&gt;source&lt;/code&gt; 是目录，它将源内部的内容复制到 &lt;code&gt;destination&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="d79c1221466668c8f2fb37f46a9b0c4eff50c912" translate="yes" xml:space="preserve">
          <source>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason &lt;code&gt;:shutdown&lt;/code&gt; all the child processes that have already been started, and then terminates itself and returns &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt;.</source>
          <target state="translated">如果任何子进程的启动功能失败或返回错误的元组或错误的值，则主管首先以以下原因终止 &lt;code&gt;:shutdown&lt;/code&gt; 所有已启动的子进程，然后终止自身并返回 &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95311d242d980eca3e042ab39a6d275172dd2491" translate="yes" xml:space="preserve">
          <source>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果范围的开头不是给定字符串的有效偏移量，或者范围的顺序相反，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdd805e8128eab933d8276c52b9cb625ab5fad9b" translate="yes" xml:space="preserve">
          <source>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</source>
          <target state="translated">如果范围的开始或结束是负数,则首先遍历整个字符串,以便将负数指数转换为正数。</target>
        </trans-unit>
        <trans-unit id="fa648af6a9f14eed70d03b7bbaf8c1091284802b" translate="yes" xml:space="preserve">
          <source>If the supervisor already has N children in a way that N exceeds the amount of &lt;code&gt;:max_children&lt;/code&gt; set on the supervisor initialization (see &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;), then this function returns &lt;code&gt;{:error, :max_children}&lt;/code&gt;.</source>
          <target state="translated">如果管理者已经有N &lt;code&gt;:max_children&lt;/code&gt; ，而N超过了管理者初始化上设置的：max_children的数量（请参阅&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;），则此函数返回 &lt;code&gt;{:error, :max_children}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab3a50abd31e0fe599ff965258406372848105a0" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully spawned (if the start function of each child process returns &lt;code&gt;{:ok, child}&lt;/code&gt;, &lt;code&gt;{:ok, child, info}&lt;/code&gt;, or &lt;code&gt;:ignore&lt;/code&gt;) this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">如果成功生成了主管及其子进程（如果每个子进程的start函数返回 &lt;code&gt;{:ok, child}&lt;/code&gt; ， &lt;code&gt;{:ok, child, info}&lt;/code&gt; 或 &lt;code&gt;:ignore&lt;/code&gt; ），则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是主管的PID。如果为主管指定了一个名称，并且已经存在具有指定名称的进程，则该函数将返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是该进程的PID。</target>
        </trans-unit>
        <trans-unit id="ba930cdc55e703dfc4d9bcd1944d94e721ba5186" translate="yes" xml:space="preserve">
          <source>If the supervisor is successfully spawned, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">如果成功生成了超级用户，则此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是超级用户的PID。如果为主管指定了名称，并且已经存在具有指定名称的进程，则该函数将返回 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; ，其中 &lt;code&gt;pid&lt;/code&gt; 是该进程的PID。</target>
        </trans-unit>
        <trans-unit id="a58325ece0282e34604d2c42efce1f2775632579" translate="yes" xml:space="preserve">
          <source>If the task or alias has already been invoked, subsequent calls to &lt;a href=&quot;#run/2&quot;&gt;&lt;code&gt;run/2&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;abort&lt;/em&gt; without executing and return &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">如果任务或别名已被调用，则随后对&lt;a href=&quot;#run/2&quot;&gt; &lt;code&gt;run/2&lt;/code&gt; 的&lt;/a&gt;调用将&lt;em&gt;中止&lt;/em&gt;而不执行，并返回 &lt;code&gt;:noop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e53af2f1716d98281bb0f2f71d348e2e0b0ca4dd" translate="yes" xml:space="preserve">
          <source>If the task or alias were already invoked, it does not run them again and simply aborts with &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">如果任务或别名已被调用，则不会再次运行它们，而只是通过 &lt;code&gt;:noop&lt;/code&gt; 中止。</target>
        </trans-unit>
        <trans-unit id="bdd5aaa87ae18322d70f284e647adedce16eae03" translate="yes" xml:space="preserve">
          <source>If the task was not yet invoked, it runs the task and returns the result.</source>
          <target state="translated">如果任务尚未被调用,则运行任务并返回结果。</target>
        </trans-unit>
        <trans-unit id="1ffe14eba0b86eb2256ef62d3f747347750fc072" translate="yes" xml:space="preserve">
          <source>If the terms compare equal, the first one is returned.</source>
          <target state="translated">如果比较条件相同,则返回第一个条件。</target>
        </trans-unit>
        <trans-unit id="76f5c2bf2f306f61b2cf3e6037db4001b825a0db" translate="yes" xml:space="preserve">
          <source>If the use case where you were using GenEvent requires more complex logic, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用GenEvent的用例需要更复杂的逻辑，则&lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt;提供了一个很好的选择。GenStage是Elixir团队维护的外部Elixir库。它提供了一种工具，用于实施以需求驱动方式交换事件的系统以及对背压的内置支持。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dea741f0a7bd15d40b84d96d22a4ee172da3fb54" translate="yes" xml:space="preserve">
          <source>If the use of this module were confined to your own project, you would be able to keep defining new &lt;code&gt;type/1&lt;/code&gt; functions for each new data type. However, this code could be problematic if it were shared as a dependency by multiple apps because there would be no easy way to extend its functionality.</source>
          <target state="translated">如果此模块的使用仅限于您自己的项目，则可以为每种新数据类型继续定义新的 &lt;code&gt;type/1&lt;/code&gt; 函数。但是，如果此代码被多个应用程序作为依赖项共享，则可能会出现问题，因为没有简单的方法来扩展其功能。</target>
        </trans-unit>
        <trans-unit id="a623a53d8f71f4bfc3e91a4b2fa820b73e9de973" translate="yes" xml:space="preserve">
          <source>If there are config providers, then a value is injected into the &lt;code&gt;:elixir&lt;/code&gt; application configuration in &lt;code&gt;sys_config&lt;/code&gt; to be read during boot and trigger the providers.</source>
          <target state="translated">如果有配置提供程序，则将一个值注入 &lt;code&gt;sys_config&lt;/code&gt; 中的 &lt;code&gt;:elixir&lt;/code&gt; 应用程序配置中，以便在引导期间读取并触发提供程序。</target>
        </trans-unit>
        <trans-unit id="0f3ba34b6884281919234bd65a5c27e05d943121" translate="yes" xml:space="preserve">
          <source>If there are duplicated keys, they are all removed and only the first one is updated.</source>
          <target state="translated">如果有重复的键,则全部删除,只更新第一个键。</target>
        </trans-unit>
        <trans-unit id="4cc5164cbf429134f06fc3a42dc1c775490799c5" translate="yes" xml:space="preserve">
          <source>If there are no errors, returns a &lt;code&gt;{parsed, rest}&lt;/code&gt; tuple where:</source>
          <target state="translated">如果没有错误，则返回一个 &lt;code&gt;{parsed, rest}&lt;/code&gt; 元组，其中：</target>
        </trans-unit>
        <trans-unit id="5f562d79d2233001e164c67b307f491a4295de9f" translate="yes" xml:space="preserve">
          <source>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</source>
          <target state="translated">如果括号周围没有换行,那么格式化器会尝试将所有内容放在一行中,比如下面的代码段</target>
        </trans-unit>
        <trans-unit id="ec750b5e724607eb9b83c43fb0d225987965cd76" translate="yes" xml:space="preserve">
          <source>If there exists a task matching the given task name and it has not yet been invoked, this will run the task with the given &lt;code&gt;args&lt;/code&gt; and return the result.</source>
          <target state="translated">如果存在与给定任务名称匹配的任务，并且尚未被调用，则将使用给定 &lt;code&gt;args&lt;/code&gt; 运行该任务并返回结果。</target>
        </trans-unit>
        <trans-unit id="21bb1c823fd135c98a6434a0ecb8b17912934fc2" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;alias&lt;/a&gt; defined for the given task name, the alias will be invoked instead of the original task.</source>
          <target state="translated">如果有一个&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;别名&lt;/a&gt;为给定的任务名称定义别名将被调用，而不是原来的任务。</target>
        </trans-unit>
        <trans-unit id="8e379b9421d0be8405c193a1a3a55eda70ffe92a" translate="yes" xml:space="preserve">
          <source>If there is an alias with the same name, the alias will be invoked instead of the original task.</source>
          <target state="translated">如果有同名的别名,则会调用该别名代替原来的任务。</target>
        </trans-unit>
        <trans-unit id="b8c630c661fb48b6b67b3b3185448712f080b96d" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">如果有兴趣在本地注册动态名称，请不要使用原子，因为原子绝不会被垃圾收集，因此动态生成的原子将不会被垃圾收集。在这种情况下，您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;模块来设置自己的本地注册表。</target>
        </trans-unit>
        <trans-unit id="742d780da366c9749e094a3e2601e05af9f19b1c" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">如果有兴趣在本地注册动态名称，请不要使用原子，因为原子绝不会被垃圾收集，因此动态生成的原子将不会被垃圾收集。在这种情况下，您可以使用&lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;模块来设置自己的本地注册表。</target>
        </trans-unit>
        <trans-unit id="09ae9d40e8862f6952cd3759209cd2022fc6c81a" translate="yes" xml:space="preserve">
          <source>If there is an invalid dependency, its status is printed before aborting.</source>
          <target state="translated">如果有一个无效的依赖关系,在中止之前会打印它的状态。</target>
        </trans-unit>
        <trans-unit id="1e0688b7a0e6bd6041bf3e04042b749415e0032c" translate="yes" xml:space="preserve">
          <source>If there is no current project, &lt;code&gt;nil&lt;/code&gt; is returned. This may happen in cases there is no &lt;code&gt;mix.exs&lt;/code&gt; in the current directory.</source>
          <target state="translated">如果没有当前项目，则返回 &lt;code&gt;nil&lt;/code&gt; 。如果当前目录中没有 &lt;code&gt;mix.exs&lt;/code&gt; ，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="c639ca5dfec4193385c0f9daeb2b1d4be710cc52" translate="yes" xml:space="preserve">
          <source>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</source>
          <target state="translated">如果邮箱中没有与任何模式匹配的消息,当前进程将等待匹配的消息到达。也可以指定一个超时时间。</target>
        </trans-unit>
        <trans-unit id="1cbcac0d0378ca0df3e990fb1469a678a45c89ea" translate="yes" xml:space="preserve">
          <source>If there is no option, we generate a random one the first time.</source>
          <target state="translated">如果没有选项,我们第一时间随机生成一个。</target>
        </trans-unit>
        <trans-unit id="8408450afd5b2f3e9042d1b8c13e9f58240f928f" translate="yes" xml:space="preserve">
          <source>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</source>
          <target state="translated">如果没有定义项目,它仍然返回一个带有默认值的关键字列表。这使得许多Mix任务可以在不需要底层项目的情况下工作。</target>
        </trans-unit>
        <trans-unit id="6b4a62bcf57109f5efa07a74f29988033109640c" translate="yes" xml:space="preserve">
          <source>If there is no such link, this function does nothing. If &lt;code&gt;pid_or_port&lt;/code&gt; does not exist, this function does not produce any errors and simply does nothing.</source>
          <target state="translated">如果没有这样的链接，则此功能不执行任何操作。如果 &lt;code&gt;pid_or_port&lt;/code&gt; 不存在，则此函数不会产生任何错误，并且只会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="690bb679a1fa855e4e7e99b242998643c82b454f" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, the a tuple with &lt;code&gt;:single&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">如果提供的 &lt;code&gt;datetime&lt;/code&gt; 只有一个可能的时间段，则返回带有 &lt;code&gt;:single&lt;/code&gt; 和 &lt;code&gt;time_zone_period&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="517af2219a54d5ffad122594bfbc6b466e49d962" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, then a tuple with &lt;code&gt;:ok&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">如果提供的 &lt;code&gt;datetime&lt;/code&gt; 只有一个可能的时间段，则返回带有 &lt;code&gt;:ok&lt;/code&gt; 和 &lt;code&gt;time_zone_period&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="f87cf65c1843c87f5a9fb595853f1c2faf34fb20" translate="yes" xml:space="preserve">
          <source>If this function receives a binary, the same binary is returned.</source>
          <target state="translated">如果该函数接收到一个二进制,则返回相同的二进制。</target>
        </trans-unit>
        <trans-unit id="8ec445d356d6135c24d3babce972b050d1a27a32" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt;，请使用Task.start / 1或考虑使用 &lt;code&gt;async_nolink&lt;/code&gt; 或 &lt;code&gt;start_child&lt;/code&gt; 在&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;下启动任务。</target>
        </trans-unit>
        <trans-unit id="722410509d91a2ea35d8481e8dcb2edd1a9471e8" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;task#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;task#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt;，请使用Task.start / 1或考虑使用 &lt;code&gt;async_nolink&lt;/code&gt; 或 &lt;code&gt;start_child&lt;/code&gt; 在&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;下启动任务。</target>
        </trans-unit>
        <trans-unit id="885b568a39d2f2144bcbdbe9f088220630bb0f55" translate="yes" xml:space="preserve">
          <source>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</source>
          <target state="translated">如果不满足这些条件,行为是未定义的(在Erlang/OTP 21和更早的版本上)或将引发(在Erlang/OTP 22和更早的版本上)。</target>
        </trans-unit>
        <trans-unit id="c532c9eeb04daa8871cfe8c245158904c23d03c5" translate="yes" xml:space="preserve">
          <source>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">如果两个日历不兼容,我们只能在它们之间转换日期和时间。如果它们是兼容的,这意味着我们也可以在它们之间转换日期和天真的日期时间。</target>
        </trans-unit>
        <trans-unit id="6230d8e63d2f6528e6ac7ed7bd4bbeed089d2da9" translate="yes" xml:space="preserve">
          <source>If two modules &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are imported and they both contain a &lt;code&gt;foo&lt;/code&gt; function with an arity of &lt;code&gt;1&lt;/code&gt;, an error is only emitted if an ambiguous call to &lt;code&gt;foo/1&lt;/code&gt; is actually made; that is, the errors are emitted lazily, not eagerly.</source>
          <target state="translated">如果导入了两个模块 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，并且它们都包含Arity为 &lt;code&gt;1&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 函数，则仅当实际上对 &lt;code&gt;foo/1&lt;/code&gt; 进行了模棱两可的调用时，才会发出错误；也就是说，错误是懒惰而不是急于发出的。</target>
        </trans-unit>
        <trans-unit id="55cdfd10bc87ea7561c4ad8cc479f9faf3b27132" translate="yes" xml:space="preserve">
          <source>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</source>
          <target state="translated">如果有大写字母,作为保留缩略语的机制,它们不作任何修改。</target>
        </trans-unit>
        <trans-unit id="1343958b023308460ee2f6f5daf43ba1fb660edd" translate="yes" xml:space="preserve">
          <source>If we save the code above in a file named &amp;ldquo;concat.ex&amp;rdquo; and compile it, Elixir will emit the following warning:</source>
          <target state="translated">如果将上面的代码保存在名为&amp;ldquo; concat.ex&amp;rdquo;的文件中并进行编译，Elixir将发出以下警告：</target>
        </trans-unit>
        <trans-unit id="8fc6b97491613a1b35780efb44cacd0f0d9099d1" translate="yes" xml:space="preserve">
          <source>If we start our server, we can now send commands to it. For now, we will get two different responses: &amp;ldquo;OK&amp;rdquo; when the command is known and &amp;ldquo;UNKNOWN COMMAND&amp;rdquo; otherwise:</source>
          <target state="translated">如果启动服务器，我们现在可以向其发送命令。现在，我们将获得两种不同的响应：知道命令后为&amp;ldquo; OK&amp;rdquo;，否则为&amp;ldquo; UNKNOWN COMMAND&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="74591893e85cc364e81b230bedab46ae114fe665" translate="yes" xml:space="preserve">
          <source>If we try to dispatch to &lt;code&gt;Hello.world&lt;/code&gt;, it won't be available as it was defined only in the other shell:</source>
          <target state="translated">如果我们尝试分派到 &lt;code&gt;Hello.world&lt;/code&gt; ，则它将仅在另一个shell中定义，因此将不可用：</target>
        </trans-unit>
        <trans-unit id="51c60bac3d7f07a69c2caf5416fb9b2fa0580339" translate="yes" xml:space="preserve">
          <source>If we use chardata instead, it will work as expected:</source>
          <target state="translated">如果我们使用chardata来代替,它将按照预期的方式工作。</target>
        </trans-unit>
        <trans-unit id="5c38beec4d9e8627a3718fd3acf1efdd27ca154a" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;code&gt;:into&lt;/code&gt;, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</source>
          <target state="translated">如果要使用 &lt;code&gt;:into&lt;/code&gt; ，则需要一个数据类型，该数据类型可以计算每个元素包含的频率。尽管Elixir中没有此类数据类型，但您可以自己实现一个。</target>
        </trans-unit>
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">如果你给一个模块起了别名,但你没有使用这个别名,Elixir就会发出一个警告,暗示这个别名没有被使用。</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">如果你连接到远程shell,在断开连接后,它仍然活着。</target>
        </trans-unit>
        <trans-unit id="6de1badf3f486dd7b08674c46aeede1396ae7af3" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您对实施事件管理器感兴趣，请阅读下面的&amp;ldquo;替代方法&amp;rdquo;部分。如果必须实现事件处理程序以与现有系统集成，例如Elixir的Logger，请改用&lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">如果您对实施事件管理器感兴趣，请阅读下面的&amp;ldquo;替代方法&amp;rdquo;部分。如果必须实现事件处理程序以与现有系统集成，例如Elixir的Logger，请改用 &lt;code&gt;:gen_event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">如果您要寻找在生产中使用的分布式键值存储，则一定要考虑&lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;，它也可以在Erlang中运行</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">如果您使用的是Windows，则必须打开 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; ，在这里可以找到：</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">如果您打算编写第一个库供其他开发人员使用，请不要忘记阅读我们的&lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;库指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f27d0db77231a9a9fe1e42f70173831ee041fc6d" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; attribute, you must set them after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">如果要设置 &lt;code&gt;@moduletag&lt;/code&gt; 或 &lt;code&gt;@describetag&lt;/code&gt; 属性，则必须在调用后 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">如果要设置 &lt;code&gt;@moduletag&lt;/code&gt; ，则必须在调用后 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 设置，否则会看到编译错误。</target>
        </trans-unit>
        <trans-unit id="5362f8df1641dd054f73093e43438bbe86931ff4" translate="yes" xml:space="preserve">
          <source>If you are setting this option manually, we recommend the cookie option to be a long and randomly generated string, such as: &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt;. We also recommend to restrict the characters in the cookie to the subset returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt;&lt;code&gt;Base.url_encode64/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您手动设置此选项，我们建议cookie选项是一个随机生成的长字符串，例如： &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt; 。我们还建议将cookie中的字符限制为&lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt; &lt;code&gt;Base.url_encode64/1&lt;/code&gt; &lt;/a&gt;返回的子集。</target>
        </trans-unit>
        <trans-unit id="84977d9680ddbf5de974cbe18e56c1d8e5ed315c" translate="yes" xml:space="preserve">
          <source>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</source>
          <target state="translated">如果您使用的是替代性日历,只要在表示方式后面加上一个空格和日历名称,就可以使用任何表示方式。</target>
        </trans-unit>
        <trans-unit id="7fff90eb4ac49dc35b69d8799d504d16e31937d0" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">如果您使用的是异步任务，则&lt;strong&gt;必须等待&lt;/strong&gt;答复，因为它们&lt;em&gt;总是&lt;/em&gt;被发送。如果您不希望得到答复，请考虑使用下面详述的&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">如果您使用的是异步任务，则&lt;strong&gt;必须等待&lt;/strong&gt;答复，因为它们&lt;em&gt;总是&lt;/em&gt;被发送。如果您不希望得到答复，请考虑使用下面详述的&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">如果使用发行版，请参阅&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;，还有另一个名为 &lt;code&gt;config/releases.exs&lt;/code&gt; 的配置文件。尽管每当您运行Mix命令（包括在汇编发行版时）都会执行上一节中提到的 &lt;code&gt;config/config.exs&lt;/code&gt; 和朋友，但是每次在生产系统启动时都会执行 &lt;code&gt;config/releases.exs&lt;/code&gt; 。由于Mix在生产系统中不可用，因此 &lt;code&gt;config/releases.exs&lt;/code&gt; 不得使用Mix中的任何功能。</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">如果你正在使用一个给定模块中的几个函数,你可以导入这些函数,并将其作为本地函数引用,例如。</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">如果你试图定义一个已经存在的模块,你会得到一个警告,说一个模块已经被重新定义。</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">如果你再次连接到localhost并执行另一个请求,只要路由表包含正确的节点名称,现在一切都应该正常。优秀!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">如果您在诸如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之&lt;/a&gt;类的OTP行为中使用 &lt;code&gt;async_nolink&lt;/code&gt; 创建任务，则应该匹配&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调中来自该任务的消息。</target>
        </trans-unit>
        <trans-unit id="7afc1a9d68fb426d62d00d555f8cf086c3ea70ff" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">如果您在诸如&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之&lt;/a&gt;类的OTP行为中使用 &lt;code&gt;async_nolink&lt;/code&gt; 创建任务，则应匹配&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调中来自该任务的消息。</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您希望在外壳内部执行受信任的命令（包括管道，重定向等），请检查&lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c4ee42b2a872c035a26a259f3f919efaaede387" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">如果您不关心计算结果，则可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; &lt;/a&gt;运行流。还设置了 &lt;code&gt;ordered: false&lt;/code&gt; ，因为您也不关心结果的顺序：</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">如果您不关心计算结果，则可以使用&lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; &lt;/a&gt;运行流。还设置了 &lt;code&gt;ordered: false&lt;/code&gt; ，因为您也不关心结果的顺序：</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">如果您确实想解析未知开关，请记住Elixir会将开关转换为原子。由于原子不是垃圾收集的，所以OptionParser将仅解析转换为运行时使用的原子的开关，以避免泄漏原子。例如，下面的代码将丢弃 &lt;code&gt;--option-parser-example&lt;/code&gt; 开关，因为 &lt;code&gt;:option_parser_example&lt;/code&gt; 原子从未在任何地方使用：</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">如果您没有使用该错误，则无需提供该错误：</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">如果在定义结构时未指定默认键值，则将假定为 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">如果你不需要进程,那么你就不需要进程。只用进程来模拟运行时的属性,比如可突变的状态、并发和失败,而不是用于代码组织。</target>
        </trans-unit>
        <trans-unit id="c5e7f3f6aaa70bf2b4b5317311d23bff5dd41301" translate="yes" xml:space="preserve">
          <source>If you don't want to assert for every result in a doctest, you can omit the result. You can do so between expressions:</source>
          <target state="translated">如果你不想对doctest中的每个结果进行断言,你可以省略结果。你可以在表达式之间这样做。</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">如果您不想从&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入函数或宏，请使用 &lt;code&gt;:except&lt;/code&gt; 选项，然后按Arity列出函数/宏：</target>
        </trans-unit>
        <trans-unit id="b4113a290da07af08fe359b9ce4d7fc5b55806b8" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不想将调用者链接到任务，则必须将受监督的任务与&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;一起使用，并调用&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不想将调用者链接到任务，则必须将受监管的任务与&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;一起使用，并调用&lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">如果您不想删除与 &lt;code&gt;key&lt;/code&gt; 关联的所有条目，请使用&lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt;，该函数将仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您希望定义一个项目，即它是当前任务的要求，则应改为调用&lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">如果您在本教程或网站上发现任何错误，&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;请报告错误或将拉取请求发送到我们的问题跟踪器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">如果你发现自己处于这样的境地:你想在每个应用程序中为同一个依赖关系使用不同的配置,或者使用不同的依赖版本,那么很可能你的代码库的发展已经超出了保护伞所能提供的范围。</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">如果您发现自己正在陷阱出口以处理异步流中的出口，请考虑使用&lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt;来启动未链接到调用进程的任务。</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">如果你忘了转义,Elixir在编译代码时就会出错。</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">如果你有一个需要并行编译其他模块的文件,那么产生的进程需要知道编译器环境。这个函数可以让开发人员创建一个知道这些环境的任务。</target>
        </trans-unit>
        <trans-unit id="c5adbe460020f7a732f72beadb2bbe1b2658c06f" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您有一个结构，并且想要将一组键合并到该结构中，请不要使用此功能，因为它将把右侧的所有键合并到该结构中，即使该键不是该结构的一部分。而是使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您有一个结构体，并且希望将一组键合并到该结构体中，请不要使用此功能，因为它将把右侧的所有键合并到该结构体中，即使该键不属于该结构体。而是使用&lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">如果你有一个内部依赖,Mix支持两种方法来处理它们。Git仓库或伞形项目。</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">如果您在同一网络上有一台同时安装了Erlang和Elixir的计算机，则可以在其上启动另一个外壳程序。如果不这样做，则可以在另一个终端中启动另一个IEx会话。在任何一种情况下，都给它简称 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">如果您对本指南有任何疑问或改进，请访问讨论渠道，例如&lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir论坛&lt;/a&gt;或&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;问题跟踪器&lt;/a&gt;。您的意见非常重要，有助于我们确保指南的可用性和最新性！</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">如果您有过编程经验，您可能会想：&amp;ldquo;我们是否可以保证铲斗首先不会崩溃？&amp;rdquo;。正如我们将看到的那样，Elixir开发人员倾向于将这些实践称为&amp;ldquo;防御性编程&amp;rdquo;。那是因为现场生产系统有很多不同的原因会导致错误。磁盘可能发生故障，内存可能损坏，错误，网络可能会停止运行一秒钟等等。如果我们要编写试图保护或避免所有这些错误的软件，那么与编写我们的错误相比，我们将花费更多的时间来处理错误自己的软件！</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">如果您已跳过入门指南或很早以前就读过它，请务必重新阅读&amp;ldquo; &lt;a href=&quot;../processes&quot;&gt;过程&amp;rdquo;&lt;/a&gt;一章。我们将以此为起点。</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">如果你必须这样做,你可以认为行为就像Java等面向对象语言中的接口:一组模块必须实现的函数签名。</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">如果您尚未安装Elixir，请访问我们的&lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;安装页面&lt;/a&gt;。完成后，您可以运行 &lt;code&gt;elixir --version&lt;/code&gt; 获得当前的Elixir版本。</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">如果你导入了一个模块,但你没有使用这个模块的任何导入函数或宏,Elixir就会发出警告,暗示没有使用导入的函数。</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">如果打算在 &lt;code&gt;timeout&lt;/code&gt; 毫秒内没有响应的情况下关闭任务，则应将其与&lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt;链接在一起，如下所示：</target>
        </trans-unit>
        <trans-unit id="d30e514f11705943605d282b2e9e021b246888e0" translate="yes" xml:space="preserve">
          <source>If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.</source>
          <target state="translated">如果你在AST元数据中引入了自定义键,请确保在它们前面加上你的库或应用程序的名称,这样它们就不会与编译器将来可能引入的键冲突。</target>
        </trans-unit>
        <trans-unit id="35ca2c3b656fa7f282e972b00616f04b656b2e75" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system than the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">如果您知道您正在与当前系统不同的系统上运行，并且正在使用正则表达式进行多次匹配，则可以手动调用&lt;a href=&quot;#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt;来执行运行时版本检查并重新编译正则表达式如有必要。</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">如果您知道您在与当前系统不同的系统上运行，并且正在使用正则表达式进行多次匹配，则可以手动调用&lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt;来执行运行时版本检查并重新编译正则表达式如有必要。</target>
        </trans-unit>
        <trans-unit id="5923e8f45f692122d1145ed7532ef3732f1c075a" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要通用词典，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块。如果您需要操作关键字列表，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要通用词典，请使用&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块。如果您需要操作关键字列表，请使用&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="681b1d87291217ee1d95dbf7ef258360d3658bf7" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">如果需要将元组或模块子规范转换为映射或修改子规范，则可以使用&lt;a href=&quot;#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数。例如，以不同的 &lt;code&gt;:id&lt;/code&gt; 和 &lt;code&gt;:shutdown&lt;/code&gt; 值为10秒（10_000毫秒）运行堆栈：</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">如果需要将元组或模块子规范转换为映射或修改子规范，则可以使用&lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;函数。例如，以不同的 &lt;code&gt;:id&lt;/code&gt; 和 &lt;code&gt;:shutdown&lt;/code&gt; 值为10秒（10_000毫秒）运行堆栈：</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">如果您需要在使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;的同时将选项传递给Elixir可执行文件，则可以按照以下步骤进行操作：</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">如果打开 &lt;code&gt;rel/env.sh.eex&lt;/code&gt; ，则会看到：</target>
        </trans-unit>
        <trans-unit id="54dbe001cacf2c5ab7935d57b0759fa2b1d3fbe5" translate="yes" xml:space="preserve">
          <source>If you partition your tests across multiple runs, you can unify the report as shown below:</source>
          <target state="translated">如果您将测试分区在多个运行中,您可以统一报告,如下所示。</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">如果在modes参数中传递 &lt;code&gt;:trim_bom&lt;/code&gt; ，则从文件读取时，流将修剪UTF-8，UTF-16和UTF-32字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="ca5840e930e22f09ee97165c990a4a919232564f" translate="yes" xml:space="preserve">
          <source>If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">如果你打算比较多个字符串,连续多次比较,你可以在前期将它们归一化,直接比较,以避免多次归一化。</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">如果你喜欢只使用运算符或跳过运算符,你可以通过以下选项。</target>
        </trans-unit>
        <trans-unit id="ced663b6bbb3741a07875a23a42c76c24864c77e" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also compile the release to a separate directory, so you can erase all source after the release is assembled:</source>
          <target state="translated">如果你喜欢,你也可以将发行版编译到一个单独的目录中,这样你就可以在发行版组装完成后擦掉所有的源代码。</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">如果您重新访问 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 实现，您会记得它只是将选项传递给GenServer：</target>
        </trans-unit>
        <trans-unit id="c5a45f99d559f9a09020a743643928ce3b42a8da" translate="yes" xml:space="preserve">
          <source>If you run &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; inside an umbrella, it will automatically gather exported cover results from all umbrella children - as long as the coverage results have been exported, like this:</source>
          <target state="translated">如果在伞中运行&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; &lt;/a&gt;，只要覆盖结果已导出，它将自动收集所有伞子导出的覆盖结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">如果运行 &lt;code&gt;bin/foo start&lt;/code&gt; ，它将使用一个短名称（ &lt;code&gt;--sname&lt;/code&gt; ）来启动系统，该短名称与发行版名称相同，在本例中为 &lt;code&gt;foo&lt;/code&gt; 。下一步是启动一个名为 &lt;code&gt;bar&lt;/code&gt; 的系统，因此我们可以像上一章一样将 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 连接在一起。但是在实现这一目标之前，让我们先讨论一下发布的好处。</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">如果在 &lt;code&gt;foo&lt;/code&gt; 仍在运行时启动 &lt;code&gt;bar&lt;/code&gt; ，则在应用程序最终关闭之前，您将看到类似以下错误的错误发生5次：</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">如果您提供 &lt;code&gt;message&lt;/code&gt; ，则有关值的信息将自动添加到该消息。</target>
        </trans-unit>
        <trans-unit id="f285809f1a4da78d4627f76c40391bd1d6265ba1" translate="yes" xml:space="preserve">
          <source>If you try to match on such an expression, &lt;code&gt;doctest&lt;/code&gt; will fail to compile. There are two ways to resolve this.</source>
          <target state="translated">如果尝试匹配这样的表达式，则 &lt;code&gt;doctest&lt;/code&gt; 将无法编译。有两种解决方法。</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">如果您尝试运行我们的新宏，您会发现它甚至无法编译，并抱怨变量 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 不存在。这是因为存在歧义： &lt;code&gt;unquote(k)&lt;/code&gt; 可以像以前一样是unquote片段，也可以像 &lt;code&gt;unquote(kv)&lt;/code&gt; 中那样是常规unquote 。</target>
        </trans-unit>
        <trans-unit id="d19c103426cd0a9b9cd1e418473a1f010bac3593" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a code point that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">如果尝试对&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;使用iodata_to_binary / 1，则将导致参数错误。例如，让我们尝试在IO数据中放置一个无法用一个字节表示的代码点，例如 &lt;code&gt;?&amp;pi;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">如果尝试对&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;使用iodata_to_binary / 1，则将导致参数错误。例如，让我们尝试在IO数据中放置一个无法用一个字节表示的代码点，例如 &lt;code&gt;?&amp;pi;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">如果你希望任务总是被重新启动。</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">如果要从模块捕获功能，可以执行 &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6595a62e94b4f38dca60f0418e3d52b457c3e382" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; to use for fetching &lt;code&gt;rebar&lt;/code&gt; please set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">如果要更改用于获取 &lt;code&gt;rebar&lt;/code&gt; 的&lt;a href=&quot;https://repo.hex.pm&quot;&gt;默认镜像&lt;/a&gt;，请设置 &lt;code&gt;HEX_MIRROR&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="6a8e46bf39b1daac7b96bda2ca9dc8fc521a77c9" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; used for fetching Hex, set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">如果要更改用于获取十六进制的&lt;a href=&quot;https://repo.hex.pm&quot;&gt;默认镜像&lt;/a&gt;，请设置 &lt;code&gt;HEX_MIRROR&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="f2cc4b639048c80880ba05a591eea3c58b3d29d6" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的float直接转换为float，则可以改用&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的float直接转换为float，则可以使用&lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08564e879edc0764f4906097067da72ec6372ab3" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的整数直接转换为整数，则可以改用&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">如果要将字符串格式的整数直接转换为整数，则可以改用&lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在不保留模式的情况下将内容从IO设备复制到另一台设备或从源直接复制到目标，请选中&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">如果您想通过自定义格式器自定义格式，则可以传递 &lt;code&gt;{module, function}&lt;/code&gt; 元组作为 &lt;code&gt;pattern&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">如果要表示允许使用映射中先前未定义的键，则通常以 &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; 结束映射类型。</target>
        </trans-unit>
        <trans-unit id="bc7ce43a44c457f071e6a594b6c6aad38b49f886" translate="yes" xml:space="preserve">
          <source>If you want to get the current time in Unix seconds, do not do &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt;. Simply call &lt;code&gt;System.os_time(:second)&lt;/code&gt; instead.</source>
          <target state="translated">如果要以Unix秒为单位获取当前时间，请不要执行 &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt; 。只需调用 &lt;code&gt;System.os_time(:second)&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="5ffb28d4834a320bc72469ce99b22a133a75bf2e" translate="yes" xml:space="preserve">
          <source>If you want to invoke specific modules and functions in your release, you can do so in two ways: using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">如果要在发行版中调用特定的模块和功能，可以通过两种方式进行：使用 &lt;code&gt;eval&lt;/code&gt; 或 &lt;code&gt;rpc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f2868ad75122ea25c9841323d0bc939ec4c117" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; attribute instead of &lt;code&gt;@type&lt;/code&gt;. The visibility also affects whether or not documentation will be generated by tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc&lt;/a&gt;, Elixir&amp;rsquo;s documentation generator.</source>
          <target state="translated">如果要保留自定义类型的私有性，可以使用 &lt;code&gt;@typep&lt;/code&gt; 属性而不是 &lt;code&gt;@type&lt;/code&gt; 。可见性还会影响是否由Elixir的文档生成器&lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc等&lt;/a&gt;工具生成文档。</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">如果要保留自定义类型的私有性，可以使用 &lt;code&gt;@typep&lt;/code&gt; 指令代替 &lt;code&gt;@type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcbbba3c1ea50cbcd365e262b9d60f2feb2c65ed" translate="yes" xml:space="preserve">
          <source>If you want to keep any two tests separate, add an empty line between them:</source>
          <target state="translated">如果你想让任何两个测试分开,在它们之间添加一个空行。</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">如果要对现有变量进行模式匹配，则需要使用&lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt;运算符：</target>
        </trans-unit>
        <trans-unit id="c8e1b5f66c0b107ff181c4a336661c05c7509728" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%5E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">如果要对现有变量进行模式匹配，则需要使用&lt;a href=&quot;#%5E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt;运算符：</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">如果要对现有变量进行模式匹配，则需要使用 &lt;code&gt;^&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行ceil操作，请改用&lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="006d429609c2e4b18605e6317262f44f76104754" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行ceil操作，请改用&lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行累加运算，请改用&lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da1610c8254e7b523adf724249920d8824d70e09" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要在其他小数位上执行累加运算，请改用&lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6176e9f771080616be12747b7598ac40675af864" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行底整数除法（向负无穷大舍入），请改用&lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行底整数除法（向负无穷大舍入），请改用&lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea950ebad1bc7656ae137230492317baa7c6a6f0" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行截断的整数除法（向零舍入），请改用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要执行截断的整数除法（向零舍入），请改用&lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">如果要清除来自名为 &lt;code&gt;:foo&lt;/code&gt; 的应用程序的所有日志调用，并仅保留 &lt;code&gt;Bar.foo/3&lt;/code&gt; 中的错误，则可以设置两个不同的匹配项：</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果要重新编译现有模块，请改用&lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">如果要重新加载单个模块，请考虑改用 &lt;code&gt;r(ModuleName)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要删除所有重复的元素，无论顺序如何，请参阅&lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">如果要手动运行测试，可以将 &lt;code&gt;:autorun&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; ,并使用&lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt;运行测试。</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">如果要同时搜索 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.app&lt;/code&gt; 文件，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="e842c7452c7ee7f8cc32ceae58854550ca1826ee" translate="yes" xml:space="preserve">
          <source>If you want to specify extra overlay directories, you can do so with the &lt;code&gt;:overlays&lt;/code&gt; option. If you need to copy files dynamically, see the &quot;Steps&quot; section.</source>
          <target state="translated">如果要指定额外的覆盖目录，可以使用 &lt;code&gt;:overlays&lt;/code&gt; 选项。如果需要动态复制文件，请参见&amp;ldquo;步骤&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">如果你想指定多个变量,你可以用逗号将它们分开。</target>
        </trans-unit>
        <trans-unit id="982a9cb228f92f03ac85417af3f281e259a660c2" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">如果要&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt;引用不是带引号的表达式的值（例如，映射），则需要在之前调用Macro.escape / 1：</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">如果要&lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt;引用不是带引号的表达式的值（例如映射），则需要在之前调用Macro.escape / 1：</target>
        </trans-unit>
        <trans-unit id="bc958b979665c9c17d7950e0854fbc66f8ee61bb" translate="yes" xml:space="preserve">
          <source>If you were to perform a hot code upgrade in such an application, it would crash, because in the initial version the state was just a counter but in the new version the state is a tuple. Furthermore, you changed the format of the &lt;code&gt;call&lt;/code&gt; message from &lt;code&gt;:bump&lt;/code&gt; to &lt;code&gt;{:bump, by}&lt;/code&gt; and the process may have both old and new messages temporarily mixed, so we need to handle both. The final version would be:</source>
          <target state="translated">如果要在这样的应用程序中执行热代码升级，则会崩溃，因为在初始版本中，状态只是一个计数器，而在新版本中，状态是一个元组。此外，您将 &lt;code&gt;call&lt;/code&gt; 消息的格式从 &lt;code&gt;:bump&lt;/code&gt; 更改为 &lt;code&gt;{:bump, by}&lt;/code&gt; ，该过程可能会将新旧消息暂时混合在一起，因此我们需要同时处理这两种消息。最终版本为：</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">如果你想了解更多关于GenServers的信息,Elixir入门指南提供了一个类似教程的介绍。Erlang中的文档和链接也可以提供额外的见解。</target>
        </trans-unit>
        <trans-unit id="b974f9968697c318d27fe1bd482bc9d5a128ec60" translate="yes" xml:space="preserve">
          <source>If you wish to inspect the code points in a single-quoted literal, you can force this by passing the &lt;code&gt;charlists&lt;/code&gt; option to &lt;code&gt;IO.inspect/2&lt;/code&gt;:</source>
          <target state="translated">如果要检查单引号文字中的代码点，可以通过将 &lt;code&gt;charlists&lt;/code&gt; 选项传递给 &lt;code&gt;IO.inspect/2&lt;/code&gt; 来强制执行此操作：</target>
        </trans-unit>
        <trans-unit id="416d7a121c99b25e16e84560ead7cb67296777e6" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果希望对累加器使用另一个值，请使用&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果希望对累加器使用另一个值，请使用&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要获取评估文件而不是其中定义的模块的结果，请参阅&lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">如果要在整个系统上启用它，则可以使用 &lt;code&gt;ERL_AFLAGS&lt;/code&gt; 环境变量，并确保在终端/外壳程序配置中对其进行了相应设置。</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">如果你的Git仓库需要认证,比如基本的用户名:密码HTTP认证通过URL,可以通过Git配置来实现,保持访问规则在源头控制之外。</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">如果您的应用程序没有监控树，则可以通过在 &lt;code&gt;mix.exs&lt;/code&gt; 内更改 &lt;code&gt;def application&lt;/code&gt; 来添加一个 &lt;code&gt;:mod&lt;/code&gt; 以应用程序回调名称包含：mod键：</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">如果您的实现通过选项，或者您正在基于该结构生成自定义代码，则还需要实现一个定义为 &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; 的宏，以获取已传递的选项。</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">如果您的用例完全需要GenEvent提供的内容，或者必须与基于 &lt;code&gt;:gen_event&lt;/code&gt; 的现有系统集成，则仍然可以使用&lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlang模块。</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">如果由于某种原因而无法检索当前工作目录，则此函数返回给定的 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3de6ae0bb7f57a373dcca73d61975801fe3edfc" translate="yes" xml:space="preserve">
          <source>If, for some reason, you must read the application environment at compile time, use &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt;&lt;code&gt;Application.compile_env/2&lt;/code&gt;&lt;/a&gt;. Read &lt;a href=&quot;application#module-compile-time-environment&quot;&gt;the &quot;Compile-time environment&quot; section of the Application docs&lt;/a&gt; for more information.</source>
          <target state="translated">如果由于某种原因必须在编译时阅读应用程序环境，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt; &lt;code&gt;Application.compile_env/2&lt;/code&gt; &lt;/a&gt;。阅读&lt;a href=&quot;application#module-compile-time-environment&quot;&gt;&amp;ldquo;应用程序&amp;rdquo;文档的&amp;ldquo;编译时环境&amp;rdquo;部分，以&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">如果在你的日历中,新的一天从午夜开始,返回{0,1}。</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">如果在你的日历中,新的一天从中午开始,返回{1,2}。</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">如果在你的日历中,新的一天从日出开始,返回{1,4}。</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">如果在你的日历中,新的一天从日落开始,返回{3,4}。</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">如果以后将 &lt;code&gt;Bar&lt;/code&gt; 模块移到 &lt;code&gt;Foo&lt;/code&gt; 模块定义之外，则必须使用其全名（ &lt;code&gt;Foo.Bar&lt;/code&gt; ）对其进行引用，或者必须使用上面讨论的 &lt;code&gt;alias&lt;/code&gt; 指令设置别名。</target>
        </trans-unit>
        <trans-unit id="5aadcd56db1850d0771fc6771663e100003c9ea8" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">如果在执行代码的同时系统时钟发生了变化，则报告在1秒内执行的某些代码将花费1个小时以上！为了解决此类问题，VM通过&lt;a href=&quot;#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt;提供了单调时间，该时间不会减少也不会跳跃：</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">如果在执行代码时更改系统时钟，则可能会报告在1秒内执行的某些代码花费了1个小时以上！为了解决此类问题，VM通过&lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt;提供单调时间，该时间不会减少也不会跳跃：</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">图片:底片。交换前景和背景。</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">图片:正。前景和背景正常。</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">想象一个模块使用在 &lt;code&gt;Math.List&lt;/code&gt; 中实现的专用列表。该 &lt;code&gt;alias&lt;/code&gt; 指令允许指 &lt;code&gt;Math.List&lt;/code&gt; 就像 &lt;code&gt;List&lt;/code&gt; 模块定义中：</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">假设有人实现了 &lt;code&gt;Calendar.Holocene&lt;/code&gt; ，这是一个基于公历的日历，该日历在当前公历年中正好增加了10,000年：</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">想象一下给定的 &quot;旧 &quot;代码。</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">想象一下,你有一个被引用的表达式,你想把它注入某个引用里面。第一个尝试是:</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">假设您有一个名为 &lt;code&gt;projects&lt;/code&gt; 的目录，其中包含三个Elixir项目： &lt;code&gt;elixir&lt;/code&gt; ， &lt;code&gt;ex_doc&lt;/code&gt; 和 &lt;code&gt;plug&lt;/code&gt; 。您可以在每个项目的 &lt;code&gt;ebin&lt;/code&gt; 目录中找到所有 &lt;code&gt;.beam&lt;/code&gt; 文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="bbd38c599b5ec1ff1edb2d327d81cfb6d57d0ae9" translate="yes" xml:space="preserve">
          <source>Imagine you have a map that contains a MapSet and is printed as:</source>
          <target state="translated">想象一下,你有一张包含MapSet的地图,并被打印成。</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">假设你有以下结构。</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">立即停止Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">执行行为</target>
        </trans-unit>
        <trans-unit id="4d98cf2da4c3ebd35020a6022935dad49c5720d8" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现诸如&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; 之&lt;/a&gt;类的功能是理解&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;强大功能的好练习。当操作不能由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的任何函数表示时，开发人员很可能会求助于&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现诸如&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; 之&lt;/a&gt;类的功能是理解&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;强大功能的好练习。当操作不能由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的任何函数表示时，开发人员很可能会求助于&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad3e95d8cf32f54c45a81b4f1a57f15494498570" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">在不调用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt;（v1.0）的情况下显式增强行为</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">在不调用&lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt;（v1.0）的情况下显式增强行为</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">重要提示：千万&lt;strong&gt;不能&lt;/strong&gt;使用这个功能在Unicode模式IO设备，因为它会写入错误的数据。特别是，默认情况下，标准IO设备设置为Unicode，因此使用此功能写入stdio可能会导致错误的数据通过网络发送。</target>
        </trans-unit>
        <trans-unit id="bdee98dcb44004b1533b9be7b352b94b0439a6f5" translate="yes" xml:space="preserve">
          <source>Importing dependencies configuration</source>
          <target state="translated">导入依赖性配置</target>
        </trans-unit>
        <trans-unit id="3e99e591c470385409fd87d84f7ea0fdc9e8826b" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file or files.</source>
          <target state="translated">从给定文件中导入配置。</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">从给定文件中导入配置。</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">从其他模块导入函数和宏。</target>
        </trans-unit>
        <trans-unit id="bb0b9afcb24ddc9f67176eeec399cead058aa4a9" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">导入：新功能可能会添加到自动导入的&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块中。它们可能会与您的模块中定义的局部功能冲突。可以使用 &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 以向后兼容的方式解决冲突，但以下情况除外：[...]列出了您不想从&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的所有功能。我们保留进行此类添加的权利。</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">导入：新功能可能会添加到自动导入的&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块中。它们可能与您的模块中定义的局部功能冲突。可以使用 &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 以向后兼容的方式解决冲突，但以下情况除外：[...]列出了您不想从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的所有功能。我们保留进行此类添加的权利。</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">不适当的名单永远不会被视为charlists。</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">不正确的列表是不能打印的,即使只由ASCII字符组成。</target>
        </trans-unit>
        <trans-unit id="1651a35afb019627c0965d85cc4992b58cfbc54d" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned a little bit about strings and we used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">在&amp;ldquo;基本类型&amp;rdquo;中，我们学习了一些有关字符串的知识，并使用了 &lt;code&gt;is_binary/1&lt;/code&gt; 函数进行检查：</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">在&amp;ldquo;基本类型&amp;rdquo;中，我们了解了字符串，并将 &lt;code&gt;is_binary/1&lt;/code&gt; 函数用于检查：</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">在&lt;a href=&quot;keywords-and-maps&quot;&gt;第7章中，&lt;/a&gt;我们了解了地图：</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">在Elixir中，我们将几个功能分组到模块中。我们已经用在前面的章节中许多不同的模块，如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;该 &lt;code&gt;String&lt;/code&gt; 模块&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f34428000982ff1805aac800f0ebed47748f3ab4" translate="yes" xml:space="preserve">
          <source>In Elixir you can use a &lt;code&gt;?&lt;/code&gt; in front of a character literal to reveal its code point:</source>
          <target state="translated">在Elixir中，您可以使用 &lt;code&gt;?&lt;/code&gt; 在字符文字前面以显示其代码点：</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">在Elixir中，将 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 定义为宏，以便可以将其用作防护。这意味着，为了调用 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; ，我们需要首先需要 &lt;code&gt;Integer&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">在Elixir中，可以抛出一个值，然后再捕获它。 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 保留用于除非使用 &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; 否则无法检索值的情况。</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">在Elixir中,所有代码都在进程中运行。进程之间相互隔离,彼此并发运行,并通过消息传递进行通信。进程不仅是Elixir中并发的基础,而且还为构建分布式和容错程序提供了手段。</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">在Elixir中，可枚举是实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的任何数据类型。&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;[1, 2, 3]&lt;/code&gt; ），&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ）和&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;1..3&lt;/code&gt; ）是常用的可枚举数据类型：</target>
        </trans-unit>
        <trans-unit id="a207968d5a8dba5d6352c7b46008a0e1ddc8ec1d" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">在Elixir中，可枚举是实现&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的任何数据类型。&lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;s（ &lt;code&gt;[1, 2, 3]&lt;/code&gt; ），&lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;s（ &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ）和&lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;s（ &lt;code&gt;1..3&lt;/code&gt; ）是常用的可枚举数据类型：</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在Elixir中，代码组织是由模块和功能完成的，过程不是必需的。例如，假设您正在实现一个计算器，然后决定将所有计算器操作放在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之后&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7900ac30a1169c9e2266c3344cde6f7b66b7bf2b" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在Elixir中，代码组织是由模块和功能完成的，过程不是必需的。例如，假设您正在实现一个计算器，然后决定将所有计算器操作放在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 之后&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">在Elixir中,代码组织是由模块和函数来完成的,流程是不必要的。例如,想象一下,你正在实现一个计算器,你决定把所有的计算器操作放在GenServer后面。</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">在Elixir中,可以使用比较运算符对不同的数据类型进行比较。</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">在Elixir中，通常遍历一个Enumerable，通常会过滤掉一些结果并将值映射到另一个列表中。理解是此类构造的语法糖：它们将那些常见的任务归 &lt;code&gt;for&lt;/code&gt; 特殊形式。</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">在Elixir中,记录主要用于两种情况。</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">在Elixir中， &lt;code&gt;=&lt;/code&gt; 运算符实际上称为&lt;em&gt;match运算符&lt;/em&gt;。让我们看看为什么：</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">在Elixir中,这是由一个监督器完成的。Supervisor是一个监督其他进程并在它们崩溃时重新启动它们的进程。为此,Supervisors管理任何被监督进程的整个生命周期,包括启动和关闭。</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">在Elixir中，我们避免使用 &lt;code&gt;try/rescue&lt;/code&gt; ,因为&lt;strong&gt;我们没有在控制流中使用错误&lt;/strong&gt;。我们从字面上理解错误：它们是为意外和/或例外情况保留的。如果您实际上需要流控制构造，则应使用&lt;em&gt;throws&lt;/em&gt;。这就是我们接下来要看到的。</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">在Elixir中,我们可以比较两种不同的数据类型。</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">在Elixir中，我们有两个用于检查数据结构中有多少项的惯用法： &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;length&lt;/code&gt; 表示必须计算信息。例如， &lt;code&gt;length(list)&lt;/code&gt; 需要遍历整个列表以计算其长度。另一方面， &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 在数据结构中预先计算了大小信息，因此tuple_size（tuple）和 &lt;code&gt;byte_size(binary)&lt;/code&gt; 不依赖于tuple和二进制大小。</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">在Elixir中，我们有两个主要的关联数据结构：关键字列表和映射。是时候进一步了解它们了！</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">在Elixir中，我们有两个动词来检查数据结构中有多少个项： &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;length&lt;/code&gt; 表示必须计算信息。例如， &lt;code&gt;length(list)&lt;/code&gt; 需要遍历整个列表以计算其长度。另一方面， &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 在数据结构中预先计算了大小信息，因此tuple_size（tuple）和 &lt;code&gt;byte_size(binary)&lt;/code&gt; 不依赖于tuple和二进制大小。</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Elixir中，您可以使用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 定义二进制文件：</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">在Erlang中，此结构由 &lt;code&gt;:file_info&lt;/code&gt; 记录表示。因此，此模块还提供用于在Erlang记录和Elixir结构之间进行转换的功能。</target>
        </trans-unit>
        <trans-unit id="19ae95f1d5cbc8f9036da514524bab95b3e8521e" translate="yes" xml:space="preserve">
          <source>In Mix projects this function returns the environment this configuration file is executed on. In releases, the environment when &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; ran.</source>
          <target state="translated">在Mix项目中，此函数返回执行此配置文件的环境。在发行版中，运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;版时的环境。</target>
        </trans-unit>
        <trans-unit id="e341b5436849e02ad44c7ab5cb526b1b7ab5e415" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. For example, someone using your application can override its &lt;code&gt;:db_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">在Mix项目中，可以通过 &lt;code&gt;config/config.exs&lt;/code&gt; 文件覆盖应用程序的环境及其依赖项。例如，使用您的应用程序的人可以重写其 &lt;code&gt;:db_host&lt;/code&gt; 环境变量，如下所示：</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">在Mix项目中，可以通过 &lt;code&gt;config/config.exs&lt;/code&gt; 文件覆盖应用程序的环境及其依赖项。如果使用Mix启动应用程序，则该配置在编译时和运行时都可用，但要考虑到该配置未包含在生成的应用程序资源文件中，如果在没有Mix的情况下启动应用程序，则该配置不可用。</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">在类Unix系统中，更改修改时间可能要求您是 &lt;code&gt;root&lt;/code&gt; 用户或文件所有者。具有写访问权限可能还不够。在这种情况下，第一次触摸（创建）文件会成功，但是如果使用 &lt;code&gt;{:error, :eperm}&lt;/code&gt; 触摸现有文件会失败。</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">在GenServer中,上面的代码将是两个独立的函数,大致是这样的。</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">在具有多个节点的分布式设置中,接受匿名函数的API只有在调用者(客户端)和代理拥有相同版本的调用者模块时才会工作。</target>
        </trans-unit>
        <trans-unit id="0fe49527fc564fb18ae1d9b47c99a05222fe3f97" translate="yes" xml:space="preserve">
          <source>In a hot code upgrade, you want to update a node from version A to version B. To do so, the first step is to write recipes for every application that changed between those two releases, telling exactly how the application changed between versions, those recipes are called &lt;code&gt;.appup&lt;/code&gt; files. While some of the steps in building &lt;code&gt;.appup&lt;/code&gt; files can be automated, not all of them can. Furthermore, each process in the application needs to be explicitly coded with hot code upgrades in mind. Let's see an example. Imagine your application has a counter process as a GenServer:</source>
          <target state="translated">在热代码升级中，您希望将节点从版本A更新到版本B。为此，第一步是为在这两个发行版之间更改的每个应用程序编写配方，以准确说明该应用程序在两个版本之间的变化方式。配方称为 &lt;code&gt;.appup&lt;/code&gt; 文件。虽然构建 &lt;code&gt;.appup&lt;/code&gt; 文件的某些步骤可以自动化，但并非所有步骤都可以。此外，在应用程序中的每个过程都需要明确编码，同时要考虑到热代码升级。让我们来看一个例子。想象一下，您的应用程序具有作为GenServer的计数器进程：</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">总而言之,一个版本用三个数字来表示。</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">简而言之，应用程序由 &lt;code&gt;.app&lt;/code&gt; 文件中定义的所有模块组成，包括 &lt;code&gt;.app&lt;/code&gt; 文件本身。一个应用程序通常只有两个目录： &lt;code&gt;ebin&lt;/code&gt; （用于 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.app&lt;/code&gt; 文件的Elixir人工制品）和 &lt;code&gt;priv&lt;/code&gt; （在应用程序中可能需要的任何其他人工制品或资产）。</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">总而言之,当你想跟踪系统处理的文件时,必须使用第一个,以避免同一个文件被多次编译。这在脚本中很常见。</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">在常规项目中，我们可以通过简单地运行 &lt;code&gt;mix release&lt;/code&gt; 来组合发布。但是，我们有一个总括项目，在这种情况下，Elixir需要我们提供一些额外的投入。让我们看看有什么必要：</target>
        </trans-unit>
        <trans-unit id="2066279752953073a6aab2adcefe389056d45238" translate="yes" xml:space="preserve">
          <source>In addition to matching the target triple, it is also important that the target has all of the system packages that your application will need at runtime. A common one is the need for OpenSSL when building an application that uses &lt;code&gt;:crypto&lt;/code&gt; or &lt;code&gt;:ssl&lt;/code&gt;, which is dynamically linked to ERTS. The other common source for native dependencies like this comes from dependencies containing NIFs (natively-implemented functions) which may expect to dynamically link to libraries they use.</source>
          <target state="translated">除了与目标三元组匹配之外，目标还具有应用程序在运行时所需的所有系统软件包也很重要。一个常见的问题是在构建使用 &lt;code&gt;:crypto&lt;/code&gt; 或 &lt;code&gt;:ssl&lt;/code&gt; 动态链接到ERTS的应用程序时需要OpenSSL 。此类本机依赖项的另一个常见来源来自包含NIF（本机实现的函数）的依赖项，这些依赖项可以期望动态链接到它们使用的库。</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">除了Elixir文件扩展名 &lt;code&gt;.ex&lt;/code&gt; 之外，Elixir还支持 &lt;code&gt;.exs&lt;/code&gt; 文件进行脚本编写。Elixir对两个文件的处理方式完全相同，唯一的区别在于意图。 &lt;code&gt;.ex&lt;/code&gt; 文件用于编译，而 &lt;code&gt;.exs&lt;/code&gt; 文件用于编写脚本。尽管只有 &lt;code&gt;.ex&lt;/code&gt; 文件将其字节码以 &lt;code&gt;.beam&lt;/code&gt; 文件的格式写入磁盘，但两个扩展都在执行时将其模块编译并加载到内存中。</target>
        </trans-unit>
        <trans-unit id="11490d624ce7faa621bf11120bfb3fc20a3be0c2" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">除了上面概述的内置属性之外，还可以添加自定义属性。定制属性使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt;运算符表示，后跟有效的变量名。提供给custom属性的值必须是有效的Elixir值：</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">除了上面概述的内置属性之外，还可以添加自定义属性。定制属性使用&lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt;运算符表示，后跟有效的变量名。提供给custom属性的值必须是有效的Elixir值：</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">除了用户通过&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;提供的密钥外，以下附加密钥可用于 &lt;code&gt;:metadata&lt;/code&gt; 列表：</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">除此之外，还需要将双引号字符串内的双引号转义为 &lt;code&gt;\&quot;&lt;/code&gt; ，并且类似地，也需要将单引号字符列表内的单引号转义为 &lt;code&gt;\'&lt;/code&gt; 。不过，这是更好的样式如上所示更改定界符，而不是对其进行转义。</target>
        </trans-unit>
        <trans-unit id="2b2826ef1e2ef7d4eb0ba033cc662710c67d0f81" translate="yes" xml:space="preserve">
          <source>In addition, every protocol implementation module contains the &lt;code&gt;__impl__/1&lt;/code&gt; function. The function takes one of the following atoms:</source>
          <target state="translated">此外，每个协议实现模块都包含 &lt;code&gt;__impl__/1&lt;/code&gt; 函数。该函数采用以下原子之一：</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">在以上所有示例中，我们在写入文件时都使用了二进制文件。在&lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;二进制，字符串和字符列表&amp;rdquo;&lt;/a&gt;一章中，我们提到了字符串是如何由字节组成的，而字符列表是具有Unicode代码点的列表。</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">在任何情况下,都要避免出现以下情况:</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">在这两种情况下，总是会调用 &lt;code&gt;Stack.start_link/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这两种情况下，脚本或表达式的命令行参数都可在&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; 中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91806a81fe43b48626fc4b371025096ff818c577" translate="yes" xml:space="preserve">
          <source>In case ANSI is disabled, the ANSI escape sequences are simply discarded.</source>
          <target state="translated">如果ANSI被禁用,ANSI转义序列将被丢弃。</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">如果&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;:suspend&lt;/code&gt; 累加器，则它必须由调用方显式处理，并且永远不要泄漏。</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">如果&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;:suspend&lt;/code&gt; 累加器，则 &lt;code&gt;:suspended&lt;/code&gt; 元组必须由调用方显式处理，并且永远不要泄漏。实际上，这意味着常规枚举功能只需要关注 &lt;code&gt;:done&lt;/code&gt; 和 &lt;code&gt;:halted&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">如果找不到直接的相对路径,则返回原始路径。</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">在测试单个文件的情况下,可以通过一个或多个特定的行号,只运行这些给定的测试。</target>
        </trans-unit>
        <trans-unit id="e8071ad6cb618eac03347482224d3c6ae15920db" translate="yes" xml:space="preserve">
          <source>In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果字符串本身必须带有双引号，则双引号必须以反斜杠转义，例如： &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">如果指定的开关 &lt;code&gt;SWITCH&lt;/code&gt; 具有类型 &lt;code&gt;:boolean&lt;/code&gt; ，则它也可以作为 &lt;code&gt;--no-SWITCH&lt;/code&gt; 传递，这会将选项设置为 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">如果任何条目返回 &lt;code&gt;nil&lt;/code&gt; ，则其键将被删除，删除将被视为成功。</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">在任何情况下，中间返回条目的 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; 将返回为每&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">如果中间的任何条目返回 &lt;code&gt;nil&lt;/code&gt; ，则在接下来尝试访问它时将引发错误。</target>
        </trans-unit>
        <trans-unit id="14f58659a0439f1a109167c635ebf2ecb21a5dc3" translate="yes" xml:space="preserve">
          <source>In case any of the keys returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned:</source>
          <target state="translated">在任何情况下返回键 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; 将返回：</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">万一它确实存在,那就不做了。否则,就建。</target>
        </trans-unit>
        <trans-unit id="75a8464fb2113eaca41fdf083e397d6efb34f66b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">如果要访问原始&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;，可以通过访问 &lt;code&gt;Elixir&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">如果要访问原始&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;，可以通过访问 &lt;code&gt;Elixir&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">万一出了问题，您也可以&lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt;其他原因使用exit / 1：</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">如果别名是由一个宏自动生成的,Elixir不会发出任何警告,因为别名没有被明确定义。</target>
        </trans-unit>
        <trans-unit id="2b98ade5811cd318aeee5332f266a7b7225f7348" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">如果转换失败，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt;。如果给出了字符串，它将返回字符串本身。</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">如果转换失败，则会引发&lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt;。如果给出了字符串，它将返回字符串本身。</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">如果文件不存在,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">如果导入是由宏自动生成的,Elixir不会发出任何警告,因为没有明确定义导入。</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">如果任务进程死亡,当前进程将以与任务相同的理由退出。</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">如果测试崩溃,你会看到如下的报告。</target>
        </trans-unit>
        <trans-unit id="899b34a899719bbd8b066e45019119b52779572b" translate="yes" xml:space="preserve">
          <source>In case the value you want to interpolate cannot be converted to a string, because it doesn't have an human textual representation, a protocol error will be raised.</source>
          <target state="translated">如果你要插值的值不能转换为字符串,因为它没有人类的文本表示,将引发协议错误。</target>
        </trans-unit>
        <trans-unit id="94805569146261c99e1aba00cef7b14d9f604927" translate="yes" xml:space="preserve">
          <source>In case there are no config providers, it doesn't change &lt;code&gt;sys_config&lt;/code&gt;.</source>
          <target state="translated">如果没有配置提供程序，则不会更改 &lt;code&gt;sys_config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">如果在检查您的结构时发生错误，Elixir将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;错误，并将自动退回到原始表示形式以打印结构。</target>
        </trans-unit>
        <trans-unit id="fd386531e2486b3f99bcfc36b0d8da5b224c20a5" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">如果在检查您的结构时发生错误，Elixir将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;错误，并将自动退回到原始表示形式以打印结构。</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">如果没有这样的消息,当前进程将挂起,直到消息到达或等待给定的超时值。</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">如果情况无法按预期进行，请在报告中包含尽可能多的信息，例如：Elixir版本，代码段和错误消息以及错误stacktrace。使用&lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist之类的&lt;/a&gt;网站粘贴此信息。</target>
        </trans-unit>
        <trans-unit id="2d3cb03ba7258afff951799e09542865bc33c540" translate="yes" xml:space="preserve">
          <source>In case you are manually compiling protocols or building releases, you need to take the generated protocols into account. This can be done with:</source>
          <target state="translated">如果你正在手动编译协议或构建发行版,你需要将生成的协议考虑在内。这可以通过以下方式实现:</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">如果你需要配置一个进程,那么在启动该进程时应该传递这些选项。</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">如果需要使用字节，请查看&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您想自动加载&lt;strong&gt;并启动&lt;/strong&gt; &lt;code&gt;app&lt;/code&gt; 的所有依赖项，请参见&lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">如果您想为用户模块提供一些现有功能，请在相应导入的模块中定义它；例如，&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;在调用 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 的模块中未定义 &lt;code&gt;test/3&lt;/code&gt; 宏，但它定义了&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt;并在使用时将其导入到调用方中。</target>
        </trans-unit>
        <trans-unit id="8e67d2f3d283f6f03fc8ad3aba714edbb893d393" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中不推荐使用的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 策略，则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;几个步骤即可迁移到DynamicSupervisor。</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">如果您正在使用&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块中不推荐使用的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 策略，则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;几个步骤即可迁移到DynamicSupervisor。</target>
        </trans-unit>
        <trans-unit id="aec959cd2637331d18fa672f762e0b85e128fa1c" translate="yes" xml:space="preserve">
          <source>In code, function specs are written with the &lt;code&gt;@spec&lt;/code&gt; attribute, typically placed immediately before the function definition. Specs can describe both public and private functions. The function name and the number of arguments used in the &lt;code&gt;@spec&lt;/code&gt; attribute must match the function it describes.</source>
          <target state="translated">在代码中，函数规范是使用 &lt;code&gt;@spec&lt;/code&gt; 属性编写的，通常将其放在函数定义之前。规范可以描述公共和私有功能。 &lt;code&gt;@spec&lt;/code&gt; 属性中使用的函数名称和参数数目必须与其描述的函数匹配。</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">与关键字列表相比,地图对模式匹配非常有用。当在模式中使用地图时,它总是在给定值的子集上进行匹配。</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">相反，被调用函数的值描述了这些函数，但是是在标记函数的上下文中。例如，最后一行表示 &lt;code&gt;Mod.called2/0&lt;/code&gt; 曾经调用过 &lt;code&gt;Mod.some_function/0&lt;/code&gt; ，在这种情况下，该函数所花费的总时间为50ms。</target>
        </trans-unit>
        <trans-unit id="1bd204212246b87557a18b94547a4a49f3e0882e" translate="yes" xml:space="preserve">
          <source>In daemon mode, the system is started on the background via &lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl&lt;/a&gt;. You may also want to enable &lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;heart&lt;/a&gt; in daemon mode so it automatically restarts the system in case of crashes. See the generated &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; file.</source>
          <target state="translated">在守护程序模式下，系统通过&lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl&lt;/a&gt;在后台启动。您可能还希望在守护程序模式下启用&lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;heart&lt;/a&gt;，以便在发生崩溃时自动重启系统。请参阅生成的 &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">实际上，&lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;可用于挽救不是适当的Elixir错误的任何错误。例如，它也可以用于在转换之前挽救早期的 &lt;code&gt;:badarg&lt;/code&gt; 错误：</target>
        </trans-unit>
        <trans-unit id="3fc62d3ceab839ba2b910c33a7d8e5bd0aaee7f5" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">实际上，&lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;可用于挽救不是适当的Elixir错误的任何错误。例如，它也可以用于在转换之前挽救早期的 &lt;code&gt;:badarg&lt;/code&gt; 错误：</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">事实上,连接到远程shell是非常常见的,所以我们也提供了一个通过命令行的快捷方式。</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">实际上，让我们打开 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">实际上，每次需要将值插入引号时，建议使用 &lt;code&gt;:bind_quoted&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">实际上，这种模式非常普遍，以至于大多数时候您都希望将 &lt;code&gt;bind_quoted&lt;/code&gt; 选项与&lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; 结合使用&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">通常， &lt;code&gt;underscore&lt;/code&gt; 可以被认为是 &lt;code&gt;camelize&lt;/code&gt; 的反义词，但是，在某些情况下，格式可能会丢失：</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">一般来说,开发者应该在文件不存在的情况下使用前者。后者应该在开发者希望他们的软件在文件不能被读取的情况下失败时使用(即它实际上是一个异常)。</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">通常，开发人员将要在测试中使用常规的 &lt;code&gt;assert&lt;/code&gt; 宏。此宏会检查您的代码，并在发生故障时提供良好的报告。例如， &lt;code&gt;assert some_fun() == 10&lt;/code&gt; 将失败（假设 &lt;code&gt;some_fun()&lt;/code&gt; 返回 &lt;code&gt;13&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="9be20cb8cf2a5e21e25e5b415ec975c67912ed9d" translate="yes" xml:space="preserve">
          <source>In general, doctests are not recommended when your code examples contain side effects. For example, if a doctest prints to standard output, doctest will not try to capture the output.</source>
          <target state="translated">一般来说,当你的代码示例包含副作用时,不推荐使用doctests。例如,如果一个doctest打印到标准输出,doctest将不会尝试捕获输出。</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">一般来说,这个模块中的函数依赖于Unicode标准,但不包含任何特定于语言环境的行为。</target>
        </trans-unit>
        <trans-unit id="1b51681509b0cc1251035f9253bdae711f905e3e" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;.</source>
          <target state="translated">通常，此模块中的功能依赖Unicode标准，但不包含任何特定于语言环境的行为。有关字素的更多信息，请参见&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode标准附件＃29&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">一般来说,上述元组的结构是按照以下格式进行的。</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">一般来说,当关键字列表是函数的最后一个参数时,方括号是可选的。</target>
        </trans-unit>
        <trans-unit id="aa567762586986c74d465d0aa8d43a9b014b6cd4" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead.</source>
          <target state="translated">在守护中,当函数通常会引发异常时,它们会导致守护失败。</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">在警卫中，当函数通常会引发异常时，它们会导致警卫失败。例如，&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;函数仅适用于列表。如果我们将其与其他任何东西一起使用，则会引发运行时错误：</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">根据这种观察，我们应该考虑采用另一种监督策略。另外两个候选对象是 &lt;code&gt;:one_for_all&lt;/code&gt; 和 &lt;code&gt;:rest_for_one&lt;/code&gt; 。使用 &lt;code&gt;:rest_for_one&lt;/code&gt; 策略的管理者将杀死并重启子进程，该子进程&lt;em&gt;在&lt;/em&gt;子进程崩溃&lt;em&gt;后&lt;/em&gt;启动。在这种情况下，我们希望 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 终止，如果 &lt;code&gt;KV.Registry&lt;/code&gt; 终止。这将要求将存储桶管理器放置在注册表之后，这违反了我们在上面建立的两个段落的排序约束。</target>
        </trans-unit>
        <trans-unit id="505de6a8a3338b2af34fda74ec05eeff90a625d9" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">在宏代码中，&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt;上的爆炸声表示已放弃&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;宏卫生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">在宏代码中，&lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt;上的爆炸声表示已放弃&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;宏卫生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">在许多情况下，将期望值传递给&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;并在&lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt;回调中生成消息更为方便：</target>
        </trans-unit>
        <trans-unit id="b6d866c1d491de63fc794b51b1fe651b6b2cf7a2" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">在许多情况下，将期望值传递给&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;并在&lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt;回调中生成消息更为方便：</target>
        </trans-unit>
        <trans-unit id="19dc1fd7cd1d8b39b9ff5dace65dcd36cc88f10b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt; to both check that the given value is a tuple &lt;em&gt;and&lt;/em&gt; check its size (instead of using &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt;).</source>
          <target state="translated">在许多情况下，我们可以利用这一点。在上面的代码中，我们使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt;来检查给定值是否为元组&lt;em&gt;并&lt;/em&gt;检查其大小（而不是使用 &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">在许多情况下，我们可以利用这一点。在上面的代码中，我们使用&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;既检查给定的事物是否是列表，&lt;em&gt;又&lt;/em&gt;检查其长度的某些属性（而不是使用 &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">在许多函数式编程语言中,通常使用一个2项元组的列表作为键值数据结构的表示。在Elixir中,当我们有一个元组列表,并且元组的第一项(即键)是一个原子时,我们称之为关键字列表。</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">在大多数情况下，&lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt;就足够了。&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;必须在极少数情况下使用，通常涉及需要调用模块以获取回调信息的宏。</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">为了使缓存机制起作用，创建的ETS表需要具有 &lt;code&gt;:protected&lt;/code&gt; 的访问权限（默认），以便所有客户端都可以从中读取内容，而只有 &lt;code&gt;KV.Registry&lt;/code&gt; 进程可以对其进行写入。我们还启动表时设置了 &lt;code&gt;read_concurrency: true&lt;/code&gt; ，针对并发读取操作的常见方案优化了表。</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">为了进行加载， &lt;code&gt;.app&lt;/code&gt; 文件必须位于加载路径中。所有的 &lt;code&gt;:included_applications&lt;/code&gt; 也将被加载。</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">为了更好地理解宏的工作原理，让我们在要实现的地方创建一个新模块， &lt;code&gt;unless&lt;/code&gt; ，它作为宏和函数与 &lt;code&gt;if&lt;/code&gt; 的作用相反：</target>
        </trans-unit>
        <trans-unit id="167262643fd2c56cb15474799a3fefbbc20d320a" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为了构建变量，需要一个上下文。在大多数情况下，为了保持卫生，上下文必须为&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为了构建变量，需要一个上下文。在大多数情况下，为了保持卫生，上下文必须为&lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">为了构建我们的键值应用,我们将使用三个主要工具。</target>
        </trans-unit>
        <trans-unit id="9a8e911427746c64d6627a4cd13981382e8cbad5" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">为了比较两个以上的子句，必须使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">为了比较两个以上的子句，必须使用&lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt;宏。</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">为了配置混合，该模块 &lt;code&gt;use&lt;/code&gt; 小号&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;应该导出 &lt;code&gt;project/0&lt;/code&gt; 函数，返回表示该项目配置的关键字列表。</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">为了在不引入重大更改的情况下继续发展语言，Elixir将依靠弃用降级某些做法并推广新的做法。&lt;a href=&quot;#deprecations&quot;&gt;&amp;ldquo;弃用&amp;rdquo;部分&lt;/a&gt;概述了我们的弃用策略。</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">为了应对开发中的代码加载,Elixir中的协议提供了专门针对开发的协议调度的缓慢实现。</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">为了在Elixir中创建我们自己的模块，我们使用 &lt;code&gt;defmodule&lt;/code&gt; 宏。我们使用 &lt;code&gt;def&lt;/code&gt; 宏在该模块中定义函数：</target>
        </trans-unit>
        <trans-unit id="2db428412e028f480fb253824aa4dbe3e8772fd9" translate="yes" xml:space="preserve">
          <source>In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The &lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;Unicode Standard&lt;/a&gt; acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.</source>
          <target state="translated">为了促进跨多种语言的计算机之间有意义的通信，需要一种标准，以便一台机器上的&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 0&amp;rdquo;在传输给另一台机器时具有相同的含义。在&lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;Unicode标准&lt;/a&gt;作为几乎所有我们知道字符的官方注册：包括古典和历史文本和表情符号，格式和控制字符，以及字符。</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">为了促进软件重用，Elixir提供了三个指令（ &lt;code&gt;alias&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; ）以及一个名为 &lt;code&gt;use&lt;/code&gt; 的宏，概述如下：</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">为了完成我们的 &lt;code&gt;TestCase&lt;/code&gt; 实施，我们需要能够访问所有定义的测试用例。一种实现方法是通过 &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; 在运行时检索测试，该测试返回给定模块中所有函数的列表。但是，考虑到我们可能希望除了测试名称之外还存储有关每个测试的更多信息，因此需要一种更灵活的方法。</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">为了修复失败的测试，让我们在 &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; 中创建一个文件，内容如下。在 &lt;code&gt;KV.Bucket&lt;/code&gt; 下面的实现之前，可以尝试使用代理自行实现KV.Bucket模块。</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">为了修复这个bug,我们需要注册表监控它产生的每一个bucket。一旦我们设置了监控器,注册表就会在每次bucket进程退出时收到通知,让我们可以清理注册表。</target>
        </trans-unit>
        <trans-unit id="62bd04dae1b62f0c9a990b148f9408c4a2843b61" translate="yes" xml:space="preserve">
          <source>In order to generate the &lt;code&gt;.app&lt;/code&gt; file, Mix expects your project to have both &lt;code&gt;:app&lt;/code&gt; and &lt;code&gt;:version&lt;/code&gt; keys. Furthermore, you can configure the generated application by defining an &lt;code&gt;application/0&lt;/code&gt; function in your &lt;code&gt;mix.exs&lt;/code&gt; that returns a keyword list.</source>
          <target state="translated">为了生成 &lt;code&gt;.app&lt;/code&gt; 文件，Mix希望您的项目同时具有 &lt;code&gt;:app&lt;/code&gt; 和 &lt;code&gt;:version&lt;/code&gt; 键。此外，您可以通过在 &lt;code&gt;mix.exs&lt;/code&gt; 中定义一个返回关键字列表的 &lt;code&gt;application/0&lt;/code&gt; 函数来配置生成的应用程序。</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">为了启动你的第一个项目,Elixir提供了一个名为Mix的构建工具。你可以通过运行以下程序来启动你的新项目。</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">为了帮助 IEx 理解一个表达式由多行组成,我们可以将其包入括号中。</target>
        </trans-unit>
        <trans-unit id="06a43dffd10b2bfa3f19eb38d062aa6b636e0e88" translate="yes" xml:space="preserve">
          <source>In order to import configuration, &lt;code&gt;my_app&lt;/code&gt;'s &lt;code&gt;.formatter.exs&lt;/code&gt; would look like this:</source>
          <target state="translated">为了导入配置， &lt;code&gt;my_app&lt;/code&gt; 的 &lt;code&gt;.formatter.exs&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">为了调用上面的回调，我们需要遍历相应的 &lt;code&gt;GenServer&lt;/code&gt; 函数。让我们启动一个注册表，创建一个命名桶，然后查找它：</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">为了使我们的服务器能够处理同步连接,我们需要有一个进程作为接受者,产生其他进程来服务请求。一个解决方案是改变。</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">为了操作关键字列表，Elixir提供&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;了 &lt;code&gt;Keyword&lt;/code&gt; 模块&lt;/a&gt;。但是请记住，关键字列表只是列表，因此它们提供与列表相同的线性性能特征。列表越长，找到键，计算项目数等的时间就越长。因此，在Elixir中，关键字列表主要用于传递可选值。如果您需要存储许多物品或保证一键关联的最大一值，则应改用地图。</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">为了运行分布式代码,我们需要先启动</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">为了运行第一个测试，我们需要运行两个节点。进入 &lt;code&gt;apps/kv&lt;/code&gt; ，让我们重新启动将要由测试使用的名为 &lt;code&gt;bar&lt;/code&gt; 的节点。</target>
        </trans-unit>
        <trans-unit id="e8a55d2f768aa9a90c3e47bbc22675a61941f5a4" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called &lt;em&gt;protocol consolidation&lt;/em&gt;. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">为了加快生产环境的调度，在生产环境中，所有实现都是预先已知的，Elixir提供了一项称为&lt;em&gt;协议合并&lt;/em&gt;的功能。合并将协议直接链接到其实现，方式是从合并协议中调用功能等同于调用两个远程功能。</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">在生产环境中,所有的实现都是预先已知的,为了加快调度速度,Elixir提供了一种称为协议合并的功能。合并直接将协议与其实现联系起来,这样,从合并后的协议中调用一个函数就相当于调用两个远程函数。</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">为了启动一个监督者,我们需要首先定义一个将被监督的子进程。作为一个例子,我们将定义一个代表堆栈的GenServer。</target>
        </trans-unit>
        <trans-unit id="0dc599f69280e0654d0ad9b6739bad7864211d7c" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide and learn how to use module attributes as storage to allow developers to create DSLs.</source>
          <target state="translated">为了理解底层代码，我们需要宏，因此我们将在元编程指南中重新访问此模式，并学习如何使用模块属性作为存储以允许开发人员创建DSL。</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">为了理解底层代码，我们需要宏，因此我们将在元编程指南中重新访问此模式。但是，这里的重点是如何使用模块属性作为存储来允许开发人员创建DSL。</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">为了使用依赖关系，您需要在项目配置中添加 &lt;code&gt;:deps&lt;/code&gt; 键。我们经常将依赖项列表提取到其自己的函数中：</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">为了在我们的代码中使用应用程序环境，我们需要用以下定义替换 &lt;code&gt;KV.Router.table/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e357d261c32f760a30d8b31568d4778e3817d29" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以 &lt;code&gt;:binary&lt;/code&gt; 模式打开，这需要函数&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;中的所有其他功能都可用，因为它们直接处理Unicode数据。</target>
        </trans-unit>
        <trans-unit id="579dc3768627dbc4d67a1e0757b95afdfeb30685" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以二进制模式打开，这需要函数&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后必须使用速度较慢的&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt;函数，因为它们负责进行正确的转换并提供正确的数据保证。</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以 &lt;code&gt;:binary&lt;/code&gt; 模式打开，这需要函数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;中的所有其他功能都可用，因为它们直接处理Unicode数据。</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">为了写入和读取文件，必须使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块中的功能。默认情况下，文件以二进制模式打开，这需要函数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;与文件进行交互。开发人员在打开文件时可以通过 &lt;code&gt;:utf8&lt;/code&gt; 作为选项，然后必须使用速度较慢的&lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt;函数，因为它们负责进行正确的转换并提供正确的数据保证。</target>
        </trans-unit>
        <trans-unit id="545dafe5c1ee7a1449e5b9b98c6c6db53caaf9f3" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">换句话说，&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt;转换为：</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; 等效于 &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">换句话说， &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; 转换为：</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">换句话说，&lt;strong&gt;不要&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c7679a9328277147beb719edbd3a5a83c335113c" translate="yes" xml:space="preserve">
          <source>In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (&lt;code&gt;^&lt;/code&gt;):</source>
          <target state="translated">换句话说，Elixir支持重新绑定。如果您不想更改变量的值，可以使用pin运算符（ &lt;code&gt;^&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">换句话说，Elixir将仅解析运行时使用的选项，而忽略所有其他选项。如果您想解析所有开关，无论它们是否存在，都可以通过传递 &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; 作为选项来强制创建原子。请谨慎使用此选项。仅当您构建的命令行应用程序接收动态命名的参数并且在长时间运行的系统中必须避免使用时，此功能才有用。</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">换句话说,无论数据结构是微小还是巨大,名称中包含 &quot;size &quot;一词的函数所需时间都是一样的。相反,名称中带有 &quot;length &quot;的函数,随着数据结构大小的增加,所需的时间也会增加。</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">换句话说，如果在您的应用程序或监督树关闭时，一个进程必须自行清理很重要，则此进程必须陷阱退出，并且其子规范应指定适当的 &lt;code&gt;:shutdown&lt;/code&gt; 值，以确保在合理的间隔内终止。</target>
        </trans-unit>
        <trans-unit id="62c93298d745ed7ef2d4717535ac947d098645b2" translate="yes" xml:space="preserve">
          <source>In other words, if your configuration does something like:</source>
          <target state="translated">换句话说,如果你的配置是这样的。</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">换句话说,区分常规的Elixir值(如列表、映射、进程、引用等)和引用表达式是很重要的。有些值,如整数、原子和字符串,其引用的表达式等于值本身。其他的值,如地图,需要显式转换。最后,像函数和引用这样的值根本不能转换为引号表达式。</target>
        </trans-unit>
        <trans-unit id="8ea1895411f30c25b0c4e8a493357838af36b14b" translate="yes" xml:space="preserve">
          <source>In other words, patterns are allowed only on the left side of &lt;code&gt;=&lt;/code&gt;. The right side of &lt;code&gt;=&lt;/code&gt; follows the regular evaluation semantics of the language.</source>
          <target state="translated">换句话说，仅在 &lt;code&gt;=&lt;/code&gt; 的左侧允许使用模式。 &lt;code&gt;=&lt;/code&gt; 的右侧遵循该语言的常规评估语义。</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">换句话说，原子 &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; 只能用代码点 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 编写。使用其他规范化形式将导致令牌生成器错误。另一方面， &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; 可以写为 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 或006A 006F &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; ，因为它被写在引号之间。</target>
        </trans-unit>
        <trans-unit id="c5f854e2205df45f6200d8840717b4a209cfb3ea" translate="yes" xml:space="preserve">
          <source>In other words, the environment key &lt;code&gt;:db_host&lt;/code&gt; for application &lt;code&gt;:my_app&lt;/code&gt; will only be read when &lt;code&gt;MyApp.DBClient&lt;/code&gt; effectively starts. While reading the application environment at runtime is the preferred approach, in some rare occasions you may want to use the application environment to configure the compilation of a certain project. This is often done by calling &lt;a href=&quot;#get_env/3&quot;&gt;&lt;code&gt;get_env/3&lt;/code&gt;&lt;/a&gt; outside of a function:</source>
          <target state="translated">换句话说，仅当 &lt;code&gt;MyApp.DBClient&lt;/code&gt; 有效启动时，才会读取应用程序 &lt;code&gt;:my_app&lt;/code&gt; 的环境密钥 &lt;code&gt;:db_host&lt;/code&gt; 。虽然在运行时读取应用程序环境是首选方法，但在极少数情况下，您可能希望使用应用程序环境来配置特定项目的编译。这通常是通过在函数外部调用&lt;a href=&quot;#get_env/3&quot;&gt; &lt;code&gt;get_env/3&lt;/code&gt; &lt;/a&gt;来完成的：</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">换句话说,上面的表述简单地翻译为:。</target>
        </trans-unit>
        <trans-unit id="39fc76a1a41dfb78eff4ab58bbe78f4df61a48df" translate="yes" xml:space="preserve">
          <source>In other words, there are multiple ways systems can be deployed and releases can be automated and incorporated into all of them as long as you remember to build the system in the same target triple.</source>
          <target state="translated">换句话说,系统可以有多种部署方式,只要你记得在同一个目标三层中构建系统,发布就可以自动化并融入所有的系统。</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">换句话说，此函数尝试从 &lt;code&gt;path&lt;/code&gt; 剥离 &lt;code&gt;from&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="44dd0ca7035bd0b6e8100243c91751e16aa983c2" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">换句话说，该模块期望通常在从外部源检索数据时在其他位置检测到无效数据。例如，从数据库读取字符串的驱动程序将负责检查编码的有效性。&lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt;可用于将字符串分为有效部分和无效部分。</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">换句话说，此模块期望通常在从外部源检索数据时在其他位置检测到无效数据。例如，从数据库读取字符串的驱动程序将负责检查编码的有效性。&lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt;可用于将字符串分为有效部分和无效部分。</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">换句话说，我们转换给每个表达 &lt;code&gt;case/2&lt;/code&gt; 如步骤 &lt;code&gt;with&lt;/code&gt; 。只要任何一个步骤返回的东西不符合 &lt;code&gt;{:ok, x}&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; 中止，并返回不匹配值。</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">换句话说，即使存储桶崩溃，我们也希望注册表继续运行。让我们编写一个新的注册表测试：</target>
        </trans-unit>
        <trans-unit id="eae49db7d30fd64b6cfb19732b20c2216ea90d4c" translate="yes" xml:space="preserve">
          <source>In other words, what we would expect to be a single character, such as &lt;code&gt;&amp;eacute;&lt;/code&gt; or &lt;code&gt;ł&lt;/code&gt;, can in practice be multiple characters, each represented by potentially multiple bytes. Consider the following:</source>
          <target state="translated">换句话说，实际上，我们期望的单个字符（例如 &lt;code&gt;&amp;eacute;&lt;/code&gt; 或 &lt;code&gt;ł&lt;/code&gt; ）可以是多个字符，每个字符都可能由多个字节表示。考虑以下：</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">换句话说,当调用为。</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">换句话说</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">特别是,如果charlists只包含可打印的ASCII字符,则默认会以单引号打印回来。</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">实际上，字符列表通常在与Erlang接口时使用，特别是不接受二进制文件作为参数的旧库。您可以使用 &lt;code&gt;to_string/1&lt;/code&gt; 和 &lt;code&gt;to_charlist/1&lt;/code&gt; 函数将字符列表转换为字符串并返回：</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">然而，实际上，Elixir开发人员很少使用 &lt;code&gt;try/rescue&lt;/code&gt; 构造。例如，当文件无法成功打开时，许多语言都将迫使您挽救错误。相反，Elixir提供了 &lt;code&gt;File.read/1&lt;/code&gt; 函数，该函数返回一个元组，其中包含有关文件是否成功打开的信息：</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">在实践中，如果发现自己需要动态过程的过程注册表，则应使用Elixir随附&lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;的 &lt;code&gt;Registry&lt;/code&gt; 模块&lt;/a&gt;。它提供的功能类似于我们使用GenServer + &lt;code&gt;:ets&lt;/code&gt; 构建的功能，同时还能够同时执行写入和读取操作。&lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;它已经过基准测试，可以扩展到所有内核，甚至可以在具有40个内核的机器上进行扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">在实践中,通常将服务器和客户端功能放在同一个模块中。如果服务器和/或客户端的实现越来越复杂,你可能会希望将它们放在不同的模块中。</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">在实践中,你更有可能达到Erlang的</target>
        </trans-unit>
        <trans-unit id="cafbb493cd44c8e665619ace61e6011a8cdce243" translate="yes" xml:space="preserve">
          <source>In practice, our tools always start our applications for us, but there is an API available if you need fine-grained control.</source>
          <target state="translated">在实践中,我们的工具总是为我们启动我们的应用程序,但如果你需要精细的控制,有一个API可用。</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">在实践中,我们并不期望作为桶工作的进程会失败。但是,如果它真的发生了,不管是什么原因,我们可以放心,我们的系统将继续按照预期的方式工作。</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">在实践中,你很少用手加载应用程序,因为那是启动过程的一部分,接下来会解释。</target>
        </trans-unit>
        <trans-unit id="719d5c0677afb6db6737335d9338844042ab8998" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix-like systems. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">在极少数情况下，此功能可能在类似Unix的系统上失败。如果当前目录的父目录不存在读取权限，则可能会发生这种情况。因此，如果成功，则返回 &lt;code&gt;{:ok, cwd}&lt;/code&gt; ，否则返回{ &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">在极少数情况下，此功能在Unix上可能会失败。如果当前目录的父目录不存在读取权限，则可能会发生这种情况。因此，如果成功，则返回 &lt;code&gt;{:ok, cwd}&lt;/code&gt; ，否则返回{ &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">以设置符号表示： &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">以设置符号表示： &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">在某些情况下，为所有类型提供默认实现可能会很方便。这可以通过在协议定义 &lt;code&gt;@fallback_to_any&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">在某些情况下，可能有必要在列表中插入许多值。例如，假设您有一个包含 &lt;code&gt;[1, 2, 6]&lt;/code&gt; 的列表，而我们想向其中注入 &lt;code&gt;[3, 4, 5]&lt;/code&gt; 。使用 &lt;code&gt;unquote&lt;/code&gt; 不会产生预期的结果：</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">在某些情况下，这可能导致不希望的格式化。因此，&lt;strong&gt;格式化程序生成的某些代码在美学上可能并不令人满意，并且可能需要开发人员的明确干预&lt;/strong&gt;。这就是为什么我们不建议在现有代码库中盲目运行格式化程序的原因。相反，您应该格式化和检查每个格式化的文件。</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">在某些情况下，您不必关心模式中的特定值。通常将这些值绑定到下划线 &lt;code&gt;_&lt;/code&gt; 。例如，如果仅列表的开头对我们很重要，我们可以将结尾指定为下划线：</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">在某些情况下，您可能需要将这些&lt;em&gt;值&lt;/em&gt;插入带&lt;em&gt;引号的表达式中&lt;/em&gt;。为此，我们需要借助 &lt;code&gt;Macro.escape/1&lt;/code&gt; 首先将这些值转义为带引号的表达式：</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">在某些情况下，您想访问在调用方中定义的别名或模块。为此，您可以使用 &lt;code&gt;alias!&lt;/code&gt; 巨集：</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">在某些情况下,你可以使用formatter不生成优雅代码的事实作为重构的提示。以这段代码为例。</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，开发人员应改为直接导入或别名该模块，以便他们可以根据需要自定义模块，而无需&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt;后面的间接方法。</target>
        </trans-unit>
        <trans-unit id="459d38c03bf669f90bbbe671db50188607d62696" translate="yes" xml:space="preserve">
          <source>In such cases, using the capture operator is no different than using &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，使用捕获运算符与使用 &lt;code&gt;fn&lt;/code&gt; 并无不同。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
