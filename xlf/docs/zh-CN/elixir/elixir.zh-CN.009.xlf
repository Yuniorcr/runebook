<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="27bd571c88e679120d69355a8855de7b06b30a1a" translate="yes" xml:space="preserve">
          <source>The collection types are compared using the following rules:</source>
          <target state="translated">收集类型使用以下规则进行比较。</target>
        </trans-unit>
        <trans-unit id="8c5b2a728faaf0d704086c8a732474d34b64c7d1" translate="yes" xml:space="preserve">
          <source>The comma should be followed by a space.</source>
          <target state="translated">逗号后面应加一个空格。</target>
        </trans-unit>
        <trans-unit id="139636692335607d6eb4460b93391d027f1c3267" translate="yes" xml:space="preserve">
          <source>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</source>
          <target state="translated">上面的命令失败了,因为我们已经切换了shell。由于shell之间是相互隔离的,所以你不能从另一个shell访问在一个shell中定义的变量。</target>
        </trans-unit>
        <trans-unit id="000af91ba82011c87383cf8f5a08713fe7fef900" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;:error&lt;/code&gt;</source>
          <target state="translated">上面的命令返回 &lt;code&gt;:error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93e8c4e8d6a9562251088181806121ea8983b620" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;{:ok, bucket}&lt;/code&gt;</source>
          <target state="translated">上面的命令返回 &lt;code&gt;{:ok, bucket}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="919db13977d98a781eec05aba6aea3150c8048e9" translate="yes" xml:space="preserve">
          <source>The command above will start a new shell and connect to it. Create a new variable called &lt;code&gt;hello&lt;/code&gt; and assign some value to it:</source>
          <target state="translated">上面的命令将启动一个新的shell并连接到它。创建一个名为 &lt;code&gt;hello&lt;/code&gt; 的新变量，并为其分配一些值：</target>
        </trans-unit>
        <trans-unit id="8ecae1fb9875a4247d5f5ea9609a8cfd1c1df1d2" translate="yes" xml:space="preserve">
          <source>The community has also created its own tools, often to aid in production, other times in development:</source>
          <target state="translated">社区也创建了自己的工具,经常是为了辅助生产,其他时候是为了开发。</target>
        </trans-unit>
        <trans-unit id="5f587be913201bd350f5a6a58f7e5d2545a34fce" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">元素之间的比较必须使用&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b72ead9d1380c933dae651b694aba918748f04d3" translate="yes" xml:space="preserve">
          <source>The compilation will fail because &lt;code&gt;My.Module&lt;/code&gt; when quoted is not an atom, but a syntax tree as follows:</source>
          <target state="translated">编译将失败，因为 &lt;code&gt;My.Module&lt;/code&gt; 引号的My.Module不是原子，而是语法树，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd0d32bee722121f8e488a947a395b8badae67cf" translate="yes" xml:space="preserve">
          <source>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</source>
          <target state="translated">编译后的模式在重复进行相同的匹配时非常有用。但请注意,编译后的模式不能存储在模块属性中,因为模式是在运行时生成的,在编译时无法存活。</target>
        </trans-unit>
        <trans-unit id="2c261a06d80c478e0111d6983a7ae911378fd70b" translate="yes" xml:space="preserve">
          <source>The compiler is telling us that invoking the &lt;code&gt;join&lt;/code&gt; function with two arguments will always choose the first definition of &lt;code&gt;join&lt;/code&gt; whereas the second one will only be invoked when three arguments are passed:</source>
          <target state="translated">编译器告诉我们，使用两个参数调用 &lt;code&gt;join&lt;/code&gt; 函数将始终选择 &lt;code&gt;join&lt;/code&gt; 的第一个定义，而仅当传递三个参数时才调用第二个定义：</target>
        </trans-unit>
        <trans-unit id="4a5b9456e8b2526749824cf107036fdea5219003" translate="yes" xml:space="preserve">
          <source>The compiler translates this into multiple functions with different arities, here &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; and &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt;, that represent cases when arguments for parameters with default values are passed or not passed.</source>
          <target state="translated">编译器将此转换为具有不同变量的多个函数，此处为 &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; 和 &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt; ，它们表示传递或不传递具有默认值的参数的情况。</target>
        </trans-unit>
        <trans-unit id="25ad36289d9fc32f9ce285a83c0db949e85318f5" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, etc. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">编译器利用临时模块来编译代码。例如 &lt;code&gt;elixir_compiler_1&lt;/code&gt; ， &lt;code&gt;elixir_compiler_2&lt;/code&gt; 等。如果编译后的代码存储对匿名函数或类似函数的引用，则Elixir编译器可能无法回收这些模块，从而在内存中保留了不必要的代码量，最终导致诸如 &lt;code&gt;elixir_compiler_12345&lt;/code&gt; 之类的模块。</target>
        </trans-unit>
        <trans-unit id="4e326f0b1277ff195521c682d15083f035944526" translate="yes" xml:space="preserve">
          <source>The compiler will infer this argument as &lt;code&gt;map&lt;/code&gt;. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:</source>
          <target state="translated">编译器会将这个参数推断为 &lt;code&gt;map&lt;/code&gt; 。有时，推断将不是最佳的，特别是如果函数包含多个子句且参数每次都匹配不同值时。您可以通过在实现之前的任何时候仅声明函数头来为文档指定适当的名称：</target>
        </trans-unit>
        <trans-unit id="68165d5af4e0c7518ce750565d2875d5f1b99f6f" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, e.g. &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">&lt;code&gt;a ++ b&lt;/code&gt; 的复杂度与 &lt;code&gt;length(a)&lt;/code&gt; 成正比，因此避免重复附加到任意长度的 &lt;code&gt;list ++ [element]&lt;/code&gt; ，例如list ++ [element]。相反，请考虑通过 &lt;code&gt;[element | rest]&lt;/code&gt; ，然后反转。</target>
        </trans-unit>
        <trans-unit id="ce5190846b0b9ce88bde5e1fb9838155c0302562" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a -- b&lt;/code&gt; is proportional to &lt;code&gt;length(a) * length(b)&lt;/code&gt;, meaning that it will be very slow if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are long lists. In such cases, consider converting each list to a &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; and using &lt;a href=&quot;mapset#difference/2&quot;&gt;&lt;code&gt;MapSet.difference/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a -- b&lt;/code&gt; 的复杂度与 &lt;code&gt;length(a) * length(b)&lt;/code&gt; 成正比，这意味着如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是长列表，它将非常慢。在这种情况下，请考虑将每个列表转换为&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;并使用&lt;a href=&quot;mapset#difference/2&quot;&gt; &lt;code&gt;MapSet.difference/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84ce76ba55c26126100351cef4100465580a3f63" translate="yes" xml:space="preserve">
          <source>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with &lt;a href=&quot;#stat/1&quot;&gt;&lt;code&gt;stat/1&lt;/code&gt;&lt;/a&gt; will most probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">压缩选项必须与读取或写入结合使用，但不能同时结合使用。请注意，使用&lt;a href=&quot;#stat/1&quot;&gt; &lt;code&gt;stat/1&lt;/code&gt; &lt;/a&gt;获得的文件大小很可能与可从压缩文件读取的字节数不匹配。</target>
        </trans-unit>
        <trans-unit id="6d2bc42beb1d07a11bffabca4e75ecee65b8f3cc" translate="yes" xml:space="preserve">
          <source>The concurrency can be increased or decreased using the &lt;code&gt;:max_concurrency&lt;/code&gt; option. For example, if the tasks are IO heavy, the value can be increased:</source>
          <target state="translated">可以使用 &lt;code&gt;:max_concurrency&lt;/code&gt; 选项增加或减少并发性。例如，如果任务是IO繁重的任务，则可以增加该值：</target>
        </trans-unit>
        <trans-unit id="2dcb06049bb00d9d82db3a23393505f88e85183b" translate="yes" xml:space="preserve">
          <source>The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them.</source>
          <target state="translated">配置会被合并在一起,在冲突的情况下,第二个配置的值比第一个配置的值优先。如果两个值都设置为关键字列表,则将它们深度合并。</target>
        </trans-unit>
        <trans-unit id="8bfd0598c3186c98ed3b75f81d353f661a54c9d0" translate="yes" xml:space="preserve">
          <source>The console backend allows you to customize the format of your log messages with the &lt;code&gt;:format&lt;/code&gt; option.</source>
          <target state="translated">控制台后端允许您使用 &lt;code&gt;:format&lt;/code&gt; 选项来自定义日志消息的格式。</target>
        </trans-unit>
        <trans-unit id="7235027880d78a2aea2ca7dc4debaca1a57f60b0" translate="yes" xml:space="preserve">
          <source>The console backend logs messages by printing them to the console. It supports the following options:</source>
          <target state="translated">控制台后台通过打印消息到控制台来记录消息。它支持以下选项:</target>
        </trans-unit>
        <trans-unit id="8de6b43b33ab75286e101ec804e217bdf4636eeb" translate="yes" xml:space="preserve">
          <source>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</source>
          <target state="translated">上下文用于将回调的信息传递给测试。为了将信息从测试传递给回调,ExUnit提供了标签。</target>
        </trans-unit>
        <trans-unit id="df9b547258c058ce1d60f5a04eb16b39a7714b90" translate="yes" xml:space="preserve">
          <source>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</source>
          <target state="translated">延续是当枚举被暂停时作为结果返回的闭包。当调用时,它期待一个新的累加器,并返回结果。</target>
        </trans-unit>
        <trans-unit id="95e2451a8bd06ec3ff7404ffc596006e9814e181" translate="yes" xml:space="preserve">
          <source>The correct way to write the refutation above is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">编写上述反驳的正确方法是使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="471e051b1dfc7605a0864374979ff909fdd918ff" translate="yes" xml:space="preserve">
          <source>The corresponding child process must not be running; use &lt;a href=&quot;#terminate_child/2&quot;&gt;&lt;code&gt;terminate_child/2&lt;/code&gt;&lt;/a&gt; to terminate it if it's running.</source>
          <target state="translated">相应的子进程一定不能运行；如果正在运行，请使用&lt;a href=&quot;#terminate_child/2&quot;&gt; &lt;code&gt;terminate_child/2&lt;/code&gt; &lt;/a&gt;终止它。</target>
        </trans-unit>
        <trans-unit id="25f2832dc850f5e3ce868623e448ed6173ae8a76" translate="yes" xml:space="preserve">
          <source>The crypto module</source>
          <target state="translated">加密模块</target>
        </trans-unit>
        <trans-unit id="9ecd090fb1dcdddfdde8d184412bdb4ef34572bf" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以随时通过&lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;访问当前环境。在宏内部，可以通过&lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;访问调用者环境。</target>
        </trans-unit>
        <trans-unit id="b2d538224a6564739f222b37335408e88b676276" translate="yes" xml:space="preserve">
          <source>The date and time fields in the struct can be accessed directly:</source>
          <target state="translated">可以直接访问结构中的日期和时间字段。</target>
        </trans-unit>
        <trans-unit id="104ca7733bdc0fce19ec1a42bd6f6c3a9728b295" translate="yes" xml:space="preserve">
          <source>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</source>
          <target state="translated">天数按格里高利日计算。返回的日期与输入的日历相同。</target>
        </trans-unit>
        <trans-unit id="81de1658f9b930a338fa7d15b3cd46a31f6ce081" translate="yes" xml:space="preserve">
          <source>The default engine used by EEx.</source>
          <target state="translated">EEx使用的默认引擎。</target>
        </trans-unit>
        <trans-unit id="1841b4dcd409156ad003b434d7d06485770c7448" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;node#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">默认节点是本地节点&lt;a href=&quot;node#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;node&lt;/code&gt; 是本地节点，该函数还将所有其他未知节点的cookie设置为 &lt;code&gt;cookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7448078e00a12f44bc6d6a512061a6e8e76068" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds.</source>
          <target state="translated">默认输出包含从所有匹配函数中收集的数据。标题后的第一行包含部分结果的总和,以及列出的所有函数调用的平均时间。下面的几行包含函数调用,然后是函数被调用的次数,然后是调用所用时间的百分比,然后是该函数的总时间(以微秒为单位),最后是每次调用的平均时间(以微秒为单位)。</target>
        </trans-unit>
        <trans-unit id="ea39ed70f4785b6c480b790dacca9bfe36cb2b1f" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;code&gt;&amp;lt;--&lt;/code&gt; symbol is meant to help visualize where a new module call count begins.</source>
          <target state="translated">默认输出包含从所有匹配函数收集的数据。左列构成每个模块，其总调用计数跟踪显示在右侧。每个模块的计数均按以下功能区分。在 &lt;code&gt;&amp;lt;--&lt;/code&gt; 一个新的模块调用计数开始的地方符号是为了帮助可视化。</target>
        </trans-unit>
        <trans-unit id="819e6f3391fb45f7ce5241a6dd1d1431dc481702" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning:</source>
          <target state="translated">默认输出包含从所有剖析过程收集的数据。所有时间都是挂钟毫秒。这些列具有以下含义。</target>
        </trans-unit>
        <trans-unit id="380321e8388d234e55ec92513260d8b22df6e305" translate="yes" xml:space="preserve">
          <source>The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:</source>
          <target state="translated">上面的定义在这个特殊的例子中是行不通的,因为它会试图用一个空列表的初始值来启动计数器。然而,在你自己的代理中,这可能是一个可行的选择。一个常见的方法是使用关键字列表,因为这将允许设置初始值并给计数器进程命名,例如。</target>
        </trans-unit>
        <trans-unit id="14e3a7f1b4ff430ef2347af078514bfcd6aac53f" translate="yes" xml:space="preserve">
          <source>The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">依赖项的版本应按照语义版本控制进行格式化，并且必须按照&amp;ldquo; &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;模块中的定义指定要求。</target>
        </trans-unit>
        <trans-unit id="0199850bb5adebc71f4018576818506ad556f1cc" translate="yes" xml:space="preserve">
          <source>The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">设备将被创建并发送到给定的功能。函数返回时，设备将关闭。最终结果将是带有 &lt;code&gt;:ok&lt;/code&gt; 的元组和函数的结果。</target>
        </trans-unit>
        <trans-unit id="92c1c70614d3e16189eb567106d0cd377288e598" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; is that the latter is more strict when comparing integers and floats:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 之间的区别在于，在比较整数和浮点数时，后者更加严格：</target>
        </trans-unit>
        <trans-unit id="7b165d79002d46e097dd675e283b2c25db64a858" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">两种方法之间的区别在于，基于模块的管理器使您可以直接控制管理器的初始化方式。我们没有通过自动初始化的子代列表调用&lt;a href=&quot;supervisor#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt;，而是通过在其&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调中调用&lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; 来&lt;/a&gt;手动初始化子代。</target>
        </trans-unit>
        <trans-unit id="3b5eb7b6faff508891acf9d2eb056d03565a244c" translate="yes" xml:space="preserve">
          <source>The difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.</source>
          <target state="translated">不同的是,匿名函数要求目标节点与调用者的代码版本完全相同。使用模块、函数和参数更稳健,因为你只需要在给定的模块中找到一个具有匹配的arity的函数。</target>
        </trans-unit>
        <trans-unit id="5358501133f2ba56bf1b306cdd649fc8fee2e62a" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">区别在于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;期望子规范在调用&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt;的那一刻出现，并且不再位于init回调上。如果初始化时有任何初始参数，例如 &lt;code&gt;[initial_arg]&lt;/code&gt; ，则可以在&lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;:extra_arguments&lt;/code&gt; 标志中给出。</target>
        </trans-unit>
        <trans-unit id="53c4296a8b739f59bee25619f4e6585ba6646d78" translate="yes" xml:space="preserve">
          <source>The digraph module</source>
          <target state="translated">图形模块</target>
        </trans-unit>
        <trans-unit id="d3687778e68f2e38fa3eb29706a7417475b459a2" translate="yes" xml:space="preserve">
          <source>The document starts flat (without breaks) until a group is found.</source>
          <target state="translated">文件开始时是平铺直叙的(没有间断),直到找到一个组。</target>
        </trans-unit>
        <trans-unit id="2ad969954076e16dcc1ff7f0c2aba06e5e46ee7f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) in Elixir can be used for remote calls:</source>
          <target state="translated">Elixir中的点（ &lt;code&gt;.&lt;/code&gt; ）可用于远程呼叫：</target>
        </trans-unit>
        <trans-unit id="555f5e20b9d1a7a0564cfc99c5aa3c497147b302" translate="yes" xml:space="preserve">
          <source>The dot may be used to invoke anonymous functions too:</source>
          <target state="translated">点也可以用来调用匿名函数。</target>
        </trans-unit>
        <trans-unit id="2b457ad21100bb14e953ebf6025ecbe3add69796" translate="yes" xml:space="preserve">
          <source>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</source>
          <target state="translated">返回的两个列表中的元素与原始枚举中的元素的相对顺序相同(如果这样的枚举是有序的,像一个列表)。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="46fd29816806a299fb407c730c9ba36ba20c158f" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. It is required to return either &lt;code&gt;{:ok, term}&lt;/code&gt;, where term is an atom. It is possible to return something else than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">编码器功能应该从给定的字符串创建一个原子。需要返回 &lt;code&gt;{:ok, term}&lt;/code&gt; ，其中term是一个原子。可以返回原子以外的其他东西，但是，在这种情况下，AST不再&amp;ldquo;有效&amp;rdquo;，因为它不能用于编译或评估Elixir代码。一个用例是，如果您想在面向用户的情况下使用Elixir解析器，但又不想用尽原子表。</target>
        </trans-unit>
        <trans-unit id="7abcd054d6c0c3b0676a107d280986f037e15ba1" translate="yes" xml:space="preserve">
          <source>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt;.</source>
          <target state="translated">编码器功能将接收原子名称（作为二进制文件）和带有当前文件，行和列的关键字列表。它必须返回 &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d93739e1f908805f248fbd3ca05efb8a31a93ffb" translate="yes" xml:space="preserve">
          <source>The environment</source>
          <target state="translated">环境问题</target>
        </trans-unit>
        <trans-unit id="b1059c7023600cf66d37436e09b5b8c7e27f7d77" translate="yes" xml:space="preserve">
          <source>The environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the &lt;code&gt;:prod&lt;/code&gt; environment.</source>
          <target state="translated">该环境仅适用于当前项目。正如我们将在以后的章节中看到的，默认情况下，添加到项目中的所有依赖项都将在 &lt;code&gt;:prod&lt;/code&gt; 环境中运行。</target>
        </trans-unit>
        <trans-unit id="569fc959f1dad768558df72d1e65bcb68e016b15" translate="yes" xml:space="preserve">
          <source>The environment can be changed via the command line by setting the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable, for example:</source>
          <target state="translated">可以通过设置 &lt;code&gt;MIX_ENV&lt;/code&gt; 环境变量，通过命令行来更改环境，例如：</target>
        </trans-unit>
        <trans-unit id="cfd48ae86d7fb6e0cc9118fb73487346d9610f87" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;mix#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;mix#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; &lt;/a&gt;读取环境。</target>
        </trans-unit>
        <trans-unit id="79b786be3813b81bda2dd7613367e75b678039b6" translate="yes" xml:space="preserve">
          <source>The environment is available after loading the application, which is a process explained later:</source>
          <target state="translated">加载应用后就可以使用环境了,这个过程后面会解释。</target>
        </trans-unit>
        <trans-unit id="97a5f35bc8e443b15b7816310584c96da8ae8afe" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;exunit.test&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exunit.testmodule&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exunit.test&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;exunit.testmodule&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;返回的错误状态</target>
        </trans-unit>
        <trans-unit id="fd79581f4945ce7000f24bd77d80edb09d58223a" translate="yes" xml:space="preserve">
          <source>The example above broadcasted the message &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="translated">上面的示例将消息 &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; 到在&amp;ldquo; topic&amp;rdquo;（或我们迄今为止称为&amp;ldquo; key&amp;rdquo;） &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 下注册的所有进程。</target>
        </trans-unit>
        <trans-unit id="85cebbc730e74ea1586122c70e3648ace6b606a3" translate="yes" xml:space="preserve">
          <source>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with &lt;code&gt;100_000&lt;/code&gt; items. Then we keep all odd elements from the list, generating a new list, now with &lt;code&gt;50_000&lt;/code&gt; items, and then we sum all entries.</source>
          <target state="translated">上面的示例具有一系列操作。我们从一个范围开始，然后将范围中的每个元素乘以3。现在，第一个操作将创建并返回一个包含 &lt;code&gt;100_000&lt;/code&gt; 个项目的列表。然后，我们保留列表中的所有奇数元素，生成一个新列表，现在具有 &lt;code&gt;50_000&lt;/code&gt; 个项目，然后对所有条目求和。</target>
        </trans-unit>
        <trans-unit id="d7a86a0bce3d2d4979cfe2b252cb1ba44bf3ffc0" translate="yes" xml:space="preserve">
          <source>The example above is the same as calling &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt;.</source>
          <target state="translated">上面的示例与调用 &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34a98e7e58a5ad26483cead8675329ffdc04e919" translate="yes" xml:space="preserve">
          <source>The example above rescues the runtime error and returns the error itself which is then printed in the &lt;code&gt;iex&lt;/code&gt; session.</source>
          <target state="translated">上面的示例挽救了运行时错误，并返回错误本身，然后将其打印在 &lt;code&gt;iex&lt;/code&gt; 会话中。</target>
        </trans-unit>
        <trans-unit id="a1acf2309aa592e7d6d6148eb2c43c7439baf836" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred strategy for customizing exception messages.</source>
          <target state="translated">上面的例子显示了自定义异常消息的首选策略。</target>
        </trans-unit>
        <trans-unit id="7c4ee977260f8fcae5e39eaa8c9f47beb473c79e" translate="yes" xml:space="preserve">
          <source>The example above will define two modules: &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt;. The second can be accessed as &lt;code&gt;Bar&lt;/code&gt; inside &lt;code&gt;Foo&lt;/code&gt; as long as they are in the same lexical scope. The code above is exactly the same as:</source>
          <target state="translated">上面的示例将定义两个模块： &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Foo.Bar&lt;/code&gt; 。第二个可以作为访问 &lt;code&gt;Bar&lt;/code&gt; 内 &lt;code&gt;Foo&lt;/code&gt; ，只要它们是在同一个词汇范围。上面的代码与以下代码完全相同：</target>
        </trans-unit>
        <trans-unit id="8af5b80536d2c072fd5d6366536aa5700dca7b65" translate="yes" xml:space="preserve">
          <source>The example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.</source>
          <target state="translated">上面的例子将获取你所选文件的前10行。这意味着流对于处理大文件甚至是网络资源等慢速资源是非常有用的。</target>
        </trans-unit>
        <trans-unit id="b5335acb8d877ec62b7cb06ce91a567ae1709575" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 与右边列表中的第一个值匹配时，以上示例才有效。否则，它将引发&lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt;（就像 &lt;code&gt;=&lt;/code&gt; 运算符一样）。</target>
        </trans-unit>
        <trans-unit id="6b460f75ed7a246aed0999b0840cd9a86244be18" translate="yes" xml:space="preserve">
          <source>The example above will print:</source>
          <target state="translated">上面的例子就可以打印了。</target>
        </trans-unit>
        <trans-unit id="fb87f61c9de07aa0c29854b1fe6c1165c0f17fed" translate="yes" xml:space="preserve">
          <source>The example above will run all tests that have the external option set to &lt;code&gt;true&lt;/code&gt;. It is also possible to include all examples that have a given tag, regardless of its value:</source>
          <target state="translated">上面的示例将运行所有将外部选项设置为 &lt;code&gt;true&lt;/code&gt; 的测试。也可以包括所有具有给定标签的示例，无论其值如何：</target>
        </trans-unit>
        <trans-unit id="a35cc3928c93cd1525534e5aae37a525e3a1f63a" translate="yes" xml:space="preserve">
          <source>The example below prints the available compilers and then the list of dependencies.</source>
          <target state="translated">下面的例子打印了可用的编译器,然后是依赖列表。</target>
        </trans-unit>
        <trans-unit id="977b62dac31ac2298799e3e82efadb76ace792aa" translate="yes" xml:space="preserve">
          <source>The examples below will use &lt;code&gt;break!&lt;/code&gt;, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name &lt;code&gt;IEx.break!&lt;/code&gt;.</source>
          <target state="translated">以下示例将使用 &lt;code&gt;break!&lt;/code&gt; ，假设您是直接从IEx Shell中设置断点。但是，您可以使用完全限定的名称 &lt;code&gt;IEx.break!&lt;/code&gt; 在任何地方设置中断！。</target>
        </trans-unit>
        <trans-unit id="598b6c321009ab41147aeda0cc432613c93bc6ff" translate="yes" xml:space="preserve">
          <source>The exception type</source>
          <target state="translated">异常类型</target>
        </trans-unit>
        <trans-unit id="ef1dcbe751c0f9e41d4eb9dc12ae9aa4ff81e740" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</source>
          <target state="translated">这个函数使用了Erlang的术语排序,这意味着比较是结构性的,而不是语义性的。例如</target>
        </trans-unit>
        <trans-unit id="a8e9535a979f24690a83f0d69ec866c95c5b87d9" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;enum#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">通过发出使用警告可以有效地弃用该功能。这也称为硬弃用。为了弃用某个功能，建议的替代方案必须至少存在三个次要版本。例如，在Elixir v1.1中，不赞成使用 &lt;code&gt;Enum.uniq/2&lt;/code&gt; ,而推荐使用&lt;a href=&quot;enum#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt;。这意味着过时警告只能由Elixir v1.4或更高版本发出。</target>
        </trans-unit>
        <trans-unit id="77826c76ea0072ad69d2f391c353d094902019fd" translate="yes" xml:space="preserve">
          <source>The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.</source>
          <target state="translated">该功能被删除。这只能发生在主要的版本中。这意味着Elixir v1.x中的废弃功能只能由Elixir v2.x删除。</target>
        </trans-unit>
        <trans-unit id="64f27bcc28943bbd06806f078df1fb5cd0c4fa41" translate="yes" xml:space="preserve">
          <source>The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.</source>
          <target state="translated">这个特性是软弃用的,这意味着CHANGELOG和文档都必须将该特性列为弃用,但运行代码时却不会发出有效的警告。这意味着CHANGELOG和文档都必须将该特性列为过时的特性,但运行代码时不会发出有效的警告。没有要求对一个特性进行软废弃。</target>
        </trans-unit>
        <trans-unit id="aaf695dceb54489cced53f84555aabadc2f0e697" translate="yes" xml:space="preserve">
          <source>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">如果文件不存在，则创建该文件。如果存在，则先前的内容将被覆盖。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="d594748254e0bf9d6de08774efbf46885ccdc846" translate="yes" xml:space="preserve">
          <source>The file is created if it doesn't exist. Requires datetime in UTC (as returned by &lt;code&gt;:erlang.universaltime()&lt;/code&gt;) or an integer representing the POSIX timestamp (as returned by &lt;code&gt;System.os_time(:second)&lt;/code&gt;).</source>
          <target state="translated">如果文件不存在，则会创建该文件。需要UTC中的日期时间（由 &lt;code&gt;:erlang.universaltime()&lt;/code&gt; 返回）或代表POSIX时间戳的整数（由 &lt;code&gt;System.os_time(:second)&lt;/code&gt; 返回）。</target>
        </trans-unit>
        <trans-unit id="16e6a8d0dd5fc8fad11975b4cd8380cee1d272d3" translate="yes" xml:space="preserve">
          <source>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</source>
          <target state="translated">打开文件,作为参数给函数,函数返回后自动关闭,不管执行函数时是否有错误。</target>
        </trans-unit>
        <trans-unit id="7da78c24b03af92a331655b22affad9970828441" translate="yes" xml:space="preserve">
          <source>The file will be compiled in memory and executed, printing &amp;ldquo;3&amp;rdquo; as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</source>
          <target state="translated">该文件将在内存中编译并执行，结果打印为&amp;ldquo; 3&amp;rdquo;。不会创建任何字节码文件。在以下示例中，我们建议您将代码写入脚本文件并执行，如上所示。</target>
        </trans-unit>
        <trans-unit id="163b392b3771b3d68e4cabd76e12f649d752ed1d" translate="yes" xml:space="preserve">
          <source>The final code for the application built in this guide is in &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;this repository&lt;/a&gt; and can be used as a reference.</source>
          <target state="translated">本指南中构建的应用程序的最终代码位于&lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;此存储库中&lt;/a&gt;，可以用作参考。</target>
        </trans-unit>
        <trans-unit id="eeed0a9446d454784748ae3c92f5f970ae5e8749" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;macro#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">最终的模块名称将为 &lt;code&gt;MyHelpers.Module&lt;/code&gt; 而不是 &lt;code&gt;My.Module&lt;/code&gt; 。使用&lt;a href=&quot;macro#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; 时&lt;/a&gt;，将考虑此类别名。本地和远程宏也得到了扩展。我们可以重写上面的宏以将此函数用作：</target>
        </trans-unit>
        <trans-unit id="c94b7aa6c8d6098097b882564487315e75f42062" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; is a list of child specifications as defined in the &quot;child_spec/1&quot; section above.</source>
          <target state="translated">给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;提供的第一个参数是上面&amp;ldquo; child_spec / 1&amp;rdquo;部分中定义的子级规范列表。</target>
        </trans-unit>
        <trans-unit id="3bd0d4cfc55b69d9253066edc78349e5a5f0a43e" translate="yes" xml:space="preserve">
          <source>The first clause above will only match when &lt;code&gt;x&lt;/code&gt; is positive.</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 为正数时，上面的第一个子句才匹配。</target>
        </trans-unit>
        <trans-unit id="eb035f0f30f88032dbb2e6101c25284087903853" translate="yes" xml:space="preserve">
          <source>The first clause has a guard which says &amp;ldquo;use this definition if and only if &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;1&lt;/code&gt;&amp;rdquo;. Since this is not the case, Elixir proceeds to the next clause&amp;rsquo;s definition.</source>
          <target state="translated">第一个子句有一个保护语，它表示&amp;ldquo;仅当 &lt;code&gt;n&lt;/code&gt; 小于或等于 &lt;code&gt;1&lt;/code&gt; 时使用此定义&amp;rdquo;。由于不是这种情况，因此Elixir进入下一个子句的定义。</target>
        </trans-unit>
        <trans-unit id="89e50c2ad64d1cb084a88caace5a204ed21c004f" translate="yes" xml:space="preserve">
          <source>The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.</source>
          <target state="translated">第一列是该功能被硬性废弃的版本。第二栏简要描述了被废弃的功能,第三栏解释了替换的功能以及替换的版本。</target>
        </trans-unit>
        <trans-unit id="090b48aa7b27ba7aabd1d7a17461511059a79e62" translate="yes" xml:space="preserve">
          <source>The first element is always dropped, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为0 ，否则始终删除第一个元素。</target>
        </trans-unit>
        <trans-unit id="f10968f84672fced5f1e4ec8ec8d8d3398ac17ef" translate="yes" xml:space="preserve">
          <source>The first element is always included, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为0 ，否则始终包含第一个元素。</target>
        </trans-unit>
        <trans-unit id="d62944a019ad040d05e692b397bd4389633cb416" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function, unless &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;nth&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，否则始终将第一个元素传递给给定的函数。</target>
        </trans-unit>
        <trans-unit id="6d3d07fd30dfdee5089f7add816955448e8a7e62" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function.</source>
          <target state="translated">第一个元素总是传递给给定的函数。</target>
        </trans-unit>
        <trans-unit id="a20362c2ee76acf3525cfe072360096fe727a0f9" translate="yes" xml:space="preserve">
          <source>The first element is an atom or another tuple in the same representation;</source>
          <target state="translated">第一个元素是原子或同一表示方式的另一个元组。</target>
        </trans-unit>
        <trans-unit id="de5cd0ed2836b580d20a53b60b89fdbc3744b2af" translate="yes" xml:space="preserve">
          <source>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list.</source>
          <target state="translated">第一个元素是函数名,第二个是包含元数据的关键字列表,第三个是参数列表。</target>
        </trans-unit>
        <trans-unit id="8b93358d99cbfe2c9b65df07674bef6d363d42e0" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;enumerable&lt;/code&gt; is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the &lt;code&gt;enumerable&lt;/code&gt; is done, the last accumulator is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 的第一个元素用作累加器的初始值。然后，使用下一个元素和累加器调用该函数。该函数返回的结果将用作下一次迭代的累加器。当 &lt;code&gt;enumerable&lt;/code&gt; 完成，则返回上一个累加器。</target>
        </trans-unit>
        <trans-unit id="ff5ed72f8d68d33e831fb03d181cb08f9312e39a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple is always an atom or another tuple in the same representation.</source>
          <target state="translated">元组的第一个元素总是一个原子或同一表示中的另一个元组。</target>
        </trans-unit>
        <trans-unit id="753965fc9c8c958c1adc18030905ea9a9fce1c71" translate="yes" xml:space="preserve">
          <source>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling &lt;code&gt;do_something_expensive(state)&lt;/code&gt; outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.</source>
          <target state="translated">第一个功能阻止代理。第二个功能将所有状态复制到客户端，然后在客户端中执行操作。要考虑的一个方面是，数据是否足够大以至少在开始时需要在服务器中进行处理，还是足够小以廉价地发送到客户端。另一个因素是是否需要原子处理数据：获取状态并在代理外部调用 &lt;code&gt;do_something_expensive(state)&lt;/code&gt; 意味着可以同时更新代理的状态。这在更新的情况下尤其重要，因为如果多个客户端试图将同一状态更新为不同的值，则在客户端而不是服务器中计算新状态会导致争用情况。</target>
        </trans-unit>
        <trans-unit id="3a8bdc0ad5ea0cf6a739758090fdb5a2d0573fc4" translate="yes" xml:space="preserve">
          <source>The first function is &lt;code&gt;start_link/1&lt;/code&gt;, which starts a new GenServer passing a list of options. &lt;code&gt;start_link/1&lt;/code&gt; calls out to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;, which takes three arguments:</source>
          <target state="translated">第一个功能是 &lt;code&gt;start_link/1&lt;/code&gt; ，它启动一个新的GenServer并传递选项列表。 &lt;code&gt;start_link/1&lt;/code&gt; 调出 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; ，它带有三个参数：</target>
        </trans-unit>
        <trans-unit id="6da90265feaa08cdbd5c291c792941296efaf6fb" translate="yes" xml:space="preserve">
          <source>The first is the &lt;code&gt;init/1&lt;/code&gt; callback, that receives the second argument given to &lt;code&gt;GenServer.start_link/3&lt;/code&gt; and returns &lt;code&gt;{:ok, state}&lt;/code&gt;, where state is a new map. We can already notice how the &lt;code&gt;GenServer&lt;/code&gt; API makes the client/server segregation more apparent. &lt;code&gt;start_link/3&lt;/code&gt; happens in the client, while &lt;code&gt;init/1&lt;/code&gt; is the respective callback that runs on the server.</source>
          <target state="translated">第一个是 &lt;code&gt;init/1&lt;/code&gt; 回调，它接收给 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; 的第二个参数，并返回 &lt;code&gt;{:ok, state}&lt;/code&gt; ，其中state是一个新映射。我们已经注意到 &lt;code&gt;GenServer&lt;/code&gt; API 如何使客户端/服务器隔离更加明显。 &lt;code&gt;start_link/3&lt;/code&gt; 在客户端中发生，而 &lt;code&gt;init/1&lt;/code&gt; 是在服务器上运行的相应回调。</target>
        </trans-unit>
        <trans-unit id="56525212a2d836e7b2e6c9fc3d438debd74b1ce4" translate="yes" xml:space="preserve">
          <source>The first occurrence of each element is kept.</source>
          <target state="translated">每个元素的第一次出现都会被保留。</target>
        </trans-unit>
        <trans-unit id="6fdbbd4ad4f56c5f2d4b83c9b51836d3c3baff1c" translate="yes" xml:space="preserve">
          <source>The first one is related to operator precedence. For example, the following expression:</source>
          <target state="translated">第一个是与运算符优先性有关。例如,下面的表达式。</target>
        </trans-unit>
        <trans-unit id="eb6432ba2d593bb02b187beac0081aecf4153a10" translate="yes" xml:space="preserve">
          <source>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</source>
          <target state="translated">首先是代码是真正的评估而不是编译。这意味着在shell中做的任何基准测试都会有倾斜的结果。所以千万不要在shell中运行任何profiling或基准。</target>
        </trans-unit>
        <trans-unit id="9aa7af0b736df8170b447c11a0b1486409c8447e" translate="yes" xml:space="preserve">
          <source>The first one is with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; which we can use instead of &lt;code&gt;IO.inspect binding()&lt;/code&gt;:</source>
          <target state="translated">第一个是使用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，我们可以使用它代替 &lt;code&gt;IO.inspect binding()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cece2699937857700a6e57ae7a8e2fdab1620e09" translate="yes" xml:space="preserve">
          <source>The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is &lt;code&gt;{key, pid, value}&lt;/code&gt;. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt;.</source>
          <target state="translated">第一部分，匹配模式，必须是一个与存储在注册表中的数据结构（ &lt;code&gt;{key, pid, value}&lt;/code&gt; 匹配的元组。原子 &lt;code&gt;:_&lt;/code&gt; 可用于忽略给定的值或元组元素，而原子 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 可用于将部分模式临时分配给变量，以进行后续比较。可以像 &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33bf9cc2d09af8093ef73164f4425101ddcff356" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented.</source>
          <target state="translated">第一行(总)是所有函数调用的总和。在最后一行中,列出了被考虑进行剖析的匹配函数的数量。</target>
        </trans-unit>
        <trans-unit id="c85192b0b88529b2ffa5c7dc5ed794fb80bfa927" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code.</source>
          <target state="translated">第一行(Total)是所有剖析进程中执行的所有函数的总和。对于给定的输出,我们总共有200279次函数调用,运行代码的时间大约为2秒。</target>
        </trans-unit>
        <trans-unit id="7cd60f6007c291382d0b163734079218de4d7d65" translate="yes" xml:space="preserve">
          <source>The first step in our implementation is to call &lt;code&gt;use Agent&lt;/code&gt;.</source>
          <target state="translated">我们实现的第一步是调用 &lt;code&gt;use Agent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="868cc4dcae35b14912938b182f9884b2f9e36c22" translate="yes" xml:space="preserve">
          <source>The first step is to tell our application definition (i.e. our &lt;code&gt;.app&lt;/code&gt; file) which module is going to implement the application callback. Let&amp;rsquo;s do so by opening &lt;code&gt;mix.exs&lt;/code&gt; and changing &lt;code&gt;def application&lt;/code&gt; to the following:</source>
          <target state="translated">第一步是告诉我们的应用程序定义（即我们的 &lt;code&gt;.app&lt;/code&gt; 文件），哪个模块将实现应用程序回调。通过打开 &lt;code&gt;mix.exs&lt;/code&gt; 并将 &lt;code&gt;def application&lt;/code&gt; 更改为以下内容来进行操作：</target>
        </trans-unit>
        <trans-unit id="08b35c8002543aef4eef62b9715905dd1c3e096e" translate="yes" xml:space="preserve">
          <source>The first test invokes &lt;code&gt;Kernel.node/0&lt;/code&gt;, which returns the name of the current node, based on the bucket names &amp;ldquo;hello&amp;rdquo; and &amp;ldquo;world&amp;rdquo;. According to our routing table so far, we should get &lt;code&gt;foo@computer-name&lt;/code&gt; and &lt;code&gt;bar@computer-name&lt;/code&gt; as responses, respectively.</source>
          <target state="translated">第一个测试调用 &lt;code&gt;Kernel.node/0&lt;/code&gt; ，它根据存储桶名称&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; world&amp;rdquo;返回当前节点的名称。根据到目前为止的路由表，我们应该分别获得 &lt;code&gt;foo@computer-name&lt;/code&gt; 和 &lt;code&gt;bar@computer-name&lt;/code&gt; 作为响应。</target>
        </trans-unit>
        <trans-unit id="aac5f450f7a22287bfbd1ca580bfb413b84283d5" translate="yes" xml:space="preserve">
          <source>The first time this task is run with &lt;code&gt;--stale&lt;/code&gt;, all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with &lt;code&gt;--stale&lt;/code&gt;. A test file is also marked &quot;stale&quot; if it has been changed since the last run with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">第一次使用 &lt;code&gt;--stale&lt;/code&gt; 运行此任务时，将运行所有测试并生成清单。在随后的运行中，如果自上次运行以来用 &lt;code&gt;--stale&lt;/code&gt; 修改了测试文件引用的模块（以及这些模块递归引用的模块），则该文件将被标记为&amp;ldquo;陈旧&amp;rdquo; 。如果自从上次运行 &lt;code&gt;--stale&lt;/code&gt; 以来已对其进行了更改，则测试文件也将标记为&amp;ldquo; stale&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="295fb12141f4c89eb596a5dac17f4949547acbec" translate="yes" xml:space="preserve">
          <source>The following attributes are part of typespecs and are also built-in in Elixir:</source>
          <target state="translated">以下属性是typepecs的一部分,也是Elixir内置的。</target>
        </trans-unit>
        <trans-unit id="7ddb17433dfdb141914290560e8f56274113cff7" translate="yes" xml:space="preserve">
          <source>The following behaviour applies if &lt;code&gt;reason&lt;/code&gt; is any term except &lt;code&gt;:normal&lt;/code&gt; or &lt;code&gt;:kill&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是除 &lt;code&gt;:normal&lt;/code&gt; 或 &lt;code&gt;:kill&lt;/code&gt; 以外的任何术语，则以下行为适用：</target>
        </trans-unit>
        <trans-unit id="7cc6a385de289ddbe867800f5a4d45eaf506d87a" translate="yes" xml:space="preserve">
          <source>The following code is clearer:</source>
          <target state="translated">下面的代码更清晰。</target>
        </trans-unit>
        <trans-unit id="ab6fa07c7c4a4b08ed5ab5840982521232d9dc60" translate="yes" xml:space="preserve">
          <source>The following configuration applies to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;'s wrapper around Erlang's logging functionalities. All the configurations below must be set before the &lt;code&gt;:logger&lt;/code&gt; application starts.</source>
          <target state="translated">以下配置适用于围绕Erlang的日志记录功能的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;的包装器。 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前，必须先设置以下所有配置。</target>
        </trans-unit>
        <trans-unit id="2b59ddac9c85343e9c0315f555148e29de15b834" translate="yes" xml:space="preserve">
          <source>The following configuration must be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">在 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前，必须通过配置文件（例如 &lt;code&gt;config/config.exs&lt;/code&gt; ）设置以下配置。</target>
        </trans-unit>
        <trans-unit id="7468ef5075d9f1bb00ad4478b84201c0051a39d2" translate="yes" xml:space="preserve">
          <source>The following configurations apply only for Erlang/OTP 20 and earlier:</source>
          <target state="translated">以下配置仅适用于Erlang/OTP 20及以前的版本。</target>
        </trans-unit>
        <trans-unit id="5bee2fb68242ae2a980fb37c51c72ff07363e60a" translate="yes" xml:space="preserve">
          <source>The following contents are expanded:</source>
          <target state="translated">以下内容为展开。</target>
        </trans-unit>
        <trans-unit id="184db633c0e9a1d1d50d51efc796a68bbb36b312" translate="yes" xml:space="preserve">
          <source>The following document has 10 bytes and therefore it does not format to width 9 without breaks:</source>
          <target state="translated">下面的文档有10个字节,因此它的格式不符合宽度9,没有分格。</target>
        </trans-unit>
        <trans-unit id="de1fd9b941b49b602c0ebc3107ff23bc87d50045" translate="yes" xml:space="preserve">
          <source>The following escape codes can be used in strings and char lists:</source>
          <target state="translated">下列转义码可以用于字符串和字符列表中。</target>
        </trans-unit>
        <trans-unit id="d46d9ba3da9322ecdf037e20b892895d0db04656" translate="yes" xml:space="preserve">
          <source>The following fields are available:</source>
          <target state="translated">以下是可用的领域:</target>
        </trans-unit>
        <trans-unit id="7293829d505cc3a0054aa1a59ac73bad4f509dae" translate="yes" xml:space="preserve">
          <source>The following fields are deprecated and must not be accessed or relied on:</source>
          <target state="translated">以下字段已被废弃,不得访问或依赖。</target>
        </trans-unit>
        <trans-unit id="30c2e9695ce3105ad651330d3b52e46b3a324658" translate="yes" xml:space="preserve">
          <source>The following fields are public:</source>
          <target state="translated">以下领域是公开的。</target>
        </trans-unit>
        <trans-unit id="ecaaab8e8eae9b4df4d22551bafa8feaa1ec9420" translate="yes" xml:space="preserve">
          <source>The following fields pertain to variable handling and must not be accessed or relied on. To get a list of all variables, see &lt;a href=&quot;#vars/1&quot;&gt;&lt;code&gt;vars/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">以下字段与变量处理有关，并且不能被访问或依赖。要获取所有变量的列表，请参见&lt;a href=&quot;#vars/1&quot;&gt; &lt;code&gt;vars/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e8fcb5815c5a0952c38de454edd61e7d1f142d6d" translate="yes" xml:space="preserve">
          <source>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</source>
          <target state="translated">以下是Elixir能够解析的所有运算符的列表,按优先级从高到低排序,同时还列出了它们的关联性。</target>
        </trans-unit>
        <trans-unit id="9104e819567333a6da0e8ce2dab5b947458c30fd" translate="yes" xml:space="preserve">
          <source>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</source>
          <target state="translated">下表列出了Elixir能够解析的所有运算符,但默认情况下没有使用。</target>
        </trans-unit>
        <trans-unit id="0ba751c3adfd8a7fc2856a1dbf3e62fbc4ec76f2" translate="yes" xml:space="preserve">
          <source>The following keys are optional:</source>
          <target state="translated">以下是可选的键:</target>
        </trans-unit>
        <trans-unit id="7b884b576e7fc0feccc202abb8a4a3d2fbce2d97" translate="yes" xml:space="preserve">
          <source>The following keys are returned:</source>
          <target state="translated">返回以下键:</target>
        </trans-unit>
        <trans-unit id="bf2cdc4ebfa3f4a0590ef2625ba82e196ae8c2a8" translate="yes" xml:space="preserve">
          <source>The following literals are also supported in typespecs:</source>
          <target state="translated">typepecs中还支持以下字元。</target>
        </trans-unit>
        <trans-unit id="b914b4fb7bd70067053e9e95983328f16ab1fd00" translate="yes" xml:space="preserve">
          <source>The following macros are generated:</source>
          <target state="translated">生成以下宏:</target>
        </trans-unit>
        <trans-unit id="d3a2d7253e70d0b7ab68844ea930f5d415637299" translate="yes" xml:space="preserve">
          <source>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</source>
          <target state="translated">以下模块建立在进程之上,提供并发、容错等功能。</target>
        </trans-unit>
        <trans-unit id="b4f887b33e0c44ae6b51e81b5ab7bc56ab3d3fc4" translate="yes" xml:space="preserve">
          <source>The following modules handle Elixir built-in data types:</source>
          <target state="translated">以下模块处理Elixir内置数据类型。</target>
        </trans-unit>
        <trans-unit id="16b7215fb9d992fc605683d883c23ca3932275a5" translate="yes" xml:space="preserve">
          <source>The following names are reserved and cannot be assigned to processes nor ports:</source>
          <target state="translated">以下名称是保留的,不能分配给进程或端口。</target>
        </trans-unit>
        <trans-unit id="5b3878c8ab3dccd7e89f167b65de39bd2f92844f" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">导入时，&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块使用以下运算符：&lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bitwise#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="77f3895c41618839ee5e26a20028be3be4ec2b1d" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">必须在您的 &lt;code&gt;mix.exs&lt;/code&gt; 中的 &lt;code&gt;:escript&lt;/code&gt; 键下指定以下选项：</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">接受以下选项:</target>
        </trans-unit>
        <trans-unit id="3ab6a9f1a0bbaef19cacfbc5c31136467bf2e22d" translate="yes" xml:space="preserve">
          <source>The following options are supported:</source>
          <target state="translated">支持以下选项:</target>
        </trans-unit>
        <trans-unit id="a63388a7d9c69cb081c0bd25c0b348227ea8b98e" translate="yes" xml:space="preserve">
          <source>The following restart values are supported in the &lt;code&gt;:restart&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; 选项支持以下重启值：</target>
        </trans-unit>
        <trans-unit id="e3bfac8b769dcde18c31230db7c8155e1610b73f" translate="yes" xml:space="preserve">
          <source>The following sets up a breakpoint on &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">下面在&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt;上设置一个断点：</target>
        </trans-unit>
        <trans-unit id="af7f88d381759e98fbd8a59a2974fdc1427bfa5a" translate="yes" xml:space="preserve">
          <source>The following shutdown values are supported in the &lt;code&gt;:shutdown&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 选项支持以下关闭值：</target>
        </trans-unit>
        <trans-unit id="62c95490240e6721731c2a4166fbf474d701eaa5" translate="yes" xml:space="preserve">
          <source>The following switches take one argument:</source>
          <target state="translated">以下开关只需要一个参数。</target>
        </trans-unit>
        <trans-unit id="09182b59468032ac91eb3e19cfac73cd63919777" translate="yes" xml:space="preserve">
          <source>The following switches types take no arguments:</source>
          <target state="translated">以下开关类型不接受参数。</target>
        </trans-unit>
        <trans-unit id="656560aa5a4b69ea097162499366d646d82b57a2" translate="yes" xml:space="preserve">
          <source>The following tags are set automatically by ExUnit and are therefore reserved:</source>
          <target state="translated">以下标签由ExUnit自动设置,因此保留。</target>
        </trans-unit>
        <trans-unit id="5fc9716a622a264a8eff71eefa013048286d3378" translate="yes" xml:space="preserve">
          <source>The following tags customize how tests behave:</source>
          <target state="translated">以下标签可以自定义测试的行为方式。</target>
        </trans-unit>
        <trans-unit id="f3f1a1a3a62e3160fd586f6ee95d4fab3af95423" translate="yes" xml:space="preserve">
          <source>The following tasks are automatically reenabled: &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.do&quot;&gt;&lt;code&gt;mix do&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt;&lt;code&gt;mix loadconfig&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;mix profile.cprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt;&lt;code&gt;mix profile.eprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将自动重新启用以下任务：&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.do&quot;&gt; &lt;code&gt;mix do&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.loadconfig&quot;&gt; &lt;code&gt;mix loadconfig&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;mix profile.cprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt; &lt;code&gt;mix profile.eprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;mix profile.fprof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94b02fa4807601cf95b13d7bfacf63de52daec08" translate="yes" xml:space="preserve">
          <source>The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.</source>
          <target state="translated">除了上述的基本类型和文字类型外,Elixir还提供了以下类型作为快捷方式。</target>
        </trans-unit>
        <trans-unit id="23128f3afb79fe9776e7ccf884ae9b5f280de2c5" translate="yes" xml:space="preserve">
          <source>The following values in the prompt string will be replaced appropriately:</source>
          <target state="translated">提示字符串中的以下值将被适当替换。</target>
        </trans-unit>
        <trans-unit id="bd9e27e386ddec7a2956d45d1104ee9dcf8cf427" translate="yes" xml:space="preserve">
          <source>The following will answer with &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; to the prompt &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt;:</source>
          <target state="translated">下面将以 &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; 回答提示 &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc2e84198cf648d67efe0dc56f0a0d3f7a6c41f5" translate="yes" xml:space="preserve">
          <source>The formatter also extracts all trailing comments to their previous line. For example, the code below</source>
          <target state="translated">格式化器还将所有的尾部注释提取到它们的前一行。例如,下面的代码</target>
        </trans-unit>
        <trans-unit id="f2dbb773aae103d1ac648bef9a245406adea93a6" translate="yes" xml:space="preserve">
          <source>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</source>
          <target state="translated">格式化器处理代码注释的方式也保证了在注释的开头(#)和下一个字符之间总是添加一个空格。</target>
        </trans-unit>
        <trans-unit id="174a1bba642104242141e782016509d0a3307dd9" translate="yes" xml:space="preserve">
          <source>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</source>
          <target state="translated">格式化器试图在单行上尽可能地适应,并在不能适应时尽可能地引入换行符。</target>
        </trans-unit>
        <trans-unit id="db2d1c69ac2af0675a9fbaa3dbf3bb62be0f48e5" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, etc. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">格式化程序不硬编码名称。格式化程序不会表现出特殊的行为，因为一个函数名为 &lt;code&gt;defmodule&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; 等。该原理反映了Elixir的目标，即成为一种可扩展的语言，开发人员可以在其中使用新的结构来扩展该语言，就像它们是该语言的一部分一样。如果绝对有必要根据名称更改行为，则此行​​为应该是可配置的，例如 &lt;code&gt;:locals_without_parens&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="03003fdc11feaf71c728ace4a4e8175ee7b4844f" translate="yes" xml:space="preserve">
          <source>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</source>
          <target state="translated">格式化器接收一个代表Elixir代码的字符串,并根据预先定义的规则返回代表格式化代码的碘数据。</target>
        </trans-unit>
        <trans-unit id="72e5baea79c2662552fd592f7668202474a199d4" translate="yes" xml:space="preserve">
          <source>The formatter respects the input format in some cases. Those are listed below:</source>
          <target state="translated">格式化器在某些情况下会尊重输入格式。下面列出了这些情况。</target>
        </trans-unit>
        <trans-unit id="73147abbfb07a1782272353b129dfe6ae2759140" translate="yes" xml:space="preserve">
          <source>The formatter was designed under three principles.</source>
          <target state="translated">该表格是根据三个原则设计的。</target>
        </trans-unit>
        <trans-unit id="54861fc5081e64334a71df9d50b523e9ef441995" translate="yes" xml:space="preserve">
          <source>The formatter wraps the algebra document representing the map in &lt;a href=&quot;#next_break_fits/1&quot;&gt;&lt;code&gt;next_break_fits/1&lt;/code&gt;&lt;/a&gt; so the code is formatted as:</source>
          <target state="translated">格式化程序将代表地图的代数文档包装在&lt;a href=&quot;#next_break_fits/1&quot;&gt; &lt;code&gt;next_break_fits/1&lt;/code&gt; 中,&lt;/a&gt;因此代码的格式为：</target>
        </trans-unit>
        <trans-unit id="619bfcd8852612a615d36e293bdf93e9442a2fd9" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;mix.project&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Mix的基础是一个项目。可以通过在模块中使用&lt;a href=&quot;mix.project&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;来定义项目，通常将其放置在名为 &lt;code&gt;mix.exs&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="27f8279b8cd5628c38c64722e539ac026a11da8b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="translated">函数&lt;a href=&quot;#put_env/3&quot;&gt; &lt;code&gt;put_env/3&lt;/code&gt; &lt;/a&gt;允许动态配置应用程序环境，但是根据经验，每个应用程序都应对自己的环境负责。请不要使用该模块中的功能直接访问或修改其他应用程序的环境。</target>
        </trans-unit>
        <trans-unit id="44dd7e8c0883ba7364643058445d069f16c2e43c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#struct!/2&quot;&gt;&lt;code&gt;struct!/2&lt;/code&gt;&lt;/a&gt; emulates the compile time behaviour of structs. This means that:</source>
          <target state="translated">函数&lt;a href=&quot;#struct!/2&quot;&gt; &lt;code&gt;struct!/2&lt;/code&gt; &lt;/a&gt;模拟结构的编译时行为。这意味着：</target>
        </trans-unit>
        <trans-unit id="8e0639c36ddd40dd4d3c1545de8b7ff6af66a1a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。该函数必须返回一个包含两个元素的元组，第一个是要返回的值（即&amp;ldquo; get&amp;rdquo;值），第二个是代理的新状态。</target>
        </trans-unit>
        <trans-unit id="216982854731717320607d5aa3e2c69ffa39cfa0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The result of the function invocation is returned from this function.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。从该函数返回函数调用的结果。</target>
        </trans-unit>
        <trans-unit id="fc7b0ec15b4d375100169c807030b178d76cb224" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The return value of &lt;code&gt;fun&lt;/code&gt; becomes the new state of the agent.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 被发送到 &lt;code&gt;agent&lt;/code&gt; ，该代理调用传递通过代理状态的功能。 &lt;code&gt;fun&lt;/code&gt; 的返回值成为代理的新状态。</target>
        </trans-unit>
        <trans-unit id="cad7f93891da662dbbaf24dfbad6e47a904e9038" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term which is used to determine if two elements are duplicates.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 函数将每个元素映射到一个术语，该术语用于确定两个元素是否重复。</target>
        </trans-unit>
        <trans-unit id="2063958f17451467d712f93ea552d845434a5f7b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term. Two elements are considered duplicates if the return value of &lt;code&gt;fun&lt;/code&gt; is equal for both of them.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 函数将每个元素映射到一个术语。如果 &lt;code&gt;fun&lt;/code&gt; 的返回值相等，则两个元素都视为重复。</target>
        </trans-unit>
        <trans-unit id="786bdba792da55f0fb2aae425ae917dfa7672afd" translate="yes" xml:space="preserve">
          <source>The function must receive the exit status code as an argument.</source>
          <target state="translated">该函数必须接收退出状态码作为参数。</target>
        </trans-unit>
        <trans-unit id="a56026b8a6cb0f0aeff01c85c9ee7342a99db076" translate="yes" xml:space="preserve">
          <source>The function must return:</source>
          <target state="translated">该函数必须返回。</target>
        </trans-unit>
        <trans-unit id="78c45238f9f6bc55b2be81844c73ef2dab477691" translate="yes" xml:space="preserve">
          <source>The function receives the arguments and passes them to &lt;code&gt;if&lt;/code&gt;. However, as we learned in the &lt;a href=&quot;quote-and-unquote&quot;&gt;previous chapter&lt;/a&gt;, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</source>
          <target state="translated">该函数接收参数并将其传递给 &lt;code&gt;if&lt;/code&gt; 。但是，正如我们在&lt;a href=&quot;quote-and-unquote&quot;&gt;上一章&lt;/a&gt;中学到的那样，宏将接收带引号的表达式，将它们注入引号中，最后返回另一个带引号的表达式。</target>
        </trans-unit>
        <trans-unit id="970e1abe8c2a97edfeb1747215a9aaebefbaf05f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;:ok&lt;/code&gt; in case of success. Otherwise, it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果成功，该函数将返回 &lt;code&gt;:ok&lt;/code&gt; 。否则，它返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42211e9c17fc840b6d18e986bbdd31d79b28999c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; in case of success, &lt;code&gt;files_and_directories&lt;/code&gt; lists all files and directories copied in no specific order. It returns &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，该函数将返回 &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; ， &lt;code&gt;files_and_directories&lt;/code&gt; 列出所有未按特定顺序复制的文件和目录。否则返回 &lt;code&gt;{:error, reason, file}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b12965a38c8943a04c360761ab1a75653a316455" translate="yes" xml:space="preserve">
          <source>The function should return a non empty list where the amount of elements is equal to &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">函数应该返回一个非空列表，其中元素的数量等于 &lt;code&gt;length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="370959ce1313e0ee1574bb7b4f639ad8e764cdd3" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;fun&lt;/code&gt;, receives two arguments: the first one is the element, and the second one is the accumulator. &lt;code&gt;fun&lt;/code&gt; must return a tuple with two elements in the form of &lt;code&gt;{result, accumulator}&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;fun&lt;/code&gt; 接收两个参数：第一个是元素，第二个是累加器。 &lt;code&gt;fun&lt;/code&gt; 必须以 &lt;code&gt;{result, accumulator}&lt;/code&gt; 的形式返回具有两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="b5956f11dd1602a7d0b839eecd3ea612fa5aace7" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#nest/2&quot;&gt;&lt;code&gt;nest/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#space/2&quot;&gt;&lt;code&gt;space/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#line/2&quot;&gt;&lt;code&gt;line/2&lt;/code&gt;&lt;/a&gt; help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like &lt;a href=&quot;#glue/3&quot;&gt;&lt;code&gt;glue/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#group/1&quot;&gt;&lt;code&gt;group/1&lt;/code&gt;&lt;/a&gt;. A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it:</source>
          <target state="translated">函数&lt;a href=&quot;#nest/2&quot;&gt; &lt;code&gt;nest/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#space/2&quot;&gt; &lt;code&gt;space/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#line/2&quot;&gt; &lt;code&gt;line/2&lt;/code&gt; 可以&lt;/a&gt;帮助您将文档放在一起成为一个刚性结构。但是，当使用诸如&lt;a href=&quot;#glue/3&quot;&gt; &lt;code&gt;glue/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#group/1&quot;&gt; &lt;code&gt;group/1&lt;/code&gt; &lt;/a&gt;类的功能时，文档代数变得很有趣。胶水在两个文档之间插入一个中断。组表示必须适合当前行的文档，否则，中断将显示为新行。让我们将两个文档粘合在一起，然后将其分组，然后进行渲染：</target>
        </trans-unit>
        <trans-unit id="c253790d407e18b7d5f0c9bb8af92800693543dd" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; can be applied too, especially when ordering is required.</source>
          <target state="translated">订购时，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;的功能不保证任何属性。但是，由于关键字列表只是一个列表，因此也可以应用&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; 中&lt;/a&gt;定义的所有操作，尤其是在需要排序时。</target>
        </trans-unit>
        <trans-unit id="fc395b4f1565e86a3f414d5f43f358ea3ab4b968" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;File&lt;/code&gt; also allow lists to be given as arguments. Not only that, they also allow a mixed list of lists, integers, and binaries to be given:</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 和 &lt;code&gt;File&lt;/code&gt; 中的功能还允许将列表作为参数给出。不仅如此，它们还允许提供列表，整数和二进制文件的混合列表：</target>
        </trans-unit>
        <trans-unit id="c24702aeda4cc39358f5c9073ad6385b684128ba" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;ets&lt;/code&gt; module will modify the state of the table as a side-effect.</source>
          <target state="translated">&lt;code&gt;ets&lt;/code&gt; 模块中的功能将修改表的状态，从而产生副作用。</target>
        </trans-unit>
        <trans-unit id="645c924b3f04d5643fc9c0295858b7ef02f4fe7d" translate="yes" xml:space="preserve">
          <source>The functions in the Enum module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the &lt;code&gt;List.insert_at/3&lt;/code&gt; function from &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;the &lt;code&gt;List&lt;/code&gt; module&lt;/a&gt;, as it would make little sense to insert a value into, for example, a range.</source>
          <target state="translated">顾名思义，Enum模块中的功能仅限于枚举数据结构中的值。对于特定的操作，例如插入和更新特定的元素，可能需要访问特定于数据类型的模块。例如，如果要在列表中的给定位置插入元素，则应使用&lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&amp;ldquo; &lt;/a&gt; &lt;code&gt;List&lt;/code&gt; 模块中的 &lt;code&gt;List.insert_at/3&lt;/code&gt; 函数，因为将值插入例如范围内几乎没有意义。 。</target>
        </trans-unit>
        <trans-unit id="77cce334a46132ba295a248960c6d018c960a8aa" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 11.0.0.</source>
          <target state="translated">该模块的功能根据Unicode标准11.0.0版本执行。</target>
        </trans-unit>
        <trans-unit id="173416c87fd5ec34f77cd8d34322b0332ac7cfcb" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">该模块中的功能已被弃用，并且无法与Elixir v1.5中引入的基于模块的子规范一起使用。请改为查看&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="96e74349f320a8c58dc1c59108496ee930024bf1" translate="yes" xml:space="preserve">
          <source>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</source>
          <target state="translated">本模块中的函数可以接收一个chardata作为参数(即一个字符串或字符列表/字符串),并将始终返回一个字符串(以UTF-8编码)。</target>
        </trans-unit>
        <trans-unit id="b429b5ce2f9a2392aff46c5515cf68d49d6d6adf" translate="yes" xml:space="preserve">
          <source>The functions in this module support chardata, so giving a list will treat it as a single entity:</source>
          <target state="translated">本模块中的函数支持chardata,所以给出一个列表会将其视为一个单一实体。</target>
        </trans-unit>
        <trans-unit id="255d1a73d20d6ce6127802c33ec8ce540df5e39c" translate="yes" xml:space="preserve">
          <source>The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:</source>
          <target state="translated">本模块中从元组中添加和删除元素的函数在实践中很少使用,因为它们通常意味着元组被当作集合使用。要对一个元组进行追加,最好是用模式匹配从旧元组中提取元素,然后创建一个新的元组。</target>
        </trans-unit>
        <trans-unit id="33b30755a342f20f218b83071cf71f52c8757557" translate="yes" xml:space="preserve">
          <source>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as &lt;a href=&quot;#keys/1&quot;&gt;&lt;code&gt;keys/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values/1&quot;&gt;&lt;code&gt;values/1&lt;/code&gt;&lt;/a&gt;, run in linear time because they need to get to every element in the map.</source>
          <target state="translated">该模块中需要在对数时间内查找特定键的功能。这意味着查找键所花费的时间随着地图的增长而增长，但并不与地图的大小成正比。与在列表中查找元素相比，它的性能更好，因为列表具有线性时间复杂度。一些功能（例如&lt;a href=&quot;#keys/1&quot;&gt; &lt;code&gt;keys/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#values/1&quot;&gt; &lt;code&gt;values/1&lt;/code&gt; )&lt;/a&gt;在线性时间内运行，因为它们需要访问映射中的每个元素。</target>
        </trans-unit>
        <trans-unit id="9f0853ffd0b6dd95f29653e4a1c1ad06e52385c2" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">该模块中的功能以线性时间工作。这意味着执行操作所需的时间以与可枚举的长度相同的速度增长。这在诸如&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; 之类的&lt;/a&gt;操作中是预期的。毕竟，如果我们要遍历列表中的每个元素，则列表越长，我们需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="709dd48512a8ffdaa9639efcdf5626b90390736d" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此模块上的函数可与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构以及包含与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构相同字段的任何结构一起使用，例如&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;calendar#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd7fe8f3288c5b63dba38948e86e695e4e2b2557" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此模块上的函数与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构以及任何包含与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;结构相同字段的结构一起使用，例如&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。此类函数的类型规范中应使用&lt;a href=&quot;calendar#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt;（而不是&lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="003b5d0dd560d869b45725f5251941da4e2978b9" translate="yes" xml:space="preserve">
          <source>The general Elixir identifier rule is specified as:</source>
          <target state="translated">Elixir标识符的一般规则规定如下:</target>
        </trans-unit>
        <trans-unit id="279b2d1d6d51ad298e11acb6402db1bbf4467c85" translate="yes" xml:space="preserve">
          <source>The generated files are similar to the ones we first generated for &lt;code&gt;kv&lt;/code&gt;, with a few differences. Let&amp;rsquo;s open up &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">生成的文件与我们最初为 &lt;code&gt;kv&lt;/code&gt; 生成的文件相似，但有一些区别。让我们打开 &lt;code&gt;mix.exs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe11b786cb48918f9b05dccc30b89f3c9d182f54" translate="yes" xml:space="preserve">
          <source>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</source>
          <target state="translated">生成的宏也可以用来对记录进行模式匹配,并在匹配过程中绑定变量。</target>
        </trans-unit>
        <trans-unit id="50f5c0fcf4c39bd1e0e3ce49d94a449eccf8a5ee" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;datetime_string&lt;/code&gt; must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised.</source>
          <target state="translated">给定的 &lt;code&gt;datetime_string&lt;/code&gt; 必须包含&amp;ldquo; Z&amp;rdquo;或&amp;ldquo; 00:00&amp;rdquo;偏移量（将其标记为UTC），否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="5945d8ce9d0ed7b935712680470e46feacdd1644" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;fun&lt;/code&gt; is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</source>
          <target state="translated">对于AST中的每个节点，将使用两个参数调用给定的 &lt;code&gt;fun&lt;/code&gt; ：正在打印的节点的AST和该节点的字符串表示形式。此函数的返回值用作该AST节点的最终字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="a83da51956cb3348840e43e856af798fc100e9ea" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing configuration for the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">给定的 &lt;code&gt;opts&lt;/code&gt; 合并到给定 &lt;code&gt;root_key&lt;/code&gt; 的现有配置中。冲突键被 &lt;code&gt;opts&lt;/code&gt; 中指定的键覆盖。例如，下面的应用程序配置</target>
        </trans-unit>
        <trans-unit id="b05f234517d759a8cb3f7b2d59dc801482a98965" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing values for &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">给定的 &lt;code&gt;opts&lt;/code&gt; 合并到给定的 &lt;code&gt;root_key&lt;/code&gt; 中 &lt;code&gt;key&lt;/code&gt; 的现有值中。冲突键被 &lt;code&gt;opts&lt;/code&gt; 中指定的键覆盖。例如，下面的应用程序配置</target>
        </trans-unit>
        <trans-unit id="02ef5a607d49adbb7866b57f819df6b77fdbb345" translate="yes" xml:space="preserve">
          <source>The given config should not:</source>
          <target state="translated">给定的配置不应。</target>
        </trans-unit>
        <trans-unit id="44e635edac5e4e08e828b82a2eaab3164491a4b7" translate="yes" xml:space="preserve">
          <source>The given datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的日期时间的精度已经低于给定的精度,则不变返回。</target>
        </trans-unit>
        <trans-unit id="6d2a43a0c7f321f6321fd1b9eb5b43b059a8e70b" translate="yes" xml:space="preserve">
          <source>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的天真日期时间的精度已经低于给定的精度,则不变返回。</target>
        </trans-unit>
        <trans-unit id="c8ff7c40025099fed2b47a6ca6bd7d1bee58abb9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">给定的选项可以是与表示赋予相同的正则表达式的选项中的字符的二进制 &lt;code&gt;~r&lt;/code&gt; （见&lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt;）印记，或选项的列表，由Erlang的预期 &lt;code&gt;:re&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="8ee391432291b1d23474c64748cd369ce3de6c17" translate="yes" xml:space="preserve">
          <source>The given time is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">如果给定的时间已经比给定的精度低,则不变返回。</target>
        </trans-unit>
        <trans-unit id="595ea9127c2b29264915dada8a0a74f247f402db" translate="yes" xml:space="preserve">
          <source>The goal in this chapter is to build a module named &lt;code&gt;TestCase&lt;/code&gt; that allows us to write the following:</source>
          <target state="translated">本章的目标是构建一个名为 &lt;code&gt;TestCase&lt;/code&gt; 的模块，该模块使我们可以编写以下内容：</target>
        </trans-unit>
        <trans-unit id="005035c0ac9ba5b2d03b96ccf393ae5ff11ffe11" translate="yes" xml:space="preserve">
          <source>The goal of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的目标是为开发人员抽象&amp;ldquo;接收&amp;rdquo;循环，自动处理系统消息，支持代码更改，同步调用等。因此，永远不要在GenServer回调中调用自己的&amp;ldquo;接收&amp;rdquo;，因为这样做会导致GenServer行为异常。</target>
        </trans-unit>
        <trans-unit id="1a6d568374392c51e27178f8aac8e2da82bbf64d" translate="yes" xml:space="preserve">
          <source>The good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project&amp;rsquo;s &lt;code&gt;apps/&lt;/code&gt; directory. In the worst case scenario, you can discard the umbrella project and all related configuration (&lt;code&gt;build_path&lt;/code&gt;, &lt;code&gt;config_path&lt;/code&gt;, &lt;code&gt;deps_path&lt;/code&gt; and &lt;code&gt;lockfile&lt;/code&gt;) and still leverage the &amp;ldquo;mono-repo&amp;rdquo; pattern by keeping all applications together in the same repository. Each application will have its own dependencies and configuration. Dependencies between those applications can still be explicitly listed by using the &lt;code&gt;:path&lt;/code&gt; option (in contrast to &lt;code&gt;:git&lt;/code&gt;).</source>
          <target state="translated">好消息是，将伞分解很容易，因为您只需要将应用程序移到伞项目的 &lt;code&gt;apps/&lt;/code&gt; 目录之外。在最坏的情况下，你可以放弃伞项目和所有相关配置（ &lt;code&gt;build_path&lt;/code&gt; ， &lt;code&gt;config_path&lt;/code&gt; ， &lt;code&gt;deps_path&lt;/code&gt; 和 &lt;code&gt;lockfile&lt;/code&gt; ），并且仍然在同一个版本库保存所有的应用程序一起充分利用&amp;ldquo;单回购&amp;rdquo;的格局。每个应用程序将具有自己的依赖性和配置。仍然可以使用 &lt;code&gt;:path&lt;/code&gt; 选项显式列出这些应用程序之间的依赖关系（与 &lt;code&gt;:git&lt;/code&gt; 相反）。</target>
        </trans-unit>
        <trans-unit id="18abb99c49c0cd9f625ee8db0e020cadbbd4d636" translate="yes" xml:space="preserve">
          <source>The greatest common divisor (GCD) of &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; is the largest positive integer that divides both &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; without leaving a remainder.</source>
          <target state="translated">的最大公约数（GCD） &lt;code&gt;integer1&lt;/code&gt; 和 &lt;code&gt;integer2&lt;/code&gt; 是最大的正整数整除 &lt;code&gt;integer1&lt;/code&gt; 和 &lt;code&gt;integer2&lt;/code&gt; ，不留余数。</target>
        </trans-unit>
        <trans-unit id="04a15f34a10083efdd1b4c7fb23d6409a2799f7b" translate="yes" xml:space="preserve">
          <source>The group mode can also be set to &lt;code&gt;:inherit&lt;/code&gt;, which means it automatically breaks if the parent group has broken too.</source>
          <target state="translated">组模式也可以设置为 &lt;code&gt;:inherit&lt;/code&gt; ，这意味着如果父组也断开，它会自动断开。</target>
        </trans-unit>
        <trans-unit id="abae706b2e9875a2d4fe24ac37232c3285b58047" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won't be available by the time the handler function is invoked.</source>
          <target state="translated">处理程序总是在与其注册的进程不同的进程中执行。因此,在调用处理函数时,由调用进程管理的任何资源(ETS表、打开的文件等)都将不可用。</target>
        </trans-unit>
        <trans-unit id="91dc0be92537f81da316aa8d3834b6a0c2b63c02" translate="yes" xml:space="preserve">
          <source>The head element of aliases can be any term that must expand to an atom at compilation time.</source>
          <target state="translated">别名的头部元素可以是任何必须在编译时扩展为原子的术语。</target>
        </trans-unit>
        <trans-unit id="b5f5e37ee6e6bb7829dd572b3c957edcc2f9784b" translate="yes" xml:space="preserve">
          <source>The implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a &lt;code&gt;PID&lt;/code&gt; or an &lt;code&gt;Integer&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">上面的实现可以说是不合理的。例如，说 &lt;code&gt;PID&lt;/code&gt; 或 &lt;code&gt;Integer&lt;/code&gt; 的大小为 &lt;code&gt;0&lt;/code&gt; 毫无意义。</target>
        </trans-unit>
        <trans-unit id="1a82e7d1f4f1afb4f634e8bc16b67baab165570d" translate="yes" xml:space="preserve">
          <source>The implementation is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;reservoir sampling&lt;/a&gt; algorithm. It assumes that the sample being returned can fit into memory; the input &lt;code&gt;enumerable&lt;/code&gt; doesn't have to, as it is traversed just once.</source>
          <target state="translated">该实现基于&lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;储层采样&lt;/a&gt;算法。假设返回的样本可以放入内存； &lt;code&gt;enumerable&lt;/code&gt; 输入不必遍历，因为它只需遍历一次。</target>
        </trans-unit>
        <trans-unit id="8b8d2b9e0c9b1879d05717152c53da40bcc3437b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; is based on the Strictly Pretty paper by &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines).</source>
          <target state="translated">实施&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt;是基于严格的漂亮的纸&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt;它建立在以前的漂亮印花算法顶部，而是针对严格的语言，如药剂。本文的核心思想是使用显式文档组，这些文档组呈现为平面（以空格分隔）或以中断（以换行符分隔）。</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">这个回调的实现应该调用 &lt;code&gt;fun&lt;/code&gt; 与下的价值 &lt;code&gt;key&lt;/code&gt; 在通过结构 &lt;code&gt;data&lt;/code&gt; ，或 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 是不存在的。此函数必须返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 或 &lt;code&gt;:pop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="791ef5c45db6655a2b8e0d52e101cc594625c78d" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">初始后端是通过 &lt;code&gt;:backends&lt;/code&gt; 配置加载的，该配置必须在 &lt;code&gt;:logger&lt;/code&gt; 应用程序启动之前进行设置。</target>
        </trans-unit>
        <trans-unit id="e5d99b4bc070e331607e6d5df8659a98abe40c48" translate="yes" xml:space="preserve">
          <source>The initial value of the accumulator is &lt;code&gt;acc&lt;/code&gt;. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</source>
          <target state="translated">累加器的初始值为 &lt;code&gt;acc&lt;/code&gt; 。使用累加器为可枚举的每个元素调用该函数。函数返回的结果用作下一次迭代的累加器。该函数返回最后一个累加器。</target>
        </trans-unit>
        <trans-unit id="a3d8510abacaf7b1519659fdcdb00b6e366da892" translate="yes" xml:space="preserve">
          <source>The initialization arguments, in this case the atom &lt;code&gt;:ok&lt;/code&gt;</source>
          <target state="translated">初始化参数，在这种情况下，原子为 &lt;code&gt;:ok&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1ddbc45c619f8049cea4c440a4edb65fecbed96" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">整数可以根据&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;以不同单位给出，并且将在内部将其转换为微秒。</target>
        </trans-unit>
        <trans-unit id="c5f1e2568ac6af5c9527d828828602700a4893a4" translate="yes" xml:space="preserve">
          <source>The interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside &lt;code&gt;apps&lt;/code&gt; with a single command. However, even though they are all listed together inside &lt;code&gt;apps&lt;/code&gt;, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.</source>
          <target state="translated">这种方法的有趣的是，混合有许多便利与这样的项目，如编译和测试中的所有应用程序的能力工作 &lt;code&gt;apps&lt;/code&gt; 使用一个命令。但是，即使它们都在 &lt;code&gt;apps&lt;/code&gt; 一起列出，它们仍然彼此分离，因此您可以根据需要隔离地构建，测试和部署每个应用程序。</target>
        </trans-unit>
        <trans-unit id="ccef43e698ff7f77a039db9e5b5b3d002b852b8a" translate="yes" xml:space="preserve">
          <source>The internal date format that is used when converting between calendars.</source>
          <target state="translated">日历之间转换时使用的内部日期格式。</target>
        </trans-unit>
        <trans-unit id="5490fd4bbe326611a1d9b742e7e1f91649638437" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</source>
          <target state="translated">内部表示是不透明的,不能转换为外部术语格式,然后再转换回来,而不会失去其属性(意味着它不能被发送到另一个节点上的进程,仍然是一个有效的编译match_spec,也不能存储在磁盘上)。</target>
        </trans-unit>
        <trans-unit id="7334ee5b04d77d686d637a0f70cc9375ca49af7d" translate="yes" xml:space="preserve">
          <source>The internal time format is used when converting between calendars.</source>
          <target state="translated">日历之间转换时使用内部时间格式。</target>
        </trans-unit>
        <trans-unit id="1c746eb548e21139e2d2543ac649c03aeac54f5a" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;env&lt;/code&gt; of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application &lt;em&gt;environment&lt;/em&gt;. Note that this environment is unrelated to the operating system environment.</source>
          <target state="translated">应用程序资源文件的键 &lt;code&gt;env&lt;/code&gt; 具有将原子映射到项的元组列表，其内容称为应用程序&lt;em&gt;环境&lt;/em&gt;。请注意，此环境与操作系统环境无关。</target>
        </trans-unit>
        <trans-unit id="3409677dd18b558166751c16ef637b64275c9b00" translate="yes" xml:space="preserve">
          <source>The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys.</source>
          <target state="translated">地图中的键类型是允许重叠的,如果重叠,最左边的键优先。如果一个地图值包含的键不在允许的地图键中,则不属于这种类型。</target>
        </trans-unit>
        <trans-unit id="32d41944ca5b336f1b48c86344355078fd3da940" translate="yes" xml:space="preserve">
          <source>The keyword list used with &lt;code&gt;defstruct&lt;/code&gt; defines what fields the struct will have along with their default values.</source>
          <target state="translated">与 &lt;code&gt;defstruct&lt;/code&gt; 一起使用的关键字列表定义了该结构将具有哪些字段及其默认值。</target>
        </trans-unit>
        <trans-unit id="e67b4b10fb8bead468c4a33dc123a05fee573455" translate="yes" xml:space="preserve">
          <source>The kind (&lt;code&gt;:def&lt;/code&gt; or &lt;code&gt;:defp&lt;/code&gt;) must be given, the function name, its arguments and the compilation options.</source>
          <target state="translated">必须给出种类（ &lt;code&gt;:def&lt;/code&gt; 或 &lt;code&gt;:defp&lt;/code&gt; ），函数名称，其参数和编译选项。</target>
        </trans-unit>
        <trans-unit id="4db3abef2e6392ab0276950699e4f4e0f758b4c0" translate="yes" xml:space="preserve">
          <source>The kind handled by formatting functions</source>
          <target state="translated">由格式化函数处理的类型</target>
        </trans-unit>
        <trans-unit id="35b01fa192b09fbd575c96a38ea9c12c69135b18" translate="yes" xml:space="preserve">
          <source>The last step is to change the registry to use the dynamic supervisor:</source>
          <target state="translated">最后一步是更改注册表,使用动态主管。</target>
        </trans-unit>
        <trans-unit id="ec09c363bc1673984c9ef7c8fd26b487f2e86ec0" translate="yes" xml:space="preserve">
          <source>The last step is to implement &lt;code&gt;KVServer.Command.run/1&lt;/code&gt;, to run the parsed commands against the &lt;code&gt;:kv&lt;/code&gt; application. Its implementation is shown below:</source>
          <target state="translated">最后一步是实现 &lt;code&gt;KVServer.Command.run/1&lt;/code&gt; ，以对 &lt;code&gt;:kv&lt;/code&gt; 应用程序运行已解析的命令。其实现如下所示：</target>
        </trans-unit>
        <trans-unit id="1505f07b9a5dea491d06c3282407488da838a326" translate="yes" xml:space="preserve">
          <source>The last syntax convenience are &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks. &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example:</source>
          <target state="translated">最后一个语法方便是 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块。 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块等效于关键字，它是函数调用的最后一个参数，其中块内容用括号括起来。例如：</target>
        </trans-unit>
        <trans-unit id="bc0ec7829a3c5fbbae5ba7d71fb20b1484d4bd86" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.</source>
          <target state="translated">左至右箭头（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）的表示方式与运算符类似，不同之处在于它们始终是列表的一部分，其左侧表示参数列表，而右侧则是表达式。</target>
        </trans-unit>
        <trans-unit id="a6289423275f2a3ff2ff61d789c2121d3f39f1f8" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The &lt;code&gt;-&amp;gt;&lt;/code&gt; may appear one or more times between one of the following terminators: &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;. When &lt;code&gt;-&amp;gt;&lt;/code&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.</source>
          <target state="translated">左右箭头（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）用于建立左右之间的关系，通常称为子句。左侧可以有零个，一个或多个自变量；右侧为零，一个或多个用换行符分隔的表达式。的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 可能会出现以下的终止子的一个之间的一个或更多次： &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 或 &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; 。当使用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 时，这些终止符之间仅允许其他子句。混合子句和正则表达式是无效的语法。</target>
        </trans-unit>
        <trans-unit id="62dfa2cc28c3ba61b288f1d13e4cdc1ed0d38af0" translate="yes" xml:space="preserve">
          <source>The left-hand side supports any expression you would use on the left-hand side of a match:</source>
          <target state="translated">左侧支持任何你会在匹配的左侧使用的表达方式。</target>
        </trans-unit>
        <trans-unit id="452a67adaa49211fbae18840ab0e8f40710191cd" translate="yes" xml:space="preserve">
          <source>The length of the match is equal to the &lt;code&gt;unit&lt;/code&gt; (a number of bits) times the &lt;code&gt;size&lt;/code&gt; (the number of repeated segments of length &lt;code&gt;unit&lt;/code&gt;).</source>
          <target state="translated">匹配的长度等于 &lt;code&gt;unit&lt;/code&gt; （位数）乘以 &lt;code&gt;size&lt;/code&gt; （长度 &lt;code&gt;unit&lt;/code&gt; 的重复段数）。</target>
        </trans-unit>
        <trans-unit id="9b58150e587a8ab776f8c034fd8c13d895af6209" translate="yes" xml:space="preserve">
          <source>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below).</source>
          <target state="translated">并发水平和允许任务运行的时间可以通过选项来控制(见下面 &quot;选项 &quot;部分)。</target>
        </trans-unit>
        <trans-unit id="0f521fe02fee98ba137b8a2f629c9607b50efc70" translate="yes" xml:space="preserve">
          <source>The limit in the given &lt;code&gt;inspect_opts&lt;/code&gt; is respected and when reached this function stops processing and outputs &lt;code&gt;&quot;...&quot;&lt;/code&gt; instead.</source>
          <target state="translated">遵守给定 &lt;code&gt;inspect_opts&lt;/code&gt; 中的限制，当达到此功能时，该函数将停止处理并输出 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1945f9bf3a795845e8993a19f7a9dfe86f17eea" translate="yes" xml:space="preserve">
          <source>The line above makes &lt;code&gt;:kv&lt;/code&gt; available as a dependency inside &lt;code&gt;:kv_server&lt;/code&gt; and automatically starts the &lt;code&gt;:kv&lt;/code&gt; application before the server starts.</source>
          <target state="translated">上面的 &lt;code&gt;:kv_server&lt;/code&gt; &lt;code&gt;:kv&lt;/code&gt; 可以作为：kv_server内部的依赖项使用，并在服务器启动之前自动启动 &lt;code&gt;:kv&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="6f3150330fa7863de05e8e4f528741a7ca7bb476" translate="yes" xml:space="preserve">
          <source>The line where the module is defined and its file &lt;strong&gt;must&lt;/strong&gt; be passed as options.</source>
          <target state="translated">定义模块的行及其文件&lt;strong&gt;必须&lt;/strong&gt;作为选项传递。</target>
        </trans-unit>
        <trans-unit id="65e5d401ccb2b8279fcac802ea4250628d92a6f3" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;entries&lt;/code&gt; is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked.</source>
          <target state="translated">列表 &lt;code&gt;entries&lt;/code&gt; 是两个元素的元组的一个非空的列表，其中所述第一元件是所述PID和第二元件是关联到PID的值。如果没有给定键的条目，则永远不会调用该回调。</target>
        </trans-unit>
        <trans-unit id="d8d60e505b52f11e3ed1a46b8da9d55ffe759f2d" translate="yes" xml:space="preserve">
          <source>The list of callers of the current process can be retrieved from the Process dictionary with &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt;. This will return either &lt;code&gt;nil&lt;/code&gt; or a list &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; with at least one entry Where &lt;code&gt;pid_n&lt;/code&gt; is the PID that called the current process, &lt;code&gt;pid2&lt;/code&gt; called &lt;code&gt;pid_n&lt;/code&gt;, and &lt;code&gt;pid2&lt;/code&gt; was called by &lt;code&gt;pid1&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt; 从Process字典中检索当前进程的调用者列表。这将返回 &lt;code&gt;nil&lt;/code&gt; 或列表 &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; 哪里有至少一个条目 &lt;code&gt;pid_n&lt;/code&gt; 是调用当前过程中，PID &lt;code&gt;pid2&lt;/code&gt; 称为 &lt;code&gt;pid_n&lt;/code&gt; 和 &lt;code&gt;pid2&lt;/code&gt; 被称为 &lt;code&gt;pid1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ed6bd036ce9220742f24381556f3269068288d9" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;list#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">文档列表是&amp;ldquo;从右&amp;rdquo;折叠的；在这一点上，此函数类似于&lt;a href=&quot;list#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt;，不同之处在于它不希望使用初始累加器，而是将 &lt;code&gt;docs&lt;/code&gt; 的最后一个元素用作初始累加器。</target>
        </trans-unit>
        <trans-unit id="b1a2ec347d3bbd914ac71de3130a3ca5d8e9ba73" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~d&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~d&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期信号没有用。</target>
        </trans-unit>
        <trans-unit id="243770f815841be461d24f785d91a84dc8f25160" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~n&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~n&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="61c4050f1d545dfb95cf8194b35027ab14a85e08" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~t&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~t&lt;/code&gt; 变体不存在，因为插值和转义字符对于时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="32388371298b5aa74ba2be98958ecd5080c981d1" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~u&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">小写的 &lt;code&gt;~u&lt;/code&gt; 变体不存在，因为插值和转义字符对于日期时间信号没有用。</target>
        </trans-unit>
        <trans-unit id="8467f6194459766a9d70ef8dad6012fd6200c681" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn/2&quot;&gt;&lt;code&gt;warn/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">宏&lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#warn/2&quot;&gt; &lt;code&gt;warn/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt;优于此宏，因为如果需要，它们可以在编译时自动完全消除对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;的调用（请参阅&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;模块的文档）。</target>
        </trans-unit>
        <trans-unit id="824174ce5b570e4d9805c05f1124ce5c26a319b1" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defrecordp/3&quot;&gt;&lt;code&gt;defrecordp/3&lt;/code&gt;&lt;/a&gt; can be used to create records while &lt;a href=&quot;#extract/2&quot;&gt;&lt;code&gt;extract/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extract_all/1&quot;&gt;&lt;code&gt;extract_all/1&lt;/code&gt;&lt;/a&gt; can be used to extract records from Erlang files.</source>
          <target state="translated">宏&lt;a href=&quot;#defrecord/3&quot;&gt; &lt;code&gt;defrecord/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#defrecordp/3&quot;&gt; &lt;code&gt;defrecordp/3&lt;/code&gt; &lt;/a&gt;可用于创建记录，而&lt;a href=&quot;#extract/2&quot;&gt; &lt;code&gt;extract/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extract_all/1&quot;&gt; &lt;code&gt;extract_all/1&lt;/code&gt; &lt;/a&gt;可用于从Erlang文件中提取记录。</target>
        </trans-unit>
        <trans-unit id="dd1487033e0043998b4a55854f41e5aff164999a" translate="yes" xml:space="preserve">
          <source>The macros in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">本模块中的宏有两种口味:命名或运算符。例如</target>
        </trans-unit>
        <trans-unit id="38f9dca5177d03726cc73b1076b1d78de398e382" translate="yes" xml:space="preserve">
          <source>The main function in this module is &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;, which parses a list of command line options and arguments into a keyword list:</source>
          <target state="translated">该模块的主要功能是&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;，它将命令行选项和参数列表解析为关键字列表：</target>
        </trans-unit>
        <trans-unit id="852a05b0450dc656348efc6729f9e523cd593860" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">大多数功能都需要chardata。如果提供了其他类型，函数将通过&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议将这些类型转换为字符串（如typespecs中所示）。有关chardata的更多信息，请参见下面的&amp;ldquo; IO数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="99c734179f1102a008e516a50860fb644aef0bb8" translate="yes" xml:space="preserve">
          <source>The majority of the functions in the &lt;code&gt;File&lt;/code&gt; module expect paths as arguments. Most commonly, those paths will be regular binaries. The &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; module provides facilities for working with such paths:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 模块中的大多数功能都将路径作为参数。最常见的是，这些路径将是常规二进制文件。该&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;模块提供了用于与这样的路径工作：</target>
        </trans-unit>
        <trans-unit id="14d50e0537a311e097eac9e5b800ff509846d646" translate="yes" xml:space="preserve">
          <source>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like &lt;a href=&quot;#wildcard/2&quot;&gt;&lt;code&gt;wildcard/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块中的大多数功能都不会与文件系统交互，除了一些需要它的功能（例如&lt;a href=&quot;#wildcard/2&quot;&gt; &lt;code&gt;wildcard/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;expand/1&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="53cb17dd3de6e34ca6338dd415345dba7ba819e3" translate="yes" xml:space="preserve">
          <source>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with &lt;code&gt;spawn_link/1&lt;/code&gt;, let&amp;rsquo;s see what happens when a process started with &lt;code&gt;spawn/1&lt;/code&gt; fails:</source>
          <target state="translated">大多数情况下，我们在Elixir中生成进程，我们将它们生成为链接进程。在显示带有 &lt;code&gt;spawn_link/1&lt;/code&gt; 的示例之前，让我们看看以 &lt;code&gt;spawn/1&lt;/code&gt; 开始的进程失败时会发生什么：</target>
        </trans-unit>
        <trans-unit id="10d66e531d4200425ddeb9a59e3170249b7e1aed" translate="yes" xml:space="preserve">
          <source>The map above defines a supervisor with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">上面定义地图与上级 &lt;code&gt;:id&lt;/code&gt; 的 &lt;code&gt;Stack&lt;/code&gt; ，其通过调用启动 &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bb3eb4a71679f85fc1f23e76313b0ee7d67d6ad" translate="yes" xml:space="preserve">
          <source>The map contains the following keys:</source>
          <target state="translated">该地图包含以下内容:</target>
        </trans-unit>
        <trans-unit id="89c1e1079a87250a9082cabf85f0e2b686337098" translate="yes" xml:space="preserve">
          <source>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</source>
          <target state="translated">该映射必须是一个函数。该函数接收一个整数,代表它要取消cape的字符的代码点。下面是Elixir实现的默认映射函数。</target>
        </trans-unit>
        <trans-unit id="23154a42b58e45ef674deb33492b4a7b042bd7a7" translate="yes" xml:space="preserve">
          <source>The mapping between code and data (the underlying AST) is what allows Elixir to implement &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.</source>
          <target state="translated">代码和数据之间的映射（底层的AST）使Elixir能够在Elixir自身中实现 &lt;code&gt;defmodule&lt;/code&gt; ， &lt;code&gt;def&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; 和其他。Elixir使想要将语言扩展到新域的开发人员可以使用该构造来构建该语言。</target>
        </trans-unit>
        <trans-unit id="a6991efb82e0a459b03a5b7c2a6877fbcec33018" translate="yes" xml:space="preserve">
          <source>The marker is what follows exactly after &lt;code&gt;&amp;lt;%&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; has an empty marker, but &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; has &lt;code&gt;&quot;=&quot;&lt;/code&gt; as marker. The allowed markers so far are:</source>
          <target state="translated">标记紧跟在 &lt;code&gt;&amp;lt;%&lt;/code&gt; 之后。例如， &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; 有一个空的标记物，但 &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; 有 &lt;code&gt;&quot;=&quot;&lt;/code&gt; 作为标记物。到目前为止允许的标记是：</target>
        </trans-unit>
        <trans-unit id="cbb00df7fd3fe762840c451309786ffe89ed55ff" translate="yes" xml:space="preserve">
          <source>The match operator</source>
          <target state="translated">匹配运算符</target>
        </trans-unit>
        <trans-unit id="f8693773fd6ff53ba9de6646d15390dd067bbab4" translate="yes" xml:space="preserve">
          <source>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</source>
          <target state="translated">匹配操作符不仅用于对简单的值进行匹配,而且对于重构更复杂的数据类型也很有用。例如,我们可以对元组进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="a9ee80ea2fa936cf7002a1188db1c8b023133c11" translate="yes" xml:space="preserve">
          <source>The math module</source>
          <target state="translated">数学模块</target>
        </trans-unit>
        <trans-unit id="a810ba47e0afb01caa643d3b27868322a40ed5d7" translate="yes" xml:space="preserve">
          <source>The maximum atom size is of 255 Unicode code points.</source>
          <target state="translated">最大原子大小为255个Unicode码点。</target>
        </trans-unit>
        <trans-unit id="da10e2a3fe264c784b7e0fdd60cc0177cfc3d0fb" translate="yes" xml:space="preserve">
          <source>The message is formatted and displayed in the same format as used by Elixir's CLI.</source>
          <target state="translated">该消息的格式和显示方式与Elixir的CLI使用的格式相同。</target>
        </trans-unit>
        <trans-unit id="ae60ef8d035658452d72bdc4024fef29dc953c1c" translate="yes" xml:space="preserve">
          <source>The message is not sent immediately. Therefore, &lt;code&gt;dest&lt;/code&gt; can receive other messages in-between even when &lt;code&gt;time&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">该消息不会立即发送。因此，即使 &lt;code&gt;time&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;dest&lt;/code&gt; 也可以在其间接收其他消息。</target>
        </trans-unit>
        <trans-unit id="1852e95a6b1b63c415d7d9c305bc3d2ad89962d3" translate="yes" xml:space="preserve">
          <source>The messages supported by ports and their counterpart function APIs are listed below:</source>
          <target state="translated">下面列出了 port 所支持的消息及其对应的函数 API。</target>
        </trans-unit>
        <trans-unit id="d94502ad54e0168b2a0dd7bb477e4117c14a5e51" translate="yes" xml:space="preserve">
          <source>The minimum example of a &lt;code&gt;test_helper.exs&lt;/code&gt; file would be:</source>
          <target state="translated">&lt;code&gt;test_helper.exs&lt;/code&gt; 文件的最小示例为：</target>
        </trans-unit>
        <trans-unit id="36e330d350d67652867a9b1fa816fde5c72c65e0" translate="yes" xml:space="preserve">
          <source>The modifiers available when creating a Regex are:</source>
          <target state="translated">创建Regex时可用的修饰符有:?</target>
        </trans-unit>
        <trans-unit id="554bd8892a2a2f959aaf3286fab34f7cb4eab543" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt;模块还包含少量的&lt;a href=&quot;bitwise#guards&quot;&gt;Erlang按位操作作为保护&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6173752a29eeb047f2dfafc51f6c1560f53e16b" translate="yes" xml:space="preserve">
          <source>The module containing the custom sigil must be imported before the sigil syntax can be used.</source>
          <target state="translated">在使用sigil语法之前,必须导入包含自定义sigil的模块。</target>
        </trans-unit>
        <trans-unit id="11a697026fe35980b1003f6f8535e1c516332e63" translate="yes" xml:space="preserve">
          <source>The module documentation above contains documentation and examples for the supported &lt;code&gt;name&lt;/code&gt; values, summarized below:</source>
          <target state="translated">上面的模块文档包含受支持的 &lt;code&gt;name&lt;/code&gt; 值的文档和示例，摘要如下：</target>
        </trans-unit>
        <trans-unit id="6052f32cd5500caeb9f54ee4b03cfe6002f80902" translate="yes" xml:space="preserve">
          <source>The module where the server callbacks are implemented, in this case &lt;code&gt;__MODULE__&lt;/code&gt; (meaning the current module)</source>
          <target state="translated">实现服务器回调的模块，在本例中为 &lt;code&gt;__MODULE__&lt;/code&gt; （表示当前模块）</target>
        </trans-unit>
        <trans-unit id="5d69468bc82e2cdb38bbc6e03284931c1987f717" translate="yes" xml:space="preserve">
          <source>The modules &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt;&lt;code&gt;ets&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt;&lt;code&gt;dets&lt;/code&gt;&lt;/a&gt; handle storage of large data structures in memory or on disk respectively.</source>
          <target state="translated">模块&lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt; &lt;code&gt;ets&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt; &lt;code&gt;dets&lt;/code&gt; 分别&lt;/a&gt;处理大型数据结构在内存或磁盘上的存储。</target>
        </trans-unit>
        <trans-unit id="aad5655a8df039c1d174539db815749409e4e0c7" translate="yes" xml:space="preserve">
          <source>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</source>
          <target state="translated">文件中定义的模块不会被删除,调用这个函数只是将它们从列表中删除,允许它们再次被需要。</target>
        </trans-unit>
        <trans-unit id="ea2b347a7bc6a5535356bac28ba3f2b363ebc47b" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">最常见的Erlang错误将转换为Elixir对应的错误。那些不是的将转换为更通用的&lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cdce2f67135b244ca8a17c4bfd6e3995d0cb745a" translate="yes" xml:space="preserve">
          <source>The most common sigil in Elixir is &lt;code&gt;~r&lt;/code&gt;, which is used to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;:</source>
          <target state="translated">药剂中最常见的印记是 &lt;code&gt;~r&lt;/code&gt; ，这是用来创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;正则表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5a6e4e1aba3cc5896f4b550cdd6a497deff0ddb9" translate="yes" xml:space="preserve">
          <source>The most common tasks are &lt;code&gt;mix deps.get&lt;/code&gt; and &lt;code&gt;mix deps.update&lt;/code&gt;. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing &lt;code&gt;mix help deps&lt;/code&gt;, and in the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;documentation for the Mix.Tasks.Deps module&lt;/a&gt;.</source>
          <target state="translated">最常见的任务是 &lt;code&gt;mix deps.get&lt;/code&gt; 和 &lt;code&gt;mix deps.update&lt;/code&gt; 。一旦获取，依赖项将自动为您编译。您可以通过键入 &lt;code&gt;mix help deps&lt;/code&gt; 以及在&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;Mix.Tasks.Deps模块&lt;/a&gt;的文档中了解有关deps的更多信息。</target>
        </trans-unit>
        <trans-unit id="6b9cc7f30985b20ae7924700825d31d820820e24" translate="yes" xml:space="preserve">
          <source>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</source>
          <target state="translated">heredoc符号最常见的使用情况是在编写文档时。例如,在文档中写转义字符很快就会变得容易出错,因为需要对一些字符进行双重转义。</target>
        </trans-unit>
        <trans-unit id="b3b38c4c7bf2ec83c1026ecdaac1402a38fdf641" translate="yes" xml:space="preserve">
          <source>The most common way to raise an exception is via &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">引发异常的最常见方法是通过&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ec63aea88c70e103879cfde37537cf2e076faa36" translate="yes" xml:space="preserve">
          <source>The name of the generated macros will be &lt;code&gt;name&lt;/code&gt; (which has to be an atom). &lt;code&gt;tag&lt;/code&gt; is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if &lt;code&gt;nil&lt;/code&gt;), it's the same as &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;kv&lt;/code&gt; is a keyword list of &lt;code&gt;name: default_value&lt;/code&gt; fields for the new record.</source>
          <target state="translated">生成的宏的名称将为 &lt;code&gt;name&lt;/code&gt; （必须是一个原子）。 &lt;code&gt;tag&lt;/code&gt; 也是一个原子，用作记录的&amp;ldquo;标签&amp;rdquo;（即记录元组的第一个元素）；默认情况下（如果为 &lt;code&gt;nil&lt;/code&gt; ），它与 &lt;code&gt;name&lt;/code&gt; 相同。 &lt;code&gt;kv&lt;/code&gt; 是 &lt;code&gt;name: default_value&lt;/code&gt; 的关键字列表：新记录的default_value字段。</target>
        </trans-unit>
        <trans-unit id="090750250669854ad5f2a1b18b4694400b5de691" translate="yes" xml:space="preserve">
          <source>The named sequences are represented by atoms.</source>
          <target state="translated">命名的序列由原子表示。</target>
        </trans-unit>
        <trans-unit id="84dca7c82c4adab78e96e4275650ccd595bf63f7" translate="yes" xml:space="preserve">
          <source>The need for monitoring</source>
          <target state="translated">监测的必要性</target>
        </trans-unit>
        <trans-unit id="5d5693a336fde96fc9f4a9263d265529c9d65820" translate="yes" xml:space="preserve">
          <source>The next two functions, &lt;code&gt;lookup/2&lt;/code&gt; and &lt;code&gt;create/2&lt;/code&gt;, are responsible for sending these requests to the server. In this case, we have used &lt;code&gt;{:lookup, name}&lt;/code&gt; and &lt;code&gt;{:create, name}&lt;/code&gt; respectively. Requests are often specified as tuples, like this, in order to provide more than one &amp;ldquo;argument&amp;rdquo; in that first argument slot. It&amp;rsquo;s common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to &lt;code&gt;handle_call/3&lt;/code&gt; or &lt;code&gt;handle_cast/2&lt;/code&gt;.</source>
          <target state="translated">接下来的两个函数 &lt;code&gt;lookup/2&lt;/code&gt; 和 &lt;code&gt;create/2&lt;/code&gt; 负责将这些请求发送到服务器。在这种情况下，我们分别使用了 &lt;code&gt;{:lookup, name}&lt;/code&gt; 和 &lt;code&gt;{:create, name}&lt;/code&gt; 。这样，请求通常被指定为元组，以便在第一个参数槽中提供多个&amp;ldquo;参数&amp;rdquo;。通常，将请求的操作指定为元组的第一个元素，并在其余元素中指定该操作的参数。请注意，请求必须与 &lt;code&gt;handle_call/3&lt;/code&gt; 或 &lt;code&gt;handle_cast/2&lt;/code&gt; 的第一个参数匹配。</target>
        </trans-unit>
        <trans-unit id="987bf5fe1a29a589006df7a1c4246dedd1188aa8" translate="yes" xml:space="preserve">
          <source>The node list defaults to a list of all connected nodes.</source>
          <target state="translated">节点列表默认为所有连接节点的列表。</target>
        </trans-unit>
        <trans-unit id="1e4f23ef668efde946b979656f1273bb8fc04978" translate="yes" xml:space="preserve">
          <source>The notation to represent the union of types is the pipe &lt;code&gt;|&lt;/code&gt;. For example, the typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; creates a type &lt;code&gt;type&lt;/code&gt; that can be either an &lt;code&gt;atom&lt;/code&gt;, a &lt;code&gt;pid&lt;/code&gt;, or a &lt;code&gt;tuple&lt;/code&gt;. This is usually called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt; in other languages</source>
          <target state="translated">表示类型的并集的符号是管道 &lt;code&gt;|&lt;/code&gt; 。例如，typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; ::: atom（）| pid（）| tuple（）创建一个类型 &lt;code&gt;type&lt;/code&gt; ，该类型类型可以是 &lt;code&gt;atom&lt;/code&gt; ， &lt;code&gt;pid&lt;/code&gt; 或 &lt;code&gt;tuple&lt;/code&gt; 。通常在其他语言中称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;求和类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ab75e9fdd50914ae4096566ba3ee4815b968a2a" translate="yes" xml:space="preserve">
          <source>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</source>
          <target state="translated">每个匿名函数子句中的参数数量需要相同,否则会出现错误。</target>
        </trans-unit>
        <trans-unit id="58646d5d2a31b22e08348e0987be6fb1b1552f1b" translate="yes" xml:space="preserve">
          <source>The offset is capped to the length of the string. Returns a tuple with two elements.</source>
          <target state="translated">偏移量以字符串的长度为上限。返回一个包含两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="7ac751725399e216969e58864613bb897ae9753a" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;之间的唯一区别是，在比较整数和浮点数时，&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;是严格的：</target>
        </trans-unit>
        <trans-unit id="42fcb26dc86b08d995f11bae71b9989f2f7b728a" translate="yes" xml:space="preserve">
          <source>The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.</source>
          <target state="translated">上述兼容性保证的唯一例外是实验性功能,这些功能将被明确标记为实验性功能,在其稳定之前不提供任何兼容性保证。</target>
        </trans-unit>
        <trans-unit id="5b80c752c5e1cd83678df53e132bab989245bf95" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">唯一需要实现的功能是进行转换的&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3738a03df0b0292cd0fc541a62dccb969b8d4008" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt;, which does the conversion.</source>
          <target state="translated">唯一需要实现的功能是&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt;，它可以进行转换。</target>
        </trans-unit>
        <trans-unit id="ade81e07849e4708797e256e50ea8daa5d7c1c81" translate="yes" xml:space="preserve">
          <source>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &lt;code&gt;&amp;amp;1&lt;/code&gt;, and that block expressions are not supported:</source>
          <target state="translated">创建匿名函数时的唯一限制是必须存在至少一个占位符，即它必须至少包含 &lt;code&gt;&amp;amp;1&lt;/code&gt; ，并且不支持块表达式：</target>
        </trans-unit>
        <trans-unit id="5bde5d825d53af6907621f0cb4672e1213049a4a" translate="yes" xml:space="preserve">
          <source>The operation is Unicode unsafe.</source>
          <target state="translated">该操作为Unicode不安全。</target>
        </trans-unit>
        <trans-unit id="820323122693cc928f8711400bb7374b1eb73417" translate="yes" xml:space="preserve">
          <source>The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">在二进制浮点数上进行操作,不进行十进制的转换。</target>
        </trans-unit>
        <trans-unit id="54a4338b50a933ea4de60119e3d7bc1ba6605f93" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Elixir使用的运算符（例如 &lt;code&gt;+&lt;/code&gt; ）可以由任何模块定义，并且可以代替Elixir定义的运算符使用，前提是它们不是专门从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;导入的（默认情况下随处导入）。例如：</target>
        </trans-unit>
        <trans-unit id="35424357ca8ff1662dd08fa3f02518cdf95e9618" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">将字符串转换为带引号的形式的&lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;是Macro.to_string / 2，它将带引号的形式转换为字符串/二进制表示形式。</target>
        </trans-unit>
        <trans-unit id="648996e2b78ff86fed25658983c86c1ca75fe83d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if deprecated calls exist.</source>
          <target state="translated">如果存在弃用的调用，则选项 &lt;code&gt;--abort-if-any&lt;/code&gt; 可用于使命令失败。</target>
        </trans-unit>
        <trans-unit id="719eb9d884931feb59017fec9c07b6c8395fab97" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if unreachable calls exist.</source>
          <target state="translated">如果存在无法到达的调用，则选项 &lt;code&gt;--abort-if-any&lt;/code&gt; 可用于使命令失败。</target>
        </trans-unit>
        <trans-unit id="098132f317e5ef6b4049ca986c6beb4394ebb00e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; can be used with &lt;code&gt;@derive&lt;/code&gt; to specify which fields should and should not appear in the algebra document:</source>
          <target state="translated">&lt;code&gt;:only&lt;/code&gt; 和 &lt;code&gt;:except&lt;/code&gt; 选项可以与 &lt;code&gt;@derive&lt;/code&gt; 一起使用，以指定哪些字段应该出现在代数文档中，哪些字段不应出现在代数文档中：</target>
        </trans-unit>
        <trans-unit id="1ca038b4953a725a1168758bdb05bf6957d97558" translate="yes" xml:space="preserve">
          <source>The options above have different properties. Both &lt;code&gt;:rpc&lt;/code&gt; and using a GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.</source>
          <target state="translated">上面的选项具有不同的属性。这两个 &lt;code&gt;:rpc&lt;/code&gt; 和使用GenServer将序列的一台服务器上的请求，而任务是有效的远程节点上异步运行，唯一的序列化点是由主管进行产卵。</target>
        </trans-unit>
        <trans-unit id="ec569bf070d46fd1797683900e4e0d1b42dd476e" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">这些选项还可以用于注册主管名称。支持的值在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="b29b1695f7e1a72d94e875780fae402a43a9edf2" translate="yes" xml:space="preserve">
          <source>The options given in the child specification are documented in &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">子规范中给出的选项记录在&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29149d2185c124051b475d7edf03c7125bd21d1c" translate="yes" xml:space="preserve">
          <source>The options not available are:</source>
          <target state="translated">不可用的选项有:</target>
        </trans-unit>
        <trans-unit id="df79e73939e2f96120d0bd91e6ec1e8015418fd3" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;List&lt;/code&gt; can still be accessed within &lt;code&gt;Stats&lt;/code&gt; by the fully-qualified name &lt;code&gt;Elixir.List&lt;/code&gt;.</source>
          <target state="translated">仍然可以在 &lt;code&gt;Stats&lt;/code&gt; 中使用完全限定的名称 &lt;code&gt;Elixir.List&lt;/code&gt; 来访问原始 &lt;code&gt;List&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1668a9a07e94faf6e48dc573decf8c9122af382" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">通过提供 &lt;code&gt;:label&lt;/code&gt; 选项可以轻松地将输出与其他&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用区分开，从而可以用标签修饰输出。标签将在检查 &lt;code&gt;item&lt;/code&gt; 之前打印。</target>
        </trans-unit>
        <trans-unit id="313b3334ac8a23ead5e2d1a7fbc216efaabeea04" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，将使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果此路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="6d4310f7386df1164fbd8636a1690c05bd665337" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在删除该路径之前，先使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果路径不存在，则此函数返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="838b6d73e0a2709d4a72a878f5b42de538ac3faf" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">在添加路径之前，先使用&lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 对其&lt;/a&gt;进行扩展。如果此路径不存在，则返回错误。</target>
        </trans-unit>
        <trans-unit id="e091aa0884c675c72ffb53e03abf27a7e2087b1e" translate="yes" xml:space="preserve">
          <source>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</source>
          <target state="translated">路径可以是一个charlist或一个字符串。在内部,它们是作为 charlists 工作的,所以以 list 的形式传递它们可以避免额外的转换。</target>
        </trans-unit>
        <trans-unit id="668bfdcbbc88064352f1db03b861c85f89d02114" translate="yes" xml:space="preserve">
          <source>The pattern can be a module name, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; to count all calls to that module, a call without arity, such as &lt;code&gt;String.split&lt;/code&gt;, to count all calls to that function regardless of arity, or a call with arity, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt;, to count all calls to that exact module, function and arity.</source>
          <target state="translated">该模式可以是一个模块名称，例如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;来计数对该模块的所有调用，一个无Arity的调用（例如 &lt;code&gt;String.split&lt;/code&gt; )，以计算对该函数的所有调用，而与Arity无关，或者具有Arity的调用（例如&lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt;，以计算对该确切模块，函数和Arity的所有调用。</target>
        </trans-unit>
        <trans-unit id="e6382a5f5628ad82e683e23e1297c423e36e37f3" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matched patterns:</source>
          <target state="translated">模式也可以是一个字符串列表,替换也可以是一个接收匹配模式的函数。</target>
        </trans-unit>
        <trans-unit id="5c2c0506c6452af899d4d254cc14a3c00d8d753c" translate="yes" xml:space="preserve">
          <source>The pattern of keeping multiple applications in the same repository is known as &amp;ldquo;mono-repo&amp;rdquo;. Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.</source>
          <target state="translated">将多个应用程序保留在同一存储库中的模式称为&amp;ldquo; mono-repo&amp;rdquo;。伞项目通过提供方便的方式来一次编译，测试和运行多个应用程序，从而最大化了这种模式。</target>
        </trans-unit>
        <trans-unit id="b5336f2e10af99a0ddce0df1dbcc6953c1b3edca" translate="yes" xml:space="preserve">
          <source>The pin operator</source>
          <target state="translated">销操作者</target>
        </trans-unit>
        <trans-unit id="8a16097e3345670b784d58d96c0daf29bd6b6363" translate="yes" xml:space="preserve">
          <source>The pipe operator</source>
          <target state="translated">管道操作员</target>
        </trans-unit>
        <trans-unit id="38ac69a732c3ec695582cbd0d48d9b6cb576dd15" translate="yes" xml:space="preserve">
          <source>The port can be opened through four main mechanisms.</source>
          <target state="translated">该端口可以通过四种主要机制打开。</target>
        </trans-unit>
        <trans-unit id="16f2f4882ba1e010d9493752e86925be5a3100f2" translate="yes" xml:space="preserve">
          <source>The power of Elixir&amp;rsquo;s extensibility comes when protocols and structs are used together.</source>
          <target state="translated">当协议和结构体一起使用时，Elixir的可扩展性就会到来。</target>
        </trans-unit>
        <trans-unit id="4539c5e2ab058d8719dac59fa3bb2dc3b38cff89" translate="yes" xml:space="preserve">
          <source>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</source>
          <target state="translated">精度表示将微秒表示为外部格式时必须使用的数字。如果精度为0,表示必须跳过微秒。</target>
        </trans-unit>
        <trans-unit id="7b62847898ead6d12d866064984b0e4967caa7b6" translate="yes" xml:space="preserve">
          <source>The previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many &lt;code&gt;case&lt;/code&gt; calls.</source>
          <target state="translated">先前的实现使用了流水线，使逻辑易于理解。但是，由于我们现在需要处理不同的错误代码，因此我们的服务器逻辑嵌套在许多 &lt;code&gt;case&lt;/code&gt; 调用中。</target>
        </trans-unit>
        <trans-unit id="199cc5f932aae17375561fec949a9c5a51d6d815" translate="yes" xml:space="preserve">
          <source>The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with.</source>
          <target state="translated">上述代码的问题是,如果用户提供了无效的输入,错误将在库的深处被提出,这使得用户感到困惑。此外,当你不在边界处验证值时,你的库的内部永远不能完全确定他们在处理哪种值。</target>
        </trans-unit>
        <trans-unit id="523d730771dc4a286c57cbc053f5c708e3c1f6ea" translate="yes" xml:space="preserve">
          <source>The process is terminated, if there's one. The child specification is kept unless the child is temporary.</source>
          <target state="translated">进程被终止,如果有的话。除非子程序是临时性的,否则子程序规格会被保留。</target>
        </trans-unit>
        <trans-unit id="b431d95d4131709473d087764c74e5d0bd63926d" translate="yes" xml:space="preserve">
          <source>The process of taking a list and &lt;em&gt;reducing&lt;/em&gt; it down to one value is known as a &lt;em&gt;reduce algorithm&lt;/em&gt; and is central to functional programming.</source>
          <target state="translated">服用的列表，并且处理&lt;em&gt;减少&lt;/em&gt;它下降到一个值被称为一个&lt;em&gt;减少算法&lt;/em&gt;，而且是中心功能的编程。</target>
        </trans-unit>
        <trans-unit id="2fe675ae074650fc0dd2cca82261ebbd5e4a0afa" translate="yes" xml:space="preserve">
          <source>The process that sends the message does not block on &lt;code&gt;send/2&lt;/code&gt;, it puts the message in the recipient&amp;rsquo;s mailbox and continues. In particular, a process can send messages to itself.</source>
          <target state="translated">发送消息的过程不会在 &lt;code&gt;send/2&lt;/code&gt; 上阻塞，它会将消息放入收件人的邮箱中并继续。特别是，进程可以向自身发送消息。</target>
        </trans-unit>
        <trans-unit id="f279aa503c0e9c1a8851aaff4d4667435775ccbe" translate="yes" xml:space="preserve">
          <source>The project name is given in the &lt;code&gt;snake_case&lt;/code&gt; convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the &lt;a href=&quot;naming-conventions&quot;&gt;Naming Conventions&lt;/a&gt; document for more information.</source>
          <target state="translated">项目名称以 &lt;code&gt;snake_case&lt;/code&gt; 约定给出，其中所有字母均为小写，单词之间用下划线分隔。这与Elixir中的变量，函数名称和原子使用的约定相同。有关更多信息，请参见&lt;a href=&quot;naming-conventions&quot;&gt;命名约定&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="ee55aee8e2dfe77fe02c53dba2352810a3c64b0a" translate="yes" xml:space="preserve">
          <source>The protocol definition would look like this:</source>
          <target state="translated">协议的定义是这样的。</target>
        </trans-unit>
        <trans-unit id="bc915ce7d8df69961e91346b51ae1b4406aeabbb" translate="yes" xml:space="preserve">
          <source>The queue module</source>
          <target state="translated">尾部模块</target>
        </trans-unit>
        <trans-unit id="0af8f5620b697ca5fb92373212c500e4cb31990a" translate="yes" xml:space="preserve">
          <source>The rand module</source>
          <target state="translated">兰德模块</target>
        </trans-unit>
        <trans-unit id="231da92c7cb81a49b248aa20d7528608e5de9c35" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is &lt;a href=&quot;application#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此行为的基本原理是更好地支持Erlang库，该库可能以charlists而不是Elixir字符串的形式返回文本。此类函数的一个示例是&lt;a href=&quot;application#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bd093bcc0572d7db8f0249b943686c7ab44cd28f" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">与结构混合使用时，协议的真正好处就在于。例如，Elixir附带许多实现为结构的数据类型，例如&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;。我们也可以为这些类型实现 &lt;code&gt;Size&lt;/code&gt; 协议：</target>
        </trans-unit>
        <trans-unit id="dd7d714c1aa6b48b1d5593fcc16114d85e6a86ca" translate="yes" xml:space="preserve">
          <source>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like &lt;code&gt;~r(^https?://)&lt;/code&gt; reads arguably better than &lt;code&gt;~r/^https?:\/\//&lt;/code&gt;. Similarly, if the regular expression has forward slashes and capturing groups (that use &lt;code&gt;()&lt;/code&gt;), you may then choose double quotes instead of parentheses.</source>
          <target state="translated">支持不同定界符的原因是提供了一种无需转义定界符即可编写文字的方法。例如，带有正斜杠的正则表达式，例如〜r &lt;code&gt;~r(^https?://)&lt;/code&gt; 读起来肯定比 &lt;code&gt;~r/^https?:\/\//&lt;/code&gt; 。同样，如果正则表达式具有正斜杠和捕获组（使用 &lt;code&gt;()&lt;/code&gt; ），则可以选择双引号而不是括号。</target>
        </trans-unit>
        <trans-unit id="2ebf61cf3ca7649d4a079542dcbdefccc549e8d6" translate="yes" xml:space="preserve">
          <source>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</source>
          <target state="translated">之所以会出现这些失误,是因为在教学上,我们犯了两个错误。</target>
        </trans-unit>
        <trans-unit id="c08560839cd14ff160f58cb4ece9a90b113b6018" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don&amp;rsquo;t need to worry about different data types in order to sort. The overall sorting order is defined below:</source>
          <target state="translated">我们可以比较不同数据类型的原因是实用主义。排序算法无需担心不同的数据类型即可进行排序。总体排序顺序如下：</target>
        </trans-unit>
        <trans-unit id="96b6eb1d3d1c2f52c89893113a0264a48486f7f0" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</source>
          <target state="translated">我们可以比较不同数据类型的原因是实用主义。排序算法不需要担心不同数据类型的排序问题。作为参考,整体的排序顺序定义如下。</target>
        </trans-unit>
        <trans-unit id="9745fde52cc90f68fc3769f51bdd3839a79e7909" translate="yes" xml:space="preserve">
          <source>The reason why defining the &lt;code&gt;__using__&lt;/code&gt; macro above should be avoided is because when a developer writes:</source>
          <target state="translated">应该避免定义上面的 &lt;code&gt;__using__&lt;/code&gt; 宏的原因是，当开发人员编写时：</target>
        </trans-unit>
        <trans-unit id="6ec6b8d401a0e57e5eec7caca955764b74ee728d" translate="yes" xml:space="preserve">
          <source>The reducer function.</source>
          <target state="translated">减速器功能。</target>
        </trans-unit>
        <trans-unit id="fe9b615b4b2367b7daee50e253cbdf23dba26c40" translate="yes" xml:space="preserve">
          <source>The registry can be used for different purposes, such as name lookups (using the &lt;code&gt;:via&lt;/code&gt; option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.</source>
          <target state="translated">注册表可用于不同目的，例如名称查找（使用 &lt;code&gt;:via&lt;/code&gt; 选项），存储属性，自定义调度规则或pubsub实现。我们在下面探索其中一些用例。</target>
        </trans-unit>
        <trans-unit id="830561c69ec1b44d20b1476b8ca91dcfe652b847" translate="yes" xml:space="preserve">
          <source>The registry creates the bucket and updates the cache table</source>
          <target state="translated">注册表创建桶并更新缓存表。</target>
        </trans-unit>
        <trans-unit id="1e02149d4dfcef116ac8ae8bc7c958f58a3e9c0d" translate="yes" xml:space="preserve">
          <source>The registry identifier</source>
          <target state="translated">登记处的标识符</target>
        </trans-unit>
        <trans-unit id="6c262eba9d17501af95e8d89e43d93764b4ff9c4" translate="yes" xml:space="preserve">
          <source>The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries.</source>
          <target state="translated">注册表还可以透明地进行分区,这为在具有数千或数百万条目的高并发环境中运行注册表提供了更多可扩展的行为。</target>
        </trans-unit>
        <trans-unit id="6dcaa3fc50cf9fd5531a012d77c058d5085b7bd8" translate="yes" xml:space="preserve">
          <source>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to &lt;em&gt;monitor&lt;/em&gt; each bucket. Because our &lt;em&gt;registry&lt;/em&gt; needs to be able to receive and handle ad-hoc messages from the system, the &lt;code&gt;Agent&lt;/code&gt; API is not enough.</source>
          <target state="translated">注册表需要保证它始终是最新的。例如，如果存储桶进程之一由于错误而崩溃，则注册表必须注意此更改，并避免提供过时的条目。在Elixir中，我们说注册表需要&lt;em&gt;监视&lt;/em&gt;每个存储桶。因为我们的&lt;em&gt;注册表&lt;/em&gt;需要能够接收和处理来自系统的临时消息，所以 &lt;code&gt;Agent&lt;/code&gt; API不够。</target>
        </trans-unit>
        <trans-unit id="4a058f690e57a3aca65e5ad6c344df9d0e9611d7" translate="yes" xml:space="preserve">
          <source>The registry requires the following keys:</source>
          <target state="translated">注册表需要下列键:</target>
        </trans-unit>
        <trans-unit id="66187ff2a57d2c76b021b6e86b887377c3911cc5" translate="yes" xml:space="preserve">
          <source>The remaining fields are private and should not be accessed.</source>
          <target state="translated">其余的字段都是私人的,不应该被访问。</target>
        </trans-unit>
        <trans-unit id="1f0abbf815761f3e816424020ca8e718d8880a26" translate="yes" xml:space="preserve">
          <source>The remaining options can be specified to further customize the escript:</source>
          <target state="translated">其余选项可以指定,以进一步定制escript。</target>
        </trans-unit>
        <trans-unit id="7b880036afa4f762da2230a6fa814b25c0b9e585" translate="yes" xml:space="preserve">
          <source>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the capture. In case &lt;code&gt;\0&lt;/code&gt; is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use &lt;code&gt;\\N&lt;/code&gt; and &lt;code&gt;\\g{N}&lt;/code&gt;.</source>
          <target state="translated">替换可以是字符串或函数。该字符串用作每个匹配项的替换，它允许通过 &lt;code&gt;\N&lt;/code&gt; 或 &lt;code&gt;\g{N}&lt;/code&gt; 访问特定的捕获，其中 &lt;code&gt;N&lt;/code&gt; 是捕获。如果使用 &lt;code&gt;\0&lt;/code&gt; ，则会插入整个匹配项。请注意，在正则表达式中，需要转义反斜杠，因此在实践中，您将需要使用 &lt;code&gt;\\N&lt;/code&gt; 和 &lt;code&gt;\\g{N}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12dcacc64e49f2ca797e3a42d48c6b95c4c021d" translate="yes" xml:space="preserve">
          <source>The reply sent by the task will be in the format &lt;code&gt;{ref, result}&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the monitor reference held by the task struct and &lt;code&gt;result&lt;/code&gt; is the return value of the task function.</source>
          <target state="translated">任务发送的回复将采用 &lt;code&gt;{ref, result}&lt;/code&gt; 格式，其中 &lt;code&gt;ref&lt;/code&gt; 是任务struct所拥有的监视器引用，而 &lt;code&gt;result&lt;/code&gt; 是任务函数的返回值。</target>
        </trans-unit>
        <trans-unit id="fbae3095fe06d4c7dbe53db6c416f757e85aa9e2" translate="yes" xml:space="preserve">
          <source>The requirement operand after the &lt;code&gt;~&amp;gt;&lt;/code&gt; is allowed to omit the patch version, allowing us to express &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; or &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt;, something that wouldn't be allowed when using the common comparison operators.</source>
          <target state="translated">允许 &lt;code&gt;~&amp;gt;&lt;/code&gt; 之后的需求操作数省略补丁版本，从而使我们可以表达 &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; 或 &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt; ，这是使用通用比较运算符时所不允许的。</target>
        </trans-unit>
        <trans-unit id="48c107c58db2b694200d1ee8f97e6cacd70556ad" translate="yes" xml:space="preserve">
          <source>The requirements for this guide are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">本指南的要求是（请参阅 &lt;code&gt;elixir -v&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="510fb68883c75cfa0f5726ad2958e2b2d1f8df13" translate="yes" xml:space="preserve">
          <source>The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more.</source>
          <target state="translated">本文档的其余部分将涵盖如何指定儿童进程,如何启动和停止它们,不同的监督策略等。</target>
        </trans-unit>
        <trans-unit id="34f71128fc5223e069e44135ef71e787278b7b2a" translate="yes" xml:space="preserve">
          <source>The result depends on the given options. In particular, if &lt;code&gt;:monitor&lt;/code&gt; is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</source>
          <target state="translated">结果取决于给定的选项。特别是，如果 &lt;code&gt;:monitor&lt;/code&gt; 作为选项提供，它将返回一个包含PID和监视参考的元组，否则仅返回生成的过程PID。</target>
        </trans-unit>
        <trans-unit id="8c0864a3fd323ad326bf0ff0a4ae750f6f28b62b" translate="yes" xml:space="preserve">
          <source>The result is a map where each key is given by &lt;code&gt;key_fun&lt;/code&gt; and each value is a list of elements given by &lt;code&gt;value_fun&lt;/code&gt;. The order of elements within each list is preserved from the &lt;code&gt;enumerable&lt;/code&gt;. However, like all maps, the resulting map is unordered.</source>
          <target state="translated">结果是一个映射，其中每个键都由 &lt;code&gt;key_fun&lt;/code&gt; 给定，每个值都是 &lt;code&gt;value_fun&lt;/code&gt; 给定的元素列表。每个列表中元素的顺序保留在 &lt;code&gt;enumerable&lt;/code&gt; 。但是，像所有地图一样，生成的地图是无序的。</target>
        </trans-unit>
        <trans-unit id="8c937afc93e905039ed962f46e31ce761b0b7910" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the code point and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">结果是一个带代码点和字符串其余部分的元组，如果字符串到达​​末尾则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b054d17c2daa0de49da800a95e641450c215bba5" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the grapheme and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the String reached its end.</source>
          <target state="translated">结果是带有字素和字符串其余部分的元组，如果字符串到达​​末尾则为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf56030549a526b9bf11fca22b129025175f9e01" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">结果是一个元组，具有下一个字形大小和字符串的其余部分，或者 &lt;code&gt;nil&lt;/code&gt; （如果字符串到达​​其末尾）。</target>
        </trans-unit>
        <trans-unit id="69c824c2f4dd9e92c63e7c43b613daec936f10e9" translate="yes" xml:space="preserve">
          <source>The result is always a float. Use &lt;a href=&quot;#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rem/2&quot;&gt;&lt;code&gt;rem/2&lt;/code&gt;&lt;/a&gt; if you want an integer division or the remainder.</source>
          <target state="translated">结果始终是浮点数。如果要整数除法或余数，请使用&lt;a href=&quot;#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rem/2&quot;&gt; &lt;code&gt;rem/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e60b28a7c2d9f237889da5d63ad55cd56db26e5f" translate="yes" xml:space="preserve">
          <source>The result is returned in the &lt;code&gt;:native&lt;/code&gt; time unit.</source>
          <target state="translated">结果以 &lt;code&gt;:native&lt;/code&gt; 时间单位返回。</target>
        </trans-unit>
        <trans-unit id="7e378125d134cee06b90778b774e2ca53b3a689f" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (e.g., obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">其结果是在给定的时间单位返回 &lt;code&gt;unit&lt;/code&gt; 。返回的偏移量添加到Erlang单调时间（例如，通过&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt;获得），从而得出与该单调时间相对应的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="ad2bb7bf504a7a31fc692bc22a46a7f6c26558df" translate="yes" xml:space="preserve">
          <source>The result is rounded via the floor function.</source>
          <target state="translated">结果通过底限函数取整。</target>
        </trans-unit>
        <trans-unit id="7c9d24e7e55d00cf51e7d7ac4365534956cf6af0" translate="yes" xml:space="preserve">
          <source>The result of the reduce operation.</source>
          <target state="translated">减少操作的结果。</target>
        </trans-unit>
        <trans-unit id="5c33a08ba308a53a6a04ff3b3a415b2906539c81" translate="yes" xml:space="preserve">
          <source>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">这个函数的结果是用来检查两个日历是否在一天中的同一时间翻转。如果没有,我们只能在它们之间转换日期和时间。如果是,这意味着我们也可以在它们之间转换日期和天真的日期时间。</target>
        </trans-unit>
        <trans-unit id="deee6a8e2cf3a1dc01e05f85abd7a333a49b9743" translate="yes" xml:space="preserve">
          <source>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</source>
          <target state="translated">当参数是一个 list 时,返回的结果是满足 list 元素反结的节点列表。</target>
        </trans-unit>
        <trans-unit id="de9d80b1ab304736a1d1cf097b00ab6920ddf496" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;fun&lt;/code&gt; is expected to be</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 的返回值预计为</target>
        </trans-unit>
        <trans-unit id="c789d5090be5fd4830e5650f8cf224329bb3d092" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; or any of the &lt;code&gt;handle_*&lt;/code&gt; callbacks may include a timeout value in milliseconds; if not, &lt;code&gt;:infinity&lt;/code&gt; is assumed. The timeout can be used to detect a lull in incoming messages.</source>
          <target state="translated">&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;或任何 &lt;code&gt;handle_*&lt;/code&gt; 回调的返回值都可以包含超时值（以毫秒为单位）。如果不是，则假定 &lt;code&gt;:infinity&lt;/code&gt; 。超时可用于检测传入消息的停顿。</target>
        </trans-unit>
        <trans-unit id="637f2543c6c71a469bb5665295bb80f1c21c7816" translate="yes" xml:space="preserve">
          <source>The return value of this function is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此函数的返回值始终为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee9968a076604f4bf8eb65e4e57dfeed366595f" translate="yes" xml:space="preserve">
          <source>The return value of this function is the value that was previously stored under &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; in case no value was stored under it.</source>
          <target state="translated">这个函数的返回值是以前下存储的值 &lt;code&gt;key&lt;/code&gt; ，或 &lt;code&gt;nil&lt;/code&gt; 的情况下，没有值存储在它之下。</target>
        </trans-unit>
        <trans-unit id="f600704ad2a1d265216e1874920599247dcd864b" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">返回的函数通常作为访问器传递给&lt;a href=&quot;kernel#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt;和朋友。</target>
        </trans-unit>
        <trans-unit id="feb14c2276580a5fb93fd8afe56dfe5ef725b402" translate="yes" xml:space="preserve">
          <source>The returned function raises if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则返回的函数将引发。</target>
        </trans-unit>
        <trans-unit id="f18363f66f41ea776d213b7a358943fee2fbf810" translate="yes" xml:space="preserve">
          <source>The returned function receives a term and a command and injects the term into the collectable on every &lt;code&gt;{:cont, term}&lt;/code&gt; command.</source>
          <target state="translated">返回的函数接收一个术语和一个命令，并在每个 &lt;code&gt;{:cont, term}&lt;/code&gt; 命令上将其注入到collectable中。</target>
        </trans-unit>
        <trans-unit id="03b6bd0a789c54c65fa616d4c3d05a787c9fac95" translate="yes" xml:space="preserve">
          <source>The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys:</source>
          <target state="translated">如果键不存在,返回的函数使用默认值。这可以用来指定默认值和安全地遍历丢失的键。</target>
        </trans-unit>
        <trans-unit id="17eadcc2531c98be75b3d36e9d02f1db40badbf9" translate="yes" xml:space="preserve">
          <source>The returned information is a two-element tuple in the shape of &lt;code&gt;{info, value}&lt;/code&gt;.</source>
          <target state="translated">返回的信息是一个 &lt;code&gt;{info, value}&lt;/code&gt; 形式的两个元素的元组。</target>
        </trans-unit>
        <trans-unit id="40619e10ae25c330063c65535cf867c78a0305e7" translate="yes" xml:space="preserve">
          <source>The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:</source>
          <target state="translated">所有类型的函数(本地和外部)的返回键(以及相应的可能值)如下:</target>
        </trans-unit>
        <trans-unit id="8ee75b4eeb81fcc96ebfd98173bc87ddff369546" translate="yes" xml:space="preserve">
          <source>The returned path will be expanded.</source>
          <target state="translated">返回的路径将被展开。</target>
        </trans-unit>
        <trans-unit id="4d71c99a8e09f63bf55427e1e561d5818b8e3777" translate="yes" xml:space="preserve">
          <source>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</source>
          <target state="translated">返回的引用将在大约2^82次调用后重新出现,因此对于实际目的来说,它是唯一的。</target>
        </trans-unit>
        <trans-unit id="6710b3a068da95fe2b8593d7add9ec761b0835bc" translate="yes" xml:space="preserve">
          <source>The returned value is a map containing name-value pairs. Variable names and their values are strings.</source>
          <target state="translated">返回的值是一个包含名-值对的映射。变量名称及其值是字符串。</target>
        </trans-unit>
        <trans-unit id="b373635bb9902337ad9e10b973bd7b4caeea100c" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是一个由 &lt;code&gt;fun&lt;/code&gt; 返回的&amp;ldquo; get&amp;rdquo;值的元组，以及在 &lt;code&gt;key&lt;/code&gt; 下具有更新后值的新关键字列表。</target>
        </trans-unit>
        <trans-unit id="b42137d3006c00e4b619eab71021a2f058571bc2" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回值是一个由 &lt;code&gt;fun&lt;/code&gt; 返回的&amp;ldquo; get&amp;rdquo;值的元组，以及一个在 &lt;code&gt;key&lt;/code&gt; 下具有更新值的新映射。</target>
        </trans-unit>
        <trans-unit id="bcdf4e0951183ef655924f609aa3f331a6262b10" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new container with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">返回的值是通过返回的&amp;ldquo;获得&amp;rdquo;价值两元的元组 &lt;code&gt;fun&lt;/code&gt; 和新的容器下的更新值 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e65f7f051c44e5c9c75a8f2f854fabd880fc538" translate="yes" xml:space="preserve">
          <source>The returned value of the environment variable &lt;code&gt;varname&lt;/code&gt; is a string. If the environment variable is not set, returns the string specified in &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; if none is specified.</source>
          <target state="translated">环境变量 &lt;code&gt;varname&lt;/code&gt; 的返回值是一个字符串。如果没有设置环境变量，返回指定的字符串 &lt;code&gt;default&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，如果没有指定。</target>
        </trans-unit>
        <trans-unit id="0f847cce0d292ae271a717b61d78816a1f1ea3fd" translate="yes" xml:space="preserve">
          <source>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</source>
          <target state="translated">右侧的路径将始终被扩展为相对格式,并且在连接时,任何尾部的斜线都将被删除。</target>
        </trans-unit>
        <trans-unit id="643a7d1289fc8c2df27def8f3faf469415ebab11" translate="yes" xml:space="preserve">
          <source>The right side of &lt;code&gt;.&lt;/code&gt; may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</source>
          <target state="translated">的右侧 &lt;code&gt;.&lt;/code&gt; 可以是以大写字母开头（代表别名）的单词，以小写字母或下划线开头的单词，任何有效的语言运算符或任何用单引号或双引号引起来的名称。这些都是有效的示例：</target>
        </trans-unit>
        <trans-unit id="c04e1c8f69c2f1a88e36a20e9901940c66e8dcfe" translate="yes" xml:space="preserve">
          <source>The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">四舍五入的方向总是与半上挂钩。该操作是在二进制浮点数上进行的,没有转换为十进制。</target>
        </trans-unit>
        <trans-unit id="4144dd4219963dfd0900f8f0b48ec21d6f4d014e" translate="yes" xml:space="preserve">
          <source>The router will check the first byte of the bucket name against the table and dispatch to the appropriate node based on that. For example, a bucket starting with the letter &amp;ldquo;a&amp;rdquo; (&lt;code&gt;?a&lt;/code&gt; represents the Unicode codepoint of the letter &amp;ldquo;a&amp;rdquo;) will be dispatched to node &lt;code&gt;foo@computer-name&lt;/code&gt;.</source>
          <target state="translated">路由器将对照表检查存储桶名称的第一个字节，并根据该表将其分发到适当的节点。例如，以字母&amp;ldquo; a&amp;rdquo;（ &lt;code&gt;?a&lt;/code&gt; 代表字母&amp;ldquo; a&amp;rdquo; 的Unicode代码点）开头的存储桶将被分派到节点 &lt;code&gt;foo@computer-name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff8ac86ff623f4bf3fb0733f54cbe348a65e9dc" translate="yes" xml:space="preserve">
          <source>The routing layer will receive a routing table of the following format:</source>
          <target state="translated">路由层将收到一个格式如下的路由表。</target>
        </trans-unit>
        <trans-unit id="4c154bbe6784f06daaef10626cc0bf86a4376497" translate="yes" xml:space="preserve">
          <source>The same applies to duplicate registries:</source>
          <target state="translated">这同样适用于重复的登记册。</target>
        </trans-unit>
        <trans-unit id="8461a29f68bfc60f9acb948d5fe98c088c56fd3e" translate="yes" xml:space="preserve">
          <source>The same applies to maps where each pair is treated as a list of tuples with two elements:</source>
          <target state="translated">同样的道理也适用于地图,在地图中,每个对子都被视为具有两个元素的图元组列表。</target>
        </trans-unit>
        <trans-unit id="b487f77f15de12365c59e270fe90d68cbbe73146" translate="yes" xml:space="preserve">
          <source>The same applies to qualified calls such as &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt;, which is the same as &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt;. However, remember parentheses are not optional for non-qualified calls with no arguments, such as &lt;code&gt;sum()&lt;/code&gt;. Removing the parentheses for &lt;code&gt;sum&lt;/code&gt; causes it to be represented as the variable &lt;code&gt;sum&lt;/code&gt;, which means they would be no longer equivalent.</source>
          <target state="translated">这同样适用于限定调用，例如 &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt; ，与 &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt; 相同。但是，请记住，对于没有参数的非限定调用 &lt;code&gt;sum()&lt;/code&gt; 例如sum（）），括号不是可选的。卸下的括号 &lt;code&gt;sum&lt;/code&gt; 导致它被表示为变量 &lt;code&gt;sum&lt;/code&gt; ，这意味着它们将不再相等。</target>
        </trans-unit>
        <trans-unit id="47e032a5027ea138ef1f6dce21b412d852e000c1" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cd/1&quot;&gt; &lt;code&gt;cd/1&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="18e01d0d75a4c60af88fee26dd31622d04f96a97" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;bytes_copied&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cf6de4f99822a7c8fe3b408ab5d4cf7f42930ca" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f92c875af9b9262d24ee988fee5dadfcecefeb5a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#cp_r/3&quot;&gt; &lt;code&gt;cp_r/3&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt;异常。否则返回复制文件的列表。</target>
        </trans-unit>
        <trans-unit id="f459fdf18e68c368ea8cc4aa8ed5c7cc8b9dd88a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">与&lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;cwd/0&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="e983c20087a73c47c1b91cd7c2c300a823c39d00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="translated">与&lt;a href=&quot;#ls/1&quot;&gt; &lt;code&gt;ls/1&lt;/code&gt; &lt;/a&gt;相同，但是在发生错误的情况下引发&lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="94d50f21dfa011da9b3d948e9722047f3d7526a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出任何无效的选项，则会引发&lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="a5050ef6fcebfe967949f495038b1cf5998440f0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;相同，但是如果给出了任何无效的选项，则会引发&lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="44ad2c47fd323d50a1b7a9d773f54ea42bbc2572" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="translated">与&lt;a href=&quot;#read_imports!/2&quot;&gt; &lt;code&gt;read_imports!/2&lt;/code&gt; &lt;/a&gt;相同，但只返回给定文件中的配置，而不返回导入的路径。</target>
        </trans-unit>
        <trans-unit id="76551e442cf0920ecab6d0eb8ea56bcf94c15620" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.renameerror&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">与&lt;a href=&quot;#rename/2&quot;&gt; &lt;code&gt;rename/2&lt;/code&gt; &lt;/a&gt;相同，但是如果失败则引发&lt;a href=&quot;file.renameerror&quot;&gt; &lt;code&gt;File.RenameError&lt;/code&gt; &lt;/a&gt;异常。否则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff7e3f389bbffc2c11af04820517b44446f5b5b0" translate="yes" xml:space="preserve">
          <source>The second approach uses function calls which better suits more complex APIs (for example, if you need to pass many options) and reads nicely in Elixir thanks to the pipe operator.</source>
          <target state="translated">第二种方法使用函数调用,它更适合更复杂的API(例如,如果你需要传递许多选项),并且由于管道操作符的存在,在Elixir中也能很好地读取。</target>
        </trans-unit>
        <trans-unit id="4989f7d201fe4b48e470058521e1ca80ae6c9569" translate="yes" xml:space="preserve">
          <source>The second argument is a keyword list of options:</source>
          <target state="translated">第二个参数是一个关键词的选项列表。</target>
        </trans-unit>
        <trans-unit id="43642aa7f67e7784c0b111753a92ead35aec4a5a" translate="yes" xml:space="preserve">
          <source>The second argument is either a timeout or &lt;code&gt;:brutal_kill&lt;/code&gt;. In case of a timeout, a &lt;code&gt;:shutdown&lt;/code&gt; exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With &lt;code&gt;:brutal_kill&lt;/code&gt; the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</source>
          <target state="translated">第二个参数是超时或 &lt;code&gt;:brutal_kill&lt;/code&gt; 。在超时的情况下， &lt;code&gt;:shutdown&lt;/code&gt; 退出信号被发送到任务进程，如果在超时时间内没有退出，则该信号被杀死。使用 &lt;code&gt;:brutal_kill&lt;/code&gt; 可以立即杀死任务。万一任务异常终止（可能被另一个进程终止），该功能将以相同的原因退出。</target>
        </trans-unit>
        <trans-unit id="fcb757bd7051270d8c819a13491903d89a8704fd" translate="yes" xml:space="preserve">
          <source>The second argument is first expanded to an absolute path.</source>
          <target state="translated">第二个参数首先扩展为绝对路径。</target>
        </trans-unit>
        <trans-unit id="524ef427f3aceff5423ab5acc031269f5e3169df" translate="yes" xml:space="preserve">
          <source>The second argument specifying every &lt;code&gt;nth&lt;/code&gt; element must be a non-negative integer.</source>
          <target state="translated">指定每个 &lt;code&gt;nth&lt;/code&gt; 元素的第二个参数必须是非负整数。</target>
        </trans-unit>
        <trans-unit id="6a6d508d801e049e82fe48d35683e28b76dc2200" translate="yes" xml:space="preserve">
          <source>The second change is in the &lt;code&gt;application&lt;/code&gt; function inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">第二个变化是在 &lt;code&gt;mix.exs&lt;/code&gt; 内部的 &lt;code&gt;application&lt;/code&gt; 函数中：</target>
        </trans-unit>
        <trans-unit id="36314cd4001b7103421433826074baa427430f61" translate="yes" xml:space="preserve">
          <source>The second concern is that, while using &lt;code&gt;mix run&lt;/code&gt; is completely fine to run our software in production, the command we use to start our services is getting increasingly more complex. For example, imagine we also want to &lt;code&gt;--preload-modules&lt;/code&gt;, to all code is loaded upfront, as well as set the &lt;code&gt;MIX_ENV=prod&lt;/code&gt; environment variable:</source>
          <target state="translated">第二个担忧是，尽管使用 &lt;code&gt;mix run&lt;/code&gt; 在生产环境中运行我们的软件完全可以，但是用于启动服务的命令却变得越来越复杂。例如，假设我们还想要 &lt;code&gt;--preload-modules&lt;/code&gt; ，以将所有代码预先加载，并设置 &lt;code&gt;MIX_ENV=prod&lt;/code&gt; 环境变量：</target>
        </trans-unit>
        <trans-unit id="59db642f7ebf3826674361ba0acf5de33120795d" translate="yes" xml:space="preserve">
          <source>The second definition matches the pattern and has no guard so it will be executed. It first prints our &lt;code&gt;msg&lt;/code&gt; and then calls itself passing &lt;code&gt;n - 1&lt;/code&gt; (&lt;code&gt;2&lt;/code&gt;) as the second argument.</source>
          <target state="translated">第二个定义与模式匹配并且没有保护，因此它将被执行。它首先打印我们的 &lt;code&gt;msg&lt;/code&gt; ，然后通过第二个参数 &lt;code&gt;n - 1&lt;/code&gt; （ &lt;code&gt;2&lt;/code&gt; ）调用自身。</target>
        </trans-unit>
        <trans-unit id="dae9460a51adde13fd535bc1aee22f1354a6ed7b" translate="yes" xml:space="preserve">
          <source>The second element is a keyword list containing metadata, like numbers and contexts;</source>
          <target state="translated">第二个元素是包含元数据的关键字列表,如数字和上下文。</target>
        </trans-unit>
        <trans-unit id="09930d4769fdab8c631461548dda5978d0ffac47" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents metadata.</source>
          <target state="translated">元组的第二个元素代表元数据。</target>
        </trans-unit>
        <trans-unit id="49369ce9190f9083bafea50347ba1f7b69ded63d" translate="yes" xml:space="preserve">
          <source>The second flaw is related to the supervision strategy. If &lt;code&gt;KV.Registry&lt;/code&gt; dies, all information linking &lt;code&gt;KV.Bucket&lt;/code&gt; names to bucket processes is lost. Therefore the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; and all children must terminate too - otherwise we will have orphan processes.</source>
          <target state="translated">第二个缺陷与监管策略有关。如果 &lt;code&gt;KV.Registry&lt;/code&gt; 死亡， &lt;code&gt;KV.Bucket&lt;/code&gt; 名称链接到存储桶进程的所有信息都将丢失。因此， &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 和所有子代也必须终止-否则我们将具有孤立进程。</target>
        </trans-unit>
        <trans-unit id="1b27ec208e18d1eae9448f08cbc57e44112bc1f3" translate="yes" xml:space="preserve">
          <source>The second is to make sure your &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did:</source>
          <target state="translated">第二个是确保您的&lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; &lt;/a&gt;调用没有通配符。如果是这样，则需要手动执行通配符查找。例如，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="03c8c69c3a8917dcc36201eb8826bb675ed3a306" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">第二部分，保护措施，是允许过滤结果的条件列表。每个防护是一个元组，它描述应该由模式的指定部分通过的检查。例如， &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 保护条件将表示为 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 元组。请注意，警戒条件只会工作，像赋值的变量 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ， &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; ，等等。</target>
        </trans-unit>
        <trans-unit id="8279ae6c0770b2c5c483279a964f5a0fd686e18a" translate="yes" xml:space="preserve">
          <source>The second pitfall is that the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator works on calls. For example, when you write:</source>
          <target state="translated">第二个陷阱是 &lt;code&gt;|&amp;gt;&lt;/code&gt; 运算符可用于通话。例如，当您编写时：</target>
        </trans-unit>
        <trans-unit id="494117d2d88c4ce9741e6ac16716fddbb8f4cbe4" translate="yes" xml:space="preserve">
          <source>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</source>
          <target state="translated">第二个原则是尽可能少地提供配置。这样可以通过消除争议点来简化formatter的采用,同时确保整个社区一致遵循单一风格。</target>
        </trans-unit>
        <trans-unit id="661a367f5412305ec9e82e19ba1e4e566dc26d28" translate="yes" xml:space="preserve">
          <source>The second test checks that the code raises for unknown entries.</source>
          <target state="translated">第二个测试检查代码是否会引发未知条目。</target>
        </trans-unit>
        <trans-unit id="8cd7d01257f835cc5a3247359bf87ad73936ce2f" translate="yes" xml:space="preserve">
          <source>The server is now running, and you will even notice the console is blocked. Let&amp;rsquo;s use &lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;a &lt;code&gt;telnet&lt;/code&gt; client&lt;/a&gt; to access our server. There are clients available on most operating systems, and their command lines are generally similar:</source>
          <target state="translated">服务器现在正在运行，您甚至会注意到控制台已被阻止。让我们用&lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;一个 &lt;code&gt;telnet&lt;/code&gt; 客户端&lt;/a&gt;来访问我们的服务器。大多数操作系统上都有可用的客户端，它们的命令行通常类似：</target>
        </trans-unit>
        <trans-unit id="fd585ae8b1d0205e194512ad32642a694a88c604" translate="yes" xml:space="preserve">
          <source>The server reference.</source>
          <target state="translated">服务器参考。</target>
        </trans-unit>
        <trans-unit id="d40bf167b8d71e1dda39cd357ab868e4586251d2" translate="yes" xml:space="preserve">
          <source>The server responsibilities include:</source>
          <target state="translated">服务器的职责包括:</target>
        </trans-unit>
        <trans-unit id="ff65793db264093aa3a7a1cf46e0cbfc1e4b8a04" translate="yes" xml:space="preserve">
          <source>The setup callbacks are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as &lt;code&gt;context&lt;/code&gt;. The context to be used in the tests can be optionally extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="translated">设置回调是通过宏定义的，每个回调都可以选择接收包含测试状态和元数据（通常称为 &lt;code&gt;context&lt;/code&gt; )的映射。通过返回正确的结构化值（请参阅下文），安装程序回调可以扩展在测试中使用的上下文。</target>
        </trans-unit>
        <trans-unit id="be70f07b576f3a68fa738cef7302c8e28346ebfb" translate="yes" xml:space="preserve">
          <source>The shutdown process happens in reverse order.</source>
          <target state="translated">关机过程以相反的顺序进行。</target>
        </trans-unit>
        <trans-unit id="a344948a2691ee6269fc2879136d40e4dca1f373" translate="yes" xml:space="preserve">
          <source>The size can be a variable:</source>
          <target state="translated">大小可以是一个变量。</target>
        </trans-unit>
        <trans-unit id="8111a6aa75f3c6e4735d59b2e853a7faeadebe29" translate="yes" xml:space="preserve">
          <source>The size of a map is the number of key-value pairs that the map contains.</source>
          <target state="translated">地图的大小是指地图包含的键值对的数量。</target>
        </trans-unit>
        <trans-unit id="0078ede4075127860c2ade218ba7d232c2981cd7" translate="yes" xml:space="preserve">
          <source>The snippet above only works because numbers implement the &lt;code&gt;String.Chars&lt;/code&gt; protocol. Passing a tuple, for example, will lead to an error:</source>
          <target state="translated">上面的代码段仅适用于数字实现 &lt;code&gt;String.Chars&lt;/code&gt; 协议的情况。例如，传递元组将导致错误：</target>
        </trans-unit>
        <trans-unit id="6272c1202f90648d2a2419029598638bd1dd5c26" translate="yes" xml:space="preserve">
          <source>The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument:</source>
          <target state="translated">解决的办法是尽可能地在使用的地方提供配置,而不是通过应用环境。在函数的情况下,你可以期待关键字列表作为一个新的参数。</target>
        </trans-unit>
        <trans-unit id="2c2456d942f9ee207983a501b269e82c8ae7c4b6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm will be stable as long as the given function returns &lt;code&gt;true&lt;/code&gt; for values considered equal:</source>
          <target state="translated">只要给定函数对于认为相等的值返回 &lt;code&gt;true&lt;/code&gt; ，排序算法将保持稳定：</target>
        </trans-unit>
        <trans-unit id="972944894d27378714ceb941dffde3e2074c4f7f" translate="yes" xml:space="preserve">
          <source>The spec also provides a &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; set but Elixir does not include any character on this set. Therefore the identifier rule has been simplified to consider this.</source>
          <target state="translated">规范还提供了 &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; 集，但Elixir在此集上不包含任何字符。因此，简化了标识符规则以考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="fc80cf8cc0e875b59d4cb7a74f58a13e82e8e79b" translate="yes" xml:space="preserve">
          <source>The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching.</source>
          <target state="translated">堆栈是列表的一个小包装。它允许我们把一个元素放在堆栈的顶部,通过预置到列表中,并通过模式匹配获得堆栈的顶部。</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="c90a34e2afaa39e30146b58a596138ac46c6ee44" translate="yes" xml:space="preserve">
          <source>The steps necessary to work across nodes is already commented out as an example. You can enable full distribution by uncommenting the last two lines by removing the leading &lt;code&gt;# &lt;/code&gt;.</source>
          <target state="translated">作为示例，已经注释了跨节点工作所需的步骤。您可以通过删除开头的 &lt;code&gt;# &lt;/code&gt; 取消对最后两行的注释，从而启用完全分发。</target>
        </trans-unit>
        <trans-unit id="6547b77a17d5ef12542c7afee97cc798fc8b1249" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="translated">该流同时实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议，这意味着它可用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="d0a2b7409cbfc04d5907be0d98cbcaddcde54753" translate="yes" xml:space="preserve">
          <source>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt;&lt;code&gt;node/0&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">提示中括号之间的字符串是您节点的名称。我们可以通过调用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt; &lt;code&gt;node/0&lt;/code&gt; &lt;/a&gt;函数来检索它：</target>
        </trans-unit>
        <trans-unit id="81e25ea527122c6269507a786b1fac990f5269a4" translate="yes" xml:space="preserve">
          <source>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</source>
          <target state="translated">字符串串联使代码适合于单行,也给formatter提供了更多的选择。</target>
        </trans-unit>
        <trans-unit id="86cdec7e4462e9309a1a4eb1db8bbf7175736e0b" translate="yes" xml:space="preserve">
          <source>The string concatenation operation is actually a binary concatenation operator:</source>
          <target state="translated">字符串连接操作实际上是一个二进制连接操作符。</target>
        </trans-unit>
        <trans-unit id="8259167cccd8df309147297c84a34df6a1de5df3" translate="yes" xml:space="preserve">
          <source>The string is split into as many parts as possible by default, but can be controlled via the &lt;code&gt;:parts&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，该字符串被分成尽可能多的部分，但是可以通过 &lt;code&gt;:parts&lt;/code&gt; 选项控制。</target>
        </trans-unit>
        <trans-unit id="ff34135d2b9fe9bf18a8b4692de3737dabb31735" translate="yes" xml:space="preserve">
          <source>The struct fields are private and should not be accessed.</source>
          <target state="translated">该结构的字段是私有的,不应该被访问。</target>
        </trans-unit>
        <trans-unit id="571837e3b232d92d474e8917fdedc1786ba58276" translate="yes" xml:space="preserve">
          <source>The struct fields can be given when building the struct:</source>
          <target state="translated">在构建结构时可以给定结构字段。</target>
        </trans-unit>
        <trans-unit id="92bf51de3e3e5df1170754020b84a38130fd526e" translate="yes" xml:space="preserve">
          <source>The supervision strategy dictates what happens when one of the children crashes. &lt;code&gt;:one_for_one&lt;/code&gt; means that if a child dies, it will be the only one restarted. Since we have only one child now, that&amp;rsquo;s all we need. The &lt;code&gt;Supervisor&lt;/code&gt; behaviour supports many different strategies and we will discuss them in this chapter.</source>
          <target state="translated">监督策略规定了其中一个孩子撞车时会发生什么。 &lt;code&gt;:one_for_one&lt;/code&gt; 表示如果一个孩子死亡，它将是唯一重启的孩子。由于我们现在只有一个孩子，这就是我们所需要的。该 &lt;code&gt;Supervisor&lt;/code&gt; 的行为支持许多不同的策略，我们将在本章讨论。</target>
        </trans-unit>
        <trans-unit id="d45ea759f46bff3ba089e89707b504285b2e2aff" translate="yes" xml:space="preserve">
          <source>The supervisor flags returned on init</source>
          <target state="translated">启动时返回的主管标志</target>
        </trans-unit>
        <trans-unit id="e3742ff69698c4acf77e80f28496fe07172ab4b1" translate="yes" xml:space="preserve">
          <source>The supervisor reference</source>
          <target state="translated">监理参考</target>
        </trans-unit>
        <trans-unit id="5aec5d17ff71d8a46be456b119441ed148f52e07" translate="yes" xml:space="preserve">
          <source>The supervisor specification</source>
          <target state="translated">监理规范</target>
        </trans-unit>
        <trans-unit id="55243bfac4a971c230124af0cb70d274159f15f1" translate="yes" xml:space="preserve">
          <source>The supervisor will then invoke &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; to retrieve a child specification. Now the &lt;code&gt;Stack&lt;/code&gt; module is responsible for building its own specification, for example, we could write:</source>
          <target state="translated">然后，主管将调用 &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; 来检索子规范。现在， &lt;code&gt;Stack&lt;/code&gt; 模块负责构建自己的规范，例如，我们可以编写：</target>
        </trans-unit>
        <trans-unit id="48df4bde49257478d542a437f9de2f0a2ea29a61" translate="yes" xml:space="preserve">
          <source>The supported class names are:</source>
          <target state="translated">支持的类名有:</target>
        </trans-unit>
        <trans-unit id="2acb742979d49cdd1ce894f691b11d6c69ead543" translate="yes" xml:space="preserve">
          <source>The supported forms are:</source>
          <target state="translated">支持的形式有:</target>
        </trans-unit>
        <trans-unit id="a8f9a7d8961a3767298fcfbab64cbbb6e0e6ee0b" translate="yes" xml:space="preserve">
          <source>The supported keys in the &lt;code&gt;:colors&lt;/code&gt; keyword list are:</source>
          <target state="translated">&lt;code&gt;:colors&lt;/code&gt; 关键字列表中支持的键是：</target>
        </trans-unit>
        <trans-unit id="b7878d33057652c5e4e57d591e83ecedf612c203" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by precedence, are:</source>
          <target state="translated">支持的级别按优先顺序排列如下:</target>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">支持的选项有:</target>
        </trans-unit>
        <trans-unit id="a909fba4eceb102c979e5e9c2b15d4702c456bf4" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (e.g., &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">Elixir提供的用于类型说明的语法类似于&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;Erlang中&lt;/a&gt;的语法。 Erlang提供的大多数内置类型（例如 &lt;code&gt;pid()&lt;/code&gt; ）都以相同的方式表示： &lt;code&gt;pid()&lt;/code&gt; （或简称为 &lt;code&gt;pid&lt;/code&gt; ）。还支持参数化类型（例如 &lt;code&gt;list(integer)&lt;/code&gt; ），也支持远程类型（例如 &lt;code&gt;Enum.t&lt;/code&gt; ）。允许使用整数和原子文字作为类型（例如 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;:atom&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。所有其他类型都是根据预定义类型的并集构建的。允许使用一些简写形式，例如 &lt;code&gt;[...]&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d0036cfb43509daaf5a87c862104d3f9568ed85" translate="yes" xml:space="preserve">
          <source>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the &lt;code&gt;:c&lt;/code&gt; key failed because there is no &lt;code&gt;:c&lt;/code&gt; in the map.</source>
          <target state="translated">上面的语法要求给定密钥存在。它不能用于添加新密钥。例如，将其与 &lt;code&gt;:c&lt;/code&gt; 键一起使用失败，因为映射中没有 &lt;code&gt;:c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e74604ffed887af469a3ff79efc01a49993440e8" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;badstructerror&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">上面的语法将确保给定的键在编译时有效，并且将在运行时保证给定的参数是一个结构，否则将&lt;a href=&quot;badstructerror&quot;&gt; &lt;code&gt;BadStructError&lt;/code&gt; &lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="15e9fc5e9c4c2be91d093aa25daa8c7249775f24" translate="yes" xml:space="preserve">
          <source>The tail elements of aliases are guaranteed to always be atoms.</source>
          <target state="translated">保证别名的尾元素永远是原子。</target>
        </trans-unit>
        <trans-unit id="0bcdf2274bc91e89bdf8524fe117cd1e390a0aae" translate="yes" xml:space="preserve">
          <source>The task can now be invoked with &lt;code&gt;mix hello&lt;/code&gt;.</source>
          <target state="translated">现在可以使用 &lt;code&gt;mix hello&lt;/code&gt; 调用该任务。</target>
        </trans-unit>
        <trans-unit id="60d7de295785ea0605333a1eba6bb25d621b6acc" translate="yes" xml:space="preserve">
          <source>The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, &lt;code&gt;1 == 1.0&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but since they are of different types, &lt;code&gt;1 === 1.0&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果这些术语具有相同的值和相同的类型，则仅被视为完全相等。例如， &lt;code&gt;1 == 1.0&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，但是由于它们的类型不同， &lt;code&gt;1 === 1.0&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="705df9c2e6adef6ee615fd1500b80411120b3a6b" translate="yes" xml:space="preserve">
          <source>The test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.</source>
          <target state="translated">上面的测试将在最后一个断言上失败,因为即使我们停止了 bucket 进程,bucket 名称仍然在注册表中。</target>
        </trans-unit>
        <trans-unit id="2570223385e731ad04d7b7880f45f2e4a73c2ce4" translate="yes" xml:space="preserve">
          <source>The test is similar to &amp;ldquo;removes bucket on exit&amp;rdquo; except that we are being a bit more harsh by sending &lt;code&gt;:shutdown&lt;/code&gt; as the exit reason instead of &lt;code&gt;:normal&lt;/code&gt;. If a process terminates with a reason different than &lt;code&gt;:normal&lt;/code&gt;, all linked processes receive an EXIT signal, causing the linked process to also terminate unless it is trapping exits.</source>
          <target state="translated">该测试类似于&amp;ldquo;在退出时删除存储桶&amp;rdquo;，不同之处在于，通过发送 &lt;code&gt;:shutdown&lt;/code&gt; 作为退出原因而不是 &lt;code&gt;:normal&lt;/code&gt; 更加苛刻。如果某个进程由于不同于 &lt;code&gt;:normal&lt;/code&gt; 的原因而终止，则所有链接的进程都会收到EXIT信号，从而导致该链接的进程也终止，除非它正在捕获退出。</target>
        </trans-unit>
        <trans-unit id="bdde6c13039b2d4b85652376fce95fabfa20deef" translate="yes" xml:space="preserve">
          <source>The test should pass.</source>
          <target state="translated">测试应该会通过。</target>
        </trans-unit>
        <trans-unit id="3bf29b425a5cead446e53e0022f0fce0236e0195" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;exunit#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="translated">测试类型将转换为字符串并进行复数显示。您可以使用&lt;a href=&quot;exunit#plural_rule/2&quot;&gt; &lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt; &lt;/a&gt;设置自定义复数。</target>
        </trans-unit>
        <trans-unit id="a927d1705beb862013fa4736d80e7112683437e5" translate="yes" xml:space="preserve">
          <source>The third approach uses macros, and is by far the most complex. It will take more lines of code to implement, it is hard and expensive to test (compared to testing simple functions), and it limits how the user may use the library since all validations need to be defined inside a module.</source>
          <target state="translated">第三种方法使用宏,是迄今为止最复杂的方法。它需要更多的代码行来实现,它的测试难度大,成本高(与测试简单的函数相比),而且它限制了用户使用库的方式,因为所有的验证都需要在一个模块中定义。</target>
        </trans-unit>
        <trans-unit id="1d45004d92cd0fa8dd37a67dc40c34ac5fe7a8f6" translate="yes" xml:space="preserve">
          <source>The third argument given to &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary.</source>
          <target state="translated">给&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt;的第三个参数是与当前进程关联的值。尽管在上一节中我们在调度时使用了它，但在这个特定示例中，我们对此不感兴趣，因此我们将其设置为空列表。如有必要，您可以存储更有意义的值。</target>
        </trans-unit>
        <trans-unit id="286a4f81139162ba612e0fc78d910245b92506ae" translate="yes" xml:space="preserve">
          <source>The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.</source>
          <target state="translated">第三个参数是stacktrace,用来给归一化的错误添加更多信息。它只在错误类型时使用。</target>
        </trans-unit>
        <trans-unit id="b0469bb3fc164355009dcbe32b659229c5de7434" translate="yes" xml:space="preserve">
          <source>The third element is either a list of arguments for the function call or an atom. When this element is an atom, it means the tuple represents a variable.</source>
          <target state="translated">第三个元素是函数调用的参数列表或原子。当这个元素是一个原子时,它意味着元组代表一个变量。</target>
        </trans-unit>
        <trans-unit id="61d0bd68d9312dd1a2b6bc353f3631650af592e9" translate="yes" xml:space="preserve">
          <source>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).</source>
          <target state="translated">元组的第三个元素是函数调用的参数。第三个参数可能是一个原子,它通常是一个变量(或一个局部调用)。</target>
        </trans-unit>
        <trans-unit id="e03e20762e8bbf0a5e287057fa9da1be08a2ebb0" translate="yes" xml:space="preserve">
          <source>The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt;, assuming you bound those variables in order in the match part, you would provide a body like &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt;. Like guards, you can use some operations like &lt;code&gt;:element&lt;/code&gt; to modify the output format.</source>
          <target state="translated">第三部分，主体，是返回条目的形状的列表。像警卫一样，您可以访问分配的变量，如 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; ，可以将其与硬编码的值组合以自由调整条目的形状。请注意，元组必须包装在其他元组中。要获得类似 &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt; 的结果格式，假设您按顺序在匹配部分中绑定了这些变量，则应提供一个类似于 &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt; 。与警卫一样，您可以使用诸如 &lt;code&gt;:element&lt;/code&gt; 之类的一些操作来修改输出格式。</target>
        </trans-unit>
        <trans-unit id="dd8a93e3bf717eed4a2e3026f8f31870641fb464" translate="yes" xml:space="preserve">
          <source>The time functions in this module work in the &lt;code&gt;:native&lt;/code&gt; unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the &lt;code&gt;:native&lt;/code&gt; unit, to avoid loss of precision, with &lt;a href=&quot;#convert_time_unit/3&quot;&gt;&lt;code&gt;convert_time_unit/3&lt;/code&gt;&lt;/a&gt; being invoked at the end to convert to a specific time unit like &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:microsecond&lt;/code&gt;. See the &lt;a href=&quot;#t:time_unit/0&quot;&gt;&lt;code&gt;time_unit/0&lt;/code&gt;&lt;/a&gt; type for more information.</source>
          <target state="translated">该模块中的时间功能以 &lt;code&gt;:native&lt;/code&gt; 单位（除非另有说明）工作，这取决于操作系统。大多数时候，所有计算都以 &lt;code&gt;:native&lt;/code&gt; 单位进行，以避免精度损失，最后会调用&lt;a href=&quot;#convert_time_unit/3&quot;&gt; &lt;code&gt;convert_time_unit/3&lt;/code&gt; &lt;/a&gt;转换为特定的时间单位，如 &lt;code&gt;:millisecond&lt;/code&gt; 或 &lt;code&gt;:microsecond&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;#t:time_unit/0&quot;&gt; &lt;code&gt;time_unit/0&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="c81a5f56c30620f4ca3fdbd7994e540bcd3307ec" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in options. &lt;code&gt;{:time, type}&lt;/code&gt; where type can be &lt;code&gt;:local&lt;/code&gt;, &lt;code&gt;:universal&lt;/code&gt;, or &lt;code&gt;:posix&lt;/code&gt;. Default is &lt;code&gt;:universal&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中返回的时间类型取决于在options中设置的时间类型。 &lt;code&gt;{:time, type}&lt;/code&gt; ，其中type可以是 &lt;code&gt;:local&lt;/code&gt; ， &lt;code&gt;:universal&lt;/code&gt; 或 &lt;code&gt;:posix&lt;/code&gt; 。默认是 &lt;code&gt;:universal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ccc7b51abb959b7b6a642bc36ea122d38002d9a" translate="yes" xml:space="preserve">
          <source>The time unit to be passed to functions like &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">要传递给诸如&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; 之&lt;/a&gt;类的函数的时间单位。</target>
        </trans-unit>
        <trans-unit id="1bbd3b4515f159eff3b51909840a9c295b77b423" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</source>
          <target state="translated">根据IANA tz数据库的时区ID(如欧洲/苏黎世)。</target>
        </trans-unit>
        <trans-unit id="b125596c86be66bad3036f66746716d52648f027" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds</source>
          <target state="translated">时区UTC偏移量(秒)</target>
        </trans-unit>
        <trans-unit id="4a33e0326e0255c69b66326b76b995f67cc50bc7" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (e.g. CET or CEST or BST etc.)</source>
          <target state="translated">时区缩写(如CET或CEST或BST等)</target>
        </trans-unit>
        <trans-unit id="fcad795376e4abb458cc8e3841c41b9eba5c998c" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (not zero in summer times)</source>
          <target state="translated">时区标准偏移量,以秒为单位(夏季不为零)。</target>
        </trans-unit>
        <trans-unit id="cce73f4a8a7c3c6d7d87f75bc5aa727351d2f2f2" translate="yes" xml:space="preserve">
          <source>The timer will be automatically canceled if the given &lt;code&gt;dest&lt;/code&gt; is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when &lt;code&gt;dest&lt;/code&gt; is an atom (as the atom resolution is done on delivery).</source>
          <target state="translated">如果给定的 &lt;code&gt;dest&lt;/code&gt; 是一个未激活的PID或给定的PID退出，则计时器将自动取消。请注意，当 &lt;code&gt;dest&lt;/code&gt; 是一个原子时，计时器将不会自动取消（因为原子分辨率是在交付时完成的）。</target>
        </trans-unit>
        <trans-unit id="95f67c03b8dd416c9af30e47423ea3401d29e99a" translate="yes" xml:space="preserve">
          <source>The trait can be one of two options:</source>
          <target state="translated">该性状可以是两个选项之一。</target>
        </trans-unit>
        <trans-unit id="8c51e1e67805ed16c58e9c1e802e36335ea6aca4" translate="yes" xml:space="preserve">
          <source>The trouble with state</source>
          <target state="translated">国家的问题</target>
        </trans-unit>
        <trans-unit id="a1d02c2f92fc207d7072d19d88bfe702734e4f16" translate="yes" xml:space="preserve">
          <source>The tuple above represents a function call to &lt;code&gt;sum&lt;/code&gt; passing 1, 2 and 3 as arguments. The tuple elements are:</source>
          <target state="translated">上面的元组表示一个函数调用， &lt;code&gt;sum&lt;/code&gt; 传递1、2和3作为参数。元组元素是：</target>
        </trans-unit>
        <trans-unit id="0be32613fcd0e0034d6c53c421573b087961e380" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keywords must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="translated">这两种语法是完全等效的。像原子一样，关键字必须由Unicode字符组成，例如字母，数字，下划线和 &lt;code&gt;@&lt;/code&gt; 。如果关键字的字符不属于上述类别，例如空格，则可以将其用引号引起来：</target>
        </trans-unit>
        <trans-unit id="7bf824f894b5901f732af99ee1c6741c2c8f9460" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="translated">访问密钥的两种语法揭示了映射的双重性质。的 &lt;code&gt;map[key]&lt;/code&gt; 语法用于可具有任意键的任何类型的，动态创建的地图。 &lt;code&gt;map.key&lt;/code&gt; 与持有预定的原子键集合的地图一起使用，该原子键预计将始终存在。通过&lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;定义的结构是此类&amp;ldquo;静态映射&amp;rdquo;的一个示例，其中的键也可以在编译时进行检查。</target>
        </trans-unit>
        <trans-unit id="27b2df44172f3a57aa97a9d731e7cf407e529ef4" translate="yes" xml:space="preserve">
          <source>The type of keys allowed on registration</source>
          <target state="translated">注册时允许的钥匙类型</target>
        </trans-unit>
        <trans-unit id="2981849bde4b665272891869623a6b0939beaaa5" translate="yes" xml:space="preserve">
          <source>The type of registry metadata keys</source>
          <target state="translated">登记处元数据键的类型</target>
        </trans-unit>
        <trans-unit id="1b222464dab205a6bd54b94d0bb3729d611af5dc" translate="yes" xml:space="preserve">
          <source>The type of registry metadata values</source>
          <target state="translated">登记处元数据值的类型</target>
        </trans-unit>
        <trans-unit id="1d6b108d320c16acf0d32c924ccacb139089d8c7" translate="yes" xml:space="preserve">
          <source>The type of the registry</source>
          <target state="translated">登记处的类型</target>
        </trans-unit>
        <trans-unit id="53279e10023dca8a2288968b9bcf710b0c986964" translate="yes" xml:space="preserve">
          <source>The type of values allowed on registration</source>
          <target state="translated">注册时允许的值的类型</target>
        </trans-unit>
        <trans-unit id="96d309a1ca8c9b49d61652c9574ee5761b49d46b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">类型 &lt;code&gt;String.t()&lt;/code&gt; 和 &lt;code&gt;binary()&lt;/code&gt; 等效于分析工具。尽管对于那些阅读文档的人， &lt;code&gt;String.t()&lt;/code&gt; 暗示它是UTF-8编码的二进制文件。</target>
        </trans-unit>
        <trans-unit id="cb8c250a62b4261ebc510b4a71573c121311d0bb" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%User{}&lt;/code&gt; 中不包含的struct字段的类型默认为 &lt;code&gt;term()&lt;/code&gt; （请参阅&lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;term/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8b47b534c105a2118838e65f4bd8f13e6c75b738" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">单位也可以是&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; 中&lt;/a&gt;的整数：</target>
        </trans-unit>
        <trans-unit id="a447ce422905d13f06edc954109b01bb1211f3ed" translate="yes" xml:space="preserve">
          <source>The unreachable and deprecated checks below happen every time your project is compiled via &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;mix compile.xref&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">每次通过&lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;mix compile.xref&lt;/code&gt; &lt;/a&gt;编译您的项目时，都会发生以下不可达和不推荐使用的检查。有关更多信息，请参见&lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f350c7b62e10906702ea9465bc4c4e8ee009110d" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;:ok&lt;/code&gt;/&lt;code&gt;:error&lt;/code&gt; tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary.</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; / &lt;code&gt;:error&lt;/code&gt; 元组的用法与该函数起作用的域有关，在这种情况下，是文件系统访问权限。无论函数名如何，错误的参数，逻辑错误，无效的选项都应引发。如有疑问，最好返回元组而不是加元，因为您库的用户始终可以匹配结果，并在必要时加元。</target>
        </trans-unit>
        <trans-unit id="f2761fc5ed5c6c550d3c3f11fa24ee7951107bd4" translate="yes" xml:space="preserve">
          <source>The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;.</source>
          <target state="translated">用户必须按Enter键或输入 &quot;y&quot;、&quot;yes&quot;、&quot;Y&quot;、&quot;YES &quot;或 &quot;Yes &quot;中的一个。</target>
        </trans-unit>
        <trans-unit id="067adddb8899b26a44c6d119cc5060679343ac3f" translate="yes" xml:space="preserve">
          <source>The valid parameters you can use are:</source>
          <target state="translated">你可以使用的有效参数有:</target>
        </trans-unit>
        <trans-unit id="3e5fe130617142d21e815f74a253669918514b41" translate="yes" xml:space="preserve">
          <source>The value emitted is &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given time until the element is streamed.</source>
          <target state="translated">发出的值为 &lt;code&gt;0&lt;/code&gt; 。此操作将在给定时间之前阻止调用者，直到流式传输元素为止。</target>
        </trans-unit>
        <trans-unit id="d90bdb7c5d59a88b306900023f5ca84001349ca6" translate="yes" xml:space="preserve">
          <source>The value is a keyword list with two possible keys representing prompt types:</source>
          <target state="translated">该值是一个关键字列表,有两个可能的键代表提示类型。</target>
        </trans-unit>
        <trans-unit id="caa6577865e36568b3711626c14e00f9b424ae56" translate="yes" xml:space="preserve">
          <source>The value is no longer a binary, but a bitstring &amp;ndash; a bunch of bits! So a binary is a bitstring where the number of bits is divisible by 8.</source>
          <target state="translated">该值不再是二进制，而是一个位串-一堆位！因此，二进制是一个位串，其中位数可以被8整除。</target>
        </trans-unit>
        <trans-unit id="3cc68a54cd0dbc959bc6164a6a2b53075dfa30ea" translate="yes" xml:space="preserve">
          <source>The values emitted are an increasing counter starting at &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given interval every time a new element is streamed.</source>
          <target state="translated">发出的值是一个从 &lt;code&gt;0&lt;/code&gt; 开始的递增计数器。每当有新元素流式传输时，此操作将以给定的时间间隔阻止调用者。</target>
        </trans-unit>
        <trans-unit id="be1b57a18ace41fb8f93930afe8b1ad887b40d1d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:case&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:case&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="3a8416871ca07e4a4f59fb2e54024c09ce510c3d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:padding&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="48b014b54ab14e39b32c6219693fd725eede8847" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:time&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; 的值可以是：</target>
        </trans-unit>
        <trans-unit id="21f3f4f945d9026f4fff4e43f08cf7f4707e46e4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;_&lt;/code&gt; is special in that it can never be read from. Trying to read from it gives a compile error:</source>
          <target state="translated">变量 &lt;code&gt;_&lt;/code&gt; 的特殊之处在于它永远无法读取。尝试从中读取会产生编译错误：</target>
        </trans-unit>
        <trans-unit id="9e1be81239623e7fbf2a82d7e2a4f2b80599067d" translate="yes" xml:space="preserve">
          <source>The variables defined inside &lt;code&gt;quote&lt;/code&gt; won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</source>
          <target state="translated">由于引用表达式中的卫生机制，因此在撬动期间在 &lt;code&gt;quote&lt;/code&gt; 内定义的变量将不可用。卫生机制会更改带引号的表达式中的变量名称，以免它们与宏用户定义的变量冲突。因此，原始名称不可用。</target>
        </trans-unit>
        <trans-unit id="1d0b621f78879c76c317ddf557989e7b4d0a18c9" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="translated">版本由&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;结构表示，字段根据SemVer &lt;code&gt;:major&lt;/code&gt; ， &lt;code&gt;:minor&lt;/code&gt; ， &lt;code&gt;:patch&lt;/code&gt; ， &lt;code&gt;:pre&lt;/code&gt; 和 &lt;code&gt;:build&lt;/code&gt; 命名。</target>
        </trans-unit>
        <trans-unit id="64e09f157d5e5070ea793feca6351f0810f54544" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;!&lt;/code&gt; is preferred when you want to handle different outcomes using pattern matching:</source>
          <target state="translated">没有版本 &lt;code&gt;!&lt;/code&gt; 如果您想使用模式匹配来处理不同的结果，则首选：</target>
        </trans-unit>
        <trans-unit id="e2528fcfa71e426e6f186925ba5d183a72e0825f" translate="yes" xml:space="preserve">
          <source>The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">通配符看起来就像一个普通的路径,只是下面的 &quot;通配符 &quot;会有特殊的解释。</target>
        </trans-unit>
        <trans-unit id="0fcbc9b2e71d94abc862c5aacc86295bf5f87ef7" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits and, while ISO 8601 allows datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Note leap seconds are not supported by the built-in Calendar.ISO.</source>
          <target state="translated">该函数解析的年份仅限于四位数,虽然ISO 8601允许将日期时间指定为24:00:00作为第二天的零时,但Elixir不支持这种符号。注意内置的Calendar.ISO不支持闰秒。</target>
        </trans-unit>
        <trans-unit id="43359a56ca5b9f74f8ed54225f235a4eac841d33" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits.</source>
          <target state="translated">该函数解析的年份限定为四位数。</target>
        </trans-unit>
        <trans-unit id="42c8fd279491ba3a5a79a3fc57c18b896f2e8d7e" translate="yes" xml:space="preserve">
          <source>The zip and zlib modules</source>
          <target state="translated">zip和zlib模块</target>
        </trans-unit>
        <trans-unit id="a928b0d99e54733f051669ca9f28257ad67f0a00" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable completes.</source>
          <target state="translated">拉链完成后,只要任何列举完成。</target>
        </trans-unit>
        <trans-unit id="92c61e8c081422e6cb087e5091e2eef8743332a7" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable in the given collection completes.</source>
          <target state="translated">当给定集合中的任何一个枚举完成后,拉链就完成了。</target>
        </trans-unit>
        <trans-unit id="5390d109c8d9531238497e8770981143c5154c71" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any list terminates.</source>
          <target state="translated">当任何列表终止时,拉链就结束了。</target>
        </trans-unit>
        <trans-unit id="b625dd872916e65cdac731dbaa58c2540d9b95a9" translate="yes" xml:space="preserve">
          <source>Then we define a &lt;code&gt;start_link/1&lt;/code&gt; function, which will effectively start the agent. It is a convention to define a &lt;code&gt;start_link/1&lt;/code&gt; function that always accepts a list of options. We don&amp;rsquo;t plan on using any options right now, but we might later on. We then proceed to call &lt;code&gt;Agent.start_link/1&lt;/code&gt;, which receives an anonymous function that returns the Agent&amp;rsquo;s initial state.</source>
          <target state="translated">然后，我们定义一个 &lt;code&gt;start_link/1&lt;/code&gt; 函数，它将有效地启动代理。约定定义一个 &lt;code&gt;start_link/1&lt;/code&gt; 函数，该函数始终接受选项列表。我们暂时不打算使用任何选项，但稍后可能会使用。然后，我们继续调用 &lt;code&gt;Agent.start_link/1&lt;/code&gt; ，它接收一个返回代理程序初始状态的匿名函数。</target>
        </trans-unit>
        <trans-unit id="a9efffd6370bf177135cf0838aedef8c490edaff" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider:</source>
          <target state="translated">然后在指定你的发布时,你可以指定提供者。</target>
        </trans-unit>
        <trans-unit id="90be63383bb86c2a9b4266d11b3e7f59bb1305ef" translate="yes" xml:space="preserve">
          <source>Then, we add the head of the list to the accumulator &lt;code&gt;head + accumulator&lt;/code&gt; and call &lt;code&gt;sum_list&lt;/code&gt; again, recursively, passing the tail of the list as its first argument. The tail will once again match &lt;code&gt;[head | tail]&lt;/code&gt; until the list is empty, as seen below:</source>
          <target state="translated">然后，我们将列表的开头添加到累加器的 &lt;code&gt;head + accumulator&lt;/code&gt; 并递归地再次调用 &lt;code&gt;sum_list&lt;/code&gt; ，并将列表的结尾作为第一个参数。尾巴将再次匹配 &lt;code&gt;[head | tail]&lt;/code&gt; 直到列表为空，如下所示：</target>
        </trans-unit>
        <trans-unit id="6b87f84651e39aeea5d926774256f894a29c7180" translate="yes" xml:space="preserve">
          <source>Then, whenever desired, those tests could be included in the run via the &lt;code&gt;--include&lt;/code&gt; option:</source>
          <target state="translated">然后，只要需要，就可以通过 &lt;code&gt;--include&lt;/code&gt; 选项将这些测试包括在运行中：</target>
        </trans-unit>
        <trans-unit id="b194d7af362d9259824b1fbfd5de6ca884c3d2da" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve a character integer code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="translated">有两种方法可以检索字符整数代码点。一个可以使用 &lt;code&gt;?&lt;/code&gt; 构造：</target>
        </trans-unit>
        <trans-unit id="1fd8e7b8f98e5336f83be9a7d713b450297e94ab" translate="yes" xml:space="preserve">
          <source>There are a couple other options here. One option is to spawn the distributed node programmatically at the beginning of &lt;code&gt;test/test_helper.exs&lt;/code&gt;. Erlang/OTP does provide APIs for doing so, but they are non-trivial and therefore we won&amp;rsquo;t cover them here.</source>
          <target state="translated">这里还有其他几个选择。一种选择是在 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 的开头以编程方式生成分布式节点。Erlang / OTP确实提供了这样做的API，但是它们并非易事，因此我们在这里不介绍它们。</target>
        </trans-unit>
        <trans-unit id="c36172e9cd5c05c77e84149217392745df0757dd" translate="yes" xml:space="preserve">
          <source>There are a few attributes available in Mix tasks to configure them in Mix:</source>
          <target state="translated">Mix任务中有一些属性可以在Mix中进行配置。</target>
        </trans-unit>
        <trans-unit id="29207daf154a421b800aeacb77caf5c5eb506793" translate="yes" xml:space="preserve">
          <source>There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case.</source>
          <target state="translated">有几个合适的替代方案可以取代GenEvent。其中每一种都可以根据用例成为最有利的选择。</target>
        </trans-unit>
        <trans-unit id="10bcc082a2d994b16cb89b80b77c2f9140673c29" translate="yes" xml:space="preserve">
          <source>There are a few ways to quit the IEx shell:</source>
          <target state="translated">有几种方法可以退出 IEx shell。</target>
        </trans-unit>
        <trans-unit id="7d8ce000a8dc139890c07c24e80b5de5ae99f4f0" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="translated">IEx提供了许多自定义选项。通过输入 &lt;code&gt;h IEx.configure/1&lt;/code&gt; 来查看&lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt;函数的文档。</target>
        </trans-unit>
        <trans-unit id="09d8b4775b01e8f623175d798409cd369f28544b" translate="yes" xml:space="preserve">
          <source>There are a number of ways to debug code in Elixir. In this chapter we will cover some of the more common ways of doing so.</source>
          <target state="translated">在Elixir中,有很多方法可以调试代码,本章我们将介绍一些比较常见的方法。在本章中,我们将介绍一些比较常见的方法。</target>
        </trans-unit>
        <trans-unit id="aa57737d9360fbe5afeae180cdd5ea0fce51697c" translate="yes" xml:space="preserve">
          <source>There are additional macros for other levels.</source>
          <target state="translated">还有其他级别的宏。</target>
        </trans-unit>
        <trans-unit id="a57a74b23748fb93cbfac3d76920a5b6c297f9f8" translate="yes" xml:space="preserve">
          <source>There are also other known problems like flooring or rounding numbers. See &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for more details about them.</source>
          <target state="translated">还存在其他已知问题，例如地板号或舍入数字。有关它们的更多详细信息，请参见&lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e4e195bc2fdfc89b8bda777699ef0647f0c7ff7" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还有一些不成对的函数，没有非爆炸变体。爆炸仍然表示它将在失败时引发异常。示例：&lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt; &lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5ae6e32d973b8c6e5e16938f53a6274e7ce3ca" translate="yes" xml:space="preserve">
          <source>There are currently no plans for a major v2 release.</source>
          <target state="translated">目前还没有重大的v2发布计划。</target>
        </trans-unit>
        <trans-unit id="70fbc19347af9335ddb73d64b97e33f72c2ab414" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;模块上也有与浮点数有关的功能。以下是它们的列表：</target>
        </trans-unit>
        <trans-unit id="0447596598be1689749a73489423ead2b26c8b89" translate="yes" xml:space="preserve">
          <source>There are many functions in Elixir's standard library that return streams, some examples are:</source>
          <target state="translated">在Elixir的标准库中,有很多函数可以返回流,一些例子是。</target>
        </trans-unit>
        <trans-unit id="87db69fabab6d8aebc72fcaa67f0f5d2378adab2" translate="yes" xml:space="preserve">
          <source>There are many other helpers available, here are some examples:</source>
          <target state="translated">还有很多其他的辅助工具,下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="926409681cd9a91dbce4de89116e3485c968a501" translate="yes" xml:space="preserve">
          <source>There are many situations where using the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string &lt;code&gt;prefix&lt;/code&gt; and you want to remove this prefix from another string named &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">在许多情况下，可以避免使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块，而使用二进制函数或模式匹配。例如，假设您有一个字符串 &lt;code&gt;prefix&lt;/code&gt; 并且想要从另一个名为 &lt;code&gt;full&lt;/code&gt; 的字符串中删除此前缀。</target>
        </trans-unit>
        <trans-unit id="d8989cd7033f2099b81956882184639864ede98b" translate="yes" xml:space="preserve">
          <source>There are no guarantees about the order of keys in the returned keyword.</source>
          <target state="translated">在返回的关键词中,不保证键的顺序。</target>
        </trans-unit>
        <trans-unit id="54c0f70e4a42a4d0d67a77196f05623f3bcdb80e" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones.</source>
          <target state="translated">Elixir中还有其他协议,但这涵盖了最常见的协议。</target>
        </trans-unit>
        <trans-unit id="3101471cbaca1a87da38ada818ec10b102a0a294" translate="yes" xml:space="preserve">
          <source>There are other tuple formats both &lt;code&gt;handle_call/3&lt;/code&gt; and &lt;code&gt;handle_cast/2&lt;/code&gt; callbacks may return. There are also other callbacks like &lt;code&gt;terminate/2&lt;/code&gt; and &lt;code&gt;code_change/3&lt;/code&gt; that we could implement. You are welcome to explore the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;full GenServer documentation&lt;/a&gt; to learn more about those.</source>
          <target state="translated">还有其他元组格式， &lt;code&gt;handle_call/3&lt;/code&gt; 和 &lt;code&gt;handle_cast/2&lt;/code&gt; 回调都可能返回。我们还可以实现其他回调，例如 &lt;code&gt;terminate/2&lt;/code&gt; 和 &lt;code&gt;code_change/3&lt;/code&gt; 。欢迎您浏览&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;完整的GenServer文档，&lt;/a&gt;以进一步了解这些内容。</target>
        </trans-unit>
        <trans-unit id="8c6bd7329e736075fbed60e12572ebdf4871cb55" translate="yes" xml:space="preserve">
          <source>There are probably many more to come too!</source>
          <target state="translated">可能还有更多的人要来!</target>
        </trans-unit>
        <trans-unit id="eabb9c46f92e64d3211aa2057e1cb64ad70409b3" translate="yes" xml:space="preserve">
          <source>There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:</source>
          <target state="translated">有一些模块目前Elixir还没有实现,但将来可能会实现。这些模块是保留的,定义它们会导致编译错误。</target>
        </trans-unit>
        <trans-unit id="eb77960230e6dd3139afa82409f2f1ffc3a5c2e5" translate="yes" xml:space="preserve">
          <source>There are some very well known problems with floating-point numbers and arithmetics due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.</source>
          <target state="translated">浮点数字和算术有一些众所周知的问题,因为大多数小数不能用浮点二进制表示,而且大多数运算不是精确的,而是在近似值上操作。这些问题并不是Elixir所特有的,而是浮点表示法本身的一个特性。</target>
        </trans-unit>
        <trans-unit id="e3154b8cdccf8ec261d752f5f3690d9739db0824" translate="yes" xml:space="preserve">
          <source>There are three better alternatives to &lt;code&gt;Node.spawn_link/2&lt;/code&gt; that we could use in our implementation:</source>
          <target state="translated">我们可以在实现中使用三种更好的 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 替代方案：</target>
        </trans-unit>
        <trans-unit id="0a011fd8fc19265bbdfa804b9e46482377afe2df" translate="yes" xml:space="preserve">
          <source>There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated.</source>
          <target state="translated">有三个回调在定义函数时被调用,以及在模块字节码生成之前和之后立即被调用。</target>
        </trans-unit>
        <trans-unit id="f0cff0a96056604973d2ce970f4952a288926525" translate="yes" xml:space="preserve">
          <source>There are three main use cases for not replying using the return value:</source>
          <target state="translated">使用返回值不回复主要有三种用例。</target>
        </trans-unit>
        <trans-unit id="adbd396ed0556c8293f2a87ae93d14c10746024c" translate="yes" xml:space="preserve">
          <source>There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module.</source>
          <target state="translated">有两种 API 用于处理 ports。它可以像上面的例子一样,通过消息传递进行异步操作,也可以通过调用这个模块上的函数来实现。</target>
        </trans-unit>
        <trans-unit id="701240237d3a52a3d32e044be779f88e8b80021f" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls when using the pipe operator.</source>
          <target state="translated">在使用管道运营商时,有两个常见的陷阱。</target>
        </trans-unit>
        <trans-unit id="406dbf0d435a200ca4cabd1441349a8cdaeded38" translate="yes" xml:space="preserve">
          <source>There are two concerns in this approach.</source>
          <target state="translated">这种做法有两个问题。</target>
        </trans-unit>
        <trans-unit id="5cac6c30b6750da044a369458652387600eab8a0" translate="yes" xml:space="preserve">
          <source>There are two data types without an accompanying module:</source>
          <target state="translated">有两种数据类型没有附带模块。</target>
        </trans-unit>
        <trans-unit id="b081e88ef54c7ae6048998f8dea958b729c0be39" translate="yes" xml:space="preserve">
          <source>There are two important things to consider when using &lt;code&gt;async&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;async&lt;/code&gt; 时，有两点要考虑的重要事项：</target>
        </trans-unit>
        <trans-unit id="a03d1dfcb5538f40d22abd10d512a80d2c451bc1" translate="yes" xml:space="preserve">
          <source>There are two topics left before we move on to the next chapter.</source>
          <target state="translated">在我们进入下一章之前,还剩下两个题目。</target>
        </trans-unit>
        <trans-unit id="b6bcf7cf68be2f9527622d710936107d32e56ffb" translate="yes" xml:space="preserve">
          <source>There are two types of captured functions: &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. External functions are functions residing in modules that are captured with &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt;. Local functions are anonymous functions defined with &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn/1&lt;/code&gt;&lt;/a&gt; or with the capture operator &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt;, and so on as replacements.</source>
          <target state="translated">捕获的函数有两种类型：&lt;strong&gt;external&lt;/strong&gt;和&lt;strong&gt;local&lt;/strong&gt;。外部函数是驻留在用&lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; &lt;/a&gt;捕获的模块中的函数，例如 &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt; 。局部函数是使用&lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt; &lt;code&gt;fn/1&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;&amp;amp;1&lt;/code&gt; ， &lt;code&gt;&amp;amp;2&lt;/code&gt; 等作为捕获运算符&lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; &lt;/a&gt;定义的匿名函数，以此类推。</target>
        </trans-unit>
        <trans-unit id="71487477c04c1e20b0a1c8eb6cde1dc3cb98c687" translate="yes" xml:space="preserve">
          <source>There are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server &lt;strong&gt;must&lt;/strong&gt; send a response back to such requests. While the server computes the response, the client is &lt;strong&gt;waiting&lt;/strong&gt;. Casts are asynchronous: the server won&amp;rsquo;t send a response back and therefore the client won&amp;rsquo;t wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the &lt;code&gt;:create&lt;/code&gt; messages, to be handled as cast, and on the &lt;code&gt;:lookup&lt;/code&gt; messages, to be handled as call.</source>
          <target state="translated">您可以向GenServer发送两种类型的请求：调用和强制转换。调用是同步的，服务器&lt;strong&gt;必须&lt;/strong&gt;将响应发送回此类请求。服务器计算响应时，客户端正在&lt;strong&gt;等待&lt;/strong&gt;。强制转换是异步的：服务器不会发回响应，因此客户端不会等待响应。这两个请求都是发送到服务器的消息，将按顺序处理。在上面的实现中，我们对 &lt;code&gt;:create&lt;/code&gt; 消息（将作为强制转换）和 &lt;code&gt;:lookup&lt;/code&gt; 消息（作为调用进行处理）进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="3c9ea73ebc91f0affdf337778b29e743e68daec7" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt;s in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. This:</source>
          <target state="translated">还有另一种方法可以简化防护中的 &lt;code&gt;or&lt;/code&gt; 链：Elixir支持在同一子句中编写&amp;ldquo;多个防护&amp;rdquo;。这个：</target>
        </trans-unit>
        <trans-unit id="36182dc39abbf8ba08b014521f410bb7023fa49b" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, that is rarely changed. It is set automatically based on the value in &lt;code&gt;:start&lt;/code&gt;.</source>
          <target state="translated">第六个键 &lt;code&gt;:modules&lt;/code&gt; 很少更改。它是根据 &lt;code&gt;:start&lt;/code&gt; 中的值自动设置的。</target>
        </trans-unit>
        <trans-unit id="cacb5192e79338de26b6ff207a8ab99cd8a36150" translate="yes" xml:space="preserve">
          <source>There is also a deprecated strategy called &lt;code&gt;:simple_one_for_one&lt;/code&gt; which has been replaced by the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;:simple_one_for_one&lt;/code&gt; supervisor was similar to &lt;code&gt;:one_for_one&lt;/code&gt; but suits better when dynamically attaching children. Many functions in this module behaved slightly differently when this strategy was used. See the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module for more information and migration strategies.</source>
          <target state="translated">还有一个不推荐使用的策略 &lt;code&gt;:simple_one_for_one&lt;/code&gt; ，已由&lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;取代。的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 主管是相似的 &lt;code&gt;:one_for_one&lt;/code&gt; 但西服的时候动态附加儿童更好。使用此策略时，此模块中的许多功能的行为略有不同。有关更多信息和迁移策略，请参见&lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="21605b424eea559d8c71a63a6ba5de9f7a6c7351" translate="yes" xml:space="preserve">
          <source>There is also a private function named &lt;code&gt;deps&lt;/code&gt;, which is invoked from the &lt;code&gt;project&lt;/code&gt; function, that defines our project dependencies. Defining &lt;code&gt;deps&lt;/code&gt; as a separate function is not required, but it helps keep the project configuration tidy.</source>
          <target state="translated">还有一个名为 &lt;code&gt;deps&lt;/code&gt; 的私有函数，它从 &lt;code&gt;project&lt;/code&gt; 函数中调用，它定义了我们的项目依赖项。不需要将 &lt;code&gt;deps&lt;/code&gt; 定义为单独的功能，但这有助于保持项目配置整洁。</target>
        </trans-unit>
        <trans-unit id="bb7b6e86fbf7b732fa4c4c68a1745621601d30ca" translate="yes" xml:space="preserve">
          <source>There is more to learn about &lt;code&gt;put_in/2&lt;/code&gt; and &lt;code&gt;update_in/2&lt;/code&gt;, including the &lt;code&gt;get_and_update_in/2&lt;/code&gt; that allows us to extract a value and update the data structure at once. There are also &lt;code&gt;put_in/3&lt;/code&gt;, &lt;code&gt;update_in/3&lt;/code&gt; and &lt;code&gt;get_and_update_in/3&lt;/code&gt; which allow dynamic access into the data structure. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;Check their respective documentation in the &lt;code&gt;Kernel&lt;/code&gt; module for more information&lt;/a&gt;.</source>
          <target state="translated">还有更多关于 &lt;code&gt;put_in/2&lt;/code&gt; 和 &lt;code&gt;update_in/2&lt;/code&gt; 的知识，包括 &lt;code&gt;get_and_update_in/2&lt;/code&gt; ，它使我们能够提取值并立即更新数据结构。还有 &lt;code&gt;put_in/3&lt;/code&gt; ， &lt;code&gt;update_in/3&lt;/code&gt; 和 &lt;code&gt;get_and_update_in/3&lt;/code&gt; ，它们允许动态访问数据结构。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;有关详细信息，&lt;/a&gt;请查看 &lt;code&gt;Kernel&lt;/code&gt; 模块中各自的文档。</target>
        </trans-unit>
        <trans-unit id="6b4424ea8037c81012b4a89fa0c4119c6711e1c4" translate="yes" xml:space="preserve">
          <source>There is much more to Mix, and we will continue to explore it as we build our project. A &lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;general overview is available on the Mix documentation&lt;/a&gt;. Read &lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;the Mix source code here&lt;/a&gt;.</source>
          <target state="translated">Mix还有很多，我们将在构建项目时继续探索它。一个&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;总体概述可在混合文档上&lt;/a&gt;。&lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;在此处&lt;/a&gt;阅读Mix源代码。</target>
        </trans-unit>
        <trans-unit id="237778ff123bf6054865096a64c61845e79b8f82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;try/rescue&lt;/code&gt; here. In case you want to handle multiple outcomes of opening a file, you can use pattern matching within the &lt;code&gt;case&lt;/code&gt; construct:</source>
          <target state="translated">这里没有 &lt;code&gt;try/rescue&lt;/code&gt; 。如果要处理打开文件的多种结果，可以在 &lt;code&gt;case&lt;/code&gt; 构造中使用模式匹配：</target>
        </trans-unit>
        <trans-unit id="f0bc74ac50000eb990e97f6493bd512424cfda40" translate="yes" xml:space="preserve">
          <source>There is one important difference between the &lt;code&gt;setup&lt;/code&gt; block we wrote for &lt;code&gt;KV.Registry&lt;/code&gt; and the one we wrote for &lt;code&gt;KV.Bucket&lt;/code&gt;. Instead of starting the registry by hand by calling &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;, we instead called &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;the &lt;code&gt;start_supervised!/2&lt;/code&gt; function&lt;/a&gt;, passing the &lt;code&gt;KV.Registry&lt;/code&gt; module.</source>
          <target state="translated">还有就是之间的一个重要区别 &lt;code&gt;setup&lt;/code&gt; 我们为写块 &lt;code&gt;KV.Registry&lt;/code&gt; 与大家写了一个 &lt;code&gt;KV.Bucket&lt;/code&gt; 。与其通过调用 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 手动启动注册表，我们通过传递 &lt;code&gt;KV.Registry&lt;/code&gt; 模块调用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;了 &lt;code&gt;start_supervised!/2&lt;/code&gt; 函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02df8421114d1f579a4430e4f56430c17c3fdd06" translate="yes" xml:space="preserve">
          <source>There is one project-level option that affects how the escript is generated:</source>
          <target state="translated">有一个项目级的选项会影响脚本的生成方式。</target>
        </trans-unit>
        <trans-unit id="690ca402cdab5a8902f2e2787a305dd6116dc3d0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.</source>
          <target state="translated">GenServer代码中多了不少仪式感,但正如我们将看到的,它也带来了一些好处。</target>
        </trans-unit>
        <trans-unit id="868c9d3de02a9c397e5804f3e5b1beeb25227226" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">由于许多Mix任务定义了从该配置读取的自己的选项，因此没有由 &lt;code&gt;project/0&lt;/code&gt; 返回的所有选项的完整列表。例如，查看文档中&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt;任务的&amp;ldquo;配置&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="06cb32d59125a8444c6ab67709a472cedf77eb2d" translate="yes" xml:space="preserve">
          <source>There, &lt;code&gt;byte_size/1&lt;/code&gt; counts the underlying raw bytes, and &lt;code&gt;String.length/1&lt;/code&gt; counts characters.</source>
          <target state="translated">在那里， &lt;code&gt;byte_size/1&lt;/code&gt; 计算基础裸字节，而 &lt;code&gt;String.length/1&lt;/code&gt; 计算字符。</target>
        </trans-unit>
        <trans-unit id="4307601f224307e22cd02454aa0b8b4d5545438a" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (e.g. &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;file#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">因此，不能保证在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;退出时调用Terminate &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;。由于这些原因，我们通常建议使用监视或链接本身在单独的进程中发生重要的清理规则。当&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;控制 &lt;code&gt;port&lt;/code&gt; （例如 &lt;code&gt;:gen_tcp.socket&lt;/code&gt; ）或&lt;a href=&quot;file#t:io_device/0&quot;&gt; &lt;code&gt;File.io_device/0&lt;/code&gt; 时&lt;/a&gt;，不需要清理，因为它们将在收到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的退出信号时关闭，并且不需要在Terminate &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;手动关闭。。</target>
        </trans-unit>
        <trans-unit id="f4064ff8458c4f5d1958ee9109a3740ff3b2b0e6" translate="yes" xml:space="preserve">
          <source>Therefore, an Elixir developer prefers to &amp;ldquo;let it crash&amp;rdquo; or &amp;ldquo;fail fast&amp;rdquo;. And one of the most common ways we can recover from a failure is by restarting whatever part of the system crashed.</source>
          <target state="translated">因此，Elixir开发人员更喜欢&amp;ldquo;使其崩溃&amp;rdquo;或&amp;ldquo;快速失败&amp;rdquo;。我们可以从故障中恢复的最常见方法之一是重新启动系统崩溃的任何部分。</target>
        </trans-unit>
        <trans-unit id="67da13e4777f268949639e3941225f274f61e540" translate="yes" xml:space="preserve">
          <source>Therefore, if you don&amp;rsquo;t want to handle the error outcomes, prefer using &lt;code&gt;File.read!/1&lt;/code&gt;.</source>
          <target state="translated">因此，如果您不想处理错误结果，请首选使用 &lt;code&gt;File.read!/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ef416d8b169a4f47a3dda56e98187b8d57d742" translate="yes" xml:space="preserve">
          <source>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">因此,如果你打算比较多个字符串,连续多次比较,可以在前期将它们归一化,直接进行比较,避免多次归一化。</target>
        </trans-unit>
        <trans-unit id="5cb2ec194ba3355670294e9c457ea3adb567e875" translate="yes" xml:space="preserve">
          <source>Therefore, in order to minimize the distributed tests, let&amp;rsquo;s pick a routing table that does not require distribution. Then, for the distributed tests, we will programatically change the routing table. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="translated">因此，为了最小化分布式测试，让我们选择一个不需要分布式的路由表。然后，对于分布式测试，我们将以编程方式更改路由表。返回 &lt;code&gt;config/config.exs&lt;/code&gt; ，添加以下行：</target>
        </trans-unit>
        <trans-unit id="af72f8d5888562059c52cc4bad66a2a3aa2e8b0b" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="translated">因此，此功能用于在使用模块之前检查是否已加载模块，并允许其做出相应的反应。例如，&lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;模块使用此功能来检查给定URI方案是否存在特定的解析器。</target>
        </trans-unit>
        <trans-unit id="d10b167c94497dff77b11dad17668b97ba38a48a" translate="yes" xml:space="preserve">
          <source>These are a few options that are not used by just one Mix task (and will thus be documented here):</source>
          <target state="translated">这几个选项并不是只有一个Mix任务才会用到的(因此,这里将对其进行记录)。</target>
        </trans-unit>
        <trans-unit id="41d198d3d66dfd7fa75bf909de01737698c3fc91" translate="yes" xml:space="preserve">
          <source>These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:</source>
          <target state="translated">这些是Elixir语言中的保留词汇。本指南中对它们进行了详细介绍,但为了方便起见,在此进行了总结。</target>
        </trans-unit>
        <trans-unit id="26cd6bcff6d81ebade774a0f501e5b9a49a3141c" translate="yes" xml:space="preserve">
          <source>These can be used anywhere you want to refer to a characters codepoint.</source>
          <target state="translated">这些可以用在任何你想引用一个字符代码点的地方。</target>
        </trans-unit>
        <trans-unit id="a33f02a3cf972439fc9644228266bf6ac583f283" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned the following syntax is supported:</source>
          <target state="translated">这些特征是提示关键字列表成为将选项传递给Elixir中的函数的默认机制的原因。在第5章中，当我们讨论 &lt;code&gt;if/2&lt;/code&gt; 宏时，我们提到了支持以下语法：</target>
        </trans-unit>
        <trans-unit id="76567fa6ed57b5e28a73659cbd673c9a7f350853" translate="yes" xml:space="preserve">
          <source>These functions and macros follow the Erlang convention of an &lt;code&gt;is_&lt;/code&gt; prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.</source>
          <target state="translated">这些函数和宏遵循 &lt;code&gt;is_&lt;/code&gt; 前缀的Erlang约定，而不是尾随的问号，以精确地指示在保护子句中允许使用它们。</target>
        </trans-unit>
        <trans-unit id="add5b2dbfbafe6da3d0a22b6f870b2eed75d677f" translate="yes" xml:space="preserve">
          <source>These options are expected to be literals (including the binary values) at compile time.</source>
          <target state="translated">在编译时,这些选项应该是 literals(包括二进制值)。</target>
        </trans-unit>
        <trans-unit id="2ec1191cd2717326d5b2f8e25c4fb58ff593d194" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's Code Server.</source>
          <target state="translated">这些选项是全局性的,因为它们是由Elixir的Code Server存储的。</target>
        </trans-unit>
        <trans-unit id="8aca497f05ede32d92fad7a0a08861307fed5d02" translate="yes" xml:space="preserve">
          <source>These paths are based on the &lt;code&gt;:apps_path&lt;/code&gt; and &lt;code&gt;:apps&lt;/code&gt; configurations.</source>
          <target state="translated">这些路径基于 &lt;code&gt;:apps_path&lt;/code&gt; 和 &lt;code&gt;:apps&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="90f90a0bd1abd66881352917a593420e21df4638" translate="yes" xml:space="preserve">
          <source>They also support &lt;code&gt;else&lt;/code&gt; blocks:</source>
          <target state="translated">它们还支持 &lt;code&gt;else&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="c272e830fb2eeca6af73d25f9dc7ec1a9ffc0efc" translate="yes" xml:space="preserve">
          <source>They are discussed individually in the sections below.</source>
          <target state="translated">以下各节将分别讨论这些问题。</target>
        </trans-unit>
        <trans-unit id="d984bcb0628847679167196f524ecb516b6c251c" translate="yes" xml:space="preserve">
          <source>They serve to annotate the module, often with information to be used by the user or the</source>
          <target state="translated">它们的作用是对模块进行注解,通常是提供用户或企业使用的信息。</target>
        </trans-unit>
        <trans-unit id="97ca407460ebb22e0ec5bdeff0b3e028c669bf37" translate="yes" xml:space="preserve">
          <source>They work as a temporary module storage to be used during compilation.</source>
          <target state="translated">它们作为临时模块存储,在编译过程中使用。</target>
        </trans-unit>
        <trans-unit id="ee6dd5d64b66e821ff94c4d17d21b9f93db749f2" translate="yes" xml:space="preserve">
          <source>They work as constants.</source>
          <target state="translated">它们作为常量工作。</target>
        </trans-unit>
        <trans-unit id="e53339d9d0bc53c58fe8778d10ade8bb49736f46" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang Syntax: A Crash Course&lt;/a&gt; provides a concise intro to Erlang&amp;rsquo;s syntax. Each code snippet is accompanied by equivalent code in Elixir. This is an opportunity for you to not only get some exposure to Erlang&amp;rsquo;s syntax but also review some of the things you have learned in this guide.</source>
          <target state="translated">本《&lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang语法：速成班》&lt;/a&gt;简要介绍了Erlang的语法。每个代码段均随附Elixir中的等效代码。这是一个机会，您不仅可以了解Erlang的语法，还可以查看本指南中学到的一些知识。</target>
        </trans-unit>
        <trans-unit id="c3d65d16574f84519ba2e69aa0d37e68059885e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值（如果 &lt;code&gt;key&lt;/code&gt; 不存在，则返回 &lt;code&gt;nil&lt;/code&gt; ），并且必须返回一个包含两个元素的元组：&amp;ldquo; get&amp;rdquo;值（检索到的值，可以在返回之前对其进行操作），并将新值存放在 &lt;code&gt;key&lt;/code&gt; 下。该 &lt;code&gt;fun&lt;/code&gt; 也可能返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值应从关键字列表中删除并返回。</target>
        </trans-unit>
        <trans-unit id="21531bdd28fd8a4fab193e8f907a1304804427e8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">这个 &lt;code&gt;fun&lt;/code&gt; 参数接收 &lt;code&gt;key&lt;/code&gt; 的值，并且必须返回一个包含两个元素的元组：&amp;ldquo; get&amp;rdquo;值（获取的值，可以在返回之前对其进行操作）和要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值。</target>
        </trans-unit>
        <trans-unit id="106724662d1a48acf5e96ebf33c77969eed35e72" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="translated">该建议不仅适用于库，还适用于任何Elixir代码。每次收到多个选项或使用外部数据时，都应在边界处验证数据并将其转换为结构化数据。例如，如果您提供可以通过多个选项启动的&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则希望在服务器启动时验证这些选项，并且仅在整个流程生命周期中依赖结构化数据。同样，如果数据库或套接字为您提供了字符串映射，则在接收到数据后，您应该对其进行验证，并有可能将其转换为结构或原子映射。</target>
        </trans-unit>
        <trans-unit id="38b51c7863a18d9dea71afde173bd863c4339d77" translate="yes" xml:space="preserve">
          <source>This also works with nested structs and the &lt;code&gt;struct.path.to.value&lt;/code&gt; way to specify paths:</source>
          <target state="translated">这也适用于嵌套结构和 &lt;code&gt;struct.path.to.value&lt;/code&gt; 方法来指定路径：</target>
        </trans-unit>
        <trans-unit id="c86b0384c6fa0ab23e023705951a2e26ece47398" translate="yes" xml:space="preserve">
          <source>This behaviour is deprecated. Use Erlang/OTP's :gen_event module instead.</source>
          <target state="translated">这种行为已经被废弃了,请使用Erlang/OTP的:gen_event模块。使用 Erlang/OTP 的 :gen_event 模块代替。</target>
        </trans-unit>
        <trans-unit id="72f035035b3d70bcbf1171738b7f8c7d508d05aa" translate="yes" xml:space="preserve">
          <source>This behaviour is relied on in many different places. For example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;exit(:shutdown)&lt;/code&gt; when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.</source>
          <target state="translated">在许多不同的地方都依赖此行为。例如，&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;在退出测试过程时使用 &lt;code&gt;exit(:shutdown)&lt;/code&gt; 来向链接的过程，监督树等发出信号，从而也有礼貌地关闭。</target>
        </trans-unit>
        <trans-unit id="c8eb2df7e5f6ba76a64892942e28c56d4c4a7f04" translate="yes" xml:space="preserve">
          <source>This break can be rendered as a linebreak or as the given &lt;code&gt;string&lt;/code&gt;, depending on the &lt;code&gt;mode&lt;/code&gt; of the chosen layout.</source>
          <target state="translated">此中断可以呈现为换行符或给定的 &lt;code&gt;string&lt;/code&gt; ，具体取决于所选布局的 &lt;code&gt;mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7ad5339c141f0de9e312dc2f25b5df3e7d8cb4" translate="yes" xml:space="preserve">
          <source>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt;, the macro will receive the AST representing the &lt;code&gt;self()&lt;/code&gt; call, and not the PID itself.</source>
          <target state="translated">因为宏从不接收PID，所以永远不会达到此断点。即使您将宏调用为 &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt; ，该宏也会收到表示 &lt;code&gt;self()&lt;/code&gt; 调用的AST ，而不是PID本身。</target>
        </trans-unit>
        <trans-unit id="8761ea35931ac08c3f3679fbf6f993fa3ef09746" translate="yes" xml:space="preserve">
          <source>This calendar implements the proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.</source>
          <target state="translated">该日历采用的是格里高利历,因此与当今大多数国家使用的日历兼容。闰年意味着格里高利历的闰年规则适用于所有时间,因此,1583年之前的日期与采用格里高利历的日期有不同的结果。</target>
        </trans-unit>
        <trans-unit id="7991ee0aa425c7d3f3afff7118c6225869810d3f" translate="yes" xml:space="preserve">
          <source>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</source>
          <target state="translated">此调用将设置一个停止一次的断点。要设置一个停止10次的断点。</target>
        </trans-unit>
        <trans-unit id="b325289ad4384d9c3ff3e14f0e004ec0fadc1690" translate="yes" xml:space="preserve">
          <source>This callback can be useful to control the &lt;em&gt;appearance&lt;/em&gt; of the status of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. For example, it can be used to return a compact representation of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s state to avoid having large state terms printed.</source>
          <target state="translated">此回调对于控制&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;状态的&lt;em&gt;外观&lt;/em&gt;很有用。例如，它可以用于返回&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;状态的紧凑表示形式，以避免打印大的状态项。</target>
        </trans-unit>
        <trans-unit id="1327f9cbc59e218b07255d5dfd814547d5d8807b" translate="yes" xml:space="preserve">
          <source>This callback is only supported on Erlang/OTP 21+.</source>
          <target state="translated">这个回调只在Erlang/OTP 21+上支持。</target>
        </trans-unit>
        <trans-unit id="ee5f243ca65efd502d5c4c6af5c8cd9dfd5d476c" translate="yes" xml:space="preserve">
          <source>This callback is optional.</source>
          <target state="translated">这个回调是可选的。</target>
        </trans-unit>
        <trans-unit id="f2424dc84d136b7783611865075888a14d9c990b" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the received message will be logged.</source>
          <target state="translated">这个回调是可选的。如果没有实现,收到的消息将被记录。</target>
        </trans-unit>
        <trans-unit id="985bade6a0d966231f4d34d8934365d5ebe8193e" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a call is performed against it.</source>
          <target state="translated">这个回调是可选的。如果没有实现这个回调,如果对它进行调用,服务器将失败。</target>
        </trans-unit>
        <trans-unit id="f84f9f7a0fb58e5af47a01d8f797b8c62ea95537" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.</source>
          <target state="translated">这个回调是可选的。如果没有实现这个回调,如果服务器对它进行投射,就会失败。</target>
        </trans-unit>
        <trans-unit id="5a8f931c4cb12fef7b434a37af006aef2ba0d46a" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.</source>
          <target state="translated">这个回调是可选的。如果没有实现,如果使用了继续指令,服务器将失败。</target>
        </trans-unit>
        <trans-unit id="ddfd8ff82f8cdfbfeb3d06aa0134b83f46048ef4" translate="yes" xml:space="preserve">
          <source>This can be added to any custom engine by invoking &lt;a href=&quot;#handle_assign/1&quot;&gt;&lt;code&gt;handle_assign/1&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以通过使用&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;#handle_assign/1&quot;&gt; &lt;code&gt;handle_assign/1&lt;/code&gt; &lt;/a&gt;将其添加到任何自定义引擎中：</target>
        </trans-unit>
        <trans-unit id="9a48050cb80bb5c2bc634b01accf3b4f5bd8c332" translate="yes" xml:space="preserve">
          <source>This chapter is a quick introduction to input/output mechanisms and file-system-related tasks, as well as to related modules like &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本章是对输入/输出机制和文件系统相关任务以及&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;等相关模块的快速介绍。</target>
        </trans-unit>
        <trans-unit id="3b602041d24e676175f7fd300fe9987bf2555172" translate="yes" xml:space="preserve">
          <source>This chapter is part of the</source>
          <target state="translated">这一章是 &quot;中国梦 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="d39494a06027e3ecee2968740895a5b78940cdae" translate="yes" xml:space="preserve">
          <source>This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.</source>
          <target state="translated">这将检查存储在正则表达式中的版本,并在版本不匹配的情况下重新编译regex。</target>
        </trans-unit>
        <trans-unit id="9ba63be17004fe209fc861513a8577afc4eb4889" translate="yes" xml:space="preserve">
          <source>This code counts the number of files in a ZIP file:</source>
          <target state="translated">该代码计算ZIP文件中的文件数量。</target>
        </trans-unit>
        <trans-unit id="b9d6dcf55f45221cfb511f9790e81d0872563106" translate="yes" xml:space="preserve">
          <source>This code generates a warning letting you know that you are mistakenly implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;. You can read more about &lt;code&gt;@impl&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;module documentation&lt;/a&gt;.</source>
          <target state="translated">此代码会生成警告，让您知道您错误地实现了 &lt;code&gt;parse/0&lt;/code&gt; 而不是 &lt;code&gt;parse/1&lt;/code&gt; 。您可以在&lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;模块文档中&lt;/a&gt;阅读有关 &lt;code&gt;@impl&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="7461ed387e3c81526760cfc0eb288d63eeb1988f" translate="yes" xml:space="preserve">
          <source>This command deletes all build artifacts for the current project. Dependencies' sources and build files are cleaned only if the &lt;code&gt;--deps&lt;/code&gt; option is given.</source>
          <target state="translated">此命令删除当前项目的所有构建工件。仅在指定了 &lt;code&gt;--deps&lt;/code&gt; 选项的情况下，才会清除依赖项的源文件和构建文件。</target>
        </trans-unit>
        <trans-unit id="f03f46afb53748c93f12e42d7a94c9567ade9ff8" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;iex&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="translated">该命令仅在通过&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;手动启动的撬会话或通过&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;设置的断点内起作用。在常规&lt;a href=&quot;iex&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt;会话期间调用此函数将打印错误。</target>
        </trans-unit>
        <trans-unit id="9a69791b2bccfac2d2c8e3aaab714d3c02736c70" translate="yes" xml:space="preserve">
          <source>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</source>
          <target state="translated">我们对Elixir中关联数据结构的介绍到此结束。你会发现,只要给定关键字列表和映射,你总会有合适的工具来解决Elixir中需要关联数据结构的问题。</target>
        </trans-unit>
        <trans-unit id="16f934bff72f27aaf7d700d67cebd5f253fc677d" translate="yes" xml:space="preserve">
          <source>This concludes our optimization chapter. We have used ETS as a cache mechanism where reads can happen from any processes but writes are still serialized through a single process. More importantly, we have also learned that once data can be read asynchronously, we need to be aware of the race conditions it might introduce.</source>
          <target state="translated">我们的优化章节到此结束。我们将ETS作为一种缓存机制,读取可以发生在任何进程中,但写入仍然是通过单一进程串行化的。更重要的是,我们还了解到,一旦数据可以异步读取,我们需要注意它可能引入的竞赛条件。</target>
        </trans-unit>
        <trans-unit id="e537b568fbfe0eb80dc56346fdc7829c98d99600" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="translated">可以使用&lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt;读取此配置。请注意，如果未定义项目，则&lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;config/0&lt;/code&gt; &lt;/a&gt;不会失败；这使许多Mix任务无需项目即可工作。</target>
        </trans-unit>
        <trans-unit id="a6e1f3335434ce7c6c1db9f585fc250ca17087fe" translate="yes" xml:space="preserve">
          <source>This configuration is split in three categories:</source>
          <target state="translated">这种配置分为三类。</target>
        </trans-unit>
        <trans-unit id="50abf55bb08a41598a90aba43d936a7f680d70a0" translate="yes" xml:space="preserve">
          <source>This configures a routing table that always points to the current node. Now remove &lt;code&gt;@tag :distributed&lt;/code&gt; from the test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; and run the suite, the test should now pass.</source>
          <target state="translated">这将配置一个始终指向当前节点的路由表。现在，从 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 中的测试中删除 &lt;code&gt;@tag :distributed&lt;/code&gt; ，并运行套件，测试现在应该通过了。</target>
        </trans-unit>
        <trans-unit id="300ecf84b2025cc5045f1e2f3e97de582fbc3fe7" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by checking equality instead, like &lt;code&gt;val == %{}&lt;/code&gt;.</source>
          <target state="translated">可以通过确保不引发异常来纠正此问题，可以通过 &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt; 类的类型检查，或者通过检查 &lt;code&gt;val == %{}&lt;/code&gt; 类的相等性来进行纠正。</target>
        </trans-unit>
        <trans-unit id="9c9bc7bb0b19c22166e70549a7bdc2d167883d30" translate="yes" xml:space="preserve">
          <source>This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</source>
          <target state="translated">这个日期时间可以被看作是一个特定时区的日期时间的短暂快照。为此,它还包括UTC和标准偏移量,以及专门用于格式化目的的区域缩写字段。</target>
        </trans-unit>
        <trans-unit id="025523ae9891a8ad2cd843de98bd87706ff12c27" translate="yes" xml:space="preserve">
          <source>This day fraction should be in its most simplified form possible, to make comparisons fast.</source>
          <target state="translated">这个日分数应该是最简化的形式,以便快速比较。</target>
        </trans-unit>
        <trans-unit id="99d3f98fe052dbacd8470e76a4e43e20ad18ae6f" translate="yes" xml:space="preserve">
          <source>This default can be overridden by &lt;code&gt;@tag capture_log: false&lt;/code&gt; or &lt;code&gt;@moduletag capture_log: false&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;@tag capture_log: false&lt;/code&gt; 或 &lt;code&gt;@moduletag capture_log: false&lt;/code&gt; 覆盖此默认值。</target>
        </trans-unit>
        <trans-unit id="dc33441b7a8711ad3ca32a6f565dfd02fa511842" translate="yes" xml:space="preserve">
          <source>This dependency refers to the latest version of Plug in the 1.x.x version series that has been pushed to Hex. This is indicated by the &lt;code&gt;~&amp;gt;&lt;/code&gt; preceding the version number. For more information on specifying version requirements, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;documentation for the Version module&lt;/a&gt;.</source>
          <target state="translated">此依赖性是指已推入十六进制的1.xx版本系列中插件的最新版本。版本号前面的 &lt;code&gt;~&amp;gt;&lt;/code&gt; 表示。有关指定版本要求的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;Version模块&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b6c49f1989fcd795b139792169130547ab503617" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="translated">这种设计是有意的。&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;旨在支持无限集合，资源和其他形状固定的结构。例如，将值插入范围是没有意义的，因为它具有固定的形状，仅存储范围限制。</target>
        </trans-unit>
        <trans-unit id="7534091aa8dce080c878d8bf8e2b8c4a424f0e53" translate="yes" xml:space="preserve">
          <source>This difference is exclusive, so the test will fail if the difference and the delta are equal.</source>
          <target state="translated">这个差值是排他性的,所以如果差值和delta相等,测试就会失败。</target>
        </trans-unit>
        <trans-unit id="2dd776fd236b4c910c6f960d04bcbda080e07c54" translate="yes" xml:space="preserve">
          <source>This difference is inclusive, so the test will pass if the difference and the &lt;code&gt;delta&lt;/code&gt; are equal.</source>
          <target state="translated">此差异是包含性的，因此，如果差异和 &lt;code&gt;delta&lt;/code&gt; 相等，则测试将通过。</target>
        </trans-unit>
        <trans-unit id="98215fb8db656d563463f8fe38acbb92d7848ad1" translate="yes" xml:space="preserve">
          <source>This distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:</source>
          <target state="translated">这种区分很重要。如果有昂贵的操作要做,你必须考虑是在客户端还是在服务器上执行这些操作更好。例如:</target>
        </trans-unit>
        <trans-unit id="df29062cd643c03ef91e3b2f35c7d26d81006829" translate="yes" xml:space="preserve">
          <source>This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.</source>
          <target state="translated">本文档涵盖了所有的Elixir语法结构作为参考,然后讨论它们的确切AST表示。</target>
        </trans-unit>
        <trans-unit id="5ca6dcbf01e5b678fc80bf68968384a6697f2309" translate="yes" xml:space="preserve">
          <source>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</source>
          <target state="translated">本文档涵盖了Elixir中的操作符,它们是如何被解析的,如何被定义的,以及如何被覆盖的。</target>
        </trans-unit>
        <trans-unit id="76b6d6a8fc49e94c927ef5f992d5906c281ba114" translate="yes" xml:space="preserve">
          <source>This document covers some naming conventions in Elixir code, from casing to punctuation characters.</source>
          <target state="translated">本文档介绍了Elixir代码中的一些命名惯例,从套管到标点符号。</target>
        </trans-unit>
        <trans-unit id="e522e86f1169f55700b99174079a5a7fddfa90ed" translate="yes" xml:space="preserve">
          <source>This document defines the commonly used base 16, base 32, and base 64 encoding schemes.</source>
          <target state="translated">本文档定义了常用的基数16、基数32和基数64编码方案。</target>
        </trans-unit>
        <trans-unit id="d8780e3a54cb0fb8d842fe0203eab3683b262d16" translate="yes" xml:space="preserve">
          <source>This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.</source>
          <target state="translated">本文档为那些编写和发布供其他开发者使用的Elixir库的人概述了一般指南、反模式和规则。</target>
        </trans-unit>
        <trans-unit id="7635e286607ededea5965d1544a7717ea9ae091d" translate="yes" xml:space="preserve">
          <source>This document provides a reference to Elixir syntax, exploring its constructs and their AST equivalents.</source>
          <target state="translated">本文档提供了Elixir语法的参考,探讨了其构造及其AST等价物。</target>
        </trans-unit>
        <trans-unit id="cb11a86f08fe1f7ebc5f36609a52188a6715fc6d" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;kernel#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本文档涉及为您自己的数据结构实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议。要了解有关使用检查的更多信息，请参见&lt;a href=&quot;kernel#inspect/2&quot;&gt; &lt;code&gt;Kernel.inspect/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c15107405a954dcb039847f9ffc0e90a3a08175" translate="yes" xml:space="preserve">
          <source>This example shows how to get everything from the registry.</source>
          <target state="translated">这个例子展示了如何从注册表中获取一切。</target>
        </trans-unit>
        <trans-unit id="370c43dc94083c1b83066d682a8c408a4aa46d4b" translate="yes" xml:space="preserve">
          <source>This feature is considered experimental and may change in future releases.</source>
          <target state="translated">此功能被认为是试验性的,可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="91e35a46b080fba070b1bb9706d962577f541321" translate="yes" xml:space="preserve">
          <source>This file can be compiled using &lt;code&gt;elixirc&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;elixirc&lt;/code&gt; 编译该文件：</target>
        </trans-unit>
        <trans-unit id="b21275a067c181042b1ef479348b07d28e434640" translate="yes" xml:space="preserve">
          <source>This file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application &lt;code&gt;version&lt;/code&gt;, all the modules defined by it, as well as a list of applications we depend on, like Erlang&amp;rsquo;s &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; itself, and &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">该文件包含Erlang术语（使用Erlang语法编写）。即使我们不熟悉Erlang，也很容易猜出此文件包含我们的应用程序定义。它包含我们的应用程序 &lt;code&gt;version&lt;/code&gt; ，由它定义的所有模块，以及我们依赖的应用程序列表，例如Erlang的 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;elixir&lt;/code&gt; 本身和 &lt;code&gt;logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4e5090203b164b7b8cda10cfcc22848f5f4e098" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">每次运行测试之前，Mix都会需要此文件。我们可以使用 &lt;code&gt;mix test&lt;/code&gt; 运行测试：</target>
        </trans-unit>
        <trans-unit id="5c84c085804b613daf8adcad4e1c5bc2c3c89312" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;rescue&lt;/code&gt;. You will find they are used less frequently in Elixir than in other languages, although they may be handy in some situations where a library or some particular code is not playing &amp;ldquo;by the rules&amp;rdquo;.</source>
          <target state="translated">至此，我们完成了对 &lt;code&gt;try&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;rescue&lt;/code&gt; 。您会发现在Elixir中使用它们的频率比在其他语言中要低，尽管在某些情况下，如果库或某些特定代码未按&amp;ldquo;规则&amp;rdquo;播放，它们可能会很方便。</target>
        </trans-unit>
        <trans-unit id="5e21f5a627b95129ae5af664e7fd87944d88dfd3" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs.</source>
          <target state="translated">我们对模式匹配的介绍到此结束。我们将在下一章中看到,模式匹配在许多语言结构中非常常见。</target>
        </trans-unit>
        <trans-unit id="8a8c048ae2840f3778becb01897e7dcb0a936037" translate="yes" xml:space="preserve">
          <source>This finishes our short introduction to modules. In the next chapters, we will learn how to use named functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules and discuss module attributes.</source>
          <target state="translated">我们对模块的简短介绍到此结束。在接下来的章节中,我们将学习如何使用命名函数进行递归,探索可用于从其他模块导入函数的Elixir词汇指令,并讨论模块属性。</target>
        </trans-unit>
        <trans-unit id="d37728bdb738ca01b9639cfc5853b77bca6e2f31" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about four Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="translated">至此，我们完成了IO设备和IO相关功能的介绍。我们已经学会了大约四个药剂模块- &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; 的&lt;/a&gt; -以及如何</target>
        </trans-unit>
        <trans-unit id="4be537303d97003eb7a277c4a7ca1256fe24cb96" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="translated">此函数接受任何至少包含与&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;结构相同的字段的映射或结构。最常见的示例是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。在这种情况下，有关该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;时区的信息将被完全忽略。这与将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;传递到&lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; 的&lt;/a&gt;原理相同。&lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt;仅提取给定结构的特定于日期的字段（日历，年，月和日），而忽略所有其他字段。</target>
        </trans-unit>
        <trans-unit id="5bf6aff9caccdb3a64ed2f33e59b9d34b47e60ba" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="translated">该函数接受的 &lt;code&gt;number&lt;/code&gt; 根据所测&lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;。时间以与给定的日历相同的日历返回。</target>
        </trans-unit>
        <trans-unit id="e2a89e508cd312bb2a9827f189a0607424832acb" translate="yes" xml:space="preserve">
          <source>This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call):</source>
          <target state="translated">该函数接受以下选项,这些选项相互排斥(即在同一调用中只能使用其中一个)。</target>
        </trans-unit>
        <trans-unit id="01d34bc3e6a8b2f03537e43d3d5e42ba54d0dddb" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped.</source>
          <target state="translated">此函数还接受 &lt;code&gt;predicate&lt;/code&gt; 函数作为可选参数。如果传递了此函数，则将使用 &lt;code&gt;string&lt;/code&gt; 每个字节作为参数调用此函数，如果给定的字节应保留原样，则应返回真实值（除 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 以外的任何值），或者返回虚假值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）。是否应该转义字符。</target>
        </trans-unit>
        <trans-unit id="b98eb6f021aa33018c50a97a2ae82859d4b9d5d9" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="translated">如果 &lt;code&gt;pattern&lt;/code&gt; 是正则表达式，则此函数还接受&lt;a href=&quot;regex#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt;接受的所有选项。</target>
        </trans-unit>
        <trans-unit id="ac6f41672cc7456ee783ae52a0830c9c41b7db86" translate="yes" xml:space="preserve">
          <source>This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">此功能还通知编译器打印警告（如果启用了--warnings-as-errors）。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f335fe1ab0a202ff3768395fb418ab92d63c45f8" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt; regardless of whether the destination &lt;code&gt;server&lt;/code&gt; (or node) exists. Therefore it is unknown whether the destination &lt;code&gt;server&lt;/code&gt; successfully handled the message.</source>
          <target state="translated">无论目标 &lt;code&gt;server&lt;/code&gt; （或节点）是否存在，此函数始终返回 &lt;code&gt;:ok&lt;/code&gt; 。因此，未知目标 &lt;code&gt;server&lt;/code&gt; 是否成功处理了该消息。</target>
        </trans-unit>
        <trans-unit id="bc08e67f2fe286bbaa38c013f9a0710de372c88c" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">此函数始终返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="440a46241c8ccf32d2a66af8c374d6f2f268c12c" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="57434e8d5ce39ceeb05917e87327e9180f6a8556" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">此函数始终返回浮点数。&lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt;可以使用Kernel.trunc / 1将结果截断为整数。</target>
        </trans-unit>
        <trans-unit id="0953d55a24fb80955003844da1bc3b8af51086cb" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">此功能假定任务的监视器仍处于活动状态，或者该监视器的 &lt;code&gt;:DOWN&lt;/code&gt; 消息在消息队列中。如果已被监视或已接收到消息，则此功能将等待超时，等待消息。</target>
        </trans-unit>
        <trans-unit id="7b478825975b2adf1e339715031349cd41d1d953" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">此功能假定任务的监视器仍处于活动状态，或者该监视器的 &lt;code&gt;:DOWN&lt;/code&gt; 消息在消息队列中。如果已对其进行监视，或者已经接收到消息，则此功能将等待超时的持续时间，以等待消息。</target>
        </trans-unit>
        <trans-unit id="12bd78dfccf68211322b54eebf7d9f19fae21105" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare a DateTime without the time zone information:</source>
          <target state="translated">这个函数也可以用来比较一个没有时区信息的DateTime。</target>
        </trans-unit>
        <trans-unit id="6685e43cbdb2479bfe075aeca3ae08082570222e" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the date fields:</source>
          <target state="translated">这个函数也可以用来比较更复杂的日历类型,只考虑日期字段。</target>
        </trans-unit>
        <trans-unit id="abca05fe88ba596b97d33bdad630bb0ce33ca0d8" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the time fields:</source>
          <target state="translated">这个函数也可以用来比较更复杂的日历类型,只考虑时间字段。</target>
        </trans-unit>
        <trans-unit id="50c88d683e6ca48ffff95675148916e0e611983e" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to ISO 8601 without the time zone information:</source>
          <target state="translated">这个功能也可以用来将DateTime转换为不含时区信息的ISO 8601。</target>
        </trans-unit>
        <trans-unit id="41a09a6604ea410d09611cc0508b8a9905bff4c2" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a erl format without the time zone information:</source>
          <target state="translated">这个函数也可以用来将DateTime转换为不含时区信息的erl格式。</target>
        </trans-unit>
        <trans-unit id="90561437b8e4f9d3679b45a602783e2cfc785f58" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a string without the time zone information:</source>
          <target state="translated">这个函数也可以用来将DateTime转换为没有时区信息的字符串。</target>
        </trans-unit>
        <trans-unit id="d7b8cf5df777bb4d4ddd30603ec1dffb30552797" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;stream#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以将此功能视为&lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;stream#transform/3&quot;&gt; &lt;code&gt;Stream.transform/3&lt;/code&gt; 的组合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65aef6f44f45a3fc1e3176aa1c4a4acc551773fb" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly send a reply to a client that called &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multi_call/4&quot;&gt;&lt;code&gt;multi_call/4&lt;/code&gt;&lt;/a&gt; when the reply cannot be specified in the return value of &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当无法在&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;的返回值中指定回复时，可以使用此函数向调用&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#multi_call/4&quot;&gt; &lt;code&gt;multi_call/4&lt;/code&gt; &lt;/a&gt;的客户端显式发送回复。</target>
        </trans-unit>
        <trans-unit id="e57ccc748f6208d195990a8cc4f2ec6d283e0449" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">对于任何给定任务，只能调用一次此函数。如果您希望能够多次检查长时间运行的任务是否已完成其计算，请改用&lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98e8c080a62ccf76ac34e7992cc0abb94cb3247b" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;Kernel.function_exported?/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt; &lt;/a&gt;分别检查编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="b999fb0a29efbf4b7d7e63844d3c5a01d70c5786" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取所有持久化的属性，或使用&lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt;检索已编译模块中的所有与文档相关的属性。</target>
        </trans-unit>
        <trans-unit id="8efbd3ec7525b3bf67461748ab16a84e708bda9c" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="translated">此功能只能在尚未编译的模块上使用。使用&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt;回调获取已编译模块中的公共函数和宏。</target>
        </trans-unit>
        <trans-unit id="4d5f5ab7615681bbf6fd8b48511d63b244920517" translate="yes" xml:space="preserve">
          <source>This function changes the current working directory and loads the project at the given directory onto the project stack.</source>
          <target state="translated">该函数改变当前工作目录,并将给定目录下的项目加载到项目栈中。</target>
        </trans-unit>
        <trans-unit id="8e3b67a18d5ef72f20a07d2887c95146e1126e8b" translate="yes" xml:space="preserve">
          <source>This function checks if &lt;code&gt;map_set1&lt;/code&gt; is a subset of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">此功能检查 &lt;code&gt;map_set1&lt;/code&gt; 的一个子集 &lt;code&gt;map_set2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2d91333f4d34514a5b0456ce852915cb7c3b1bf" translate="yes" xml:space="preserve">
          <source>This function could also receive &lt;code&gt;:restart&lt;/code&gt; and &lt;code&gt;:shutdown&lt;/code&gt; as options but those two options have been deprecated and it is now preferred to give them directly to &lt;code&gt;start_child&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">此函数还可以接收 &lt;code&gt;:restart&lt;/code&gt; 和 &lt;code&gt;:shutdown&lt;/code&gt; 作为选项，但是不建议使用这两个选项，现在最好直接将它们提供给 &lt;code&gt;start_child&lt;/code&gt; 和 &lt;code&gt;async&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff81d1869547c10033febe62aa38e4cdb8f5c51e" translate="yes" xml:space="preserve">
          <source>This function discards all formatting of the original code.</source>
          <target state="translated">这个函数放弃了原始代码的所有格式化。</target>
        </trans-unit>
        <trans-unit id="bc64919f284870e1f397d0b40b0bdb1f6bff9e2a" translate="yes" xml:space="preserve">
          <source>This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.</source>
          <target state="translated">这个函数在任何时候都不加载协议,也不加载编译模块的新字节码。然而,每个实现必须是可用的,它将被加载。</target>
        </trans-unit>
        <trans-unit id="5e9ba48e0ab714ebacb38f83050628f3e221fabd" translate="yes" xml:space="preserve">
          <source>This function does not query the file system, so it assumes no symlinks between the paths.</source>
          <target state="translated">这个函数不查询文件系统,所以假设路径之间没有符号链接。</target>
        </trans-unit>
        <trans-unit id="352c8d36738c6dbc1f9234ecd7c20913e38da8c4" translate="yes" xml:space="preserve">
          <source>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</source>
          <target state="translated">这个函数在设计上不支持正则表达式。当使用正则表达式时,让正则表达式一次遍历字符串通常比像本函数这样分批遍历更有效率。</target>
        </trans-unit>
        <trans-unit id="df30bac7bb7c4cc8e50dfd93b53e8ccc88b71e0c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="translated">此函数需要有效的Elixir AST（也称为带引号的表达式）作为参数。如果你想 &lt;code&gt;unquote&lt;/code&gt; 任何值，如地图或四元元组，你应该叫&lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; unquoting前。</target>
        </trans-unit>
        <trans-unit id="9f41d20e5f7f0240b4127af0359d8f266f1d505e" translate="yes" xml:space="preserve">
          <source>This function expects the &lt;code&gt;id&lt;/code&gt; in the child specification. For example:</source>
          <target state="translated">该函数需要子规范中的 &lt;code&gt;id&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="0a24e422135d3a72abf7a20c0e4887299173a50a" translate="yes" xml:space="preserve">
          <source>This function expects the file to be closed with success, which is usually the case unless the &lt;code&gt;:delayed_write&lt;/code&gt; option is given. For this reason, we do not recommend passing &lt;code&gt;:delayed_write&lt;/code&gt; to this function.</source>
          <target state="translated">该函数期望文件成功关闭，通常情况下，除非指定 &lt;code&gt;:delayed_write&lt;/code&gt; 选项，否则通常情况如此。因此，我们不建议将 &lt;code&gt;:delayed_write&lt;/code&gt; 传递给此函数。</target>
        </trans-unit>
        <trans-unit id="295cf4a022ae9886df00b43f0a66cd0e9487ce78" translate="yes" xml:space="preserve">
          <source>This function fails unless &lt;code&gt;enumerable&lt;/code&gt; is or can be converted into a list of tuples with &lt;em&gt;exactly&lt;/em&gt; two elements in each tuple.</source>
          <target state="translated">除非将 &lt;code&gt;enumerable&lt;/code&gt; 或可以将其转换为元组列表，且每个元组中&lt;em&gt;恰好有&lt;/em&gt;两个元素，否则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="2b4e5979f3e77e3276f95ef316da429597fdbf6e" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a directory, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">此函数遵循符号链接，因此，如果符号链接指向目录，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3644ab39c8ba48b5055b8839db30ad7f73881153" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a regular file, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">该函数遵循符号链接，因此，如果符号链接指向常规文件，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa8e1b3e795c072d918d9fb7e14d1f0f556146a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="translated">在&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;完成之后但在&lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;返回之前调用此函数。对于应用程序（和任何包含的应用程序）规范中定义的每个开始阶段，将按列出顺序将其调用一次。</target>
        </trans-unit>
        <trans-unit id="324f00c4d8269119ff0a84cb2a42e9f018297cf4" translate="yes" xml:space="preserve">
          <source>This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</source>
          <target state="translated">在应用程序停止后，即在其监视树停止后，将调用此函数。它应该执行与&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调相反的操作，并应执行任何必要的清除。此回调的返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="d1e69bba301a1e9a02d953f1b325981a44e10b03" translate="yes" xml:space="preserve">
          <source>This function is called before the top-level supervisor is terminated. It receives the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value is later passed to &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在终止顶级主管之前，将调用此函数。它接收&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;返回的状态（如果存在），否则返回 &lt;code&gt;[]&lt;/code&gt; 。返回值稍后传递给&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82b44336c3cb3815e176b242c09b89fad73c5747" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;application#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">当使用&lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;启动应用程序时调用此函数（以及位于其之上的函数，例如&lt;a href=&quot;application#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;）。此功能应启动应用程序的顶级过程（如果应用程序遵循围绕监督的OTP设计原则，则该功能应成为应用程序的监督树的最高主管）。</target>
        </trans-unit>
        <trans-unit id="6397213a49d0900b8102d7287a15cef482e32621" translate="yes" xml:space="preserve">
          <source>This function is commonly used on sigil implementations (like &lt;code&gt;~r&lt;/code&gt;, &lt;code&gt;~s&lt;/code&gt; and others) which receive a raw, unescaped string.</source>
          <target state="translated">此功能上印记实现常用（如 &lt;code&gt;~r&lt;/code&gt; ， &lt;code&gt;~s&lt;/code&gt; 及其他），其接收原料，不转义字符串。</target>
        </trans-unit>
        <trans-unit id="c1d006a8fc94dd9c7e1ba97fca6cd955efbe08aa" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead.</source>
          <target state="translated">这个函数已经过时了。Code.get_docs/2总是返回nil,因为它的过期文档不再存储在BEAM文件中。请使用Code.fetch_docs/1来代替。</target>
        </trans-unit>
        <trans-unit id="d817e277c636af5ee8696b4df5a417a3f80ca798" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use :unicode.characters_to_nfc_binary/1 or :unicode.characters_to_nfd_binary/1 instead.</source>
          <target state="translated">这个函数已经过时了,请使用:unicode.characters_to_nfc_binary/1或:unicode.characters_to_nfd_binary/1代替。使用:unicode.characters_to_nfc_binary/1或:unicode.characters_to_nfd_binary/1代替。</target>
        </trans-unit>
        <trans-unit id="6d197dc51c7a88c8b078c1ba4ae70a662b56ba4a" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd!/0 instead.</source>
          <target state="translated">此函数已被废弃,请使用File.cwd!/0代替。使用File.cwd!/0代替。</target>
        </trans-unit>
        <trans-unit id="68131068aaa063f7af71e9caaedd8601eae221d0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd/0 instead.</source>
          <target state="translated">此函数已被废弃,请使用File.cwd/0代替。使用File.cwd/0代替。</target>
        </trans-unit>
        <trans-unit id="d9e5b31b2e69678e54278c031112af02d71d6009" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Mix.Project.compile_path/1 instead.</source>
          <target state="translated">这个函数已经过时了,请使用Mix.Project.compile_path/1代替。使用Mix.Project.compile_path/1代替。</target>
        </trans-unit>
        <trans-unit id="a03218696b1f2f17e92328d8d93708ef4f7e2fab" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use maps and the Map module instead.</source>
          <target state="translated">此功能已被废弃。使用地图和地图模块代替。</target>
        </trans-unit>
        <trans-unit id="afca0b7ebdad39b2deed844f934a667e8bfea571" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Map module for working with maps or the Keyword module for working with keyword lists.</source>
          <target state="translated">此功能已被废弃,请使用地图模块处理地图或关键字模块处理关键字列表。使用地图模块来处理地图,或者使用关键字模块来处理关键字列表。</target>
        </trans-unit>
        <trans-unit id="9a82ec0a465ee3ffdfcf230d76d58430e9467641" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module for working with sets.</source>
          <target state="translated">此功能已被废弃,请使用MapSet模块来处理集合。使用MapSet模块来处理集合。</target>
        </trans-unit>
        <trans-unit id="01a53758d90cccf848faf6930295f5427dfb10e9" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module instead.</source>
          <target state="translated">此功能已被废弃,请使用MapSet模块代替。使用MapSet模块代替。</target>
        </trans-unit>
        <trans-unit id="03ea43b93839fafbcde7b68af462e5f9eed5a8d0" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</source>
          <target state="translated">此函数用于开发和调试的目的。不要在生产代码中依赖它。</target>
        </trans-unit>
        <trans-unit id="a44ba9065763e466dc65d136dacf651b48b4c551" translate="yes" xml:space="preserve">
          <source>This function is often used to set an &lt;code&gt;:id&lt;/code&gt; option when the same module needs to be started multiple times in the supervision tree:</source>
          <target state="translated">当需要在监管树中多次启动同一模块时，通常使用此函数设置 &lt;code&gt;:id&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="8b1fd4e59486849679c33280edfff500c42ca784" translate="yes" xml:space="preserve">
          <source>This function is often used with &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; since any evaluation is delayed until the stream is executed. See &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">此功能通常与&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;一起使用，因为任何评估都将延迟到执行流之前。有关示例，请参见&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35db107573e34332f733e95b887f5793867baa7f" translate="yes" xml:space="preserve">
          <source>This function is only available for modules being compiled.</source>
          <target state="translated">该功能仅适用于正在编译的模块。</target>
        </trans-unit>
        <trans-unit id="d6bf228951da57a994d903de6610ec9973c50adc" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;a href=&quot;#container_doc/6&quot;&gt;&lt;code&gt;container_doc/6&lt;/code&gt;&lt;/a&gt; and friends to the maximum number of entries on the same line.</source>
          <target state="translated">&lt;a href=&quot;#container_doc/6&quot;&gt; &lt;code&gt;container_doc/6&lt;/code&gt; &lt;/a&gt;和其朋友使用此功能以达到同一行上的最大条目数。</target>
        </trans-unit>
        <trans-unit id="4934d4902c08909612efec0de002f5df60337c47" translate="yes" xml:space="preserve">
          <source>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</source>
          <target state="translated">当你的代码已经在本地编译或更新,而你想在其他节点上运行时,这个函数对开发和调试很有用。</target>
        </trans-unit>
        <trans-unit id="50108ad28c85db6aa26c7746481f7a06145abb10" translate="yes" xml:space="preserve">
          <source>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate &lt;code&gt;:__struct__&lt;/code&gt; field into the map may not be enough and &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">此功能对于动态创建和更新结构以及将映射转换为结构很有用。在后一种情况下，仅将适当的 &lt;code&gt;:__struct__&lt;/code&gt; 字段插入映射中可能不够，而应使用&lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5385bb3c5cc1848788f9b3bfe82e294efa3644f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you have templates but you want to precompile inside a module for speed.</source>
          <target state="translated">这个函数在你有模板,但你想在一个模块内预编译以提高速度的情况下很有用。</target>
        </trans-unit>
        <trans-unit id="d4f1c9110eb148d436155bff7b34df88e2134afb" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present (e.g., the value is expensive to calculate or generally difficult to setup and teardown again).</source>
          <target state="translated">如果仅当 &lt;code&gt;key&lt;/code&gt; 不存在时才想计算要放入 &lt;code&gt;key&lt;/code&gt; 下的值（例如，该值计算起来很昂贵或通常很难再次设置和拆卸），此功能很有用。</target>
        </trans-unit>
        <trans-unit id="bf89a2dec2302779e475a219a3cc56e86137d9f9" translate="yes" xml:space="preserve">
          <source>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:</source>
          <target state="translated">当需要检索当前值(或当前值的函数计算)并同时更新时,这个函数很有用。例如,它可以用来读取用户的当前年龄,同时一次增加一个年龄。</target>
        </trans-unit>
        <trans-unit id="68a1bac27fa5baaa472b5537d1c8fee1ec1e9478" translate="yes" xml:space="preserve">
          <source>This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.</source>
          <target state="translated">当您知道模块的字节码已经在文件系统中更新,并且您想告诉虚拟机加载它时,这个功能很有用。</target>
        </trans-unit>
        <trans-unit id="80a765f43bfbc2222f8ba2acffb613f97fc1ff91" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</source>
          <target state="translated">该函数通常用于编译任务中,每当此类配置文件发生变化时,就会触发一次完整的重新编译。</target>
        </trans-unit>
        <trans-unit id="5161d32c18b7b4c986062d2c9d65d697f139b8ce" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.</source>
          <target state="translated">这个函数通常用于编译任务中,每当此类配置文件发生变化时,就会触发一次完整的重新编译。因此,mtime被缓存以避免文件系统的查找。</target>
        </trans-unit>
        <trans-unit id="79351219ceeb1dfd5ceb68c4d1517bb1d53f3be9" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report is logged.</source>
          <target state="translated">此功能保留有关错误报告的OTP语义。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 之外的其他原因，则会记录错误报告。</target>
        </trans-unit>
        <trans-unit id="9fb9a7593d63fc692737aa5ebbecdecf78a06b53" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report will be logged.</source>
          <target state="translated">此功能保留有关错误报告的OTP语义。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 以外的其他原因，则会记录错误报告。</target>
        </trans-unit>
        <trans-unit id="78ffeed4e3d53d08c6f8c5350cc948af11ad5cb9" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Unix and Windows. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="translated">该函数使用Unix和Windows上的环境变量PATH查找给定名称的可执行程序。它还考虑了每个操作系统的适当可执行扩展名，因此对于Windows，它将尝试查找具有 &lt;code&gt;.com&lt;/code&gt; ， &lt;code&gt;.cmd&lt;/code&gt; 或类似扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="03c6c18f32c36e354994adeed127bb47604a29a4" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数使用提供的 &lt;code&gt;mapper&lt;/code&gt; 函数映射 &lt;code&gt;enumerable&lt;/code&gt; 每个元素。然后使用 &lt;code&gt;sorter&lt;/code&gt; 函数（默认为&lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt; &lt;/a&gt;通过映射的元素对可枚举数进行排序。</target>
        </trans-unit>
        <trans-unit id="23713134a12e3df672b0e8ed70b6c1e947176852" translate="yes" xml:space="preserve">
          <source>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed.</source>
          <target state="translated">这个功能在复制文件时可能会失败,在这种情况下,它将使目标目录处于肮脏状态,已经复制的文件不会被删除。</target>
        </trans-unit>
        <trans-unit id="fc53ec83419111665403d3184c5309cb3ac3114b" translate="yes" xml:space="preserve">
          <source>This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">如果未找到 &lt;code&gt;child_id&lt;/code&gt; ，或者当前进程正在运行或正在重新启动，则此函数可能返回带有适当错误元组的错误。</target>
        </trans-unit>
        <trans-unit id="8ae84d6b7d02c1f5e4d3d90e843aa4994fe5afbb" translate="yes" xml:space="preserve">
          <source>This function merges two URIs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986, section 5.2&lt;/a&gt;.</source>
          <target state="translated">此功能根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986第5.2节&lt;/a&gt;合并两个URI 。</target>
        </trans-unit>
        <trans-unit id="7249b2b7e8627d3ee0f960577e5cfe5cf5a1c42f" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;kernel#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="translated">该函数仅接受浮点数，并且始终返回浮点数。如果您想要一个既接受浮点数又接受整数并且始终返回整数的函数，请使用&lt;a href=&quot;kernel#round/1&quot;&gt; &lt;code&gt;Kernel.round/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50d8af487774d9f7e007fed31c88d7f628e11c28" translate="yes" xml:space="preserve">
          <source>This function only ever needs to store the last emitted element.</source>
          <target state="translated">这个函数只需要存储最后一个发射的元素。</target>
        </trans-unit>
        <trans-unit id="295eba0c064a53ae3a651500b18114cd09951154" translate="yes" xml:space="preserve">
          <source>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</source>
          <target state="translated">这个功能只有在shell上启用ANSI转义码的情况下才有效,这意味着这个功能在Windows机器上默认是不可用的。</target>
        </trans-unit>
        <trans-unit id="528389cc0cdba8ed58acc495892cfb708eb725e7" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="translated">此函数产生的结果与用于列表的&lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt;运算符相同。</target>
        </trans-unit>
        <trans-unit id="2bd92c0ea07d00b8bd2fd96f2a2022d49efc3e5e" translate="yes" xml:space="preserve">
          <source>This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too.</source>
          <target state="translated">该函数清除当前由编译器保存的所有模块,允许旧的编译器模块名被重新使用。如果有任何进程在运行这些模块的代码,它们也将被终止。</target>
        </trans-unit>
        <trans-unit id="0c8f05dda04bc767a1282d611e4af5dafdcb7b8d" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="translated">该函数接收任务列表，并在给定的时间间隔内等待其答复。它返回一个包含两个元素的元组的列表，任务是第一个元素，而产生的结果是第二个。返回列表中的任务将与 &lt;code&gt;tasks&lt;/code&gt; 输入参数中提供的任务的顺序相同。</target>
        </trans-unit>
        <trans-unit id="66ca8de099428d7febba36a7eae6660d193647fb" translate="yes" xml:space="preserve">
          <source>This function reruns the given task; to do that, it first re-enables the task and then runs it as normal.</source>
          <target state="translated">这个函数重新运行给定的任务;要做到这一点,它首先重新启用任务,然后正常运行。</target>
        </trans-unit>
        <trans-unit id="7f88acb523db6223367758a20b1546d9d8c207d7" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, owner}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;. The &lt;code&gt;owner&lt;/code&gt; is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller.</source>
          <target state="translated">此函数返回 &lt;code&gt;{:ok, owner}&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 。该 &lt;code&gt;owner&lt;/code&gt; 是负责的PID注册表分区PID。所有者自动链接到呼叫者。</target>
        </trans-unit>
        <trans-unit id="902dd92c08e25103df4b50bae4697cf10a6fc6fd" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, pid}&lt;/code&gt; in case of success, otherwise it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3353899fe4360fc7c94245abd3933c4141ee40" translate="yes" xml:space="preserve">
          <source>This function returns a list of &lt;code&gt;{id, child, type, modules}&lt;/code&gt; tuples, where:</source>
          <target state="translated">此函数返回 &lt;code&gt;{id, child, type, modules}&lt;/code&gt; 元组的列表，其中：</target>
        </trans-unit>
        <trans-unit id="c22e6a9591d2580a185def76ec2a7822b6c5d175" translate="yes" xml:space="preserve">
          <source>This function returns a list of tuples containing:</source>
          <target state="translated">这个函数返回一个包含以下内容的元组列表。</target>
        </trans-unit>
        <trans-unit id="4ffb7797732e8eabda6ec4358625e5d11748d93c" translate="yes" xml:space="preserve">
          <source>This function returns a new enumerable built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together; conceptually, this is similar to a combination of &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个函数返回附加调用的结果，建立一个新的枚举 &lt;code&gt;fun&lt;/code&gt; 中的每个元素 &lt;code&gt;enumerable&lt;/code&gt; 在一起; 从概念上讲，这类似于&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; 的组合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4c4692a1b2085c0d5c4c7060abeb21e5e80d789" translate="yes" xml:space="preserve">
          <source>This function returns a new stream built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together.</source>
          <target state="translated">这个函数返回附加调用的结果，建立一个新的数据流 &lt;code&gt;fun&lt;/code&gt; 中的每个元素 &lt;code&gt;enumerable&lt;/code&gt; 在一起。</target>
        </trans-unit>
        <trans-unit id="9207161e31f07b71a8de0abeb84876a37ff477ac" translate="yes" xml:space="preserve">
          <source>This function returns a timer reference, which can be read with &lt;a href=&quot;#read_timer/1&quot;&gt;&lt;code&gt;read_timer/1&lt;/code&gt;&lt;/a&gt; or canceled with &lt;a href=&quot;#cancel_timer/1&quot;&gt;&lt;code&gt;cancel_timer/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数返回一个计时器参考，它可以与读取&lt;a href=&quot;#read_timer/1&quot;&gt; &lt;code&gt;read_timer/1&lt;/code&gt; &lt;/a&gt;或取消&lt;a href=&quot;#cancel_timer/1&quot;&gt; &lt;code&gt;cancel_timer/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3b4424c23b3b31b7bea686c83f6fbd90413317a" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the collected result and the command exit status.</source>
          <target state="translated">该函数返回一个包含收集结果和命令退出状态的元组。</target>
        </trans-unit>
        <trans-unit id="1c1572156370222a67bdcd453345528785b5b103" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor flags and child specifications.</source>
          <target state="translated">这个函数返回一个包含主管标志和子规范的元组。</target>
        </trans-unit>
        <trans-unit id="a236219391c9665ab6cd417a5f529892164a5643" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor options.</source>
          <target state="translated">这个函数返回一个包含主管选项的元组。</target>
        </trans-unit>
        <trans-unit id="f10657fb9f9d2dbe8abd5fb7b8f8b43416880ed5" translate="yes" xml:space="preserve">
          <source>This function returns an empty list when used at the root of an umbrella project because there is no compile manifest to extract the function call information from. To get the function calls of each child in an umbrella, execute the function at the root of each individual application.</source>
          <target state="translated">这个函数在伞形项目的根部使用时,返回一个空列表,因为没有编译清单来提取函数调用信息。要获取伞形项目中每个子程序的函数调用,请在每个应用程序的根部执行该函数。</target>
        </trans-unit>
        <trans-unit id="a6fbf0f83b2acb02bb139f54eef721ae8347767a" translate="yes" xml:space="preserve">
          <source>This function returns either &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. Where &lt;code&gt;definition&lt;/code&gt; is &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt; or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">此函数返回 &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 。其中 &lt;code&gt;definition&lt;/code&gt; 为 &lt;code&gt;:def&lt;/code&gt; ， &lt;code&gt;:defp&lt;/code&gt; ， &lt;code&gt;:defmacro&lt;/code&gt; 或 &lt;code&gt;:defmacrop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5908984f567478e4a60e81ad1b7f0e0a95ff38d7" translate="yes" xml:space="preserve">
          <source>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</source>
          <target state="translated">该函数立即返回,并忽略不存在的节点,或服务器名称不存在的节点。</target>
        </trans-unit>
        <trans-unit id="3c26de55ed91737da0adcc687c60b204ef4f41f8" translate="yes" xml:space="preserve">
          <source>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</source>
          <target state="translated">该函数返回断点ID,如果断点设置错误,则会引发。</target>
        </trans-unit>
        <trans-unit id="e9031a38e543bd6739ba00dbc5fed0a5a01f11ea" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回以秒为单位的差异，其中根据&lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;测量秒。</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">该函数返回:</target>
        </trans-unit>
        <trans-unit id="dc16b8c0d60d4a66a61b6088df628cb2cdbe5f10" translate="yes" xml:space="preserve">
          <source>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</source>
          <target state="translated">此函数用于将一个路径列表转换为路径。请注意,在连接时,任何尾部的斜线都会被删除。</target>
        </trans-unit>
        <trans-unit id="f72643333bea463c7a8ea5767e80e22d1a7036bf" translate="yes" xml:space="preserve">
          <source>This function should be used to remove a specific extension which may or may not be there.</source>
          <target state="translated">这个功能应该用来删除一个可能存在或不存在的特定扩展。</target>
        </trans-unit>
        <trans-unit id="1fc59171af9c1101b367bf06403fbdf95aa428ac" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback (see the documentation for the &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback for more information).</source>
          <target state="translated">如果启动成功 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; 此函数应该返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 或{：ok，pid，state}。 &lt;code&gt;pid&lt;/code&gt; 应该是最高主管的PID。 &lt;code&gt;state&lt;/code&gt; 可以是任意术语，如果省略，将默认为 &lt;code&gt;[]&lt;/code&gt; ；如果应用程序后停止， &lt;code&gt;state&lt;/code&gt; 传递到&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;的回调（请参阅文件&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;的详细信息，回调）。</target>
        </trans-unit>
        <trans-unit id="21a65796034b404efe85bb5cf745e9599f9e6028" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</source>
          <target state="translated">这个函数不应该在应用程序代码的运行时使用(相对于基础架构和构建代码,比如Mix任务)。Mix是一个构建工具,在代码编译后可能无法使用(例如在发行版中)。</target>
        </trans-unit>
        <trans-unit id="7d9efdf471f60e2ed682dd93f955c9a027ea855c" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (see &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;env/0&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">不应在运行时在应用程序代码中使用此函数（有关更多信息，请参见&lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;env/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">该函数应该返回 &lt;code&gt;{:ok, value}&lt;/code&gt; ，如果键中存在 &lt;code&gt;key&lt;/code&gt; 则 &lt;code&gt;value&lt;/code&gt; 是键下的值；如果键中不存在键，则为 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e0b499c79fbb5106ff12e9b189fd33d1ca2f878" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="translated">这个函数不应该直接调用，除非实现自定义时 &lt;code&gt;inspect_fun&lt;/code&gt; 必须考虑到&lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;。在其他任何地方，应该首选&lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; ,&lt;/a&gt;因为它可以处理结构和异常。</target>
        </trans-unit>
        <trans-unit id="7c7b31de7bb27ac0e240dd4370dcbe439841a348" translate="yes" xml:space="preserve">
          <source>This function simply reads the configuration value for &lt;code&gt;:ansi_enabled&lt;/code&gt; in the &lt;code&gt;:elixir&lt;/code&gt; application. The value is by default &lt;code&gt;false&lt;/code&gt; unless Elixir can detect during startup that both &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; are terminals.</source>
          <target state="translated">此函数仅在 &lt;code&gt;:elixir&lt;/code&gt; 应用程序中读取 &lt;code&gt;:ansi_enabled&lt;/code&gt; 的配置值。除非Elixir在启动过程中可以检测到 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 均为终端，否则该值默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="334f3d5e4471a23891371c10f4d6629f6f864306" translate="yes" xml:space="preserve">
          <source>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</source>
          <target state="translated">这个函数产生一个进程,这个进程与调用者进程相连接,并由调用者进程监控。链接部分很重要,因为如果父进程死亡,它就会中止任务。它还能保证async/await之前的代码在你添加async调用后具有相同的属性。例如,想象一下你有这样的内容。</target>
        </trans-unit>
        <trans-unit id="c734a84fb40ac9d66210c296db69e31b0a02eadc" translate="yes" xml:space="preserve">
          <source>This function splits the given &lt;code&gt;string&lt;/code&gt; into a list of strings in a similar way to many shells.</source>
          <target state="translated">该函数将给定的 &lt;code&gt;string&lt;/code&gt; 拆分为字符串列表，其方式与许多Shell相似。</target>
        </trans-unit>
        <trans-unit id="2feb07f1ca6bdd2a159c3be3d1d2d967088b7ce0" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#expand_once/2&quot;&gt;&lt;code&gt;expand_once/2&lt;/code&gt;&lt;/a&gt; under the hood. Check it out for more information and examples.</source>
          <target state="translated">该函数在&lt;a href=&quot;#expand_once/2&quot;&gt; &lt;code&gt;expand_once/2&lt;/code&gt; &lt;/a&gt;使用expand_once / 2。查阅更多信息和示例。</target>
        </trans-unit>
        <trans-unit id="6e2fc530fdd36a8deb023fe2c739cc5eac5cf4d5" translate="yes" xml:space="preserve">
          <source>This function uses Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt;&lt;code&gt;:rand&lt;/code&gt; module&lt;/a&gt; to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</source>
          <target state="translated">该函数使用Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt; &lt;code&gt;:rand&lt;/code&gt; 模块&lt;/a&gt;来计算随机值。检查其文档以设置其他随机算法或其他种子。</target>
        </trans-unit>
        <trans-unit id="97aac23199beb8d9422f08074a16068341921614" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">该功能使用&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块根据给定的 &lt;code&gt;keys&lt;/code&gt; 遍历结构，除非 &lt;code&gt;key&lt;/code&gt; 是一个功能，这将在后面的部分中详细介绍。</target>
        </trans-unit>
        <trans-unit id="8aa0a6bd6b734aebad750c42bf0f37171db0b991" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; environment variable and falls back to &lt;code&gt;EDITOR&lt;/code&gt; if the former is not available.</source>
          <target state="translated">此函数使用 &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; 环境变量，如果前者不可用，则退回到 &lt;code&gt;EDITOR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbfcbb53a61b66a747c2491e188753fa8068b44" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes the second one.</source>
          <target state="translated">此函数使用合并排序算法。给定的函数应该比较两个参数，如果第一个参数在第二个参数之前，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="862ee811fb4cabde3cfb7ab7a9097a9d6c254988" translate="yes" xml:space="preserve">
          <source>This function uses the parsing regular expression as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986, Appendix B&lt;/a&gt;.</source>
          <target state="translated">此函数使用&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986附录B中&lt;/a&gt;定义的解析正则表达式。</target>
        </trans-unit>
        <trans-unit id="d26051019e95731e1d7b99be08f5928a37367d27" translate="yes" xml:space="preserve">
          <source>This function was designed to camelize language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">该功能旨在将语言标识符/令牌标记化，因此它属于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt;模块。不要将其用作驼峰化字符串的通用机制，因为它不支持Unicode或在Elixir标识符中无效的字符。</target>
        </trans-unit>
        <trans-unit id="582211980e20afdfe93b93a25608463f5c56a8bf" translate="yes" xml:space="preserve">
          <source>This function was designed to underscore language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">此函数旨在强调语言标识符/标记，因此它属于&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt;模块。请勿将其用作下划线字符串的通用机制，因为它不支持Unicode或Elixir标识符中无效的字符。</target>
        </trans-unit>
        <trans-unit id="ddcb598fb0ce62c01ead735edd62ec7ef5afb147" translate="yes" xml:space="preserve">
          <source>This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</source>
          <target state="translated">这个函数将对给定的模块进行仪表化处理,并在内存中加载一个新的版本,并在给定的函数和arity处设置断点。如果模块被重新编译,所有断点都会丢失。</target>
        </trans-unit>
        <trans-unit id="8b8f47c44e23aa37c7285c683f845cd5e9a96e09" translate="yes" xml:space="preserve">
          <source>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to &lt;code&gt;nil&lt;/code&gt;, which will remove that key from the metadata.</source>
          <target state="translated">此功能会将给定的关键字列表合并到现有的元数据中，但将键设置为 &lt;code&gt;nil&lt;/code&gt; 除外，这会将键从元数据中删除。</target>
        </trans-unit>
        <trans-unit id="11a397f1ed689beeb86c4bc32143ddefc115ba76" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;functionclauseerror&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="translated">如果给定的 &lt;code&gt;node&lt;/code&gt; 未处于活动状态，则此函数将引发&lt;a href=&quot;functionclauseerror&quot;&gt; &lt;code&gt;FunctionClauseError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b9fdfcab204aeb9ec68e1e7116d2ac8debacde" translate="yes" xml:space="preserve">
          <source>This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of &lt;code&gt;{args, guards}&lt;/code&gt; pairs where each argument and each top-level condition in a guard separated by &lt;code&gt;and&lt;/code&gt;/&lt;code&gt;or&lt;/code&gt; is wrapped in a tuple with blame metadata.</source>
          <target state="translated">此函数将从字节码中检索可用子句，并根据给定的参数对它们进行评估。这些子句以 &lt;code&gt;{args, guards}&lt;/code&gt; 对的列表形式返回，其中，每个参数和保护中的每个顶级条件都由 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 分隔，并包装在带有非常规元数据的元组中。</target>
        </trans-unit>
        <trans-unit id="029c82ca4692615f6cc90f101026e01c3b5dc4e0" translate="yes" xml:space="preserve">
          <source>This functionality starts the &lt;code&gt;:net_kernel&lt;/code&gt; and other related processes.</source>
          <target state="translated">此功能将启动 &lt;code&gt;:net_kernel&lt;/code&gt; 和其他相关过程。</target>
        </trans-unit>
        <trans-unit id="a5c0fe11d15d66b3e64978f03cccbe68ad69f39c" translate="yes" xml:space="preserve">
          <source>This guarantees all messages sent to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; prior to this call will be processed. This is useful for testing and it should not be called in production code.</source>
          <target state="translated">这样可以确保在此调用之前发送给&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 的&lt;/a&gt;所有消息都将得到处理。这对于测试很有用，不应在生产代码中调用。</target>
        </trans-unit>
        <trans-unit id="931eb8597cbb84926c09fb6a3b1aa749f547e621" translate="yes" xml:space="preserve">
          <source>This guide aims to introduce the meta-programming techniques available in Elixir. The ability to represent an Elixir program by its own data structures is at the heart of meta-programming. This chapter starts by exploring those structures and the associated &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; constructs, so we can take a look at macros in the next chapter and finally build our own domain specific language.</source>
          <target state="translated">本指南旨在介绍Elixir中可用的元编程技术。通过自身的数据结构表示Elixir程序的能力是元编程的核心。本章将通过探索这些结构和相关的开始 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;unquote&lt;/code&gt; 的构建，所以我们可以在下一章看看宏和最终建立我们自己的领域特定语言。</target>
        </trans-unit>
        <trans-unit id="5849b2456045ed3a32dde6f55db3e066f023528f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;kernel#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">发生这种情况是因为格式设置程序可以在不更改代码语义的情况下引入新行的唯一位置是插值。在这种情况下，我们建议开发人员直接调整代码。在这里，我们可以使用二进制连接运算符&lt;a href=&quot;kernel#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ccb1f24686f9c6bcd91b3b281d116c9f04cb68f5" translate="yes" xml:space="preserve">
          <source>This helper only works when IEx is started with a Mix project, for example, &lt;code&gt;iex -S mix&lt;/code&gt;. The application is not restarted after compilation, which means any long running process may crash as any changed module will be temporarily removed and recompiled, without going through the proper code changes callback.</source>
          <target state="translated">仅当从Mix项目启动IEx（例如 &lt;code&gt;iex -S mix&lt;/code&gt; )时，此帮助程序才起作用。编译后，应用程序不会重新启动，这意味着任何长时间运行的进程都可能崩溃，因为任何更改的模块都将被临时删除并重新编译，而不经过适当的代码更改回调。</target>
        </trans-unit>
        <trans-unit id="af9ea0d60815c82f22be854ae11982e7962bd190" translate="yes" xml:space="preserve">
          <source>This implementation also adds &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; which give more control over the document fitting.</source>
          <target state="translated">此实现还添加了&lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#next_break_fits/2&quot;&gt; &lt;code&gt;next_break_fits/2&lt;/code&gt; &lt;/a&gt;，它们可以更好地控制文档的拟合。</target>
        </trans-unit>
        <trans-unit id="ecf1cb6c3f0131a137b0e41a93d52ab7359f8a7c" translate="yes" xml:space="preserve">
          <source>This implementation provides two types of breaks: &lt;code&gt;:strict&lt;/code&gt; and &lt;code&gt;:flex&lt;/code&gt;. When a group does not fit, all strict breaks are treated as newlines. Flex breaks however are re-evaluated on every occurrence and may still be rendered flat. See &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此实现提供两种类型的中断 &lt;code&gt;:strict&lt;/code&gt; 和 &lt;code&gt;:flex&lt;/code&gt; 。当一组不合适时，所有严格的休息时间都被视为换行符。但是，每次发生时都会重新评估柔韧性折断，并且可能仍会变得平坦。有关更多信息，请参见&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc54167321bb690ef67cdb4d7c3892839915a92e" translate="yes" xml:space="preserve">
          <source>This information is returned based on the code path. Here is an example:</source>
          <target state="translated">这些信息是根据代码路径返回的。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="60031e59b55c11c2eb9a171c6db3ebaf52a6c050" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell.</source>
          <target state="translated">这是Mix的默认外壳。</target>
        </trans-unit>
        <trans-unit id="5053391a8e72e9d443f680cf9656acc6cdd0a4d5" translate="yes" xml:space="preserve">
          <source>This is a bad idea, as we don&amp;rsquo;t want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.</source>
          <target state="translated">这是一个坏主意，因为我们不希望注册表在存储桶崩溃时崩溃。正确的解决方法是实际上不将存储桶链接到注册表。取而代之的是，我们将每个存储段链接到一种称为Supervisor的特殊类型的过程，该过程专门用于处理故障和崩溃。我们将在下一章中详细了解它们。</target>
        </trans-unit>
        <trans-unit id="9e5ab726c57b0fb6f6da70a28676a9b1f70f7bab" translate="yes" xml:space="preserve">
          <source>This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated:</source>
          <target state="translated">这是一个硬解,因为它会发出警告,并将文档注释为弃用。</target>
        </trans-unit>
        <trans-unit id="c34842432839543d617525657c5d1288600c6c0e" translate="yes" xml:space="preserve">
          <source>This is a soft-deprecation as it simply annotates the documentation as deprecated:</source>
          <target state="translated">这是一个软解读,因为它只是简单地将文档注释为废弃的。</target>
        </trans-unit>
        <trans-unit id="77df0c1b4e2776653e0c5177f9ffa6268916531c" translate="yes" xml:space="preserve">
          <source>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</source>
          <target state="translated">这其实是开发宏时常见的陷阱。我们在宏中假设了一个特定的形状。我们可以通过取消引用表达式里面的变量的引用来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="0dc899362b8fa129cf65071f623d739413cc73aa" translate="yes" xml:space="preserve">
          <source>This is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.</source>
          <target state="translated">这一切都很好,但我们仍然希望为用户提供一个API,让我们隐藏我们的实现细节。</target>
        </trans-unit>
        <trans-unit id="f7b133b5999cc2d686bfdd612eea0550282bc0a5" translate="yes" xml:space="preserve">
          <source>This is also the syntax that Elixir uses to inspect keyword lists:</source>
          <target state="translated">这也是Elixir用来检查关键字列表的语法。</target>
        </trans-unit>
        <trans-unit id="695d7b0825ac4fbdcbd163159a7fc336c49f943b" translate="yes" xml:space="preserve">
          <source>This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly:</source>
          <target state="translated">这是一种反模式,不仅因为它使计算器逻辑复杂化,而且因为你把计算器逻辑放在一个单一的进程后面,这将成为你系统的潜在瓶颈,特别是当调用的数量增加时。相反直接定义函数就好了。</target>
        </trans-unit>
        <trans-unit id="9d1d1dd333c995d40a1c0f70de189cf4bf055fbb" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;a href=&quot;#myers_difference/2&quot;&gt;&lt;code&gt;myers_difference/2&lt;/code&gt;&lt;/a&gt; where a &lt;code&gt;diff_script&lt;/code&gt; function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or &lt;code&gt;nil&lt;/code&gt; in case there is no such script. The returned inner edit script will be under the &lt;code&gt;:diff&lt;/code&gt; key.</source>
          <target state="translated">这是&lt;a href=&quot;#myers_difference/2&quot;&gt; &lt;code&gt;myers_difference/2&lt;/code&gt; &lt;/a&gt;的扩展，其中在需要计算嵌套差异的情况下可以提供 &lt;code&gt;diff_script&lt;/code&gt; 函数。该函数可以返回带有内部编辑脚本的列表，如果没有这样的脚本，则返回 &lt;code&gt;nil&lt;/code&gt; 。返回的内部编辑脚本将在 &lt;code&gt;:diff&lt;/code&gt; 键下。</target>
        </trans-unit>
        <trans-unit id="1c0d7fab04e5bf783756a7f428e6b36128d23270" translate="yes" xml:space="preserve">
          <source>This is an optimization for &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt;.</source>
          <target state="translated">这是对 &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8a27bb1d6f71fa4c6c204cb8cc47805a7ed11d7" translate="yes" xml:space="preserve">
          <source>This is an option determining the prompt displayed to the user when awaiting input.</source>
          <target state="translated">这是一个决定在等待输入时向用户显示提示的选项。</target>
        </trans-unit>
        <trans-unit id="d40bb6ddf99cda982a812b8ae52262c178bb85e3" translate="yes" xml:space="preserve">
          <source>This is because the macro is expecting its arguments to be a keyword list at &lt;strong&gt;compilation&lt;/strong&gt; time. Since in the example above we are passing the representation of the variable &lt;code&gt;kv&lt;/code&gt;, our code fails.</source>
          <target state="translated">这是因为宏在&lt;strong&gt;编译&lt;/strong&gt;时期望其参数是关键字列表。由于在上面的示例中，我们传递了变量 &lt;code&gt;kv&lt;/code&gt; 的表示形式，因此我们的代码失败了。</target>
        </trans-unit>
        <trans-unit id="21f107c1b12d2af11cc6fc5fce200280f5598e01" translate="yes" xml:space="preserve">
          <source>This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.</source>
          <target state="translated">这可以是一个普通的PID,也可以是一个代表注册名称的值。更多信息请参见本文件的 &quot;名称注册 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="b9679cc98b384d2fae74f5c4e147d814a3605b34" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used way less frequently here).</source>
          <target state="translated">这等效于许多命令式语言中的 &lt;code&gt;else if&lt;/code&gt; 子句（尽管此处使用频率较低）。</target>
        </trans-unit>
        <trans-unit id="20b3f3a29153ddca60608cf1ff19217f8f298150" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro so it can be used in guard clauses.</source>
          <target state="translated">这是以宏的形式实现的,所以它可以在保护子句中使用。</target>
        </trans-unit>
        <trans-unit id="b6ca1cc005536f5b89386dac5e9eaab2c71326b3" translate="yes" xml:space="preserve">
          <source>This is in contrast to &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt; which splits the entire string upfront.</source>
          <target state="translated">这与&lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;split/3&lt;/code&gt; &lt;/a&gt;相反，后者将预先拆分整个字符串。</target>
        </trans-unit>
        <trans-unit id="d6a69df7f8c6fe2ffd7e21f569ce958484e18a07" translate="yes" xml:space="preserve">
          <source>This is mainly useful in tests, allowing us to assert if given messages were received or not instead of performing checks on some captured IO. Since we need to guarantee a clean slate between tests, there is also a &lt;a href=&quot;#flush/1&quot;&gt;&lt;code&gt;flush/1&lt;/code&gt;&lt;/a&gt; function responsible for flushing all &lt;code&gt;:mix_shell&lt;/code&gt; related messages from the process inbox.</source>
          <target state="translated">这主要在测试中有用，它使我们能够断言是否接收​​到给定消息，而不是对某些捕获的IO进行检查。由于我们需要保证测试之间的间隔 &lt;code&gt;:mix_shell&lt;/code&gt; ，因此还有一个&lt;a href=&quot;#flush/1&quot;&gt; &lt;code&gt;flush/1&lt;/code&gt; &lt;/a&gt;函数负责从进程收件箱中刷新所有与：mix_shell相关的消息。</target>
        </trans-unit>
        <trans-unit id="d3cb696d174caaa2396a3c713ad639f81cfe5da1" translate="yes" xml:space="preserve">
          <source>This is often used to emulate configuration across environments:</source>
          <target state="translated">这通常用于模拟跨环境的配置。</target>
        </trans-unit>
        <trans-unit id="58dabc93b2ce93a10dc83d366ab232e1eea3c140" translate="yes" xml:space="preserve">
          <source>This is often used to start the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; as part of a supervision tree.</source>
          <target state="translated">通常将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用作监督树的一部分来启动GenServer。</target>
        </trans-unit>
        <trans-unit id="320f2d885658e9db2171a44a753f72f41faf6056" translate="yes" xml:space="preserve">
          <source>This is often used to start the agent as part of a supervision tree.</source>
          <target state="translated">这通常用于启动代理作为监督树的一部分。</target>
        </trans-unit>
        <trans-unit id="626d510108035955935a541c301f344a380255ad" translate="yes" xml:space="preserve">
          <source>This is often used to start the process as part of a supervision tree.</source>
          <target state="translated">这经常被用来作为监督树的一部分来启动这个过程。</target>
        </trans-unit>
        <trans-unit id="30067513715299ced12cf77d1d47bd85e8cef7ec" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;macro#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="translated">与&lt;a href=&quot;macro#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt;一起使用时，这通常非常有用，它可以从表达式中删除行和卫生计数器之类的信息以进行存储或比较。</target>
        </trans-unit>
        <trans-unit id="4240cfedebaf42c2fac3f95a041f2d57c453967e" translate="yes" xml:space="preserve">
          <source>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</source>
          <target state="translated">这只在任务用于副作用时使用(即对返回的结果没有兴趣),而且它不应该与当前进程相联系。</target>
        </trans-unit>
        <trans-unit id="077e7548b6aaec650e916de489ebe79d6d5f3c44" translate="yes" xml:space="preserve">
          <source>This is pretty much all we need to implement our echo server. Let&amp;rsquo;s give it a try!</source>
          <target state="translated">这几乎是我们实现回显服务器所需的全部。试一试吧！</target>
        </trans-unit>
        <trans-unit id="81016b61e7a2b5883ac247d4885c2d149315bdb9" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这与&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt;相似，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="50c031832816906ca789ff0f4ad1f1b4dfcf5d4e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#pop_in/2&quot;&gt;&lt;code&gt;pop_in/2&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这类似于&lt;a href=&quot;#pop_in/2&quot;&gt; &lt;code&gt;pop_in/2&lt;/code&gt; &lt;/a&gt;，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="7523a1751f43741a0a08ddae723c5c9199fa87e6" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#put_in/3&quot;&gt;&lt;code&gt;put_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这类似于&lt;a href=&quot;#put_in/3&quot;&gt; &lt;code&gt;put_in/3&lt;/code&gt; &lt;/a&gt;，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="22e8ffb1e74ab770f905747e9a80ef5c0478eb99" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#update_in/3&quot;&gt;&lt;code&gt;update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">这与&lt;a href=&quot;#update_in/3&quot;&gt; &lt;code&gt;update_in/3&lt;/code&gt; &lt;/a&gt;相似，除了路径是通过宏而不是通过列表提取的。例如：</target>
        </trans-unit>
        <trans-unit id="08ab0b2ff940cf63760635df2e0fe23beb3cbaa7" translate="yes" xml:space="preserve">
          <source>This is similar to the mistake we made when we called &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; straight from the registry. That meant a failure in any bucket would bring the whole registry down.</source>
          <target state="translated">这类似于我们直接从注册表中调用 &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; 时所犯的错误。这意味着任何存储桶中的故障都会使整个注册表崩溃。</target>
        </trans-unit>
        <trans-unit id="e61420057f50d9b6c715f4347be7ca8efd78730b" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;uri#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both reserved and unreserved characters are kept unescaped.</source>
          <target state="translated">这是&lt;a href=&quot;uri#encode/2&quot;&gt; &lt;code&gt;URI.encode/2&lt;/code&gt; &lt;/a&gt;使用的默认值，其中保留和未保留的字符都保持不转义。</target>
        </trans-unit>
        <trans-unit id="0dc79651e84bb5089915ce0f6bd2c110d8036119" translate="yes" xml:space="preserve">
          <source>This is the function invoked when there is string interpolation.</source>
          <target state="translated">这是字符串插值时调用的函数。</target>
        </trans-unit>
        <trans-unit id="9b687c89eb6e152da4dd73f09f730d0ddb490ab0" translate="yes" xml:space="preserve">
          <source>This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">这是Erlang VM用来查找模块代码的目录列表。</target>
        </trans-unit>
        <trans-unit id="a08d7b564f58b24087fbb35fa3617eff44897de1" translate="yes" xml:space="preserve">
          <source>This is the moment, in your calendar, when the current day ends and the next day starts.</source>
          <target state="translated">在你的日历中,这是当前一天结束和第二天开始的时刻。</target>
        </trans-unit>
        <trans-unit id="9162b52e4ae81113f3c3ee3bea2997ff399ccecc" translate="yes" xml:space="preserve">
          <source>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</source>
          <target state="translated">这是自ISO 8601记数法0000-01-01+00:00T00:00.000000(也称为公元前1月1日午夜的格里高利历)以来,包括最后一天的小数部分在内的天数。</target>
        </trans-unit>
        <trans-unit id="289ea50e9ca33fea490350d4d95a5411c3088228" translate="yes" xml:space="preserve">
          <source>This is the same AST as &lt;code&gt;not(left in right)&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;not(left in right)&lt;/code&gt; 相同（左向右）。</target>
        </trans-unit>
        <trans-unit id="b6d704491ec250974e27401b8e2b811c3f199e66" translate="yes" xml:space="preserve">
          <source>This is the same template generated by &lt;code&gt;mix new --sup&lt;/code&gt;.</source>
          <target state="translated">这是由 &lt;code&gt;mix new --sup&lt;/code&gt; 生成的模板。</target>
        </trans-unit>
        <trans-unit id="5580fdfd5d3be89e971bd5cfbc417edd38ca5b8e" translate="yes" xml:space="preserve">
          <source>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</source>
          <target state="translated">这是Elixir中每当我们有一个表达式块时使用的特殊形式。这种特殊形式是私有的,不应直接调用。</target>
        </trans-unit>
        <trans-unit id="ac7417af7c2a4cf8300b3d4dd8d7d38b6e9711f6" translate="yes" xml:space="preserve">
          <source>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check &lt;a href=&quot;#unescape_string/2&quot;&gt;&lt;code&gt;unescape_string/2&lt;/code&gt;&lt;/a&gt; for information on how to customize the escaping map.</source>
          <target state="translated">这是Elixir单引号和双引号字符串中默认使用的转义行为。检查&lt;a href=&quot;#unescape_string/2&quot;&gt; &lt;code&gt;unescape_string/2&lt;/code&gt; &lt;/a&gt;以获取有关如何自定义转义图的信息。</target>
        </trans-unit>
        <trans-unit id="13cd7a952e7bcf9bdf6ec9068841b4aa1581c6f4" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information.</source>
          <target state="translated">通常在基于模块的管理器的&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调的末尾调用此函数。有关更多信息，请参见模块文档中的&amp;ldquo;基于模块的主管&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4c3451cd606049c68c6fdb6bd088a1087ca448fd" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the sections &quot;Module-based supervisors&quot; and &quot;start_link/2, init/2, and strategies&quot; in the module documentation for more information.</source>
          <target state="translated">通常在基于模块的管理器的&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调的末尾调用此函数。有关更多信息，请参见模块文档中的&amp;ldquo;基于模块的管理器&amp;rdquo;和&amp;ldquo; start_link / 2，init / 2和策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="af7248045672bdf709fa9a7434ee693bbb5b3f33" translate="yes" xml:space="preserve">
          <source>This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code:</source>
          <target state="translated">这是Elixir的代码格式化器用来避免在某些特定位置中断代码的。例如,考虑这段代码。</target>
        </trans-unit>
        <trans-unit id="b9e62f945dfe72ca17b7bcf35230b54a13d5ce33" translate="yes" xml:space="preserve">
          <source>This is used by third-party projects, like QuickCheck, to implement macros like &lt;code&gt;property/3&lt;/code&gt; that works like &lt;code&gt;test&lt;/code&gt; but instead defines a property. See &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; implementation for an example of invoking this function.</source>
          <target state="translated">第三方项目（如QuickCheck）使用它来实现诸如 &lt;code&gt;property/3&lt;/code&gt; 之类的宏，该宏的作用类似于 &lt;code&gt;test&lt;/code&gt; ,但定义了一个属性。有关调用此功能的示例，请参见&lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="7c60447d6bcf0312eb4c4e52c080f8e8aeffd1b2" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">这在调试由特定进程执行的特定代码块时非常有用。该过程将成为IEx命令的评估者，并且会暂时更改为具有自定义组负责人。通过调用&lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt; &lt;/a&gt;还原这些值，这将启动一个新的IEx shell，从而释放撬出的外壳。</target>
        </trans-unit>
        <trans-unit id="aaba5c733f8e5f3a464f80421ccdf2cbfb12126e" translate="yes" xml:space="preserve">
          <source>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">如果默认值的计算成本很高,或者一般很难设置和再次拆解,这一点很有用。</target>
        </trans-unit>
        <trans-unit id="e90f6c096938c0c1b08fe0f1a4ed6112b1726e64" translate="yes" xml:space="preserve">
          <source>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">如果数值的计算非常昂贵,或者一般难以设置和再次拆解,这一点很有用。</target>
        </trans-unit>
        <trans-unit id="5a46a616db1ce450247219cde25e3ee509bdc87d" translate="yes" xml:space="preserve">
          <source>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</source>
          <target state="translated">当需要运行一个流时,这很有用,因为副作用,而且对其返回结果没有兴趣。</target>
        </trans-unit>
        <trans-unit id="8454071c897ae3b3f6c5cf6b435c8859ed4d0efe" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is even capable of expanding structs defined under the module being compiled.</source>
          <target state="translated">当一个结构需要在编译时被展开,而被展开的结构可能已经被编译过,也可能还没有被编译过,这个函数就很有用。这个函数甚至可以扩展在被编译的模块下定义的结构。</target>
        </trans-unit>
        <trans-unit id="5765e6f4f6c943fc2869a6d958ffb07d4ecdc95a" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="translated">通常由以&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;开头的会话调用。这允许当前进程执行到下一个断点，这将自动将控制权交还给IEx，而无需请求允许撬动。</target>
        </trans-unit>
        <trans-unit id="d5c28e5992d11ab017599cfba8c0660377868c31" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="translated">通常由需要在项目上定义其他功能的任务来调用。由于此类任务通常取决于定义的项目，因此在没有可用项目的情况下，此函数会引发&lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="89c99ecc9ec64bbd119250b6f605dbf4510f1e46" translate="yes" xml:space="preserve">
          <source>This key is optional, only needed for applications that start a supervision tree.</source>
          <target state="translated">这个键是可选的,只有启动监督树的应用才需要。</target>
        </trans-unit>
        <trans-unit id="29ecf7d31c543b3beaa11f8d6b32d12f2cddd50a" translate="yes" xml:space="preserve">
          <source>This lets you put imports in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">如果您打开模块不可用的控制台，则可以将导入放入 &lt;code&gt;.iex.exs&lt;/code&gt; 文件（包括 &lt;code&gt;~/.iex.exs&lt;/code&gt; ）中，而不会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="e5847e98d18087e669daaf541b861bb0616506ae" translate="yes" xml:space="preserve">
          <source>This lets you use the module in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">如果您打开一个模块不可用的控制台，则可以在 &lt;code&gt;.iex.exs&lt;/code&gt; 文件（包括 &lt;code&gt;~/.iex.exs&lt;/code&gt; ）中使用该模块，而不会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="e593f23f33013dc92ddfcd3a9c60d10f99bd1858" translate="yes" xml:space="preserve">
          <source>This linear behaviour should also be expected on operations like &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#at/2&quot;&gt;&lt;code&gt;at/2&lt;/code&gt;&lt;/a&gt; and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</source>
          <target state="translated">在诸如&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#at/2&quot;&gt; &lt;code&gt;at/2&lt;/code&gt; 之&lt;/a&gt;类的操作上也应该期望这种线性行为。尽管Elixir确实允许数据类型为此类操作提供高性能的变体，但您不应期望它始终可用，因为&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块旨在使用多种数据类型，并且并非所有数据类型都可以提供优化的性能。</target>
        </trans-unit>
        <trans-unit id="0519fbd8b9b5639ec90e00d83250f771f4f40453" translate="yes" xml:space="preserve">
          <source>This macro addresses this issue by checking if the file exists or not in behalf of the user.</source>
          <target state="translated">这个宏通过代表用户检查文件是否存在来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="5cc6e8a94ed92b3b0f91dd0c407badd0f4cd9583" translate="yes" xml:space="preserve">
          <source>This macro defines a module with the given &lt;code&gt;alias&lt;/code&gt; as its name and with the given contents. It returns a tuple with four elements:</source>
          <target state="translated">该宏定义了一个模块，该模块具有给定的 &lt;code&gt;alias&lt;/code&gt; 作为其名称并具有给定的内容。它返回一个包含四个元素的元组：</target>
        </trans-unit>
        <trans-unit id="ba5022c9c8161864d7b55a2f306a7cb1932890b2" translate="yes" xml:space="preserve">
          <source>This macro evaluates and returns the &lt;code&gt;do&lt;/code&gt; block passed in as the second argument if &lt;code&gt;condition&lt;/code&gt; evaluates to a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;). Otherwise, it returns the value of the &lt;code&gt;else&lt;/code&gt; block if present or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">如果 &lt;code&gt;condition&lt;/code&gt; 的值为 &lt;code&gt;false&lt;/code&gt; （false或 &lt;code&gt;nil&lt;/code&gt; ），则此宏将求值并返回作为第二个参数传入的 &lt;code&gt;do&lt;/code&gt; 块。否则，如果存在则返回 &lt;code&gt;else&lt;/code&gt; 块的值，否则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="053dc4326086a38d85524369b85300ca1b5d0614" translate="yes" xml:space="preserve">
          <source>This macro expects the first argument to be a condition and the second argument to be a keyword list.</source>
          <target state="translated">这个宏希望第一个参数是一个条件,第二个参数是一个关键字列表。</target>
        </trans-unit>
        <trans-unit id="b7318b11fdb5ce2984ea08a62c18118bc9d28bcc" translate="yes" xml:space="preserve">
          <source>This makes your code clearer and easier to test and maintain, as you can invoke and test &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; directly. It also helps you design an actual API for developers that do not want to rely on macros.</source>
          <target state="translated">因为您可以直接调用和测试 &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; ，所以这使您的代码更清晰，更易于测试和维护。它还可以帮助您为不想依赖宏的开发人员设计实际的API。</target>
        </trans-unit>
        <trans-unit id="781a3479b6ef9afbd878f1e315bbde3afc7381db" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">这意味着可以扩展&lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt;以提供自定义查找。缺点是，函数不能作为键存储在访问的数据结构中。</target>
        </trans-unit>
        <trans-unit id="cfd9674170ea7f680e0ec4f0f9ace7b923ad6168" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">这意味着可以将&lt;a href=&quot;#get_in/2&quot;&gt; &lt;code&gt;get_in/2&lt;/code&gt; &lt;/a&gt;扩展为提供自定义查找。缺点是，函数不能作为键存储在访问的数据结构中。</target>
        </trans-unit>
        <trans-unit id="7a04c313f02da8b2b423b92a32377c49ecdd6219" translate="yes" xml:space="preserve">
          <source>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</source>
          <target state="translated">这意味着文件可以在节点之间传递,消息传递保证它们可以在网络中写入同一个文件。</target>
        </trans-unit>
        <trans-unit id="1e15019a33fea88c51d5e497980380e75ee3dd48" translate="yes" xml:space="preserve">
          <source>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</source>
          <target state="translated">这意味着在使用该模块中的函数时,与直接使用二进制文件的更低级的操作相比,往往会有性能成本。</target>
        </trans-unit>
        <trans-unit id="8571bea1bef1bde6a2d1b2d12776f78df57e4340" translate="yes" xml:space="preserve">
          <source>This means our implementation is going in the correct direction, but it doesn&amp;rsquo;t look very elegant, does it?</source>
          <target state="translated">这意味着我们的实现朝着正确的方向发展，但是看起来并不优雅，是吗？</target>
        </trans-unit>
        <trans-unit id="64cb76e001bde4ce0c23b9ae9350ed13f2f87e6d" translate="yes" xml:space="preserve">
          <source>This means reserved characters, such as &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default.</source>
          <target state="translated">这意味着保留字符（例如 &lt;code&gt;:&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; ）以及具有转义和未转义含义相同的所谓未保留字符在默认情况下不会被转义。</target>
        </trans-unit>
        <trans-unit id="466121cf36d188101adba56c09d86681a5f8592b" translate="yes" xml:space="preserve">
          <source>This means that when performing multiple operations with &lt;code&gt;Enum&lt;/code&gt;, each operation is going to generate an intermediate list until we reach the result:</source>
          <target state="translated">这意味着，当使用 &lt;code&gt;Enum&lt;/code&gt; 执行多个操作时，每个操作将生成一个中间列表，直到我们得到结果：</target>
        </trans-unit>
        <trans-unit id="e439478d8b723981d4581d054a8682120535699c" translate="yes" xml:space="preserve">
          <source>This means the VM no longer needs to keep the stacktrace once inside an &lt;code&gt;else&lt;/code&gt; clause and so tail recursion is possible when using a &lt;code&gt;try&lt;/code&gt; with a tail call as the final call inside an &lt;code&gt;else&lt;/code&gt; clause. The same is true for &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; clauses.</source>
          <target state="translated">这意味着虚拟机不再需要保持堆栈跟踪一次内部 &lt;code&gt;else&lt;/code&gt; 条款，所以使用时尾递归可以 &lt;code&gt;try&lt;/code&gt; 用尾调用作为内部最终调用 &lt;code&gt;else&lt;/code&gt; 条款。 &lt;code&gt;rescue&lt;/code&gt; 条款和 &lt;code&gt;catch&lt;/code&gt; 条款也是如此。</target>
        </trans-unit>
        <trans-unit id="03cbb2743a8fea6a87cdaa1b5871df611958047b" translate="yes" xml:space="preserve">
          <source>This means we can also configure our &lt;code&gt;:routing_table&lt;/code&gt; directly in the &lt;code&gt;config/config.exs&lt;/code&gt; file. However, which configuration value should we use?</source>
          <target state="translated">这意味着我们也可以直接在 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中配置 &lt;code&gt;:routing_table&lt;/code&gt; 。但是，我们应该使用哪个配置值？</target>
        </trans-unit>
        <trans-unit id="d88b91b0ac64ad4e82abb4e5d0dae196f85569c8" translate="yes" xml:space="preserve">
          <source>This message was triggered by invoking the helper &lt;code&gt;h()&lt;/code&gt;, usually referred to as &lt;a href=&quot;#h/0&quot;&gt;&lt;code&gt;h/0&lt;/code&gt;&lt;/a&gt; (since it expects 0 arguments).</source>
          <target state="translated">该消息是通过调用辅助程序 &lt;code&gt;h()&lt;/code&gt; 触发的，通常被称为&lt;a href=&quot;#h/0&quot;&gt; &lt;code&gt;h/0&lt;/code&gt; &lt;/a&gt;（因为它需要0个参数）。</target>
        </trans-unit>
        <trans-unit id="0f38cc8ed71ef5111e6f4d0950287ab1718bd370" translate="yes" xml:space="preserve">
          <source>This module allows a developer to define a test case template to be used throughout their tests. This is useful when there are a set of functions that should be shared between tests or a set of setup callbacks.</source>
          <target state="translated">这个模块允许开发人员定义一个测试用例模板,以便在整个测试中使用。当有一组函数需要在测试之间共享或一组设置回调时,这很有用。</target>
        </trans-unit>
        <trans-unit id="29465ded0e12b42e58045ba6de87bf204437ce87" translate="yes" xml:space="preserve">
          <source>This module allows developers to specify a string that serves as template for log messages, for example:</source>
          <target state="translated">该模块允许开发人员指定一个字符串作为日志消息的模板,例如。</target>
        </trans-unit>
        <trans-unit id="4305f790d0ec82e224afef341de114e73b6a1e74" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块还文档中的宏，大约药剂的编译环境返回信息，如（&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b8d05e55cf46fce50db35799f75e85316f97b59d" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">此模块还包括用于调试目的的帮助程序，有关更多信息，请参见&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef6795d77de60f24997761f8faf2a5faa8a9879b" translate="yes" xml:space="preserve">
          <source>This module also provides low-level functions, such as &lt;a href=&quot;#next/2&quot;&gt;&lt;code&gt;next/2&lt;/code&gt;&lt;/a&gt;, for parsing switches manually, as well as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#to_argv/1&quot;&gt;&lt;code&gt;to_argv/1&lt;/code&gt;&lt;/a&gt; for parsing from and converting switches to strings.</source>
          <target state="translated">此模块还提供了低级功能，例如&lt;a href=&quot;#next/2&quot;&gt; &lt;code&gt;next/2&lt;/code&gt; &lt;/a&gt;，用于手动分析开关，以及&lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#to_argv/1&quot;&gt; &lt;code&gt;to_argv/1&lt;/code&gt; ,&lt;/a&gt;用于从开关进行解析并将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="08818329b397b72cb93efb576183f5c8fee90efe" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;stream#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">此模块还提供了许多用于创建流的便捷功能，例如&lt;a href=&quot;stream#cycle/1&quot;&gt; &lt;code&gt;Stream.cycle/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stream#unfold/2&quot;&gt; &lt;code&gt;Stream.unfold/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="ad2b3a4e9085aa555ad326d7ab4e688a30372b07" translate="yes" xml:space="preserve">
          <source>This module also provides other convenience functions like &lt;code&gt;assert_in_delta&lt;/code&gt; and &lt;code&gt;assert_raise&lt;/code&gt; to easily handle other common cases such as checking a floating-point number or handling exceptions.</source>
          <target state="translated">该模块还提供其他便利功能，例如 &lt;code&gt;assert_in_delta&lt;/code&gt; 和 &lt;code&gt;assert_raise&lt;/code&gt; ,以轻松处理其他常见情况，例如检查浮点数或处理异常。</target>
        </trans-unit>
        <trans-unit id="9e2d831a828a6863612cdac8824ced54a83aa6de" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;exunit.callbacks&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process lifecycle.</source>
          <target state="translated">此模块自动包括&lt;a href=&quot;exunit.callbacks&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; 中&lt;/a&gt;定义的所有回调。有关 &lt;code&gt;setup&lt;/code&gt; ， &lt;code&gt;start_supervised&lt;/code&gt; ， &lt;code&gt;on_exit&lt;/code&gt; 和测试过程生命周期的更多信息，请参见该模块。</target>
        </trans-unit>
        <trans-unit id="a6257d1fd58c649338860fae4d9c7189fabdb3f2" translate="yes" xml:space="preserve">
          <source>This module complements Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt; to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</source>
          <target state="translated">此模块是对Erlang的&lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 模块&lt;/a&gt;的补充，以添加特定于Elixir的行为。此模块中的几乎所有功能都对Elixir的行为产生全局副作用。</target>
        </trans-unit>
        <trans-unit id="653ac253ebf8eeb2f4ad27098db4993bb2625263" translate="yes" xml:space="preserve">
          <source>This module contains a set of assertion functions that are imported by default into your test cases.</source>
          <target state="translated">这个模块包含了一组默认导入测试用例的断言函数。</target>
        </trans-unit>
        <trans-unit id="922f087298c98adf032ad8b0ed4a5b0046285656" translate="yes" xml:space="preserve">
          <source>This module contains functions to manipulate files.</source>
          <target state="translated">该模块包含操作文件的功能。</target>
        </trans-unit>
        <trans-unit id="999b5229e2658017fe9fe551f8ab83bda85a2221" translate="yes" xml:space="preserve">
          <source>This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour:</source>
          <target state="translated">这个模块包含三个编译和评估文件的函数。下面是它们的摘要和行为。</target>
        </trans-unit>
        <trans-unit id="6edd43c8bb392184539818160b2c1a73b42dd599" translate="yes" xml:space="preserve">
          <source>This module defines a behaviour for providing time zone data.</source>
          <target state="translated">该模块定义了提供时区数据的行为。</target>
        </trans-unit>
        <trans-unit id="fc612a9ae903e6387df477d371e55523892dcb6f" translate="yes" xml:space="preserve">
          <source>This module defines a supervisor which can be used to dynamically supervise tasks.</source>
          <target state="translated">该模块定义了一个监督器,可以用来动态监督任务。</target>
        </trans-unit>
        <trans-unit id="ff54a5422bbcc14ae0339cf9003ae87e696322e7" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;a href=&quot;#setup/1&quot;&gt;&lt;code&gt;setup/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup/2&quot;&gt;&lt;code&gt;setup/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#setup_all/2&quot;&gt;&lt;code&gt;setup_all/2&lt;/code&gt;&lt;/a&gt; callbacks, as well as the &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">此模块定义&lt;a href=&quot;#setup/1&quot;&gt; &lt;code&gt;setup/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setup/2&quot;&gt; &lt;code&gt;setup/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#setup_all/2&quot;&gt; &lt;code&gt;setup_all/2&lt;/code&gt; &lt;/a&gt;回调，以及&lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="adca2c4f19b234afbf1c3981b55410081f195e79" translate="yes" xml:space="preserve">
          <source>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</source>
          <target state="translated">本模块定义了在Elixir中使用日历、日期、时间和日期时间的职责。</target>
        </trans-unit>
        <trans-unit id="1b157bc741bdfd8ba6ae8d42ded3b63cf4cd77d7" translate="yes" xml:space="preserve">
          <source>This module implements the functionality described in &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;&quot;Strictly Pretty&quot; (2000) by Christian Lindig&lt;/a&gt; with small additions, like support for binary nodes and a break mode that maximises use of horizontal space.</source>
          <target state="translated">该模块实现了&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Christian Lindig&lt;/a&gt;在&amp;ldquo; Strictly Pretty&amp;rdquo;（2000年）中描述的功能，并增加了一些附加功能，例如对二进制节点的支持以及使水平空间的使用最大化的中断模式。</target>
        </trans-unit>
        <trans-unit id="112202a17c89837b3a647d3e666a456f2e4b078d" translate="yes" xml:space="preserve">
          <source>This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the &lt;code&gt;when&lt;/code&gt; operator. For example:</source>
          <target state="translated">该模块包括Elixir开发人员使用的内置防护。它们是一组预定义的函数和宏，可以增强模式匹配，通常在 &lt;code&gt;when&lt;/code&gt; 运算符之后调用。例如：</target>
        </trans-unit>
        <trans-unit id="83714cee8828e8f9110c531415bac329978b2d35" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块，请改用&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="698253e94267be04646f8c090c390fb2cc54ab28" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="translated">不建议使用此模块。代替&lt;a href=&quot;#defcallback/1&quot;&gt; &lt;code&gt;defcallback/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#defmacrocallback/1&quot;&gt; &lt;code&gt;defmacrocallback/1&lt;/code&gt; &lt;/a&gt;，可以分别使用 &lt;code&gt;@callback&lt;/code&gt; 和 &lt;code&gt;@macrocallback&lt;/code&gt; 模块属性。有关这些属性的更多信息，请参见&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="fdf2b70f41d95f88ee9e4aeda784850c33cb6114" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use @callback and @macrocallback attributes instead.</source>
          <target state="translated">这个模块已经废弃了。使用@callback和@macrocallback属性代替。</target>
        </trans-unit>
        <trans-unit id="21c46dbb91fb819b2c0d1361c70dbb30920cffa0" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map instead.</source>
          <target state="translated">这个模块已经不适用了。使用Map代替。</target>
        </trans-unit>
        <trans-unit id="39e094eeeb209ce88d3bf96eb154f3cef16627e8" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map or Keyword modules instead.</source>
          <target state="translated">此模块已被废弃,请使用地图或关键字模块。使用地图或关键字模块代替。</target>
        </trans-unit>
        <trans-unit id="45cb95722786d1fc420f1550713942a3d2a40ee4" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use MapSet instead.</source>
          <target state="translated">这个模块已经废弃。使用MapSet代替。</target>
        </trans-unit>
        <trans-unit id="b8d2e8897e9809b530aad6556d1d82b7d911062f" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块。请改用&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="ff61ace86ab234eb7df8bf6ecf37e092b5b0882a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">不建议使用此模块。请改用&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="51805cd79a5e913405d55c2dfa613daced6e0652" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="translated">该模块已被废弃。请使用 Supervisor 模块中概述的新的子规范。</target>
        </trans-unit>
        <trans-unit id="090a0510a4b709bb729894c57c0c587dc11055ba" translate="yes" xml:space="preserve">
          <source>This module is most commonly used to define application configuration, typically in &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">该模块最常用于定义应用程序配置，通常在 &lt;code&gt;config/config.exs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="2befac5116f60db9c19a013fd1aa9a67a87481ad" translate="yes" xml:space="preserve">
          <source>This module must be used in other modules as a way to configure and prepare them for testing.</source>
          <target state="translated">该模块必须在其他模块中使用,作为配置和准备测试的方式。</target>
        </trans-unit>
        <trans-unit id="5b22afa6be61052c1f9cdf8dac15ff3c336d6750" translate="yes" xml:space="preserve">
          <source>This module provides 3 main APIs for you to use:</source>
          <target state="translated">这个模块提供了3个主要的API供你使用。</target>
        </trans-unit>
        <trans-unit id="769d078447abaa6265ad7bb0de8a70d942cff612" translate="yes" xml:space="preserve">
          <source>This module provides a Mix shell implementation that uses the current process mailbox for communication instead of IO.</source>
          <target state="translated">该模块提供了一个Mix shell的实现,它使用当前进程邮箱来代替IO进行通信。</target>
        </trans-unit>
        <trans-unit id="61d141fedc9a9bf97077c1d4c4dd489c9b785e1b" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块提供了遍历其他结构（如元组和列表）的便捷功能。这些功能可以在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中所有与&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;有关的功能和宏中使用。</target>
        </trans-unit>
        <trans-unit id="782a5e74e17fd10ef3053ba12c4f6db6d729bfdd" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for manipulating or retrieving file system paths.</source>
          <target state="translated">该模块提供了操作或检索文件系统路径的便利。</target>
        </trans-unit>
        <trans-unit id="da08bc2535ffa10b4ff19a553d1b9ea3a60095e8" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure.</source>
          <target state="translated">该模块为在编译时处理记录提供了便利,编译时的字段名用于操作元组,在元组的紧凑结构之上提供了快速操作。</target>
        </trans-unit>
        <trans-unit id="d8865f287fbd66961e8c5ed897c4cb1e98bb7854" translate="yes" xml:space="preserve">
          <source>This module provides data encoding and decoding functions according to &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;.</source>
          <target state="translated">该模块根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;提供数据编码和解码功能。</target>
        </trans-unit>
        <trans-unit id="775daee9805ae8be33fdd0d2d338cd5f646e58b6" translate="yes" xml:space="preserve">
          <source>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;.</source>
          <target state="translated">此模块提供用于处理URI的功能（例如，解析URI或编码查询字符串）。此模块中的功能根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="975d761a831604643250ee0022304cbf208c888f" translate="yes" xml:space="preserve">
          <source>This module relies on this behaviour to ignore such invalid characters. For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; will return a correct result even if an invalid code point is fed into it.</source>
          <target state="translated">此模块依靠此行为来忽略此类无效字符。例如，即使将无效的代码点输入给&lt;a href=&quot;#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;，length / 1也将返回正确的结果。</target>
        </trans-unit>
        <trans-unit id="a2a3fd3d8cfc91e72f80f4c370ccf8f3a32b7b9d" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="translated">该模块使用字节大小计算剩余的空间。如果您的文档包含字符串，则需要将它们包装在&lt;a href=&quot;#string/1&quot;&gt; &lt;code&gt;string/1&lt;/code&gt; 中&lt;/a&gt;，然后使用&lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;来预先计算文档的大小。</target>
        </trans-unit>
        <trans-unit id="bf6c5bbe802615e0aa5a1527fbeb868a3dd4e46f" translate="yes" xml:space="preserve">
          <source>This operation happens in constant time.</source>
          <target state="translated">这个操作是在恒定的时间内发生的。</target>
        </trans-unit>
        <trans-unit id="0323d90aa13d0480aa31c479eb72ceeb1afc3cbd" translate="yes" xml:space="preserve">
          <source>This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given &lt;code&gt;iodata&lt;/code&gt; is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation.</source>
          <target state="translated">该操作旨在与未经编码启动的&amp;ldquo;原始&amp;rdquo;设备一起使用。给定的 &lt;code&gt;iodata&lt;/code&gt; 将直接写入设备，而无需进行转换。有关IO数据的更多信息，请参见模块文档中的&amp;ldquo; IO数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="caa455aca538782e938e4b888f46d0efc72ad432" translate="yes" xml:space="preserve">
          <source>This operation is not recursive.</source>
          <target state="translated">这个操作不是递归的。</target>
        </trans-unit>
        <trans-unit id="6cf233431f4056abd018dbc95c859c52d627d1ab" translate="yes" xml:space="preserve">
          <source>This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on.</source>
          <target state="translated">这个操作可能很昂贵,因为它从文件系统中读取数据,解析梁文件,评估代码等。</target>
        </trans-unit>
        <trans-unit id="4ac87cbe297ccc151c1adeb864d9d02cdda18b09" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;enum#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="translated">此运算符（是宏）仅转换为对&lt;a href=&quot;enum#member?/2&quot;&gt; &lt;code&gt;Enum.member?/2&lt;/code&gt; &lt;/a&gt;的调用。上面的示例将转换为：</target>
        </trans-unit>
        <trans-unit id="331fe094cd09d757ad66d6f225117b31c709d88f" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For match comparison, use &lt;a href=&quot;#!==/2&quot;&gt;&lt;code&gt;!==/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">该运算符认为1和1.0相等。对于匹配比较，请使用&lt;a href=&quot;#!==/2&quot;&gt; &lt;code&gt;!==/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a93d5027785794a41da95cb35f0cd6d2acb007f9" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For stricter semantics, use &lt;a href=&quot;#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">该运算符认为1和1.0相等。对于更严格的语义，请改用&lt;a href=&quot;#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d9501c58df67371e18635ed16fc7a445f5df561" translate="yes" xml:space="preserve">
          <source>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</source>
          <target state="translated">这个运算符将左手边的表达式作为右手边函数调用的第一个参数引入。</target>
        </trans-unit>
        <trans-unit id="f341e422c93c5bb9c0446195cea1180bec59b5b7" translate="yes" xml:space="preserve">
          <source>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</source>
          <target state="translated">在Elixir中,这个操作符在两种不同的场合下使用。它在 typespecs 中用于指定变量、函数或类型本身的类型。</target>
        </trans-unit>
        <trans-unit id="769404e29fd0d9c0c1b74fd982594f4931cda146" translate="yes" xml:space="preserve">
          <source>This protocol requires four functions to be implemented, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#slice/1&quot;&gt;&lt;code&gt;slice/1&lt;/code&gt;&lt;/a&gt;. The core of the protocol is the &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.</source>
          <target state="translated">该协议需要实现四个功能，&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#slice/1&quot;&gt; &lt;code&gt;slice/1&lt;/code&gt; &lt;/a&gt;。该协议的核心是&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt;功能。所有其他功能作为数据结构的优化路径而存在，可以比线性时间更好地实现某些属性。</target>
        </trans-unit>
        <trans-unit id="fb7da1dc23c1e9f315adf4ca89a991f2f576c3b4" translate="yes" xml:space="preserve">
          <source>This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the &lt;code&gt;zip/1&lt;/code&gt; and &lt;code&gt;zip/2&lt;/code&gt; functions).</source>
          <target state="translated">该协议使用标记的元组在化简函数和实现该协议的数据类型之间交换信息。这样可以高效完成资源（例如文件）的枚举，同时还可以确保在枚举结束时将关闭资源。该协议还允许中止枚举，这在需要许多可枚举之间的交织时非常有用（如 &lt;code&gt;zip/1&lt;/code&gt; 和 &lt;code&gt;zip/2&lt;/code&gt; 函数中所示）。</target>
        </trans-unit>
        <trans-unit id="0d2faccf1f4cab6a9360849e0c4b192286433613" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="translated">从IO读取为UTF-8。&lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; &lt;/a&gt;出IO.binstream / 2以将IO作为原始二进制文件进行处理。</target>
        </trans-unit>
        <trans-unit id="fb3289e1168d746e447207053b10b0f0b058ccb5" translate="yes" xml:space="preserve">
          <source>This returns true if a task is marked as recursive and it is being executed inside an umbrella project.</source>
          <target state="translated">如果任务被标记为递归,并且在伞形项目中执行,则返回true。</target>
        </trans-unit>
        <trans-unit id="ea9af91069aa4c9d64215d6cd9db073871191b73" translate="yes" xml:space="preserve">
          <source>This section covers built-in attributes. However, attributes can also be used by developers or extended by libraries to support custom behaviour.</source>
          <target state="translated">本节介绍了内置属性。然而,属性也可以被开发者使用,或者被库扩展以支持自定义行为。</target>
        </trans-unit>
        <trans-unit id="cd8870a170daeec23154d49d471c2dd9485fac0a" translate="yes" xml:space="preserve">
          <source>This shortcut will be extremely useful as we build our project, allowing us to quickly iterate by running a single test.</source>
          <target state="translated">在我们构建项目的过程中,这个快捷方式将非常有用,它允许我们通过运行一个测试来快速迭代。</target>
        </trans-unit>
        <trans-unit id="bd1e1ed3f015a12c58d63db1a9d93b599be9e3dd" translate="yes" xml:space="preserve">
          <source>This structure is enough to compile our project:</source>
          <target state="translated">这个结构足以编译我们的项目。</target>
        </trans-unit>
        <trans-unit id="5aeacadd2f95dc684bd082e5479290a732535d0b" translate="yes" xml:space="preserve">
          <source>This syntax is very convenient as it can be nested arbitrarily:</source>
          <target state="translated">这种语法非常方便,因为它可以任意嵌套。</target>
        </trans-unit>
        <trans-unit id="a3f217bb694fd565ea5471a5519af65161e8bfcb" translate="yes" xml:space="preserve">
          <source>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</source>
          <target state="translated">这种语法反映了有效尺寸是由尺寸乘以单位给出的。</target>
        </trans-unit>
        <trans-unit id="d91886050dfd3b8b0ffcd36baeadec3113935150" translate="yes" xml:space="preserve">
          <source>This task also removes documentation and debugging chunks from the compiled &lt;code&gt;.beam&lt;/code&gt; files to reduce the size of the escript. If this is not desired, check the &lt;code&gt;:strip_beams&lt;/code&gt; option.</source>
          <target state="translated">此任务还从已编译的 &lt;code&gt;.beam&lt;/code&gt; 文件中删除文档和调试块，以减小escript的大小。如果不希望这样做，请检查 &lt;code&gt;:strip_beams&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="1b4cda0b866fc4bd88710556e9ee176eb8201a71" translate="yes" xml:space="preserve">
          <source>This task guarantees the project and its dependencies are compiled and packages them inside an escript. Before invoking &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, it is only necessary to define a &lt;code&gt;:escript&lt;/code&gt; key with a &lt;code&gt;:main_module&lt;/code&gt; option in your &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">该任务确保项目及其依赖项被编译并将其打包在escript中。在调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;之前，只需要在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中使用 &lt;code&gt;:main_module&lt;/code&gt; 选项定义一个 &lt;code&gt;:escript&lt;/code&gt; 键：</target>
        </trans-unit>
        <trans-unit id="7b95bdbfd4b655866a594149ce367ef4e30f87be" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times to load different configs.</source>
          <target state="translated">这个任务会自动重新启用,所以可以多次调用它来加载不同的配置。</target>
        </trans-unit>
        <trans-unit id="60b7baa6b3d14e1c34ecb1ce263c22e53b326d02" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times with different arguments.</source>
          <target state="translated">这个任务是自动重新启用的,所以可以用不同的参数多次调用。</target>
        </trans-unit>
        <trans-unit id="26dd7e67f1b7b3ef5db86ff692753739683ca6d1" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times.</source>
          <target state="translated">这个任务会自动重新启用,所以可以多次调用。</target>
        </trans-unit>
        <trans-unit id="ee1da0440bde8a127669b55f6844894777d90f76" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can perform multiple cross reference checks in the same Mix invocation.</source>
          <target state="translated">这个任务会自动重新启用,所以你可以在同一个Mix调用中执行多个交叉引用检查。</target>
        </trans-unit>
        <trans-unit id="59102e430969db44aa9dbab5520c01e316dd3de5" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can profile multiple times in the same Mix invocation.</source>
          <target state="translated">这个任务会自动重新启用,所以你可以在同一个Mix调用中多次配置文件。</target>
        </trans-unit>
        <trans-unit id="25ec3e34affdc5b118add6428766793ecf3c3afd" translate="yes" xml:space="preserve">
          <source>This task starts the current application, loads up &lt;code&gt;test/test_helper.exs&lt;/code&gt; and then requires all files matching the &lt;code&gt;test/**/*_test.exs&lt;/code&gt; pattern in parallel.</source>
          <target state="translated">此任务将启动当前应用程序，加载 &lt;code&gt;test/test_helper.exs&lt;/code&gt; ，然后要求并行匹配 &lt;code&gt;test/**/*_test.exs&lt;/code&gt; 模式的所有文件。</target>
        </trans-unit>
        <trans-unit id="b4d9fcf010b1211b86ea4237770d26b428fafb33" translate="yes" xml:space="preserve">
          <source>This time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt;, one extra test should run and successfully pass as long as the &lt;code&gt;bar@computer-name&lt;/code&gt; node is available.</source>
          <target state="translated">这次所有测试都通过了，ExUnit警告我们分布式测试被排除在外了。如果使用 &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt; 运行测试，则只要 &lt;code&gt;bar@computer-name&lt;/code&gt; 节点可用，就应该运行一项额外的测试并成功通过。</target>
        </trans-unit>
        <trans-unit id="477d833785327cf68017043ef90fe5f9da786575" translate="yes" xml:space="preserve">
          <source>This time is monotonically increasing and starts in an unspecified point in time.</source>
          <target state="translated">这个时间是单调递增的,并从一个不确定的时间点开始。</target>
        </trans-unit>
        <trans-unit id="d29fa001afdf2d6ca161492ebf202a329eec33bb" translate="yes" xml:space="preserve">
          <source>This time let&amp;rsquo;s add a &lt;code&gt;:distributed&lt;/code&gt; tag to &lt;code&gt;test/kv/router_test.exs&lt;/code&gt;:</source>
          <target state="translated">这次，我们将一个 &lt;code&gt;:distributed&lt;/code&gt; 标签添加到 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8a08500e8bc91707c167cbe26d52c3bd3806ea0d" translate="yes" xml:space="preserve">
          <source>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</source>
          <target state="translated">这个时间可以无限制地向前或向后调整,而且不是单调的。</target>
        </trans-unit>
        <trans-unit id="6d3ccee502b139d7db4ac43bc5181f6363d2dc18" translate="yes" xml:space="preserve">
          <source>This time the supervisor started a named registry, allowing us to create buckets without having to explicitly fetch the PID from the supervisor. You should also know how to make the registry crash again, without looking up its PID: give it a try.</source>
          <target state="translated">这次主管启动了一个命名的注册表,使我们可以创建桶,而不必明确地从主管那里获取PID。你应该也知道如何让注册表再次崩溃,而不需要查找它的PID:试一试。</target>
        </trans-unit>
        <trans-unit id="2674a77869b19062b86e06c05052e9cdedb0c192" translate="yes" xml:space="preserve">
          <source>This time, since our test relies on global data, we have not given &lt;code&gt;async: true&lt;/code&gt; to &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Furthermore, in order to guarantee our test is always in a clean state, we stop and start the &lt;code&gt;:kv&lt;/code&gt; application before each test. In fact, stopping the &lt;code&gt;:kv&lt;/code&gt; application even prints a warning on the terminal:</source>
          <target state="translated">这一次，因为我们的测试依赖于全局数据，我们没有给 &lt;code&gt;async: true&lt;/code&gt; 要 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 。此外，为了确保我们的测试始终处于干净状态，请在每次测试之前停止并启动 &lt;code&gt;:kv&lt;/code&gt; 应用程序。实际上，停止 &lt;code&gt;:kv&lt;/code&gt; 应用程序甚至会在终端上显示警告：</target>
        </trans-unit>
        <trans-unit id="c22b7275344f29b83a9a0084e4877ef048fc7831" translate="yes" xml:space="preserve">
          <source>This time, we have joined two aliases, defining the final alias &lt;code&gt;Hello.World&lt;/code&gt;.</source>
          <target state="translated">这次，我们加入了两个别名，定义了最终别名 &lt;code&gt;Hello.World&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f412811fd9f81fa6e535feea04f5cd402448c56" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="translated">该元组遵循Elixir中通用引用的表达式结构，名称为第一个参数，某些关键字列表作为元数据为第二个，参数列表为第三个。在这种情况下，参数是别名&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;和atom &lt;code&gt;:downcase&lt;/code&gt; 。远程调用中的第二个参数&lt;strong&gt;始终&lt;/strong&gt;是一个原子。</target>
        </trans-unit>
        <trans-unit id="09127719cfc463768ae7ae77dbace1cb3021f292" translate="yes" xml:space="preserve">
          <source>This way if you have a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for 2018-08-24 10:00:00 in UTC you can do:</source>
          <target state="translated">这样，如果您在一个时区中有一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，则可以在另一个时区中获得相同的时间。例如，如果您在哥本哈根有2018-08-24 10:00:00，并且想要在UTC中有2018-08-24 10:00:00的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="07671b087d75abe1588362cd61ce69e954d8e6a8" translate="yes" xml:space="preserve">
          <source>This will appear to the &lt;code&gt;node&lt;/code&gt; as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns &lt;code&gt;true&lt;/code&gt; if disconnection succeeds, otherwise &lt;code&gt;false&lt;/code&gt;. If the local node is not alive, the function returns &lt;code&gt;:ignored&lt;/code&gt;.</source>
          <target state="translated">这将对 &lt;code&gt;node&lt;/code&gt; 显示，好像本地节点已崩溃。此功能主要用于Erlang网络身份验证协议中。如果断开连接成功，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果本地节点未处于活动状态，则该函数返回 &lt;code&gt;:ignored&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3db39e63e0c8d60956e47f7856c88ea07f5720f2" translate="yes" xml:space="preserve">
          <source>This will cause the operating system process to exit with the status given by &lt;code&gt;integer&lt;/code&gt; while signaling all linked Erlang processes to politely shut down.</source>
          <target state="translated">这将导致操作系统进程以 &lt;code&gt;integer&lt;/code&gt; 给定的状态退出，同时发信号通知所有链接的Erlang进程以礼貌地关闭。</target>
        </trans-unit>
        <trans-unit id="932ec01a6dc27cb0bacb799b1bb13427b2604043" translate="yes" xml:space="preserve">
          <source>This will generate a file named &lt;code&gt;Elixir.Math.beam&lt;/code&gt; containing the bytecode for the defined module. If we start &lt;code&gt;iex&lt;/code&gt; again, our module definition will be available (provided that &lt;code&gt;iex&lt;/code&gt; is started in the same directory the bytecode file is in):</source>
          <target state="translated">这将生成一个名为 &lt;code&gt;Elixir.Math.beam&lt;/code&gt; 的文件，其中包含已定义模块的字节码。如果再次启动 &lt;code&gt;iex&lt;/code&gt; ，则模块定义将可用（前提是 &lt;code&gt;iex&lt;/code&gt; 在字节码文件所在的同一目录中启动）：</target>
        </trans-unit>
        <trans-unit id="3e50caa68b186c476cfb0083912fddaf93761ce6" translate="yes" xml:space="preserve">
          <source>This won't work as it will rather try to invoke the local function &lt;code&gt;fun&lt;/code&gt;:</source>
          <target state="translated">这将不起作用，因为它将尝试调用局部函数 &lt;code&gt;fun&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="988a9f0b35eb11882e7b92d107c2e4d9a3c956cd" translate="yes" xml:space="preserve">
          <source>This works because accessing anything on a &lt;code&gt;nil&lt;/code&gt; value, returns &lt;code&gt;nil&lt;/code&gt; itself:</source>
          <target state="translated">之所以有效，是因为访问 &lt;code&gt;nil&lt;/code&gt; 值上的任何东西，本身都会返回 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a9ae4006317b94bfaa968ed593d618d9dbca367b" translate="yes" xml:space="preserve">
          <source>This works:</source>
          <target state="translated">这个很管用</target>
        </trans-unit>
        <trans-unit id="35b2e50e251cc0ba39a82b26384abdc7366f7bc3" translate="yes" xml:space="preserve">
          <source>This would be repetitive to write every time we need this check, so, as mentioned at the beginning of this section, we can abstract this away using a macro. Remember that defining a function that performs this check wouldn't work because we can't use custom functions in guards. Use &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; to create guard macros. Here's an example:</source>
          <target state="translated">每次需要此检查时，这都是重复的，因此，如本节开头所述，我们可以使用宏将其抽象化。请记住，定义执行该检查的功能将不起作用，因为我们无法在后卫中使用自定义功能。使用 &lt;code&gt;defguard&lt;/code&gt; 和 &lt;code&gt;defguardp&lt;/code&gt; 创建保护宏。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="e6043c141b8f19b7be4caf31617881f52b255da5" translate="yes" xml:space="preserve">
          <source>This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it.</source>
          <target state="translated">这就相当于得到所有的文件内容,并将其全部打包成一行在IEx中执行。</target>
        </trans-unit>
        <trans-unit id="6ff1d4baf9340ffd06f6ffb996d0e212cbfa8737" translate="yes" xml:space="preserve">
          <source>Those are all protocols that ship with Elixir and they are being consolidated. Because a protocol can dispatch to any data type, the protocol must check on every call if an implementation for the given type exists. This may be expensive.</source>
          <target state="translated">这些都是Elixir附带的协议,它们正在被合并。因为一个协议可以调度到任何数据类型,所以协议必须在每次调用时检查是否存在给定类型的实现。这可能是昂贵的。</target>
        </trans-unit>
        <trans-unit id="20eb63dea1b46358d700b88edabba7314d37424c" translate="yes" xml:space="preserve">
          <source>Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST.</source>
          <target state="translated">这些构造只存在于语法层面。上面所有的例子在AST中都以它们的底层整数来表示。</target>
        </trans-unit>
        <trans-unit id="2a23b257e1a8396bae8e624da37c5fa4a14cd69d" translate="yes" xml:space="preserve">
          <source>Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.</source>
          <target state="translated">这些文件是并行编译的,可以自动检测它们之间的依赖关系。一旦发现依赖关系,当前文件就会停止编译,直到依赖关系解决为止。</target>
        </trans-unit>
        <trans-unit id="e697466781be26b9795959553f68c3100b1e1fc6" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).</source>
          <target state="translated">这些功能被优化为处理常见的纪元,如上面的Unix纪元或Gregorian纪元(0000-01-01 00:00:00)。</target>
        </trans-unit>
        <trans-unit id="c4de8ddc259e007e8ba142a7f915e7b9f301d071" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</source>
          <target state="translated">这些功能经过优化,可以处理常见的纪元,如上面的Unix纪元或Gregorian纪元(0000-01-01)。</target>
        </trans-unit>
        <trans-unit id="394d2aacfa0d4e93088c549af6bbb4449e2dc409" translate="yes" xml:space="preserve">
          <source>Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.</source>
          <target state="translated">这些函数将在其文档中明确标记为 &quot;编译器内联&quot;。</target>
        </trans-unit>
        <trans-unit id="63c1f7abeafa00aa21caec35b0a45a7d4562b860" translate="yes" xml:space="preserve">
          <source>Those options are shared across all modes:</source>
          <target state="translated">这些选项在所有模式中都是共享的。</target>
        </trans-unit>
        <trans-unit id="7600e9dc66e9f49a5eef98b40a90050ef4b71a9b" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="translated">这些选项可以在项目配置文件中进行配置，也可以通过从 &lt;code&gt;~/.iex.exs&lt;/code&gt; 文件中调用&lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; 进行&lt;/a&gt;全局配置。例如：</target>
        </trans-unit>
        <trans-unit id="74a14ac9f70e4b2f7b26991bd0d257ac84bd9ed1" translate="yes" xml:space="preserve">
          <source>Those options mean all dependencies will be checked out to &lt;code&gt;kv_umbrella/deps&lt;/code&gt;, and they will share the same build, config and lock files. We haven&amp;rsquo;t talked about configuration yet, but from here we can build the intuition that all configuration and dependencies are shared across all projects in an umbrella, and it is not per application.</source>
          <target state="translated">这些选项意味着所有依赖项都将检出到 &lt;code&gt;kv_umbrella/deps&lt;/code&gt; ，并且它们将共享相同的构建，配置和锁定文件。我们还没有讨论过配置，但是从这里我们可以直觉，所有配置和依赖项在一个伞中跨所有项目共享，而不是针对每个应用程序。</target>
        </trans-unit>
        <trans-unit id="ff34978b55b28c6dbd12a23ca68d40a4861e6f90" translate="yes" xml:space="preserve">
          <source>Those performance characteristics dictate the usage of those data structures. One very common use case for tuples is to use them to return extra information from a function. For example, &lt;code&gt;File.read/1&lt;/code&gt; is a function that can be used to read file contents. It returns a tuple:</source>
          <target state="translated">这些性能特征决定了这些数据结构的使用。元组的一种非常常见的用例是使用它们从函数中返回额外的信息。例如， &lt;code&gt;File.read/1&lt;/code&gt; 是可用于读取文件内容的函数。它返回一个元组：</target>
        </trans-unit>
        <trans-unit id="c4f3c9a9eefe9427c2dedc41fe39d6f07ee20806" translate="yes" xml:space="preserve">
          <source>Those situations are quite uncommon in practice except when interfacing with libraries that do not provide a proper API. For example, let&amp;rsquo;s imagine the &lt;code&gt;Enum&lt;/code&gt; module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers:</source>
          <target state="translated">这些情况在实践中很少见，除非与不提供适当API的库接口时。例如，假设 &lt;code&gt;Enum&lt;/code&gt; 模块没有提供任何用于查找值的API，而我们需要在数字列表中查找13的第一个倍数：</target>
        </trans-unit>
        <trans-unit id="aad090c769c6e03a992f9e5138ceea80922ae0f4" translate="yes" xml:space="preserve">
          <source>Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, got familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.</source>
          <target state="translated">在整个指南中,我们构建了一个非常简单的分布式键值存储,以此为契机,我们探索了许多构造,如通用服务器、主管、任务、代理、应用等。不仅如此,我们还为整个应用程序编写了测试,熟悉了ExUnit,并学会了如何使用Mix构建工具来完成各种任务。</target>
        </trans-unit>
        <trans-unit id="d3b0d5df9824877f9b29731225c4ba90e068aada" translate="yes" xml:space="preserve">
          <source>Throughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions &lt;code&gt;hd/1&lt;/code&gt; and &lt;code&gt;tl/1&lt;/code&gt;. Let&amp;rsquo;s assign a list to a variable and retrieve its head and tail:</source>
          <target state="translated">在整个教程中，我们将大量讨论列表的开头和结尾。头部是列表的第一个元素，而尾部是列表的其余部分。可以使用功能 &lt;code&gt;hd/1&lt;/code&gt; 和 &lt;code&gt;tl/1&lt;/code&gt; 检索它们。让我们为变量分配一个列表并检索其头部和尾部：</target>
        </trans-unit>
        <trans-unit id="090c252d7880a95a839fb25bf07e4aad923532bf" translate="yes" xml:space="preserve">
          <source>Throughout this tutorial, we have been using the notation &lt;code&gt;name/arity&lt;/code&gt; to refer to functions. It happens that this notation can actually be used to retrieve a named function as a function type. Start &lt;code&gt;iex&lt;/code&gt;, running the &lt;code&gt;math.exs&lt;/code&gt; file defined above:</source>
          <target state="translated">在本教程中，我们一直使用符号 &lt;code&gt;name/arity&lt;/code&gt; 来表示函数。碰巧这种表示法实际上可以用于检索命名函数作为函数类型。启动 &lt;code&gt;iex&lt;/code&gt; ，运行上面定义的 &lt;code&gt;math.exs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="4dc17499006fce61c64e8dfd0c8c4c038df992f0" translate="yes" xml:space="preserve">
          <source>Time representations with reduced accuracy are not supported.</source>
          <target state="translated">不支持精度降低的时间表示。</target>
        </trans-unit>
        <trans-unit id="9452a856dc424a6f92632b47f9b6540703986d72" translate="yes" xml:space="preserve">
          <source>Time zone database</source>
          <target state="translated">时区数据库</target>
        </trans-unit>
        <trans-unit id="dad962fdacc68e64400f9f34e93f5814f862947c" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</source>
          <target state="translated">时区偏移可以包含在字符串中,但它们将被直接丢弃,因为这些信息不包含在天真的日期时间中。</target>
        </trans-unit>
        <trans-unit id="55ded65dce8b65205b0b4f7c820bffa416a68f37" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</source>
          <target state="translated">时区偏移可以包含在字符串中,但它们将被直接丢弃,因为这些信息不包含在时间中。</target>
        </trans-unit>
        <trans-unit id="f905b9189d8d13ac7a8491eceeb00e40cf5247c7" translate="yes" xml:space="preserve">
          <source>Time zone period for a point in time in UTC for a specific time zone.</source>
          <target state="translated">以UTC为单位的某一特定时区时间点的时区周期。</target>
        </trans-unit>
        <trans-unit id="4ca2fde51c11eb446c9f4471c5d166e6cd917c52" translate="yes" xml:space="preserve">
          <source>Timeout is set to 0, so there is no waiting time.</source>
          <target state="translated">超时设置为0,所以没有等待时间。</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="f1b3091799895b01e6aa24802a8c476d47d3c391" translate="yes" xml:space="preserve">
          <source>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</source>
          <target state="translated">为了符合Unicode标准,本模块中的许多函数都以线性时间运行,因为它们需要遍历整个字符串,考虑适当的Unicode码点。</target>
        </trans-unit>
        <trans-unit id="916b5fa900a6f384af0597e7d8f402a05c3c1c1f" translate="yes" xml:space="preserve">
          <source>To aid in the correct implementation of behaviours, you may optionally declare &lt;code&gt;@impl&lt;/code&gt; for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:</source>
          <target state="translated">为了帮助正确实现行为，您可以选择为行为的已实现回调声明 &lt;code&gt;@impl&lt;/code&gt; 。这使回调变得显式，并可以帮助您捕获代码中的错误。在以下情况下，编译器将发出警告：</target>
        </trans-unit>
        <trans-unit id="688d49bd28e977f5619e4299defc87b3580ff416" translate="yes" xml:space="preserve">
          <source>To assert exits from linked processes started from the test, trap exits with &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt;&lt;code&gt;Process.flag/2&lt;/code&gt;&lt;/a&gt; and assert the exit message with &lt;a href=&quot;#assert_received/2&quot;&gt;&lt;code&gt;assert_received/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要声明从测试开始的链接进程的退出，陷阱将使用&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt; &lt;code&gt;Process.flag/2&lt;/code&gt; &lt;/a&gt;退出，并使用&lt;a href=&quot;#assert_received/2&quot;&gt; &lt;code&gt;assert_received/2&lt;/code&gt; &lt;/a&gt;声明退出消息。</target>
        </trans-unit>
        <trans-unit id="60dda8ca6a65152c1c53235c6221b24d765a7234" translate="yes" xml:space="preserve">
          <source>To avoid printing log messages during tests, ExUnit provides a neat feature called &lt;code&gt;:capture_log&lt;/code&gt;. By setting &lt;code&gt;@tag :capture_log&lt;/code&gt; before each test or &lt;code&gt;@moduletag :capture_log&lt;/code&gt; for the whole test case, ExUnit will automatically capture anything that is logged while the test runs. In case our test fails, the captured logs will be printed alongside the ExUnit report.</source>
          <target state="translated">为避免在测试期间打印日志消息，ExUnit提供了一个名为 &lt;code&gt;:capture_log&lt;/code&gt; 的简洁功能。通过设置 &lt;code&gt;@tag :capture_log&lt;/code&gt; 每次测试或之前 &lt;code&gt;@moduletag :capture_log&lt;/code&gt; 整个测试案例，ExUnit会自动捕获任何记录，而试运行。万一我们的测试失败，捕获的日志将与ExUnit报告一起打印。</target>
        </trans-unit>
        <trans-unit id="f974b60e8a8ca0fdff2c240dbeb8be96e5b7e1d4" translate="yes" xml:space="preserve">
          <source>To avoid that late answers (after the timeout) pollute the caller's message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process.</source>
          <target state="translated">为了避免延迟应答(超时后)污染呼叫者的消息队列,使用一个中间人进程来进行实际呼叫。迟来的应答在到达终止的进程时将被丢弃。</target>
        </trans-unit>
        <trans-unit id="915324fb4db3a9cfde09b72fdeb57083f3b6ada4" translate="yes" xml:space="preserve">
          <source>To be converted to a string, a list must either be empty or only contain the following elements:</source>
          <target state="translated">要转换为字符串,列表必须为空或只包含以下元素。</target>
        </trans-unit>
        <trans-unit id="fc7a4b67b1cf2b13d1bec5831057b11f1a8ac991" translate="yes" xml:space="preserve">
          <source>To check the Unicode version of your current Elixir installation, run &lt;code&gt;String.Unicode.version()&lt;/code&gt;.</source>
          <target state="translated">要检查当前Elixir安装的Unicode版本，请运行 &lt;code&gt;String.Unicode.version()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32741725588800279ae172b79b44e5964f47f63a" translate="yes" xml:space="preserve">
          <source>To convert maps into keywords and vice-versa, use the &lt;code&gt;new&lt;/code&gt; function in the respective modules.</source>
          <target state="translated">要将地图转换为关键字，反之亦然，请在相应模块中使用 &lt;code&gt;new&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="90fe397a356898d27888dc41d52d7983ef57d2b2" translate="yes" xml:space="preserve">
          <source>To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="translated">要创建自定义 &lt;code&gt;sigil_{identifier}&lt;/code&gt; ，请定义一个名称为sigil_ {identifier}的函数，该函数带有两个参数。第一个参数是字符串，第二个参数是包含任何修饰符的字符列表。如果sigil是小写字母（例如 &lt;code&gt;sigil_x&lt;/code&gt; ），则字符串参数将允许插值。如果sigil是大写字母（例如 &lt;code&gt;sigil_X&lt;/code&gt; ），则不会插入字符串。</target>
        </trans-unit>
        <trans-unit id="bb585bff51bf0b0752f3b9643ada939cb21bacf2" translate="yes" xml:space="preserve">
          <source>To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (for function callbacks and macro callbacks respectively).</source>
          <target state="translated">要定义一个行为模块，在该模块中定义一个或多个回调就足够了。要定义回调，可以使用 &lt;code&gt;@callback&lt;/code&gt; 和 &lt;code&gt;@macrocallback&lt;/code&gt; 模块属性（分别用于函数回调和宏回调）。</target>
        </trans-unit>
        <trans-unit id="748c36f2db63d3a03dc4e6fadef52aac3b262d3c" translate="yes" xml:space="preserve">
          <source>To define a struct, a developer must define both &lt;code&gt;__struct__/0&lt;/code&gt; and &lt;code&gt;__struct__/1&lt;/code&gt; functions. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; is a convenience macro which defines such functions with some conveniences.</source>
          <target state="translated">要定义结构，开发人员必须同时定义 &lt;code&gt;__struct__/0&lt;/code&gt; 和 &lt;code&gt;__struct__/1&lt;/code&gt; 函数。&lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt;是一个便利宏，它以一些便利来定义此类功能。</target>
        </trans-unit>
        <trans-unit id="5e46e68069cc59aab3678e72e8671077b9e1f5c1" translate="yes" xml:space="preserve">
          <source>To define a struct, the &lt;code&gt;defstruct&lt;/code&gt; construct is used:</source>
          <target state="translated">要定义一个结构，可以使用 &lt;code&gt;defstruct&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="15c7a0bd6bb05c83760ad9659631936c1f603b9d" translate="yes" xml:space="preserve">
          <source>To define an operator, you can use the usual &lt;code&gt;def*&lt;/code&gt; constructs (&lt;code&gt;def&lt;/code&gt;, &lt;code&gt;defp&lt;/code&gt;, &lt;code&gt;defmacro&lt;/code&gt;, and so on) but with a syntax similar to how the operator is used:</source>
          <target state="translated">要定义运算符，可以使用常用的 &lt;code&gt;def*&lt;/code&gt; 构造（ &lt;code&gt;def&lt;/code&gt; ， &lt;code&gt;defp&lt;/code&gt; ， &lt;code&gt;defmacro&lt;/code&gt; 等），但语法类似于使用运算符的方式：</target>
        </trans-unit>
        <trans-unit id="b1416bbc268b001f44ff03e41dd657568db375a9" translate="yes" xml:space="preserve">
          <source>To determine how many seconds the &lt;code&gt;:native&lt;/code&gt; unit represents in your current runtime, you can can call this function to convert 1 second to the &lt;code&gt;:native&lt;/code&gt; time unit: &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt;.</source>
          <target state="translated">要确定 &lt;code&gt;:native&lt;/code&gt; 单位在当前运行时中所代表的秒数，可以调用此函数将1秒钟转换为 &lt;code&gt;:native&lt;/code&gt; 时间单位： &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb35bc4715abc885d6ad16dcca4ef00591e6ce0e" translate="yes" xml:space="preserve">
          <source>To differentiate the program behavior depending on the environment, it is recommended to use application environment through &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt;. Proper configuration can be set in config files, often per-environment (see the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module for more information).</source>
          <target state="translated">为了根据环境区分程序行为，建议通过&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; &lt;/a&gt;使用应用程序环境。可以在每个环境中的配置文件中设置正确的配置（有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;模块）。</target>
        </trans-unit>
        <trans-unit id="ade0297c81614f897441b308bffb7079cbf4b959" translate="yes" xml:space="preserve">
          <source>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</source>
          <target state="translated">要发现一个模块的公共功能或其他模块,键入模块名称后加一个点,然后按tab键触发自动完成。例如</target>
        </trans-unit>
        <trans-unit id="0f350e9537ca99b19347d61d7b15f4ba1b815fe4" translate="yes" xml:space="preserve">
          <source>To display &quot;What is your name?&quot; as a prompt and await user input:</source>
          <target state="translated">要显示 &quot;你叫什么名字?&quot;作为提示并等待用户输入。</target>
        </trans-unit>
        <trans-unit id="9392c58481cde14e24d585ca66473875cbcb0d13" translate="yes" xml:space="preserve">
          <source>To drive the point home, imagine you want to validate a certain attribute only if a given condition is met. We could easily achieve it with the first solution, by manipulating the data structure accordingly, or with the second solution by using conditionals (if/else) before invoking the function. However, it is impossible to do so with the macros approach unless its DSL is augmented.</source>
          <target state="translated">为了让大家明白这一点,想象一下,只有在满足给定条件的情况下,你才想验证某个属性。我们可以通过第一种解决方案,通过对数据结构进行相应的操作,或者通过在调用函数之前使用条件(if/else),轻松地实现这一目标。但是,用宏方法是不可能做到的,除非对其DSL进行增强。</target>
        </trans-unit>
        <trans-unit id="842501ce37fce5610a16f26dd98d6da220a3b08e" translate="yes" xml:space="preserve">
          <source>To exit a breakpoint, the developer can either invoke &lt;code&gt;continue()&lt;/code&gt;, which will block the shell until the next breakpoint is found or the process terminates, or invoke &lt;code&gt;respawn()&lt;/code&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">要退出断点，开发人员可以调用 &lt;code&gt;continue()&lt;/code&gt; ，它将阻塞外壳程序，直到找到下一个断点或进程终止为止；或者可以调用 &lt;code&gt;respawn()&lt;/code&gt; ，后者启动一个新的IEx shell，以释放撬出的外壳程序。</target>
        </trans-unit>
        <trans-unit id="a3c693fb70a5169722986ac65b4c67dfb305f68f" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s change the function and its callback as follows:</source>
          <target state="translated">要解决该故障，我们需要使用 &lt;code&gt;call/2&lt;/code&gt; 而不是 &lt;code&gt;cast/2&lt;/code&gt; 来使 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 同步。这将确保客户端仅在对表进行更改后才能继续。让我们如下更改函数及其回调：</target>
        </trans-unit>
        <trans-unit id="d939e666619b837bbfc72a19c0edb64540f7b914" translate="yes" xml:space="preserve">
          <source>To give the formatter a try, change a file in the &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; directories to include extra spaces or extra newlines, such as &lt;code&gt;def  hello  do&lt;/code&gt;, and then run &lt;code&gt;mix format&lt;/code&gt;.</source>
          <target state="translated">要尝试格式化程序，请在 &lt;code&gt;lib&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 目录中更改文件以包含额外的空格或额外的换行符，例如 &lt;code&gt;def hello do&lt;/code&gt; ，然后运行 &lt;code&gt;mix format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a15120dae8d76afe9639289d60fb9093810c397a" translate="yes" xml:space="preserve">
          <source>To help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny &lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;GenServer cheat sheet&lt;/a&gt;.</source>
          <target state="translated">为了帮助开发人员记住调用，&lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;强制转换&lt;/a&gt;和信息之间的差异，支持的返回值等等，我们提供了一个很小的GenServer备忘单。</target>
        </trans-unit>
        <trans-unit id="555a879eb773cd3d2dff7da0f2a52cb90ca0b876" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;Application&lt;/code&gt; behaviour, we have to &lt;code&gt;use Application&lt;/code&gt; and define a &lt;code&gt;start/2&lt;/code&gt; function. The goal of &lt;code&gt;start/2&lt;/code&gt; is to start a supervisor, which will then start any child services or execute any other code our application may need. Let&amp;rsquo;s use this opportunity to start the &lt;code&gt;KV.Supervisor&lt;/code&gt; we have implemented earlier in this chapter.</source>
          <target state="translated">要实现 &lt;code&gt;Application&lt;/code&gt; 行为，我们必须 &lt;code&gt;use Application&lt;/code&gt; 并定义一个 &lt;code&gt;start/2&lt;/code&gt; 函数。 &lt;code&gt;start/2&lt;/code&gt; 的目标是启动主管，然后主管将启动任何子服务或执行应用程序可能需要的任何其他代码。让我们利用这个机会来启动我们在本章前面实现的 &lt;code&gt;KV.Supervisor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee64280d1fb25258cd437b5d0c77efe55acbd252" translate="yes" xml:space="preserve">
          <source>To learn more about IEx as a whole, type &lt;code&gt;h(IEx)&lt;/code&gt;.</source>
          <target state="translated">要总体上了解有关IEx的更多信息，请键入 &lt;code&gt;h(IEx)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699ef2c862a7af01ce3ea7b060fc68320ed60961" translate="yes" xml:space="preserve">
          <source>To learn more about floating-point arithmetic visit:</source>
          <target state="translated">要了解更多关于浮点运算的信息,请访问。</target>
        </trans-unit>
        <trans-unit id="101e8672c7193137af23129687e2ed29b0030ea4" translate="yes" xml:space="preserve">
          <source>To learn more about specific optimizations and performance considerations, check out &lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang's Efficiency Guide on handling binaries&lt;/a&gt;.</source>
          <target state="translated">要了解有关特定优化和性能注意事项的更多信息，请查看&lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang关于处理二进制文件的效率指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a32f6bfbd0a46a1fe8412990dabfb9a92464fbb" translate="yes" xml:space="preserve">
          <source>To list all IEx helpers available, which is effectively all exports (functions and macros) in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">要列出所有可用的IEx帮助器，实际上就是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt;模块中的所有导出（函数和宏）：</target>
        </trans-unit>
        <trans-unit id="34f6e4a2bb843898b6a1a63430d9ad523188262e" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="translated">要分析代码，可以使用类似于&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;任务的语法：</target>
        </trans-unit>
        <trans-unit id="b90e482b9b75d2e1ab9c0ff8e4d1e0e5aecc5f06" translate="yes" xml:space="preserve">
          <source>To quote &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;the official guide on Macros&lt;/a&gt;:</source>
          <target state="translated">引用&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;有关宏的官方指南&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e5139cf2a16e17732e5bda38b6b67324152e536b" translate="yes" xml:space="preserve">
          <source>To reply after returning from the callback because the response is not yet available.</source>
          <target state="translated">在从回调中返回后回复,因为响应还没有到。</target>
        </trans-unit>
        <trans-unit id="716f6562922e06c13563ae83ce61a300e8352363" translate="yes" xml:space="preserve">
          <source>To reply before returning from the callback because the response is known before calling a slow function.</source>
          <target state="translated">要在从回调中返回之前回复,因为在调用慢速函数之前已经知道了响应。</target>
        </trans-unit>
        <trans-unit id="e57aadf0943d8ee32b1daf18536595cdf4b85435" translate="yes" xml:space="preserve">
          <source>To reply from another process, such as a task.</source>
          <target state="translated">从另一个进程(如任务)中回复。</target>
        </trans-unit>
        <trans-unit id="aa09c7d0058c95fdae6640e10ab83ae7e2c7d29c" translate="yes" xml:space="preserve">
          <source>To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">要检索当前进程的堆栈跟踪，请改用 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9be81917be7c5a65d20c56cce5430337e7437a2" translate="yes" xml:space="preserve">
          <source>To run our doctests, we&amp;rsquo;ll create a file at &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; and call &lt;code&gt;doctest KVServer.Command&lt;/code&gt; in the test case:</source>
          <target state="translated">要运行doctest，我们将在 &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; 创建一个文件，并在测试用例中调用 &lt;code&gt;doctest KVServer.Command&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c550ca70984ac8e2f646e72f7f0c9faa1dd704b7" translate="yes" xml:space="preserve">
          <source>To run the tests above, run the file using &lt;code&gt;elixir&lt;/code&gt; from the command line. Assuming you named the file &lt;code&gt;assertion_test.exs&lt;/code&gt;, you can run it as:</source>
          <target state="translated">要运行上述测试，请从命令行使用 &lt;code&gt;elixir&lt;/code&gt; 运行文件。假设您将文件命名为 &lt;code&gt;assertion_test.exs&lt;/code&gt; ，则可以按以下方式运行它：</target>
        </trans-unit>
        <trans-unit id="f88b35a6396b6373f09d679595715d5f894666f2" translate="yes" xml:space="preserve">
          <source>To see documentation for each specific compiler, you must invoke &lt;code&gt;help&lt;/code&gt; directly for the compiler command:</source>
          <target state="translated">要查看每个特定编译器的文档，必须直接为编译器命令调用 &lt;code&gt;help&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7fcc2e5f60178276dfc7759916301cae9d1d546f" translate="yes" xml:space="preserve">
          <source>To show all entries, configure the limit to &lt;code&gt;:infinity&lt;/code&gt;:</source>
          <target state="translated">要显示所有条目，请将限制配置为 &lt;code&gt;:infinity&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b50964644227148ad32fc703cd3d520d71c70f6b" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can take again a look at the implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;mapset#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了展示如何实现该协议，我们可以再次看看&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;的实现。在此实现中，&amp;ldquo;收集&amp;rdquo;元素仅意味着通过&lt;a href=&quot;mapset#put/2&quot;&gt; &lt;code&gt;MapSet.put/2&lt;/code&gt; &lt;/a&gt;将它们插入到集合中。</target>
        </trans-unit>
        <trans-unit id="6baefde74a3b1948259d37f28d66b2da3cc95503" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了展示如何手动使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议，让我们&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="5683b1948dc754efdfed9ba11dc087a421c0449e" translate="yes" xml:space="preserve">
          <source>To specify that a module implements a given behaviour, the &lt;code&gt;@behaviour&lt;/code&gt; attribute must be used:</source>
          <target state="translated">要指定模块实现给定的行为，必须使用 &lt;code&gt;@behaviour&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="e0fee1e5263eb41b6e360a95cfaf76805e6190b5" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">要启动管理程序，将在给定 &lt;code&gt;module&lt;/code&gt; 中使用 &lt;code&gt;arg&lt;/code&gt; 作为其参数调用&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调。在&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调必须返回可与的帮助下创建了一个主管规格&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="340467355095ab2102cf53f317a261f28f43cfa1" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;init_arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">要启动管理程序，将在给定 &lt;code&gt;module&lt;/code&gt; 中使用 &lt;code&gt;init_arg&lt;/code&gt; 作为其参数调用&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调。在&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调必须返回可与的帮助下创建了一个主管规格&lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="6bd659c0fd4a88cb66bdff02f16f40278b81dd1f" translate="yes" xml:space="preserve">
          <source>To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions.</source>
          <target state="translated">总结一下:由于格式化器不能改变代码的语义,所以有时需要调整或重构代码以获得最佳的格式化。为了帮助更好地理解如何控制格式化器,我们在接下来的章节中描述格式化器保留用户编码的情况以及如何控制多行表达式。</target>
        </trans-unit>
        <trans-unit id="dc5e717b9aecb2c9e25ade231bba83d35b0f1df7" translate="yes" xml:space="preserve">
          <source>To this point, we have been starting &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;. Typically the registry is started as part of a supervision tree though:</source>
          <target state="translated">至此，我们已经使用&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;启动&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;。通常，注册表是作为监督树的一部分启动的：</target>
        </trans-unit>
        <trans-unit id="f69493266441ce87de2c6a579e769590bf4ddfcf" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="translated">要跟踪您的代码与任务之间的关系，我们在流程字典中使用 &lt;code&gt;$callers&lt;/code&gt; 键。因此，假设上面有&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;调用，我们有：</target>
        </trans-unit>
        <trans-unit id="97175bd03b3eda9bcbde862759fc67493bd67482" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">要在测试期间使用&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;，您需要在 &lt;code&gt;iex&lt;/code&gt; 命令中运行 &lt;code&gt;mix&lt;/code&gt; 并传递 &lt;code&gt;--trace&lt;/code&gt; 来进行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;以避免超时：</target>
        </trans-unit>
        <trans-unit id="ad497a0e7b4707958b2bbdf25658f61ced2eef66" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">要在测试过程中使用&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，您需要在 &lt;code&gt;iex&lt;/code&gt; 命令中运行 &lt;code&gt;mix&lt;/code&gt; 并传递 &lt;code&gt;--trace&lt;/code&gt; 来进行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;以避免超时：</target>
        </trans-unit>
        <trans-unit id="525e76db8eaa15a02d475c0b25c1748678200a4e" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;:keep&lt;/code&gt; with a type other than &lt;code&gt;:string&lt;/code&gt;, use a list as the type for the switch. For example: &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt;.</source>
          <target state="translated">要使用 &lt;code&gt;:keep&lt;/code&gt; 而不是 &lt;code&gt;:string&lt;/code&gt; 的类型，请使用列表作为开关的类型。例如： &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b67f756b7a47a192314501d13fc2788976f1a9c" translate="yes" xml:space="preserve">
          <source>To use the newly defined operators, we &lt;strong&gt;have to&lt;/strong&gt; import the module that defines them:</source>
          <target state="translated">要使用新定义的运算符，我们&lt;strong&gt;必须&lt;/strong&gt;导入定义它们的模块：</target>
        </trans-unit>
        <trans-unit id="f4e084ee0583dab5cdb8f2aaa6336b9ae8900f06" translate="yes" xml:space="preserve">
          <source>To work around this error, redefine the field with your own &amp;amp;M.f/a function, like so:</source>
          <target state="translated">要变通解决此错误，请使用您自己的＆M.f / a函数重新定义该字段，如下所示：</target>
        </trans-unit>
        <trans-unit id="123be2f9bdd25b0f49703cfe940d72bfca8fdce4" translate="yes" xml:space="preserve">
          <source>TokenMissingError</source>
          <target state="translated">TokenMissingError</target>
        </trans-unit>
        <trans-unit id="42d5db27696210e57467dc675285521f0930aa67" translate="yes" xml:space="preserve">
          <source>TokenMissingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TokenMissingError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="cd770bf19fa776a62cbc130cb90d8f5cd6a0b438" translate="yes" xml:space="preserve">
          <source>Tools like Mix may use this information to ensure the module is recompiled in case any of the external resources change.</source>
          <target state="translated">像Mix这样的工具可能会使用这些信息来确保模块在任何外部资源发生变化时被重新编译。</target>
        </trans-unit>
        <trans-unit id="77431b38c8bb01a363da5bccdb519bd75745358b" translate="yes" xml:space="preserve">
          <source>Trailing bang (&lt;code&gt;foo!&lt;/code&gt;)</source>
          <target state="translated">尾随爆炸（ &lt;code&gt;foo!&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ff6cffeaff58c52204a5122da57dc4b26f381da0" translate="yes" xml:space="preserve">
          <source>Trailing question mark (&lt;code&gt;foo?&lt;/code&gt;)</source>
          <target state="translated">尾随问号（ &lt;code&gt;foo?&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b7a933d6378a29d15a7b6795f6516bd8c8f0c0ab" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream with function-based start and finish.</source>
          <target state="translated">用基于函数的开始和结束来转换一个现有的流。</target>
        </trans-unit>
        <trans-unit id="0183630f154b045739040c0a476db00c0d8d8489" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream.</source>
          <target state="translated">改造现有的流。</target>
        </trans-unit>
        <trans-unit id="a0bf22bc28c174dfbe4750edd483edd80c1c1f1c" translate="yes" xml:space="preserve">
          <source>Translates to:</source>
          <target state="translated">译为:</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="eb726f366153f5273c287e7afe4de066bacf45f4" translate="yes" xml:space="preserve">
          <source>Traverses paths according to the given &lt;code&gt;glob&lt;/code&gt; expression and returns a list of matches.</source>
          <target state="translated">根据给定的 &lt;code&gt;glob&lt;/code&gt; 表达式遍历路径并返回匹配项列表。</target>
        </trans-unit>
        <trans-unit id="2b9bae059da0df068a9a43bf70813a2cc0165c80" translate="yes" xml:space="preserve">
          <source>Tries to create the directory &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试创建目录 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1274a0f5d2ed4698598c860012ff8d0e34e7aeca" translate="yes" xml:space="preserve">
          <source>Tries to delete the dir at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试删除 &lt;code&gt;path&lt;/code&gt; 中的目录。</target>
        </trans-unit>
        <trans-unit id="79494b7d121b41ed702af12c8820f16d4b440ca4" translate="yes" xml:space="preserve">
          <source>Tries to delete the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">尝试删除文件 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7267f3b3b246e3958379e99f6b106bc8021e929a" translate="yes" xml:space="preserve">
          <source>Tries to set up a connection to node.</source>
          <target state="translated">试图建立与节点的连接。</target>
        </trans-unit>
        <trans-unit id="836d86c6c848f493d3ff2e48bb6f5f308c9c411f" translate="yes" xml:space="preserve">
          <source>Truthy and falsy values</source>
          <target state="translated">真实和虚假的价值观</target>
        </trans-unit>
        <trans-unit id="a0d62e00a429e56556bf1455c0175bc4654fbf2a" translate="yes" xml:space="preserve">
          <source>Truthy values:</source>
          <target state="translated">真理价值。</target>
        </trans-unit>
        <trans-unit id="ccf6e0cd6e8c63d5ae42d6c2569741d54c61f4d5" translate="yes" xml:space="preserve">
          <source>Try to connect two telnet clients at the same time. When you do so, you will notice that the second client doesn&amp;rsquo;t echo:</source>
          <target state="translated">尝试同时连接两个telnet客户端。这样做时，您会注意到第二个客户端没有回显：</target>
        </trans-unit>
        <trans-unit id="965b5b1e76f73cc1dd48f82e36854d491ebbe607" translate="yes" xml:space="preserve">
          <source>TryClauseError</source>
          <target state="translated">TryClauseError</target>
        </trans-unit>
        <trans-unit id="bb04413eca53d9d4f9ada422b12b458b1a19dc69" translate="yes" xml:space="preserve">
          <source>TryClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TryClauseError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3d6d3a96a93234d43a687b1131b3901f142d46c" translate="yes" xml:space="preserve">
          <source>Trying to access an attribute that was not defined will print a warning:</source>
          <target state="translated">试图访问一个未定义的属性会打印一个警告。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="dc4f3a01c46fc5525a4e91e907b957d6688cd48a" translate="yes" xml:space="preserve">
          <source>Tuple describing the client of a call request.</source>
          <target state="translated">描述调用请求的客户端的元组。</target>
        </trans-unit>
        <trans-unit id="eb4abd3a92bef73903da00d10d474ba4501f6bab" translate="yes" xml:space="preserve">
          <source>Tuple-based HashDict implementation.</source>
          <target state="translated">基于Tuple的HashDict实现。</target>
        </trans-unit>
        <trans-unit id="91c1b6c09400f880e21ca1e3d43c7f7b3443b423" translate="yes" xml:space="preserve">
          <source>Tuple-based HashSet implementation.</source>
          <target state="translated">基于Tuple的HashSet实现。</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="793259df3cfbea29ea94e801a3dc852ba0481364" translate="yes" xml:space="preserve">
          <source>Tuples are compared by size, then element by element.</source>
          <target state="translated">图元组按大小比较,然后按元素比较。</target>
        </trans-unit>
        <trans-unit id="cbb1dd7716c923dc57835e6545295dd3e5141a82" translate="yes" xml:space="preserve">
          <source>Tuples are denoted with curly braces:</source>
          <target state="translated">图元组用大括号表示。</target>
        </trans-unit>
        <trans-unit id="f9d295b48169d12e8a4a885f2969f7ebb5f288bf" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="translated">元组旨在用作多个元素的固定大小的容器。要操作元素集合，请改用列表。&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;函数不适用于元组。</target>
        </trans-unit>
        <trans-unit id="6007daf5620486dbca1cb7e87969100af322cc9f" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="translated">元组通常在函数具有多个返回值或用于错误处理时使用。如果成功读取给定文件，则&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;{:ok, contents}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 例如文件不存在时）。</target>
        </trans-unit>
        <trans-unit id="db66b3f610de5841b308865fc05862649e3b269d" translate="yes" xml:space="preserve">
          <source>Tuples have their own representation, except for two-element tuples, which are represented as themselves:</source>
          <target state="translated">除了双元素元组外,其他元组都有自己的表示方式。</target>
        </trans-unit>
        <trans-unit id="6d23bff74f82a432abab310b02bda096c901d05c" translate="yes" xml:space="preserve">
          <source>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:</source>
          <target state="translated">图元组在内存中连续地存储元素。这意味着通过索引访问一个元组元素或获取元组大小是一个快速的操作。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="4827be384e5b92dfa89593fd34e759c469d83f68" translate="yes" xml:space="preserve">
          <source>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:</source>
          <target state="translated">另一方面,Tuple在内存中是连续存储的。这意味着获取元组大小或通过索引访问元素的速度很快。然而,更新或添加元素到元组是昂贵的,因为它需要在内存中创建一个新的元组。</target>
        </trans-unit>
        <trans-unit id="c4eeec2166369454fe72d485310480999d9e41ff" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node.</source>
          <target state="translated">将一个分布式节点变成一个非分布式节点。</target>
        </trans-unit>
        <trans-unit id="78cb13dab8abb15c4418dcf574cee609f60fff10" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node.</source>
          <target state="translated">将一个非分布式节点变成分布式节点。</target>
        </trans-unit>
        <trans-unit id="0d200b5cca6122d2ea47ef95bc1ae207e6bed360" translate="yes" xml:space="preserve">
          <source>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">如果两个关键字包含相同的键,并且这些键包含相同的值,则认为它们是相等的。</target>
        </trans-unit>
        <trans-unit id="fddf4faa5ad6ac7c7817431eda4bde5737ecc7a7" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="translated">可以使用&lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#--/2&quot;&gt; &lt;code&gt;Kernel.--/2&lt;/code&gt; &lt;/a&gt;运算符来连接和减去两个列表：</target>
        </trans-unit>
        <trans-unit id="c6eb24ea9f355df425e35046856649369306137b" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated or subtracted using the &lt;code&gt;++/2&lt;/code&gt; and &lt;code&gt;--/2&lt;/code&gt; operators respectively:</source>
          <target state="translated">可以分别使用 &lt;code&gt;++/2&lt;/code&gt; 和 &lt;code&gt;--/2&lt;/code&gt; 运算符来连接或减去两个列表：</target>
        </trans-unit>
        <trans-unit id="28dd04de329219b61258e459b05052b6d195ed8c" translate="yes" xml:space="preserve">
          <source>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">如果两个地图包含相同的键,并且这些键包含相同的值,则被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="130c35a2878e328189066b98bf54e31f721289db" translate="yes" xml:space="preserve">
          <source>Type &amp;ldquo;hello&amp;rdquo;, press enter, and you will get &amp;ldquo;hello&amp;rdquo; back. Excellent!</source>
          <target state="translated">输入&amp;ldquo; hello&amp;rdquo;，按Enter，您将返回&amp;ldquo; hello&amp;rdquo;。优秀的！</target>
        </trans-unit>
        <trans-unit id="e252ef20859612096fbf35e99f3db43d0d903502" translate="yes" xml:space="preserve">
          <source>Type checks and other boolean checks that are allowed in guard clauses are named with an &lt;code&gt;is_&lt;/code&gt; prefix.</source>
          <target state="translated">保护子句中允许的类型检查和其他布尔检查使用 &lt;code&gt;is_&lt;/code&gt; 前缀命名。</target>
        </trans-unit>
        <trans-unit id="ce1a99d47d96ec4a8d262432fdeeb24d34842d1c" translate="yes" xml:space="preserve">
          <source>Type specifications (sometimes referred to as &lt;em&gt;typespecs&lt;/em&gt;) are defined in different contexts using the following attributes:</source>
          <target state="translated">使用以下属性在不同的上下文中定义类型规范（有时称为&lt;em&gt;typespecs&lt;/em&gt;）：</target>
        </trans-unit>
        <trans-unit id="c6f295ce9af290691ba77bd28066b72b6d97e560" translate="yes" xml:space="preserve">
          <source>Type variables with no restriction can also be defined using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">无限制的类型变量也可以使用 &lt;code&gt;var&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="9c292c75a9bfb2deb75a816df8b4fa93d8b86cdf" translate="yes" xml:space="preserve">
          <source>Types and specs</source>
          <target state="translated">类型和规格</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
