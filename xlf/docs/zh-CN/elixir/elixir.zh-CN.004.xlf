<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="22c577ef1c31238772ee8831a83e168e224b3891" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO.inspect/2&lt;/code&gt; also provides the ability to decorate the output with a &lt;code&gt;label&lt;/code&gt; option. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IO.inspect/2&lt;/code&gt; 还提供了使用 &lt;code&gt;label&lt;/code&gt; 选项装饰输出的功能。标签将在检查 &lt;code&gt;item&lt;/code&gt; 之前打印：</target>
        </trans-unit>
        <trans-unit id="ab245843059173dbf82eb4fe6e1efb8953b384a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KVServer.Command.run/1&lt;/code&gt;&amp;rsquo;s implementation is sending commands directly to the server named &lt;code&gt;KV.Registry&lt;/code&gt;, which is registered by the &lt;code&gt;:kv&lt;/code&gt; application. This means this server is global and if we have two tests sending messages to it at the same time, our tests will conflict with each other (and likely fail). We need to decide between having unit tests that are isolated and can run asynchronously, or writing integration tests that work on top of the global state, but exercise our application&amp;rsquo;s full stack as it is meant to be exercised in production.</source>
          <target state="translated">&lt;code&gt;KVServer.Command.run/1&lt;/code&gt; 的实现是将命令直接发送到名为 &lt;code&gt;KV.Registry&lt;/code&gt; 的服务器，该服务器由 &lt;code&gt;:kv&lt;/code&gt; 应用程序注册。这意味着该服务器是全局服务器，如果我们有两个同时向其发送消息的测试，则我们的测试将相互冲突（并且可能会失败）。我们需要决定是隔离的，可以异步运行的单元测试，还是编写可以在全局状态之上工作的集成测试，但是要行使应用程序的完整堆栈，因为它打算在生产环境中行使。</target>
        </trans-unit>
        <trans-unit id="da6d4153744f3433ed1a5402789f34e812c03af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; -指定要将档案安装到的目录</target>
        </trans-unit>
        <trans-unit id="8c717830b04d23844afea6b838122a9bdf423ef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed (default: &lt;code&gt;~/.mix/archives&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; -指定要将归档文件安装到的目录（默认值： &lt;code&gt;~/.mix/archives&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f2e7a10def5ff72cf9b8c6ec1feafc70b7396700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#build_path/0&quot;&gt;&lt;code&gt;Mix.Project.build_path/0&lt;/code&gt;&lt;/a&gt; config. This option must always point to a subdirectory inside a temporary directory. For instance, never &quot;/tmp&quot; or &quot;_build&quot; but &quot;_build/PROD&quot; or &quot;/tmp/PROD&quot;, as required by Mix</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; -设置项目&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#build_path/0&quot;&gt; &lt;code&gt;Mix.Project.build_path/0&lt;/code&gt; &lt;/a&gt;配置。此选项必须始终指向临时目录内的子目录。例如，按照Mix的要求，绝不要&amp;ldquo; / tmp&amp;rdquo;或&amp;ldquo; _build&amp;rdquo;，而要&amp;ldquo; _build / PROD&amp;rdquo;或&amp;ldquo; / tmp / PROD&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9e3878570d540f1dc8a3f3f892fd2b11f01cccaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project build_path config</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; -设置项目的build_path配置</target>
        </trans-unit>
        <trans-unit id="9a08f060f5be9937a437a588bee8fc6346fcb193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_ROOT&lt;/code&gt; - sets the root directory where build artifacts should be written to. For example, &quot;_build&quot;. If &lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; is set, this option is ignored.</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_ROOT&lt;/code&gt; -设置应将构建工件写入其中的根目录。例如，&amp;ldquo; _ build&amp;rdquo;。如果设置了 &lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; ，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="0140498ebd7646b788b6566801c7befbab061cb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEBUG&lt;/code&gt; - outputs debug information about each task before running it</source>
          <target state="translated">&lt;code&gt;MIX_DEBUG&lt;/code&gt; -在运行每个任务之前输出有关每个任务的调试信息</target>
        </trans-unit>
        <trans-unit id="11512a24233fbaca58260cd8b783ef9bc74e70b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEPS_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#deps_path/0&quot;&gt;&lt;code&gt;Mix.Project.deps_path/0&lt;/code&gt;&lt;/a&gt; config (default: &lt;code&gt;deps&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_DEPS_PATH&lt;/code&gt; -设置项目&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#deps_path/0&quot;&gt; &lt;code&gt;Mix.Project.deps_path/0&lt;/code&gt; &lt;/a&gt;配置（默认值： &lt;code&gt;deps&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="329ed8db0c467fa57966c2408385f46d68602c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ENV&lt;/code&gt; - specifies which environment should be used. See &lt;a href=&quot;#module-environments&quot;&gt;Environments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_ENV&lt;/code&gt; -指定应使用的环境。查看&lt;a href=&quot;#module-environments&quot;&gt;环境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d50621b63f1f2c2227991dd4eff2fd82684592f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_EXS&lt;/code&gt; - changes the full path to the &lt;code&gt;mix.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;MIX_EXS&lt;/code&gt; -将完整路径更改为 &lt;code&gt;mix.exs&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="0c7e96e7109921de42973a61dead2b979ac90fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; -Mix的主目录的路径，存储配置文件和Mix使用的脚本</target>
        </trans-unit>
        <trans-unit id="03ef2cea06987a0a92a52a0d0f29167ab7220a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix (default: &lt;code&gt;~/.mix&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; -Mix主目录的路径，存储Mix使用的配置文件和脚本（默认值： &lt;code&gt;~/.mix&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="553587fa68acdae7dd360d62677c233b8de4b6a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_PATH&lt;/code&gt; - appends extra code paths</source>
          <target state="translated">&lt;code&gt;MIX_PATH&lt;/code&gt; -附加额外的代码路径</target>
        </trans-unit>
        <trans-unit id="e5e1141c719d2a85373ac124af8fe76e6cceea81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_QUIET&lt;/code&gt; - does not print information messages to the terminal</source>
          <target state="translated">&lt;code&gt;MIX_QUIET&lt;/code&gt; -不向终端打印信息消息</target>
        </trans-unit>
        <trans-unit id="7254592f8891c8c6dd40bd7299fc6ec41c04871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; -覆盖一个Mix安装的rebar3命令的路径</target>
        </trans-unit>
        <trans-unit id="e09832a96f2b1d018a61ea57e9189d15094a9f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar3&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; -覆盖一个Mix安装的rebar3命令的路径（默认值： &lt;code&gt;~/.mix/rebar3&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="06ea93f78b26d8cfb7ce48134404d1f745e0f50b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; -覆盖一个Mix安装的rebar命令的路径</target>
        </trans-unit>
        <trans-unit id="b266a14c80d9857d2f0f79371c5122b2ebde45ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; -覆盖一个Mix安装的rebar命令的路径（默认值： &lt;code&gt;~/.mix/rebar&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9971767c5036a2608426896f053fa0cf39812d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_TARGET&lt;/code&gt; - specifies which target should be used. See &lt;a href=&quot;#module-targets&quot;&gt;Targets&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_TARGET&lt;/code&gt; -指定应使用的目标。查看&lt;a href=&quot;#module-targets&quot;&gt;目标&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73dafaead44cb117058f87e670829a36ef8f794b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_XDG&lt;/code&gt; - asks Mix to follow the &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Directory Specification&lt;/a&gt; for its home directory and configuration files. This behaviour needs to be opt-in due to backwards compatibility. &lt;code&gt;MIX_HOME&lt;/code&gt; has higher preference than &lt;code&gt;MIX_XDG&lt;/code&gt;. If none of the variables are set, the default directory &lt;code&gt;~/.mix&lt;/code&gt; will be used</source>
          <target state="translated">&lt;code&gt;MIX_XDG&lt;/code&gt; -要求Mix遵循&lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG目录规范&lt;/a&gt;为其主目录和配置文件。由于向后兼容，因此必须选择启用此行为。 &lt;code&gt;MIX_HOME&lt;/code&gt; 的优先级高于 &lt;code&gt;MIX_XDG&lt;/code&gt; 。如果没有变量的设置，默认目录 &lt;code&gt;~/.mix&lt;/code&gt; 将使用</target>
        </trans-unit>
        <trans-unit id="3d25413013d7642f8cf841919f8270de1f43ed5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Macro.expand_once/2&lt;/code&gt; receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about &lt;code&gt;__ENV__&lt;/code&gt; later in this chapter).</source>
          <target state="translated">&lt;code&gt;Macro.expand_once/2&lt;/code&gt; 接收一个带引号的表达式，并根据当前环境对其进行扩展。在这种情况下，它扩展/调用了 &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; 宏并返回了其结果。然后，我们将返回的带引号的表达式转换为字符串并打印（我们将在本章稍后讨论 &lt;code&gt;__ENV__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f7cf5a4a08fc0443742331ca9c19953329372043" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Makefile.win&lt;/code&gt;- invokes &lt;code&gt;nmake /F Makefile.win&lt;/code&gt; (only on Windows)</source>
          <target state="translated">&lt;code&gt;Makefile.win&lt;/code&gt; -调用 &lt;code&gt;nmake /F Makefile.win&lt;/code&gt; （仅在Windows上）</target>
        </trans-unit>
        <trans-unit id="5089530935a333b39d0f09b9dc40db65ec63d8f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Makefile&lt;/code&gt; - invokes &lt;code&gt;gmake&lt;/code&gt; on DragonFlyBSD, FreeBSD, NetBSD, and OpenBSD, invokes &lt;code&gt;make&lt;/code&gt; on any other operating system (except on Windows)</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; -在DragonFlyBSD，FreeBSD，NetBSD和OpenBSD上调用 &lt;code&gt;gmake&lt;/code&gt; ，在任何其他操作系统（Windows上除外）上调用 &lt;code&gt;make&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00b1d41a5db3e2d02233a9ec6cf644eff865bef1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mix.Task.run(&quot;compile&quot;, args)&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;Mix.Task.run(&quot;compile&quot;, args)&lt;/code&gt; （v1.0）</target>
        </trans-unit>
        <trans-unit id="0f0e096f8f78d8ae18f78e22ad67df03c1d9cd33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_BOOT_SCRIPT&lt;/code&gt; - the name of the boot script to use when starting the release. This script is used when running commands such as &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;daemon&lt;/code&gt;. The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot&lt;/code&gt;. Defaults to &lt;code&gt;start&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_BOOT_SCRIPT&lt;/code&gt; -启动发行版时要使用的启动脚本的名称。运行诸如 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;daemon&lt;/code&gt; 之类的命令时使用此脚本。引导脚本应位于路径 &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot&lt;/code&gt; 中。默认 &lt;code&gt;start&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8d200a48258e76cb9c3dfbc4c5509d26e83cf9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_BOOT_SCRIPT_CLEAN&lt;/code&gt; - the name of the boot script used when starting the release clean, without your application or its dependencies. This script is used by commands such as &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;rpc&lt;/code&gt;, and &lt;code&gt;remote&lt;/code&gt;. The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot&lt;/code&gt;. Defaults to &lt;code&gt;start_clean&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_BOOT_SCRIPT_CLEAN&lt;/code&gt; -干净启动版本时使用的启动脚本的名称，没有您的应用程序或其依赖项。此脚本由 &lt;code&gt;eval&lt;/code&gt; ， &lt;code&gt;rpc&lt;/code&gt; 和 &lt;code&gt;remote&lt;/code&gt; 等命令使用。引导脚本应位于路径 &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot&lt;/code&gt; 中。默认为 &lt;code&gt;start_clean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b347c1865aeb917d5f8064ddb6bb310c8775c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_COMMAND&lt;/code&gt; - the command given to the release, such as &lt;code&gt;&quot;start&quot;&lt;/code&gt;, &lt;code&gt;&quot;remote&quot;&lt;/code&gt;, &lt;code&gt;&quot;eval&quot;&lt;/code&gt;, and so on. This is typically accessed inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to set different environment variables under different conditions. Note, however, that &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; has not been validated by the time &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; are called, so it may be empty or contain invalid values. This variable is always computed and it cannot be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_COMMAND&lt;/code&gt; -授予发行版的命令，例如 &lt;code&gt;&quot;start&quot;&lt;/code&gt; ， &lt;code&gt;&quot;remote&quot;&lt;/code&gt; ， &lt;code&gt;&quot;eval&quot;&lt;/code&gt; 等。通常可以在 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 内部访问此文件，以在不同条件下设置不同的环境变量。但是请注意，在调用 &lt;code&gt;env.sh&lt;/code&gt; 和 &lt;code&gt;env.bat&lt;/code&gt; 时尚未验证 &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; ，因此它可能为空或包含无效值。始终会计算此变量，并且不能将其设置为自定义值</target>
        </trans-unit>
        <trans-unit id="5db5d9d226dd57b61c3de56bafcb76a6e683a137" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_COOKIE&lt;/code&gt; - the release cookie. By default uses the value in &lt;code&gt;releases/COOKIE&lt;/code&gt;. It can be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_COOKIE&lt;/code&gt; -版本cookie。默认情况下，使用 &lt;code&gt;releases/COOKIE&lt;/code&gt; 中的值。可以将其设置为自定义值</target>
        </trans-unit>
        <trans-unit id="11092c988bfb9b026d3556a8be28d644e61b02b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; - how do we want to run the distribution. May be &lt;code&gt;name&lt;/code&gt; (long names), &lt;code&gt;sname&lt;/code&gt; (short names) or &lt;code&gt;none&lt;/code&gt; (distribution is not started automatically). Defaults to &lt;code&gt;sname&lt;/code&gt; which allows access only within the current system. &lt;code&gt;name&lt;/code&gt; allows external connections. If &lt;code&gt;name&lt;/code&gt; is used and you are not running on Erlang/OTP 22 or later, you must set &lt;code&gt;RELEASE_NODE&lt;/code&gt; to &lt;code&gt;RELEASE_NAME@127.0.0.1&lt;/code&gt; with an IP or a known host</source>
          <target state="translated">&lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; -我们如何运行发行版。可以是 &lt;code&gt;name&lt;/code&gt; （长名称）， &lt;code&gt;sname&lt;/code&gt; （短名称）或 &lt;code&gt;none&lt;/code&gt; （发行不会自动开始）。默认为 &lt;code&gt;sname&lt;/code&gt; ，仅允许在当前系统内访问。 &lt;code&gt;name&lt;/code&gt; 允许外部连接。如果 &lt;code&gt;name&lt;/code&gt; 使用，你是不是在运行二郎/ OTP 22或更高版本，您必须设置 &lt;code&gt;RELEASE_NODE&lt;/code&gt; 到 &lt;code&gt;RELEASE_NAME@127.0.0.1&lt;/code&gt; 与IP或著名主持人</target>
        </trans-unit>
        <trans-unit id="1c0fdca101ddcd4c15181c8e5aef8f9de51f1808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_MODE&lt;/code&gt; - if the release should start in embedded or interactive mode. Defaults to &quot;embedded&quot;. It applies only to start/daemon/install commands</source>
          <target state="translated">&lt;code&gt;RELEASE_MODE&lt;/code&gt; -如果发行版应以嵌入式或交互模式启动。默认为&amp;ldquo;嵌入式&amp;rdquo;。它仅适用于启动/守护程序/安装命令</target>
        </trans-unit>
        <trans-unit id="f7ccd36485374c0118fd8558abe9f6a5ba88f205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_NAME&lt;/code&gt; - the name of the release. It can be set to a custom value when invoking the release</source>
          <target state="translated">&lt;code&gt;RELEASE_NAME&lt;/code&gt; -版本名称。可以在调用发行版时将其设置为自定义值</target>
        </trans-unit>
        <trans-unit id="2f70cb906cf189a8668c80a9a5ba13a29c35617f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_NODE&lt;/code&gt; - the release node name, in the format &lt;code&gt;name@host&lt;/code&gt;. It can be set to a custom value. The name part must be made only of letters, digits, underscores, and hyphens</source>
          <target state="translated">&lt;code&gt;RELEASE_NODE&lt;/code&gt; -发行节点名称，格式为 &lt;code&gt;name@host&lt;/code&gt; 。可以将其设置为自定义值。名称部分只能由字母，数字，下划线和连字符组成</target>
        </trans-unit>
        <trans-unit id="f06d11834d6cb4ca20dd2e4206b76cc64d991608" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_ROOT&lt;/code&gt; - points to the root of the release. If the system includes ERTS, then it is the same as &lt;a href=&quot;http://www.erlang.org/doc/man/code.html#root_dir-0&quot;&gt;&lt;code&gt;:code.root_dir/0&lt;/code&gt;&lt;/a&gt;. This variable is always computed and it cannot be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_ROOT&lt;/code&gt; -指向发行版的根目录。如果系统包含ERTS，则它与&lt;a href=&quot;http://www.erlang.org/doc/man/code.html#root_dir-0&quot;&gt; &lt;code&gt;:code.root_dir/0&lt;/code&gt; &lt;/a&gt;相同。始终会计算此变量，并且不能将其设置为自定义值</target>
        </trans-unit>
        <trans-unit id="1388a58ae031e8df945df5b3a7bfe0e70c9fd9a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_SYS_CONFIG&lt;/code&gt; - the location of the sys.config file. It can be set to a custom path and it must not include the &lt;code&gt;.config&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;RELEASE_SYS_CONFIG&lt;/code&gt; -sys.config文件的位置。可以将其设置为自定义路径，并且不得包含 &lt;code&gt;.config&lt;/code&gt; 扩展名</target>
        </trans-unit>
        <trans-unit id="4abf1af7d08e33f076797e5d00e9b7760c2e2b5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_TMP&lt;/code&gt; - the directory in the release to write temporary files to. It can be set to a custom directory. It defaults to &lt;code&gt;$RELEASE_ROOT/tmp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_TMP&lt;/code&gt; -版本中的写入临时文件的目录。可以将其设置为自定义目录。默认为 &lt;code&gt;$RELEASE_ROOT/tmp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57a28a1108df7bec7cd0a4fb296132129fff4ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_VM_ARGS&lt;/code&gt; - the location of the vm.args file. It can be set to a custom path</source>
          <target state="translated">&lt;code&gt;RELEASE_VM_ARGS&lt;/code&gt; -vm.args文件的位置。可以将其设置为自定义路径</target>
        </trans-unit>
        <trans-unit id="a11c1bc1765c0750c7c0007612319bfe2c0845eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_VSN&lt;/code&gt; - the version of the release, otherwise the latest version is used. It can be set to a custom value when invoking the release. The custom value must be an existing release version in the &lt;code&gt;releases/&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;RELEASE_VSN&lt;/code&gt; -版本号，否则使用最新版本。可以在调用发行版时将其设置为自定义值。自定义值必须是 &lt;code&gt;releases/&lt;/code&gt; 目录中的现有发行版</target>
        </trans-unit>
        <trans-unit id="3fc6929a951f92925b08e51e26456aa3d1b43853" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="025d0341292dc3a3ec173d8548f02f17ffdfc36c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.length/1&lt;/code&gt; counts graphemes, but &lt;code&gt;byte_size/1&lt;/code&gt; reveals the number of underlying raw bytes needed to store the string when using UTF-8 encoding. UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, and &lt;code&gt;o&lt;/code&gt;, but two bytes to represent &lt;code&gt;ł&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String.length/1&lt;/code&gt; 计数字素，但是 &lt;code&gt;byte_size/1&lt;/code&gt; 揭示了使用UTF-8编码时存储字符串所需的基础原始字节数。UTF-8需要一个字节来表示字符 &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;o&lt;/code&gt; ，但是需要两个字节来表示 &lt;code&gt;ł&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c79ae2e0183612283b4bdd763f31738afe6b32e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.ljust/3&lt;/code&gt; and &lt;code&gt;String.rjust/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.ljust/3&lt;/code&gt; 和 &lt;code&gt;String.rjust/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6971e188b1f5ca6887f36a1aabb3d9f4803817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/1&lt;/code&gt; and &lt;code&gt;String.rstrip/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/1&lt;/code&gt; 和 &lt;code&gt;String.rstrip/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4f8fac69d745e565219ca9c212f205a839b4d94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/2&lt;/code&gt; and &lt;code&gt;String.rstrip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/2&lt;/code&gt; 和 &lt;code&gt;String.rstrip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dba6d3f4606546ef740ff6427a2da28113bd080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.strip/1&lt;/code&gt; and &lt;code&gt;String.strip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.strip/1&lt;/code&gt; 和 &lt;code&gt;String.strip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd32067781123d89c1ac8e4f997b876beb9c3863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; is capable of building a child specification from a given module and/or tuple, and it also accepts values that override the underlying child specification. Now we have an always running acceptor that starts temporary task processes under an always running task supervisor.</source>
          <target state="translated">&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 能够从给定的模块和/或元组构建子规范，并且它还接受覆盖基础子规范的值。现在，我们有了一个始终运行的接受器，可以在始终运行的任务管理程序下启动临时任务进程。</target>
        </trans-unit>
        <trans-unit id="ad77d229f6cbfcafcb4f7741c0dc27b0f4b740b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="088aa7cd9bf1e6a8427fd52deb0693f6c10b18ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[char1,char2,...]&lt;/code&gt; - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;[char1,char2,...]&lt;/code&gt; -匹配列出的任何字符；用连字符分隔的两个字符将匹配一系列字符。请勿在逗号前后添加空格，否则会匹配包含空格字符本身的路径。</target>
        </trans-unit>
        <trans-unit id="716d641385133215b3dad8b4209c815a375959a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[xref: [exclude: ...]]&lt;/code&gt; - a list of &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;{module, function, arity}&lt;/code&gt; that should not be warned on in case on undefined modules or undefined application warnings.</source>
          <target state="translated">&lt;code&gt;[xref: [exclude: ...]]&lt;/code&gt; - &lt;code&gt;module&lt;/code&gt; 或 &lt;code&gt;{module, function, arity}&lt;/code&gt; 的列表，在未定义模块或未定义应用程序警告的情况下，不应发出警告。</target>
        </trans-unit>
        <trans-unit id="7678d3e63037186910d7f0ae81525b64485520eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\#&lt;/code&gt; - Returns the &lt;code&gt;#&lt;/code&gt; character itself, skipping interpolation</source>
          <target state="translated">&lt;code&gt;\#&lt;/code&gt; -返回 &lt;code&gt;#&lt;/code&gt; 字符本身，跳过插值</target>
        </trans-unit>
        <trans-unit id="39c640871ce2526ab4fa5310ef6480273c950ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\0&lt;/code&gt; - null byte</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 空字节</target>
        </trans-unit>
        <trans-unit id="65ed13dac56222bcbf8e3e216b956a7a2244b177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; &amp;ndash; single backslash</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; &amp;ndash;单反斜杠</target>
        </trans-unit>
        <trans-unit id="47357c3d9a815c299db4cc36a5a19e15cd4a88d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; - see &lt;a href=&quot;kernel#def/2-default-arguments&quot;&gt;Default arguments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; -请参阅&lt;a href=&quot;kernel#def/2-default-arguments&quot;&gt;默认参数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b174b497cb3a1cc6880a9950599e3a0b77cab5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; is used to specify a default value for a parameter of a function. For example:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 用于指定函数参数的默认值。例如：</target>
        </trans-unit>
        <trans-unit id="6f9d9ffe5a9bac743656529800fff03c95336241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; &amp;ndash; bell/alert</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; &amp;ndash;贝尔/警报</target>
        </trans-unit>
        <trans-unit id="45753357243d44add04b0d403bcb727bf01ac640" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; - Bell</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; a-贝尔</target>
        </trans-unit>
        <trans-unit id="14886ebc85cca038dec60a61c0e91b8b4ead61c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; &amp;ndash; backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; &amp;ndash;退格键</target>
        </trans-unit>
        <trans-unit id="e2b21a168427d47ef491a0b46394abff13b4ace1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; - Backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 退格键</target>
        </trans-unit>
        <trans-unit id="0bb4d977ed1327929c1a92021eb0613308fd0ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; - delete</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 删除</target>
        </trans-unit>
        <trans-unit id="f1fa4a2a5b80412cbf38d35040e73ca767510a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - Command Escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 命令转义</target>
        </trans-unit>
        <trans-unit id="ccb79b2d6e647a0cac1fd9c56eabf463190b35ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 逃生</target>
        </trans-unit>
        <trans-unit id="55299eb9827bdc0cdce7357d89c2a61fb6cf5a99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - Form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; 换页</target>
        </trans-unit>
        <trans-unit id="7df87f44b5903cdd4ae86383ef920d5afcb83fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; 换页</target>
        </trans-unit>
        <trans-unit id="74c29c02b88f493e0b8a40781b5dd5c63d7f01bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; &amp;ndash; newline</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; &amp;ndash;换行符</target>
        </trans-unit>
        <trans-unit id="035d222408ecfdbe03e1c6f467bf7b85f3d09276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; - Line feed (New lines)</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 换行（新行）</target>
        </trans-unit>
        <trans-unit id="f63d66cab57190093b88defb77e6fab011870475" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; &amp;ndash; carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; &amp;ndash;回车</target>
        </trans-unit>
        <trans-unit id="16a3f8f6e455b31b406751d768b8997d3b0141f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; - Carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; 回车</target>
        </trans-unit>
        <trans-unit id="0a1c5bdfb07d4e036fe4810e5550d502e2f30408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; &amp;ndash; space</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; &amp;ndash;空间</target>
        </trans-unit>
        <trans-unit id="547d5d52bd4fa577be6f348f6604137b954496a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; &amp;ndash; tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; &amp;ndash;标签</target>
        </trans-unit>
        <trans-unit id="ac9f3e83b566f79b509b507babdbaf1e3039b623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; - Horizontal tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; 水平标签</target>
        </trans-unit>
        <trans-unit id="736c96e8078aabb67ae94f12f2958e5765eb382c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uDDDD&lt;/code&gt; and &lt;code&gt;\u{D...}&lt;/code&gt; - represents a Unicode codepoint in hexadecimal (such as &lt;code&gt;\u{1F600}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\uDDDD&lt;/code&gt; 和 &lt;code&gt;\u{D...}&lt;/code&gt; -以十六进制表示Unicode代码点（例如 &lt;code&gt;\u{1F600}&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f59792bb819b89eb12383151ec5c270c793db45e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uNNNN&lt;/code&gt; - A Unicode code point represented by &lt;code&gt;NNNN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\uNNNN&lt;/code&gt; 由 &lt;code&gt;NNNN&lt;/code&gt; 表示的Unicode代码点</target>
        </trans-unit>
        <trans-unit id="46eb12f311d0fe7aa10c40fac2213a97f6692013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uXXXX&lt;/code&gt; or &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</source>
          <target state="translated">&lt;code&gt;\uXXXX&lt;/code&gt; 或 &lt;code&gt;\u{X*}&lt;/code&gt; （v1.1）</target>
        </trans-unit>
        <trans-unit id="c0b1167bef21cda9a624d04841f631aeb54af646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; &amp;ndash; vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; &amp;ndash;垂直标签</target>
        </trans-unit>
        <trans-unit id="baae21e52c1a4d911ab0b0815dbbb669da87f8c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; - Vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; 垂直标签</target>
        </trans-unit>
        <trans-unit id="38a8f23f2eb09ba8af053d2c20b167de36d6466a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xDD&lt;/code&gt; - represents a single byte in hexadecimal (such as &lt;code&gt;\x13&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\xDD&lt;/code&gt; 代表十六进制的单个字节（例如 &lt;code&gt;\x13&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0119ce503ea17ff365f93ebcad5ab105e0246f64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xNN&lt;/code&gt; - A byte represented by the hexadecimal &lt;code&gt;NN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\xNN&lt;/code&gt; 以十六进制 &lt;code&gt;NN&lt;/code&gt; 表示的字节</target>
        </trans-unit>
        <trans-unit id="3210dc14496231e2d2fc4514864f15323c30fdbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{X*}&lt;/code&gt; inside strings/sigils/charlists</source>
          <target state="translated">&lt;code&gt;\x{X*}&lt;/code&gt; 在字符串/签名/字符列表中</target>
        </trans-unit>
        <trans-unit id="12de2ac6c25aa71b2904637230b82ed326e8ae16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_&lt;/code&gt;: pad with spaces</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; ：空格处</target>
        </trans-unit>
        <trans-unit id="3cde9d9e85c4c0b53108719f116e97eb679ac877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ENV__&lt;/code&gt; returns an instance of the &lt;code&gt;Macro.Env&lt;/code&gt; struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires and so on:</source>
          <target state="translated">&lt;code&gt;__ENV__&lt;/code&gt; 返回 &lt;code&gt;Macro.Env&lt;/code&gt; 结构的实例，该实例包含有关编译环境的有用信息，包括当前模块，文件和行，当前作用域中定义的所有变量以及导入，需求等：</target>
        </trans-unit>
        <trans-unit id="bd76053a130e15c6a7e3c3653c524a8cead2f8f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__STACKTRACE__&lt;/code&gt; in &lt;code&gt;try/catch/rescue&lt;/code&gt; (v1.7)</source>
          <target state="translated">&lt;code&gt;__STACKTRACE__&lt;/code&gt; 中 &lt;code&gt;try/catch/rescue&lt;/code&gt; （V1.7）</target>
        </trans-unit>
        <trans-unit id="e61733caa542452527b202971f1b67c6052df9a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__protocol__/1&lt;/code&gt; - returns the protocol information. The function takes one of the following atoms:</source>
          <target state="translated">&lt;code&gt;__protocol__/1&lt;/code&gt; 返回协议信息。该函数采用以下原子之一：</target>
        </trans-unit>
        <trans-unit id="f30c6faee12c1a5a12b4701c1489caf0490de93e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 通常用于需要在调用者中设置一些状态（通过模块属性）或回调（例如 &lt;code&gt;@before_compile&lt;/code&gt; ，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;的文档以获取更多信息）的情况。</target>
        </trans-unit>
        <trans-unit id="ead78218949f957d38127d6c0b9181cecc79bdc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 通常用于需要在调用者中设置一些状态（通过模块属性）或回调（例如 &lt;code&gt;@before_compile&lt;/code&gt; ，请参见&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;的文档以获取更多信息）的情况。</target>
        </trans-unit>
        <trans-unit id="18fec841d33b1eed5707722ba145fa8e46469457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; may also be used to alias, require, or import functionality from different modules:</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 还可用于别名，要求或从不同模块导入功能：</target>
        </trans-unit>
        <trans-unit id="5888cfe9b0257d8c48e3413d54a04e07ef4f2f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;: words in the list are atoms</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; ：列表中的单词是原子</target>
        </trans-unit>
        <trans-unit id="5dd0df57ca13d192483ae4afa8ee7dcd66ac716e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt;; the current system access to the file.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt; ; 当前系统对该文件的访问。</target>
        </trans-unit>
        <trans-unit id="5bf576af207250aae2f10f4b1a3367c771a70828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="561d785f096648699e854e9a94018cf81a312387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; 迭代完成后将调用after_fun，并且还必须返回 &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; 或 &lt;code&gt;{:cont, acc}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e3d214af6b3554314446ba0e18e374c3577cbda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; 迭代完成后将调用after_fun，并且还必须返回 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 或 &lt;code&gt;{:cont, acc}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72b02de91b9af39aa2a7c9496b9788f7c36c0544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias&lt;/code&gt; allows you to set up aliases for any given module name.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 允许您为任何给定的模块名称设置别名。</target>
        </trans-unit>
        <trans-unit id="c880b6a07ca827b5812f7f974a1fcacab19aaf4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aliases&lt;/code&gt; - a list of two-element tuples, where the first element is the aliased name and the second one the actual name</source>
          <target state="translated">&lt;code&gt;aliases&lt;/code&gt; -两元素元组的列表，其中第一个元素是别名，第二个元素是实际名称</target>
        </trans-unit>
        <trans-unit id="8d4e8eef689e82c072f90c3d43dbd352d218bf09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anchored&lt;/code&gt; - not available, use &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;\A&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;anchored&lt;/code&gt; -不提供，使用 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;\A&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="69d2286a504a92480fa7093d21b1d829c664c953" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 在规范的 &lt;code&gt;:start&lt;/code&gt; 字段中作为&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;的参数传递。</target>
        </trans-unit>
        <trans-unit id="4458fc9a4b25b25b5a15d3aebebe9b878cfddf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 在规范的 &lt;code&gt;:start&lt;/code&gt; 字段中作为&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;的参数传递。</target>
        </trans-unit>
        <trans-unit id="d15eca1e275872ac68dbab33a4fcdc7d4900f368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 必须是布尔值；如果不是，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="c766db9327568eebb91c2c7ede208193b9693614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; is a list of the remaining arguments in &lt;code&gt;argv&lt;/code&gt; as strings</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 是 &lt;code&gt;argv&lt;/code&gt; 中作为字符串的其余参数的列表</target>
        </trans-unit>
        <trans-unit id="67b55e613b38ca10448abedd47d027b2fda5747b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must be a list of binaries which the executable will receive as its arguments as is. This means that:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 必须是可执行文件将按其原样接收的二进制文件列表。这意味着：</target>
        </trans-unit>
        <trans-unit id="783fe4760ba15ae07c09e338cd73681f91718b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; 在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; 中为&lt;/a&gt;false，并且&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6116c0e3ccd4227ebffa3336ec78198214587e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; 在&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; 中为&lt;/a&gt; false，并且&lt;a href=&quot;kernel.specialforms#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="822629b7db721ef2933cb934e45149d4a945780c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;enum#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; 存在as_boolean（t）来向用户发送信号，将给定值视为布尔值，其中 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 将被评估为 &lt;code&gt;false&lt;/code&gt; ,而其他所有条件均为 &lt;code&gt;true&lt;/code&gt; 。例如，&lt;a href=&quot;enum#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt;具有以下规范： &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ca5e1feb985abd11ae694ad71b883d67b520062" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; 存在as_boolean（t）来通知用户给定值将被视为布尔值，其中 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 将被评估为 &lt;code&gt;false&lt;/code&gt; ,而其他所有条件均为 &lt;code&gt;true&lt;/code&gt; 。例如，&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt;具有以下规范： &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9d720388f308d192f8429307f6fcab52f0e1f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 会反省基础表达式，并在出现故障时提供良好的报告。例如，如果表达式使用比较运算符，则该消息将显示两侧的值。断言</target>
        </trans-unit>
        <trans-unit id="b8c959da5563d8804e6c5ab088f8ce78ed2be376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; provides a very simple mechanism to compute values concurrently. Not only that, &lt;code&gt;async/await&lt;/code&gt; can also be used with the same &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; we have used in previous chapters. We just need to call &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; instead of &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; and use &lt;code&gt;Task.await/2&lt;/code&gt; to read the result later on.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 提供了一种非常简单的机制来同时计算值。不仅如此， &lt;code&gt;async/await&lt;/code&gt; 还可以与前面章节中使用的&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;一起使用。我们只需要调用 &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 而不是 &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; ,然后使用 &lt;code&gt;Task.await/2&lt;/code&gt; 来读取结果。</target>
        </trans-unit>
        <trans-unit id="5cbc2fd902dcfa9a0d5b3b03629aa9a39e8105cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atime&lt;/code&gt; - the last time the file was read.</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; -上次读取文件的时间。</target>
        </trans-unit>
        <trans-unit id="a1bc563adc7ed0327db5ff505175d84400d984ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_nodes&lt;/code&gt; - is a list of nodes that either did not exist or where a server with the given &lt;code&gt;name&lt;/code&gt; did not exist or did not reply</source>
          <target state="translated">&lt;code&gt;bad_nodes&lt;/code&gt; -是不存在的节点或具有给定 &lt;code&gt;name&lt;/code&gt; 的服务器不存在或未答复的节点的列表</target>
        </trans-unit>
        <trans-unit id="b0f9d352deff5e6bef483d40252e8c579ec823db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; can be an integer between 2 and 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 可以是2到36之间的整数。</target>
        </trans-unit>
        <trans-unit id="f8fd140ab9c10a0cfc1c2df9c9a53282f52de13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;big&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; （默认）</target>
        </trans-unit>
        <trans-unit id="24aeeb91a66e25c695a35aa48b22c0e94d817f06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; commands</source>
          <target state="translated">&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; 命令</target>
        </trans-unit>
        <trans-unit id="683140005c82637887b9603468709538ca7e8c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo daemon&lt;/code&gt; and &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; - to start the system as a daemon on Unix-like systems</source>
          <target state="translated">&lt;code&gt;bin/foo daemon&lt;/code&gt; 和bin / foo守护程序 &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; 在类Unix系统上作为守护程序启动系统</target>
        </trans-unit>
        <trans-unit id="decd6a4e6f8eff7dd632caccc3c36fce1d0d44bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - to start a fresh system that runs a single command and then shuts down</source>
          <target state="translated">&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; -启动一个运行单个命令然后关闭的新系统</target>
        </trans-unit>
        <trans-unit id="432eeca34ed295a1f1ff0e49167671eefec3e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo install&lt;/code&gt; - to install the system as a service on Windows machines</source>
          <target state="translated">&lt;code&gt;bin/foo install&lt;/code&gt; -在Windows机器上将系统作为服务安装</target>
        </trans-unit>
        <trans-unit id="8eb1dbc6df6a7ebd68488f9c558335906ced9632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; and &lt;code&gt;bin/foo remote&lt;/code&gt; - for running commands on the running system or to connect to the running system</source>
          <target state="translated">&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; 和 &lt;code&gt;bin/foo remote&lt;/code&gt; -用于在正在运行的系统上运行命令或连接到正在运行的系统</target>
        </trans-unit>
        <trans-unit id="61afcc7c9d27662591ec64aeb53fbe50494c9c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo start&lt;/code&gt;, &lt;code&gt;bin/foo start_iex&lt;/code&gt;, &lt;code&gt;bin/foo restart&lt;/code&gt;, and &lt;code&gt;bin/foo stop&lt;/code&gt; - for general management of the release</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; ， &lt;code&gt;bin/foo start_iex&lt;/code&gt; ， &lt;code&gt;bin/foo restart&lt;/code&gt; 和 &lt;code&gt;bin/foo stop&lt;/code&gt; -用于释放的一般管理</target>
        </trans-unit>
        <trans-unit id="0ca6cada709e43a4d29a38bd7db90e5e5fdce17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/my_app start&lt;/code&gt; will start the system connected to the current standard input/output, where logs are also written to by default. This is the preferred way to run the system. Many tools, such as &lt;code&gt;systemd&lt;/code&gt;, platforms as a service, such as Heroku, and many containers platforms, such as Docker, are capable of processing the standard input/output and redirecting the log contents elsewhere. Those tools and platforms also take care of restarting the system in case it crashes.</source>
          <target state="translated">&lt;code&gt;bin/my_app start&lt;/code&gt; 将启动连接到当前标准输入/输出的系统，默认情况下还将在其中写入日志。这是运行系统的首选方式。许多工具（例如 &lt;code&gt;systemd&lt;/code&gt; ，作为服务的平台（例如Heroku）和许多容器平台（例如Docker））能够处理标准输入/输出，并将日志内容重定向到其他地方。这些工具和平台还负责在系统崩溃时重新启动系统。</target>
        </trans-unit>
        <trans-unit id="1d72332764c11e123f7347708663156c1233e11a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a keyword list with the value of all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 是一个关键字列表，其中包含在评估 &lt;code&gt;string&lt;/code&gt; 之后所有变量绑定的值。绑定键通常是一个原子，但对于在不同上下文中定义的变量，它可能是一个元组。</target>
        </trans-unit>
        <trans-unit id="7e7fbcaa11b87d5daded74fc37531decf595f1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a list with all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 是在评估 &lt;code&gt;string&lt;/code&gt; 之后具有所有变量绑定的列表。绑定键通常是原子，但它们可能是在不同上下文中定义的变量的元组。</target>
        </trans-unit>
        <trans-unit id="1c823d3a888334fa369393bafb696100163d27f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bits&lt;/code&gt; (alias for &lt;code&gt;bitstring&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bits&lt;/code&gt; （ &lt;code&gt;bitstring&lt;/code&gt; 的别名）</target>
        </trans-unit>
        <trans-unit id="15d4a43121fe32de8967a969e91d058bcf17a84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes&lt;/code&gt; (alias for &lt;code&gt;binary&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; （ &lt;code&gt;binary&lt;/code&gt; 别名）</target>
        </trans-unit>
        <trans-unit id="834919dffb47cc92a7a48cd0b0701a70f30f53b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: words in the list are charlists</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; ：列表中的单词是字符列表</target>
        </trans-unit>
        <trans-unit id="b2ccd200c0a8ea5eab26b2092f3c2628e13ebdda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; 或 &lt;code&gt;info&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="f8c3b2d3da64ab6cc3b0a518b860cadf593c568e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; is a function that receives no arguments and runs in a separate process than the caller.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 函数是不接收任何参数的函数，它在与调用者不同的进程中运行。</target>
        </trans-unit>
        <trans-unit id="95b68f4cda4012cbd6bf09e1c90d22f081c35df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; allows us to compare a value against many patterns until we find a matching one:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 允许我们将值与许多模式进行比较，直到找到匹配的模式：</target>
        </trans-unit>
        <trans-unit id="e2e836bef50ccfd75e73db047504ecafbbd45966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; is useful when you need to match against different values. However, in many circumstances, we want to check different conditions and find the first one that does not evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. In such cases, one may use &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 当您需要匹配不同的值时，case很有用。但是，在许多情况下，我们要检查不同的条件，并找到第一个不 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的条件。在这种情况下，可以使用 &lt;code&gt;cond&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93db9ef7d76055eccf64ca125a1bd08e2afa0ce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caseless&lt;/code&gt; (i) - adds case insensitivity</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; （ⅰ） -将不区分大小写</target>
        </trans-unit>
        <trans-unit id="111682203e5e59ead60bf73cdbc6a0fd477ad42b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 可以用来捕获&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; &lt;/a&gt;抛出的值：</target>
        </trans-unit>
        <trans-unit id="81988c264165854eebe013b354206a9d80761cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;kernel#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 可以用来捕获&lt;a href=&quot;kernel#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; &lt;/a&gt;抛出的值：</target>
        </trans-unit>
        <trans-unit id="cb7c5d439fab5f4770d5cbbe8aa9adfa7fda6776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="db91933fecb8b9776531516395537a60984fe8c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changed&lt;/code&gt; is a keyword list of keys and their changed values in the application environment. &lt;code&gt;new&lt;/code&gt; is a keyword list with all new keys and their values. &lt;code&gt;removed&lt;/code&gt; is a list with all removed keys.</source>
          <target state="translated">&lt;code&gt;changed&lt;/code&gt; 是应用程序环境中键及其更改值的关键字列表。 &lt;code&gt;new&lt;/code&gt; 是包含所有新键及其值的关键字列表。 &lt;code&gt;removed&lt;/code&gt; 是具有所有被删除键的列表。</target>
        </trans-unit>
        <trans-unit id="60538f44591b66b504b274f4df6fe77688be99e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_list/0&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;char_list/0&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="343cfd2a019aa43de8f9ab53908dba3ccb94d728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process or the atom &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; -相应的子过程或原子的PID &lt;code&gt;:restarting&lt;/code&gt; 过程是否要被重新启动</target>
        </trans-unit>
        <trans-unit id="8b19e01788ee36713a234b5a35b8998444e68a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process, &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted, or &lt;code&gt;:undefined&lt;/code&gt; if there is no such process</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; -相应的子进程的PID， &lt;code&gt;:restarting&lt;/code&gt; 过程是否要重新启动，或者 &lt;code&gt;:undefined&lt;/code&gt; 如果没有这样的过程</target>
        </trans-unit>
        <trans-unit id="6476916acd48544b426c8480acd642ec86103d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;Child specification&quot; section of the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 应该是有效的子规范，如&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档的&amp;ldquo;子规范&amp;rdquo;部分所述。子进程将按照子规范中的定义启动。</target>
        </trans-unit>
        <trans-unit id="4b785aaae874a7f7ac89b390425e4e181327565b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;child_spec/1&quot; section of the documentation for &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 应该是有效的子规范，如&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档的&amp;ldquo; child_spec / 1&amp;rdquo;部分中所述。子进程将按照子规范中的定义启动。</target>
        </trans-unit>
        <trans-unit id="d9984de2b8855daeaef81ef2dcc1396c0705a01d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 应该是有效的子规范。子进程将按照子规范中的定义启动。</target>
        </trans-unit>
        <trans-unit id="631a468d011ccda2d4a412a6dc19a7a03449ce32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; 接收当前元素和累加器，并且必须返回 &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; 来发出给定的块并继续累加器，或者返回 &lt;code&gt;{:cont, acc}&lt;/code&gt; 以不发出任何块并继续返回累加器。</target>
        </trans-unit>
        <trans-unit id="9f93140b69bea94d444900d436d05d80b21439d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; 接收当前元素和累加器，并且必须返回 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 来发出给定的块并继续累加器，或者 &lt;code&gt;{:cont, acc}&lt;/code&gt; 不发出任何块并继续返回累加器。</target>
        </trans-unit>
        <trans-unit id="1a4d8126ef5b5ce5f93f354fe8074bc265f819b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client&lt;/code&gt; must be the &lt;code&gt;from&lt;/code&gt; argument (the second argument) accepted by &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callbacks. &lt;code&gt;reply&lt;/code&gt; is an arbitrary term which will be given back to the client as the return value of the call.</source>
          <target state="translated">&lt;code&gt;client&lt;/code&gt; 必须是&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;回调接受的 &lt;code&gt;from&lt;/code&gt; 参数（第二个参数）。 &lt;code&gt;reply&lt;/code&gt; 是一个任意术语，它将作为调用的返回值返回给客户端。</target>
        </trans-unit>
        <trans-unit id="74ea1ebde7d25d8d5b3afc102cd5079c21ac3674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; is expected to be an executable available in PATH unless an absolute path is given.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 除非给出绝对路径，否则该命令应该是PATH中可用的可执行文件。</target>
        </trans-unit>
        <trans-unit id="5be94dc7b7015ea04aea4b9a09952702a0f94d63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which are executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; （和 &lt;code&gt;config/prod.exs&lt;/code&gt; ）-提供构建时应用程序配置，该配置在发行版组装后执行</target>
        </trans-unit>
        <trans-unit id="dcd9856e60a10b0680192123ebbb0d9096956b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which is executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; （和 &lt;code&gt;config/prod.exs&lt;/code&gt; ）-提供构建时应用程序配置，该配置在发行版组装后执行</target>
        </trans-unit>
        <trans-unit id="d4b61ac40c23e500c794d4e5338038bb7d000bbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; - provides build-time application configuration, which is executed when the release is assembled. This file often imports configuration files based on the environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/prod.exs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; -提供构建时应用程序配置，该配置在发布发行版时执行。该文件通常根据环境导入配置文件，例如 &lt;code&gt;config/dev.exs&lt;/code&gt; 和 &lt;code&gt;config/prod.exs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="238fad20b64f6752094e989e81c47221593a4dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time the release boots and is further extensible via config providers</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; -提供运行时应用程序配置。它在每次发行版引导时执行，并可通过配置提供程序进一步扩展</target>
        </trans-unit>
        <trans-unit id="a8ff7a040c02a1351d6dbd358d27db3517eb600c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to a regular &lt;code&gt;config/config.exs&lt;/code&gt; but it may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; 文件的工作与常规 &lt;code&gt;config/config.exs&lt;/code&gt; 非常相似，但是可能会有一些限制。您可以&lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;阅读文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="d115832a93226d7668d444d20891799549c49ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to regular &lt;code&gt;config/config.exs&lt;/code&gt; files, but they may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; 文件的工作与常规 &lt;code&gt;config/config.exs&lt;/code&gt; 文件非常相似，但是可能会有一些限制。您可以&lt;a href=&quot;https://hexdocs.pm/mix/1.9.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;阅读文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="c9a7117d3f47e4aa0c4a534c57f688556ec90f1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/runtime.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time your Mix project or your release boots and is further extensible via config providers. If you want to detect you are inside a release, you can check for release specific environment variables, such as &lt;code&gt;RELEASE_NODE&lt;/code&gt; or &lt;code&gt;RELEASE_MODE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;config/runtime.exs&lt;/code&gt; -提供运行时应用程序配置。每当您的Mix项目或发行版启动时，它就会执行，并且可以通过配置提供程序进一步扩展。如果要检测您是否在发行版中，则可以检查发行版特定的环境变量，例如 &lt;code&gt;RELEASE_NODE&lt;/code&gt; 或 &lt;code&gt;RELEASE_MODE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11f7fbb073392ce31a1574f9793451f7610f3ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt; should be a list of &lt;code&gt;{app, app_config}&lt;/code&gt; tuples or a &lt;code&gt;%{app =&amp;gt; app_config}&lt;/code&gt; map where &lt;code&gt;app&lt;/code&gt; are the applications to be configured and &lt;code&gt;app_config&lt;/code&gt; are the configuration (as key-value pairs) for each of those applications.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 应该是 &lt;code&gt;{app, app_config}&lt;/code&gt; 元组的列表或 &lt;code&gt;%{app =&amp;gt; app_config}&lt;/code&gt; 映射，其中 &lt;code&gt;app&lt;/code&gt; 是要配置的应用程序，而 &lt;code&gt;app_config&lt;/code&gt; 是每个这些应用程序的配置（作为键值对）。</target>
        </trans-unit>
        <trans-unit id="8f3eb732cc99e5e8d0e7d53c8f3927e2f14fdbcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; must be &lt;code&gt;iodata&lt;/code&gt; (a list of bytes or a binary). Setting the encoding for this function has no effect.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 必须是 &lt;code&gt;iodata&lt;/code&gt; （字节列表或二进制文件）。设置此功能的编码无效。</target>
        </trans-unit>
        <trans-unit id="3deab4bf4d8695b2db46398f128ebe3680400d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contents&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 可以是字符串，字符串列表或编译模式。</target>
        </trans-unit>
        <trans-unit id="4068af36af3815a173cb8e9bbb5840dd4f7966e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context&lt;/code&gt; - the context of the environment; it can be &lt;code&gt;nil&lt;/code&gt; (default context), &lt;code&gt;:guard&lt;/code&gt; (inside a guard) or &lt;code&gt;:match&lt;/code&gt; (inside a match)</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; -环境的上下文；它可以是 &lt;code&gt;nil&lt;/code&gt; （默认上下文） &lt;code&gt;:guard&lt;/code&gt; （在守卫内部）或 &lt;code&gt;:match&lt;/code&gt; （在比赛内）</target>
        </trans-unit>
        <trans-unit id="e65d01ac3d70dd939e249ff006400606c24ca6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context_modules&lt;/code&gt; - a list of modules defined in the current context</source>
          <target state="translated">&lt;code&gt;context_modules&lt;/code&gt; -当前上下文中定义的模块列表</target>
        </trans-unit>
        <trans-unit id="5d9edb2d993802ba4716d7849368f4f8e74a86f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cprof&lt;/code&gt; can be useful when you want to discover the bottlenecks related to function calls.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 当您想发现与函数调用相关的瓶颈时，cprof可能会很有用。</target>
        </trans-unit>
        <trans-unit id="38a38cdb98964403a68aee6e3174c867d51569e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; -此时间字段的解释取决于操作系统。在Unix上，这是最后一次更改文件或inode的时间。在Windows中，这是创建时间。</target>
        </trans-unit>
        <trans-unit id="e58b9649a044a1cbcb6e4a1e77207d650bc8622b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix-like operating systems, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; -此时间字段的解释取决于操作系统。在类似Unix的操作系统上，这是最后一次更改文件或inode的时间。在Windows中，这是创建的时间。</target>
        </trans-unit>
        <trans-unit id="cf11efa8a9ba50fdad146c0ab1f8c6bab17d9d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cycles&lt;/code&gt; - prints all cycles in the graph;</source>
          <target state="translated">&lt;code&gt;cycles&lt;/code&gt; -打印图中的所有周期；</target>
        </trans-unit>
        <trans-unit id="f1205b070fab0c83d6c993c3f3960abb127d2ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the characters in the line terminated by a line-feed (LF) or end of file (EOF)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -行中以换行（LF）或文件结尾（EOF）结尾的字符</target>
        </trans-unit>
        <trans-unit id="65ebe7dc5a6cbe47bb0f679ee7ef6cf59418d356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the input characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输入字符</target>
        </trans-unit>
        <trans-unit id="3d4410c596b384477fdcae0b3c0d2b1de73cede5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output bytes</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输出字节</target>
        </trans-unit>
        <trans-unit id="d66ff6e276982cb027d53bd1f1e405fd861fcfe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输出字符</target>
        </trans-unit>
        <trans-unit id="f1e314b3d0f6ce196df7c11d73e42319ca204a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 是一个嵌套结构（即实现&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="7c1c6811edebd033596c7ac3e0aad23e4479ee80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 是一个嵌套结构（即实现&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="29e5249cd2895fafdb31d5931c2c7169b30ae35c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour). The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and the result replaces the value in the structure.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 是一个嵌套结构（即实现&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。的 &lt;code&gt;fun&lt;/code&gt; 参数接收的值 &lt;code&gt;key&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; 如果 &lt;code&gt;key&lt;/code&gt; 是不存在）且结果替换的结构中的值。</target>
        </trans-unit>
        <trans-unit id="7a5af7db322cfde7e4e292358150d98466d7d4fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dep1 dep2&lt;/code&gt; - the name of dependencies to be unlocked</source>
          <target state="translated">&lt;code&gt;dep1 dep2&lt;/code&gt; -要解锁的依赖项的名称</target>
        </trans-unit>
        <trans-unit id="d5594dd739a777b9fbe6eced0fe4ddf09a7ab2b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dep1 dep2&lt;/code&gt; - the names of dependencies to be deleted separated by a space</source>
          <target state="translated">&lt;code&gt;dep1 dep2&lt;/code&gt; -要删除的依赖项的名称，以空格分隔</target>
        </trans-unit>
        <trans-unit id="e5cb8b51e466bd529414676deb5702007605833f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt; may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 可以是远程或本地PID，本地端口，本地注册名称，也可以是 &lt;code&gt;{registered_name, node}&lt;/code&gt; 形式的元组，表示另一个节点上的注册名称。</target>
        </trans-unit>
        <trans-unit id="06cb04154e21b24c69f9c8bad5656b7a39545bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device&lt;/code&gt; - the IO device</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; -IO设备</target>
        </trans-unit>
        <trans-unit id="48cd3cb1cdaa44a2d6bca7edd5d1a1fc56abbc4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 块</target>
        </trans-unit>
        <trans-unit id="325351821945a7973f1da881d3d9c9177ab84e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks are a syntactic convenience built on top of the keywords one. That&amp;rsquo;s why &lt;code&gt;do/end&lt;/code&gt; blocks do not require a comma between the previous argument and the block. They are useful exactly because they remove the verbosity when writing blocks of code. These are equivalent:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 块是建立在关键字one之上的语法便利。这就是为什么 &lt;code&gt;do/end&lt;/code&gt; 块在前一个参数和该块之间不需要逗号的原因。它们之所以有用，正是因为它们在编写代码块时消除了冗长的内容。这些是等效的：</target>
        </trans-unit>
        <trans-unit id="ade8e208e831b5d198ac3add386fe1dab9834807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; - used in do/end blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;rescue&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; -在做/结束块</target>
        </trans-unit>
        <trans-unit id="3985298d4759592d757f0cb9a9e4f9b15e52aa5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块</target>
        </trans-unit>
        <trans-unit id="43edbc936cf9ae8a8d1677e787957e43950a7cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dollar_endonly&lt;/code&gt; - not available, use &lt;code&gt;\z&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;dollar_endonly&lt;/code&gt; -不提供，使用 &lt;code&gt;\z&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="81166ee1fc1c5f6aa3345e5c1516903114a049ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description in &lt;code&gt;xref_graph.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -产生以点图形描述 &lt;code&gt;xref_graph.dot&lt;/code&gt; 在当前目录。警告：这将覆盖任何先前生成的文件</target>
        </trans-unit>
        <trans-unit id="2d738dd7421b12b1a016e326ba2d61a77f72e728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the application tree in &lt;code&gt;app_tree.dot&lt;/code&gt; in the current directory. Warning: this will overwrite any previously generated file.</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -产生应用树的以点图形描述 &lt;code&gt;app_tree.dot&lt;/code&gt; 在当前目录。警告：这将覆盖任何先前生成的文件。</target>
        </trans-unit>
        <trans-unit id="7f0188ed62d4d0a891a4d684caeeb5e48721569b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the dependency tree in &lt;code&gt;deps_tree.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file.</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -产生依赖关系树的一个点图描述 &lt;code&gt;deps_tree.dot&lt;/code&gt; 在当前目录。警告：这将覆盖任何先前生成的文件。</target>
        </trans-unit>
        <trans-unit id="5aa86ef28d23f77d91172ba542c09d2cc5b7637b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dotall&lt;/code&gt; (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; according to &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;dotall&lt;/code&gt; （s）-使点与换行符匹配，并将换行符设置为anycrlf；可以根据 &lt;code&gt;:re&lt;/code&gt; 文档设置 &lt;code&gt;(*CR)&lt;/code&gt; 或 &lt;code&gt;(*LF)&lt;/code&gt; 或 &lt;code&gt;(*CRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANY)&lt;/code&gt; 来覆盖新行设置</target>
        </trans-unit>
        <trans-unit id="df6f1675aa9801dfb22096bcea57d03ccca2fb4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="d4c769601399680023c8ba6fd6b77d7373a374a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses allow the result of the body passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; to be pattern matched on:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 子句允许传递给&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;的正文的结果在以下位置进行模式匹配：</target>
        </trans-unit>
        <trans-unit id="cddbb9fd21a3bab1166f759ba9181e02747b988c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; can also be &amp;ldquo;caught&amp;rdquo; using &lt;code&gt;try/catch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 也可以使用 &lt;code&gt;try/catch&lt;/code&gt; 来&amp;ldquo;捕获&amp;rdquo; 出口：</target>
        </trans-unit>
        <trans-unit id="17e496cdf50605afa594c0a2b3b48bf5f1fd62d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; signals are an important part of the fault tolerant system provided by the Erlang</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 信号是Erlang提供的容错系统的重要组成部分</target>
        </trans-unit>
        <trans-unit id="db3067f33775b9f16e85d2c27602d9e6760ad782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extended&lt;/code&gt; (x) - whitespace characters are ignored except when escaped and allow &lt;code&gt;#&lt;/code&gt; to delimit comments</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; （x）-空格字符将被忽略，除非已转义，并且允许 &lt;code&gt;#&lt;/code&gt; 分隔注释</target>
        </trans-unit>
        <trans-unit id="5dd94be61300bd55483654aaa07e30abd3dae510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - ignores padding from the input string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; -忽略输入字符串的填充</target>
        </trans-unit>
        <trans-unit id="0f2f2cad3367ff4259e6a85005d20253c790cbd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - omit padding from the output string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; -省略输出字符串中的填充</target>
        </trans-unit>
        <trans-unit id="0dd4008fc42804b6bf3e46bd4df4d0ea81c26c3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; - the current file name as a binary</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; -当前文件名（二进制）</target>
        </trans-unit>
        <trans-unit id="89e027d1ed05b4018b4a08d0262f23b3ff60ce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstline&lt;/code&gt; (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline</source>
          <target state="translated">&lt;code&gt;firstline&lt;/code&gt; （f）-强制未锚定模式在第一个换行符之前或在第一行换行，尽管匹配的文本可能会在换行符上继续</target>
        </trans-unit>
        <trans-unit id="6908e3631ddb64d7fcca5b3480aa8fd1cfac7e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; - used for anonymous function definitions</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; -用于匿名函数定义</target>
        </trans-unit>
        <trans-unit id="7b569c1f1b88d633c8ae41253689a2f767acd2bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; - accesses a map/struct field; in case the field is not present, an error is raised</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; -访问一个map / struct字段；如果该字段不存在，则会引发错误</target>
        </trans-unit>
        <trans-unit id="f4b838ac959304b5441479216a13abe7cbdbbcf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo[bar]&lt;/code&gt; - accesses the key &lt;code&gt;bar&lt;/code&gt; in &lt;code&gt;foo&lt;/code&gt;; in case &lt;code&gt;foo&lt;/code&gt; is nil, &lt;code&gt;nil&lt;/code&gt; is returned</source>
          <target state="translated">&lt;code&gt;foo[bar]&lt;/code&gt; -访问该键 &lt;code&gt;bar&lt;/code&gt; 中 &lt;code&gt;foo&lt;/code&gt; ; 如果 &lt;code&gt;foo&lt;/code&gt; 为nil，则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eef0f2d09999efe1c1a474dc48a013215ea64e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprof&lt;/code&gt; can be useful when you want to discover the bottlenecks of a sequential code.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 当您想发现顺序代码的瓶颈时，fprof很有用。</target>
        </trans-unit>
        <trans-unit id="2c7bedba0b383b7f10d86c6ad80100844e60be3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 是调用下的电流值， &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 不在当前 &lt;code&gt;map&lt;/code&gt; ），并且必须返回一个两个元素的元组：&amp;ldquo;获取&amp;rdquo;值（检索到的值，可以在返回前进行操作）以及将要存储在新映射中 &lt;code&gt;key&lt;/code&gt; 下的新值。 &lt;code&gt;fun&lt;/code&gt; 可能还会返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值将从 &lt;code&gt;map&lt;/code&gt; 中删除并返回（使此函数的行为类似于 &lt;code&gt;Map.pop(map, key)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1497d120ffa4d64ecfb633cbede2202bdb558511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 被调用下的电流值 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; （或者 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 不存在 &lt;code&gt;map&lt;/code&gt; ）和必须返回一个两元件的元组：电流值（检索到的值，它可以在被返回之前被操作），并且要存储在生成的新映射中的 &lt;code&gt;key&lt;/code&gt; 下的新值。 &lt;code&gt;fun&lt;/code&gt; 也可能返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值应从 &lt;code&gt;map&lt;/code&gt; 中删除并返回（使此函数的行为类似于 &lt;code&gt;Map.pop(map, key)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="73987292ec55c205146407f70cc34101bc201e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the module name of the given &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt;. The return value of this function is the return value of &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 是所谓的与给定的模块名称&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;。该函数的返回值是 &lt;code&gt;fun&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="0344ca817de66fc2cf01667d06d78a915e393ff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 必须是零arity匿名函数。</target>
        </trans-unit>
        <trans-unit id="bec4f976c611de0387ba3b8e5bc5a82998ebd9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 必须是零arity匿名函数。此功能产生一个链接到调用者进程并受其监视的进程。一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;结构返回一个包含相关信息。</target>
        </trans-unit>
        <trans-unit id="ba04c9a31c6587cb12b54223a008938c6c36fce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt; - a tuple as &lt;code&gt;{atom, integer}&lt;/code&gt;, where the first element is the function name and the second its arity; returns &lt;code&gt;nil&lt;/code&gt; if not inside a function</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; - &lt;code&gt;{atom, integer}&lt;/code&gt; 的元组，其中第一个元素是函数名称，第二个元素是函数名称；如果不在函数内，则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdce62b51d95c967bffec92639abb05fa80a816f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;functions&lt;/code&gt; - a list of functions imported from each module</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; -从每个模块导入的功能列表</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 是检索到的值（可以在返回之前对其进行操作）</target>
        </trans-unit>
        <trans-unit id="24a178311ad224c4a60feb7863864b4d30e88cd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; -指示拥有文件的组。对于非Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="1f43a02c647206e5b6b07cf646b10821f30b84ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix-like file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; -指示拥有文件的组。对于非类Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="64ea8480a297125c017fea9dde76f546c7b7fe47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_leader&lt;/code&gt; is the group leader of the process which logged the message</source>
          <target state="translated">&lt;code&gt;group_leader&lt;/code&gt; 是记录消息的过程的组长</target>
        </trans-unit>
        <trans-unit id="70ac6a68765cc03d71749e0430309afdc39b2cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h round/1&lt;/code&gt; works because it is defined in &lt;code&gt;Kernel&lt;/code&gt; module. All functions in the &lt;code&gt;Kernel&lt;/code&gt; module are automatically imported into our namespace. Most often you will also include the module name when looking up for documentation for a given function:</source>
          <target state="translated">&lt;code&gt;h round/1&lt;/code&gt; 有效，因为它是在 &lt;code&gt;Kernel&lt;/code&gt; 模块中定义的。 &lt;code&gt;Kernel&lt;/code&gt; 模块中的所有函数都会自动导入到我们的命名空间中。在查找给定功能的文档时，通常还会包含模块名称：</target>
        </trans-unit>
        <trans-unit id="7e4a6ea58f48db7fc69ef53cf936a56a08b467db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_call/3&lt;/code&gt; must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful backpressure mechanism.</source>
          <target state="translated">&lt;code&gt;handle_call/3&lt;/code&gt; 必须用于同步请求。这应该是默认选择，因为等待服务器回复是一种有用的反压机制。</target>
        </trans-unit>
        <trans-unit id="a2af7471be23ef0937ae1a0fe2c62f92e8f8d066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_cast/2&lt;/code&gt; must be used for asynchronous requests, when you don&amp;rsquo;t care about a reply. A cast does not even guarantee the server has received the message and, for this reason, should be used sparingly. For example, the &lt;code&gt;create/2&lt;/code&gt; function we have defined in this chapter should have used &lt;code&gt;call/2&lt;/code&gt;. We have used &lt;code&gt;cast/2&lt;/code&gt; for didactic purposes.</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 当您不关心答复时，必须将handle_cast / 2用于异步请求。强制转换甚至不能保证服务器已收到该消息，因此，应谨慎使用。例如，我们在本章中定义的 &lt;code&gt;create/2&lt;/code&gt; 函数应该使用 &lt;code&gt;call/2&lt;/code&gt; 。我们已将 &lt;code&gt;cast/2&lt;/code&gt; 用于教学目的。</target>
        </trans-unit>
        <trans-unit id="ba53ab70dc78f0a9b7412ec3b2bb0f747a7d63ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_info/2&lt;/code&gt; must be used for all other messages a server may receive that are not sent via &lt;code&gt;GenServer.call/2&lt;/code&gt; or &lt;code&gt;GenServer.cast/2&lt;/code&gt;, including regular messages sent with &lt;code&gt;send/2&lt;/code&gt;. The monitoring &lt;code&gt;:DOWN&lt;/code&gt; messages are an example of this.</source>
          <target state="translated">&lt;code&gt;handle_info/2&lt;/code&gt; 必须将handle_info / 2用于服务器可能未通过 &lt;code&gt;GenServer.call/2&lt;/code&gt; 或 &lt;code&gt;GenServer.cast/2&lt;/code&gt; 发送的所有其他消息，包括使用 &lt;code&gt;send/2&lt;/code&gt; 发送的常规消息。监视 &lt;code&gt;:DOWN&lt;/code&gt; 消息就是一个例子。</target>
        </trans-unit>
        <trans-unit id="8e34c824ac05b21ab757c5fbf6100951dcd8cb12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -在子规范中定义</target>
        </trans-unit>
        <trans-unit id="a955d26c8cf2d713bf003551df2c96067ee51799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - it is always &lt;code&gt;:undefined&lt;/code&gt; for dynamic supervisors</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -它始终是 &lt;code&gt;:undefined&lt;/code&gt; 动态监管</target>
        </trans-unit>
        <trans-unit id="1f9254b1d6d22c5cafac5af8f10ed37f33275d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;unless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89169d2e3dce0e0e3f3d300ab237fbc286465d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for!/1&lt;/code&gt; - same as above but raises an error if an implementation is not found</source>
          <target state="translated">&lt;code&gt;impl_for!/1&lt;/code&gt; -与上述相同，但是如果找不到实现，则会引发错误</target>
        </trans-unit>
        <trans-unit id="dd4dcd3de4db76dbf5cd688389ee6bc144a73c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - receives a structure and returns the module that implements the protocol for the structure, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; -接收结构并返回实现该结构协议的模块，否则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a626f31f573838ae13727b9af9053a68b4bf36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - returns the module that implements the protocol for the given argument, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; -返回为给定参数实现协议的模块，否则为 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77adafb3f8e1c04dc649c8a27bf4a028398d3422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;import Config&lt;/code&gt; 将导入功能&lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; ,&lt;/a&gt;以帮助您管理配置。</target>
        </trans-unit>
        <trans-unit id="4616b488ff51bfbaf80546fbb756faeba6d758dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; also supports &lt;code&gt;:macros&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; to be given to &lt;code&gt;:only&lt;/code&gt;. For example, to import all macros, one could write:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 还支持 &lt;code&gt;:macros&lt;/code&gt; 和 &lt;code&gt;:functions&lt;/code&gt; 赋予 &lt;code&gt;:only&lt;/code&gt; 。例如，要导入所有宏，可以编写：</target>
        </trans-unit>
        <trans-unit id="6778e8370969e09cdb7b6d95b8411befab07014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;&lt;code&gt;not in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; &lt;code&gt;not in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b77d9288e8177ffb5c0fdea530e9078c1f6cab7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; 必须是&lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;。给定一个 &lt;code&gt;enumerable&lt;/code&gt; ，它将元素放置在 &lt;code&gt;index_range.first&lt;/code&gt; （零基）之前，然后放置元素直到元素 &lt;code&gt;index_range.last&lt;/code&gt; （包括端点）。</target>
        </trans-unit>
        <trans-unit id="1c71b4bbf5308a944ca78d7e8a7957ad9301c49e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; 必须是&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;。给定一个 &lt;code&gt;enumerable&lt;/code&gt; ，它将元素 &lt;code&gt;index_range.first&lt;/code&gt; 之前（零基），然后将元素 &lt;code&gt;index_range.last&lt;/code&gt; 元素index_range.last之前（包括端点）。</target>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_arg&lt;/code&gt; 是传递给&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;的参数项（第二个参数）。</target>
        </trans-unit>
        <trans-unit id="42ccdeed4cb31f96c120a6107473e17cfa988fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; -给出索引号。在非Unix文件系统上，该字段为零。</target>
        </trans-unit>
        <trans-unit id="b6ea18a5d36717bfe706a8d2aa403ba6e826028c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix-like file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; -给出索引号。在非类Unix文件系统上，此字段将为零。</target>
        </trans-unit>
        <trans-unit id="a082bb1049b72730ef91489b19d870c7f2e5f5fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cac343e7ca30a47b6b2cafdd3b896dfb0b1254c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; ， &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f662fb245490dd208672d79aaf08db7f1d03ffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; ， &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04dc3cb7748f4ca9dc612c4051de3bbd8865f718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;invalid&lt;/code&gt; is a list of invalid options as &lt;code&gt;{option_name, value}&lt;/code&gt; where &lt;code&gt;option_name&lt;/code&gt; is the raw option and &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option</source>
          <target state="translated">&lt;code&gt;invalid&lt;/code&gt; 是无效的选项列表 &lt;code&gt;{option_name, value}&lt;/code&gt; 其中 &lt;code&gt;option_name&lt;/code&gt; 是原始选项和 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，如果是没有预料到的选项或字符串值，如果值没有在相应的选项预期的类型</target>
        </trans-unit>
        <trans-unit id="55411785328be352b733c3e64dd054a411983253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 实际上是处理文件的进程的PID。此过程链接到最初打开文件的过程。如果链接到 &lt;code&gt;io_device&lt;/code&gt; 的任何进程终止，该文件将关闭，并且进程本身将终止。</target>
        </trans-unit>
        <trans-unit id="2069292f94f4f2165e4255f81f033e84ed34215f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process monitors the process that originally opened the file (the owner process). If the owner process terminates, the file is closed and the process itself terminates too. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated. An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 实际上是处理文件的进程的PID。此过程监视最初打开文件的过程（所有者过程）。如果所有者进程终止，则文件将关闭，并且进程本身也会终止。如果链接到 &lt;code&gt;io_device&lt;/code&gt; 的任何进程终止，该文件将关闭，并且进程本身将终止。从此调用返回的 &lt;code&gt;io_device&lt;/code&gt; 可用作&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块功能的参数。</target>
        </trans-unit>
        <trans-unit id="5af2f0d60c8ca31bd9daa14054f2d8834771b498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iodata&lt;/code&gt; and &lt;code&gt;chardata&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iodata&lt;/code&gt; 和 &lt;code&gt;chardata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea30f7281c750bcdb363bf792a71040fa82420b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e622f1b70f9ca4dde650995469cb5ac546f01dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_&lt;/code&gt; prefix (&lt;code&gt;is_foo&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;is_&lt;/code&gt; 前缀（ &lt;code&gt;is_foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0ae12fa1bd5cefeb45ca87984e5434aa6c1ab55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner&lt;/code&gt; can be either a binary or a list and the result will be of the same type as &lt;code&gt;joiner&lt;/code&gt;. If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty binary.</source>
          <target state="translated">&lt;code&gt;joiner&lt;/code&gt; 可以是二进制文件也可以是列表，并且结果将与 &lt;code&gt;joiner&lt;/code&gt; 属于同一类型。如果完全没有传递 &lt;code&gt;joiner&lt;/code&gt; ，则默认为空二进制文件。</target>
        </trans-unit>
        <trans-unit id="050495ebb57fd238ad025920a895b7b1b31f5954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; - if the message is a &lt;code&gt;:report&lt;/code&gt; or &lt;code&gt;:format&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; -如果消息是 &lt;code&gt;:report&lt;/code&gt; 或 &lt;code&gt;:format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="341383e5f6f763ffb092f6be26a117949ada5934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; can be any of &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt;, or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 可以是 &lt;code&gt;:def&lt;/code&gt; ， &lt;code&gt;:defp&lt;/code&gt; ， &lt;code&gt;:defmacro&lt;/code&gt; 或 &lt;code&gt;:defmacrop&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="43a606e3b01bc357576e2067b4913ba6530c37d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - set it to &lt;code&gt;:erlang&lt;/code&gt; for Erlang projects managed by Mix. Doing so will ensure Elixir is not embedded by default. Your app will still be started as part of escript loading, with the config used during build.</source>
          <target state="translated">&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; 对于由Mix管理的Erlang项目，将其设置为 &lt;code&gt;:erlang&lt;/code&gt; 。这样做将确保默认情况下未嵌入Elixir。您的应用仍将作为escript加载的一部分启动，并使用在构建过程中使用的配置。</target>
        </trans-unit>
        <trans-unit id="1615078eab6862c1223e38ceca7c0c858e7fb3ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left not in right&lt;/code&gt; is parsed by the compiler into the AST:</source>
          <target state="translated">&lt;code&gt;left not in right&lt;/code&gt; 编译器将左不右的内容解析为AST：</target>
        </trans-unit>
        <trans-unit id="04daa36a0e26e29c02251806cbf56bde90f72442" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - the level of the message being translated</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; -正在翻译的消息的级别</target>
        </trans-unit>
        <trans-unit id="a0cdec75a5c5e0d6470766585fef67da68441fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 是 &lt;code&gt;:debug&lt;/code&gt; ， &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:warn&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 之一，如先前所述</target>
        </trans-unit>
        <trans-unit id="a4d5841581a184cf1414acb4f60c9a23be456dac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described (for compatibility with pre 1.10 backends the &lt;code&gt;:notice&lt;/code&gt; will be translated to &lt;code&gt;:info&lt;/code&gt; and all messages above &lt;code&gt;:error&lt;/code&gt; will be translated to &lt;code&gt;:error&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 是 &lt;code&gt;:debug&lt;/code&gt; ， &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:warn&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 之一，如先前所述（为了与1.10之前的后端兼容， &lt;code&gt;:notice&lt;/code&gt; 将转换为 &lt;code&gt;:info&lt;/code&gt; ,而所有 &lt;code&gt;:error&lt;/code&gt; 以上的消息将转换为 &lt;code&gt;:error&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ad467d7b51aa9a22263cef951086b6316700c37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_tracker&lt;/code&gt; - PID of the lexical tracker which is responsible for keeping user info</source>
          <target state="translated">&lt;code&gt;lexical_tracker&lt;/code&gt; -词法跟踪器的PID，负责保留用户信息</target>
        </trans-unit>
        <trans-unit id="00b7f69aa97db45047c5fc9677b43d58013c72d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the current line as an integer</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; -当前行为整数</target>
        </trans-unit>
        <trans-unit id="8a637d2453fa7712dde78a4184c51cb4f28ba3e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line_or_bytes&lt;/code&gt; - if reading should read lines or a given number of bytes</source>
          <target state="translated">&lt;code&gt;line_or_bytes&lt;/code&gt; -如果读取应读取行或给定数量的字节</target>
        </trans-unit>
        <trans-unit id="de043cb51af4ab5a147a2fd2fb7510e6d4f6968b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;links&lt;/code&gt; - the number of links to this file. This is always 1 for file systems which have no concept of links.</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; -到此文件的链接数。对于没有链接概念的文件系统，该值始终为1。</target>
        </trans-unit>
        <trans-unit id="b6df45129219eb88ff0e445a634f5ec40fa7565a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list(binary)&lt;/code&gt; - a list of named captures to capture</source>
          <target state="translated">&lt;code&gt;list(binary)&lt;/code&gt; -要捕获的命名捕获的列表</target>
        </trans-unit>
        <trans-unit id="b30b2f2ca39cc18127aed43526b57922054977d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro_aliases&lt;/code&gt; - a list of aliases defined inside the current macro</source>
          <target state="translated">&lt;code&gt;macro_aliases&lt;/code&gt; -当前宏内定义的别名列表</target>
        </trans-unit>
        <trans-unit id="e68229a8f305b62b43dd03a0bee3d8371fd691cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macros&lt;/code&gt; - a list of macros imported from each module</source>
          <target state="translated">&lt;code&gt;macros&lt;/code&gt; -从每个模块导入的宏的列表</target>
        </trans-unit>
        <trans-unit id="da01a0ff55acb30995528624346541bfd079654b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_device&lt;/code&gt; - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">&lt;code&gt;major_device&lt;/code&gt; -标识文件所在的文件系统。在Windows中，数字表示驱动器，如下所示：0表示A :， 1表示B :，依此类推。</target>
        </trans-unit>
        <trans-unit id="122658d8aed547a03014a89daa76d75e7458af25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - the message to format. If it is &lt;code&gt;:report&lt;/code&gt;, it is a tuple with &lt;code&gt;{report_type, report_data}&lt;/code&gt;, if it is &lt;code&gt;:format&lt;/code&gt;, it is a tuple with &lt;code&gt;{format_message, format_args}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; -要格式化的消息。如果为 &lt;code&gt;:report&lt;/code&gt; ，则为具有 &lt;code&gt;{report_type, report_data}&lt;/code&gt; 的元组；如果为 &lt;code&gt;:format&lt;/code&gt; ，则为具有 &lt;code&gt;{format_message, format_args}&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="758cc0c5ee8acd71fe0b83a3e86f48dd145a827c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; is the actual message (as chardata)</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 是实际的消息（作为chardata）</target>
        </trans-unit>
        <trans-unit id="876c3f9a8c4fd0d3cc2d1f037866f3debf0464cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; is a keyword list of metadata used when logging the message</source>
          <target state="translated">&lt;code&gt;metadata&lt;/code&gt; 是记录消息时使用的元数据的关键字列表</target>
        </trans-unit>
        <trans-unit id="a589d4f6762768ff5257c5bba38458ca30db3f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_level&lt;/code&gt; - the current Logger level</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; -当前记录器级别</target>
        </trans-unit>
        <trans-unit id="ed12497f2b56facc6f9492f4e4c4032a391d9c99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix-like systems. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -仅对类似Unix的系统上的字符设备有效。在所有其他情况下，此字段为零。</target>
        </trans-unit>
        <trans-unit id="3885fa3becd34b396b52f6d8056bdc58ee479e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -仅对Unix上的字符设备有效。在所有其他情况下，此字段为零。</target>
        </trans-unit>
        <trans-unit id="24b263dd8a1d1347bf64bee3038f26998b4b840b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mix.exs&lt;/code&gt; - invokes &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; -调用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6340174a39f21a758f5572a672b194a9d24cc3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; - the file permissions.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; -文件权限。</target>
        </trans-unit>
        <trans-unit id="8a3927965ac3d6f77c51036b665e6f351a35212d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:always&lt;/code&gt;, which means nesting always happen, or &lt;code&gt;:break&lt;/code&gt;, which means nesting only happens inside a group that has been broken.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:always&lt;/code&gt; ，这意味着总是发生嵌套，或者是 &lt;code&gt;:break&lt;/code&gt; ，这意味着嵌套只发生在已断开的组中。</target>
        </trans-unit>
        <trans-unit id="58c0879f979115e580bc917136d2b58ff8c9f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:enabled&lt;/code&gt; or &lt;code&gt;:disabled&lt;/code&gt;. When &lt;code&gt;:enabled&lt;/code&gt;, it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; in search of the next break.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:enabled&lt;/code&gt; 或 &lt;code&gt;:disabled&lt;/code&gt; 。当 &lt;code&gt;:enabled&lt;/code&gt; 时，它将在找到下一个中​​断后立即认为文档合适，从而有效地取消了该中断。在搜索下一个中断时，它将也忽略任何&lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50100399cfb27f3841672acd2f4af9b485e65862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; lowercases only the letters A to Z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:default&lt;/code&gt; ， &lt;code&gt;:ascii&lt;/code&gt; 或 &lt;code&gt;:greek&lt;/code&gt; 。的 &lt;code&gt;:default&lt;/code&gt; 模式认为Unicode标准中列出的所有非条件的转换。 &lt;code&gt;:ascii&lt;/code&gt; 仅将字母A到Z小写。 &lt;code&gt;:greek&lt;/code&gt; 包括在希腊语中找到的上下文相关映射。</target>
        </trans-unit>
        <trans-unit id="a1aa428e4e231b54bacb63710c1631f262151d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; uppercases only the letters a to z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:default&lt;/code&gt; ， &lt;code&gt;:ascii&lt;/code&gt; 或 &lt;code&gt;:greek&lt;/code&gt; 。的 &lt;code&gt;:default&lt;/code&gt; 模式认为Unicode标准中列出的所有非条件的转换。 &lt;code&gt;:ascii&lt;/code&gt; 仅将字母a到z大写。 &lt;code&gt;:greek&lt;/code&gt; 包括希腊语中的上下文相关映射。</target>
        </trans-unit>
        <trans-unit id="a86fdaff8bc5148e78a1c4c04f8fce0a3900889d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes&lt;/code&gt; - the file modes</source>
          <target state="translated">&lt;code&gt;modes&lt;/code&gt; -文件模式</target>
        </trans-unit>
        <trans-unit id="8d0e52c287df97f7b63fd739d48b6d486974eb14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes_or_function&lt;/code&gt; can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt;. See the documentation for &lt;a href=&quot;#open/3&quot;&gt;&lt;code&gt;open/3&lt;/code&gt;&lt;/a&gt; for more information on this function.</source>
          <target state="translated">&lt;code&gt;modes_or_function&lt;/code&gt; 可以是模式列表或函数。如果是列表，则将其视为模式列表（在下面记录）。如果它是一个函数，则等效于调用 &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt; 。有关此功能的更多信息，请参见&lt;a href=&quot;#open/3&quot;&gt; &lt;code&gt;open/3&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="34262bd30becc8991857017eb2e5b09e7a70e4f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - the current module name</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; -当前模块名称</target>
        </trans-unit>
        <trans-unit id="698d9c8f57c8e28a58401b70d215fc5e4dfe9978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; has to be an Elixir module, as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; won't work with Erlang-style modules (for example, &lt;code&gt;split(:lists)&lt;/code&gt; raises an error).</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 必须是Elixir模块，因为&lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt;不适用于Erlang样式的模块（例如， &lt;code&gt;split(:lists)&lt;/code&gt; 会引发错误）。</target>
        </trans-unit>
        <trans-unit id="548b3515fdb43f8aa1119d92ad82f1b43b9de201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; -子规范中定义</target>
        </trans-unit>
        <trans-unit id="5b0d17e736b2173d4e4a1a204473eec63e0cda5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as specified by the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; -由子规范指定</target>
        </trans-unit>
        <trans-unit id="b3e68cee7399cd5a129a86e8776d09db0b50d6de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; is the message and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. When a timeout occurs the message is &lt;code&gt;:timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 是消息， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。发生超时时，消息为 &lt;code&gt;:timeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235eae13b2d8f1e8b35533fb20776ffccdd37a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mtime&lt;/code&gt; - the last time the file was written.</source>
          <target state="translated">&lt;code&gt;mtime&lt;/code&gt; -上次写入文件的时间。</target>
        </trans-unit>
        <trans-unit id="4413bd051f5b2ef5173fbddf4ea926ec05b4ccf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt; (m) - causes &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to mark the beginning and end of each line; use &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; to match the end or beginning of the string</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt; （m）-使 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 标记每行的开始和结束；使用 &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 匹配字符串的结尾或开头</target>
        </trans-unit>
        <trans-unit id="1aa7f499be35910aae1a7c96d198532426312d81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, &lt;code&gt;v(-2)&lt;/code&gt; returns the value of the expression evaluated before the last evaluated expression. In particular, &lt;code&gt;v(-1)&lt;/code&gt; returns the result of the last evaluated expression and &lt;code&gt;v()&lt;/code&gt; does the same.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 可以是负值：如果是，则返回相对于当前表达式的相应表达式值。例如， &lt;code&gt;v(-2)&lt;/code&gt; 返回在最后一个求值表达式之前求值的表达式的值。特别是， &lt;code&gt;v(-1)&lt;/code&gt; 返回最后一个求值表达式的结果，而 &lt;code&gt;v()&lt;/code&gt; 则执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="45c8a3e19ab3e2ddbc2090990f79c346b752b3be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is an integer greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 是大于或等于 &lt;code&gt;0&lt;/code&gt; 的整数。</target>
        </trans-unit>
        <trans-unit id="5659d6236346e538cb5cb8cba7c914efd4b16565" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/0&lt;/code&gt; to create a new record with default values for all fields</source>
          <target state="translated">&lt;code&gt;name/0&lt;/code&gt; 以使用所有字段的默认值创建新记录</target>
        </trans-unit>
        <trans-unit id="f6ba1c0b71b535b43431e95788b71f1fdb5ee903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/1&lt;/code&gt; to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list</source>
          <target state="translated">&lt;code&gt;name/1&lt;/code&gt; 以创建具有给定字段和值的新记录，以获取记录中给定字段的从零开始的索引，或将给定记录转换为关键字列表</target>
        </trans-unit>
        <trans-unit id="cd9835c312b0e62d1d19feb8dd6a112dd5f5a0e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/2&lt;/code&gt; to update an existing record with the given fields and values or to access a given field in a given record</source>
          <target state="translated">&lt;code&gt;name/2&lt;/code&gt; 以使用给定的字段和值更新现有记录，或访问给定记录中的给定字段</target>
        </trans-unit>
        <trans-unit id="11db5b5b41604eea36b6926eb7a04818f3d804d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 必须是一个原子，并且在使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;发送消息时可以代替PID /端口标识符。</target>
        </trans-unit>
        <trans-unit id="64a47b8a0625c2774e6a643cd7191d74cfc61cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 必须是一个原子，并且在使用&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;发送消息时可以代替PID /端口标识符。</target>
        </trans-unit>
        <trans-unit id="91d48a3d18e54472d43b317cb1d047ea37a8ead4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;, which is the name of the extracted record, is expected to be an atom &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ，它是提取记录的名称，&lt;em&gt;在编译时&lt;/em&gt;应该是一个原子。</target>
        </trans-unit>
        <trans-unit id="ec3f729a0f6c717fcfbc43d515a7ec59810c5367" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native&lt;/code&gt; is determined by the VM at startup and will depend on the host operating system.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 由虚拟机在启动时确定，并将取决于主机操作系统。</target>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 是使用 &lt;code&gt;update_value&lt;/code&gt; 更新 &lt;code&gt;key&lt;/code&gt; 的值之后的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f28f31350f1c7665853e6d4b5999e6152b971b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline&lt;/code&gt; - not available, use &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANYCRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; at the beginning of the regexp according to the &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;newline&lt;/code&gt; -不可用，根据 &lt;code&gt;:re&lt;/code&gt; 文档，在正则表达式的开头使用 &lt;code&gt;(*CR)&lt;/code&gt; 或 &lt;code&gt;(*LF)&lt;/code&gt; 或 &lt;code&gt;(*CRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANYCRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANY)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22526a6e658f1a28d28bf75f04eb407c154f8ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; （v1.0）</target>
        </trans-unit>
        <trans-unit id="6fab3275a5dbf0c17e6bb5dbfbc499091c5cb4ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; if the task keeps running past the timeout</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 如果任务持续超过超时，则为nil</target>
        </trans-unit>
        <trans-unit id="0d2d366e73b9ec112919fa2886cd3525aa66ea55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_auto_capture&lt;/code&gt; - not available, use &lt;code&gt;?:&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;no_auto_capture&lt;/code&gt; -不可用，使用 &lt;code&gt;?:&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="408ece252fdd1021e44cd3be96e784b7803ec157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nodes&lt;/code&gt; is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</source>
          <target state="translated">&lt;code&gt;nodes&lt;/code&gt; 是将请求发送到的节点名称的列表。默认值为所有已知节点（包括该节点）的列表。</target>
        </trans-unit>
        <trans-unit id="8137eb4c3f6c478804bd118d3101e44c85663fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 必须是非负整数。</target>
        </trans-unit>
        <trans-unit id="f3b3f1b4b4b341558fb4af537b367fd2795f31d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either a &lt;code&gt;pid&lt;/code&gt; of the monitored process (if monitoring a PID) or &lt;code&gt;{name, node}&lt;/code&gt; (if monitoring a remote or local name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 是受监视进程的 &lt;code&gt;pid&lt;/code&gt; （如果监视PID）或 &lt;code&gt;{name, node}&lt;/code&gt; （如果监视远程或本地名称）；</target>
        </trans-unit>
        <trans-unit id="60373c8878902ec332f31b76bff00eee4691253c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either the &lt;code&gt;port&lt;/code&gt; being monitored (when monitoring by port ID) or &lt;code&gt;{name, node}&lt;/code&gt; (when monitoring by a port name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 是正在监视的 &lt;code&gt;port&lt;/code&gt; （通过端口ID监视时）或 &lt;code&gt;{name, node}&lt;/code&gt; （通过端口名称监视）；</target>
        </trans-unit>
        <trans-unit id="f4103502bdc67af84a755c711febd0144e731649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_vsn&lt;/code&gt; is the previous version of the module (defined by the &lt;code&gt;@vsn&lt;/code&gt; attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element &lt;code&gt;:down&lt;/code&gt;. &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;extra&lt;/code&gt; is any extra data required to change the state.</source>
          <target state="translated">&lt;code&gt;old_vsn&lt;/code&gt; 是升级时模块的先前版本（由 &lt;code&gt;@vsn&lt;/code&gt; 属性定义）。降级时，以前的版本将打包为带有第一个元素 &lt;code&gt;:down&lt;/code&gt; 的2元组。 &lt;code&gt;state&lt;/code&gt; 是当前状态&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;extra&lt;/code&gt; 就是要改变状态所需的任何额外数据。</target>
        </trans-unit>
        <trans-unit id="571d94e13302249f0de59d56d782ae3e234cacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options_or_function&lt;/code&gt; can be a keyword list of options or a function.</source>
          <target state="translated">&lt;code&gt;options_or_function&lt;/code&gt; 可以是选项或函数的关键字列表。</target>
        </trans-unit>
        <trans-unit id="3bab089b1bf1e41f034e7ae6bdb132bc0001b94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;and&lt;/code&gt; 是短路运算符。仅当左侧不足以确定结果时，它们才执行右侧：</target>
        </trans-unit>
        <trans-unit id="ccbe854a095f6f33ceeba28c9b8d43c2cbc1d56a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is a keyword list of parsed switches with &lt;code&gt;{switch_name, value}&lt;/code&gt; tuples in it; &lt;code&gt;switch_name&lt;/code&gt; is the atom representing the switch name while &lt;code&gt;value&lt;/code&gt; is the value for that switch parsed according to &lt;code&gt;opts&lt;/code&gt; (see the &quot;Examples&quot; section for more information)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是其中包含 &lt;code&gt;{switch_name, value}&lt;/code&gt; 元组的已解析开关的关键字列表； &lt;code&gt;switch_name&lt;/code&gt; 是代表交换机名称的原子，而 &lt;code&gt;value&lt;/code&gt; 是根据 &lt;code&gt;opts&lt;/code&gt; 解析的该交换机的值（有关更多信息，请参见&amp;ldquo;示例&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="b1fbee1588161b4bf8e5a810b28d741081f25011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是已解析的开关的列表（与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; 中的&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="2788d1165c4896248d485fc9d7605024d3d940c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是已解析的开关的列表（与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; 中的&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="56a1d646feea00078c3dafde93470f5d90c7d9db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the file path</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; -文件路径</target>
        </trans-unit>
        <trans-unit id="c68a85ae9613cab9896c95f71c08475d4a1e6f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; has to be a literal string and is automatically expanded via &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 必须是文字字符串，并通过&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt;自动扩展。</target>
        </trans-unit>
        <trans-unit id="bff908c352a7c02daae4149d788dab257dcc7734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdict_and_state&lt;/code&gt; is a two-elements list &lt;code&gt;[pdict, state]&lt;/code&gt; where &lt;code&gt;pdict&lt;/code&gt; is a list of &lt;code&gt;{key, value}&lt;/code&gt; tuples representing the current process dictionary of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pdict_and_state&lt;/code&gt; 是两元件列表 &lt;code&gt;[pdict, state]&lt;/code&gt; 其中 &lt;code&gt;pdict&lt;/code&gt; 是列表 &lt;code&gt;{key, value}&lt;/code&gt; 元组代表的当前进程字典&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;state&lt;/code&gt; 是所述的当前状态&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c00f6b21503d6f14ec9e351116f82e98a1a573d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="283bbf3a7e63361529544f57e65445c33be2473a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; is the PID of the caller and &lt;code&gt;tag&lt;/code&gt; is a unique term used to identify the call.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 是呼叫者的PID，而 &lt;code&gt;tag&lt;/code&gt; 是用于识别呼叫的唯一术语。</target>
        </trans-unit>
        <trans-unit id="7472d33de0e4e4c6d6bc5be3bc64d1117f76ab97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 必须引用在本地节点上运行的进程，否则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87f6156bd80de24e4a8c659010f40070dcf0cd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 必须引用在本地节点上运行的进程，否则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b460b4fb7f2948315666a3696deeaf29f7c5fac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - does not use Unicode code points for formatting the tree. This is the default on Windows.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -不使用Unicode代码点来格式化树。这是Windows上的默认设置。</target>
        </trans-unit>
        <trans-unit id="167a28851306fdaf355a0b9d87bd9e06c3264602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - the same as pretty except ASCII characters are used instead of Unicode characters. This is the default on Windows;</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -除了使用ASCII字符代替Unicode字符外，其他均与Pretty相同。这是Windows上的默认设置。</target>
        </trans-unit>
        <trans-unit id="d8a4a973778edbc3b9292682c2961c04afdada51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 可以是字符串，字符串列表或已编译模式。</target>
        </trans-unit>
        <trans-unit id="d7a7b88e7dfa1815defebaaadeadc69b2b64802d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - prints the graph to the terminal using Unicode characters. Each prints each file followed by the files it depends on. This is the default except on Windows;</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; -使用Unicode字符将图形打印到终端。每个都打印每个文件，然后打印它所依赖的文件。这是默认设置，Windows除外。</target>
        </trans-unit>
        <trans-unit id="0ff046f53f79369619f74d0275786f73ba6cad39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - uses Unicode code points for formatting the tree. This is the default except on Windows.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; -使用Unicode代码点来格式化树。除Windows以外，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="a5c6719a29e3444d2a98704658b2abe3abc07b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;raw&lt;/code&gt; - a boolean indicating if bin functions should be used</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; -一个布尔值，指示是否应使用bin函数</target>
        </trans-unit>
        <trans-unit id="2413f2dcbac9c52ab69f886cdee3aec797acde03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is exit reason and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 是退出原因， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="3d14f1d74048b142cf9c3c866e8baef03f5f628e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is the exit reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 是退出的原因。</target>
        </trans-unit>
        <trans-unit id="6d577afb9a7d7b11f4e9b26cc4f2b99ca0cd4414" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar PATH&lt;/code&gt; - specifies a path for &lt;code&gt;rebar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar PATH&lt;/code&gt; 指定 &lt;code&gt;rebar&lt;/code&gt; 的路径</target>
        </trans-unit>
        <trans-unit id="fb8b62aa3c01480881b0ff737a93cf393955b7ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar.config&lt;/code&gt; - invokes &lt;code&gt;rebar compile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar.config&lt;/code&gt; -调用 &lt;code&gt;rebar compile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ea1f065e3dfe97d2f4adaffe2e923025e9a488c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar3 PATH&lt;/code&gt; - specifies a path for &lt;code&gt;rebar3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar3 PATH&lt;/code&gt; -指定 &lt;code&gt;rebar3&lt;/code&gt; 的路径</target>
        </trans-unit>
        <trans-unit id="017b38f6c3a63b34a77cb61fad862a0108619da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; is a monitor reference returned by this function;</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 是此函数返回的监视器引用；</target>
        </trans-unit>
        <trans-unit id="f67bb08de7b98445d3c88e9a2ee8208aab548754" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and are executed on every command to set up environment variables, including specific ones to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 和 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; -复制到每个发行版并在每个命令上执行以设置环境变量（包括VM的特定变量）和常规环境的模板文件</target>
        </trans-unit>
        <trans-unit id="f1dac4945e37fa410a22296831615f2618a6f8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and executed on every command to set up environment variables, including ones specific to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 和 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; -复制到每个发行版中并在每个命令上执行以设置环境变量（包括特定于VM的环境变量）的模板文件</target>
        </trans-unit>
        <trans-unit id="c19918b14a9453c91c643c933cd15244538fc1e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - a template file that is copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags</source>
          <target state="translated">&lt;code&gt;rel/vm.args.eex&lt;/code&gt; -复制到每个发行版中的模板文件，并提供Erlang虚拟机的静态配置和其他运行时标志</target>
        </trans-unit>
        <trans-unit id="7f40a3451ab81b3153487e704b02d37b9b6a4ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replies&lt;/code&gt; - is a list of &lt;code&gt;{node, reply}&lt;/code&gt; tuples where &lt;code&gt;node&lt;/code&gt; is the node that replied and &lt;code&gt;reply&lt;/code&gt; is its reply</source>
          <target state="translated">&lt;code&gt;replies&lt;/code&gt; -是 &lt;code&gt;{node, reply}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;node&lt;/code&gt; 是被 &lt;code&gt;reply&lt;/code&gt; 的节点，reply是其答复</target>
        </trans-unit>
        <trans-unit id="1e85e74a7cd5534b5dc26bb806f6e8445febf275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from&lt;/code&gt; is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 是由&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;发送的请求消息， &lt;code&gt;from&lt;/code&gt; 一个2元组，包含调用者的PID和唯一标识该调用的术语， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。</target>
        </trans-unit>
        <trans-unit id="04e74abb0f4cf0d18536a2a96e905cc0f6069b33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 是由&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;发送的请求消息， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。</target>
        </trans-unit>
        <trans-unit id="93816bb90205c96752dc4b1f4768e5dfd91ffd4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; - the list of required modules</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; 所需模块列表</target>
        </trans-unit>
        <trans-unit id="6c48083bf2c441634af8637cbd181b09103d558d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="c088bb2e30718916b5822f6df8045124d80cf2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fafec51a6ba058e17a08730a003c35a45d91a237" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 是参数列表（与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="99d571b4f50dd13d3d5dab2e90c0858010d81600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 是参数列表（与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; 中&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="3bfa723258218ecec6b8ad74fe2b88b2c40ccf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: words in the list are strings (default)</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ：列表中的单词是字符串（默认）</target>
        </trans-unit>
        <trans-unit id="62965b3fa200d2fcdd302a063393661d33658602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2218676f02b43a5d86faf5ba604881574737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serve/1&lt;/code&gt; is another loop that reads a line from the socket and writes those lines back to the socket. Note that the &lt;code&gt;serve/1&lt;/code&gt; function uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;the pipe operator &lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/a&gt; to express this flow of operations. The pipe operator evaluates the left side and passes its result as the first argument to the function on the right side. The example above:</source>
          <target state="translated">&lt;code&gt;serve/1&lt;/code&gt; 是另一个循环，它从套接字读取一行并将这些行写回到套接字。请注意， &lt;code&gt;serve/1&lt;/code&gt; 函数使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;管道运算符 &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;/a&gt;表示此操作流程。管道运算符评估左侧，并将其结果作为第一个参数传递给右侧的函数。上面的例子：</target>
        </trans-unit>
        <trans-unit id="4035242838ff6348de2918394188b203c1cec888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 可以是此模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中描述的任何值。</target>
        </trans-unit>
        <trans-unit id="2bd4d2b94c9ed5de47dab724a819b4256c36fb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks can be defined by a block, by passing an atom naming a one-arity function, or by passing a list of such atoms. Both can opt to receive the current context by specifying it as parameter if defined by a block. Functions used to define a test setup must accept the context as single argument.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;setup_all&lt;/code&gt; 回调可以由一个块定义，可以通过传递一个命名为一元函数的原子，也可以通过传递此类原子的列表来定义。两者都可以通过将当前上下文指定为参数（如果由块定义）来选择接收当前上下文。用于定义测试设置的函数必须接受上下文作为单个参数。</target>
        </trans-unit>
        <trans-unit id="74e50f77430f1a1bdfe5ca63476784209360d3eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; and &lt;code&gt;unsigned&lt;/code&gt; are only used for matching binaries (see below) and are only used for integers.</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 仅用于匹配二进制文件（请参见下文），并且仅用于整数。</target>
        </trans-unit>
        <trans-unit id="cfa5ba00cd0c9fad3ce7a3c8fe2e154e61d87770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - size of file in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; -文件大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="0a4f18566a210c559013bf9a5086044257909566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source_file&lt;/code&gt; and &lt;code&gt;destination_file&lt;/code&gt; must be a file or a symbolic link to one, or in the case of destination, a path to a non-existent file. If either one of them is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;source_file&lt;/code&gt; 和 &lt;code&gt;destination_file&lt;/code&gt; 必须是一个文件或指向一个文件的符号链接，或者如果是Destination，则是一个不存在的文件的路径。如果其中一个是目录，将返回 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38212c1b9d372738da7952d34b2b9942eed99263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt; are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let&amp;rsquo;s see the most common one, called tasks.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 和 &lt;code&gt;spawn_link/1&lt;/code&gt; 是在Elixir中创建进程的基本原语。尽管到目前为止我们仅使用它们，但是大多数时候我们将使用基于它们的抽象。让我们看看最常见的一种，称为任务。</target>
        </trans-unit>
        <trans-unit id="ef8e38976f8ee83eeb6656542cc862dd86ba301d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; takes a function which it will execute in another process.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 具有一个将在另一个进程中执行的功能。</target>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 是在 &lt;code&gt;:mod&lt;/code&gt; 规范密钥（例如， &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ）中传递给应用程序的参数。</target>
        </trans-unit>
        <trans-unit id="1befc5d39644d1bc3134d4c35ea706fb5258286c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (for example, &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 是在 &lt;code&gt;:mod&lt;/code&gt; 规范键中传递给应用程序的参数（例如， &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe417925fd6a03a1cadb38a84034165856ff0856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_link/2&lt;/code&gt;, &lt;code&gt;init/2&lt;/code&gt;, and strategies</source>
          <target state="translated">&lt;code&gt;start_link/2&lt;/code&gt; ， &lt;code&gt;init/2&lt;/code&gt; 和策略</target>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 定义如何启动应用程序：</target>
        </trans-unit>
        <trans-unit id="6346aa15c5ba367a190147de81ac212a3a013075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;starting_on&lt;/code&gt; can also be &lt;code&gt;:default&lt;/code&gt;, which is equivalent to &lt;code&gt;:monday&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;starting_on&lt;/code&gt; 也可以是 &lt;code&gt;:default&lt;/code&gt; ，它等效于 &lt;code&gt;:monday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bed6184e7c750cc712f2203171e1d9b7e789646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. If the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt; is present, &lt;code&gt;state&lt;/code&gt; is its return value instead.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;返回的状态（如果已返回），否则为 &lt;code&gt;[]&lt;/code&gt; 。如果存在可选的回调&lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;state&lt;/code&gt; 为其返回值。</target>
        </trans-unit>
        <trans-unit id="2e6893ab1b754c2ae7dc9f997ecb10ec083f344f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt; - prints general statistics about the graph;</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; -打印有关图形的常规统计信息；</target>
        </trans-unit>
        <trans-unit id="2790d8f945460f49048af9ed95a7afa73085f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer value which is returned by the runtime system to the operating system.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 必须是非负整数值，由运行时系统返回给操作系统。</target>
        </trans-unit>
        <trans-unit id="8c1f069e75f041dd495821b88b772c17da451669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer, the atom &lt;code&gt;:abort&lt;/code&gt; or a binary.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 必须是非负整数，原子 &lt;code&gt;:abort&lt;/code&gt; 或二进制。</target>
        </trans-unit>
        <trans-unit id="d6ac53a1094c979479b6f1b561f3e74f3968e85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; is optional and, if not passed, defaults to &lt;code&gt;count&lt;/code&gt;, i.e. chunks do not overlap.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 是可选的，如果未通过，则默认为 &lt;code&gt;count&lt;/code&gt; ，即块不重叠。</target>
        </trans-unit>
        <trans-unit id="07277647df2178950f06633decd26215f156ae7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;float#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是包含小数点的浮点数的字符串表示形式。为了将不带小数点的字符串解析为浮点数，应使用&lt;a href=&quot;float#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; &lt;/a&gt;。否则，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d88be8a0ed663da6633319f9f9081e4b82fb323" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是包含小数点的浮点数的字符串表示形式。为了将不带小数点的字符串解析为浮点数，应使用&lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; &lt;/a&gt;。否则，将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a57ce393e0bf34dc0ca576de7675a4598947d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;integer#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是整数的字符串表示形式。否则，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。如果要解析可能包含格式错误的整数的字符串，请使用&lt;a href=&quot;integer#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c40c085b7a127dc3368869ad8c744f3545f95330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是整数的字符串表示形式。否则，将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。如果要解析可能包含格式错误的整数的字符串，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a8f508a843dbaf6b9d5439d982a8903dd2999cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; will be the initial input of the newly created device.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 将是新创建的设备的初始输入。</target>
        </trans-unit>
        <trans-unit id="572985c443231f1ffed373013f737ade9f044914" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suffixes&lt;/code&gt; can be either a single suffix or a list of suffixes.</source>
          <target state="translated">&lt;code&gt;suffixes&lt;/code&gt; 可以是单个后缀，也可以是后缀列表。</target>
        </trans-unit>
        <trans-unit id="bdbf5dd9e7ab5c58f01c1dec17c4fb41c8b81931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是一个大于零的整数，它指定代理执行该功能并返回结果值之前允许的毫秒数，或者原子 &lt;code&gt;:infinity&lt;/code&gt; 无限期等待。如果在指定时间内未收到结果，则函数调用失败，并且调用者退出。</target>
        </trans-unit>
        <trans-unit id="1d95411839d7e41402b228ea7bab4f308778467d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. The default value is &lt;code&gt;5000&lt;/code&gt;. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是一个大于零的整数，它指定等待答复的毫秒数，或者原子 &lt;code&gt;:infinity&lt;/code&gt; 无限期等待。默认值为 &lt;code&gt;5000&lt;/code&gt; 。如果在指定的时间内未收到答复，则函数调用失败，并且调用者退出。如果呼叫者发现了故障并继续运行，并且服务器的回复很晚，则它可能会在以后的任何时间到达呼叫者的消息队列中。在这种情况下，调用者必须为此做好准备，并丢弃所有包含两个元素元组的垃圾消息，并以引用作为第一个元素。</target>
        </trans-unit>
        <trans-unit id="4f68b2a1cb84499ed2c00c6482e49eeac64039aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is either the number of milliseconds to sleep as an integer or the atom &lt;code&gt;:infinity&lt;/code&gt;. When &lt;code&gt;:infinity&lt;/code&gt; is given, the current process will sleep forever, and not consume or reply to messages.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是以毫秒为单位的整数，也可以是atom &lt;code&gt;:infinity&lt;/code&gt; 。当给出 &lt;code&gt;:infinity&lt;/code&gt; 时，当前进程将永远休眠，并且不会消耗或回复消息。</target>
        </trans-unit>
        <trans-unit id="0d03dca1cbfe2406a67e381ab2870ef2bddd059b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is the timestamp for when the message was logged, as a &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; tuple</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 是记录消息的时间戳，以 &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; 元组记录</target>
        </trans-unit>
        <trans-unit id="08d7a6e449b07af8124dddd49b8a31de7399fb11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - pad the output string to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; -垫输出字符串到8（默认）最接近的倍数</target>
        </trans-unit>
        <trans-unit id="4948e3624434de9113da8f38917d02367479d2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - requires the input string to be padded to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; -要求将输入字符串填充为最接近的8的倍数（默认）</target>
        </trans-unit>
        <trans-unit id="37f317994df4c5094e8b2eff3348d68fdc66f93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5f7234d664879c7a94dbc62ea230645de6ab29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f74a2bb6fb5fbbcf93b8f217f0cc291412b0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; - used as atoms</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; -用作原子</target>
        </trans-unit>
        <trans-unit id="040c2cc20f87605723b2be4cdc0803a474de3d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt; are reserved words that are represented by the atoms &lt;code&gt;:true&lt;/code&gt;, &lt;code&gt;:false&lt;/code&gt; and &lt;code&gt;:nil&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 是保留字，分别由原子 &lt;code&gt;:true&lt;/code&gt; ， &lt;code&gt;:false&lt;/code&gt; 和 &lt;code&gt;:nil&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="256ad4bcf7e37fd9a26fac8676e48361c0ed6b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt;; the type of the file.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt; ; 文件的类型。</target>
        </trans-unit>
        <trans-unit id="300d31ca0e6078f76938d4d6e305aff178a1dd44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt; as defined in the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:supervisor&lt;/code&gt; ，在子规范中定义</target>
        </trans-unit>
        <trans-unit id="1b592d0e2922f716b9d2f7ecf2cb31932d6201bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt;, as specified by the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:supervisor&lt;/code&gt; ，由子规范指定</target>
        </trans-unit>
        <trans-unit id="c53830ff73ee4bc1cf4e63694e58c8a37efe371d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; -指示文件的所有者。对于非Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="9c0b465a5be832bc5b6b71e76009205aaeca5144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix-like file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; -指示文件的所有者。对于非类Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="11d146eb39b484665d14fa72a8f2163b4c09bdef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ungreedy&lt;/code&gt; (U) - inverts the &quot;greediness&quot; of the regexp (the previous &lt;code&gt;r&lt;/code&gt; option is deprecated in favor of &lt;code&gt;U&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ungreedy&lt;/code&gt; （U）-反转正则表达式的&amp;ldquo;贪婪性&amp;rdquo;（不推荐使用以前的 &lt;code&gt;r&lt;/code&gt; 选项，而推荐使用 &lt;code&gt;U&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7c18fe6e2d8bd072b618387739a87dc0d858fa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and causes character classes like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, etc. to also match on Unicode (see examples below in &quot;Character classes&quot;). It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; （u）-启用 &lt;code&gt;\p&lt;/code&gt; 等Unicode特定模式，并使 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 等字符类也与Unicode匹配（请参见下面的&amp;ldquo;字符类&amp;rdquo;中的示例）。它期望在匹配时给出有效的Unicode字符串</target>
        </trans-unit>
        <trans-unit id="2b1493a8644a9f711c2b660f18b2fd58dc57c6be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and change modifiers like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and friends to also match on Unicode. It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; （u）-使Unicode特定模式（例如 &lt;code&gt;\p&lt;/code&gt; 和更改修饰符（例如 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 和朋友）也可以在Unicode上匹配。它期望在匹配时给出有效的Unicode字符串</target>
        </trans-unit>
        <trans-unit id="3e21f4d0f150e8661e7894e55a7889cd5ea7c932" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unquote&lt;/code&gt; can even be used to inject function names:</source>
          <target state="translated">&lt;code&gt;unquote&lt;/code&gt; 甚至可以用来注入函数名称：</target>
        </trans-unit>
        <trans-unit id="b17f1b91056678deff5c7f31333a1d38b43965f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; （默认）</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 是要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值</target>
        </trans-unit>
        <trans-unit id="be70aa90b34d9b75607b8ad2c0d7e7068392c466" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Agent&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Agent&lt;/code&gt; 还接受用于配置子级规范的选项列表，并因此配置其在管理程序下的运行方式。可以使用以下选项来自定义生成的&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d929111db564f10be37ff4f2d784720755bf5dc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; defines a default implementation of this function which does nothing and just returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 定义了此函数的默认实现，该实现不执行任何操作，仅返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 没有为&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调提供默认实现。</target>
        </trans-unit>
        <trans-unit id="8a3cd0a6ee94294da88b60ba9da6b647450af00b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use ExUnit.Case&lt;/code&gt; is responsible for setting up our module for testing and imports many test-related functionality, such as the &lt;code&gt;test/2&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 负责设置我们的测试模块，并导入许多与测试相关的功能，例如 &lt;code&gt;test/2&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="0384590b7214948d657738c3d5bfaf0a2cce9c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use GenServer&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;code&gt;child_spec/1&lt;/code&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use GenServer&lt;/code&gt; 还接受用于配置子级规范的选项列表，并因此配置其在管理程序下的运行方式。可以使用以下选项来自定义生成的 &lt;code&gt;child_spec/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9efc1ff6af2e783df9ff3c05cff5c9496b06d302" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Mix.Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;use Mix.Config&lt;/code&gt; 将导入功能&lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; &lt;/a&gt;来帮助您管理配置。</target>
        </trans-unit>
        <trans-unit id="19aacd0bb192aebbc1eaab7675d05f8b371c3c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Supervisor&lt;/code&gt; also defines a &lt;code&gt;child_spec/1&lt;/code&gt; function which allows us to run &lt;code&gt;MyApp.Supervisor&lt;/code&gt; as a child of another supervisor or at the top of your supervision tree as:</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 还定义了 &lt;code&gt;child_spec/1&lt;/code&gt; 函数，该函数使我们可以将 &lt;code&gt;MyApp.Supervisor&lt;/code&gt; 作为其他主管的孩子或在您的主管树的顶部运行：</target>
        </trans-unit>
        <trans-unit id="32f3cdd98eaec66584c149fc480cbffd83f3560c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Task&lt;/code&gt; defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, allowing the defined module to be put under a supervision tree. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Task&lt;/code&gt; 定义了&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;函数，允许将定义的模块放在监视树下。可以使用以下选项来自定义生成的&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bbf41816587fbe42f4bce2c3bd242b8da116833a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 必须是布尔值；如果不是，则会&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="9001f343f267d4f2ca6c3f31d0f08dd106421221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; - a list keeping all defined variables as &lt;code&gt;{var, context}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; -将所有定义的变量保留为 &lt;code&gt;{var, context}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6656f8557f89b74ee5b1266b3a4c9d4655c1a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt; - see &lt;a href=&quot;patterns-and-guards#guards&quot;&gt;Guards&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; -见&lt;a href=&quot;patterns-and-guards#guards&quot;&gt;守卫&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39f4537522a5331ce77a3c7353321177c38c05b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; - used as operators</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; -作为运营商</target>
        </trans-unit>
        <trans-unit id="9ccd1761f004157a607955393cdd4a8c9b980865" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with&lt;/code&gt; also supports the &lt;code&gt;else&lt;/code&gt; keyword, which supports patterns matching and guards.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 还支持 &lt;code&gt;else&lt;/code&gt; 关键字，该关键字支持模式匹配和防护。</target>
        </trans-unit>
        <trans-unit id="a2513b6e343efdb3f9d26eeabec520aa38f1a707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 将导致&lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="f61ce99a9a56276c62bed185d0f0b8dde3175729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 将导致&lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="2f10cb46a7888b0c5592ef3405b96b453cace5d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; - exit signals in case the port crashes. If reason is not &lt;code&gt;:normal&lt;/code&gt;, this message will only be received if the owner process is trapping exits</source>
          <target state="translated">&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; -如果端口崩溃，则退出信号。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ，则仅当所有者进程正在捕获出口时才会收到此消息</target>
        </trans-unit>
        <trans-unit id="065a347a5c8149198567fd9f55e5f4c28abdefcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias, meta, alias, as, opts}&lt;/code&gt; - traced whenever &lt;code&gt;alias&lt;/code&gt; is aliased to &lt;code&gt;as&lt;/code&gt;. &lt;code&gt;meta&lt;/code&gt; is the alias AST metadata and &lt;code&gt;opts&lt;/code&gt; are the alias options.</source>
          <target state="translated">&lt;code&gt;{:alias, meta, alias, as, opts}&lt;/code&gt; -每当 &lt;code&gt;alias&lt;/code&gt; 被别名为 &lt;code&gt;as&lt;/code&gt; 时都将跟踪。 &lt;code&gt;meta&lt;/code&gt; 是别名AST元数据，而 &lt;code&gt;opts&lt;/code&gt; 是别名选项。</target>
        </trans-unit>
        <trans-unit id="082404bfe2437ad4bd067635d72a3999fb3e2dae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias_expansion, meta, as, alias}&lt;/code&gt; traced whenever there is an alias expansion for a previously defined &lt;code&gt;alias&lt;/code&gt;, i.e. when the user writes &lt;code&gt;as&lt;/code&gt; which is expanded to &lt;code&gt;alias&lt;/code&gt;. &lt;code&gt;meta&lt;/code&gt; is the alias expansion AST metadata.</source>
          <target state="translated">&lt;code&gt;{:alias_expansion, meta, as, alias}&lt;/code&gt; 每当对先前定义的 &lt;code&gt;alias&lt;/code&gt; 进行别名扩展时（即，当用户写成 &lt;code&gt;as&lt;/code&gt; 时被扩展为 &lt;code&gt;alias&lt;/code&gt; )都被跟踪。 &lt;code&gt;meta&lt;/code&gt; 是别名扩展AST元数据。</target>
        </trans-unit>
        <trans-unit id="6a890edd2324777883e6844077da60f97a9d6609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias_reference, meta, module}&lt;/code&gt; - traced whenever there is an alias in the code, i.e. whenever the user writes &lt;code&gt;MyModule.Foo.Bar&lt;/code&gt; in the code, regardless if it was expanded or not.</source>
          <target state="translated">&lt;code&gt;{:alias_reference, meta, module}&lt;/code&gt; -在代码中存在别名时（即用户在代码中写入 &lt;code&gt;MyModule.Foo.Bar&lt;/code&gt; 时）进行跟踪，无论是否扩展。</target>
        </trans-unit>
        <trans-unit id="d2ed0adc88ae3ddaebc212331dcf48c5613f80ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:case_finished, test_module}&lt;/code&gt; - a test module has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:case_finished, test_module}&lt;/code&gt; -测试模块已完成。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cfe221b7da4019de03a758ec67212053a813890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:case_started, test_module}&lt;/code&gt; - a test module has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:case_started, test_module}&lt;/code&gt; -测试模块已启动。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc109206f208d54c435135b2ed115830f37e260b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:compile, modules, warnings}&lt;/code&gt; - to continue compilation with a list of further modules to compile</source>
          <target state="translated">&lt;code&gt;{:compile, modules, warnings}&lt;/code&gt; -继续编译并列出其他要编译的模块</target>
        </trans-unit>
        <trans-unit id="9cf15a4b4877415b55cb1833700221f7d6ae839d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:compile_env, app, path, return}&lt;/code&gt; - traced whenever &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/3&quot;&gt;&lt;code&gt;Application.compile_env/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env!/2&quot;&gt;&lt;code&gt;Application.compile_env!/2&lt;/code&gt;&lt;/a&gt; are called. &lt;code&gt;app&lt;/code&gt; is an atom, &lt;code&gt;path&lt;/code&gt; is a list of keys to traverse in the application environment and &lt;code&gt;return&lt;/code&gt; is either &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:compile_env, app, path, return}&lt;/code&gt; -每当调用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/3&quot;&gt; &lt;code&gt;Application.compile_env/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env!/2&quot;&gt; &lt;code&gt;Application.compile_env!/2&lt;/code&gt; 时&lt;/a&gt;都进行跟踪。 &lt;code&gt;app&lt;/code&gt; 是一个原子， &lt;code&gt;path&lt;/code&gt; 是在应用程序环境中要遍历的键的列表， &lt;code&gt;return&lt;/code&gt; 是 &lt;code&gt;{:ok, value}&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4a7ed7743b808212846bc29e7788b55113c253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:cont, acc}&lt;/code&gt; to continue the reduction with &lt;code&gt;acc&lt;/code&gt; as the new accumulator or</source>
          <target state="translated">&lt;code&gt;{:cont, acc}&lt;/code&gt; 继续使用 &lt;code&gt;acc&lt;/code&gt; 作为新累加器进行折减，或者</target>
        </trans-unit>
        <trans-unit id="d680d1ab4f34debbf293fabb4c907ec127e5d9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - other (rare) error condition; for instance, &lt;code&gt;{:error, :estale}&lt;/code&gt; if reading from an NFS volume</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -其他（罕见）错误情况；例如，如果从NFS卷读取，则 &lt;code&gt;{:error, :estale}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="583a02e135d23d6e385e3fd6dec1ef2ebace7264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - the file could not be opened.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -无法打开文件。</target>
        </trans-unit>
        <trans-unit id="4b6d8de35ac50e9117049f505f7b0ce980f3a49c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, rest}&lt;/code&gt; - there are no switches at the head of the given &lt;code&gt;argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:error, rest}&lt;/code&gt; -给定 &lt;code&gt;argv&lt;/code&gt; 的开头没有开关</target>
        </trans-unit>
        <trans-unit id="905947e36e510a423fa76acaab54776f74a95e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has died</source>
          <target state="translated">&lt;code&gt;{:exit, reason}&lt;/code&gt; 如果任务已终止</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; -如果由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而将应用程序分发并在当前节点上启动，并且应用程序规范键 &lt;code&gt;:start_phases&lt;/code&gt; 不是 &lt;code&gt;:undefined&lt;/code&gt; 时使用。</target>
        </trans-unit>
        <trans-unit id="6493ada3691c289f4563082f5504570c40c851bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; - accesses file descriptors, &lt;code&gt;fd_in&lt;/code&gt; and &lt;code&gt;fd_out&lt;/code&gt; opened by the VM.</source>
          <target state="translated">&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; -访问由VM打开的文件描述符 &lt;code&gt;fd_in&lt;/code&gt; 和 &lt;code&gt;fd_out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14377d50e215463748eff219d9c02d214d948fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; - the GenServer is registered globally with the given term using the functions in the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; -GenServer使用&lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 模块中&lt;/a&gt;的功能在给定的术语下全局注册。</target>
        </trans-unit>
        <trans-unit id="53c120865859b22092af466d2b931e7ac0b771c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; if the server is globally registered</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; 如果服务器已全局注册）</target>
        </trans-unit>
        <trans-unit id="ef45711b970d4f5ebbd374f8b94ce469f1caf938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:halt, acc}&lt;/code&gt; to halt the reduction</source>
          <target state="translated">&lt;code&gt;{:halt, acc}&lt;/code&gt; 停止减少</target>
        </trans-unit>
        <trans-unit id="06e121f623dc4144b41238906f22fa65a8ff1bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:import, meta, module, opts}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt; is imported. &lt;code&gt;meta&lt;/code&gt; is the import AST metadata and &lt;code&gt;opts&lt;/code&gt; are the import options.</source>
          <target state="translated">&lt;code&gt;{:import, meta, module, opts}&lt;/code&gt; -每次导入 &lt;code&gt;module&lt;/code&gt; 都进行跟踪。 &lt;code&gt;meta&lt;/code&gt; 是导入的AST元数据，而 &lt;code&gt;opts&lt;/code&gt; 是导入选项。</target>
        </trans-unit>
        <trans-unit id="38709f8fda71690dafe2be34764221212b52066c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:imported_function, meta, module, name, arity}&lt;/code&gt; and &lt;code&gt;{:imported_macro, meta, module, name, arity}&lt;/code&gt; - traced whenever an imported function or macro is invoked. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, &lt;code&gt;module&lt;/code&gt; is the module the import is from, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt; of the imported function/macro.</source>
          <target state="translated">&lt;code&gt;{:imported_function, meta, module, name, arity}&lt;/code&gt; 和 &lt;code&gt;{:imported_macro, meta, module, name, arity}&lt;/code&gt; -每当调用导入的函数或宏时，都将进行跟踪。 &lt;code&gt;meta&lt;/code&gt; 是呼叫AST元， &lt;code&gt;module&lt;/code&gt; 是模块的进口是从，其次是 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;arity&lt;/code&gt; 输入函数/宏。</target>
        </trans-unit>
        <trans-unit id="df2e65d7200b3a773f87421feb6af3b00afa9729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is invalid with &lt;code&gt;value&lt;/code&gt; (returned when the value cannot be parsed according to the switch type)</source>
          <target state="translated">&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; -选项 &lt;code&gt;key&lt;/code&gt; 对 &lt;code&gt;value&lt;/code&gt; 无效（当无法根据开关类型解析值时返回）</target>
        </trans-unit>
        <trans-unit id="d22ea9a831b4e750f4a7deb2f6398228dd603aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:local_function, meta, name, arity}&lt;/code&gt; and &lt;code&gt;{:local_macro, meta, name, arity}&lt;/code&gt; - traced whenever a local function or macro is referenced. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:local_function, meta, name, arity}&lt;/code&gt; 和 &lt;code&gt;{:local_macro, meta, name, arity}&lt;/code&gt; -每当引用本地函数或宏时都将进行跟踪。 &lt;code&gt;meta&lt;/code&gt; 是调用AST元数据，后跟 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;arity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d9e4ebeed749539e0779650148edbda53e98c0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:module_finished, test_module}&lt;/code&gt; - a test module has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:module_finished, test_module}&lt;/code&gt; -测试模块已完成。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="336e80413658853e833a1e7e92e6610ddd62c9d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:module_started, test_module}&lt;/code&gt; - a test module has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:module_started, test_module}&lt;/code&gt; -测试模块已启动。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70b5edb9ec5c74f3f67332fddbfa4c82e88ce245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; - if the message translation with its metadata</source>
          <target state="translated">&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; -如果消息翻译有其元数据</target>
        </trans-unit>
        <trans-unit id="996ab638f8c8d4d802e499bedf1f4770ab7fbb80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata}&lt;/code&gt; - the translated message</source>
          <target state="translated">&lt;code&gt;{:ok, chardata}&lt;/code&gt; -翻译后的消息</target>
        </trans-unit>
        <trans-unit id="e3a6f52fcc50382042712f66d3261d0c08067f8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, io_device}&lt;/code&gt; - the file has been opened in the requested mode.</source>
          <target state="translated">&lt;code&gt;{:ok, io_device}&lt;/code&gt; -文件已以请求的模式打开。</target>
        </trans-unit>
        <trans-unit id="a0b6d7c9a83237db145690056b0e8a37a74e66c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; was successfully parsed</source>
          <target state="translated">&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - 具有 &lt;code&gt;value&lt;/code&gt; 的选项 &lt;code&gt;key&lt;/code&gt; 已成功解析</target>
        </trans-unit>
        <trans-unit id="7268c1f7f90baff55c1875a554395341ede463ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, term}&lt;/code&gt; if the task has successfully reported its result back in the given time interval</source>
          <target state="translated">&lt;code&gt;{:ok, term}&lt;/code&gt; 如果任务已在给定的时间间隔内成功报告了其结果</target>
        </trans-unit>
        <trans-unit id="5a0025dce43d3ec421b2a7d6b5d906ef9dfeda7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:remote_function, meta, module, name, arity}&lt;/code&gt; and &lt;code&gt;{:remote_macro, meta, module, name, arity}&lt;/code&gt; - traced whenever a remote function or macro is referenced. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, &lt;code&gt;module&lt;/code&gt; is the invoked module, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:remote_function, meta, module, name, arity}&lt;/code&gt; 和 &lt;code&gt;{:remote_macro, meta, module, name, arity}&lt;/code&gt; -每当引用远程函数或宏时都将跟踪。 &lt;code&gt;meta&lt;/code&gt; 是调用AST元数据， &lt;code&gt;module&lt;/code&gt; 是调用的模块，后跟 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;arity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4907bf582e669d083cd73a78fa6927d7145e6417" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:require, meta, module, opts}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt; is required. &lt;code&gt;meta&lt;/code&gt; is the require AST metadata and &lt;code&gt;opts&lt;/code&gt; are the require options.</source>
          <target state="translated">&lt;code&gt;{:require, meta, module, opts}&lt;/code&gt; -在需要 &lt;code&gt;module&lt;/code&gt; 跟踪。 &lt;code&gt;meta&lt;/code&gt; 是require AST元数据，而 &lt;code&gt;opts&lt;/code&gt; 是require选项。</target>
        </trans-unit>
        <trans-unit id="ff00c961233a1e2c73ed6d683a2899cff9a55847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:runtime, modules, warnings}&lt;/code&gt; - to stop compilation and verify the list of modules because dependent modules have changed</source>
          <target state="translated">&lt;code&gt;{:runtime, modules, warnings}&lt;/code&gt; -停止编译并验证模块列表，因为相关模块已更改</target>
        </trans-unit>
        <trans-unit id="15f17eecf5beefa66ca856a267346c5b572581dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn, command}&lt;/code&gt; - runs an external program. &lt;code&gt;command&lt;/code&gt; must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option.</source>
          <target state="translated">&lt;code&gt;{:spawn, command}&lt;/code&gt; -运行一个外部程序。 &lt;code&gt;command&lt;/code&gt; 必须包含程序名称以及（可选）由空格分隔的参数列表。如果传递名称中带有空格的程序或参数，请使用下一个选项。</target>
        </trans-unit>
        <trans-unit id="d6ebca30f0cc1777601d5fcf5ac5189ec02cece8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; - spawns so-called port drivers.</source>
          <target state="translated">&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; -产生所谓的端口驱动程序。</target>
        </trans-unit>
        <trans-unit id="66e3057e6196a07aafd175143d071fd417be195c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; - runs the executable given by the absolute file name &lt;code&gt;filename&lt;/code&gt;. Arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; -运行绝对文件名 &lt;code&gt;filename&lt;/code&gt; 给出的可执行文件。可以通过 &lt;code&gt;:args&lt;/code&gt; 选项传递参数。</target>
        </trans-unit>
        <trans-unit id="be94e236baf94b78cb30d77bbb4ebd4da68c9b56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:struct_expansion, meta, module, keys}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt;'s struct is expanded. &lt;code&gt;meta&lt;/code&gt; is the struct AST metadata and &lt;code&gt;keys&lt;/code&gt; are the keys being used by expansion</source>
          <target state="translated">&lt;code&gt;{:struct_expansion, meta, module, keys}&lt;/code&gt; &amp;ndash;每次扩展 &lt;code&gt;module&lt;/code&gt; 的结构时都将跟踪。 &lt;code&gt;meta&lt;/code&gt; 是结构AST元数据，而 &lt;code&gt;keys&lt;/code&gt; 是扩展使用的键</target>
        </trans-unit>
        <trans-unit id="d1386d6f87a3f87789d9b775ccc84560bf0eae35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:suite_finished, run_us, load_us}&lt;/code&gt; - the suite has finished. &lt;code&gt;run_us&lt;/code&gt; and &lt;code&gt;load_us&lt;/code&gt; are the run and load times in microseconds respectively.</source>
          <target state="translated">&lt;code&gt;{:suite_finished, run_us, load_us}&lt;/code&gt; -套件已完成。 &lt;code&gt;run_us&lt;/code&gt; 和 &lt;code&gt;load_us&lt;/code&gt; 分别是运行时间和加载时间（以微秒为单位）。</target>
        </trans-unit>
        <trans-unit id="a6e2e6cee0edee1861330cc7bd688a9ea27b8c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:suite_started, opts}&lt;/code&gt; - the suite has started with the specified options to the runner.</source>
          <target state="translated">&lt;code&gt;{:suite_started, opts}&lt;/code&gt; -套件已开始向跑步者指定选项。</target>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -如果应用程序是分布式的，并且由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而在当前节点上启动，则使用它。</target>
        </trans-unit>
        <trans-unit id="20e4bddf70360e9ac231b1938a4cb8644bf0a079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:test_finished, test}&lt;/code&gt; - a test has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:test_finished, test}&lt;/code&gt; -测试已完成。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33cd63400c35c42b44de188a407ed8bc57ab11fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:test_started, test}&lt;/code&gt; - a test has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:test_started, test}&lt;/code&gt; -测试已经开始。有关详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26b97b81c2506b473edb7172c2f617dcec5b26d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms)</source>
          <target state="translated">&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; -选项 &lt;code&gt;key&lt;/code&gt; 是不确定的（当开关未知或原子不存在时，以严格模式返回）</target>
        </trans-unit>
        <trans-unit id="85bdb5005d451e7a63cf262238f500974e283030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, name}&lt;/code&gt; if the server is registered through an alternative registry</source>
          <target state="translated">&lt;code&gt;{:via, module, name}&lt;/code&gt; 如果通过备用注册表注册了服务器）</target>
        </trans-unit>
        <trans-unit id="c5d0cf1ea956f6839d57a4b353eb908c39c5c01c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer已使用给定的机制和名称进行注册。的 &lt;code&gt;:via&lt;/code&gt; 选项期望的模块，出口 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; 和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt;。一个这样的例子是&lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 模块&lt;/a&gt;，它使用这些功能来保存进程名称及其关联的PID的列表，这些列表可全局用于Elixir节点的网络。Elixir还附带了一个名为&lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;的本地，分散和可扩展的注册表，用于本地存储动态生成的名称。</target>
        </trans-unit>
        <trans-unit id="8b29339dcb62621d0d8075c996c9fab09ff31622" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer已使用给定的机制和名称进行注册。的 &lt;code&gt;:via&lt;/code&gt; 选项期望的模块，出口 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; 和&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt;。一个这样的例子是&lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 模块&lt;/a&gt;，它使用这些功能来保存进程名称及其关联的PID的列表，这些列表可全局用于Elixir节点的网络。Elixir还附带了一个名为&lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;的本地，分散和可扩展的注册表，用于本地存储动态生成的名称。</target>
        </trans-unit>
        <trans-unit id="cc2c818f59492934d15abff13439c0782289f3e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c6157992132973e0f3d822fb7bbb7d409431fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; is a tuple containing information about the logged message:</source>
          <target state="translated">&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; 是一个元组，其中包含有关所记录消息的信息：</target>
        </trans-unit>
        <trans-unit id="db1f5193dbaaf9fec82f82738b42e72b2810c7d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{atom, node}&lt;/code&gt; if the server is locally registered at another node</source>
          <target state="translated">&lt;code&gt;{atom, node}&lt;/code&gt; 如果服务器在另一节点本地注册）</target>
        </trans-unit>
        <trans-unit id="2d5e8a342d00497e80fb0e1378891350b6989d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{item1,item2,...}&lt;/code&gt; - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;{item1,item2,...}&lt;/code&gt; -匹配替代项之一。请勿在逗号前后添加空格，否则会匹配包含空格字符本身的路径。</target>
        </trans-unit>
        <trans-unit id="a7691a8a9c5c0f0c080c5918b2771046501cab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{level, group_leader, {Logger, message, timestamp, metadata}}&lt;/code&gt; where:</source>
          <target state="translated">&lt;code&gt;{level, group_leader, {Logger, message, timestamp, metadata}}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="ac157d52ecf1d75482d9d1aeecc889281122e50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, :close}&lt;/code&gt; - closes the port. Unless the port is already closed, the port will reply with &lt;code&gt;{port, :closed}&lt;/code&gt; message once it has flushed its buffers and effectively closed. See &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, :close}&lt;/code&gt; -关闭端口。除非端口已经关闭，否则端口将在刷新缓冲区并有效关闭后以 &lt;code&gt;{port, :closed}&lt;/code&gt; 消息进行回复。参见&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a895632430cc7c653dfc0e0b7e07abf543b5e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; - sends the given data to the port. See &lt;a href=&quot;#command/3&quot;&gt;&lt;code&gt;command/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; -将给定的数据发送到端口。参见&lt;a href=&quot;#command/3&quot;&gt; &lt;code&gt;command/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288f6592e3c497e594f8671f3ea30d712d05da67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - sets the &lt;code&gt;new_pid&lt;/code&gt; as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes &lt;code&gt;new_pid&lt;/code&gt; the new connected processes. Unless the port is dead, the port will reply to the old owner with &lt;code&gt;{port, :connected}&lt;/code&gt;. See &lt;a href=&quot;#connect/2&quot;&gt;&lt;code&gt;connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; -将 &lt;code&gt;new_pid&lt;/code&gt; 设置为端口的新所有者。打开端口后，该端口将链接并连接到呼叫者进程，并且仅通过连接的进程与该端口进行通信。此消息使 &lt;code&gt;new_pid&lt;/code&gt; 成为新连接的进程。除非端口失效，否则端口将通过 &lt;code&gt;{port, :connected}&lt;/code&gt; 回复旧所有者。参见&lt;a href=&quot;#connect/2&quot;&gt; &lt;code&gt;connect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e874c9f986bcbc4835de87b79c60801c982748f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :closed}&lt;/code&gt; - reply to the &lt;code&gt;{pid, :close}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :closed}&lt;/code&gt; -回复 &lt;code&gt;{pid, :close}&lt;/code&gt; 消息</target>
        </trans-unit>
        <trans-unit id="fa93e43d244395859c46aade03423cd222f87032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :connected}&lt;/code&gt; - reply to the &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :connected}&lt;/code&gt; -回复 &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; 消息</target>
        </trans-unit>
        <trans-unit id="efc9c7697827d4669aad3228ed4c07741bb10c50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, {:data, data}}&lt;/code&gt; - data sent by the port</source>
          <target state="translated">&lt;code&gt;{port, {:data, data}}&lt;/code&gt; -端口发送的数据</target>
        </trans-unit>
        <trans-unit id="8331cbf97282804d067bb29ba8bd9b7caf6144bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a1fc7b83a3791c9f16933b021a993fc251a976d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c515caea553b7a18b81d363c568a315a5150f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="036d3dd0689aaa1e1f2cd3395422e4acf8dcaf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&amp;gt;&lt;/code&gt; will never include pre-release versions of its upper bound, regardless of the usage of the &lt;code&gt;:allow_pre&lt;/code&gt; option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for &lt;code&gt;~&amp;gt;&lt;/code&gt; requirements and their corresponding translations.</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; 永远不会包含其上限的预发行版本，无论 &lt;code&gt;:allow_pre&lt;/code&gt; 选项的用法如何，还是操作数是否为预发行版本。它也可以用于仅在主要版本部分上设置上限。请参阅下表以了解 &lt;code&gt;~&amp;gt;&lt;/code&gt; 要求及其相应的翻译。</target>
        </trans-unit>
        <trans-unit id="d3a808d1b26854bfff9e3a0b3845ea1a05448e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e23e262f305f153040f0582095898a4190393fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09579eaf4feb9e28fce9fc17746e4ff55890bca0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;None&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;None&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d79e4e6ea4fe26e44ae09fe2933d731631027ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: unlike &lt;code&gt;@after_compile&lt;/code&gt;, the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist).</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：与 &lt;code&gt;@after_compile&lt;/code&gt; 不同，回调函数/宏必须放在单独的模块中（因为调用回调时，当前模块尚不存在）。</target>
        </trans-unit>
        <trans-unit id="4f08c9a12c9ca68459deea27c07cfa5cbf312698" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The leading underscore in &lt;code&gt;_sep&lt;/code&gt; means that the variable will be ignored in this function; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;_sep&lt;/code&gt; 中的下划线表示该函数将忽略该变量；请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;命名约定&lt;/a&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d76d0c90116afc56a7d7c36ee9aa1c61ab7189e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The trailing question mark in &lt;code&gt;zero?&lt;/code&gt; means that this function returns a boolean; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;尾随问号 &lt;code&gt;zero?&lt;/code&gt; 表示此函数返回一个布尔值；请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;命名约定&lt;/a&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64b3259a23cbcee4b6f5269de5bf892f183bee1a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API Reference</source>
          <target state="translated">&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API参考</target>
        </trans-unit>
        <trans-unit id="ecdafb6979a08deb1f64b585c6ae8d1c3aad60c6" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Getting Started&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;入门&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b4788aa3df60b3245cde2a89f8ad4433addb6e87" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Meta-programming in Elixir&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Elixir中的元编程&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5989ccc62afedfde6898bb6ed0007714bf2b045b" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Mix and OTP&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;混合和OTP&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3775fefac93bd98a436d0d00b0aab5a204bb7bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a test-unit based framework that ships with Elixir;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;是Elixir附带的基于测试单元的框架；</target>
        </trans-unit>
        <trans-unit id="79fc31f88ea6f7006047293577c94843734d6c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;是Elixir随附的构建工具，它提供创建，编译，测试应用程序，管理依赖项等任务。</target>
        </trans-unit>
        <trans-unit id="7760e740159ba1e4a18006d398566be346370d1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;(Open Telecom Platform)&lt;/em&gt; is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;（开放电信平台）&lt;/em&gt;是Erlang附带的一组库。Erlang开发人员使用OTP来构建强大的容错应用程序。在本章中，我们将探讨OTP与Elixir集成的方面，包括监督树，事件管理器等等。</target>
        </trans-unit>
        <trans-unit id="88c0e166c78e581a32cc00488db4dd2a2485ff1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A binary is a bitstring where the number of bits is divisible by 8.&lt;/strong&gt; That means that every binary is a bitstring, but not every bitstring is a binary. We can use the &lt;code&gt;is_bitstring/1&lt;/code&gt; and &lt;code&gt;is_binary/1&lt;/code&gt; functions to demonstrate this.</source>
          <target state="translated">&lt;strong&gt;二进制是一个位串，其中位数可以被8整除。&lt;/strong&gt;这意味着每个二进制都是位串，但并非每个位串都是二进制。我们可以使用 &lt;code&gt;is_bitstring/1&lt;/code&gt; 和 &lt;code&gt;is_binary/1&lt;/code&gt; 函数进行演示。</target>
        </trans-unit>
        <trans-unit id="336831bc9d7d14d606049e8d100d4d10f2fcd283" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A charlist is a list of integers where all the integers are valid code points.&lt;/strong&gt; In practice, you will not come across them often, except perhaps when interfacing with Erlang, in particular when using older libraries that do not accept binaries as arguments.</source>
          <target state="translated">&lt;strong&gt;字符列表是整数列表，其中所有整数都是有效代码点。&lt;/strong&gt;在实践中，除非与Erlang进行交互，尤其是在使用不接受二进制文件作为参数的较早的库时，否则不会经常遇到它们。</target>
        </trans-unit>
        <trans-unit id="e636b218c0e3e0b13d91ec18a5e99e58de43d704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A string is a UTF-8 encoded binary&lt;/strong&gt;, where the code point for each character is encoded using 1 to 4 bytes. Thus every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string.</source>
          <target state="translated">&lt;strong&gt;字符串是UTF-8编码的二进制文件&lt;/strong&gt;，其中每个字符的代码点使用1到4个字节进行编码。因此，每个字符串都是二进制，但是由于UTF-8标准编码规则，并非每个二进制都是有效字符串。</target>
        </trans-unit>
        <trans-unit id="08113db7fca81fb8e42233f3eb8aa29c2802e31c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see &lt;a href=&quot;#compile_env!/2&quot;&gt;&lt;code&gt;compile_env!/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;例如，如果您在编译时正在读取应用程序环境，例如，在模块定义内部而不是函数内部，请参阅&lt;a href=&quot;#compile_env!/2&quot;&gt; &lt;code&gt;compile_env!/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a738399c9df445c8f274660ea67228dc4666ce43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;例如，如果在编译时正在读取应用程序环境，例如，在模块定义内部而不是函数内部，请参阅&lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45bdb2bd826dc57156f3bf24a36a9c22bb6b679a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our &lt;a href=&quot;library-guidelines&quot;&gt;library guidelines&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;如果要编写供其他开发人员使用的库，通常建议避免使用应用程序环境，因为该应用程序环境实际上是全局存储。有关更多信息，请阅读我们的&lt;a href=&quot;library-guidelines&quot;&gt;磁带库指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cebf98b4bce979e6d8b77444f797642d0aeb4c22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: in Elixir, you don&amp;rsquo;t have to define the &lt;code&gt;Foo&lt;/code&gt; module before being able to define the &lt;code&gt;Foo.Bar&lt;/code&gt; module, as the language translates all module names to atoms. You can define arbitrarily-nested modules without defining any module in the chain (e.g., &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; without defining &lt;code&gt;Foo&lt;/code&gt; or &lt;code&gt;Foo.Bar&lt;/code&gt; first).</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在Elixir中，无需定义 &lt;code&gt;Foo&lt;/code&gt; 模块即可定义 &lt;code&gt;Foo.Bar&lt;/code&gt; 模块，因为该语言会将所有模块名称转换为atom。您可以定义任意嵌套的模块，而无需定义链中的任何模块（例如， &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; ,而无需先定义 &lt;code&gt;Foo&lt;/code&gt; 或 &lt;code&gt;Foo.Bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4830045d3f9fb785bdafea364ad01a0303638b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this function must be used only for debugging purposes.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此功能只能用于调试目的。</target>
        </trans-unit>
        <trans-unit id="f5c1f94fbf601c6ec501544925ca954903163e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this function with extreme care&lt;/strong&gt;. For almost all situations where you would use &lt;a href=&quot;#sleep/1&quot;&gt;&lt;code&gt;sleep/1&lt;/code&gt;&lt;/a&gt; in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing.</source>
          <target state="translated">&lt;strong&gt;请格外小心地使用此功能&lt;/strong&gt;。对于几乎所有在Elixir中使用&lt;a href=&quot;#sleep/1&quot;&gt; &lt;code&gt;sleep/1&lt;/code&gt; 的&lt;/a&gt;情况，都可能有更正确，更快和更精确的方式来通过消息传递实现相同的目的。</target>
        </trans-unit>
        <trans-unit id="aac3b6f8e5ab64ac8a9b9ba5343d9c93a85c8ca8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;每次调用此函数时，都会打开一个文件描述符，并产生一个新进程来写入文件。因此，如果您要在循环中进行多次写入，则通过&lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt;打开文件并使用&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 中&lt;/a&gt;的函数写入文件将比多次调用此函数产生更好的性能。</target>
        </trans-unit>
        <trans-unit id="6d8fa24c5f50dfc16b2c10bf309baf5a47726342" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;file#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;每次调用此函数时，都会打开文件描述符，并产生一个新进程来写入文件。因此，如果您要在循环中进行多次写入，则通过&lt;a href=&quot;file#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt;打开文件并使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 中&lt;/a&gt;的函数写入文件将比多次调用此函数产生更好的性能。</target>
        </trans-unit>
        <trans-unit id="365ce4331359866dc083be4a975f43b82fadac5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#compile_string/2&quot;&gt;&lt;code&gt;compile_string/2&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;string&lt;/code&gt; 可以是任何Elixir代码，并且可以与Erlang VM相同的特权执行代码：这意味着此类代码可能会危害计算机（例如，通过执行系统命令）。不要将&lt;a href=&quot;#compile_string/2&quot;&gt; &lt;code&gt;compile_string/2&lt;/code&gt; &lt;/a&gt;与不受信任的输入（例如来自网络的字符串）一起使用。</target>
        </trans-unit>
        <trans-unit id="9a9945569acc699104fbc382a7f6902cdbb849ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;string&lt;/code&gt; 可以是任何Elixir代码，并且将以与Erlang VM相同的特权执行：这意味着此类代码可能会危害计算机（例如，通过执行系统命令）。不要将&lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt;与不受信任的输入（例如来自网络的字符串）一起使用。</target>
        </trans-unit>
        <trans-unit id="2875bd2bb7c9486ad98cafa18ea844a4e68bfa0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：在宏内调用此函数被认为是不好的做法，因为它将尝试在编译时评估运行时值。宏参数通常通过将其取消引用到返回的带引号的表达式中（而不是被评估的）来转换。</target>
        </trans-unit>
        <trans-unit id="993e7a2f2e8a8af096a402bf2629008a4fb49467" translate="yes" xml:space="preserve">
          <source>= (2)</source>
          <target state="translated">=（2）</target>
        </trans-unit>
        <trans-unit id="070f4bb5062b181b2dab5baebd4e926e8227b544" translate="yes" xml:space="preserve">
          <source>== (2)</source>
          <target state="translated">==（2）</target>
        </trans-unit>
        <trans-unit id="80782192fde18010086342ec452afa4a2968c387" translate="yes" xml:space="preserve">
          <source>=== (2)</source>
          <target state="translated">===（2）</target>
        </trans-unit>
        <trans-unit id="7d042330e275b9df07c1b99a60576379d66570eb" translate="yes" xml:space="preserve">
          <source>=~ (2)</source>
          <target state="translated">=〜（2）</target>
        </trans-unit>
        <trans-unit id="3ac5ef8377daeb708c25b635e6c467ff0bfcb4e4" translate="yes" xml:space="preserve">
          <source>@expr</source>
          <target state="translated">@expr</target>
        </trans-unit>
        <trans-unit id="3fb5c30970be466c24df6f91f050369f404a45eb" translate="yes" xml:space="preserve">
          <source>@expr (1)</source>
          <target state="translated">@expr（1）</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="212381917bbc6314dd3515bae3faeae224b2edde" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use GenServer&lt;/code&gt;, it automatically defines a &lt;code&gt;child_spec/1&lt;/code&gt; function that allows us to start the &lt;code&gt;Stack&lt;/code&gt; directly under a supervisor. To start a default stack of &lt;code&gt;[:hello]&lt;/code&gt; under a supervisor, one may do:</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;被监督树底下最常见的开始。当我们 &lt;code&gt;use GenServer&lt;/code&gt; 调用时，它会自动定义 &lt;code&gt;child_spec/1&lt;/code&gt; 函数，该函数使我们可以直接在管理程序下启动 &lt;code&gt;Stack&lt;/code&gt; 。要在主管下启动默认的 &lt;code&gt;[:hello]&lt;/code&gt; 堆栈，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b04250c280e3b81f91e1d5dd337c0df8de26b240" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is represented internally using the &lt;code&gt;%MapSet{}&lt;/code&gt; struct. This struct can be used whenever there's a need to pattern match on something being a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;使用内部表示 &lt;code&gt;%MapSet{}&lt;/code&gt; 结构。每当需要在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;上进行模式匹配时，都可以使用此结构：</target>
        </trans-unit>
        <trans-unit id="5592a96e74b3dea455cad3a6cdcc2a71d33e7e9c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; 的&lt;/a&gt;IO设备可以作为&amp;ldquo;设备&amp;rdquo;到在大部分功能被传递&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="96991deff4ed5a082a254d0673af19964e04b750" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; 的&lt;/a&gt; IO设备可以作为&amp;ldquo;设备&amp;rdquo;到在大部分功能被传递&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="11c30e3595630fd2ed85f755977f5e0806af282c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;被绑定到相同的名称注册规则作为&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中了解有关它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="b2e4d521318bcdf190d785d923c77a3515720622" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;被绑定到相同的名称注册规则作为&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中了解有关它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="55645d6c06d3271f36e9be3f5d20e93cd6d7aa12" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;结构返回一个包含相关信息。开发人员必须最终调用&lt;a href=&quot;#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt;，然后&lt;a href=&quot;#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;上返回的任务。</target>
        </trans-unit>
        <trans-unit id="04a844239e65727f5eb23023aa50bf8c3c86fe4c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;task#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;结构返回一个包含相关信息。开发人员必须最终调用&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;task#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt;，然后&lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;上返回的任务。</target>
        </trans-unit>
        <trans-unit id="c99b78808a672297ddd7132ed2c68ad7b242b61f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;%Date{}&lt;/a&gt; struct contains the fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, and &lt;code&gt;calendar&lt;/code&gt;. You can create one using the &lt;code&gt;~D&lt;/code&gt; sigil:</source>
          <target state="translated">一&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;％日期{}&lt;/a&gt;结构包含字段 &lt;code&gt;year&lt;/code&gt; ， &lt;code&gt;month&lt;/code&gt; ， &lt;code&gt;day&lt;/code&gt; 和 &lt;code&gt;calendar&lt;/code&gt; 。您可以使用创建一个 &lt;code&gt;~D&lt;/code&gt; 印记：</target>
        </trans-unit>
        <trans-unit id="ca463d32e6d6ecf67f11f02d3da51e0794706014" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;%DateTime{}&lt;/a&gt; struct contains the same fields as a &lt;code&gt;NaiveDateTime&lt;/code&gt; with the addition of fields to track timezones. The &lt;code&gt;~U&lt;/code&gt; sigil allows developers to create a DateTime in the UTC timezone:</source>
          <target state="translated">甲&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;％的DateTime {}&lt;/a&gt;结构体包含相同的字段作为 &lt;code&gt;NaiveDateTime&lt;/code&gt; 通过添加字段来跟踪时区。在 &lt;code&gt;~U&lt;/code&gt; 印记允许开发人员创建的UTC时区一个DateTime：</target>
        </trans-unit>
        <trans-unit id="9a8c365525108d9b02bcf9ac0efff934b78be9b7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--module&lt;/code&gt; option can be given in order to name the modules in the generated code skeleton.</source>
          <target state="translated">甲 &lt;code&gt;--module&lt;/code&gt; 选项可以以命名在生成的代码骨架的模块进行说明。</target>
        </trans-unit>
        <trans-unit id="93ae153a76bb9eaf92dda3893cc5ead4482398e3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--sup&lt;/code&gt; option can be given to generate an OTP application skeleton including a supervision tree. Normally an app is generated without a supervisor and without the app callback.</source>
          <target state="translated">一个 &lt;code&gt;--sup&lt;/code&gt; 可以给出选项生成的骨架，包括监督树的OTP应用。通常，在没有主管和没有应用程序回调的情况下生成应用程序。</target>
        </trans-unit>
        <trans-unit id="6b893cfed0032b8cee12fcb9d4b611446984d618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:name&lt;/code&gt; option could also be given to &lt;code&gt;Agent.start_link/2&lt;/code&gt; and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called &lt;code&gt;GenServer&lt;/code&gt;), tasks, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt; which will build a complete Elixir application from start to finish.</source>
          <target state="translated">也可以将 &lt;code&gt;:name&lt;/code&gt; 选项提供给 &lt;code&gt;Agent.start_link/2&lt;/code&gt; 并将其自动注册。除代理程序外，Elixir还提供了一个API，用于构建通用服务器（称为 &lt;code&gt;GenServer&lt;/code&gt; ），任务等，所有这些均由下面的进程提供支持。这些以及监督树将在&lt;strong&gt;&lt;em&gt;Mix and OTP指南中&lt;/em&gt;&lt;/strong&gt;进行更详细的探讨，该&lt;strong&gt;&lt;em&gt;指南&lt;/em&gt;&lt;/strong&gt;将从头到尾构建一个完整的Elixir应用程序。</target>
        </trans-unit>
        <trans-unit id="e18a4ffc55e5c9028c4e176af5316103f1339b8d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;post_config&lt;/code&gt; can be passed that will be merged into the project configuration.</source>
          <target state="translated">一个 &lt;code&gt;post_config&lt;/code&gt; 可以通过将被合并到项目配置。</target>
        </trans-unit>
        <trans-unit id="953f85d383aa733b4232421e096ff53630a36ae0" translate="yes" xml:space="preserve">
          <source>A Date struct and functions.</source>
          <target state="translated">一个Date结构和功能。</target>
        </trans-unit>
        <trans-unit id="41bff3f5550cc14457144dffbdae442d3deffbd2" translate="yes" xml:space="preserve">
          <source>A GUI should pop-up containing all sorts of information about our system, from general statistics to load charts as well as a list of all running processes and applications.</source>
          <target state="translated">一个GUI应该弹出,包含所有关于我们系统的信息,从一般的统计数据到加载图表,以及所有正在运行的进程和应用程序的列表。</target>
        </trans-unit>
        <trans-unit id="ce30e5498af53503d24e931e06501bf314a92d8d" translate="yes" xml:space="preserve">
          <source>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</source>
          <target state="translated">GenServer和其他Elixir进程一样是一个进程,它可以用来保持状态,异步执行代码等。使用本模块实现的通用服务器进程(GenServer)的优势在于,它将拥有一套标准的接口函数,并包含跟踪和错误报告的功能。它也将适合于监督树。</target>
        </trans-unit>
        <trans-unit id="e1d021610e2e2d5fff8dcc8068b986d35f87da19" translate="yes" xml:space="preserve">
          <source>A GenServer is a process that invokes a limited set of functions under specific conditions. When we used an &lt;code&gt;Agent&lt;/code&gt;, we would keep both the client code and the server code side by side, like this:</source>
          <target state="translated">GenServer是在特定条件下调用一组有限功能的过程。当使用 &lt;code&gt;Agent&lt;/code&gt; 时，我们将同时保留客户端代码和服务器代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="fa09e34f4344d6d1e3072b5dbac5303f17145bcc" translate="yes" xml:space="preserve">
          <source>A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we&amp;rsquo;ll use a single module for both the server callbacks and the client API.</source>
          <target state="translated">GenServer分两部分实现：客户端API和服务器回调。您可以将这两个部分组合成一个模块，也可以将它们分为客户端模块和服务器模块。客户端是调用客户端功能的任何进程。服务器始终是我们将作为参数显式传递给客户端API的进程标识符或进程名称。在这里，我们将对服务器回调和客户端API使用一个模块。</target>
        </trans-unit>
        <trans-unit id="2c3564c401d9bcae5f982375952ba5b0f96579bf" translate="yes" xml:space="preserve">
          <source>A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes.</source>
          <target state="translated">一个GenServer,或一般的进程,必须用来模拟你的系统的运行时特性。GenServer决不能用于代码组织的目的。</target>
        </trans-unit>
        <trans-unit id="6c4080de87ee470f7abb62ce27d54db9157b6efe" translate="yes" xml:space="preserve">
          <source>A Mix compiler task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task.Compiler&lt;/code&gt;&lt;/a&gt; in a module whose name starts with &lt;code&gt;Mix.Tasks.Compile.&lt;/code&gt; and defining the &lt;a href=&quot;#c:run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">只需在名称以 &lt;code&gt;Mix.Tasks.Compile.&lt;/code&gt; 开头的模块中使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task.Compiler&lt;/code&gt; &lt;/a&gt;即可定义Mix编译器任务。并定义&lt;a href=&quot;#c:run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="4c204de36640465711bc67da137f234cf9e4f98d" translate="yes" xml:space="preserve">
          <source>A Mix project is defined by calling &lt;code&gt;use Mix.Project&lt;/code&gt; in a module, usually placed in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">通过在模块中调用 &lt;code&gt;use Mix.Project&lt;/code&gt; 来定义Mix项目，通常将其放置在 &lt;code&gt;mix.exs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="4077ad8fe6f71eae596391489d6e96f0ea24015b" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module starting with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and defining the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">只需在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; s开头&lt;/a&gt;的模块中使用Mix.Task即可定义Mix任务 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 并定义&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="56400b7c36038183acc14a25e0a3549d626f0ddc" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module whose name begins with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and which defines the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function. Typically, task modules live inside the &lt;code&gt;lib/mix/tasks/&lt;/code&gt; directory, and their file names use dot separators instead of underscores (e.g. &lt;code&gt;deps.clean.ex&lt;/code&gt;) - although ultimately the file name is not relevant.</source>
          <target state="translated">可以通过在名称以 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 开头的模块中使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; &lt;/a&gt;来定义Mix任务。并定义了&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数。通常，任务模块位于 &lt;code&gt;lib/mix/tasks/&lt;/code&gt; 目录中，并且它们的文件名使用点分隔符而不是下划线（例如 &lt;code&gt;deps.clean.ex&lt;/code&gt; ）-尽管最终文件名不相关。</target>
        </trans-unit>
        <trans-unit id="ed54926907bf0ba78a3375ef0d22019252f3389e" translate="yes" xml:space="preserve">
          <source>A NaiveDateTime struct (without a time zone) and functions.</source>
          <target state="translated">一个NaiveDateTime结构(没有时区)和函数。</target>
        </trans-unit>
        <trans-unit id="555fb6c5e065889ab4dcadeaa574e32486d7fb5d" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind it is not guaranteed two regular expressions from the same source are equal, for example:</source>
          <target state="translated">正则表达式在内部表示为正则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;结构。因此，只要需要匹配，就可以使用 &lt;code&gt;%Regex{}&lt;/code&gt; 。请记住，不能保证来自同一源的两个正则表达式相等，例如：</target>
        </trans-unit>
        <trans-unit id="5b641f005f95d171d045430ceaf72d4ba2227ac3" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. There is also not guarantee two regular expressions from the same source are equal, for example:</source>
          <target state="translated">正则表达式在内部表示为正则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;结构。因此，只要需要匹配，就可以使用 &lt;code&gt;%Regex{}&lt;/code&gt; 。请记住，所有结构字段都是私有的。也不能保证来自相同源的两个正则表达式相等，例如：</target>
        </trans-unit>
        <trans-unit id="2afaaf5f34eb9535b346406765e25f28777ebcbf" translate="yes" xml:space="preserve">
          <source>A String in Elixir is a UTF-8 encoded binary.</source>
          <target state="translated">Elixir中的字符串是一个UTF-8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="1d40f8897ae8fea751dfe1a3787ebde9eaf60e69" translate="yes" xml:space="preserve">
          <source>A TCP server, in broad strokes, performs the following steps:</source>
          <target state="translated">一个TCP服务器,大体上要执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="9b4c21dfcd9b32e19a4da6bba2ed1b078799abfe" translate="yes" xml:space="preserve">
          <source>A Time struct and functions.</source>
          <target state="translated">A 时间结构和功能。</target>
        </trans-unit>
        <trans-unit id="8ed92df07fe6e75daa797531db7710c5a365538d" translate="yes" xml:space="preserve">
          <source>A UTF-8 code point. It may be one or more bytes.</source>
          <target state="translated">一个UTF-8码点。它可以是一个或多个字节。</target>
        </trans-unit>
        <trans-unit id="d4551e142fcb8c6dfcab6f6c771c1757c5d408c6" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded binary.</source>
          <target state="translated">一个UTF-8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="c6baac594934e18050d15b336369478a962b486d" translate="yes" xml:space="preserve">
          <source>A basic setup for ExUnit is shown below:</source>
          <target state="translated">ExUnit的基本设置如下所示。</target>
        </trans-unit>
        <trans-unit id="d872a4d789410051d4047736ebac85378931dcb1" translate="yes" xml:space="preserve">
          <source>A beginning is inclusive. An ending is exclusive. Eg. if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00, the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00.</source>
          <target state="translated">开始是包容的。结尾是包含性的。例如:如果一个时期是从2015-03-29 01:00:00开始到2015-10-25 01:00:00为止,那么这个时期包括并从2015-03-29 01:00:00开始到2015-10-25 01:00:00之前。</target>
        </trans-unit>
        <trans-unit id="4b46e9949a74e5098958730c1a927a02cf0e1c74" translate="yes" xml:space="preserve">
          <source>A beginning or end for certain periods are infinite. For instance the latest period for time zones without DST or plans to change. However for the purpose of this behaviour they are only used for gaps in wall time where the needed period limits are at a certain time.</source>
          <target state="translated">某些时期的开始或结束是无限的。例如,对于没有DST或计划改变的时区,最新的时期。然而,为了这种行为的目的,它们只用于所需的时期限制在某一时间的墙时间的间隙。</target>
        </trans-unit>
        <trans-unit id="eb34fc850ae56e44c450bb71c054995b2321814e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">行为模块定义了一组函数和宏（称为&lt;em&gt;回调&lt;/em&gt;），实现该行为的回调模块必须将其导出。该&amp;ldquo;接口&amp;rdquo;标识组件的特定部分。例如，&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 的&lt;/a&gt;行为和功能从特定的部分（例如该服务器进程必须执行的动作）中抽象出&amp;ldquo;服务器&amp;rdquo;进程可能希望实现的所有消息传递（发送和接收）和错误报告。</target>
        </trans-unit>
        <trans-unit id="db41558e90a255b03a8dc01169dd1f98b2391f4e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">行为模块定义了实现该行为的回调模块必须导出的一组函数和宏（称为&lt;em&gt;回调&lt;/em&gt;）。该&amp;ldquo;接口&amp;rdquo;标识组件的特定部分。例如，&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 的&lt;/a&gt;行为和功能从特定的部分（例如该服务器进程必须执行的动作）中抽象出&amp;ldquo;服务器&amp;rdquo;进程可能希望实现的所有消息传递（发送和接收）和错误报告。</target>
        </trans-unit>
        <trans-unit id="7c9e867bc2a6fb80d40eab6dcf2caa49046c25ae" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing supervisors.</source>
          <target state="translated">实施监督员的行为模块。</target>
        </trans-unit>
        <trans-unit id="605d4ad9d9fdab9c7d0d8facad9343748a300de2" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing the server of a client-server relation.</source>
          <target state="translated">一个行为模块,用于实现客户与服务器关系的服务器。</target>
        </trans-unit>
        <trans-unit id="00f8ebc260124e1ab7b63ede984d78166228dd40" translate="yes" xml:space="preserve">
          <source>A better function definition would be:</source>
          <target state="translated">更好的职能定义是:</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">一个二进制总是包含一个完整的字节数。</target>
        </trans-unit>
        <trans-unit id="d08e886402089500f760cd62e9be33847d11368c" translate="yes" xml:space="preserve">
          <source>A binary is a sequence of bytes. Those bytes can be organized in any way, even in a sequence that does not make them a valid string:</source>
          <target state="translated">二进制是一个字节的序列。这些字节可以以任何方式组织起来,即使是一个不能使其成为有效字符串的序列。</target>
        </trans-unit>
        <trans-unit id="6f4b7277d1938d9dc02215252a72af388262f382" translate="yes" xml:space="preserve">
          <source>A bitstring generator can be mixed with &amp;ldquo;regular&amp;rdquo; enumerable generators, and supports filters as well.</source>
          <target state="translated">比特串生成器可以与&amp;ldquo;常规&amp;rdquo;可枚举生成器混合使用，并且还支持过滤器。</target>
        </trans-unit>
        <trans-unit id="18fa63ca56fa56c911a7c87acd788299f0b5e786" translate="yes" xml:space="preserve">
          <source>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</source>
          <target state="translated">一个比特串是由许多段组成的,每个段有一个类型。比特串中使用的类型有9种。</target>
        </trans-unit>
        <trans-unit id="ea8cc225102a641a743fb78156d8a9bef53771d8" translate="yes" xml:space="preserve">
          <source>A byte of Erlang</source>
          <target state="translated">埃尔兰的一个字节</target>
        </trans-unit>
        <trans-unit id="79fd446d748480ae656763877da9c4cf859f5647" translate="yes" xml:space="preserve">
          <source>A calendar implementation</source>
          <target state="translated">执行日历</target>
        </trans-unit>
        <trans-unit id="45adc33f9e352c348aeb6f71e9cae2cc39cef184" translate="yes" xml:space="preserve">
          <source>A calendar implementation that follows to ISO 8601.</source>
          <target state="translated">遵循ISO 8601的日历实施。</target>
        </trans-unit>
        <trans-unit id="abb29a18596674b0600471f06a0b774c5ee65d42" translate="yes" xml:space="preserve">
          <source>A captured remote function in the format of &amp;amp;Mod.fun/arity</source>
          <target state="translated">以＆Mod.fun / arity格式捕获的远程功能</target>
        </trans-unit>
        <trans-unit id="4983d0390c0cc88fb62df8a53e3ded20887e73ee" translate="yes" xml:space="preserve">
          <source>A charlist is nothing more than a list of code points. Char lists may be created with single-quoted literals:</source>
          <target state="translated">charlist不过是一个代码点的列表。Char list可以用单引号创建。</target>
        </trans-unit>
        <trans-unit id="e14e2847d8fdb35b747294036ae2ad35a22ccd61" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to a string to see its inner binary representation:</source>
          <target state="translated">Elixir中的一个常见技巧是将空字节 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 到字符串以查看其内部二进制表示形式：</target>
        </trans-unit>
        <trans-unit id="ab960785cbfb3aadf16ce8c8af561b378d6faa72" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir when you want to see the inner binary representation of a string is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to it:</source>
          <target state="translated">当您想查看字符串的内部二进制表示形式时，Elixir中的一个常见技巧是将空字节 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 连接到该字符串：</target>
        </trans-unit>
        <trans-unit id="1bfb26f32033c8d890b9980e9f88f657ab247fd3" translate="yes" xml:space="preserve">
          <source>A common use case of &lt;code&gt;:into&lt;/code&gt; can be transforming values in a map, without touching the keys:</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 的常见用例可以是在不触摸键的情况下转换映射中的值：</target>
        </trans-unit>
        <trans-unit id="27f0ae652ebbfbd5531320563e778f58becfe7bb" translate="yes" xml:space="preserve">
          <source>A compiled pattern can also be given:</source>
          <target state="translated">也可以给出一个编译的模式。</target>
        </trans-unit>
        <trans-unit id="e76869e54063c0294aaea20a8943a0f7504376d4" translate="yes" xml:space="preserve">
          <source>A compiled pattern:</source>
          <target state="translated">编制的模式。</target>
        </trans-unit>
        <trans-unit id="0d84ab3be01cbc1dc689657ecb9175e041485e11" translate="yes" xml:space="preserve">
          <source>A compiler supports the same attributes for configuration and documentation as a regular Mix task. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">编译器支持与常规Mix任务相同的配置和文档属性。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4854fa789ccf4924d0dea2f4dbb87c84c9909913" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;在Elixir文档中&lt;/a&gt;可以找到有关二进制/位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 的完整参考。</target>
        </trans-unit>
        <trans-unit id="d3ab1c60e70dbccd5bb3b6385dfc22cb20961df9" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;. This concludes our tour of bitstrings, binaries and strings. A string is a UTF-8 encoded binary and a binary is a bitstring where the number of bits is divisible by 8. Although this shows the flexibility Elixir provides for working with bits and bytes, 99% of the time you will be working with binaries and using the &lt;code&gt;is_binary/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;在Elixir文档中&lt;/a&gt;可以找到有关二进制/位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 的完整参考。到此结束我们的位串，二进制和字符串之旅。字符串是UTF-8编码的二进制，而二进制是位串，其中位数可以被8整除。尽管这表明Elixir提供了灵活的位和字节处理能力，但您有99％的时间使用二进制文件并使用 &lt;code&gt;is_binary/1&lt;/code&gt; 和 &lt;code&gt;byte_size/1&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="105058c6913b6aca65f638c1f413a6d39b69929a" translate="yes" xml:space="preserve">
          <source>A comprehension accepts many generators and filters. Enumerable generators are defined using &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">理解可以接受许多生成器和过滤器。可枚举的生成器使用 &lt;code&gt;&amp;lt;-&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="f2254d1e3c598efd95bae0fbcd5261dc7a19b584" translate="yes" xml:space="preserve">
          <source>A comprehension is made of three parts: generators, filters, and collectables.</source>
          <target state="translated">理解力由三部分组成:发电机、过滤器、收藏品。</target>
        </trans-unit>
        <trans-unit id="57e82275e50252bbe2085b03c1d0b32e426de8c6" translate="yes" xml:space="preserve">
          <source>A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback is useful to verify the arguments given to the provider and prepare the state that will be given to &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配置提供程序通常在组装系统的机器上而不是在目标机器上初始化。该&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调是验证给定到提供者的参数，并准备将被提供给状态有用&lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2d91cecc19bd9b6373cb65cc2b96981847455a7" translate="yes" xml:space="preserve">
          <source>A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.</source>
          <target state="translated">只要reduce函数是以尾递归的方式定义的,就可以琐碎地实现延续。如果函数是尾递归的,所有的状态都作为参数传递,所以延续是部分应用了还原函数。</target>
        </trans-unit>
        <trans-unit id="d9d07f696d7dfca22202afba7e8f633e04a8e575" translate="yes" xml:space="preserve">
          <source>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</source>
          <target state="translated">一个方便的宏,用于检查右侧(一个表达式)是否与左侧(一个模式)匹配。</target>
        </trans-unit>
        <trans-unit id="519bb29b1d6986fcd05f0a99d472d916cc9bd057" translate="yes" xml:space="preserve">
          <source>A datetime implementation with a time zone.</source>
          <target state="translated">一个带时区的日期时间实现。</target>
        </trans-unit>
        <trans-unit id="b6db3633bda62d2390f3bfd7494f15fde875e846" translate="yes" xml:space="preserve">
          <source>A default value can also be given as third argument. If any of the keys in the path along the way is missing, the default value is used:</source>
          <target state="translated">也可以给出一个默认值作为第三个参数。如果沿途路径中缺少任何一个键,则使用默认值。</target>
        </trans-unit>
        <trans-unit id="67d109facb82e3da7d9ccbd5e6e026c506c1e1ee" translate="yes" xml:space="preserve">
          <source>A dependency that wants to export formatter configuration needs to have a &lt;code&gt;.formatter.exs&lt;/code&gt; file at the root of the project. In this file, the dependency can export a &lt;code&gt;:export&lt;/code&gt; option with configuration to export. For now, only one option is supported under &lt;code&gt;:export&lt;/code&gt;: &lt;code&gt;:locals_without_parens&lt;/code&gt; (whose value has the same shape as the value of the &lt;code&gt;:locals_without_parens&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#format_string!/2&quot;&gt;&lt;code&gt;Code.format_string!/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">要导出格式化程序配置的依赖项需要在项目的根目录具有 &lt;code&gt;.formatter.exs&lt;/code&gt; 文件。在此文件中，依赖项可以导出带有配置的 &lt;code&gt;:export&lt;/code&gt; 选项以进行导出。现在，只有一个选项是在支持 &lt;code&gt;:export&lt;/code&gt; ： &lt;code&gt;:locals_without_parens&lt;/code&gt; （其值具有相同形状的值 &lt;code&gt;:locals_without_parens&lt;/code&gt; 中&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#format_string!/2&quot;&gt; &lt;code&gt;Code.format_string!/2&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="78f3b8cdfef736d240c67d26318dec43ff774694" translate="yes" xml:space="preserve">
          <source>A developer can filter to import only macros or functions via the only option:</source>
          <target state="translated">开发者可以通过 &quot;唯一 &quot;选项过滤,只导入宏或函数。</target>
        </trans-unit>
        <trans-unit id="02f52246bffbbbb2db795496e80d43d32453cd29" translate="yes" xml:space="preserve">
          <source>A developer can set a string as an input. The default input is an empty string. If capturing a named device asynchronously, an input can only be given to the first capture. Any further capture that is given to a capture on that device will raise an exception and would indicate that the test should be run synchronously.</source>
          <target state="translated">开发者可以设置一个字符串作为输入。默认的输入是一个空字符串。如果异步捕获一个命名的设备,只能给第一个捕获输入。任何进一步给该设备上的捕获的输入都将引发一个异常,并将表明测试应该同步运行。</target>
        </trans-unit>
        <trans-unit id="5a911f4ab0ec30f4f88b0aebbdc462456eb2bb1d" translate="yes" xml:space="preserve">
          <source>A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as:</source>
          <target state="translated">开发者决不能为了代码组织的目的而使用进程。流程必须用于模拟运行时属性,如:。</target>
        </trans-unit>
        <trans-unit id="84906ae4b0b03202e187ef303aa6f0bec88d2611" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, a supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;), and a name:</source>
          <target state="translated">动态主管是从没有孩子开始的，有一个主管策略（当前支持的唯一策略是 &lt;code&gt;:one_for_one&lt;/code&gt; ）和一个名称：</target>
        </trans-unit>
        <trans-unit id="4d1073f62e845462d6a9fa22958360b75968c4eb" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, often under a supervisor with the supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;) and a name:</source>
          <target state="translated">动态的主管是从没有孩子开始的，通常是在具有主管策略（当前支持的唯一策略是 &lt;code&gt;:one_for_one&lt;/code&gt; ）的主管的领导下：</target>
        </trans-unit>
        <trans-unit id="206a7ca6f86f975f7d383ad0847c73bb36ab55be" translate="yes" xml:space="preserve">
          <source>A event manager with event handlers behaviour.</source>
          <target state="translated">一个具有事件处理程序行为的事件管理器。</target>
        </trans-unit>
        <trans-unit id="5b9f82bdf9353661bdb7bfb129accfcfc67cacc8" translate="yes" xml:space="preserve">
          <source>A file can also be opened with &lt;code&gt;:utf8&lt;/code&gt; encoding, which tells the &lt;code&gt;File&lt;/code&gt; module to interpret the bytes read from the file as UTF-8-encoded bytes.</source>
          <target state="translated">也可以使用 &lt;code&gt;:utf8&lt;/code&gt; 编码打开文件，该 &lt;code&gt;File&lt;/code&gt; 告诉File模块将从文件中读取的字节解释为UTF-8编码的字节。</target>
        </trans-unit>
        <trans-unit id="26174891cb43d56e620f230c7e58f6661e413141" translate="yes" xml:space="preserve">
          <source>A file named &lt;code&gt;mix.exs&lt;/code&gt; was generated inside our new project folder (&lt;code&gt;kv&lt;/code&gt;) and its main responsibility is to configure our project. Let&amp;rsquo;s take a look at it:</source>
          <target state="translated">在我们的新项目文件夹（ &lt;code&gt;kv&lt;/code&gt; ）内生成了一个名为 &lt;code&gt;mix.exs&lt;/code&gt; 的文件，其主要职责是配置我们的项目。让我们看一下：</target>
        </trans-unit>
        <trans-unit id="b7f8081cbb17a898eeed9fb6829112a813894639" translate="yes" xml:space="preserve">
          <source>A finished test can be in one of five states:</source>
          <target state="translated">完成的测试可以有五种状态之一。</target>
        </trans-unit>
        <trans-unit id="4fed755e476e5364797de1ef4e79f28c16e21183" translate="yes" xml:space="preserve">
          <source>A first attempt at improving it could be with ranges:</source>
          <target state="translated">改进的第一个尝试可能是与范围。</target>
        </trans-unit>
        <trans-unit id="433ee9a9f829c196fd1ee1abea74ddd48c74e24a" translate="yes" xml:space="preserve">
          <source>A flex break still causes a group to break, like &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;, but it is re-evaluated when the documented is rendered.</source>
          <target state="translated">弹性中断仍然会导致组中断，例如&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;，但是在呈现文档时会重新评估它。</target>
        </trans-unit>
        <trans-unit id="c789b9878ed6a8416701bcc8a3653070d47748c6" translate="yes" xml:space="preserve">
          <source>A full match spec used when selecting objects in the registry</source>
          <target state="translated">在注册表中选择对象时使用的完全匹配规格。</target>
        </trans-unit>
        <trans-unit id="a3614f0c3cc10c91c4e5886008e5901952c470af" translate="yes" xml:space="preserve">
          <source>A function clause will be executed if and only if its guard expression evaluates to &lt;code&gt;true&lt;/code&gt;. If any other value is returned, the function clause will be skipped. In particular, guards have no concept of &quot;truthy&quot; or &quot;falsey&quot;.</source>
          <target state="translated">当且仅当其保护表达式的计算结果为 &lt;code&gt;true&lt;/code&gt; 时,函数子句才会执行。如果返回任何其他值，则将跳过function子句。特别是，警卫人员没有&amp;ldquo;真实&amp;rdquo;或&amp;ldquo;虚假&amp;rdquo;的概念。</target>
        </trans-unit>
        <trans-unit id="7d5721d8d9a91361a538da41fa6ecb3b70b6fe95" translate="yes" xml:space="preserve">
          <source>A function that expects arguments can be defined as follows:</source>
          <target state="translated">一个期望参数的函数可以定义如下。</target>
        </trans-unit>
        <trans-unit id="d355151786999a1eeed6fd34569b3fb108130e3c" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;application#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">一般指导原则是仅在监视树的顶部（通常在&lt;a href=&quot;application#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;回调中）使用不带回调模块的管理程序。我们建议对应用程序中的任何其他主管使用基于模块的主管，以便它们可以作为树中其他主管的子代运行。可以使用以下选项来自定义&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;自动生成的 &lt;code&gt;child_spec/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d26632b07b76b36fb14c1f0930f3f860b35b498" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">一般指导原则是仅在您的监督树的顶部（通常在&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;回调中）使用不带回调模块的主管。我们建议对应用程序中的任何其他主管使用基于模块的主管，以便它们可以作为树中其他主管的子代运行。可以使用以下选项来自定义&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;自动生成的 &lt;code&gt;child_spec/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6b4711dc1275381e6488c7af769cb77bdc74fad" translate="yes" xml:space="preserve">
          <source>A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute:</source>
          <target state="translated">给定的字节码或协议实现可以通过分析协议属性来检查是否合并。</target>
        </trans-unit>
        <trans-unit id="78b0b35ef86b280f67197dee5c9182e1ddbec041" translate="yes" xml:space="preserve">
          <source>A given include/exclude filter can be given more than once:</source>
          <target state="translated">一个给定的include/exclude过滤器可以给定一次以上。</target>
        </trans-unit>
        <trans-unit id="ace5acb901e1cf11450076f19fc37584bf1d2ad7" translate="yes" xml:space="preserve">
          <source>A group with linebreaks will fit if all lines in the group fit.</source>
          <target state="translated">如果组中所有的线都符合,那么一个有断线的组就会符合。</target>
        </trans-unit>
        <trans-unit id="d57f1441409523fcaba5ede0a6bbc3934bffdaa3" translate="yes" xml:space="preserve">
          <source>A guard to be evaluated when matching on objects in a registry</source>
          <target state="translated">匹配注册表中的对象时要评估的保护。</target>
        </trans-unit>
        <trans-unit id="d0ff20995d6baf3cafcf4ec6d8e37185e4734ce5" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, for example, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">存在一些用于处理重复键的函数，例如，&lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt;返回给定键的所有值，而&lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt;仅删除现有条目之一。</target>
        </trans-unit>
        <trans-unit id="f530d85d2682e767c664f63f19c8edab6f12a410" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, in particular, &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; allows creating new keywords without removing duplicated keys, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">存在一些用于处理重复键的函数，特别是&lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;允许创建新关键字而不删除重复键，&lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt;返回给定键的所有值，而&lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt;仅删除现有条目之一。</target>
        </trans-unit>
        <trans-unit id="015b83a7f5c39d5e87a14fcb109161e605efd575" translate="yes" xml:space="preserve">
          <source>A higher level and more convenient API is also available via &lt;a href=&quot;#format/1&quot;&gt;&lt;code&gt;IO.ANSI.format/1&lt;/code&gt;&lt;/a&gt;, where you use atoms to represent each ANSI escape sequence and by default checks if ANSI is enabled:</source>
          <target state="translated">还可以通过&lt;a href=&quot;#format/1&quot;&gt; &lt;code&gt;IO.ANSI.format/1&lt;/code&gt; &lt;/a&gt;获得更高级别和更方便的API ，您可以在其中使用原子来表示每个ANSI转义序列，并默认检查是否启用了ANSI：</target>
        </trans-unit>
        <trans-unit id="596a9b5a3a8aa9b50ec41bf23a4f842662a8cb81" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled.</source>
          <target state="translated">在模块编译前调用的钩子。</target>
        </trans-unit>
        <trans-unit id="a0a0a51df914ce59ba1556541b6506e53ae5b94d" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled. Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">在编译模块之前将调用的挂钩。接受模块或 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 元组。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="6987134a6eff9f82a6141f1c9cc8c83ffe79d180" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled.</source>
          <target state="translated">在当前模块编译完成后立即调用的钩子。</target>
        </trans-unit>
        <trans-unit id="83dcc203e6f45c9ceed02fc70bb7ce0dc9022031" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled. Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt;. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">在编译当前模块后将立即调用的钩子。接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="7281774c2eebc7eedcdde8f4eb9495e25954bfba" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</source>
          <target state="translated">当当前模块中的每个函数或宏被定义时,将被调用的钩子。在注释函数时很有用。</target>
        </trans-unit>
        <trans-unit id="b574e1f9586eced8b5deb66bb46ac24d0c228cae" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked whenever the module is loaded.</source>
          <target state="translated">一个钩子,每当模块被加载时就会被调用。</target>
        </trans-unit>
        <trans-unit id="3230b053994c4f824d19b0f0c39c5b461d162140" translate="yes" xml:space="preserve">
          <source>A keyword list can also be given if there is a need to change the child specification for the given child process:</source>
          <target state="translated">如果需要更改给定子流程的子规范,也可以给出一个关键字列表。</target>
        </trans-unit>
        <trans-unit id="27f0445b17da9c462d7db8862e1b68f43ab27b20" translate="yes" xml:space="preserve">
          <source>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</source>
          <target state="translated">一个关键字列表,包含shell在打印表达式评估结果时使用的检查选项。默认为pretty格式,限制为50个条目。</target>
        </trans-unit>
        <trans-unit id="61fe73f02ff5a301c92071887b054a01257fbb87" translate="yes" xml:space="preserve">
          <source>A keyword list is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</source>
          <target state="translated">关键字列表是一个双元素元组的列表,其中元组的第一个元素是原子,第二个元素可以是任何值。</target>
        </trans-unit>
        <trans-unit id="a6fa0b36a31d21b7bbaef70cccf2751fe2ed4b92" translate="yes" xml:space="preserve">
          <source>A keyword list is a list that consists exclusively of two-element tuples.</source>
          <target state="translated">关键词列表是一个完全由两个元素元组组成的列表。</target>
        </trans-unit>
        <trans-unit id="5a590eff23e0d301e8846f76f5edec42c61cc765" translate="yes" xml:space="preserve">
          <source>A keyword list of AST metadata.</source>
          <target state="translated">一个AST元数据的关键字列表。</target>
        </trans-unit>
        <trans-unit id="352c6325949d916dfbf48e00d1fe4d030d4dc592" translate="yes" xml:space="preserve">
          <source>A keyword list that encapsulates all color settings used by the shell. See documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt;&lt;code&gt;IO.ANSI&lt;/code&gt;&lt;/a&gt; module for the list of supported colors and attributes.</source>
          <target state="translated">关键字列表，封装了外壳使用的所有颜色设置。有关支持的颜色和属性的列表，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt; &lt;code&gt;IO.ANSI&lt;/code&gt; &lt;/a&gt;模块的文档。</target>
        </trans-unit>
        <trans-unit id="90fd8fbcd55ac37d5c84cb3c58c955ad51a59d87" translate="yes" xml:space="preserve">
          <source>A keyword list:</source>
          <target state="translated">一个关键词列表。</target>
        </trans-unit>
        <trans-unit id="b0d83669bf620b5b45fad88effbdaebb1342a611" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value data type. However most of the functions in this module behave exactly as a key-value so they work similarly to the functions you would find in the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. For example, &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete/2&quot;&gt;&lt;code&gt;Keyword.delete/2&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts.</source>
          <target state="translated">关键字可能具有重复的键，因此严格来说不是键值数据类型。但是，此模块中的大多数功能的行为都与键值完全相同，因此它们的作用类似于在&lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块中找到的功能。例如，&lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt;将获取与给定键匹配的第一个条目，而不管是否存在重复的条目。同样，&lt;a href=&quot;#put/3&quot;&gt; &lt;code&gt;Keyword.put/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#delete/2&quot;&gt; &lt;code&gt;Keyword.delete/2&lt;/code&gt; &lt;/a&gt;确保在调用时删除给定键的所有重复条目。但是请注意，关键字列表操作需要遍历整个列表才能找到关键字，因此这些操作比对应的地图操作要慢。</target>
        </trans-unit>
        <trans-unit id="207a17d66a4d274303a0b808b876e2f07cab4cdc" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">关键字可能具有重复的键，因此严格来说不是键值存储。但是，此模块中的大多数功能完全像字典一样工作，因此它们的工作方式与您在&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块中找到的功能类似。</target>
        </trans-unit>
        <trans-unit id="7d3c9948a05d7abcab99c9cefbe9438aa010a2dc" translate="yes" xml:space="preserve">
          <source>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return &lt;code&gt;false&lt;/code&gt; if it does not support the concept of leap years.</source>
          <target state="translated">year年是比正常更长的一年。确切含义取决于日历。如果日历不支持leap年的概念，则必须返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9fe9c85fbf7d3fb18bb99ccf2350f33242ce20" translate="yes" xml:space="preserve">
          <source>A library should not provide &lt;code&gt;use MyLib&lt;/code&gt; functionality if all &lt;code&gt;use MyLib&lt;/code&gt; does is to &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;alias&lt;/code&gt; the module itself. For example, this is an anti-pattern:</source>
          <target state="translated">如果 &lt;code&gt;use MyLib&lt;/code&gt; 全部 &lt;code&gt;use MyLib&lt;/code&gt; 是 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;alias&lt;/code&gt; 模块本身，则库不应提供use MyLib功能。例如，这是一个反模式：</target>
        </trans-unit>
        <trans-unit id="86a187cb80a7c4ad0fb8e723a871bc21c28d506c" translate="yes" xml:space="preserve">
          <source>A link is created between the calling process and the new process, atomically. If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason &lt;code&gt;:noconnection&lt;/code&gt; will be received).</source>
          <target state="translated">原子地在调用过程和新过程之间创建一个链接。如果 &lt;code&gt;node&lt;/code&gt; 不存在，则返回无用的PID（并且由于链接，将收到退出原因为 &lt;code&gt;:noconnection&lt;/code&gt; 的退出信号）。</target>
        </trans-unit>
        <trans-unit id="f32efab7c564ee44d8dbdb445e6ef037578935c8" translate="yes" xml:space="preserve">
          <source>A list also supports matching on its own head and tail:</source>
          <target state="translated">列表也支持在自己的头部和尾部进行匹配。</target>
        </trans-unit>
        <trans-unit id="b51c3a4547f02d7e7f4e5168a995c1a16dcdbcfa" translate="yes" xml:space="preserve">
          <source>A list can be checked if it is made of only printable ASCII characters with &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果列表仅由具有&lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; 的&lt;/a&gt;可打印ASCII字符组成，则可以进行检查。</target>
        </trans-unit>
        <trans-unit id="09109009b595afbd12ae9a2a04f05c373522edd5" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;code#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">环境选项列表也可以作为参数给出。有关更多信息，请参见&lt;a href=&quot;code#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a39f6289583bb5f5f00c8514b83d6750f110e0a" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">环境选项列表也可以作为参数给出。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d66ba38cf190fb69cf061a0304e059a09b5cac80" translate="yes" xml:space="preserve">
          <source>A list of files and/or directories can be given after the task name in order to select the files to run:</source>
          <target state="translated">可以在任务名称后给出文件和/或目录的列表,以便选择要运行的文件。</target>
        </trans-unit>
        <trans-unit id="5fa40d2c95d1592c3f577816c839f4bfb9a0eb32" translate="yes" xml:space="preserve">
          <source>A list of files can be given after the task name in order to select the files to compile:</source>
          <target state="translated">可以在任务名称后面给出一个文件列表,以便选择要编译的文件。</target>
        </trans-unit>
        <trans-unit id="e4f891471b493829a13afb97466625b0b354b781" translate="yes" xml:space="preserve">
          <source>A list of guards to be evaluated when matching on objects in a registry</source>
          <target state="translated">匹配注册表中的对象时要评估的防护措施列表</target>
        </trans-unit>
        <trans-unit id="a09af47acaa10fb69360523f8594ec6d2a340887" translate="yes" xml:space="preserve">
          <source>A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents.</source>
          <target state="translated">返回一个列表,其中主列表中的每个条目代表一个匹配,副列表中的每个条目代表捕获的内容。</target>
        </trans-unit>
        <trans-unit id="ea96d09747a4aa343151e0377aac270bb2119eb2" translate="yes" xml:space="preserve">
          <source>A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on &lt;code&gt;start_link/1&lt;/code&gt; to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</source>
          <target state="translated">选项列表，可用于指定诸如服务器名称之类的内容。现在，我们将在 &lt;code&gt;start_link/1&lt;/code&gt; 上收到的选项列表转发到 &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14180540c9dfb80b1033daf7503e57620771cedc" translate="yes" xml:space="preserve">
          <source>A list of patterns:</source>
          <target state="translated">一系列的模式。</target>
        </trans-unit>
        <trans-unit id="2579a07d3781330f2b03068754b700311c87706a" translate="yes" xml:space="preserve">
          <source>A list with all variable bindings.</source>
          <target state="translated">一个包含所有变量绑定的列表。</target>
        </trans-unit>
        <trans-unit id="bfadb8e1f57e1fb13ad2e8d3a0b69f6c2d5144ae" translate="yes" xml:space="preserve">
          <source>A local, decentralized and scalable key-value process storage.</source>
          <target state="translated">一个本地的、分散的、可扩展的键值过程存储。</target>
        </trans-unit>
        <trans-unit id="fea558b9d01d10708bd232eedeea8d9affdc8614" translate="yes" xml:space="preserve">
          <source>A logger for Elixir applications.</source>
          <target state="translated">一个用于Elixir应用的记录器。</target>
        </trans-unit>
        <trans-unit id="0f699b34255da40ccc76a38c897571c0c579e349" translate="yes" xml:space="preserve">
          <source>A mandatory linebreak.</source>
          <target state="translated">一个强制性的断线。</target>
        </trans-unit>
        <trans-unit id="a06294fa5d8aaf5ba345cd5c76ff398b3966ffbf" translate="yes" xml:space="preserve">
          <source>A map representing the results of running a test suite</source>
          <target state="translated">代表测试套件运行结果的地图。</target>
        </trans-unit>
        <trans-unit id="3d6bcd31c59bce4c517c58779221986c48c5763e" translate="yes" xml:space="preserve">
          <source>A meta task that compiles source files.</source>
          <target state="translated">一个编译源文件的元任务。</target>
        </trans-unit>
        <trans-unit id="6a1a9dcccbb902320d46c5c63b16e41809e26be8" translate="yes" xml:space="preserve">
          <source>A module for working with applications and defining application callbacks.</source>
          <target state="translated">一个用于处理应用程序和定义应用程序回调的模块。</target>
        </trans-unit>
        <trans-unit id="393ee42f919d889432d7d012d4db2df21c1d324c" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt; behaviour.</source>
          <target state="translated">实现&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt;行为的模块。</target>
        </trans-unit>
        <trans-unit id="8dd0cdfde3f3104d72c5cb46bfa86d5986868373" translate="yes" xml:space="preserve">
          <source>A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.</source>
          <target state="translated">如果一个模块目前正在被定义,并且它的属性和功能可以被修改,那么这个模块就是 &quot;开放 &quot;的。</target>
        </trans-unit>
        <trans-unit id="bcc80a2d15eb1ca0fa95f140b2ab076769a58202" translate="yes" xml:space="preserve">
          <source>A module may export a &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; function that can cause the module to be recompiled using custom rules. For example, &lt;code&gt;@external_resource&lt;/code&gt; already adds a compile-time dependency on an external file, however to depend on a &lt;em&gt;dynamic&lt;/em&gt; list of files we can do:</source>
          <target state="translated">模块可以导出 &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; 函数，该函数可能导致使用自定义规则重新编译模块。例如， &lt;code&gt;@external_resource&lt;/code&gt; 已经在外部文件上添加了编译时依赖关系，但是要依赖&lt;em&gt;动态&lt;/em&gt;文件列表，我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="db0c1125a7c9859ba806c52d2b8389c8da71008d" translate="yes" xml:space="preserve">
          <source>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with &lt;code&gt;@doc false&lt;/code&gt;, &lt;code&gt;@impl true&lt;/code&gt;, or functions that aren't explicitly documented and where the function name is in the form of &lt;code&gt;__foo__&lt;/code&gt;.</source>
          <target state="translated">模块可能会导出不希望直接使用的功能：IEX不会自动完成这些功能。IEx不会自动完成以 &lt;code&gt;@doc false&lt;/code&gt; ， &lt;code&gt;@impl true&lt;/code&gt; 注释的函数或未明确记录且函数名称为 &lt;code&gt;__foo__&lt;/code&gt; 形式的函数。</target>
        </trans-unit>
        <trans-unit id="32cd185a5680fc74f94a90987dd36d929f10c20a" translate="yes" xml:space="preserve">
          <source>A module responsible for compiling and requiring files in parallel.</source>
          <target state="translated">一个负责并行编译和要求文件的模块。</target>
        </trans-unit>
        <trans-unit id="29645843a5110b928d9faeadea534106995dc37f" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; fetches the last element).</source>
          <target state="translated">可以传递一个负 &lt;code&gt;index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且 &lt;code&gt;index&lt;/code&gt; 从末尾开始计数（例如， &lt;code&gt;-1&lt;/code&gt; 提取最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="26cdfdc092bdd1d22ed3029d691848711d9f566b" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; finds the last element).</source>
          <target state="translated">可以传递一个负 &lt;code&gt;index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且 &lt;code&gt;index&lt;/code&gt; 从末尾开始计数（例如 &lt;code&gt;-1&lt;/code&gt; 找到最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="7237cde12b43d44a106f66033ee7470522a9c3a4" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;length&lt;/code&gt; can be used to extract bytes that come &lt;em&gt;before&lt;/em&gt; the byte at &lt;code&gt;start&lt;/code&gt;:</source>
          <target state="translated">负 &lt;code&gt;length&lt;/code&gt; 可用于提取 &lt;code&gt;start&lt;/code&gt; 字节&lt;em&gt;之前&lt;/em&gt;的字节：</target>
        </trans-unit>
        <trans-unit id="36a3b9605725fcc95fe9b23e674356e7e27c98c9" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;start_index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the index is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; starts slicing from the last element).</source>
          <target state="translated">可以传递一个负的 &lt;code&gt;start_index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且索引从末尾开始计数（例如 &lt;code&gt;-1&lt;/code&gt; 从最后一个元素开始切片）。</target>
        </trans-unit>
        <trans-unit id="81c58f8de418e8cd25d1b22380a53e0273247707" translate="yes" xml:space="preserve">
          <source>A negative assertion, expects the expression to be &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">否定断言期望表达式为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f88876dd5bc14e91399b8aa67a2ddb2e03a67c34" translate="yes" xml:space="preserve">
          <source>A non-local return from a function.</source>
          <target state="translated">一个函数的非本地返回。</target>
        </trans-unit>
        <trans-unit id="0eaabe61fdbf51208eaa83fc1dc3996aba60b1e8" translate="yes" xml:space="preserve">
          <source>A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;a href=&quot;#restart_child/2&quot;&gt;&lt;code&gt;restart_child/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#delete_child/2&quot;&gt;&lt;code&gt;delete_child/2&lt;/code&gt;&lt;/a&gt; to remove the child specification.</source>
          <target state="translated">管理员以后可以重新启动非临时子进程。子进程也可以通过调用&lt;a href=&quot;#restart_child/2&quot;&gt; &lt;code&gt;restart_child/2&lt;/code&gt; &lt;/a&gt;显式重启。使用&lt;a href=&quot;#delete_child/2&quot;&gt; &lt;code&gt;delete_child/2&lt;/code&gt; &lt;/a&gt;删除子级规范。</target>
        </trans-unit>
        <trans-unit id="8f2c93e683b0d27c8800a0f19ebf6094692e37b8" translate="yes" xml:space="preserve">
          <source>A partially applied reduce function.</source>
          <target state="translated">部分应用还原功能。</target>
        </trans-unit>
        <trans-unit id="e00db969c5f31283ff3f80e6b605d47156f36587" translate="yes" xml:space="preserve">
          <source>A path may start with a variable, local or remote call, and must be followed by one or more:</source>
          <target state="translated">一个路径可以以变量、本地或远程调用开始,后面必须有一个或多个。</target>
        </trans-unit>
        <trans-unit id="5e11bed9e1e8a8a0b7c8ded2d01ff3d9a7368c94" translate="yes" xml:space="preserve">
          <source>A path pointing to a configuration file.</source>
          <target state="translated">指向配置文件的路径。</target>
        </trans-unit>
        <trans-unit id="41835ab5b136f3e0eaefd676f9827017842ad941" translate="yes" xml:space="preserve">
          <source>A pattern match error will occur if the sides can&amp;rsquo;t be matched, for example if the tuples have different sizes:</source>
          <target state="translated">如果边不能匹配，则会发生模式匹配错误，例如，如果元组的大小不同：</target>
        </trans-unit>
        <trans-unit id="79fa4792dd24d1c9ce95071d9547feb6a4d474ba" translate="yes" xml:space="preserve">
          <source>A pattern to match on objects in a registry</source>
          <target state="translated">在注册表中匹配对象的模式。</target>
        </trans-unit>
        <trans-unit id="3d346e75c8c6987f80b82de7253d52d8aba958ff" translate="yes" xml:space="preserve">
          <source>A pattern used to representing the output format part of a match spec</source>
          <target state="translated">用于表示匹配规格的输出格式部分的一种模式。</target>
        </trans-unit>
        <trans-unit id="a00cd65793f8f99aab040156d050cf1a0b39a869" translate="yes" xml:space="preserve">
          <source>A period where a certain combination of UTC offset, standard offset and zone abbreviation is in effect.</source>
          <target state="translated">在一个时期内,UTC偏移、标准偏移和区域缩写的某种组合是有效的。</target>
        </trans-unit>
        <trans-unit id="a5288558e1086c80bf20bc1087103275b3133199" translate="yes" xml:space="preserve">
          <source>A port can be closed via the &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; function or by sending a &lt;code&gt;{pid, :close}&lt;/code&gt; message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but &lt;strong&gt;it won't be automatically terminated&lt;/strong&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt;函数或发送 &lt;code&gt;{pid, :close}&lt;/code&gt; 消息来关闭端口。但是，如果VM崩溃，则由该端口启动的长时间运行的程序将关闭其stdin和stdout通道，但&lt;strong&gt;不会自动终止&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b2122c1973c2dda96664be48d7e0ad6fbebe03e1" translate="yes" xml:space="preserve">
          <source>A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters:</source>
          <target state="translated">Elixir中的可打印字符表仅包含标准七位ASCII字符编码中的可打印字符,这些字符的十进制符号范围为32至126,再加上以下控制字符。</target>
        </trans-unit>
        <trans-unit id="b3af7c971656040987518db1c82f85c014263d8e" translate="yes" xml:space="preserve">
          <source>A process destination.</source>
          <target state="translated">一个进程的目的地。</target>
        </trans-unit>
        <trans-unit id="4b7c7e3dbab6f551e809bcd37eae034f6b3551ed" translate="yes" xml:space="preserve">
          <source>A project at the given PATH will be created. The application name and module name will be retrieved from the path, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="translated">将在给定的PATH下创建一个项目。除非指定了 &lt;code&gt;--module&lt;/code&gt; 或 &lt;code&gt;--app&lt;/code&gt; ，否则将从路径中检索应用程序名称和模块名称。</target>
        </trans-unit>
        <trans-unit id="e0fec4c2c4c04c0f55fd194db047a9dd66ea084b" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">协议指定应由其实现定义的API。协议使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;定义，其实现使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcf40e109a152697e452d59c6feb366ea55241fd" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">协议指定应由其实现定义的API。甲协议与定义&lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;以及其与实施方式&lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40779d1515587d6db075e7f5314df3d534311c89" translate="yes" xml:space="preserve">
          <source>A protocol to traverse data structures.</source>
          <target state="translated">一个遍历数据结构的协议。</target>
        </trans-unit>
        <trans-unit id="faabe41c6f24d8fc609c47ff799c87b178b75359" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">范围实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于范围：</target>
        </trans-unit>
        <trans-unit id="2d52cd8c9685cc3a9e0c6c8bc2ca91497bbfa62d" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">范围实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于范围：</target>
        </trans-unit>
        <trans-unit id="7c19f0802d8f5cc7c36ac99c9fcb0b292b74f36a" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">范围在内部以结构表示。但是，在范围上创建和匹配的最常见形式是通过从&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入的&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt;宏：</target>
        </trans-unit>
        <trans-unit id="c2bc069750ea0a5631ff0d83641bb81ba15fed6b" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;kernel#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">范围在内部以结构表示。但是，在范围上创建和匹配的最常见形式是通过&lt;a href=&quot;kernel#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt;宏（从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入）：</target>
        </trans-unit>
        <trans-unit id="28e7d9d80973e28b2fb29cdc49aa8ec0aa8cccf3" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">日期范围实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于范围：</target>
        </trans-unit>
        <trans-unit id="efe5b28deb10fda5ba1b89dbda06bf2a014043ab" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">日期范围实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于处理范围：</target>
        </trans-unit>
        <trans-unit id="ef459269461f63f29663369bbbf33d383fe471b6" translate="yes" xml:space="preserve">
          <source>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</source>
          <target state="translated">日期范围表示一个离散的日期数,其中第一个和最后一个值是匹配日历的日期。</target>
        </trans-unit>
        <trans-unit id="857a01be27effa9640fcaf21a35ced2eddd4ea08" translate="yes" xml:space="preserve">
          <source>A range represents a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">一个范围表示一个或多个,升序或降序,连续的整数序列。</target>
        </trans-unit>
        <trans-unit id="3fb37b0dc70a7a2ede2ae25048520f07b813bb7c" translate="yes" xml:space="preserve">
          <source>A regular expression:</source>
          <target state="translated">正则表达式。</target>
        </trans-unit>
        <trans-unit id="fde0b7800eb1831e2b2dcfa6756a9337fbe2e1f7" translate="yes" xml:space="preserve">
          <source>A release can be configured in your &lt;code&gt;mix.exs&lt;/code&gt; file under the &lt;code&gt;:releases&lt;/code&gt; key inside &lt;code&gt;def project&lt;/code&gt;:</source>
          <target state="translated">可以在 &lt;code&gt;def project&lt;/code&gt; 中的 &lt;code&gt;:releases&lt;/code&gt; 键下的 &lt;code&gt;mix.exs&lt;/code&gt; 文件中配置一个发行版：</target>
        </trans-unit>
        <trans-unit id="be263ca652770d8e713a67b34a6b5d617a6d08fc" translate="yes" xml:space="preserve">
          <source>A release is a self-contained directory that consists of your application code, all of its dependencies, plus the whole Erlang Virtual Machine (VM) and runtime. Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.</source>
          <target state="translated">一个版本是一个独立的目录,它包含了你的应用程序代码,所有的依赖关系,加上整个Erlang虚拟机(VM)和运行时。一旦一个发行版被组装好,它就可以被打包并部署到目标机上,只要目标机运行在与组装发行版的机器相同的操作系统(OS)发行版和版本上。</target>
        </trans-unit>
        <trans-unit id="b854f9766a4f0c513ad5b3d7f5739e28f8893848" translate="yes" xml:space="preserve">
          <source>A release is built on a &lt;strong&gt;host&lt;/strong&gt;, a machine which contains Erlang, Elixir, and any other dependencies needed to compile your application. A release is then deployed to a &lt;strong&gt;target&lt;/strong&gt;, potentially the same machine as the host, but usually separate, and often there are many targets (either multiple instances, or the release is deployed to heterogeneous environments).</source>
          <target state="translated">一个发行版基于&lt;strong&gt;主机&lt;/strong&gt;，包含Erlang，Elixir以及编译应用程序所需的任何其他依赖项的机器上构建。然后，将发行版部署到&lt;strong&gt;目标&lt;/strong&gt;（可能与主机位于同一台机器上），但通常是分开的，并且通常有许多目标（多个实例，或者将发行版部署到异构环境）。</target>
        </trans-unit>
        <trans-unit id="081a4af35cb82d84d3baced50f94a0f210c0215f" translate="yes" xml:space="preserve">
          <source>A release is organized as follows:</source>
          <target state="translated">释放的组织形式如下:</target>
        </trans-unit>
        <trans-unit id="c42536b2192014c69ae4b22e18c222e0b18ad99c" translate="yes" xml:space="preserve">
          <source>A remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">远程或本地PID，本地端口，本地注册名称或 &lt;code&gt;{registered_name, node}&lt;/code&gt; 形式的元组，表示另一个节点上的注册名称。</target>
        </trans-unit>
        <trans-unit id="ed74d2fa39cb6d22ba41097b9f56baec46115768" translate="yes" xml:space="preserve">
          <source>A runtime error can be raised any time by using &lt;code&gt;raise/1&lt;/code&gt;:</source>
          <target state="translated">可以随时通过使用 &lt;code&gt;raise/1&lt;/code&gt; 引发运行时错误：</target>
        </trans-unit>
        <trans-unit id="afd43801a9dc45b9bee09b2dbc25b3cf49922533" translate="yes" xml:space="preserve">
          <source>A set can be constructed using &lt;a href=&quot;#new/0&quot;&gt;&lt;code&gt;MapSet.new/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以使用&lt;a href=&quot;#new/0&quot;&gt; &lt;code&gt;MapSet.new/0&lt;/code&gt; &lt;/a&gt;构造一个集合：</target>
        </trans-unit>
        <trans-unit id="ecf229e1b88c6de3ab419f5af0149c86ba96a100" translate="yes" xml:space="preserve">
          <source>A set can contain any kind of elements, and elements in a set don't have to be of the same type. By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op.</source>
          <target state="translated">一个集合可以包含任何种类的元素,而且集合中的元素不一定是同一类型的。根据定义,集合不能包含重复的元素:当在集合中插入一个已经存在的元素时,插入的元素只是一个无操作。</target>
        </trans-unit>
        <trans-unit id="707ec361763bdb2e00f730f12d75204db159aa81" translate="yes" xml:space="preserve">
          <source>A set is a data structure that can contain unique elements of any kind, without any particular order. &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is the &quot;go to&quot; set data structure in Elixir.</source>
          <target state="translated">集合是一种数据结构，可以包含任何种类的唯一元素，而没有任何特定顺序。&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;是Elixir中的&amp;ldquo;转到&amp;rdquo;设置数据结构。</target>
        </trans-unit>
        <trans-unit id="69129ee232976b3cda2ab262254ae0307e0e66f5" translate="yes" xml:space="preserve">
          <source>A set of aliases can be specified in the &lt;code&gt;:aliases&lt;/code&gt; option:</source>
          <target state="translated">可以在 &lt;code&gt;:aliases&lt;/code&gt; 选项中指定一组别名：</target>
        </trans-unit>
        <trans-unit id="77bfe7434af33915219476e72f8afa049afc81c9" translate="yes" xml:space="preserve">
          <source>A set of files that contain tests that failed the last time they ran. The paths are absolute paths.</source>
          <target state="translated">一组包含上次运行失败的测试的文件。这些路径是绝对路径。</target>
        </trans-unit>
        <trans-unit id="e06834fc00f6bb288e0de824ba38e921ca02021c" translate="yes" xml:space="preserve">
          <source>A set of functions for creating and manipulating algebra documents.</source>
          <target state="translated">一组用于创建和操作代数文档的函数。</target>
        </trans-unit>
        <trans-unit id="88d1b0f8b81589767cdd10b2d4eb2dac1c18cfad" translate="yes" xml:space="preserve">
          <source>A set of functions for working with functions.</source>
          <target state="translated">一套用于处理函数的函数。</target>
        </trans-unit>
        <trans-unit id="730d44e1645bfae97fe7c12ff77a7bf08210ea3c" translate="yes" xml:space="preserve">
          <source>A set of functions for working with keywords.</source>
          <target state="translated">一套用于处理关键词的功能。</target>
        </trans-unit>
        <trans-unit id="dfb7a76606ff3c8779b3a99cd95301d320dbf7d1" translate="yes" xml:space="preserve">
          <source>A set of functions for working with maps.</source>
          <target state="translated">一套用于处理地图的功能。</target>
        </trans-unit>
        <trans-unit id="9f7b7bb83b1ac5ba845f1d4d693eba42524cef2e" translate="yes" xml:space="preserve">
          <source>A set of functions that perform calculations on bits.</source>
          <target state="translated">一组对比特进行计算的函数。</target>
        </trans-unit>
        <trans-unit id="5f326a556060d175497aed660d915fb196c3082f" translate="yes" xml:space="preserve">
          <source>A set of macros that perform calculations on bits.</source>
          <target state="translated">一组对比特进行计算的宏。</target>
        </trans-unit>
        <trans-unit id="0f36a297b599bd007efe012e6a6da2cbf2b3692f" translate="yes" xml:space="preserve">
          <source>A set of test IDs that failed the last time they ran</source>
          <target state="translated">一组上次运行失败的测试ID。</target>
        </trans-unit>
        <trans-unit id="7d47059c046e5014c34e11ea59ece30879e2953e" translate="yes" xml:space="preserve">
          <source>A short example is:</source>
          <target state="translated">一个简单的例子是:</target>
        </trans-unit>
        <trans-unit id="cbb763bbb5e88ec5f61d4da245e4ae7009da3216" translate="yes" xml:space="preserve">
          <source>A similar example is when the formatter breaks a function definition over multiple clauses:</source>
          <target state="translated">一个类似的例子是当formatter将一个函数定义分解到多个子句上。</target>
        </trans-unit>
        <trans-unit id="f0bbc03071215c2e0f6a6903b25b4b7e9d6e31a3" translate="yes" xml:space="preserve">
          <source>A simple configuration API and functions for managing config files.</source>
          <target state="translated">一个简单的配置API和管理配置文件的功能。</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="50c4d47f669eefd6925f54ce413c2f2d2b593c55" translate="yes" xml:space="preserve">
          <source>A simple example of a custom type implementation is to provide a more descriptive alias of an existing type. For example, defining &lt;code&gt;year&lt;/code&gt; as a type makes your function specs more descriptive than if they had simply used &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">自定义类型实现的一个简单示例是提供现有类型的更具描述性的别名。例如，将 &lt;code&gt;year&lt;/code&gt; 定义为类型可以使您的功能规范更具描述性，而不是仅仅使用 &lt;code&gt;integer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="70f5ef2ef60f95969333b92d42f3f374f63b82f9" translate="yes" xml:space="preserve">
          <source>A simple keyword-based configuration API.</source>
          <target state="translated">一个简单的基于关键字的配置API。</target>
        </trans-unit>
        <trans-unit id="c8561655e8b17e9fc3693ef2633482210d43ebb9" translate="yes" xml:space="preserve">
          <source>A simple module that provides conveniences for creating, loading and manipulating tasks.</source>
          <target state="translated">一个简单的模块,为创建、加载和操作任务提供便利。</target>
        </trans-unit>
        <trans-unit id="15571e3a35bf5ea9940001cd7a008535588aae55" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">一个更简单的选择是将理解用于字母的映射和过滤，然后调用&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;来构建映射，例如：</target>
        </trans-unit>
        <trans-unit id="3b0c96451986330669665045ba5856473caa87a1" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">一个更简单的选择是使用理解来映射和过滤字母，然后调用&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;来构建映射，例如：</target>
        </trans-unit>
        <trans-unit id="5961d93e1fd6c1a5f3b6d9b27c8ebaac2a4e2eb8" translate="yes" xml:space="preserve">
          <source>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</source>
          <target state="translated">以UTF-8编码的单一Unicode码点。它可以是一个或多个字节。</target>
        </trans-unit>
        <trans-unit id="42b7224e7f04fc46b45efe7b42b88ffb7dce900f" translate="yes" xml:space="preserve">
          <source>A slicing function that receives the initial position and the number of elements in the slice.</source>
          <target state="translated">一个接收初始位置和切片中元素数量的切片函数。</target>
        </trans-unit>
        <trans-unit id="9542d8f0337c374d610ba8edde94615ef17ee5bc" translate="yes" xml:space="preserve">
          <source>A solution is to make sure the child processes listen to the standard input and terminate when standard input is closed. We discuss this topic at length in the &quot;Zombie operating system processes&quot; of the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">一种解决方案是确保子进程监听标准输入并在标准输入关闭时终止。我们将在&lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;僵尸操作系统进程&amp;rdquo;中详细讨论此主题。</target>
        </trans-unit>
        <trans-unit id="c87e0295b0434ce8d6e0bea2a0090734199f18b2" translate="yes" xml:space="preserve">
          <source>A specification for a function can be defined as follows:</source>
          <target state="translated">一个函数的规格可以定义如下:</target>
        </trans-unit>
        <trans-unit id="db516f2d9f13380d21782abf7bf499d7db55707d" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">必须将stacktrace作为参数。如果不是，则从&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt;检索stacktrace 。</target>
        </trans-unit>
        <trans-unit id="cb5a957f0b3dafd85aa37ba4fcf8ab83b116491b" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;process#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">必须将stacktrace作为参数。如果不是，则从&lt;a href=&quot;process#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt;检索stacktrace 。</target>
        </trans-unit>
        <trans-unit id="024c57bba13b29b29ec58526f15dcb1593786c12" translate="yes" xml:space="preserve">
          <source>A string is a UTF-8 encoded binary. In order to understand exactly what we mean by that, we need to understand the difference between bytes and code points.</source>
          <target state="translated">字符串是一个UTF-8编码的二进制。为了准确理解我们所说的意思,我们需要了解字节和码点的区别。</target>
        </trans-unit>
        <trans-unit id="3135dbc4cf4ce228f4aedafff7fb3268b76ca8f3" translate="yes" xml:space="preserve">
          <source>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</source>
          <target state="translated">结构体是一个标签化的映射,它允许开发者为键提供默认值,在多态派遣和编译时断言中使用的标签。</target>
        </trans-unit>
        <trans-unit id="9134cc0bb82067454750b89f0528401b6a9bc1d3" translate="yes" xml:space="preserve">
          <source>A struct that holds compile time environment information.</source>
          <target state="translated">一个保存编译时环境信息的结构。</target>
        </trans-unit>
        <trans-unit id="2aab307089f5f9db7819dc7a115a812e5a3fa578" translate="yes" xml:space="preserve">
          <source>A struct that holds file information.</source>
          <target state="translated">一个存放文件信息的结构。</target>
        </trans-unit>
        <trans-unit id="682f2bb617fd3f67f3ee1da2f3c9e406cf26c520" translate="yes" xml:space="preserve">
          <source>A struct that holds version requirement information.</source>
          <target state="translated">一个保存版本需求信息的结构。</target>
        </trans-unit>
        <trans-unit id="41babc3e64f09380f0db683d589523654ce213d8" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test case.</source>
          <target state="translated">一个保存测试用例信息的结构。</target>
        </trans-unit>
        <trans-unit id="c75627e28a62723b736494f2d433aeb4bca5337b" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test module.</source>
          <target state="translated">一个保存测试模块信息的结构。</target>
        </trans-unit>
        <trans-unit id="977bdad55f17ecd8ee2f048b6fc658fc29753b9a" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test.</source>
          <target state="translated">一个保存测试信息的结构。</target>
        </trans-unit>
        <trans-unit id="ac118fd8485fc091bbf3bccd439369617ac9e067" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as &lt;em&gt;child processes&lt;/em&gt;. Supervisors are used to build a hierarchical process structure called a &lt;em&gt;supervision tree&lt;/em&gt;. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.</source>
          <target state="translated">主管是监督其他过程的过程，我们称其为&lt;em&gt;子过程&lt;/em&gt;。主管用于构建称为&lt;em&gt;监督树&lt;/em&gt;的分层过程结构。监督树提供了容错能力，并封装了我们的应用程序如何启动和关闭。</target>
        </trans-unit>
        <trans-unit id="55d0b2c21ea69ec921c9ed14e37c45764559b92c" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities. The first one is to start child processes. Once a child process is running, the supervisor may restart a child process, either because it terminated abnormally or because a certain condition was reached. For example, a supervisor may restart all children if any child dies. Finally, a supervisor is also responsible for shutting down the child processes when the system is shutting down. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; module for a more in-depth discussion.</source>
          <target state="translated">主管是监督其他流程的流程，我们将其称为子流程。监督流程的行为包括三个不同的职责。第一个是启动子进程。子进程运行后，主管可能会重新启动子进程，这可能是因为该子进程异常终止或达到了特定条件。例如，如果任何一个孩子死亡，那么主管可以重新启动所有孩子。最后，主管还负责在系统关闭时关闭子进程。请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt;模块以进行更深入的讨论。</target>
        </trans-unit>
        <trans-unit id="2148e1ac9ba1ddbf69713d1fe8062e24faf800f8" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">主管与&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;具有相同的名称注册规则。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的文档中阅读有关这些规则的更多信息。</target>
        </trans-unit>
        <trans-unit id="2be41b998235003f44a6fb66b52b2e8add1dfc50" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">主管与&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;具有相同的名称注册规则。在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中阅读有关这些规则的更多信息。</target>
        </trans-unit>
        <trans-unit id="789257e49c9248f0d549832ff687e69eea5012dc" translate="yes" xml:space="preserve">
          <source>A supervisor may be started directly with a list of children via &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; or you may define a module-based supervisor that implements the required callbacks. The sections below use &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; to start supervisors in most examples, but it also includes a specific section on module-based ones.</source>
          <target state="translated">可以通过&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;从子列表直接启动管理程序，或者您可以定义一个基于模块的管理程序，以实现所需的回调。在大多数示例中，以下部分使用&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;来启动管理程序，但其中还包括有关基于模块的管理程序的特定部分。</target>
        </trans-unit>
        <trans-unit id="73975472006297ae3fcad167925a215d573e02d7" translate="yes" xml:space="preserve">
          <source>A supervisor restarts a child process depending on its &lt;code&gt;:restart&lt;/code&gt; configuration. For example, when &lt;code&gt;:restart&lt;/code&gt; is set to &lt;code&gt;:transient&lt;/code&gt;, the supervisor does not restart the child in case it exits with reason &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">管理员根据其 &lt;code&gt;:restart&lt;/code&gt; 配置重启子进程。例如，当 &lt;code&gt;:restart&lt;/code&gt; 设置为 &lt;code&gt;:transient&lt;/code&gt; 时，监督者不会重启子节点，以防其退出原因是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60c5977b15b358f6b78f3ae1aad052bb829be570" translate="yes" xml:space="preserve">
          <source>A supervisor that starts children dynamically.</source>
          <target state="translated">一个动态启动孩子的主管。</target>
        </trans-unit>
        <trans-unit id="615c68fd3df9515609693344bfb85db4d952662a" translate="yes" xml:space="preserve">
          <source>A tag can be set for all tests in a module or describe block by setting &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; inside each context respectively:</source>
          <target state="translated">可以为模块中的所有测试设置标签，也可以通过分别在每个上下文中设置 &lt;code&gt;@moduletag&lt;/code&gt; 或 &lt;code&gt;@describetag&lt;/code&gt; 来描述模块：</target>
        </trans-unit>
        <trans-unit id="0662f79c653f0ec45efdb5f488b2e4dad7e4bc27" translate="yes" xml:space="preserve">
          <source>A task needs to implement &lt;code&gt;run&lt;/code&gt; which receives a list of command line args.</source>
          <target state="translated">一个任务需要实现 &lt;code&gt;run&lt;/code&gt; ，该运行接收命令行参数列表。</target>
        </trans-unit>
        <trans-unit id="e97df0f46736141ff7a6d7cb0a21370015757093" translate="yes" xml:space="preserve">
          <source>A task supervisor is started with no children, often under a supervisor and a name:</source>
          <target state="translated">任务督导是在没有孩子的情况下开始的,往往是在一个督导和一个名字之下。</target>
        </trans-unit>
        <trans-unit id="ff48cedfb7c96d7c2ed5d2fcc23ecbe5aa13422a" translate="yes" xml:space="preserve">
          <source>A task supervisor is typically started under a supervision tree using the tuple format:</source>
          <target state="translated">任务监督员通常是在监督树下使用元组格式启动的。</target>
        </trans-unit>
        <trans-unit id="400405b3406f1f222a1d0498ff7d0e89bdd37f83" translate="yes" xml:space="preserve">
          <source>A task supervisor.</source>
          <target state="translated">一个任务主管。</target>
        </trans-unit>
        <trans-unit id="b1a878391a15d93f73108d99ebb6b02880382654" translate="yes" xml:space="preserve">
          <source>A task that simply instructs users to run &lt;code&gt;iex -S mix&lt;/code&gt;.</source>
          <target state="translated">一项仅指示用户运行 &lt;code&gt;iex -S mix&lt;/code&gt; 的任务。</target>
        </trans-unit>
        <trans-unit id="2894abc710a014ff1c5c80e21ac1103d9d069763" translate="yes" xml:space="preserve">
          <source>A term of type &lt;strong&gt;IO data&lt;/strong&gt; is a binary or a list containing bytes (integers in &lt;code&gt;0..255&lt;/code&gt;) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &lt;code&gt;&quot;hello&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;IO数据&lt;/strong&gt;类型的术语是二进制或包含字节（ &lt;code&gt;0..255&lt;/code&gt; 中的整数）或嵌套IO数据的列表。类型是递归的。让我们看一个代表二进制 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 的可能的IO数据之一的示例：</target>
        </trans-unit>
        <trans-unit id="7c720a57b20bbb00d7cd6e1d7bb642e1d8d5947c" translate="yes" xml:space="preserve">
          <source>A test module can define multiple &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks, and they are invoked in order of appearance.</source>
          <target state="translated">一个测试模块可以定义多个 &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;setup_all&lt;/code&gt; 回调，并按出现顺序调用它们。</target>
        </trans-unit>
        <trans-unit id="ec4945e7afe50419c6b9cae97faa15dec66d7711" translate="yes" xml:space="preserve">
          <source>A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in &lt;code&gt;1 / parts_per_second&lt;/code&gt; seconds. For example, using the &lt;code&gt;:millisecond&lt;/code&gt; time unit is equivalent to using &lt;code&gt;1000&lt;/code&gt; as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).</source>
          <target state="translated">时间单位也可以是严格的正整数。在这种情况下，它表示&amp;ldquo;每秒的零件数&amp;rdquo;：时间将以 &lt;code&gt;1 / parts_per_second&lt;/code&gt; 秒的形式返回。例如，使用 &lt;code&gt;:millisecond&lt;/code&gt; 时间单位等效于使用 &lt;code&gt;1000&lt;/code&gt; 作为时间单位（因为时间将以1/1000秒-毫秒返回）。</target>
        </trans-unit>
        <trans-unit id="f8027bb61ebc1be6167e83dd5aa3351e16405a8f" translate="yes" xml:space="preserve">
          <source>A timeout in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">超时值可以是毫秒或 &lt;code&gt;:infinity&lt;/code&gt; ，默认值是 &lt;code&gt;5000&lt;/code&gt; 。如果超过了超时，则当前进程将退出。如果任务进程链接到当前进程（使用 &lt;code&gt;async&lt;/code&gt; 启动任务时就是这种情况），那么任务进程也将退出。如果任务进程正在捕获出口或未链接到当前进程，则它将继续运行。</target>
        </trans-unit>
        <trans-unit id="198be1f82bcaf7ef6e87003105d7f1bb0913880a" translate="yes" xml:space="preserve">
          <source>A timeout of 0 can be given when you already expect the message to be in the mailbox.</source>
          <target state="translated">当你已经期待邮件进入邮箱时,可以给出0的超时。</target>
        </trans-unit>
        <trans-unit id="cdda64adffbe29ce867f4e13216350c2cecaa35a" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。</target>
        </trans-unit>
        <trans-unit id="68fd1acb1d049659698dd0e6399a2faf0bb992be" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the time runs out before a message from the task is received, this function will return &lt;code&gt;nil&lt;/code&gt; and the monitor will remain active. Therefore &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; can be called multiple times on the same task.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。如果在收到任务消息之前时间已到，此函数将返回 &lt;code&gt;nil&lt;/code&gt; 并且监视器将保持活动状态。因此，可以在同一任务上多次调用&lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da9b2c8f037d5e02cc94898fc8fb88cecc6bb373" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. Any task processes that are linked to the current process (which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;) will also exit. Any task processes that are trapping exits or not linked to the current process will continue to run.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。如果超过了超时，则当前进程将退出。链接到当前进程的任何任务进程（使用 &lt;code&gt;async&lt;/code&gt; 启动任务时就是这种情况）也将退出。任何正在捕获出口或未链接到当前进程的任务进程将继续运行。</target>
        </trans-unit>
        <trans-unit id="bef32f4d33eabc5b73b7963784b14e838138302d" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。如果超过了超时，则当前进程将退出。如果任务进程链接到当前进程（使用 &lt;code&gt;async&lt;/code&gt; 启动任务时就是这种情况），那么任务进程也将退出。如果任务进程正在捕获出口或未链接到当前进程，则它将继续运行。</target>
        </trans-unit>
        <trans-unit id="1d0d4ddbed899c477cc9f6352b9a36db821efe20" translate="yes" xml:space="preserve">
          <source>A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.</source>
          <target state="translated">尾部的bang(感叹号)表示一个函数或宏,其中失败情况会引发异常。</target>
        </trans-unit>
        <trans-unit id="1557d725dec0291342c366743098a942c2c285d9" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">转换程序只是一个包含模块和功能的元组，可以通过&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt;函数进行添加和删除，并为具有最低参数级别的每个Erlang消息调用以下四个参数：</target>
        </trans-unit>
        <trans-unit id="595193044562313fed22c09af41ccc775c92d1e5" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;logger#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">转换程序只是一个包含模块和功能的元组，可以通过&lt;a href=&quot;logger#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;logger#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt;函数进行添加和删除，并为具有最低参数级别的每个Erlang消息调用以下四个参数：</target>
        </trans-unit>
        <trans-unit id="977fa89e1a9a5fcdc6a2202879cd6a99f38e175d" translate="yes" xml:space="preserve">
          <source>A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals.</source>
          <target state="translated">一个元组可以包含不同类型的元素,这些元素连续地存储在内存中。访问任何元素都需要恒定的时间,但修改一个元组,产生一个浅层副本,需要线性时间。元组适合读取数据,而列表则更适合遍历。</target>
        </trans-unit>
        <trans-unit id="016c5c6429720a5f0c24e4c4b0bbc87c166f277a" translate="yes" xml:space="preserve">
          <source>A tuple representing the &lt;code&gt;day&lt;/code&gt; and the &lt;code&gt;era&lt;/code&gt;.</source>
          <target state="translated">代表元组 &lt;code&gt;day&lt;/code&gt; 和 &lt;code&gt;era&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b70a1f3c40082637faa4be4833ceb4685eae005" translate="yes" xml:space="preserve">
          <source>A type defined with &lt;code&gt;@typep&lt;/code&gt; is private. An opaque type, defined with &lt;code&gt;@opaque&lt;/code&gt; is a type where the internal structure of the type will not be visible, but the type is still public.</source>
          <target state="translated">用 &lt;code&gt;@typep&lt;/code&gt; 定义的类型是私有的。用 &lt;code&gt;@opaque&lt;/code&gt; 定义的不透明类型是一种类型，其中该类型的内部结构不可见，但该类型仍然是公共的。</target>
        </trans-unit>
        <trans-unit id="8d3bd389baf78dba20b0d8db318aee60b33e011c" translate="yes" xml:space="preserve">
          <source>A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup.</source>
          <target state="translated">还必须给出一个与该注册相关联的值。这个值将在每次发送或进行键查询时被检索。</target>
        </trans-unit>
        <trans-unit id="e27b2906462bb426d4db8b9c875eb3719eb195a6" translate="yes" xml:space="preserve">
          <source>A variable assigned inside a function does not affect its surrounding environment:</source>
          <target state="translated">在函数内部赋值的变量不会影响其周围环境。</target>
        </trans-unit>
        <trans-unit id="eefe91c5b1f2dca4795e8c30b3e66948a135ee4c" translate="yes" xml:space="preserve">
          <source>A variable can only be assigned on the left side of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">只能在 &lt;code&gt;=&lt;/code&gt; 的左侧分配变量：</target>
        </trans-unit>
        <trans-unit id="74219847f96158b812f49f7af3b9dcb687e015d5" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">版本是特定格式的字符串，或者是通过&lt;a href=&quot;#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; &lt;/a&gt;解析后生成的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc60d48fd93ed889b691c632db601f39d5eb520c" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;version#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">版本是特定格式的字符串，或者是通过&lt;a href=&quot;version#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; &lt;/a&gt;解析后生成的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e264f31a676a2f05ae95352027c4734997cd7f9" translate="yes" xml:space="preserve">
          <source>A very basic example is:</source>
          <target state="translated">一个很基本的例子是:</target>
        </trans-unit>
        <trans-unit id="9ddca9755179e1f59903c4ddf6f15ddbb4628e05" translate="yes" xml:space="preserve">
          <source>A warning will be printed on missing assigns. Future versions will raise.</source>
          <target state="translated">缺少赋值将被打印警告。未来的版本将提出。</target>
        </trans-unit>
        <trans-unit id="8ca63c80632d0cf1aa32c53e95d09843a1d1dd72" translate="yes" xml:space="preserve">
          <source>A word on distributed agents</source>
          <target state="translated">谈谈分布式代理</target>
        </trans-unit>
        <trans-unit id="be1bb8f888ee7021de890698fb2afa717b6c1550" translate="yes" xml:space="preserve">
          <source>ACC - total time spent in the function</source>
          <target state="translated">ACC ----在该功能中花费的总时间</target>
        </trans-unit>
        <trans-unit id="1afeece78fd2f8c83db0f4140c005969fde50b55" translate="yes" xml:space="preserve">
          <source>AM, PM</source>
          <target state="translated">上午、下午</target>
        </trans-unit>
        <trans-unit id="fcdb408000857fa7b09129071afdc276c3c00665" translate="yes" xml:space="preserve">
          <source>ANSI escapes are typically enabled on all Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command:</source>
          <target state="translated">ANSI转义符通常在所有Unix终端上启用。从Windows 10开始,它们在Windows控制台上也是可用的,不过必须通过运行以下命令在注册表中为当前用户明确启用。</target>
        </trans-unit>
        <trans-unit id="586d4163da04d5ab6791e3c06e9ffe5c9db509ec" translate="yes" xml:space="preserve">
          <source>ANSI escapes in &lt;code&gt;string&lt;/code&gt; are not processed in any way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 中的ANSI转义符不会以任何方式处理。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="7c131b6fb9555cb305f8aaa2c2c98e087084d42b" translate="yes" xml:space="preserve">
          <source>API Reference &lt;small&gt;Mix v1.11.2&lt;/small&gt;</source>
          <target state="translated">API参考&lt;small&gt;混合v1.11.2&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="08955ef48e12709a927739991a3df46487d19807" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于读取使用&lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;定义的配置文件的API 。</target>
        </trans-unit>
        <trans-unit id="1b2a5e26234b2a9ea3b34162d62a110a48636bad" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于读取使用&lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;定义的配置文件的API 。</target>
        </trans-unit>
        <trans-unit id="8b349aa6f5c8405e74e0ce2c3f7201bebe1b4de3" translate="yes" xml:space="preserve">
          <source>AST considerations</source>
          <target state="translated">AST的考虑</target>
        </trans-unit>
        <trans-unit id="722e9952d5c095e4d71bce17445a76597f676acc" translate="yes" xml:space="preserve">
          <source>AST representation</source>
          <target state="translated">AST表示</target>
        </trans-unit>
        <trans-unit id="c3b1354957064f90a14a0b8903ae1bce0e675785" translate="yes" xml:space="preserve">
          <source>Abbreviated month name</source>
          <target state="translated">缩略月名</target>
        </trans-unit>
        <trans-unit id="137c90672799288dc1f78441e61fc461964bf9c8" translate="yes" xml:space="preserve">
          <source>Abbreviated name of day</source>
          <target state="translated">缩写日名称</target>
        </trans-unit>
        <trans-unit id="266c0ed1029b1e5c3251173a36c9d608b25b8d14" translate="yes" xml:space="preserve">
          <source>Aborts when a command exits with a non-zero status.</source>
          <target state="translated">当命令以非零的状态退出时,就会中止。</target>
        </trans-unit>
        <trans-unit id="451a24b564c25a56a12bc821b009bb17521b7976" translate="yes" xml:space="preserve">
          <source>Above, &lt;code&gt;x&lt;/code&gt; matched on only the first byte of the multibyte &lt;code&gt;&amp;uuml;&lt;/code&gt; character.</source>
          <target state="translated">上面的 &lt;code&gt;x&lt;/code&gt; 仅在多字节 &lt;code&gt;&amp;uuml;&lt;/code&gt; 字符的第一个字节上匹配。</target>
        </trans-unit>
        <trans-unit id="fff456f1c782da0b35f8fa5b303ce271025c27f6" translate="yes" xml:space="preserve">
          <source>Abstract Syntax Tree (AST)</source>
          <target state="translated">抽象语法树(AST)</target>
        </trans-unit>
        <trans-unit id="23b0c80e9057a10f37a2f52e111994951df16105" translate="yes" xml:space="preserve">
          <source>Accepted formats</source>
          <target state="translated">接受的格式</target>
        </trans-unit>
        <trans-unit id="c4bbf6c7d04ca5c93be2107e4482d4ce88d69909" translate="yes" xml:space="preserve">
          <source>Accepted padding options</source>
          <target state="translated">接受的填充选项</target>
        </trans-unit>
        <trans-unit id="16d98934b253153ce90ef5967a4ab32ed934fb4d" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;ignore: :whitespace&lt;/code&gt; option which will ignore all the whitespace characters in the input string.</source>
          <target state="translated">接受 &lt;code&gt;ignore: :whitespace&lt;/code&gt; 选项，它将忽略输入字符串中的所有空白字符。</target>
        </trans-unit>
        <trans-unit id="ff9572ac36a4e1f1c2d3b6e7fe1206f556bcd6be" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will ignore padding from the input string.</source>
          <target state="translated">接受 &lt;code&gt;padding: false&lt;/code&gt; 选项，它将忽略输入字符串中的padding。</target>
        </trans-unit>
        <trans-unit id="e6606a70939f51500cf29d0104ea455b8e57bbbd" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will omit padding from the output string.</source>
          <target state="translated">接受 &lt;code&gt;padding: false&lt;/code&gt; 选项，它将省略输出字符串中的padding。</target>
        </trans-unit>
        <trans-unit id="d11f73644b7b3add855698ef69a041b85cac741e" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located.</source>
          <target state="translated">接受 &lt;code&gt;relative_to&lt;/code&gt; 作为参数来告诉文件位于何处。</target>
        </trans-unit>
        <trans-unit id="312c5b592fe6d7dd571d6c8037a1f4c663f75282" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located. If the file was already required, &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; doesn't do anything and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">接受 &lt;code&gt;relative_to&lt;/code&gt; 作为参数来告诉文件位于何处。如果已经需要该文件，则&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;不执行任何操作，并返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a8f51a20bef3da7c165ebe3b333dbb26c7d054f" translate="yes" xml:space="preserve">
          <source>Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms.</source>
          <target state="translated">接受一个原子形式的块或一元函数的名称,或一个这样的原子列表。</target>
        </trans-unit>
        <trans-unit id="8001c91fcbcc7035c433992b44685f5330523f6b" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c68ab20eebd551a8183d8a271c2a11f2f59f798e" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take 6 arguments:</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。该函数必须采用6个参数：</target>
        </trans-unit>
        <trans-unit id="7bebfa805f9fa42810edbee6281c1119c222c690" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be &lt;code&gt;__after_compile__/2&lt;/code&gt;.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。该函数必须采用两个参数：模块环境及其字节码。仅提供模块时，该函数假定为 &lt;code&gt;__after_compile__/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e8eec1dc724492ff94d0553bb6ff5b22253d396" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 元组。函数/宏必须带有一个参数：模块环境。如果是宏，则其返回值将在编译开始之前在模块定义的末尾注入。</target>
        </trans-unit>
        <trans-unit id="b8a02787b1528282c9b913825c8890849c97b169" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@doc false&lt;/code&gt; will make the entity invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">接受字符串（通常为heredoc）或 &lt;code&gt;false&lt;/code&gt; ，其中 &lt;code&gt;@doc false&lt;/code&gt; 将使该实体对于诸如&lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; 之&lt;/a&gt;类的文档提取工具不可见。例如：</target>
        </trans-unit>
        <trans-unit id="e201112d9033197e821f8bcdf23e660e950b4fd3" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@moduledoc false&lt;/code&gt; will make the module invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受字符串（通常为heredoc）或 &lt;code&gt;false&lt;/code&gt; ，其中 &lt;code&gt;@moduledoc false&lt;/code&gt; 将使该模块对诸如&lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; 之&lt;/a&gt;类的文档提取工具不可见。</target>
        </trans-unit>
        <trans-unit id="ca7b2060d47af260a69b6e20f3d794d68fe54093" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">以 &lt;code&gt;amount_to_add&lt;/code&gt; &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 接受amount_to_add。负值将在时间上向后移动。</target>
        </trans-unit>
        <trans-unit id="a5cd37e51e05c989f61c56fcc8057339b69ee344" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">以 &lt;code&gt;amount_to_add&lt;/code&gt; &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 接受amount_to_add。负值将在时间上向后移动。</target>
        </trans-unit>
        <trans-unit id="9c7e182b3105eb309155a16cd4d01036199f0e2d" translate="yes" xml:space="preserve">
          <source>Accepts an atom, a tuple, or a list of atoms and tuples. For example:</source>
          <target state="translated">接受一个原子、一个元组或一个原子和元组的列表。例如:</target>
        </trans-unit>
        <trans-unit id="3e6f11dba90273a10068990877edcdfb26f22547" translate="yes" xml:space="preserve">
          <source>Accepts the function name (as an atom) of a function in the current module or &lt;code&gt;{function_name, 0}&lt;/code&gt; tuple where &lt;code&gt;function_name&lt;/code&gt; is the name of a function in the current module. The function must be public and have an arity of 0 (no arguments). If the function does not return &lt;code&gt;:ok&lt;/code&gt;, the loading of the module will be aborted. For example:</source>
          <target state="translated">接受当前模块中函数的函数名称（作为原子）或 &lt;code&gt;{function_name, 0}&lt;/code&gt; 元组，其中 &lt;code&gt;function_name&lt;/code&gt; 是当前模块中函数的名称。该函数必须是公共函数，且Arity为0（无参数）。如果函数未返回 &lt;code&gt;:ok&lt;/code&gt; ，则模块的加载将被中止。例如：</target>
        </trans-unit>
        <trans-unit id="c1882f04cc0835dbca87fc3529d0d49574c5244e" translate="yes" xml:space="preserve">
          <source>Accepts the same options as &lt;a href=&quot;#read!/2&quot;&gt;&lt;code&gt;read!/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受与&lt;a href=&quot;#read!/2&quot;&gt; &lt;code&gt;read!/2&lt;/code&gt; &lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="16bd460f20e6be8ef8de7ddd09d7916ce4c21b09" translate="yes" xml:space="preserve">
          <source>Accepts the same options as &lt;a href=&quot;#read!/2&quot;&gt;&lt;code&gt;read!/2&lt;/code&gt;&lt;/a&gt;. Although note the &lt;code&gt;:imports&lt;/code&gt; option cannot be disabled in &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受与&lt;a href=&quot;#read!/2&quot;&gt; &lt;code&gt;read!/2&lt;/code&gt; &lt;/a&gt;相同的选项。虽然注意 &lt;code&gt;:imports&lt;/code&gt; &lt;a href=&quot;#read_imports!/2&quot;&gt; &lt;code&gt;read_imports!/2&lt;/code&gt; &lt;/a&gt;不能禁用：imports选项。</target>
        </trans-unit>
        <trans-unit id="2f81a22de0af5e9eab19326e19693f86ce612518" translate="yes" xml:space="preserve">
          <source>Access</source>
          <target state="translated">Access</target>
        </trans-unit>
        <trans-unit id="61eeb1ced62d9d70c3a7da771b7e65111efa9eeb" translate="yes" xml:space="preserve">
          <source>Access &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">访问&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="32cc0e2e72b4a5cd8e1d10f3088022c273757f9c" translate="yes" xml:space="preserve">
          <source>Access syntax</source>
          <target state="translated">访问语法</target>
        </trans-unit>
        <trans-unit id="ffaea95d2c8c2a121901ac8053918362a2259c0d" translate="yes" xml:space="preserve">
          <source>Accesses an already bound variable in match clauses. Also known as the pin operator.</source>
          <target state="translated">访问匹配子句中已经绑定的变量。也称为pin操作符。</target>
        </trans-unit>
        <trans-unit id="114bded9b29083adea70f97a0e2b9cca28f2f55b" translate="yes" xml:space="preserve">
          <source>Accessing and updating structs</source>
          <target state="translated">访问和更新结构</target>
        </trans-unit>
        <trans-unit id="d92e8c05ab3b611d5a9111ea714f7aba0dcfee85" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">不建议在营救/捕获之外访问stacktrace。如果只想支持Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; +，则必须在救援/捕获中访问__STACKTRACE __ / 0。如果您想支持早期的Elixir版本，请将&lt;a href=&quot;#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; &lt;/a&gt;移到急救/捕获中。</target>
        </trans-unit>
        <trans-unit id="778701a39f61d1d0d376ec6add6756493d3c6f48" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;system#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">不建议在营救/捕获之外访问stacktrace。如果只想支持Elixir &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; +，则必须在救援/捕获中访问__STACKTRACE __ / 0。如果您想支持早期的Elixir版本，请将&lt;a href=&quot;system#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; &lt;/a&gt;移到急救/捕获中。</target>
        </trans-unit>
        <trans-unit id="c08435b6ee1c53e0f3db32fa2d67cb282966fb48" translate="yes" xml:space="preserve">
          <source>According to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table. Since this is a race condition, you may not be able to reproduce it on your machine, but it is there.</source>
          <target state="translated">根据失败消息,我们期待的是表上已经不存在 bucket 了,但它还是存在的!这就是我们刚刚解决的问题:以前创建 bucket 的命令和更新表之间有延迟,现在 bucket 进程死亡和它的条目被从表上删除之间有延迟。这个问题与我们刚刚解决的问题正好相反:之前在创建bucket的命令和更新表之间有延迟,而现在在bucket进程死亡和它的条目从表上删除之间有延迟。由于这是一个竞赛条件,你可能无法在你的机器上重现,但它是存在的。</target>
        </trans-unit>
        <trans-unit id="f82c99de451613d4c3468e6d7fc04fc56efcc179" translate="yes" xml:space="preserve">
          <source>Actually expands to:</source>
          <target state="translated">其实扩展到。</target>
        </trans-unit>
        <trans-unit id="202286aca5e6c6b464a262fb2ffaeb8e0a69b604" translate="yes" xml:space="preserve">
          <source>Adding a backend calls the &lt;code&gt;init/1&lt;/code&gt; function in that backend with the name of the backend as its argument. For example, calling</source>
          <target state="translated">添加一个后端将以该后端的名称作为其参数调用该后端中的 &lt;code&gt;init/1&lt;/code&gt; 函数。例如，打电话</target>
        </trans-unit>
        <trans-unit id="9e4e792ab5793275266dbf12ecb483ea47d35fb1" translate="yes" xml:space="preserve">
          <source>Adding explicit parentheses is enough to bind the block to &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">添加显式括号足以将块绑定到 &lt;code&gt;if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b78cd7b823ca5c0a3d8b8957b6fa3d25e3152ce" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">此外，&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;会将所有AST的所有出现转换为 &lt;code&gt;left not in right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be05b1119a34ef95ba3623420677cc256aa4984b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">此外，&lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;会将所有AST的所有出现转换为 &lt;code&gt;left not in right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9250bc8f269bb31b837fb16fb14515407c5ad27" translate="yes" xml:space="preserve">
          <source>Additionally, it documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="translated">此外，它记录了两种特殊形式&lt;a href=&quot;#__block__/1&quot;&gt; &lt;code&gt;__block__/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt;，它们不希望开发人员直接调用，但它们出现在引用的内容中，因为它们在Elixir的构造中必不可少。</target>
        </trans-unit>
        <trans-unit id="084086258188a6f83f3c0621f1d91c6afb01428b" translate="yes" xml:space="preserve">
          <source>Additionally, the following functions and operators for lists are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此外，在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中可以找到以下列表的函数和运算符：</target>
        </trans-unit>
        <trans-unit id="b78d4c95ca68cd548509bceede9d001db1a210fc" translate="yes" xml:space="preserve">
          <source>Additionally, the following scope values can be configured:</source>
          <target state="translated">此外,还可以配置以下范围值。</target>
        </trans-unit>
        <trans-unit id="2e4dc66f0bc20a88e0f32abc42201d155226df5e" translate="yes" xml:space="preserve">
          <source>Additionally, there are a few other operators that Elixir parses but doesn't actually use. See &lt;a href=&quot;#custom-and-overridden-operators&quot;&gt;Custom and overridden operators&lt;/a&gt; below for a list and for guidelines about their use.</source>
          <target state="translated">此外，Elixir还解析了其他一些运算符，但实际上并未使用。有关列表及其使用准则，请参阅下面的&amp;ldquo;&lt;a href=&quot;#custom-and-overridden-operators&quot;&gt;自定义和重写的运算符&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6de0ba362d2990726a5406d543d6c577cd47aac" translate="yes" xml:space="preserve">
          <source>Adds a callback that runs after a given compiler.</source>
          <target state="translated">添加一个回调,在给定的编译器之后运行。</target>
        </trans-unit>
        <trans-unit id="edc18d92bf1b07aac7b2b79037d7ed0c830219fc" translate="yes" xml:space="preserve">
          <source>Adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">将子级规范添加到 &lt;code&gt;supervisor&lt;/code&gt; 并启动该子级。</target>
        </trans-unit>
        <trans-unit id="af3a79b1bbb83ca34755ad54eebe67e43975dc73" translate="yes" xml:space="preserve">
          <source>Adds a new backend.</source>
          <target state="translated">增加了一个新的后台。</target>
        </trans-unit>
        <trans-unit id="4547e3e08756cb2ef5ae23175de234a94738c653" translate="yes" xml:space="preserve">
          <source>Adds a new translator.</source>
          <target state="translated">增加了一个新的翻译器。</target>
        </trans-unit>
        <trans-unit id="9653b7fdeddd56fa913d9c1e6e4dd46142fe6bb5" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将指定的时间量添加到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fefe8eff4657ca8af82a86c4c01dcdded8f65fb" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将指定的时间量添加到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b33fc73fd1c20e1aa238dde8be82279974905542" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;number&lt;/code&gt; of &lt;code&gt;unit&lt;/code&gt;s to the given &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">增加了 &lt;code&gt;number&lt;/code&gt; 的 &lt;code&gt;unit&lt;/code&gt; s到给定的 &lt;code&gt;time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad9a4469809cf0d6f045e57922aa36fef739da3f" translate="yes" xml:space="preserve">
          <source>Adds the number of days to the given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">将天数与给定 &lt;code&gt;date&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="789089ca60682ff54ac072e501a17b9c7a45b283" translate="yes" xml:space="preserve">
          <source>Adopting a behaviour is straightforward:</source>
          <target state="translated">采用一种行为是直接的。</target>
        </trans-unit>
        <trans-unit id="3aa1232b05d45b3e4a3b9d5865607daf60ef5d9b" translate="yes" xml:space="preserve">
          <source>Adopting behaviours</source>
          <target state="translated">采纳行为</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="9ffdfdf4928b7893065d8f9388d98cfc7e4718e4" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;IO.write/2&lt;/code&gt;, we can see the request sent by the &lt;code&gt;IO&lt;/code&gt; module (a four-elements tuple) printed out. Soon after that, we see that it fails since the &lt;code&gt;IO&lt;/code&gt; module expected some kind of result, which we did not supply.</source>
          <target state="translated">在 &lt;code&gt;IO.write/2&lt;/code&gt; 之后，我们可以看到 &lt;code&gt;IO&lt;/code&gt; 模块（一个四元素元组）发送的请求已打印出来。此后不久，我们发现它失败了，因为 &lt;code&gt;IO&lt;/code&gt; 模块预期会有某种结果，而我们没有提供。</target>
        </trans-unit>
        <trans-unit id="2ddb14dc4a5af806ba7555a5887878788a5f483a" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">编译模块后，使用此模块中的许多功能会引发错误，因为检查运行时数据超出了它们的范围。大部分运行时数据都可以通过附加到每个已编译模块的&lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt;函数进行检查。</target>
        </trans-unit>
        <trans-unit id="83a04e6c0b27ee981def4e7b4af06e562bbb3d2e" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">编译模块后，使用此模块中的许多功能会引发错误，因为检查运行时数据超出了它们的范围。大部分运行时数据都可以通过附加到每个已编译模块的&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt;函数进行检查。</target>
        </trans-unit>
        <trans-unit id="6dcdc4f162ba136a3bc34f25783a0a1ec25d1f72" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;shell&lt;/code&gt; becomes the shell that is returned by &lt;a href=&quot;#shell/0&quot;&gt;&lt;code&gt;shell/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;shell&lt;/code&gt; 成为&lt;a href=&quot;#shell/0&quot;&gt; &lt;code&gt;shell/0&lt;/code&gt; &lt;/a&gt;返回的shell。</target>
        </trans-unit>
        <trans-unit id="015771d68b1b737818fe24be939749860bc0bbd0" translate="yes" xml:space="preserve">
          <source>After closing the pair, zero or more ASCII letters can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with &lt;code&gt;sigil_&lt;/code&gt; where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers:</source>
          <target state="translated">关闭该对之后，可以给出零个或多个ASCII字母作为修饰符。标记以表示为sigil_的无条件调用的形式表示，其中第一个参数是字符串的 &lt;code&gt;sigil_&lt;/code&gt; 内容，第二个参数是修饰符的整数列表：</target>
        </trans-unit>
        <trans-unit id="08a92d7d688a663eb3eb033ee1302c04449e9c25" translate="yes" xml:space="preserve">
          <source>After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:</source>
          <target state="translated">在熟悉了语言的基础知识后,您可能想尝试编写简单的程序。这可以通过将以下Elixir代码放到一个文件中来实现。</target>
        </trans-unit>
        <trans-unit id="a5362624d23008d521bcd0d5c26b23351f7a9875" translate="yes" xml:space="preserve">
          <source>After installation, the escript can be invoked as</source>
          <target state="translated">安装完成后,可以调用的脚本为</target>
        </trans-unit>
        <trans-unit id="fb046b5f9d4fee0d614358484f4e987759694e75" translate="yes" xml:space="preserve">
          <source>After installation, the tasks in the archive are available locally:</source>
          <target state="translated">安装后,存档中的任务可在本地使用。</target>
        </trans-unit>
        <trans-unit id="ef5d6001f62dd7d7ca161d7e6411b62975177f6c" translate="yes" xml:space="preserve">
          <source>After running the command above, you must restart your current console.</source>
          <target state="translated">运行上述命令后,必须重新启动当前的控制台。</target>
        </trans-unit>
        <trans-unit id="5b0b8b87bea42239c7cce2999de90ae444ed1e38" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Note that the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">发送完这两条消息后，我们调用了IEx帮助程序 &lt;code&gt;flush()&lt;/code&gt; ，该函数打印了从端口接收到的所有消息，在本例中，我们返回了&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; world&amp;rdquo;。请注意，消息是二进制的，因为在&lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; 中&lt;/a&gt;打开端口时，我们通过了 &lt;code&gt;:binary&lt;/code&gt; 选项。没有这样的选择，它将产生一个字节列表。</target>
        </trans-unit>
        <trans-unit id="01d3a5404436a56254e32994bb8c7a88df4d1e46" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Notice the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;port#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">发送完这两条消息后，我们调用了IEx帮助程序 &lt;code&gt;flush()&lt;/code&gt; ，它打印了从端口接收到的所有消息，在本例中，我们返回了&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; world&amp;rdquo;。注意消息是二进制的，因为在&lt;a href=&quot;port#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; 中&lt;/a&gt;打开端口时我们通过了 &lt;code&gt;:binary&lt;/code&gt; 选项。如果没有这样的选择，它将产生一个字节列表。</target>
        </trans-unit>
        <trans-unit id="d8c5a6d820a4e4b08554b8cba7d6f0f399ab90d4" translate="yes" xml:space="preserve">
          <source>After the child specification is retrieved, the fields on &lt;code&gt;overrides&lt;/code&gt; are directly applied on the child spec. If &lt;code&gt;overrides&lt;/code&gt; has keys that do not map to any child specification field, an error is raised.</source>
          <target state="translated">检索子规范后， &lt;code&gt;overrides&lt;/code&gt; 中的字段将直接应用于子规范。如果 &lt;code&gt;overrides&lt;/code&gt; 具有未映射到任何子指定字段的键，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="1e6e228112ef9b4259dcc6e0928e5df6bda71427" translate="yes" xml:space="preserve">
          <source>After the parsing is done, we will update our server to dispatch the parsed commands to the &lt;code&gt;:kv&lt;/code&gt; application we built previously.</source>
          <target state="translated">解析完成后，我们将更新服务器，以将解析的命令分派到我们先前构建的 &lt;code&gt;:kv&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="ce3b3ab3e45322474dff11a84ad17efa34605f34" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">创建端口后，我们使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;以消息的形式向其发送了两个命令。第一个命令具有二进制负载&amp;ldquo; hello&amp;rdquo;，第二个命令具有&amp;ldquo; world&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="126c87f3f297e14cbbd86077daaca606cae164a1" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">创建端口后，我们使用&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;以消息的形式向其发送了两个命令。第一个命令的二进制有效载荷为&amp;ldquo; hello&amp;rdquo;，第二个命令的&amp;ldquo; world&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1a727cf7abfa15b42a8b410dabb9bf09752b2748" translate="yes" xml:space="preserve">
          <source>After the supervisor retrieves all child specifications, it proceeds to start its children one by one, in the order they were defined, using the information in the &lt;code&gt;:start&lt;/code&gt; key in the child specification. For our current specification, it will call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;.</source>
          <target state="translated">主管检索完所有子级规范后，将使用子级规范中 &lt;code&gt;:start&lt;/code&gt; 键中的信息，按照定义的顺序逐一启动其子级。对于我们当前的规范，它将调用 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287bb38e4e6cedef8023aef386835e79ed530f95" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">在上述两次导入调用之后，仅&lt;a href=&quot;https://hexdocs.pm/elixir/List.html#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt;将被导入。</target>
        </trans-unit>
        <trans-unit id="5ae1d560c6b4b698d633609ab136df680bf93a49" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;list#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">在上述两次导入调用之后，仅&lt;a href=&quot;list#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt;将被导入。</target>
        </trans-unit>
        <trans-unit id="5d98e7e2a0b904bdc0ce797580a3b0c7291ef112" translate="yes" xml:space="preserve">
          <source>After this function is called, &lt;code&gt;port&lt;/code&gt; will be returned by &lt;a href=&quot;#default_port/1&quot;&gt;&lt;code&gt;default_port/1&lt;/code&gt;&lt;/a&gt; for the given scheme &lt;code&gt;scheme&lt;/code&gt;. Note that this function changes the default port for the given &lt;code&gt;scheme&lt;/code&gt;&lt;em&gt;globally&lt;/em&gt;, meaning for every application.</source>
          <target state="translated">调用此函数后，&lt;a href=&quot;#default_port/1&quot;&gt; &lt;code&gt;default_port/1&lt;/code&gt; &lt;/a&gt;将返回给定方案 &lt;code&gt;scheme&lt;/code&gt; 的 &lt;code&gt;port&lt;/code&gt; 。请注意，此函数会&lt;em&gt;全局&lt;/em&gt;更改给定 &lt;code&gt;scheme&lt;/code&gt; 的默认端口，即针对每个应用程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ce2e6f40299204d94dfc0abf19fa8ab52d6c211" translate="yes" xml:space="preserve">
          <source>Agent</source>
          <target state="translated">Agent</target>
        </trans-unit>
        <trans-unit id="64acf7e2a7590f731f683acd7aa2c04794d8cfee" translate="yes" xml:space="preserve">
          <source>Agents</source>
          <target state="translated">Agents</target>
        </trans-unit>
        <trans-unit id="42dff267934990ba61a679256d1501706a0e086a" translate="yes" xml:space="preserve">
          <source>Agents are a simple abstraction around state.</source>
          <target state="translated">代理是一个围绕状态的简单抽象。</target>
        </trans-unit>
        <trans-unit id="471de3b97e03acd6d8c9e778e9edad48b7ff717f" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">代理在客户端和服务器API之间提供隔离（类似于&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;）。特别是，作为参数传递给对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;函数的调用的函数是在Agent（服务器）内部调用的。这种区别很重要，因为您可能要避免在代理程序内部进行昂贵的操作，因为它们会有效地阻止代理程序，直到满足请求为止。</target>
        </trans-unit>
        <trans-unit id="d487a9a82d7ef9002acb21970078ec8fea1c1465" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">代理在客户端和服务器API之间提供隔离（类似于&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;）。特别是，作为参数传递给对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;函数的调用的函数是在Agent（服务器）内部调用的。这种区别很重要，因为您可能要避免在代理内部进行昂贵的操作，因为它们会有效地阻止代理，直到满足请求为止。</target>
        </trans-unit>
        <trans-unit id="e95c6b8e92e1e60f6213d7958b0da2f180bb6e84" translate="yes" xml:space="preserve">
          <source>Alias shortcut</source>
          <target state="translated">别名快捷方式</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9908d354e7b00c08a0a26e0405d0c3d4105165ab" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">别名是在编译时扩展为原子的构造。别名&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;扩展为原子 &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 。别名必须以ASCII大写字符开头，后跟任何ASCII字母，数字或下划线。别名不支持非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="d5851935f3ef549bdaa12137353f49d219f63837" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">别名是在编译时扩展为原子的构造。别名&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;扩展为原子 &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 。别名必须以ASCII大写字符开头，后跟任何ASCII字母，数字或下划线。别名不支持非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7f30b783a5f1e139f6a5d96cc53a7d69f34c844f" translate="yes" xml:space="preserve">
          <source>Aliases are expanded (if possible) and return atoms</source>
          <target state="translated">扩展别名(如果可能的话)并返回原子。</target>
        </trans-unit>
        <trans-unit id="4a6b274949d1238578afe2d23ab6b398292dddae" translate="yes" xml:space="preserve">
          <source>Aliases are frequently used to define shortcuts. In fact, calling &lt;code&gt;alias&lt;/code&gt; without an &lt;code&gt;:as&lt;/code&gt; option sets the alias automatically to the last part of the module name, for example:</source>
          <target state="translated">别名通常用于定义快捷方式。实际上，不带 &lt;code&gt;:as&lt;/code&gt; 选项调用 &lt;code&gt;alias&lt;/code&gt; 将自动将别名设置为模块名称的最后一部分，例如：</target>
        </trans-unit>
        <trans-unit id="47bc7db39f959bb0d4762319a37898eaad71d649" translate="yes" xml:space="preserve">
          <source>Aliases are represented by an &lt;code&gt;__aliases__&lt;/code&gt; call with each segment separated by dot as an argument:</source>
          <target state="translated">别名用 &lt;code&gt;__aliases__&lt;/code&gt; 调用表示，每个段用点分隔作为参数：</target>
        </trans-unit>
        <trans-unit id="e23b34bcabd70da598f18dfcddb8220122d3216a" translate="yes" xml:space="preserve">
          <source>Aliases are shortcuts or tasks specific to the current project.</source>
          <target state="translated">别名是针对当前项目的快捷方式或任务。</target>
        </trans-unit>
        <trans-unit id="0ce137f58fb14f4c5735e756413156223cbdec1d" translate="yes" xml:space="preserve">
          <source>Aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Clean.html&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="translated">别名也可以用于扩展现有任务。假设您想增加&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Clean.html&quot;&gt; &lt;code&gt;mix clean&lt;/code&gt; &lt;/a&gt;来清理Mix不知道的另一个目录：</target>
        </trans-unit>
        <trans-unit id="dc86688ecfcf9059408582f98b57b9f4cbad8152" translate="yes" xml:space="preserve">
          <source>Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example:</source>
          <target state="translated">别名可以非常强大地用于也运行Elixir脚本和shell命令,例如。</target>
        </trans-unit>
        <trans-unit id="6dd7a63c3cd9394fafd3a4d7cedc21c8e943565f" translate="yes" xml:space="preserve">
          <source>Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.</source>
          <target state="translated">在当前项目中定义的别名不影响其依赖关系,在依赖关系中定义的别名不能从当前项目中访问。</target>
        </trans-unit>
        <trans-unit id="abd1a8b6bae9484ed0f8605fb305658910cefe92" translate="yes" xml:space="preserve">
          <source>Aliases expand to atoms because in the Erlang</source>
          <target state="translated">别名扩展为原子,因为在Erlang的</target>
        </trans-unit>
        <trans-unit id="f82ba68692bccb420e6f34813f0fa1ce8af8c883" translate="yes" xml:space="preserve">
          <source>Aliases inside quote are hygienic by default. Consider the following example:</source>
          <target state="translated">引号内的别名默认是卫生的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="fb42d78167a0f8c042ef1bf76a5e556ce9a643e9" translate="yes" xml:space="preserve">
          <source>Aliases may also be lists, specifying multiple tasks to be run consecutively:</source>
          <target state="translated">别名也可以是列表,指定要连续运行的多个任务。</target>
        </trans-unit>
        <trans-unit id="fb194589028d8ecdd8a81b698121fdd94e9a4477" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常用作模块名称的别名是一个例外，因为它们必须大写并用 &lt;code&gt;CamelCase&lt;/code&gt; 编写，例如&lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt;。对于别名，大写字母保留在首字母缩写词中，例如&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8d1c898fa93e8bcfa2c17a37c421760581f9672" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常用作模块名称的别名是一个例外，因为它们必须大写并用 &lt;code&gt;CamelCase&lt;/code&gt; 编写，例如&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt;。对于别名，大写字母保留在首字母缩写词中，例如&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="493ad9ebd988ff9d7cf101317d6dd33763da348c" translate="yes" xml:space="preserve">
          <source>All Elixir code runs inside processes that communicate with each other. When a process dies of &amp;ldquo;natural causes&amp;rdquo; (e.g., unhandled exceptions), it sends an &lt;code&gt;exit&lt;/code&gt; signal. A process can also die by explicitly sending an &lt;code&gt;exit&lt;/code&gt; signal:</source>
          <target state="translated">所有的Elixir代码都在相互通信的进程中运行。当进程死于&amp;ldquo;自然原因&amp;rdquo;（例如，未处理的异常）时，它将发送 &lt;code&gt;exit&lt;/code&gt; 信号。也可以通过显式发送 &lt;code&gt;exit&lt;/code&gt; 信号来终止进程：</target>
        </trans-unit>
        <trans-unit id="bc3c548d2fd0d5198604c9d4a51b137d915ab1ca" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again.</source>
          <target state="translated">所有的应用程序都被顺利拿下,所有的代码被卸载,所有的端口被关闭,系统才会再次启动所有的应用程序。</target>
        </trans-unit>
        <trans-unit id="32c3b583cda24a964ba5c0b1c5db5a5180eab7bc" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在系统通过调用&lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt;终止之前，所有应用程序均顺利关闭，所有代码均已卸载，并且所有端口都已关闭。</target>
        </trans-unit>
        <trans-unit id="ea13d46d1a7a005cc3e73f0e566c97f99798c880" translate="yes" xml:space="preserve">
          <source>All arguments, except the first, are guaranteed to be atoms.</source>
          <target state="translated">除第一个参数外,其他参数都保证是原子。</target>
        </trans-unit>
        <trans-unit id="a450b0f803f6ae1fce87a01c5eeb4990d00edaa1" translate="yes" xml:space="preserve">
          <source>All available modes are discussed below.</source>
          <target state="translated">下面将讨论所有可用的模式。</target>
        </trans-unit>
        <trans-unit id="8a205f1c716c887255b02393e7cb3d73d2a1cc6f" translate="yes" xml:space="preserve">
          <source>All bitwise functions can be used in guards:</source>
          <target state="translated">所有的位元函数都可以在卫士中使用。</target>
        </trans-unit>
        <trans-unit id="c4c9708ca0238b22e7c13c00b06e3da882c3696d" translate="yes" xml:space="preserve">
          <source>All bitwise functions work only on integers; otherwise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">所有按位函数仅适用于整数。否则引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0506e345cce0be172d12fdeec69c477b8538823" translate="yes" xml:space="preserve">
          <source>All bitwise macros can be used in guards:</source>
          <target state="translated">所有的位元宏都可以在卫士中使用。</target>
        </trans-unit>
        <trans-unit id="b23070b414d2fa6a5985bf7370f737d23a7cab53" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下面的所有配置都可以通过配置文件（例如 &lt;code&gt;config/config.exs&lt;/code&gt; ）进行设置，但也可以在运行时通过&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; 进行&lt;/a&gt;动态更改。</target>
        </trans-unit>
        <trans-unit id="7f24df6aca6fef7279aa46c984d854c8399f1b8a" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;logger#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过配置文件（例如 &lt;code&gt;config/config.exs&lt;/code&gt; ）设置以下所有配置，但也可以在运行时通过&lt;a href=&quot;logger#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; &lt;/a&gt;动态更改。</target>
        </trans-unit>
        <trans-unit id="f86cb886460af2d7afbabd4518c2a4ae8d572dd7" translate="yes" xml:space="preserve">
          <source>All configuration for Xref should be placed under the key &lt;code&gt;:xref&lt;/code&gt;.</source>
          <target state="translated">Xref的所有配置都应放在键 &lt;code&gt;:xref&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="71cd59b6f93fc3e7ecfe59f630540043ab20c0b6" translate="yes" xml:space="preserve">
          <source>All dependencies are automatically recompiled after update.</source>
          <target state="translated">所有的依赖关系在更新后会自动重新编译。</target>
        </trans-unit>
        <trans-unit id="7e0d2ee2fbfbf3acfd326c27d7a8c9cdf22d871f" translate="yes" xml:space="preserve">
          <source>All duplicated keys are removed. See &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; for removing only the first entry.</source>
          <target state="translated">删除所有重复的密钥。请参阅&lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt;仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="962493e8f49621899a7a8fb10598ca516db9a007" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 中的所有元素都必须可转换为二进制，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="62d126d7fed26d3474d703ba63d0072a8589e3cc" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a string, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 中的所有元素都必须可转换为字符串，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="75780da216d4a9fe9a0de4cd507f0ecf910086a9" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">调用 &lt;code&gt;mapper&lt;/code&gt; 返回的所有元素都必须可转换为二进制，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="d0e64b00e325d388a4149fd69452dd2198b576ec" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a string, otherwise an error is raised.</source>
          <target state="translated">调用 &lt;code&gt;mapper&lt;/code&gt; 返回的所有元素都必须可转换为字符串，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="a81afb8178e29a9385a90fd94857e3690f36f499" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">所有向模板输出内容的表达式都&lt;strong&gt;必须&lt;/strong&gt;使用等号（ &lt;code&gt;=&lt;/code&gt; ）。由于Elixir中的所有内容都是表达式，因此该规则没有例外。例如，虽然某些模板语言将特殊使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;子句，但在EEx中将它们视为相同，并且也需要 &lt;code&gt;=&lt;/code&gt; 才能打印其结果：</target>
        </trans-unit>
        <trans-unit id="e209a7fdf9ec613b8d4f8cfecf15e0dabebad2c5" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;code&gt;if&lt;/code&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">所有向模板输出内容的表达式都&lt;strong&gt;必须&lt;/strong&gt;使用等号（ &lt;code&gt;=&lt;/code&gt; ）。由于Elixir中的所有内容都是表达式，因此该规则没有例外。例如，虽然某些模板语言会特殊使用 &lt;code&gt;if&lt;/code&gt; 子句，但在EEx中将它们视为相同，并且也需要 &lt;code&gt;=&lt;/code&gt; 才能打印其结果：</target>
        </trans-unit>
        <trans-unit id="64dc310c834981873443bb0c895820130d8003ed" translate="yes" xml:space="preserve">
          <source>All functions in this module accept EEx-related options. They are:</source>
          <target state="translated">本模块中的所有函数都接受与 EEx 相关的选项。它们是:</target>
        </trans-unit>
        <trans-unit id="b894afac8aa8f48058b57f650cf4e765dcf379d8" translate="yes" xml:space="preserve">
          <source>All functions in this module are inlined by the compiler.</source>
          <target state="translated">本模块中的所有函数都由编译器内联。</target>
        </trans-unit>
        <trans-unit id="1f14031fee2bc02634aba88d8e6180547c70d0ae" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;, overriding any existing one (i.e., the keys in &lt;code&gt;map2&lt;/code&gt; &quot;have precedence&quot; over the ones in &lt;code&gt;map1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 中的所有键都将添加到 &lt;code&gt;map1&lt;/code&gt; 中，从而覆盖任何现有的键（即 &lt;code&gt;map2&lt;/code&gt; 中的键&amp;ldquo;具有优先于 &lt;code&gt;map1&lt;/code&gt; 中的键&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="c4382006c46118de92713063dd12ca0d2391ea22" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;. The given function will be invoked when there are duplicate keys; its arguments are &lt;code&gt;key&lt;/code&gt; (the duplicate key), &lt;code&gt;value1&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map1&lt;/code&gt;), and &lt;code&gt;value2&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map2&lt;/code&gt;). The value returned by &lt;code&gt;fun&lt;/code&gt; is used as the value under &lt;code&gt;key&lt;/code&gt; in the resulting map.</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 中的所有键都将添加到 &lt;code&gt;map1&lt;/code&gt; 中。当有重复的键时，将调用给定的函数；它的参数是 &lt;code&gt;key&lt;/code&gt; （重复键）， &lt;code&gt;value1&lt;/code&gt; （价值 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map1&lt;/code&gt; ），和 &lt;code&gt;value2&lt;/code&gt; （价值 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map2&lt;/code&gt; ）。 &lt;code&gt;fun&lt;/code&gt; 返回的值用作结果映射中 &lt;code&gt;key&lt;/code&gt; 下的值。</target>
        </trans-unit>
        <trans-unit id="81067fca2a4826fa2b861dc9ccff01a040457240" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;, overriding any existing one.</source>
          <target state="translated">&lt;code&gt;keywords2&lt;/code&gt; 给出的所有关键字（包括重复的关键字）都将添加到 &lt;code&gt;keywords1&lt;/code&gt; ，从而覆盖所有现有关键字。</target>
        </trans-unit>
        <trans-unit id="e2c2426bd83d495cefd1511dd9e29d2650392f21" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;. The given function will be invoked to solve conflicts.</source>
          <target state="translated">&lt;code&gt;keywords2&lt;/code&gt; 给出的所有关键字（包括重复的关键字）都将添加到 &lt;code&gt;keywords1&lt;/code&gt; 。给定的函数将被调用以解决冲突。</target>
        </trans-unit>
        <trans-unit id="5e5fd7c77cbce8d2bd6aeafdabf4cfeac9e29a80" translate="yes" xml:space="preserve">
          <source>All modifiers listed above can be combined; repeated modifiers in &lt;code&gt;modifiers&lt;/code&gt; will be ignored.</source>
          <target state="translated">上面列出的所有修饰语都可以组合使用；修饰符中重复的 &lt;code&gt;modifiers&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="e93bb97d241121b4f4dee22d57fba8b3e522ddbd" translate="yes" xml:space="preserve">
          <source>All of the configuration defined in &lt;code&gt;config/config.exs&lt;/code&gt; will be included as part of the escript. &lt;code&gt;config/runtime.exs&lt;/code&gt;is also included for Elixir escripts. Once the configuration is loaded, this task starts the current application. If this is not desired, set the &lt;code&gt;:app&lt;/code&gt; configuration to nil.</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; 中定义的所有配置都将作为escript的一部分包括在内。 &lt;code&gt;config/runtime.exs&lt;/code&gt; 也包含在Elixir脚本中。加载配置后，此任务将启动当前应用程序。如果不希望这样，请将 &lt;code&gt;:app&lt;/code&gt; 配置设置为nil。</target>
        </trans-unit>
        <trans-unit id="c9db69ff5fd80f1c32d968ebb750da1bd96e5703" translate="yes" xml:space="preserve">
          <source>All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that &quot;desugar&quot; to one of the constructs explored above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence.</source>
          <target state="translated">以上所有的构造都是Elixir语法的一部分,并有自己的表示,作为Elixir AST的一部分。本节将讨论其余的构造,这些构造 &quot;去糖 &quot;到上面探讨的其中一个构造。换句话说,下面的构造可以在你的Elixir代码中以一种以上的方式表示,并保留AST的等价性。</target>
        </trans-unit>
        <trans-unit id="efecbd33be6692e33153d5c191da2fd42dffe301" translate="yes" xml:space="preserve">
          <source>All operators in Elixir are also valid atoms. Valid examples are &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:FOO&lt;/code&gt;, &lt;code&gt;:foo_42&lt;/code&gt;, &lt;code&gt;:foo@bar&lt;/code&gt;, and &lt;code&gt;:++&lt;/code&gt;. Invalid examples are &lt;code&gt;:@foo&lt;/code&gt; (&lt;code&gt;@&lt;/code&gt; is not allowed at start), &lt;code&gt;:123&lt;/code&gt; (numbers are not allowed at start), and &lt;code&gt;:(*)&lt;/code&gt; (not a valid operator).</source>
          <target state="translated">Elixir中的所有运算符也是有效原子。有效的示例是 &lt;code&gt;:foo&lt;/code&gt; ， &lt;code&gt;:FOO&lt;/code&gt; ， &lt;code&gt;:foo_42&lt;/code&gt; ， &lt;code&gt;:foo@bar&lt;/code&gt; 和 &lt;code&gt;:++&lt;/code&gt; 。无效的示例包括 &lt;code&gt;:@foo&lt;/code&gt; （在开始处不允许 &lt;code&gt;@&lt;/code&gt; ）、: &lt;code&gt;:123&lt;/code&gt; （在开始处不允许数字）和 &lt;code&gt;:(*)&lt;/code&gt; （无效的运算符）。</target>
        </trans-unit>
        <trans-unit id="a68a6061ed529e7321fbab2a1e1466c173d56718" translate="yes" xml:space="preserve">
          <source>All terms in Elixir can be compared with each other.</source>
          <target state="translated">Elixir的所有术语都可以相互比较。</target>
        </trans-unit>
        <trans-unit id="cd8a32aefda3f349478b8a4289ce78ffc774e378" translate="yes" xml:space="preserve">
          <source>All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests:</source>
          <target state="translated">所有测试都会收到一个上下文作为参数。上下文对于回调和测试之间的信息共享特别有用。</target>
        </trans-unit>
        <trans-unit id="46f1e0081d7ff3ef1598ee1f4611d0858df9a878" translate="yes" xml:space="preserve">
          <source>All tests start with a state of &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">所有测试 &lt;code&gt;nil&lt;/code&gt; 状态开始。</target>
        </trans-unit>
        <trans-unit id="471fbe4680a438c1f34492b7155396825fbf6e7e" translate="yes" xml:space="preserve">
          <source>All the functions in the &lt;code&gt;Enum&lt;/code&gt; module are eager. Many functions expect an enumerable and return a list back:</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 模块中的所有功能都非常渴望。许多函数需要一个可枚举的对象并返回列表：</target>
        </trans-unit>
        <trans-unit id="ad97f344ca26467cc845b62f0e8a053c5eb38fe0" translate="yes" xml:space="preserve">
          <source>All the values of caller functions describe the marked function. For example, the first row means that &lt;code&gt;Mod.caller1/0&lt;/code&gt; invoked &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3 times. 200ms of the total time spent in &lt;code&gt;Mod.some_function/0&lt;/code&gt; was spent processing calls from this particular caller.</source>
          <target state="translated">调用者函数的所有值都描述了标记的函数。例如，第一行表示 &lt;code&gt;Mod.caller1/0&lt;/code&gt; 调用了 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3次。在 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 中花费的总时间中有200毫秒用于处理来自此特定呼叫者的呼叫。</target>
        </trans-unit>
        <trans-unit id="ab62fee1181d53e168d5ddca4b76c2a3f0f14d49" translate="yes" xml:space="preserve">
          <source>All these macros are public macros (as defined by &lt;code&gt;defmacro&lt;/code&gt;).</source>
          <target state="translated">所有这些宏都是公共宏（由 &lt;code&gt;defmacro&lt;/code&gt; 定义）。</target>
        </trans-unit>
        <trans-unit id="34f3030dbffbd799437c8acd75092b93db7172e2" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses.</source>
          <target state="translated">允许在防护条款中使用。</target>
        </trans-unit>
        <trans-unit id="16b8d71f3125091140d0f8672105255771ac2803" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses. Inlined by the compiler.</source>
          <target state="translated">允许在保护子句中使用。由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="translated">允许在防护试验中。</target>
        </trans-unit>
        <trans-unit id="af6c8de133dbdc2f69863328f74fb83aacfb7360" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests. Inlined by the compiler.</source>
          <target state="translated">允许在防护测试中使用。由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="2b173cc6a1f043289cd7c3164ac03625499e4950" translate="yes" xml:space="preserve">
          <source>Allows a developer to customize the using block when the case template is used.</source>
          <target state="translated">允许开发者在使用案例模板时自定义使用块。</target>
        </trans-unit>
        <trans-unit id="ce229aa087121abe44456ef91f4d85fd2c83436e" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;cprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 中对表达式执行 &lt;code&gt;cprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="36e890e59c1727dd986c090acbf3706458233a86" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;eprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 上对表达式执行 &lt;code&gt;eprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="cec7e6385a65f90ce774de5cfa85e6c67d629db7" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;fprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 中对表达式运行 &lt;code&gt;fprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="9fb76106047518ce4fb611a343f5cfc33db811df" translate="yes" xml:space="preserve">
          <source>Alongside the observer application, Erlang also includes a &lt;code&gt;:crashdump_viewer&lt;/code&gt; to view crash dumps</source>
          <target state="translated">除了观察者应用程序之外，Erlang还包括 &lt;code&gt;:crashdump_viewer&lt;/code&gt; 来查看故障转储。</target>
        </trans-unit>
        <trans-unit id="7b9345037b9e6e5f6f050e0e1c3ba89d21df3bda" translate="yes" xml:space="preserve">
          <source>Alphanumeric characters: &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;</source>
          <target state="translated">字母数字字符： &lt;code&gt;A-Z&lt;/code&gt; ， &lt;code&gt;a-z&lt;/code&gt; ， &lt;code&gt;0-9&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc66c0fdb05c288a2d0be6731b80e56ea10955b8" translate="yes" xml:space="preserve">
          <source>Also note that Erlang&amp;rsquo;s formatting functions require special attention to Unicode handling.</source>
          <target state="translated">还要注意，Erlang的格式化功能需要特别注意Unicode处理。</target>
        </trans-unit>
        <trans-unit id="25e5fdf8b80ad209b572bf379ee2d97f709f491c" translate="yes" xml:space="preserve">
          <source>Also note the &lt;code&gt;async: true&lt;/code&gt; option passed to &lt;code&gt;ExUnit.Case&lt;/code&gt;. This option makes the test case run in parallel with other &lt;code&gt;:async&lt;/code&gt; test cases by using multiple cores in our machine. This is extremely useful to speed up our test suite. However, &lt;code&gt;:async&lt;/code&gt; must &lt;em&gt;only&lt;/em&gt; be set if the test case does not rely on or change any global values. For example, if the test requires writing to the filesystem or access a database, keep it synchronous (omit the &lt;code&gt;:async&lt;/code&gt; option) to avoid race conditions between tests.</source>
          <target state="translated">还要注意传递给 &lt;code&gt;ExUnit.Case&lt;/code&gt; 的 &lt;code&gt;async: true&lt;/code&gt; 选项。通过使用我们计算机中的多个内核，此选项可使测试用例与其他 &lt;code&gt;:async&lt;/code&gt; 测试用例并行运行。这对于加快我们的测试套件非常有用。然而， &lt;code&gt;:async&lt;/code&gt; 必须&lt;em&gt;只&lt;/em&gt;进行，如果测试情况下不依赖于或更改任何全局值设置。例如，如果测试需要写入文件系统或访问数据库，则使其保持同步（忽略 &lt;code&gt;:async&lt;/code&gt; 选项），以避免测试之间的竞争状况。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99f95b6ecaf40ea41137c6dd421e917e63ab648f" translate="yes" xml:space="preserve">
          <source>Also, keep in mind that profiling might significantly increase the running time of the profiled processes. This might skew your results if, for example, those processes perform some I/O operations, since running time of those operations will remain unchanged, while CPU bound operations of the profiled processes might take significantly longer. Thus, when profiling some intensive program, try to reduce such dependencies, or be aware of the resulting bias.</source>
          <target state="translated">此外,请记住,剖析可能会大大增加剖析进程的运行时间。例如,如果这些进程执行了一些I/O操作,这可能会扭曲你的结果,因为这些操作的运行时间将保持不变,而被剖析的进程的CPU绑定操作可能需要更长的时间。因此,在剖析一些密集型程序时,尽量减少这种依赖性,或者注意由此产生的偏差。</target>
        </trans-unit>
        <trans-unit id="92516fadfd2f18efb90c2a6ec6fde01d43c3b8e5" translate="yes" xml:space="preserve">
          <source>Also, note that we started the documentation string using &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt;. The &lt;code&gt;~S&lt;/code&gt; prevents the &lt;code&gt;\r\n&lt;/code&gt; characters from being converted to a carriage return and line feed until they are evaluated in the test.</source>
          <target state="translated">另外请注意，我们开始使用文档字符串 &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt; 。在 &lt;code&gt;~S&lt;/code&gt; 防止 &lt;code&gt;\r\n&lt;/code&gt; 字符被转换为一个回车和换行，直到它们在试验进行评价。</target>
        </trans-unit>
        <trans-unit id="48be7d4f57a1ff8c0c8de01d6b7c49d0f740172b" translate="yes" xml:space="preserve">
          <source>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</source>
          <target state="translated">在同步和异步模式之间交替使用,以便在需要时保持性能,但在压力下也能施加背压。</target>
        </trans-unit>
        <trans-unit id="56a32fedc781d04589b1e27a4190731f2b801a94" translate="yes" xml:space="preserve">
          <source>Alternatively to pattern matching, filters can be used to select some particular elements. For example, we can select the multiples of 3 and discard all others:</source>
          <target state="translated">除了模式匹配,还可以使用过滤器来选择一些特定的元素。例如,我们可以选择3的倍数,而放弃所有其他元素。</target>
        </trans-unit>
        <trans-unit id="738072000214e7dd8d85de9d3d93ddc937487ae4" translate="yes" xml:space="preserve">
          <source>Alternatively, Elixir allows a developer to pass pairs of name/arities to &lt;code&gt;:only&lt;/code&gt; or &lt;code&gt;:except&lt;/code&gt; as a fine grained control on what to import (or not):</source>
          <target state="translated">另外，Elixir允许开发人员将成对的名称/别名传递给 &lt;code&gt;:only&lt;/code&gt; 或 &lt;code&gt;:except&lt;/code&gt; ,作为对导入（或不导入）内容的精细控制：</target>
        </trans-unit>
        <trans-unit id="36ad95769db69aaf7f63f387429da94f20ab6a71" translate="yes" xml:space="preserve">
          <source>Alternatively, since doctest results are actually evaluated, you can have the MapSet building expression as the doctest result:</source>
          <target state="translated">另外,由于doctest的结果实际上是被评估的,你可以让MapSet构建表达式作为doctest的结果。</target>
        </trans-unit>
        <trans-unit id="520fd3033d5bc943230748094ad592f85a64e858" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">或者，可以通过传递 &lt;code&gt;stops&lt;/code&gt; 参数来增加停止的数量。&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt;可用于将数字重置为零。请注意，即使在所有断点上的所有停止都被消耗之后，该模块仍处于&amp;ldquo;仪表&amp;rdquo;状态。您可以通过调用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt;来删除给定模块中的工具，而可以通过调用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; &lt;/a&gt;来删除所有模块中的工具。</target>
        </trans-unit>
        <trans-unit id="6f1d115c4cc71092e4215eb5349ece403f7a97dc" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">或者，可以通过传递 &lt;code&gt;stops&lt;/code&gt; 参数来增加停止的数量。&lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt;可用于将数字重置为零。请注意，即使在所有断点上的所有停止都被消耗之后，模块仍处于&amp;ldquo;仪表&amp;rdquo;状态。您可以通过调用&lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt;删除给定模块中的检测，并通过调用&lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; 删除&lt;/a&gt;所有模块中的检测。</target>
        </trans-unit>
        <trans-unit id="7cc0d6b358d92b06480447a0e7b647b01a1915a4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also bundle the compiled object files in the release, as long as they were compiled for the same target. If doing so, you need to update &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable with the paths containing the bundled objects on Unix-like systems or the &lt;code&gt;PATH&lt;/code&gt; environment variable on Windows systems.</source>
          <target state="translated">或者，您也可以在发行版中捆绑已编译的目标文件，只要它们是针对同一目标编译的。如果这样做，则需要使用类Unix系统上的包含捆绑对象的路径或Windows系统上的 &lt;code&gt;PATH&lt;/code&gt; 环境变量来更新 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="bd5ba0c8b5719d085aa77f348942d4ad38576999" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;在您无法控制的给定模块，功能和特性上设置断点。虽然&lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;更灵活，但它不包含有关源代码中的导入和别名的信息。</target>
        </trans-unit>
        <trans-unit id="7f6b64d93c6e1bd876f47c2efd90152e6697540d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;在您无法控制的给定模块，功能和特性上设置断点。尽管&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;更加灵活，但它不包含有关源代码中的导入和别名的信息。</target>
        </trans-unit>
        <trans-unit id="4d79671dc1ec87eb565237239995efff47dca0e9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can view a string&amp;rsquo;s binary representation by using &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt;:</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect / 2&lt;/a&gt;查看字符串的二进制表示形式：</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="b0a8089f58c0c54576c2250b325fc6b97e8e0b35" translate="yes" xml:space="preserve">
          <source>Alters the current process metadata according the given keyword list.</source>
          <target state="translated">根据给定的关键字列表改变当前进程元数据。</target>
        </trans-unit>
        <trans-unit id="6b160e130daad190a032bd2c82f16a239367a706" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">改变下存储的值 &lt;code&gt;key&lt;/code&gt; 到 &lt;code&gt;value&lt;/code&gt; ，但只有当进入 &lt;code&gt;key&lt;/code&gt; 在已经存在 &lt;code&gt;keywords&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9aed7587419c22040987ccddf36342ed35dbbef" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">将存储在 &lt;code&gt;key&lt;/code&gt; 下的值更改为 &lt;code&gt;value&lt;/code&gt; ，但前提是 &lt;code&gt;map&lt;/code&gt; 中已经存在输入 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="375d49ba0682b4200a357c23af57a8fe3e771407" translate="yes" xml:space="preserve">
          <source>Although Elixir includes specific functions such as &lt;code&gt;tuple_size&lt;/code&gt;, &lt;code&gt;binary_size&lt;/code&gt; and &lt;code&gt;map_size&lt;/code&gt;, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:</source>
          <target state="translated">尽管Elixir包含诸如 &lt;code&gt;tuple_size&lt;/code&gt; ， &lt;code&gt;binary_size&lt;/code&gt; 和 &lt;code&gt;map_size&lt;/code&gt; 之类的特定功能，但有时我们希望能够检索数据结构的大小而不管其类型如何。在Elixir中，我们可以使用协议编写多态代码，即适用于不同形状/类型的代码。大小协议可以实现如下：</target>
        </trans-unit>
        <trans-unit id="868b9d8c908b99a2015b9ea01a789f020942a3d4" translate="yes" xml:space="preserve">
          <source>Although Elixir projects are not required to follow SemVer, they must follow the format outlined on &lt;a href=&quot;https://semver.org/&quot;&gt;SemVer 2.0 schema&lt;/a&gt;.</source>
          <target state="translated">尽管不需要Elixir项目遵循SemVer，但它们必须遵循&lt;a href=&quot;https://semver.org/&quot;&gt;SemVer 2.0 schema中&lt;/a&gt;概述的格式。</target>
        </trans-unit>
        <trans-unit id="271db6153eba80f48b3cb5615c2c7cf2befa189f" translate="yes" xml:space="preserve">
          <source>Although Mix generates and maintains the &lt;code&gt;.app&lt;/code&gt; file for us, we can customize its contents by adding new entries to the &lt;code&gt;application/0&lt;/code&gt; function inside the &lt;code&gt;mix.exs&lt;/code&gt; project file. We are going to do our first customization soon.</source>
          <target state="translated">尽管Mix 为我们生成并维护了 &lt;code&gt;.app&lt;/code&gt; 文件，但我们可以通过在 &lt;code&gt;mix.exs&lt;/code&gt; 项目文件内的 &lt;code&gt;application/0&lt;/code&gt; 函数中添加新条目来自定义其内容。我们将很快进行首次定制。</target>
        </trans-unit>
        <trans-unit id="5e1f61fc70481b8e1a6521771f177855b8a68b86" translate="yes" xml:space="preserve">
          <source>Although code points are represented as integers, this module represents code points in their encoded format as strings. For example:</source>
          <target state="translated">虽然码点用整数表示,但本模块将码点的编码格式表示为字符串。例如:</target>
        </trans-unit>
        <trans-unit id="b17471efb7e8b7966f0aa39356cf0b8489d5f43b" translate="yes" xml:space="preserve">
          <source>Although code points could be represented as integers, this module represents all code points as strings. For example:</source>
          <target state="translated">虽然代码点可以用整数表示,但本模块将所有代码点表示为字符串。例如:</target>
        </trans-unit>
        <trans-unit id="14fda69fb3ca698206ce8ef9fa7ae0f578b2ed83" translate="yes" xml:space="preserve">
          <source>Although doing so is not recommended as it may affect your test suite performance.</source>
          <target state="translated">虽然不建议这样做,因为它可能会影响你的测试套件性能。</target>
        </trans-unit>
        <trans-unit id="f1601918b924ec8be73d09596361453ea4e02508" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">尽管通常会避免使用不正确的列表，但是它们会在某些特殊情况下使用，例如iodata和chardata实体（请参见&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块）。</target>
        </trans-unit>
        <trans-unit id="7089c4bbd915ddfe4f12d574def40357ae4ad792" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">尽管通常会避免使用不正确的列表，但是它们会在某些特殊情况下使用，例如iodata和chardata实体（请参见&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块）。</target>
        </trans-unit>
        <trans-unit id="64c7cf26cc8984dd2eacea7d69ec4e1e732253fe" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">尽管在上面的示例中，我们已经使用&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt;和朋友直接启动服务器并与服务器进行通信，但是在大多数情况下，我们并不直接调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;函数。相反，我们将调用包装在代表服务器公共API的新函数中。</target>
        </trans-unit>
        <trans-unit id="1fac951d9acd827630fc984ba5e390c89493d219" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;genserver#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">尽管在上面的示例中，我们已经使用&lt;a href=&quot;genserver#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt;和朋友直接启动服务器并与服务器进行通信，但是在大多数情况下，我们并不直接调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;函数。相反，我们将调用包装在代表服务器公共API的新函数中。</target>
        </trans-unit>
        <trans-unit id="05cad5e03ed101afeda99f24e9baf0f87a53f9f2" translate="yes" xml:space="preserve">
          <source>Although our tests pass, our testing structure is getting more complex. In particular, running tests with only &lt;code&gt;mix test&lt;/code&gt; causes failures in our suite, since our test requires a connection to another node.</source>
          <target state="translated">尽管我们的测试通过了，但我们的测试结构却变得越来越复杂。特别是，仅使用 &lt;code&gt;mix test&lt;/code&gt; 运行测试会导致我们的套件失败，因为我们的测试需要连接到另一个节点。</target>
        </trans-unit>
        <trans-unit id="ff729d77091a6064c1d998a90b46541e7d7f75c9" translate="yes" xml:space="preserve">
          <source>Although pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:</source>
          <target state="translated">虽然模式匹配可以让我们建立强大的构造,但它的使用是有限的。例如,你不能在匹配的左侧进行函数调用。下面的例子是无效的。</target>
        </trans-unit>
        <trans-unit id="f7b600d39b3f1acbfb8a882dbb3ff05d15ab87d6" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">尽管结构是映射，但默认情况下，结构不会实现为映射实现的任何协议。检查&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;，以获取有关如何将结构与多态调度协议一起使用的更多信息。有关如何动态创建和更新结构的示例，另请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1d430d2d6fb0548beb47e18ecfea58c354f9cde" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">尽管结构是映射，但默认情况下，结构不实现为映射实现的任何协议。检查&lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;以获取有关如何将结构与多态调度协议一起使用的更多信息。有关如何动态创建和更新结构的示例，另请参见&lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="870fe0c59e3d007685ea9833cb1390f52f0e514b" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the &lt;code&gt;User&lt;/code&gt; struct leads to an error:</source>
          <target state="translated">尽管结构是映射，但默认情况下，结构不实现为映射实现的任何协议。例如，尝试将协议与 &lt;code&gt;User&lt;/code&gt; 结构一起使用会导致错误：</target>
        </trans-unit>
        <trans-unit id="431f21d40dbb5403d9bd326700ba842d9364814b" translate="yes" xml:space="preserve">
          <source>Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute &lt;code&gt;:spawn_executable&lt;/code&gt;.</source>
          <target state="translated">尽管上面的方法很方便，但是这意味着无法调用名称或参数中带有空格的可执行文件。由于这些原因，大多数时候最好执行 &lt;code&gt;:spawn_executable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fb3fdd978f27b5125e369d37a21e919df537b80" translate="yes" xml:space="preserve">
          <source>Although the directory can be accessed as &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">尽管可以通过 &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt; 来访问目录，但是此宏是一种方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="08556dd674acbaa5235d5a6dd7ba968777f84148" translate="yes" xml:space="preserve">
          <source>Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!</source>
          <target state="translated">虽然最终的结果是一样的,但打印元素的顺序却发生了变化!对于流,我们打印第一个元素,然后打印它的双倍。对于流,我们打印第一个元素,然后打印它的双倍。在这个例子中,列表只列举了一次!</target>
        </trans-unit>
        <trans-unit id="34317ca951c3b1fca45985dcc2015a9c9f8ee491" translate="yes" xml:space="preserve">
          <source>Although the example above is made of two characters, it is perceived by users as one.</source>
          <target state="translated">虽然上面的例子是由两个字符组成的,但却被用户认为是一个字符。</target>
        </trans-unit>
        <trans-unit id="a4ac7eba93e375ca0b8410e005578a589bad8a11" translate="yes" xml:space="preserve">
          <source>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;full&lt;/code&gt; strings, then slice the &lt;code&gt;full&lt;/code&gt; one, traversing it again.</source>
          <target state="translated">尽管上面的功能有效，但性能较差。为了计算字符串的长度，我们需要充分穿越它，所以我们遍历都 &lt;code&gt;prefix&lt;/code&gt; 和 &lt;code&gt;full&lt;/code&gt; 的字符串，然后切片的 &lt;code&gt;full&lt;/code&gt; 一个，再次穿越它。</target>
        </trans-unit>
        <trans-unit id="2ad64b2ae9d7779aeafe9f53ba81c4ac6a8c3bcb" translate="yes" xml:space="preserve">
          <source>Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of &lt;code&gt;0&lt;/code&gt;. That's one of the reasons why &lt;code&gt;@fallback_to_any&lt;/code&gt; is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour.</source>
          <target state="translated">尽管上面的实现可以说是不合理的。例如，说PID或整数的大小为 &lt;code&gt;0&lt;/code&gt; 毫无意义。这就是 &lt;code&gt;@fallback_to_any&lt;/code&gt; 是一种选择行为的原因之一。对于大多数协议，当未实现协议时引发错误是正确的行为。</target>
        </trans-unit>
        <trans-unit id="2d80e43bdc8417d6590a2fd8779a42e453b4510f" translate="yes" xml:space="preserve">
          <source>Although the module can be accessed in the &lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">尽管可以在&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;访问该模块，但此宏是方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="523bba024fe01ece815e7c56ce1e3c3d7d5ff12a" translate="yes" xml:space="preserve">
          <source>Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections.</source>
          <target state="translated">虽然上一节可以概括为 &quot;避免宏&quot;,但这两个主题都很重要,值得单独开一节。</target>
        </trans-unit>
        <trans-unit id="8a45380bdb24cc0394ac693565319d64e7fe3702" translate="yes" xml:space="preserve">
          <source>Although this chapter was the first time we implemented a supervisor, it was not the first time we used one! In the previous chapter, when we used &lt;code&gt;start_supervised!&lt;/code&gt; to start the registry during our tests, &lt;code&gt;ExUnit&lt;/code&gt; started the registry under a supervisor managed by the ExUnit framework itself. By defining our own supervisor, we provide more structure on how we initialize, shutdown and supervise processes in our applications, aligning our production code and tests with best practices.</source>
          <target state="translated">尽管本章是我们第一次配置主管，但这并不是我们第一次使用监督员！在上一章中，当我们使用 &lt;code&gt;start_supervised!&lt;/code&gt; 为了在测试期间启动注册表， &lt;code&gt;ExUnit&lt;/code&gt; 在由ExUnit框架本身管理的主管下启动了注册表。通过定义自己的主管，我们提供了更多有关如何初始化，关闭和监督应用程序中的流程，使生产代码和测试与最佳实践保持一致的结构。</target>
        </trans-unit>
        <trans-unit id="3c9f4ae19a7eeeab2983d7dec1f1792d10b1c1ba" translate="yes" xml:space="preserve">
          <source>Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions. Binaries are already represented by the underlying bytes and as such their representation is always &amp;ldquo;raw&amp;rdquo;.</source>
          <target state="translated">尽管这是一个细微的差别，但是如果您打算将列表传递给这些功能，则只需担心这些细节。二进制文件已经由底层字节表示，因此它们的表示始终为&amp;ldquo;原始&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a39c028c0e69f90f27ee19565121bb2984ad9e8e" translate="yes" xml:space="preserve">
          <source>Although this task does not show up in &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;, it is part of Mix public API and can be depended on.</source>
          <target state="translated">尽管此任务未显示在&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; 中&lt;/a&gt;，但它是Mix public API的一部分，可以依赖。</target>
        </trans-unit>
        <trans-unit id="84c3d8b250459ad3c47db87432253967c9d495f1" translate="yes" xml:space="preserve">
          <source>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</source>
          <target state="translated">虽然我们可以在关键词列表上进行模式匹配,但由于列表上的模式匹配需要匹配的项目数量和顺序,所以实际操作中很少进行。</target>
        </trans-unit>
        <trans-unit id="1624e83a6f323b5d4e4763fd7f94a95a8d4f3768" translate="yes" xml:space="preserve">
          <source>Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:</source>
          <target state="translated">虽然我们希望绝大多数程序能够随着时间的推移而保持兼容,但不可能保证未来的任何更改都不会破坏任何程序。在一些不太可能的情况下,我们可能会引入会破坏现有代码的更改。</target>
        </trans-unit>
        <trans-unit id="1172d58adce51402da1aca26a42f17b4f8158b48" translate="yes" xml:space="preserve">
          <source>Although we have covered code points and UTF-8 encoding, we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the &lt;strong&gt;bitstring&lt;/strong&gt;. A bitstring is a fundamental data type in Elixir, denoted with the &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; syntax. &lt;strong&gt;A bitstring is a contiguous sequence of bits in memory.&lt;/strong&gt;</source>
          <target state="translated">尽管我们已经介绍了代码点和UTF-8编码，但是仍然需要更深入地了解如何精确存储编码的字节，这就是我们介绍&lt;strong&gt;bitstring的地方&lt;/strong&gt;。位串是Elixir中的基本数据类型，用 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 语法表示。&lt;strong&gt;位串是内存中连续的位序列。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b17a13f88c530e5861a53d56146266cecae866f" translate="yes" xml:space="preserve">
          <source>Although we have overlooked some details, this is the main idea behind creating domain-specific modules in Elixir. Macros enable us to return quoted expressions that are executed in the caller, which we can then use to transform code and store relevant information in the target module via module attributes. Finally, callbacks such as &lt;code&gt;@before_compile&lt;/code&gt; allow us to inject code into the module when its definition is complete.</source>
          <target state="translated">尽管我们忽略了一些细节，但这是在Elixir中创建特定于域的模块的主要思想。宏使我们能够返回在调用程序中执行的带引号的表达式，然后我们可以使用它们来转换代码，并通过模块属性将相关信息存储在目标模块中。最后，诸如 &lt;code&gt;@before_compile&lt;/code&gt; 之类的回调使我们可以在其定义完成时将代码注入模块。</target>
        </trans-unit>
        <trans-unit id="3359c56da801ba4eef5b9504bfbf16ddf4e8ca4b" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;:ok&lt;/code&gt; and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; to read more about the &quot;owner&quot;.</source>
          <target state="translated">始终返回 &lt;code&gt;:ok&lt;/code&gt; ，如果没有更多与当前进程关联的键，则自动取消当前进程与所有者的链接。另请参阅&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt;以了解有关&amp;ldquo;所有者&amp;rdquo;的更多信息。</target>
        </trans-unit>
        <trans-unit id="72c0244fa532d1e23d46ac34ccb91bfb72ffc273" translate="yes" xml:space="preserve">
          <source>Ambiguous function/macro names</source>
          <target state="translated">含糊不清的函数/宏名称</target>
        </trans-unit>
        <trans-unit id="a049ff1aa2d29c7c72357b2f704f3d8dea2f8d78" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use Agent&lt;/code&gt;, it automatically defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do:</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;是一个监督树下最常用的开始。调用 &lt;code&gt;use Agent&lt;/code&gt; 时，它会自动定义&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;函数，该函数使我们可以直接在主管下启动代理。要在初始计数器为0的主管下启动座席，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="0cd52ac6bbd448008fc9991be40af1235993cec9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">一个&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;如果填充是不正确或非字母表字符存在于串中引发异常。</target>
        </trans-unit>
        <trans-unit id="a7daf3eed2b4a99b57bedfcc7b4244779d37a819" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">一个&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;如果填充是不正确或非字母表字符存在于串中引发异常。</target>
        </trans-unit>
        <trans-unit id="6b9f67eed7d2f0b73dd7c830850ce2ec24e88aa7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://hexdocs.pm/elixir/IO.Stream.html&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">一个&lt;a href=&quot;https://hexdocs.pm/elixir/IO.Stream.html&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt;同时实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;，允许它被用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="e7f62694e798684b6b70596713962c709a802b67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">一个&lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt;同时实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;，允许它被用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="ce760285f3ceb17ed57c0e119cfae44c3f14604f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;--app&lt;/code&gt; option can be given in order to name the OTP application for the project.</source>
          <target state="translated">可以使用 &lt;code&gt;--app&lt;/code&gt; 选项来命名该项目的OTP应用程序。</target>
        </trans-unit>
        <trans-unit id="b0ac0d09a1976576207aae2b02067561f24502c7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;--umbrella&lt;/code&gt; option can be given to generate an umbrella project.</source>
          <target state="translated">一个 &lt;code&gt;--umbrella&lt;/code&gt; 可以给选项生成一个总括项目。</target>
        </trans-unit>
        <trans-unit id="e64cd9fe6934e48aac677a5c7974fdad201f15ae" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;.app&lt;/code&gt; file is a file containing Erlang terms that defines your application. Mix automatically generates this file based on your &lt;code&gt;mix.exs&lt;/code&gt; configuration.</source>
          <target state="translated">一个 &lt;code&gt;.app&lt;/code&gt; 文件是包含定义应用程序的Erlang方面的文件。Mix根据您的 &lt;code&gt;mix.exs&lt;/code&gt; 配置自动生成此文件。</target>
        </trans-unit>
        <trans-unit id="afe086c320e6384512964bd01dec4f5547e66922" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;after&lt;/code&gt; clause allows you to define cleanup logic that will be invoked both when the block of code passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the &lt;code&gt;after&lt;/code&gt; clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</source>
          <target state="translated">一个 &lt;code&gt;after&lt;/code&gt; 子句允许定义当代码块传递给将被调用二者清理逻辑&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;时引发错误成功，并且也。请注意，当接收到退出信号导致该过程突然退出时，该过程将照常退出，因此不能保证 &lt;code&gt;after&lt;/code&gt; 子句被执行。幸运的是，Elixir中的大多数资源（例如打开的文件，ETS表，端口，套接字等）都链接到或监视拥有的进程，如果该进程退出，它们将自动清理自身。</target>
        </trans-unit>
        <trans-unit id="d9b71baa3ec4aca419614eb83a6884fce9738af0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to modify what is being returned from &lt;code&gt;with&lt;/code&gt; in the case of a failed match:</source>
          <target state="translated">一个 &lt;code&gt;else&lt;/code&gt; 可以给选项来修改什么被从返回 &lt;code&gt;with&lt;/code&gt; 一个失败的比赛的情况下：</target>
        </trans-unit>
        <trans-unit id="ff7e359bf597a6fd9ce8084d91ed80c5b7ad85f6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to specify the opposite:</source>
          <target state="translated">可以使用 &lt;code&gt;else&lt;/code&gt; 选项指定相反的内容：</target>
        </trans-unit>
        <trans-unit id="e95cabc5495eb242ab85459b1aeff5cf96a48942" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">从此调用返回的 &lt;code&gt;io_device&lt;/code&gt; 可用作&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块功能的参数。</target>
        </trans-unit>
        <trans-unit id="f97b9473a3f0b32057fd9dcd3bc6ae93dc6f50c3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;edit script&lt;/em&gt; is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring &lt;code&gt;list1&lt;/code&gt; closer to being equal to &lt;code&gt;list2&lt;/code&gt;; a key can be &lt;code&gt;:eq&lt;/code&gt;, &lt;code&gt;:ins&lt;/code&gt;, or &lt;code&gt;:del&lt;/code&gt;. Each value is a sublist of either &lt;code&gt;list1&lt;/code&gt; or &lt;code&gt;list2&lt;/code&gt; that should be inserted (if the corresponding key &lt;code&gt;:ins&lt;/code&gt;), deleted (if the corresponding key is &lt;code&gt;:del&lt;/code&gt;), or left alone (if the corresponding key is &lt;code&gt;:eq&lt;/code&gt;) in &lt;code&gt;list1&lt;/code&gt; in order to be closer to &lt;code&gt;list2&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;编辑的脚本&lt;/em&gt;是一个关键词列表。每个键描述为使 &lt;code&gt;list1&lt;/code&gt; 更接近于 &lt;code&gt;list2&lt;/code&gt; 而采取的&amp;ldquo;编辑动作&amp;rdquo; ；键可以是 &lt;code&gt;:eq&lt;/code&gt; ， &lt;code&gt;:ins&lt;/code&gt; 或 &lt;code&gt;:del&lt;/code&gt; 。每个值都是 &lt;code&gt;list1&lt;/code&gt; 或 &lt;code&gt;list2&lt;/code&gt; 的子列表，应按顺序在 &lt;code&gt;list1&lt;/code&gt; 中插入（如果对应的键 &lt;code&gt;:ins&lt;/code&gt; ），删除（如果对应的键是 &lt;code&gt;:del&lt;/code&gt; ）或单独放置（如果对应的键是 &lt;code&gt;:eq&lt;/code&gt; ）。接近 &lt;code&gt;list2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b968d4ec51b4353a379f80bf32b0dc9347be2642" translate="yes" xml:space="preserve">
          <source>An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:</source>
          <target state="translated">IO设备可以是一个原子或PID。如果是原子,原子必须是注册进程的名称。此外,Elixir还提供了两个快捷方式。</target>
        </trans-unit>
        <trans-unit id="d60cf8ae86edc9af73dfcd3cc01f5bc137486aa4" translate="yes" xml:space="preserve">
          <source>An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named &lt;code&gt;:sample&lt;/code&gt; and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction:</source>
          <target state="translated">代理可以通过简单地将模块，函数和参数元组传递给更新指令来实时热交换其代码。例如，假设您有一个名为 &lt;code&gt;:sample&lt;/code&gt; 的代理，并且想要将其内部状态从关键字列表转换为地图。可以通过以下指令完成：</target>
        </trans-unit>
        <trans-unit id="b354895b4d9f46ba32dcc5d6d21ad6dbac64a90c" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">代理绑定到与GenServers相同的名称注册规则。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中阅读有关它的更多信息。</target>
        </trans-unit>
        <trans-unit id="9c1a72284f98b833f1b474c204b90da86458f9ff" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">代理与GenServer绑定相同的名称注册规则。在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中阅读有关它的更多信息。</target>
        </trans-unit>
        <trans-unit id="2d060fe1a8daedc42f287a49cf8e64646cafb9fe" translate="yes" xml:space="preserve">
          <source>An alias in Elixir is a capitalized identifier (like &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Keyword&lt;/code&gt;, etc) which is converted to an atom during compilation. For instance, the &lt;code&gt;String&lt;/code&gt; alias translates by default to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;:</source>
          <target state="translated">Elixir中的别名是一个大写的标识符（例如 &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Keyword&lt;/code&gt; 等），该标识符在编译期间会转换为原子。例如， &lt;code&gt;String&lt;/code&gt; 别名默认情况下转换为原子 &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2eed296e4d116b1286a08b5abb835c217ff22cd0" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and life cycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;. Each application also has its own environment, which provides a unified API for configuring each application.</source>
          <target state="translated">应用程序是实现某些特定功能的组件，具有标准化的目录结构，配置和生命周期。应用程序已&lt;em&gt;加载&lt;/em&gt;，&lt;em&gt;启动&lt;/em&gt;和&lt;em&gt;停止&lt;/em&gt;。每个应用程序还具有自己的环境，该环境提供了用于配置每个应用程序的统一API。</target>
        </trans-unit>
        <trans-unit id="f1c5142518fdf011cadf3f17245bcd8f2a562ce8" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and lifecycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;.</source>
          <target state="translated">应用程序是实现某些特定功能的组件，具有标准化的目录结构，配置和生命周期。应用程序已&lt;em&gt;加载&lt;/em&gt;，&lt;em&gt;启动&lt;/em&gt;和&lt;em&gt;停止&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e3fcb6166c3639e8ba7a2f7130be093979e1d4e4" translate="yes" xml:space="preserve">
          <source>An atom is a constant whose value is its own name. Some other languages call these symbols. They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">原子是一个常量,其值是自己的名字。其他一些语言将这些符号称为原子。它们通常用于列举不同的值,例如:</target>
        </trans-unit>
        <trans-unit id="86fb449cced27f4191bdd440f9d6ef1683f1583a" translate="yes" xml:space="preserve">
          <source>An attempt to call a macro that was not loaded will raise an error.</source>
          <target state="translated">试图调用一个未加载的宏会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="0f945f62fb0dc4d4db64326ebccd5ac85f209b4e" translate="yes" xml:space="preserve">
          <source>An attribute is defined if it has been registered with &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt; or assigned a value. If an attribute has been deleted with &lt;a href=&quot;#delete_attribute/2&quot;&gt;&lt;code&gt;delete_attribute/2&lt;/code&gt;&lt;/a&gt; it is no longer considered defined.</source>
          <target state="translated">如果属性已在&lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;register_attribute/3&lt;/code&gt; 中注册&lt;/a&gt;或分配了值，则定义该属性。如果属性已使用&lt;a href=&quot;#delete_attribute/2&quot;&gt; &lt;code&gt;delete_attribute/2&lt;/code&gt; &lt;/a&gt;删除，则不再认为已定义。</target>
        </trans-unit>
        <trans-unit id="be3bd9f0eca00ecaf433384dd9dcab4453a5b9a4" translate="yes" xml:space="preserve">
          <source>An easy way to do so is by sending a synchronous request to the registry before we do the bucket lookup. The &lt;code&gt;Agent.stop/2&lt;/code&gt; operation is synchronous and only returns after the bucket process terminates and all &lt;code&gt;:DOWN&lt;/code&gt; messages are delivered. Therefore, once &lt;code&gt;Agent.stop/2&lt;/code&gt; returns, the registry has already received the &lt;code&gt;:DOWN&lt;/code&gt; message but it may not have processed it yet. In order to guarantee the processing of the &lt;code&gt;:DOWN&lt;/code&gt; message, we can do a synchronous request. Since messages are processed in order, once the registry replies to the synchronous request, then the &lt;code&gt;:DOWN&lt;/code&gt; message will definitely have been processed.</source>
          <target state="translated">一种简单的方法是在执行存储桶查找之前，向注册表发送同步请求。所述 &lt;code&gt;Agent.stop/2&lt;/code&gt; 操作是同步的，并且只有铲斗过程终止和所有后返回 &lt;code&gt;:DOWN&lt;/code&gt; 邮件传递。因此，一旦 &lt;code&gt;Agent.stop/2&lt;/code&gt; 返回，注册表就已经收到了 &lt;code&gt;:DOWN&lt;/code&gt; 消息，但它可能尚未处理它。为了保证处理 &lt;code&gt;:DOWN&lt;/code&gt; 消息，我们可以执行一个同步请求。由于消息是按顺序处理的，因此一旦注册表回复了同步请求，则 &lt;code&gt;:DOWN&lt;/code&gt; 消息肯定会被处理。</target>
        </trans-unit>
        <trans-unit id="bc95a79f72a6064f19e08b29349826dd25b216ee" translate="yes" xml:space="preserve">
          <source>An empty list can be passed to avoid stacktrace printing.</source>
          <target state="translated">可以通过一个空列表来避免堆栈跟踪打印。</target>
        </trans-unit>
        <trans-unit id="276e3d577cef8507d9164a96e53206098957da90" translate="yes" xml:space="preserve">
          <source>An empty list if there is no match.</source>
          <target state="translated">如果没有匹配,则为空列表。</target>
        </trans-unit>
        <trans-unit id="f6764a9eb225a20637ece5e74ca6e79cd54f249b" translate="yes" xml:space="preserve">
          <source>An empty list will be returned if there is no match.</source>
          <target state="translated">如果没有匹配,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="2c7a57e0b595be7bebd781fac5740e7fc7f12ace" translate="yes" xml:space="preserve">
          <source>An empty string will always match:</source>
          <target state="translated">一个空的字符串将总是匹配。</target>
        </trans-unit>
        <trans-unit id="bb794abcdf1956bbd61a3d6b9cb82432c85ee4f0" translate="yes" xml:space="preserve">
          <source>An empty suffix will always match:</source>
          <target state="translated">空后缀总是会匹配的。</target>
        </trans-unit>
        <trans-unit id="bc88b4de65545bb70648538e7fb3eb0cf86cc242" translate="yes" xml:space="preserve">
          <source>An engine may also &lt;code&gt;use EEx.Engine&lt;/code&gt; to get the default behaviour but this is not advised. In such cases, if any of the callbacks are overridden, they must call &lt;code&gt;super()&lt;/code&gt; to delegate to the underlying &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;EEx.Engine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引擎也可以 &lt;code&gt;use EEx.Engine&lt;/code&gt; 来获取默认行为，但是不建议这样做。在这种情况下，如果重写了任何回调，则它们必须调用 &lt;code&gt;super()&lt;/code&gt; 委派给基础&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;EEx.Engine&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2319178933b7fc280516f48198d763f0d06241ea" translate="yes" xml:space="preserve">
          <source>An engine needs to implement all callbacks below.</source>
          <target state="translated">一个引擎需要实现下面所有的回调。</target>
        </trans-unit>
        <trans-unit id="7d57834eea31257f109e7c789d7d41f86df67542" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a list:</source>
          <target state="translated">如果被访问的结构不是一个列表,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="5f8f5a5cd7e9dceea4cbf840417ae0c08edc2e95" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map or a struct:</source>
          <target state="translated">如果访问的结构不是映射或结构体,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="50fb59be68cf5f14388edcb66f9d042d984c8dde" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map/struct:</source>
          <target state="translated">如果被访问的结构不是一个地图/结构,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="55f9d11748bcf3c144604b93c6b2ae25f8aeccb1" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a tuple:</source>
          <target state="translated">如果访问的结构不是一个元组,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="de94d63a6d219c4ead87b23e065fc7de46de12f5" translate="yes" xml:space="preserve">
          <source>An error is raised if the predicate is not a function or is of the incorrect arity:</source>
          <target state="translated">如果谓词不是函数或者是不正确的数组,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="cde03332fee4ff115f16002c9f108e996e9a75a6" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">发生错误，将通过与&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;不同的机制来处理。这种方法可能涉及延迟尝试重新启动后调用&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b078cb3fc34c37337f004467d0ce9378efe754a" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">发生错误，将通过与&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;不同的机制来处理。这种方法可能涉及延迟尝试重新启动后调用&lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee6f2f4da896a18384f200b0e36a0f349ec99076" translate="yes" xml:space="preserve">
          <source>An escript is an executable that can be invoked from the command line. An escript can run on any machine that has Erlang/OTP installed and by default does not require Elixir to be installed, as Elixir is embedded as part of the escript.</source>
          <target state="translated">escript是可以从命令行调用的可执行文件。escript可以在任何安装了Erlang/OTP的机器上运行,默认情况下不需要安装Elixir,因为Elixir被嵌入到escript中。</target>
        </trans-unit>
        <trans-unit id="21ae8235dad3d0eb05c1b7a4b8d8a02b347ddf84" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;code#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">不能手动修改&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;的实例。如果您需要创建一个自定义环境以传递给&lt;a href=&quot;code#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt;，请使用以下技巧：</target>
        </trans-unit>
        <trans-unit id="e05b13bfc6d99bc82c0aaed709610f0a943ff0f8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">不能手动修改&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;的实例。如果需要创建自定义环境以传递给&lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt;，请使用以下技巧：</target>
        </trans-unit>
        <trans-unit id="dd8bc729544e66eee698242f46c5404236f10a6e" translate="yes" xml:space="preserve">
          <source>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of &lt;code&gt;:io.columns&lt;/code&gt;. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</source>
          <target state="translated">一个整数，指示要在输出中使用的最大列数。默认值为80列。实际输出宽度是该数字和 &lt;code&gt;:io.columns&lt;/code&gt; 结果的最小值。这样，您可以将IEx配置为最大的屏幕尺寸，并且它应始终占据当前终端屏幕的整个宽度。</target>
        </trans-unit>
        <trans-unit id="62dfd3ff7081b119a8a16043b2a10c06d4c45481" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;after&lt;/code&gt; clause can be given in case the message was not received after the given timeout period, specified in milliseconds:</source>
          <target state="translated">如果在指定的超时时间（以毫秒为单位）内未收到消息，则可以提供可选的 &lt;code&gt;after&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="509d438b27e12dd94c38e2a190b7ee190fb17b57" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; to the corresponding integer can be provided. If &lt;code&gt;base&lt;/code&gt; is not given, 10 will be used.</source>
          <target state="translated">可以提供相应整数的可选 &lt;code&gt;base&lt;/code&gt; 。如果没有给出 &lt;code&gt;base&lt;/code&gt; ，将使用10。</target>
        </trans-unit>
        <trans-unit id="bda79df01bfb65a34e0eb465b572e1c22d155d69" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the &lt;code&gt;digits&lt;/code&gt;. Base has to be an integer greater than or equal to &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">可以提供一个可选的 &lt;code&gt;base&lt;/code&gt; 值，代表 &lt;code&gt;digits&lt;/code&gt; 的基数。基数必须是大于或等于 &lt;code&gt;2&lt;/code&gt; 的整数。</target>
        </trans-unit>
        <trans-unit id="5139348d1208b18f1412d9ff5406b136dc7222e8" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the returned digits. This one must be an integer &amp;gt;= 2.</source>
          <target state="translated">可以提供一个可选的 &lt;code&gt;base&lt;/code&gt; 值，代表返回数字的基数。这个必须是大于等于2的整数。</target>
        </trans-unit>
        <trans-unit id="ac126c925abfbfed6be9468e1aea794193196b62" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;starting_on&lt;/code&gt; value may be supplied, which configures the weekday the week starts on. The default value for it is &lt;code&gt;:default&lt;/code&gt;, which translates to &lt;code&gt;:monday&lt;/code&gt; for the built-in ISO calendar. Any other weekday may be given to.</source>
          <target state="translated">可以提供一个可选的 &lt;code&gt;starting_on&lt;/code&gt; 值，该值配置一周开始的工作日。它的默认值为 &lt;code&gt;:default&lt;/code&gt; ，对于内置的ISO日历，它转换为 &lt;code&gt;:monday&lt;/code&gt; 。任何其他工作日都可以给予。</target>
        </trans-unit>
        <trans-unit id="68a979cd20856e6e7b0398abc497d56ec40c554a" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will be emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">可以传递一个可选的布尔参数来启用或禁用发出实际的ANSI代码。如果为 &lt;code&gt;false&lt;/code&gt; ，则不会发出ANSI代码。默认情况下，检查是否使用&lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt;功能启用了ANSI 。</target>
        </trans-unit>
        <trans-unit id="141cb8c089b77fc45a4b599501be2124087d63c3" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">可以传递一个可选的布尔参数来启用或禁用发出实际的ANSI代码。如果为 &lt;code&gt;false&lt;/code&gt; ，则不会发出ANSI代码。默认情况下，检查是否使用&lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt;功能启用了ANSI 。</target>
        </trans-unit>
        <trans-unit id="bf23a52f10d72db5a4b065e517b53575b77a702f" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">懒惰定义了一个可覆盖的函数，允许开发人员对其进行自定义。有关更多信息和文档，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="670e0435cab9da74bff554f172d6191175f5b29a" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;kernel#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">懒惰定义了一个可覆盖的函数，允许开发人员对其进行自定义。有关更多信息和文档，请参见&lt;a href=&quot;kernel#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f06ca58408ebbb2e2d18da83ab38dd0e2381bfd3" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to override it.</source>
          <target state="translated">一个可覆盖的函数被懒得定义,允许开发人员覆盖它。</target>
        </trans-unit>
        <trans-unit id="735f79f261a0a1398e39bb2ba9f23bdd5b445481" translate="yes" xml:space="preserve">
          <source>An unknown key:</source>
          <target state="translated">一个未知的钥匙。</target>
        </trans-unit>
        <trans-unit id="4eb360277b153c599c984a044f3a3b8d7442bbcf" translate="yes" xml:space="preserve">
          <source>An update operation specific for structs is also available:</source>
          <target state="translated">此外,还提供了针对结构的更新操作。</target>
        </trans-unit>
        <trans-unit id="dbebd5f66bf57539f1cae5d05912dfd58e43605d" translate="yes" xml:space="preserve">
          <source>Ancestor and Caller Tracking</source>
          <target state="translated">祖先和来电追踪</target>
        </trans-unit>
        <trans-unit id="4bf59e857bc43e008d05f39c6798933eabe92a7b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;:greek&lt;/code&gt; properly handles the context sensitive sigma in Greek:</source>
          <target state="translated">和 &lt;code&gt;:greek&lt;/code&gt; 正确处理希腊语中上下文相关的sigma：</target>
        </trans-unit>
        <trans-unit id="57f523660878f0ae5422d81e21ff0f2d992fab43" translate="yes" xml:space="preserve">
          <source>And also in umbrella dependencies:</source>
          <target state="translated">而且还在伞形依赖中。</target>
        </trans-unit>
        <trans-unit id="7475479141d0c8752fe853a18f88400575acc441" translate="yes" xml:space="preserve">
          <source>And also when comparing different types:</source>
          <target state="translated">而且在比较不同类型的时候,也。</target>
        </trans-unit>
        <trans-unit id="a30f504a098cdbb3e9933ddf69fbccd69bd0d89e" translate="yes" xml:space="preserve">
          <source>And an example &lt;code&gt;:my_included_app&lt;/code&gt; defines on its &lt;code&gt;mix.exs&lt;/code&gt; the function:</source>
          <target state="translated">还有一个示例 &lt;code&gt;:my_included_app&lt;/code&gt; 在其 &lt;code&gt;mix.exs&lt;/code&gt; 中定义了该函数：</target>
        </trans-unit>
        <trans-unit id="ddcbca0482883ea8e4091eaadee210a79869f2e4" translate="yes" xml:space="preserve">
          <source>And execute it as:</source>
          <target state="translated">并将其执行为。</target>
        </trans-unit>
        <trans-unit id="419827a34eea4ec811bd9357533fc68ae720c124" translate="yes" xml:space="preserve">
          <source>And finally successfully boot it:</source>
          <target state="translated">并最终成功启动。</target>
        </trans-unit>
        <trans-unit id="72688afe4af65ced53cacec5689d360d88950fb2" translate="yes" xml:space="preserve">
          <source>And here is an example of how you can define &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; from the above configuration:</source>
          <target state="translated">这是一个示例，说明如何从上述配置中定义 &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f0d1bd4c59aaee11683223b356559849183e2699" translate="yes" xml:space="preserve">
          <source>And it then returned a quoted expression as follows:</source>
          <target state="translated">然后它返回了一个引用的表达式,如下所示。</target>
        </trans-unit>
        <trans-unit id="e0b5f0362b86f72e75548b22466dd13d5a1cf84b" translate="yes" xml:space="preserve">
          <source>And it will provide the same behaviour. You may use &lt;code&gt;do:&lt;/code&gt; for one-liners but always use &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; for functions spanning multiple lines.</source>
          <target state="translated">并且它将提供相同的行为。您可以将 &lt;code&gt;do:&lt;/code&gt; 用于单行，但始终将 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 用于跨越多行的函数。</target>
        </trans-unit>
        <trans-unit id="a3be6c2d0cb8b49833135e767d2d7a4fbac9b3c5" translate="yes" xml:space="preserve">
          <source>And it works!</source>
          <target state="translated">而且还能用!</target>
        </trans-unit>
        <trans-unit id="e5ff9d5b10d267dee51c69e79f2c679b450ef8f6" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s connect to it and issue a request in another terminal:</source>
          <target state="translated">然后连接到它并在另一个终端中发出请求：</target>
        </trans-unit>
        <trans-unit id="aef6f548c63d313f3e6febdf170c4b53e23d4948" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s try to start our application again:</source>
          <target state="translated">让我们尝试再次启动我们的应用程序：</target>
        </trans-unit>
        <trans-unit id="0a3e48a60746f6b847d997fa0fbe9c121a13a5e1" translate="yes" xml:space="preserve">
          <source>And more</source>
          <target state="translated">还有更多</target>
        </trans-unit>
        <trans-unit id="3975c92bca370daedd767ed422d2ad2a60b72331" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it once more:</source>
          <target state="translated">现在让我们再次组装它：</target>
        </trans-unit>
        <trans-unit id="d14e640d4bda56647f06d50190912bc628cfe672" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it:</source>
          <target state="translated">现在让我们组装它：</target>
        </trans-unit>
        <trans-unit id="450675268dca95ea69df946fd7052040689b26b5" translate="yes" xml:space="preserve">
          <source>And now run tests with:</source>
          <target state="translated">而现在运行测试与。</target>
        </trans-unit>
        <trans-unit id="91c1d6064e2642eec275bb2697301c83bf002443" translate="yes" xml:space="preserve">
          <source>And play a bit with agents:</source>
          <target state="translated">还跟代理商玩了一下。</target>
        </trans-unit>
        <trans-unit id="2dadb42bf111f89bf23b4940e02183ac02eb51a8" translate="yes" xml:space="preserve">
          <source>And play with those definitions:</source>
          <target state="translated">而玩这些定义。</target>
        </trans-unit>
        <trans-unit id="16ce5c350460be5d7d537d13e7f1131d9b8fad50" translate="yes" xml:space="preserve">
          <source>And the variable can be defined in the match itself (prior to its use):</source>
          <target state="translated">而变量可以在匹配本身中定义(在使用之前)。</target>
        </trans-unit>
        <trans-unit id="0e8b021dea943d8ac4bd67ab292eb615322244df" translate="yes" xml:space="preserve">
          <source>And then a module may use it as:</source>
          <target state="translated">然后一个模块可以把它作为。</target>
        </trans-unit>
        <trans-unit id="118cdbf4ebff67474fde8aa873dcc8b30629e9be" translate="yes" xml:space="preserve">
          <source>And then explicitly attached in your &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">然后显式附加在&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;回调中：</target>
        </trans-unit>
        <trans-unit id="a9c544212c0f62fab7a929bdf6254c14ee92c57a" translate="yes" xml:space="preserve">
          <source>And then passing it to the supervisor:</source>
          <target state="translated">然后传给主管。</target>
        </trans-unit>
        <trans-unit id="75d0f7371704fa5ce1ab31b056a3610c4f01dd6d" translate="yes" xml:space="preserve">
          <source>And then start it:</source>
          <target state="translated">然后启动它。</target>
        </trans-unit>
        <trans-unit id="46195fee28b6f3924859b2e05c7f84e26d2f56e8" translate="yes" xml:space="preserve">
          <source>And then you can define the implementations specific to the test environment inside &lt;code&gt;test/support/some_file.ex&lt;/code&gt;.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;test/support/some_file.ex&lt;/code&gt; 中定义特定于测试环境的实现。</target>
        </trans-unit>
        <trans-unit id="08c3be653aad70d807268164f869ff1d1f07cee8" translate="yes" xml:space="preserve">
          <source>And to run them:</source>
          <target state="translated">并对他们进行管理。</target>
        </trans-unit>
        <trans-unit id="462519e135281467088215ccc649f512ae9b84ce" translate="yes" xml:space="preserve">
          <source>Anonymous functions</source>
          <target state="translated">匿名功能</target>
        </trans-unit>
        <trans-unit id="bb9a933ae349228e32e1f073b740f4f65715b58c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;</source>
          <target state="translated">匿名函数被报告为-func/arity-anonfn-count-,其中func是外层函数的名称。转换为 &quot;func/arity中的匿名fn&quot;。</target>
        </trans-unit>
        <trans-unit id="0ad3d840ff5e9c0e8ea7f52dc6172ac4b039510c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are typically created by using &lt;code&gt;fn&lt;/code&gt;:</source>
          <target state="translated">通常使用 &lt;code&gt;fn&lt;/code&gt; 创建匿名函数：</target>
        </trans-unit>
        <trans-unit id="8e2e0b675b3d9b8858e0c45385fd95f27e5170f3" translate="yes" xml:space="preserve">
          <source>Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:</source>
          <target state="translated">匿名函数也可以有多个子句。所有子句都应该期待相同数量的参数。</target>
        </trans-unit>
        <trans-unit id="bfa301a3c21795199d13e7b6588d342af94a24a1" translate="yes" xml:space="preserve">
          <source>Anonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a function is of any given arity by using &lt;code&gt;is_function/2&lt;/code&gt;:</source>
          <target state="translated">Elixir中的匿名函数还通过它们收到的参数数量来标识。我们可以使用 &lt;code&gt;is_function/2&lt;/code&gt; 来检查一个函数是否具有给定的Arity：</target>
        </trans-unit>
        <trans-unit id="cc3478c83b0f2c05d9c65b14ae56037cbfc0b5c6" translate="yes" xml:space="preserve">
          <source>Anonymous functions with no expression after &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-&amp;gt;&lt;/code&gt; 之后没有表达式的匿名函数</target>
        </trans-unit>
        <trans-unit id="3f9ea76dc507dd1537d2a78a7f363a18e4775cd5" translate="yes" xml:space="preserve">
          <source>Another alternative to &lt;code&gt;@derive&lt;/code&gt; is to explicitly tell the protocol to fallback to &lt;code&gt;Any&lt;/code&gt; when an implementation cannot be found. This can be achieved by setting &lt;code&gt;@fallback_to_any&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 的另一种选择是在找不到实现时，明确告诉协议回退到 &lt;code&gt;Any&lt;/code&gt; 。这可以通过在协议定义 &lt;code&gt;@fallback_to_any&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="2ce311858ef69483871a91631dbd1d6d4dde210e" translate="yes" xml:space="preserve">
          <source>Another approach is to disable protocol consolidation during tests in your mix.exs:</source>
          <target state="translated">另一种方法是在mix.exs的测试中禁用协议合并。</target>
        </trans-unit>
        <trans-unit id="cd6916cf153042850a0d4907b1527f29fbe844df" translate="yes" xml:space="preserve">
          <source>Another common metadata is &lt;code&gt;:deprecated&lt;/code&gt;, which emits a warning in the documentation, explaining that its usage is discouraged:</source>
          <target state="translated">另一个常见的元数据是 &lt;code&gt;:deprecated&lt;/code&gt; ，它在文档中发出警告，说明不鼓励使用它：</target>
        </trans-unit>
        <trans-unit id="2b8f4fcb03038d3204cf32a1e07964ca7ae1e5e9" translate="yes" xml:space="preserve">
          <source>Another common need in releases is to compute configuration when the release runs, not when the release is assembled. The &lt;code&gt;config/config.exs&lt;/code&gt; file we defined at the beginning of this chapter runs on every Mix command, when we build, test and run our application. This is great, because it provides a unified configuration for dev, test, and prod.</source>
          <target state="translated">版本中的另一个常见需求是在版本运行时（而不是在组装版本时）计算配置。在构建，测试和运行应用程序时，我们将在本章开头定义的 &lt;code&gt;config/config.exs&lt;/code&gt; 文件在每个Mix命令上运行。很好，因为它为开发，测试和生产提供了统一的配置。</target>
        </trans-unit>
        <trans-unit id="d2d6bcdc6f9dd5a9edc0684e098b03c84e550047" translate="yes" xml:space="preserve">
          <source>Another example comes from &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;the ExUnit framework&lt;/a&gt; which uses module attributes as annotation and storage:</source>
          <target state="translated">另一个示例来自&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit框架&lt;/a&gt;，该框架使用模块属性作为注释和存储：</target>
        </trans-unit>
        <trans-unit id="fa358ec240cab1628444ba9ff9bd76a8046b33fc" translate="yes" xml:space="preserve">
          <source>Another example while using an imported or local function:</source>
          <target state="translated">另一个例子是在使用导入或本地函数时。</target>
        </trans-unit>
        <trans-unit id="745cb32af8a59b8749a4860fd9efe56fe285cd4a" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">另一个重要的区别是，&lt;a href=&quot;#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; &lt;/a&gt;允许您控制定义模块时使用的环境变量，而&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; 会&lt;/a&gt;自动使用在其上调用的环境。</target>
        </trans-unit>
        <trans-unit id="dbe451732076cc22d41fb430c0f2cb877351509f" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;module#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;kernel#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">另一个重要的区别是&lt;a href=&quot;module#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; &lt;/a&gt;允许您控制定义模块时使用的环境变量，而&lt;a href=&quot;kernel#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; 则&lt;/a&gt;自动使用在其上调用的环境。</target>
        </trans-unit>
        <trans-unit id="2d8f88bdbecc2925caf0ed41e2d35ff7613e7a59" translate="yes" xml:space="preserve">
          <source>Another interesting function is &lt;code&gt;Stream.resource/3&lt;/code&gt; which can be used to wrap around resources, guaranteeing they are opened right before enumeration and closed afterwards, even in the case of failures. For example, &lt;code&gt;File.stream!/1&lt;/code&gt; builds on top of &lt;code&gt;Stream.resource/3&lt;/code&gt; to stream files:</source>
          <target state="translated">另一个有趣的功能是 &lt;code&gt;Stream.resource/3&lt;/code&gt; ，它可以用于包装资源，以确保它们在枚举之前就已打开并且在发生故障后也可以在之后关闭。例如， &lt;code&gt;File.stream!/1&lt;/code&gt; 在 &lt;code&gt;Stream.resource/3&lt;/code&gt; 的基础上构建以流式传输文件：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
