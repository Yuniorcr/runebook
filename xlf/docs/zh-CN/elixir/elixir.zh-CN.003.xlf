<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="f8c0e8ae95524397c8a10deff38a828266588e66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:metadata&lt;/code&gt; - the metadata to be printed by &lt;code&gt;$metadata&lt;/code&gt;. Defaults to an empty list (no metadata). Setting &lt;code&gt;:metadata&lt;/code&gt; to &lt;code&gt;:all&lt;/code&gt; prints all metadata. See the &quot;Metadata&quot; section for more information.</source>
          <target state="translated">&lt;code&gt;:metadata&lt;/code&gt; - &lt;code&gt;$metadata&lt;/code&gt; 要打印的元数据。默认为空列表（无元数据）。将 &lt;code&gt;:metadata&lt;/code&gt; 设置为 &lt;code&gt;:all&lt;/code&gt; 将打印所有元数据。有关更多信息，请参见&amp;ldquo;元数据&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4226f062e7d1ef7200c84fbb24a73070b2503346" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:metadata&lt;/code&gt; - the metadata to include in that backend</source>
          <target state="translated">&lt;code&gt;:metadata&lt;/code&gt; -要包含在该后端中的元数据</target>
        </trans-unit>
        <trans-unit id="0dd254815bbc61d41ceac9cf399bee96bce92c84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:mixed&lt;/code&gt; - allows mixed case characters</source>
          <target state="translated">&lt;code&gt;:mixed&lt;/code&gt; -允许混合大小写字符</target>
        </trans-unit>
        <trans-unit id="034a02a2f75fdec584b2557986417d5297d5c51a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - an atom which is the module where the function is defined when anonymous or the module which the function refers to when it's a named function.</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -一个原子，它是在匿名时定义函数的模块，或者是命名函数时引用的模块。</target>
        </trans-unit>
        <trans-unit id="03afe92f92a850066369ecbeec077fb8c8730935" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - filters out any results not pertaining to the given module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -过滤掉与给定模块无关的所有结果</target>
        </trans-unit>
        <trans-unit id="e73e68fdc5f4b5f45f5d525de21b134f3514b74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the current module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -当前模块</target>
        </trans-unit>
        <trans-unit id="44a3a462ffcd267c2d4f890aa1dcb1bb7578f22c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the module atom name</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -模块原子名称</target>
        </trans-unit>
        <trans-unit id="9552132b93967bd9351a85fab1e15d279d8a46db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the module on which the test was defined</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -在其上定义测试的模块</target>
        </trans-unit>
        <trans-unit id="fc6879076b19a627a0380a04c7a0d2d546631516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the protocol module atom name</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -协议模块原子名称</target>
        </trans-unit>
        <trans-unit id="8b13174d9aff6adff24ee44d0e9d07b2214e3c67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the test module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; -测试模块</target>
        </trans-unit>
        <trans-unit id="2d3cb635d826e6e2f42e31d395df5bc5b08374a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module_load_timeout&lt;/code&gt; - the timeout to be used when loading a test module in milliseconds, defaults to &lt;code&gt;60_000&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:module_load_timeout&lt;/code&gt; &lt;code&gt;60_000&lt;/code&gt; 加载测试模块时使用的超时（以毫秒为单位），默认为60_000；</target>
        </trans-unit>
        <trans-unit id="d4de44ef4c35d06879a3ced99558869a7eb86898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:modules&lt;/code&gt; - it should be a list with one element &lt;code&gt;[module]&lt;/code&gt;, where module is the name of the callback module only if the child process is a &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;; if the child process is a &lt;a href=&quot;genevent&quot;&gt;&lt;code&gt;GenEvent&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;:modules&lt;/code&gt; should be &lt;code&gt;:dynamic&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:modules&lt;/code&gt; -它应该是一个包含一个元素 &lt;code&gt;[module]&lt;/code&gt; 的列表，其中只有子进程是&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 时&lt;/a&gt;，module才是回调模块的名称；如果子进程是&lt;a href=&quot;genevent&quot;&gt; &lt;code&gt;GenEvent&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;:modules&lt;/code&gt; 应该是 &lt;code&gt;:dynamic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b46c49197edb9f631c7197843c5072be7a2e97cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:monotonic&lt;/code&gt; - the returned integer is monotonically increasing. This means that, on the same runtime instance (but even on different processes), integers returned using the &lt;code&gt;:monotonic&lt;/code&gt; modifier will always be strictly less than integers returned by successive calls with the &lt;code&gt;:monotonic&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;:monotonic&lt;/code&gt; -返回的整数单调递增。即，在相同的运行实例（但即使在不同的进程），整数使用返回，这意味着 &lt;code&gt;:monotonic&lt;/code&gt; 修改将始终严格小于通过连续调用返回的整数 &lt;code&gt;:monotonic&lt;/code&gt; 修改。</target>
        </trans-unit>
        <trans-unit id="fe1bf16ea612e21f7ed9d11d89e86df957666d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - (atom) the name of the function.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; -（原子）函数名称。</target>
        </trans-unit>
        <trans-unit id="50c8b0d3195f9dcf65699cef76043138713e0e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - a name to register the supervisor process. Supported values are explained in the &quot;Name registration&quot; section in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Optional.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; -注册主管进程的名称。支持的值在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档的&amp;ldquo;名称注册&amp;rdquo;部分中进行了说明。可选的。</target>
        </trans-unit>
        <trans-unit id="16f8eb524605e91d50e6381d13c1fec381bf9af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the name of the generated escript. Defaults to app name.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; name-生成的脚本的名称。默认为应用名称。</target>
        </trans-unit>
        <trans-unit id="2600c278c31a1e1c8298e6e701956a29855af335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the name of the registry and its tables</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; name-注册表及其表的名称</target>
        </trans-unit>
        <trans-unit id="128744a3dca6488c56f9f75cfe18ae9e4336a316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the test case name</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; -测试用例名称</target>
        </trans-unit>
        <trans-unit id="c3eb020586c1e91919b1e11fc875e674f851d758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the test name</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; -测试名称</target>
        </trans-unit>
        <trans-unit id="01a18172e153ec90bcdbca66d6e84c34c3288cc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - used for name registration as described in the &quot;Name registration&quot; section in the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用于名称注册，如GenServer文档中&amp;ldquo;名称注册&amp;rdquo;部分所述</target>
        </trans-unit>
        <trans-unit id="d74908d7eb54c999a9bfde3e2955191d78ff9678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - used to register a supervisor name, the supported values are described under the &lt;code&gt;Name Registration&lt;/code&gt; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs;</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用于注册管理员名称，支持的值在GenServer模块文档的&amp;ldquo; &lt;code&gt;Name Registration&lt;/code&gt; 部分中进行了描述；</target>
        </trans-unit>
        <trans-unit id="acfd8be1ce758b3026bf57dff69111e7fcd5a8ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:new_index&lt;/code&gt; - (integer) an index into the module function table.</source>
          <target state="translated">&lt;code&gt;:new_index&lt;/code&gt; -（整数）模块功能表的索引。</target>
        </trans-unit>
        <trans-unit id="161c527608bad21ffff501946a03419dfc142531" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:new_uniq&lt;/code&gt; - (binary) a unique value for this function. It's calculated from the compiled code for the entire module.</source>
          <target state="translated">&lt;code&gt;:new_uniq&lt;/code&gt; -（二进制）此函数的唯一值。它是根据整个模块的编译代码计算得出的。</target>
        </trans-unit>
        <trans-unit id="1f6fea81bc1e0f6b5eff26c026b0aee54699962a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nfc&lt;/code&gt; - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence.</source>
          <target state="translated">&lt;code&gt;:nfc&lt;/code&gt; -规范化形式规范组成。字符被分解，然后通过规范对等重新组合。</target>
        </trans-unit>
        <trans-unit id="7045d14e5dbaf635ddb7e2ebbfa3e40fdcbb6c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nfd&lt;/code&gt; - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</source>
          <target state="translated">&lt;code&gt;:nfd&lt;/code&gt; -规范化形式规范分解。字符通过规范等价分解，并且多个组合字符按特定顺序排列。</target>
        </trans-unit>
        <trans-unit id="4aa6af82b34423b1f6ea582b4cb31c825940854b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:noconnect&lt;/code&gt; - when used, if sending the message would require an auto-connection to another node the message is not sent and &lt;code&gt;:noconnect&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;:noconnect&lt;/code&gt; -使用时，如果发送消息需要自动连接到另一个节点，则不发送消息，并返回 &lt;code&gt;:noconnect&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e039a3b05df1dbc0406ab8f52dd05fb5a8365cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:none&lt;/code&gt; - does not return matching subpatterns at all</source>
          <target state="translated">&lt;code&gt;:none&lt;/code&gt; -完全不返回匹配的子模式</target>
        </trans-unit>
        <trans-unit id="e05cd3cd1ea9b5187e61dc703681711120bf8926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:none&lt;/code&gt; - if there is no translation, which triggers the next translator</source>
          <target state="translated">&lt;code&gt;:none&lt;/code&gt; -如果没有翻译，则触发下一个翻译器</target>
        </trans-unit>
        <trans-unit id="249a47ff9128b780dd1578c5de067a02d8afb0dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:normal&lt;/code&gt; - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes do not exit</source>
          <target state="translated">&lt;code&gt;:normal&lt;/code&gt; -在这种情况下，退出将不会被记录，在瞬态模式下不会重启，链接的进程也不会退出</target>
        </trans-unit>
        <trans-unit id="bf16a0cb151458c4bbe810828ac70da7a9c6b053" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:normal&lt;/code&gt; - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:normal&lt;/code&gt; -如果启动是正常启动，或者由于从另一个节点进行故障转移而应用程序已分发并在当前节点上启动，并且应用程序规范键 &lt;code&gt;:start_phases&lt;/code&gt; 为 &lt;code&gt;:undefined&lt;/code&gt; ,则使用此命令。</target>
        </trans-unit>
        <trans-unit id="0108614a94cf717462c8a940ce89f65176962e19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nosuspend&lt;/code&gt; - when used, if sending the message would cause the sender to be suspended the message is not sent and &lt;code&gt;:nosuspend&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;:nosuspend&lt;/code&gt; -使用时，如果发送消息将导致发件人被暂停，则不发送消息，并返回 &lt;code&gt;:nosuspend&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d697c6fad7644d5c44cc03beb2cdf09f070f143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on&lt;/code&gt; - specifies which captures to split the string on, and in what order. Defaults to &lt;code&gt;:first&lt;/code&gt; which means captures inside the regex do not affect the splitting process.</source>
          <target state="translated">&lt;code&gt;:on&lt;/code&gt; on-指定在哪个捕获上分割字符串，以什么顺序分割。默认为 &lt;code&gt;:first&lt;/code&gt; ，这意味着在正则表达式内捕获不会影响拆分过程。</target>
        </trans-unit>
        <trans-unit id="b63ce5b92cf87aaf8196a041e1faa21397a5e1a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_eof&lt;/code&gt; - if it should &lt;code&gt;:stop_evaluator&lt;/code&gt; (default) or &lt;code&gt;:halt&lt;/code&gt; the system</source>
          <target state="translated">&lt;code&gt;:on_eof&lt;/code&gt; -如果应该 &lt;code&gt;:stop_evaluator&lt;/code&gt; （默认）或 &lt;code&gt;:halt&lt;/code&gt; 系统</target>
        </trans-unit>
        <trans-unit id="d548253b9f1938f29a8cd30c79d0668b2da0b00f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_timeout&lt;/code&gt; - what do to when a task times out. The possible values are:</source>
          <target state="translated">&lt;code&gt;:on_timeout&lt;/code&gt; -任务超时时该怎么办。可能的值为：</target>
        </trans-unit>
        <trans-unit id="967f2648d4361145dec902214164deca8962ea9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_timeout&lt;/code&gt; - what to do when a task times out. The possible values are:</source>
          <target state="translated">&lt;code&gt;:on_timeout&lt;/code&gt; -任务超时时该怎么办。可能的值为：</target>
        </trans-unit>
        <trans-unit id="c005f28aee9fbfc4e81dfedffe4486f2021c9fd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:one_for_all&lt;/code&gt; - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted.</source>
          <target state="translated">&lt;code&gt;:one_for_all&lt;/code&gt; -如果子进程终止，则所有其他子进程终止，然后所有子进程（包括终止的子进程）重新启动。</target>
        </trans-unit>
        <trans-unit id="0336c9bdb63340074782b8de5a2753c895868b6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:one_for_one&lt;/code&gt; - if a child process terminates, only that process is restarted.</source>
          <target state="translated">&lt;code&gt;:one_for_one&lt;/code&gt; -如果子进程终止，则仅重新启动该进程。</target>
        </trans-unit>
        <trans-unit id="49745e56745dd2d278e647db8397f06e8ac4651a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only&lt;/code&gt; - the dependency is made available only in the given environments, useful when declaring dev- or test-only dependencies; by default the dependency will be available in all environments. The value of this option can either be a single environment (like &lt;code&gt;:dev&lt;/code&gt;) or a list of environments (like &lt;code&gt;[:dev, :test]&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:only&lt;/code&gt; only-依赖关系仅在给定的环境中可用，在声明仅开发或测试依赖项时很有用；默认情况下，依赖关系将在所有环境中可用。此选项的值可以是单个环境（例如 &lt;code&gt;:dev&lt;/code&gt; ），也可以是环境列表（例如 &lt;code&gt;[:dev, :test]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b4a49a5b1a71967998498e4f9c663e9db62e642a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only_operators&lt;/code&gt; - includes only operators</source>
          <target state="translated">&lt;code&gt;:only_operators&lt;/code&gt; -仅包含运算符</target>
        </trans-unit>
        <trans-unit id="89ac265643029bb4e9eb87a3a1eb43a83ac0e877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only_test_ids&lt;/code&gt; - a list of &lt;code&gt;{module_name, test_name}&lt;/code&gt; tuples that limits what tests get run;</source>
          <target state="translated">&lt;code&gt;:only_test_ids&lt;/code&gt; - &lt;code&gt;{module_name, test_name}&lt;/code&gt; 元组的列表，用于限制运行哪些测试；</target>
        </trans-unit>
        <trans-unit id="63e34ca0c4f83325812704dbfa01fc6f74cf793a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:opt_release&lt;/code&gt; - OTP release it was compiled with</source>
          <target state="translated">&lt;code&gt;:opt_release&lt;/code&gt; -编译时使用的OTP版本</target>
        </trans-unit>
        <trans-unit id="759987ebbfa09610ba0e7f6e23e613bfab1fb35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:optional&lt;/code&gt; - marks the dependency as optional. In such cases, the current project will always include the optional dependency but any other project that depends on the current project won't be forced to use the optional dependency. However, if the other project includes the optional dependency on its own, the requirements and options specified here will also be applied.</source>
          <target state="translated">&lt;code&gt;:optional&lt;/code&gt; -将依赖项标记为可选。在这种情况下，当前项目将始终包含可选依赖项，但是依赖于当前项目的任何其他项目都不会被迫使用可选依赖项。但是，如果另一个项目本身包括可选依赖项，则此处指定的要求和选项也将适用。</target>
        </trans-unit>
        <trans-unit id="aa75a186c5e0b6e3cd756723da44fdbe7c72a94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ordered&lt;/code&gt; - whether the results should be returned in the same order as the input stream. This option is useful when you have large streams and don't want to buffer results before they are delivered. This is also useful when you're using the tasks for side effects. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:ordered&lt;/code&gt; -结果是否应该以与输入流相同的顺序返回。当您有大量流并且不想在结果交付之前对其进行缓冲时，此选项很有用。当您将任务用于副作用时，这也很有用。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="109bd51b27eae75e1fd5751b4effad28d8d6894c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:output&lt;/code&gt; - the output directory for cover results. Defaults to &lt;code&gt;&quot;cover&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:output&lt;/code&gt; -封面结果的输出目录。默认为 &lt;code&gt;&quot;cover&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dae0f0ed816b6755246a3425d7e89c8cbe1617c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:override&lt;/code&gt; - if set to &lt;code&gt;true&lt;/code&gt; the dependency will override any other definitions of itself by other dependencies</source>
          <target state="translated">&lt;code&gt;:override&lt;/code&gt; -如果设置为 &lt;code&gt;true&lt;/code&gt; ,则依赖项将被其他依赖项覆盖其自身的任何其他定义</target>
        </trans-unit>
        <trans-unit id="ee21d75db571092b33f3c6e04150d8d96d12186b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:owner&lt;/code&gt; - the PID of the process that started the task</source>
          <target state="translated">&lt;code&gt;:owner&lt;/code&gt; -启动任务的进程的PID</target>
        </trans-unit>
        <trans-unit id="c871b777e9d6dc410ad77517a57eb10ea04f208d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:padding&lt;/code&gt; - specifies whether to apply padding</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; -指定是否应用填充</target>
        </trans-unit>
        <trans-unit id="05b6bc5dd9b9c177e298ed308bd0312e9879c46e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:padding&lt;/code&gt; - specifies whether to require padding</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; -指定是否需要填充</target>
        </trans-unit>
        <trans-unit id="7e85cd35375539c186e4ef217380868547a2f1d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parallelism&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, the VM will schedule port tasks to improve parallelism in the system. If set to &lt;code&gt;false&lt;/code&gt;, the VM will try to perform commands immediately, improving latency at the expense of parallelism. The default can be set on system startup by passing the &quot;+spp&quot; argument to &lt;code&gt;--erl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:parallelism&lt;/code&gt; -当 &lt;code&gt;true&lt;/code&gt; ，虚拟机将安排端口的任务，以提高系统的并行性。如果设置为 &lt;code&gt;false&lt;/code&gt; ，VM将尝试立即执行命令，从而以牺牲并行度为代价来改善延迟。可以在系统启动时通过将&amp;ldquo; + spp&amp;rdquo;参数传递给 &lt;code&gt;--erl&lt;/code&gt; 来设置默认值。</target>
        </trans-unit>
        <trans-unit id="102eba9adcb8ff5954a857f9e93f446ec880188e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parents&lt;/code&gt; - starts the dependency traversal from the given parents instead of the application root</source>
          <target state="translated">&lt;code&gt;:parents&lt;/code&gt; parents-从给定的父级而不是应用程序根目录开始遍历依赖项</target>
        </trans-unit>
        <trans-unit id="3623e6b3ee4e48790eba50c01efff6e8f6ad8dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:partitions&lt;/code&gt; - the number of partitions in the registry. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:partitions&lt;/code&gt; -注册表中的分区数。默认为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbe591931e54f52a5cb6243fb366662ce3c9e43a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parts&lt;/code&gt; (positive integer or &lt;code&gt;:infinity&lt;/code&gt;) - the string is split into at most as many parts as this option specifies. If &lt;code&gt;:infinity&lt;/code&gt;, the string will be split into all possible parts. Defaults to &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:parts&lt;/code&gt; （正整数或 &lt;code&gt;:infinity&lt;/code&gt; ）-字符串最多可拆分为该选项指定的部分。如果 &lt;code&gt;:infinity&lt;/code&gt; ，则字符串将分为所有可能的部分。默认为 &lt;code&gt;:infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="738e4711d24c22556e9769f827fc877a333c3ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parts&lt;/code&gt; - when specified, splits the string into the given number of parts. If not specified, &lt;code&gt;:parts&lt;/code&gt; defaults to &lt;code&gt;:infinity&lt;/code&gt;, which will split the string into the maximum number of parts possible based on the given pattern.</source>
          <target state="translated">&lt;code&gt;:parts&lt;/code&gt; parts-指定后，将字符串拆分为给定数量的部分。如果未指定， &lt;code&gt;:parts&lt;/code&gt; 默认为 &lt;code&gt;:infinity&lt;/code&gt; ，它将根据给定的模式将字符串分割为最大可能的部分数。</target>
        </trans-unit>
        <trans-unit id="f8406b284a5d9f169d7ef202053625ca78690289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:path&lt;/code&gt; - the path for the dependency</source>
          <target state="translated">&lt;code&gt;:path&lt;/code&gt; -依赖关系的路径</target>
        </trans-unit>
        <trans-unit id="b56c1cc4784009d5aadab5d03f37af62be889258" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:path&lt;/code&gt; - the path to write the escript to. Defaults to app name.</source>
          <target state="translated">&lt;code&gt;:path&lt;/code&gt; path-将脚本写入的路径。默认为应用名称。</target>
        </trans-unit>
        <trans-unit id="37ef1282fca65e1ae92072e62b8991b4072fcb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates, all other applications and the entire node are also terminated.</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; -如果 &lt;code&gt;app&lt;/code&gt; 终止，则所有其他应用程序和整个节点也终止。</target>
        </trans-unit>
        <trans-unit id="8173b1a9fdd8413821b53ff0d59ff5ae7d56eec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - the child process is always restarted</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; -子进程始终重新启动</target>
        </trans-unit>
        <trans-unit id="234321a1e7ed8d159948d60118f2b6f61e82c18f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - the child process is always restarted.</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; -子进程始终重新启动。</target>
        </trans-unit>
        <trans-unit id="5af1c24ccb0c6eacd3bee795d8a1eb3bffe04c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:persist&lt;/code&gt; - the attribute will be persisted in the Erlang Abstract Format. Useful when interfacing with Erlang libraries.</source>
          <target state="translated">&lt;code&gt;:persist&lt;/code&gt; -该属性将以Erlang抽象格式保存。与Erlang库连接时很有用。</target>
        </trans-unit>
        <trans-unit id="95c886b860026fac40b14994cc8c7589bc9d5579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:persistent&lt;/code&gt; - persists the given value on application load and reloads</source>
          <target state="translated">&lt;code&gt;:persistent&lt;/code&gt; -在应用程序加载时持久保存给定值，然后重新加载</target>
        </trans-unit>
        <trans-unit id="c1e21c7b8be8dd8f64aa4684e89339f074ceea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - PID of the process that originally created the function.</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; -最初创建函数的进程的PID。</target>
        </trans-unit>
        <trans-unit id="6fdd59eeb918211220a78f33fe0ea77139aabb39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - the PID of the task process; &lt;code&gt;nil&lt;/code&gt; if the task does not use a task process</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; -任务进程的PID；如果任务不使用任务进程，则为 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89fc2eba42a25521afbb74432f41643f75e1cb86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - the current process identifier</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; -当前进程标识符</target>
        </trans-unit>
        <trans-unit id="b5003a88b1f32f3ca59143861dd60c14442ca836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pop&lt;/code&gt;, which implies that the current value under &lt;code&gt;key&lt;/code&gt; should be removed from the structure and returned.</source>
          <target state="translated">&lt;code&gt;:pop&lt;/code&gt; ，这意味着应将 &lt;code&gt;key&lt;/code&gt; 下的当前值从结构中删除并返回。</target>
        </trans-unit>
        <trans-unit id="c23ced478543f9465b4975d50e6ad67db0bc29fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:positive&lt;/code&gt; - the returned integer is guaranteed to be positive.</source>
          <target state="translated">&lt;code&gt;:positive&lt;/code&gt; -返回的整数保证为正。</target>
        </trans-unit>
        <trans-unit id="b7eca98f205a2eb6fa4afcfa1aaf0a99d46382c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:posix&lt;/code&gt; - returns the time as integer seconds since epoch</source>
          <target state="translated">&lt;code&gt;:posix&lt;/code&gt; -返回自纪元以来的时间，以整数秒为单位</target>
        </trans-unit>
        <trans-unit id="ea02bc9a384e4edfcb6c2cc741dc4786b967cbd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:preferred_cli_env&lt;/code&gt; - a keyword list of &lt;code&gt;{task, env}&lt;/code&gt; tuples where &lt;code&gt;task&lt;/code&gt; is the task name as an atom (for example, &lt;code&gt;:&quot;deps.get&quot;&lt;/code&gt;) and &lt;code&gt;env&lt;/code&gt; is the preferred environment (for example, &lt;code&gt;:test&lt;/code&gt;). This option overrides what is specified by the tasks with the &lt;code&gt;@preferred_cli_env&lt;/code&gt; attribute (see the docs for &lt;a href=&quot;mix.task&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt;). Defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:preferred_cli_env&lt;/code&gt; - &lt;code&gt;{task, env}&lt;/code&gt; 元组的关键字列表，其中 &lt;code&gt;task&lt;/code&gt; 是作为原子的任务名称（例如 &lt;code&gt;:&quot;deps.get&quot;&lt;/code&gt; ），而 &lt;code&gt;env&lt;/code&gt; 是首选环境（例如 &lt;code&gt;:test&lt;/code&gt; ）。此选项将覆盖任务使用 &lt;code&gt;@preferred_cli_env&lt;/code&gt; 属性指定的内容（请参见文档&lt;a href=&quot;mix.task&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; &lt;/a&gt;）。默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae71f650b5c3ff499f225d9db2c4ded70c2ae8af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:preferred_cli_target&lt;/code&gt; - a keyword list of &lt;code&gt;{task, target}&lt;/code&gt; tuples where &lt;code&gt;task&lt;/code&gt; is the task name as an atom (for example, &lt;code&gt;:test&lt;/code&gt;) and &lt;code&gt;target&lt;/code&gt; is the preferred target (for example, &lt;code&gt;:host&lt;/code&gt;). Defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:preferred_cli_target&lt;/code&gt; - &lt;code&gt;{task, target}&lt;/code&gt; 元组的关键字列表，其中 &lt;code&gt;task&lt;/code&gt; 是作为原子的任务名称（例如 &lt;code&gt;:test&lt;/code&gt; ），而 &lt;code&gt;target&lt;/code&gt; 是首选目标（例如 &lt;code&gt;:host&lt;/code&gt; ）。默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="144b18390df45b9e362d37e94ce800c0b5df1bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prefix&lt;/code&gt; - the IEx prefix</source>
          <target state="translated">&lt;code&gt;:prefix&lt;/code&gt; -将IEx中的前缀</target>
        </trans-unit>
        <trans-unit id="825668baf0806b14b62d6651ff422468cea677d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pretty&lt;/code&gt; - if set to &lt;code&gt;true&lt;/code&gt; enables pretty printing, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:pretty&lt;/code&gt; -如果设置为 &lt;code&gt;true&lt;/code&gt; 则启用漂亮打印，默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8601a8e7eca3b625cc8cb07702803a2fe0b6855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:printable&lt;/code&gt; - the string is split into chunks of printable and non-printable character sequences</source>
          <target state="translated">&lt;code&gt;:printable&lt;/code&gt; -字符串分为可打印和不可打印字符序列的块</target>
        </trans-unit>
        <trans-unit id="79f3790d5f2a7ff6e99ae9f98dc69012ae7abae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:printable_limit&lt;/code&gt; - limits the number of characters that are inspected on printable strings and printable charlists. You can use &lt;a href=&quot;string#printable?/1&quot;&gt;&lt;code&gt;String.printable?/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list#ascii_printable?/1&quot;&gt;&lt;code&gt;List.ascii_printable?/1&lt;/code&gt;&lt;/a&gt; to check if a given string or charlist is printable. Defaults to 4096. If you don't want to limit the number of characters to a particular number, use &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:printable_limit&lt;/code&gt; -限制在可打印字符串和可打印字符列表上检查的字符数。您可以使用&lt;a href=&quot;string#printable?/1&quot;&gt; &lt;code&gt;String.printable?/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;list#ascii_printable?/1&quot;&gt; &lt;code&gt;List.ascii_printable?/1&lt;/code&gt; &lt;/a&gt;来检查给定的字符串或字符列表是否可打印。默认值为4096。如果您不想将字符数限制为特定数字，请使用 &lt;code&gt;:infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="410adb09a6ecf7e6416cfacc8be4f6d5ae1a9cb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prod&lt;/code&gt; - the environment your dependencies run on</source>
          <target state="translated">&lt;code&gt;:prod&lt;/code&gt; -您的依赖运行的环境</target>
        </trans-unit>
        <trans-unit id="7a4f54da6e36123b2d0abcd43ec7c9b1ec1bb3a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prod&lt;/code&gt; - the one you will use to run your project in production</source>
          <target state="translated">&lt;code&gt;:prod&lt;/code&gt; -用于在生产中运行项目的那个</target>
        </trans-unit>
        <trans-unit id="e2b4fb1538eb0b3321b10395f6eeb08b1757f804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prune_metadata&lt;/code&gt; - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs, never values. Defaults to false.</source>
          <target state="translated">&lt;code&gt;:prune_metadata&lt;/code&gt; -为 true时，从转义的AST节点中删除元数据。请注意，此选项更改了转义代码的语义，并且仅应在转义AST时使用，而从不使用值。默认为false。</target>
        </trans-unit>
        <trans-unit id="6bfc26e873b6c092ea866965157d01fa76cb5ee3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:raw&lt;/code&gt; - a single atom to bypass the file server and only check for the file locally</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; -单个原子绕过文件服务器，仅在本地检查文件</target>
        </trans-unit>
        <trans-unit id="837ead4ba27d5e026c9a07708c1e9ca692ba17c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:read&lt;/code&gt; - the file, which must exist, is opened for reading.</source>
          <target state="translated">&lt;code&gt;:read&lt;/code&gt; -必须存在的文件已打开以进行读取。</target>
        </trans-unit>
        <trans-unit id="41f2b24882408cbe66a5f9e787bb34bbad9bb826" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ref&lt;/code&gt; - the reference to checkout (may be a branch, a commit SHA or a tag)</source>
          <target state="translated">&lt;code&gt;:ref&lt;/code&gt; -签出的引用（可以是分支，提交SHA或标记）</target>
        </trans-unit>
        <trans-unit id="9d480f66df0057bb82616e58781811e154a72adc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ref&lt;/code&gt; - the task monitor reference</source>
          <target state="translated">&lt;code&gt;:ref&lt;/code&gt; -任务监视器参考</target>
        </trans-unit>
        <trans-unit id="417480cff77826d3dfc29a2ea00d2a119bdc3ade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:refute_receive_timeout&lt;/code&gt; - the timeout to be used on &lt;code&gt;refute_receive&lt;/code&gt; calls in milliseconds, defaults to &lt;code&gt;100&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:refute_receive_timeout&lt;/code&gt; -用于 &lt;code&gt;refute_receive&lt;/code&gt; 调用的超时（以毫秒为单位），默认为 &lt;code&gt;100&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="229b5c7ed45f45fed3bc29a08eb916ef712f16c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:registered&lt;/code&gt; - used for &lt;a href=&quot;exunit.case#register_attribute/3&quot;&gt;&lt;code&gt;ExUnit.Case.register_attribute/3&lt;/code&gt;&lt;/a&gt; values</source>
          <target state="translated">&lt;code&gt;:registered&lt;/code&gt; -用于&lt;a href=&quot;exunit.case#register_attribute/3&quot;&gt; &lt;code&gt;ExUnit.Case.register_attribute/3&lt;/code&gt; &lt;/a&gt;值</target>
        </trans-unit>
        <trans-unit id="76107f04b252aa2d494b9f3ac57d2e536b8f063b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:registered_name&lt;/code&gt; - the process registered name as an atom</source>
          <target state="translated">&lt;code&gt;:registered_name&lt;/code&gt; -进程注册名称为atom</target>
        </trans-unit>
        <trans-unit id="06becb331a4b35f5874f87f1f273eb1acc1b1ccd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:relative_paths&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, use relative paths in quoted nodes, warnings and errors generated by the compiler. Note disabling this option won't affect runtime warnings and errors. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:relative_paths&lt;/code&gt; -当 &lt;code&gt;true&lt;/code&gt; ，使用编译器生成引用节点，警告和错误的相对路径。请注意，禁用此选项不会影响运行时警告和错误。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c9b9529236ac69920375f4608006430e5e82f28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:rename_deprecated_at&lt;/code&gt; - rename all known deprecated functions at the given version to their non-deprecated equivalent. It expects a valid &lt;a href=&quot;version&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; which is usually the minimum Elixir version supported by the project.</source>
          <target state="translated">&lt;code&gt;:rename_deprecated_at&lt;/code&gt; -将给定版本中所有已知的不推荐使用的功能重命名为它们的不推荐使用的等效功能。它需要一个有效的&lt;a href=&quot;version&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;，通常是项目支持的最低Elixir版本。</target>
        </trans-unit>
        <trans-unit id="a041a0b82d4d647034a3e36bbcb3cd58280dd271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:requires&lt;/code&gt; - a list of modules required</source>
          <target state="translated">&lt;code&gt;:requires&lt;/code&gt; -所需模块列表</target>
        </trans-unit>
        <trans-unit id="94cf107e8f2ec96f62b5bcda4ba38f57ecdf19f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:rest_for_one&lt;/code&gt; - if a child process terminates, the terminated child process and the rest of the children started after it, are terminated and restarted.</source>
          <target state="translated">&lt;code&gt;:rest_for_one&lt;/code&gt; -如果子进程终止，终止的子进程以及在其之后启动的其余子进程将终止并重新启动。</target>
        </trans-unit>
        <trans-unit id="68e05441de900538fe9477d909c390fedde76193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below)</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -一个原子，它定义何时应重新启动终止的子进程（请参阅下面的&amp;ldquo;重新启动值&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="c3f56495278d055220a28af1dee51e5d16162127" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below). This key is optional and defaults to &lt;code&gt;:permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -一个原子，它定义何时应重新启动终止的子进程（请参见下面的&amp;ldquo;重新启动值&amp;rdquo;部分）。该密钥是可选的，默认为 &lt;code&gt;:permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31df30af299f360d0ce36c8750e7fac18dea49e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - the restart strategy, may be &lt;code&gt;:temporary&lt;/code&gt; (the default), &lt;code&gt;:transient&lt;/code&gt; or &lt;code&gt;:permanent&lt;/code&gt;. &lt;code&gt;:temporary&lt;/code&gt; means the task is never restarted, &lt;code&gt;:transient&lt;/code&gt; means it is restarted if the exit is not &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, reason}&lt;/code&gt;. A &lt;code&gt;:permanent&lt;/code&gt; restart strategy means it is always restarted. It defaults to &lt;code&gt;:temporary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -重新启动策略，可以是 &lt;code&gt;:temporary&lt;/code&gt; （默认） &lt;code&gt;:transient&lt;/code&gt; 或 &lt;code&gt;:permanent&lt;/code&gt; 。 &lt;code&gt;:temporary&lt;/code&gt; 表示该任务永不重启， &lt;code&gt;:transient&lt;/code&gt; 表示如果出口不是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, reason}&lt;/code&gt; 则重启该任务。一 &lt;code&gt;:permanent&lt;/code&gt; 重启策略意味着它总是重新启动。默认为 &lt;code&gt;:temporary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d94868512153cae048d95355b79448372cfe504b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the child should be restarted, defaults to &lt;code&gt;:permanent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -当应该重新启动子级时，默认为 &lt;code&gt;:permanent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c63e56060e5424b4a88bbcfb341afd200f5f7897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the child should be restarted, defaults to &lt;code&gt;:temporary&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -当应该重新启动子级时，默认为 &lt;code&gt;:temporary&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6de1858d17c1b3a7b52262da84be82d05ba0d46d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the supervisor should be restarted, defaults to &lt;code&gt;:permanent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; -主管重启时，默认为 &lt;code&gt;:permanent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="440372047cb7510fed08fef14217a8f597bd7289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:return&lt;/code&gt; - set to &lt;code&gt;:index&lt;/code&gt; to return byte index and match length. Defaults to &lt;code&gt;:binary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:return&lt;/code&gt; -设置为 &lt;code&gt;:index&lt;/code&gt; 以返回字节索引和匹配长度。默认为 &lt;code&gt;:binary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38002dbf053bffbccd100620de9a971d9751a6b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:revision&lt;/code&gt; - short Git revision hash. If Git was not available at building time, it is set to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:revision&lt;/code&gt; -简短的Git修订哈希。如果在构建时Git不可用，则将其设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ad37a4945d66cff0b511df34d8cb047955022d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:runtime&lt;/code&gt; - whether the dependency is part of runtime applications. If the &lt;code&gt;:applications&lt;/code&gt; key is not provided in &lt;code&gt;def application&lt;/code&gt; in your &lt;code&gt;mix.exs&lt;/code&gt; file, Mix will automatically include all dependencies as a runtime application, except if &lt;code&gt;runtime: false&lt;/code&gt; is given. Defaults to true.</source>
          <target state="translated">&lt;code&gt;:runtime&lt;/code&gt; -依赖项是否是运行时应用程序的一部分。如果您的 &lt;code&gt;mix.exs&lt;/code&gt; 文件的 &lt;code&gt;def application&lt;/code&gt; 中未提供 &lt;code&gt;:applications&lt;/code&gt; 密钥，则Mix将自动将所有依赖项包含为运行时应用程序，除非给出 &lt;code&gt;runtime: false&lt;/code&gt; 。默认为true。</target>
        </trans-unit>
        <trans-unit id="00d27bf7444b8506e92e835fad445d9f5d17c7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:safe&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, failures while inspecting structs will be raised as errors instead of being wrapped in the &lt;a href=&quot;inspect.error&quot;&gt;&lt;code&gt;Inspect.Error&lt;/code&gt;&lt;/a&gt; exception. This is useful when debugging failures and crashes for custom inspect implementations.</source>
          <target state="translated">&lt;code&gt;:safe&lt;/code&gt; &lt;a href=&quot;inspect.error&quot;&gt; &lt;code&gt;Inspect.Error&lt;/code&gt; &lt;/a&gt;如果为 &lt;code&gt;false&lt;/code&gt; ，则检查结构失败将作为错误而不是被包装在Inspect.Error异常中。当调试失败和自定义检查实现的崩溃时，这很有用。</target>
        </trans-unit>
        <trans-unit id="001fb2888a3bbf8f2282716dcd9bc9e213771931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, etc. (v1.4)</source>
          <target state="translated">&lt;code&gt;:second&lt;/code&gt; ， &lt;code&gt;:millisecond&lt;/code&gt; 等（v1.4）</target>
        </trans-unit>
        <trans-unit id="fc20f799112d39f70e51b99fd18bdd1c1ee396e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:seconds&lt;/code&gt;, &lt;code&gt;:milliseconds&lt;/code&gt;, etc. as time units</source>
          <target state="translated">&lt;code&gt;:seconds&lt;/code&gt; ， &lt;code&gt;:milliseconds&lt;/code&gt; 等作为时间单位</target>
        </trans-unit>
        <trans-unit id="998c92a04eac1b1ae60c5fb46272bef007b2eaa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:seed&lt;/code&gt; - an integer seed value to randomize the test suite. This seed is also mixed with the test module and name to create a new unique seed on every test, which is automatically fed into the &lt;code&gt;:rand&lt;/code&gt; module. This provides randomness between tests, but predictable and reproducible results;</source>
          <target state="translated">&lt;code&gt;:seed&lt;/code&gt; -整数种子值，用于随机化测试套件。该种子也与测试模块和名称混合在一起，以在每个测试上创建一个新的唯一种子，该种子会自动输入到 &lt;code&gt;:rand&lt;/code&gt; 模块中。这提供了测试之间的随机性，但可预测和可再现的结果。</target>
        </trans-unit>
        <trans-unit id="6f522c42e08b6faff3741f41a44a8b151be7a4ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:separator&lt;/code&gt; - the separator used between each doc</source>
          <target state="translated">&lt;code&gt;:separator&lt;/code&gt; -每个文档之间使用的分隔符</target>
        </trans-unit>
        <trans-unit id="3df407e63d4f1dd306d22158c48447875dcd44a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shebang&lt;/code&gt; - shebang interpreter directive used to execute the escript. Defaults to &lt;code&gt;&quot;#! /usr/bin/env escript\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:shebang&lt;/code&gt; shebang-用于执行脚本的shebang解释器指令。默认为 &lt;code&gt;&quot;#! /usr/bin/env escript\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac59fe1ea179551b1d0d56d67d2e5ba3c352a0ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; 如果任务必须直接在关机或表示5000毫秒的超时值，默认整数被杀死。</target>
        </trans-unit>
        <trans-unit id="936a9bb35e41ad39f3649a9ecb5c019ee144362b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; if the tasks must be killed directly on shutdown or an integer indicating the timeout value. Defaults to &lt;code&gt;5000&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; 如果任务必须直接在关机或表示超时值的整数被杀死。默认为 &lt;code&gt;5000&lt;/code&gt; 毫秒。</target>
        </trans-unit>
        <trans-unit id="1cf41cf5f20acc429222ecbf9a193bced833b34a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below)</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; -定义子进程终止方式的原子（请参见下面的&amp;ldquo; Shutdown值&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="9620978d3a10c2d505e327fdfaf699eced8b0449" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below). This key is optional and defaults to &lt;code&gt;5000&lt;/code&gt; if the type is &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:infinity&lt;/code&gt; if the type is &lt;code&gt;:supervisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; -定义子进程终止方式的原子（请参见下面的&amp;ldquo; Shutdown值&amp;rdquo;部分）。此键是可选的，默认为 &lt;code&gt;5000&lt;/code&gt; ，如果类型是 &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:infinity&lt;/code&gt; ，如果类型是 &lt;code&gt;:supervisor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddcaa1d742adc479e7f57ff4367400cc87484a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - how to shut down the child, either immediately or by giving it time to shut down</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; -如何立即关闭孩子或给它时间关闭孩子</target>
        </trans-unit>
        <trans-unit id="b1aba46cc3edbcb6180c7652dcd34c6ba320a2c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt; - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they're trapping exits</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, term}&lt;/code&gt; -在这种情况下，将不会记录退出，在瞬态模式下不会重新启动，并且链接的进程会以相同的原因退出，除非它们捕获了退出</target>
        </trans-unit>
        <trans-unit id="266532d049cf506370e108062bc4a50658b5256d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip&lt;/code&gt; - if the message is not meant to be translated nor logged</source>
          <target state="translated">&lt;code&gt;:skip&lt;/code&gt; -如果消息既不打算翻译也不记录</target>
        </trans-unit>
        <trans-unit id="ff7f81cb7821c0feece478ab371981af6cf1f69a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip&lt;/code&gt; - skips the test with the given reason</source>
          <target state="translated">&lt;code&gt;:skip&lt;/code&gt; -跳过给定原因的测试</target>
        </trans-unit>
        <trans-unit id="022caec0dc167b29f0c878de3ec67c7ab0c56551" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip_operators&lt;/code&gt; - skips operators</source>
          <target state="translated">&lt;code&gt;:skip_operators&lt;/code&gt; -跳过运算符</target>
        </trans-unit>
        <trans-unit id="a4b3697aab2485b4ee7ea6ef4fb2eecc63a70d5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:slowest&lt;/code&gt; - prints timing information for the N slowest tests. Running ExUnit with slow test reporting automatically runs in &lt;code&gt;trace&lt;/code&gt; mode. It is disabled by default;</source>
          <target state="translated">&lt;code&gt;:slowest&lt;/code&gt; -打印N个最慢测试的计时信息。以慢速测试报告运行ExUnit会自动以 &lt;code&gt;trace&lt;/code&gt; 模式运行。默认禁用。</target>
        </trans-unit>
        <trans-unit id="61a5ecc1db838c978ad68e03c29acffb369c9b18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sort&lt;/code&gt; - sort the results by &lt;code&gt;:time&lt;/code&gt; or &lt;code&gt;:calls&lt;/code&gt; (default: &lt;code&gt;:time&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:sort&lt;/code&gt; -按 &lt;code&gt;:time&lt;/code&gt; 或 &lt;code&gt;:calls&lt;/code&gt; 对结果进行排序（默认值 &lt;code&gt;:time&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5a0fbd35060bc33058f26c75fbb0786746853984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sort&lt;/code&gt; - sorts the output by given key: &lt;code&gt;:acc&lt;/code&gt; (default) or &lt;code&gt;:own&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:sort&lt;/code&gt; -按给定的键对输出进行排序 &lt;code&gt;:acc&lt;/code&gt; （默认）或 &lt;code&gt;:own&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7c0ae6bc71ab6ce71807d74b1d6644314067777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sparse&lt;/code&gt; - checkout a single directory inside the Git repository and use it as your Mix dependency. Search &quot;sparse git checkouts&quot; for more information.</source>
          <target state="translated">&lt;code&gt;:sparse&lt;/code&gt; -在Git存储库中签出一个目录，并将其用作您的Mix依赖项。搜索&amp;ldquo;稀疏git checkouts&amp;rdquo;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8f14b0c78d56b7cb533ee482d5f2f0bb4eb40c9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:spawn&lt;/code&gt; will retrieve the program name from the argument and traverse your operating system &lt;code&gt;$PATH&lt;/code&gt; environment variable looking for a matching program.</source>
          <target state="translated">&lt;code&gt;:spawn&lt;/code&gt; 将从参数中检索程序名称，并遍历您的操作系统 &lt;code&gt;$PATH&lt;/code&gt; 环境变量以查找匹配的程序。</target>
        </trans-unit>
        <trans-unit id="1bc8c2fc08c495bee7787edbf2eea78df04638c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:spawn_opt&lt;/code&gt; - if present, its value is passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:spawn_opt&lt;/code&gt; -如果存在，则将其值作为选项传递给基础进程，如&lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd4275872253e2afba277f439142884806fb692e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:specs&lt;/code&gt; - the number of children processes</source>
          <target state="translated">&lt;code&gt;:specs&lt;/code&gt; -子进程数</target>
        </trans-unit>
        <trans-unit id="3a46b61f201e318f7905a2d0fe61831192204a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:specs&lt;/code&gt; - the total count of children, dead or alive</source>
          <target state="translated">&lt;code&gt;:specs&lt;/code&gt; -生或死的孩子总数</target>
        </trans-unit>
        <trans-unit id="9d3891b26de246a89814cfdd208bf4676f78f7f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stack_info&lt;/code&gt; - ... the stacktrace color</source>
          <target state="translated">&lt;code&gt;:stack_info&lt;/code&gt; -... stacktrace颜色</target>
        </trans-unit>
        <trans-unit id="0070dccb5edec0c3460ca92eea2a5ff294243a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stacktrace_depth&lt;/code&gt; - configures the stacktrace depth to be used on formatting and reporters, defaults to &lt;code&gt;20&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:stacktrace_depth&lt;/code&gt; -配置要用于格式化和报告程序的stacktrace深度，默认为 &lt;code&gt;20&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="81aa5a013a0b30e71264b2a6df647e044f117888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:start&lt;/code&gt; - a tuple with the module-function-args to be invoked to start the child process. This key is required.</source>
          <target state="translated">&lt;code&gt;:start&lt;/code&gt; -一个带有模块功能参数的元组，以启动子进程。此密钥是必需的。</target>
        </trans-unit>
        <trans-unit id="e4389c8a4f1e9e9b79cd01871ba2e306282798fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:state&lt;/code&gt; - the finished test state (see &lt;a href=&quot;exunit#t:state/0&quot;&gt;&lt;code&gt;ExUnit.state/0&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;:state&lt;/code&gt; &lt;a href=&quot;exunit#t:state/0&quot;&gt; &lt;code&gt;ExUnit.state/0&lt;/code&gt; &lt;/a&gt;完成的测试状态（请参阅ExUnit.state / 0）</target>
        </trans-unit>
        <trans-unit id="060b62ea4c1cd006950ab4a603b2e3d10c314354" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:state&lt;/code&gt; - the test error state (see &lt;a href=&quot;exunit#t:state/0&quot;&gt;&lt;code&gt;ExUnit.state/0&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;:state&lt;/code&gt; &lt;a href=&quot;exunit#t:state/0&quot;&gt; &lt;code&gt;ExUnit.state/0&lt;/code&gt; &lt;/a&gt;测试错误状态（请参阅ExUnit.state / 0）</target>
        </trans-unit>
        <trans-unit id="4e8e9dbb5db3d0c5b133a1711403f03c2707f93c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:static_atom_encoder&lt;/code&gt; - The static atom encoder function, see &quot;The &lt;code&gt;:static_atom_encoder&lt;/code&gt; function&quot; section below. This option overrides the &lt;code&gt;:existing_atoms_only&lt;/code&gt; behaviour for static atoms but &lt;code&gt;:existing_atoms_only&lt;/code&gt; is still used for dynamic atoms, such as atoms with interpolations.</source>
          <target state="translated">&lt;code&gt;:static_atom_encoder&lt;/code&gt; -静态原子编码器功能，请参见下面的&amp;ldquo; &lt;code&gt;:static_atom_encoder&lt;/code&gt; 函数&amp;rdquo;部分。该选项覆盖静态原子的 &lt;code&gt;:existing_atoms_only&lt;/code&gt; 行为，但 &lt;code&gt;:existing_atoms_only&lt;/code&gt; 仍用于动态原子，例如具有插值的原子。</target>
        </trans-unit>
        <trans-unit id="343ef905fb4f21e5d27635c8e9062e23d8bcc3a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stderr&lt;/code&gt; - a shortcut for the named process &lt;code&gt;:standard_error&lt;/code&gt; provided in Erlang</source>
          <target state="translated">&lt;code&gt;:stderr&lt;/code&gt; - Erlang中提供的命名过程 &lt;code&gt;:standard_error&lt;/code&gt; 的快捷方式</target>
        </trans-unit>
        <trans-unit id="2f83bee1f54001a194ca817ca04fac4082d02743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stderr_to_stdout&lt;/code&gt; - redirects stderr to stdout when &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:stderr_to_stdout&lt;/code&gt; -为 &lt;code&gt;true&lt;/code&gt; 时将stderr重定向到stdout</target>
        </trans-unit>
        <trans-unit id="e60878611aa41a0dc31c7c64864c5d1bd0faed6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stdio&lt;/code&gt; - a shortcut for &lt;code&gt;:standard_io&lt;/code&gt;, which maps to the current &lt;a href=&quot;process#group_leader/0&quot;&gt;&lt;code&gt;Process.group_leader/0&lt;/code&gt;&lt;/a&gt; in Erlang</source>
          <target state="translated">&lt;code&gt;:stdio&lt;/code&gt; - &lt;code&gt;:standard_io&lt;/code&gt; 的快捷方式，它映射到Erlang中的当前&lt;a href=&quot;process#group_leader/0&quot;&gt; &lt;code&gt;Process.group_leader/0&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58045e7e96ed45a0fb6a2556602dbe4dff9befbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the restart strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt;, &lt;code&gt;:one_for_all&lt;/code&gt;, or &lt;code&gt;:simple_one_for_one&lt;/code&gt;. You can learn more about strategies in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; -重新启动策略选项。它可以是 &lt;code&gt;:one_for_one&lt;/code&gt; ， &lt;code&gt;:rest_for_one&lt;/code&gt; ， &lt;code&gt;:one_for_all&lt;/code&gt; 或 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 。您可以在&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块文档中了解有关策略的更多信息。</target>
        </trans-unit>
        <trans-unit id="328214f38c6d873de09f4dee8577407384e48cb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the restart strategy option. The only supported value is &lt;code&gt;:one_for_one&lt;/code&gt; which means that no other child is terminated if a child process terminates. You can learn more about strategies in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; -重新启动策略选项。唯一受支持的值是 &lt;code&gt;:one_for_one&lt;/code&gt; ，这意味着如果子进程终止，则不会终止其他子进程。您可以在&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;模块文档中了解有关策略的更多信息。</target>
        </trans-unit>
        <trans-unit id="aba2a28a21a71d37aecb4e25a9571218596b092c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the supervision strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt; or &lt;code&gt;:one_for_all&lt;/code&gt;. Required. See the &quot;Strategies&quot; section.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; -监督策略选项。它可以是 &lt;code&gt;:one_for_one&lt;/code&gt; ， &lt;code&gt;:rest_for_one&lt;/code&gt; 或 &lt;code&gt;:one_for_all&lt;/code&gt; 。需要。请参阅&amp;ldquo;策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="e1f83540fffe130cdc9643409c033d9e92241452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the supervision strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt;, &lt;code&gt;:one_for_all&lt;/code&gt;, or the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; -监督策略选项。它可以是 &lt;code&gt;:one_for_one&lt;/code&gt; ， &lt;code&gt;:rest_for_one&lt;/code&gt; ， &lt;code&gt;:one_for_all&lt;/code&gt; 或不推荐使用的 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af1c6ce276c33d1550d8c38b505c9a844b0f8a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strict&lt;/code&gt; - defines strict switches and their types. Any switch in &lt;code&gt;argv&lt;/code&gt; that is not specified in the list is returned in the invalid options list. This is the preferred way to parse options.</source>
          <target state="translated">&lt;code&gt;:strict&lt;/code&gt; -定义严格的开关及其类型。列表中未指定的 &lt;code&gt;argv&lt;/code&gt; 中的任何开关都将在无效选项列表中返回。这是解析选项的首选方法。</target>
        </trans-unit>
        <trans-unit id="c793876b11b8ab1cbc7182ff168a554b74265bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:string&lt;/code&gt; - parses the value as a string</source>
          <target state="translated">&lt;code&gt;:string&lt;/code&gt; -将值解析为字符串</target>
        </trans-unit>
        <trans-unit id="5fb0eee54aeddb670a69245cf74b0ac28cacdc61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strip_beam&lt;/code&gt; - if &lt;code&gt;true&lt;/code&gt; strips BEAM code in the escript to remove chunks unnecessary at runtime, such as debug information and documentation. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:strip_beam&lt;/code&gt; -如果为 &lt;code&gt;true&lt;/code&gt; ，则在脚本中剥离BEAM代码以删除运行时不必要的块，例如调试信息和文档。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d4b0681bc2e63567bfddd7c1a32eb1a2af4cc12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:structs&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, structs are not formatted by the inspect protocol, they are instead printed as maps, defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:structs&lt;/code&gt; -如果为 &lt;code&gt;false&lt;/code&gt; ，则结构不会由inspect协议格式化，而是将其打印为映射，默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="535bfa8e2b14835196f89e91d1dbba30cd7fd13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:submodules&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, initialize submodules for the repo</source>
          <target state="translated">&lt;code&gt;:submodules&lt;/code&gt; -当 &lt;code&gt;true&lt;/code&gt; 的回购，初始化子模块</target>
        </trans-unit>
        <trans-unit id="fd1a11e08b3533d6ec7807000ca6b512f99b293b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:summary&lt;/code&gt; - summary output configuration; can be either a boolean or a keyword list. When a keyword list is passed, it can specify a &lt;code&gt;:threshold&lt;/code&gt;, which is a boolean or numeric value that enables coloring of code coverage results in red or green depending on whether the percentage is below or above the specified threshold, respectively. Defaults to &lt;code&gt;[threshold: 90]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:summary&lt;/code&gt; -摘要输出配置；可以是布尔值列表或关键字列表。传递关键字列表时，它可以指定 &lt;code&gt;:threshold&lt;/code&gt; ，它是一个布尔值或数字值，分别根据百分比是低于还是高于指定阈值来使代码覆盖率着色为红色或绿色。默认值为 &lt;code&gt;[threshold: 90]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caae8c51b443956985309cfe957ca2d2488d4f5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:supervisors&lt;/code&gt; - the count of all supervisors whether or not the child process is still alive</source>
          <target state="translated">&lt;code&gt;:supervisors&lt;/code&gt; -子进程是否仍然存在的所有主管的数量</target>
        </trans-unit>
        <trans-unit id="fe23eb4b90f7f51cad01e75be68fdcd3f495ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:supervisors&lt;/code&gt; - the count of all supervisors whether or not these child supervisors are still alive</source>
          <target state="translated">&lt;code&gt;:supervisors&lt;/code&gt; -所有主管的计数，无论这些子女主管是否还活着</target>
        </trans-unit>
        <trans-unit id="28c96dc0f5b0d2b21c6a75b87f6a5675c12740c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:suspend&lt;/code&gt; - the enumeration should be suspended immediately</source>
          <target state="translated">&lt;code&gt;:suspend&lt;/code&gt; -枚举应立即暂停</target>
        </trans-unit>
        <trans-unit id="afff777a8b91efd6a7328a1dc7bacbf707dcf110" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:switches&lt;/code&gt; - defines switches and their types. This function still attempts to parse switches that are not in this list.</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 定义开关及其类型。此功能仍尝试解析不在此列表中的开关。</target>
        </trans-unit>
        <trans-unit id="fe6ee28c7980294509aa65f52a5155fddb2b9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:switches&lt;/code&gt; or &lt;code&gt;:strict&lt;/code&gt; - see the &quot;Switch definitions&quot; section below</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 或 &lt;code&gt;:strict&lt;/code&gt; -请参见下面的&amp;ldquo;开关定义&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="41ebdb15357f55413373b605a304c40cd67b6e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:symlink_ebin&lt;/code&gt; - symlink ebin instead of copying it</source>
          <target state="translated">&lt;code&gt;:symlink_ebin&lt;/code&gt; -符号链接ebin而不是将其复制</target>
        </trans-unit>
        <trans-unit id="3f4ba688e23f2c521ba75337c1b3789939d1ff7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sync_threshold&lt;/code&gt; - if the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; manager has more than &lt;code&gt;:sync_threshold&lt;/code&gt; messages in its queue, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; will change to &lt;em&gt;sync mode&lt;/em&gt;, to apply backpressure to the clients. &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; will return to &lt;em&gt;async mode&lt;/em&gt; once the number of messages in the queue is reduced to one below the &lt;code&gt;sync_threshold&lt;/code&gt;. Defaults to 20 messages. &lt;code&gt;:sync_threshold&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt; to force &lt;em&gt;sync mode&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;:sync_threshold&lt;/code&gt; -如果&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;管理器队列中的消息超过 &lt;code&gt;:sync_threshold&lt;/code&gt; ，则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;将更改为&lt;em&gt;sync模式&lt;/em&gt;，以向客户端施加背压。一旦队列中的消息数减少到 &lt;code&gt;sync_threshold&lt;/code&gt; 以下的一个，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;将返回&lt;em&gt;异步模式&lt;/em&gt;。默认为20条消息。 &lt;code&gt;:sync_threshold&lt;/code&gt; 可以设置为 &lt;code&gt;0&lt;/code&gt; 以强制&lt;em&gt;同步模式&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ec2abd529b1aa552da9ce3d98d2a89cd3dc8ad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:syntax_colors&lt;/code&gt; - when set to a keyword list of colors the output is colorized. The keys are types and the values are the colors to use for each type (for example, &lt;code&gt;[number: :red, atom: :blue]&lt;/code&gt;). Types can include &lt;code&gt;:number&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;regex&lt;/code&gt;, &lt;code&gt;:tuple&lt;/code&gt;, &lt;code&gt;:map&lt;/code&gt;, &lt;code&gt;:list&lt;/code&gt;, and &lt;code&gt;:reset&lt;/code&gt;. Colors can be any &lt;a href=&quot;io.ansi#t:ansidata/0&quot;&gt;&lt;code&gt;IO.ANSI.ansidata/0&lt;/code&gt;&lt;/a&gt; as accepted by &lt;a href=&quot;io.ansi#format/1&quot;&gt;&lt;code&gt;IO.ANSI.format/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:syntax_colors&lt;/code&gt; -设置为颜色的关键字列表时，输出将着色。键是类型，值是每种类型要使用的颜色（例如 &lt;code&gt;[number: :red, atom: :blue]&lt;/code&gt; ）。类型可以包括 &lt;code&gt;:number&lt;/code&gt; ， &lt;code&gt;:atom&lt;/code&gt; ， &lt;code&gt;regex&lt;/code&gt; ， &lt;code&gt;:tuple&lt;/code&gt; ， &lt;code&gt;:map&lt;/code&gt; ， &lt;code&gt;:list&lt;/code&gt; 和 &lt;code&gt;:reset&lt;/code&gt; 。颜色可以是&lt;a href=&quot;io.ansi#format/1&quot;&gt; &lt;code&gt;IO.ANSI.format/1&lt;/code&gt; &lt;/a&gt;接受的任何&lt;a href=&quot;io.ansi#t:ansidata/0&quot;&gt; &lt;code&gt;IO.ANSI.ansidata/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fc68f71f7771a43da5d88e5526c2ab32c9df54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:system_env&lt;/code&gt; - an enumerable of key-value tuples of binaries to be set as environment variables when loading or compiling the dependency</source>
          <target state="translated">&lt;code&gt;:system_env&lt;/code&gt; -二进制的键值元组的枚举，在加载或编译依赖项时将其设置为环境变量</target>
        </trans-unit>
        <trans-unit id="3ada65ff2401005a619f67139d0ac025b40891d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:system_limit&lt;/code&gt; - all available ports in the Erlang emulator are in use</source>
          <target state="translated">&lt;code&gt;:system_limit&lt;/code&gt; -Erlang仿真器中的所有可用端口都在使用中</target>
        </trans-unit>
        <trans-unit id="c3723a25f474d6156a4964e6d55bb745f148b597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tag&lt;/code&gt; - the Git tag to checkout</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; tag-要签出的Git标签</target>
        </trans-unit>
        <trans-unit id="3619075d3eee8e910609afdbc22465ad531aeddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tags&lt;/code&gt; - the test tags</source>
          <target state="translated">&lt;code&gt;:tags&lt;/code&gt; -测试标签</target>
        </trans-unit>
        <trans-unit id="9b5435d8bc38d5fc84b0cc5dd6913e6d59a3dd03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:targets&lt;/code&gt; - the dependency is made available only for the given targets. By default the dependency will be available in all environments. The value of this option can either be a single target (like &lt;code&gt;:host&lt;/code&gt;) or a list of environments (like &lt;code&gt;[:host, :rpi3]&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:targets&lt;/code&gt; -依赖项仅可用于给定的目标。默认情况下，依赖关系将在所有环境中可用。此选项的值可以是单个目标（例如 &lt;code&gt;:host&lt;/code&gt; ），也可以是环境列表（例如 &lt;code&gt;[:host, :rpi3]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="54d2de44d85c61192c7cad03af98fe1af3d9a1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates, it is reported but no other applications are terminated (the default).</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; -如果 &lt;code&gt;app&lt;/code&gt; 终止，则报告它，但没有其他应用程序终止（默认）。</target>
        </trans-unit>
        <trans-unit id="4c539ed3846b0fb29a4866d15d8c60ecc20ec1d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - the child process is never restarted (not even when the supervisor's strategy is &lt;code&gt;:rest_for_one&lt;/code&gt; or &lt;code&gt;:one_for_all&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; -子进程从不重启（即使主管的策略是 &lt;code&gt;:rest_for_one&lt;/code&gt; 或 &lt;code&gt;:one_for_all&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="31eabe44bb62418e11c93f7e46da12189bd5aaa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - the child process is never restarted, regardless of the supervision strategy: any termination (even abnormal) is considered successful.</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; -无论监督策略如何，子进程都不会重启：任何终止（甚至异常）都被视为成功。</target>
        </trans-unit>
        <trans-unit id="f22bbcb496432cea55f6a9f47e8bd2d643c8b467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - the environment &lt;a href=&quot;mix.tasks.test&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; runs on</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; &lt;a href=&quot;mix.tasks.test&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;运行环境混合测试</target>
        </trans-unit>
        <trans-unit id="b76e6f5c90e7a6502ee72e49445edbe147645e1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - the test name</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; -测试名称</target>
        </trans-unit>
        <trans-unit id="90fcbfaf585325b36b4502c01e390ea297199d7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - used by &lt;code&gt;mix test&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; -用于 &lt;code&gt;mix test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8552d2a1fa910d0583045a91b3e56578f35d7bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_coverage&lt;/code&gt; - a set of options to be passed down to the coverage mechanism</source>
          <target state="translated">&lt;code&gt;:test_coverage&lt;/code&gt; -向下传递到coverage机制的一组选项</target>
        </trans-unit>
        <trans-unit id="ab99093006f8a392a546b357f96e21e57466385c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_location_relative_path&lt;/code&gt; - the test location is the file:line information printed by tests as a shortcut to run a given test. When this value is set, the value is used as a prefix for the test itself. This is typically used by Mix to properly set-up umbrella projects</source>
          <target state="translated">&lt;code&gt;:test_location_relative_path&lt;/code&gt; -测试位置是文件：测试打印的行信息，作为运行给定测试的快捷方式。设置此值后，该值将用作测试本身的前缀。Mix通常使用它来正确设置伞项目</target>
        </trans-unit>
        <trans-unit id="002a1a6acbf0c987e6f149650dc64ee37f6191d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_paths&lt;/code&gt; - list of paths containing test files. Defaults to &lt;code&gt;[&quot;test&quot;]&lt;/code&gt; if the &lt;code&gt;test&lt;/code&gt; directory exists; otherwise, it defaults to &lt;code&gt;[]&lt;/code&gt;. It is expected that all test paths contain a &lt;code&gt;test_helper.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;:test_paths&lt;/code&gt; -包含测试文件的路径列表。如果 &lt;code&gt;test&lt;/code&gt; 目录存在，则默认为 &lt;code&gt;[&quot;test&quot;]&lt;/code&gt; ；否则，默认为 &lt;code&gt;[]&lt;/code&gt; 。预期所有测试路径都包含一个 &lt;code&gt;test_helper.exs&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="b83107d9f58141aa3359434d963157b4ee458a18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_pattern&lt;/code&gt; - a pattern to load test files. Defaults to &lt;code&gt;*_test.exs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:test_pattern&lt;/code&gt; -加载测试文件的模式。默认为 &lt;code&gt;*_test.exs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a91a4aef73b36cb1759a347e386bab5fcd35f14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tests&lt;/code&gt; - all tests for this case</source>
          <target state="translated">&lt;code&gt;:tests&lt;/code&gt; -这种情况下的所有测试</target>
        </trans-unit>
        <trans-unit id="6fe266c99e03604d6137a8d1ea2015fe914436ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - configures how the file timestamps are returned</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; -配置如何返回文件时间戳</target>
        </trans-unit>
        <trans-unit id="0bf29d79146cc591901187eaae942b579a923d41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - filters out any results that took lower than specified (in &amp;micro;s)</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; -过滤掉所有花费少于指定时间（以微秒为单位）的结果</target>
        </trans-unit>
        <trans-unit id="945d163c11a9410b1a739a489e0aa33606521d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - the duration in microseconds of the test's runtime</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; time-测试运行时的持续时间（以微秒为单位）</target>
        </trans-unit>
        <trans-unit id="1bb289f6502ed3468e35c755cc0f3501180ebada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - customizes the test timeout in milliseconds (defaults to 60000). Accepts &lt;code&gt;:infinity&lt;/code&gt; as a timeout value.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; -自定义测试超时（以毫秒为单位）（默认为60000）。接受 &lt;code&gt;:infinity&lt;/code&gt; 作为超时值。</target>
        </trans-unit>
        <trans-unit id="cc267265be13bca0983f3fe0f82491f86c3281fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - if present, the server is allowed to spend the given number of milliseconds initializing or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; -如果存在，则允许服务器花费给定的毫秒数进行初始化，否则它将终止，并且启动功能将返回 &lt;code&gt;{:error, :timeout}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31542e4a35ff214ba221de059f800cc2101050ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - sets the timeout for the tests in milliseconds, defaults to &lt;code&gt;60_000&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; &lt;code&gt;60_000&lt;/code&gt; 设置测试的超时时间（以毫秒为单位），默认为60_000；</target>
        </trans-unit>
        <trans-unit id="2baafad806202f66b01ccfd25bb715322d63de82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the maximum amount of time (in milliseconds) each task is allowed to execute for. Defaults to &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; -每个任务被允许执行的最长时间（以毫秒为单位）。默认为 &lt;code&gt;5000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb2ba6f815c6858cb7e4136a89c5d45161dc4d98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the maximum amount of time to wait (in milliseconds) without receiving a task reply (across all running tasks). Defaults to &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; -等待（所有正在运行的任务）未收到任务回复的最长时间（以毫秒为单位）。默认为 &lt;code&gt;5000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a888f2b8abe68c72ecc4a468fad6dcd9c82ece65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the timeout for the change (defaults to &lt;code&gt;5_000&lt;/code&gt; milliseconds)</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; &lt;code&gt;5_000&lt;/code&gt; 更改超时（默认为5_000毫秒）</target>
        </trans-unit>
        <trans-unit id="34e24470b02bfc44c44f776cb2fcc734faafb94f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:to&lt;/code&gt; - the module to dispatch to.</source>
          <target state="translated">&lt;code&gt;:to&lt;/code&gt; to-调度到的模块。</target>
        </trans-unit>
        <trans-unit id="834e5bf44b0a682b00fcfce09fe6a6d232dc65ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tool&lt;/code&gt; - the coverage tool</source>
          <target state="translated">&lt;code&gt;:tool&lt;/code&gt; -覆盖率工具</target>
        </trans-unit>
        <trans-unit id="99082314da4b63e3d8f7a64f945d58a484e4ab21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trace&lt;/code&gt; - sets ExUnit into trace mode, this sets &lt;code&gt;:max_cases&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and prints each test case and test while running. Note that in trace mode test timeouts will be ignored as timeout is set to &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:trace&lt;/code&gt; trace-将ExUnit设置为跟踪模式，这 &lt;code&gt;:max_cases&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; ，并在运行时打印每个测试用例和测试。请注意，在跟踪模式下，由于超时设置为 &lt;code&gt;:infinity&lt;/code&gt; ,测试超时将被忽略。</target>
        </trans-unit>
        <trans-unit id="70971b562b0e5ec3e13c95916e7a96be595a80a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates with &lt;code&gt;:normal&lt;/code&gt; reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated.</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; -如果 &lt;code&gt;app&lt;/code&gt; 以 &lt;code&gt;:normal&lt;/code&gt; 原因终止，则报告该错误，但没有其他应用程序终止。如果临时应用程序异常终止，则所有其他应用程序和整个节点也将终止。</target>
        </trans-unit>
        <trans-unit id="8c8b579053cc8b765ddb56db8a5d6c340a1c9ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; -子进程仅在异常终止时才重新启动，即，除了 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 以外的退出原因</target>
        </trans-unit>
        <trans-unit id="dd62486aa68570d0f4a2e16bacd9ea1b578b8a0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; -子进程仅在异常终止（即，由于 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 以外的退出原因终止）时才重启。</target>
        </trans-unit>
        <trans-unit id="f069e598cc72f10de360ffe78ef566fd3d1a1b38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:translator_inspect_opts&lt;/code&gt; - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected.</source>
          <target state="translated">&lt;code&gt;:translator_inspect_opts&lt;/code&gt; -翻译OTP报告和错误时，必须在错误报告中检查最后一条消息和状态。此配置使开发人员可以更改应检查的数量和方式。</target>
        </trans-unit>
        <trans-unit id="d8bd50a7c18a4e891bbba01af094152e12dc8854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; (boolean) - if &lt;code&gt;true&lt;/code&gt;, empty strings are removed from the resulting list.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; （boolean）-如果为 &lt;code&gt;true&lt;/code&gt; ，将从结果列表中删除空字符串。</target>
        </trans-unit>
        <trans-unit id="4a665c5e500044cbff85b11b93656534301845be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; - trims whitespace left/right of quotation tags. If a quotation tag appears on its own in a given line, line endings are also removed.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; trim-在引号标签的左/右修剪空白。如果引号标记在给定的行中单独出现，则行尾也将被删除。</target>
        </trans-unit>
        <trans-unit id="b09754295e0a7f11e57f31788d5d04d1352790d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, removes empty strings (&lt;code&gt;&quot;&quot;&lt;/code&gt;) from the result. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; -当 &lt;code&gt;true&lt;/code&gt; ，删除空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; 从结果）。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d71bda1f4d67b286a26089f9b3d3a7af2141030a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:truncate&lt;/code&gt; - the maximum message size to be logged (in bytes). Defaults to 8192 bytes. Note this configuration is approximate. Truncated messages will have &lt;code&gt;&quot; (truncated)&quot;&lt;/code&gt; at the end. The atom &lt;code&gt;:infinity&lt;/code&gt; can be passed to disable this behavior.</source>
          <target state="translated">&lt;code&gt;:truncate&lt;/code&gt; -要记录的最大消息大小（以字节为单位）。默认为8192字节。请注意，此配置是近似的。截断的消息末尾将带有 &lt;code&gt;&quot; (truncated)&quot;&lt;/code&gt; 。可以传递原子 &lt;code&gt;:infinity&lt;/code&gt; 禁用此行为。</target>
        </trans-unit>
        <trans-unit id="3c269b735cc40a6e0b9e6ae233b92cbc96bb45b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:type&lt;/code&gt; - &lt;code&gt;:local&lt;/code&gt; (for anonymous functions) or &lt;code&gt;:external&lt;/code&gt; (for named functions).</source>
          <target state="translated">&lt;code&gt;:type&lt;/code&gt; - &lt;code&gt;:local&lt;/code&gt; （匿名函数）或 &lt;code&gt;:external&lt;/code&gt; （命名功能）。</target>
        </trans-unit>
        <trans-unit id="07b2d5e7363b172a9678eec9bf2505da8b949758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:type&lt;/code&gt; - specifies that the child process is a &lt;code&gt;:worker&lt;/code&gt; or a &lt;code&gt;:supervisor&lt;/code&gt;. This key is optional and defaults to &lt;code&gt;:worker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:type&lt;/code&gt; -指定子进程是 &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:supervisor&lt;/code&gt; 。该密钥是可选的，默认为 &lt;code&gt;:worker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef0b82875d3e0219deca5a33c69825d900b1ddd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:uniq&lt;/code&gt; - (integer) a unique value for this function. This integer is calculated from the compiled code for the entire module.</source>
          <target state="translated">&lt;code&gt;:uniq&lt;/code&gt; -（整数）此函数的唯一值。此整数是根据整个模块的编译代码计算得出的。</target>
        </trans-unit>
        <trans-unit id="ca9d3acb06123805c5480fec9d97b0e18ec5a45a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:universal&lt;/code&gt; - returns a &lt;code&gt;{date, time}&lt;/code&gt; tuple in UTC (default)</source>
          <target state="translated">&lt;code&gt;:universal&lt;/code&gt; -以UTC 返回一个 &lt;code&gt;{date, time}&lt;/code&gt; 元组（默认）</target>
        </trans-unit>
        <trans-unit id="90bb6b004d3a5bade442ad27b72dd634377a8d2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:unquote&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, disables unquoting. This means any &lt;code&gt;unquote&lt;/code&gt; call will be kept as is in the AST, instead of replaced by the &lt;code&gt;unquote&lt;/code&gt; arguments. For example:</source>
          <target state="translated">&lt;code&gt;:unquote&lt;/code&gt; unquote- 如果为 &lt;code&gt;false&lt;/code&gt; ，则取消引用。这意味着任何 &lt;code&gt;unquote&lt;/code&gt; 的通话将被保存为是在AST，而不是通过更换 &lt;code&gt;unquote&lt;/code&gt; 的论点。例如：</target>
        </trans-unit>
        <trans-unit id="c8522475e803f9d234e8fefb372137355db79dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:unquote&lt;/code&gt; - when true, this function leaves &lt;a href=&quot;kernel.specialforms#unquote/1&quot;&gt;&lt;code&gt;unquote/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#unquote_splicing/1&quot;&gt;&lt;code&gt;unquote_splicing/1&lt;/code&gt;&lt;/a&gt; statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false.</source>
          <target state="translated">&lt;code&gt;:unquote&lt;/code&gt; -为 true时，此函数使&lt;a href=&quot;kernel.specialforms#unquote/1&quot;&gt; &lt;code&gt;unquote/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel.specialforms#unquote_splicing/1&quot;&gt; &lt;code&gt;unquote_splicing/1&lt;/code&gt; &lt;/a&gt;语句不转义，从而有效地对转义时的内容取消引用。仅当转义可能带有引号的AST时，此选项才有用。默认为false。</target>
        </trans-unit>
        <trans-unit id="da1acb5f6f05ab526efed9e68ec909c1560d04b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:upper&lt;/code&gt; - only allows upper case characters (default)</source>
          <target state="translated">&lt;code&gt;:upper&lt;/code&gt; -只允许使用大写字母（默认）</target>
        </trans-unit>
        <trans-unit id="e7569b8882893c01db9f45913b40ea583be067a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:upper&lt;/code&gt; - uses upper case characters (default)</source>
          <target state="translated">&lt;code&gt;:upper&lt;/code&gt; -使用大写字母（默认）</target>
        </trans-unit>
        <trans-unit id="9411b629323b5e86fa681c28de9a4aceec773ecf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:utc_log&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, uses UTC in logs. By default it uses local time (i.e., it defaults to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:utc_log&lt;/code&gt; -当 &lt;code&gt;true&lt;/code&gt; ，使用UTC日志中。默认情况下，它使用本地时间（即，默认为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="effab779af0f67bc8dd05247dbafef135012c33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:utf8&lt;/code&gt; - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8.</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; -此选项指示如何在磁盘文件中实际存储数据，并使文件在UTF-8之间自动执行字符转换。</target>
        </trans-unit>
        <trans-unit id="f94cda1b877876edd0aa1cda48627ad7c2b262a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:valid&lt;/code&gt; - the string is split into chunks of valid and invalid character sequences</source>
          <target state="translated">&lt;code&gt;:valid&lt;/code&gt; -字符串分为有效和无效字符序列的块</target>
        </trans-unit>
        <trans-unit id="f2b436b6c7866bb272d673331295201a888ee4c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:version&lt;/code&gt; - the Elixir version</source>
          <target state="translated">&lt;code&gt;:version&lt;/code&gt; -Elixir版本</target>
        </trans-unit>
        <trans-unit id="55a62f489cf1e3c1c55f5ca9ee8251ef3deeeaf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn&lt;/code&gt; - color for warn messages. Defaults to: &lt;code&gt;:yellow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:warn&lt;/code&gt; -警告消息的颜色。默认为 &lt;code&gt;:yellow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c5e79805db42d87c49b6e732710f8a9883d53cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn&lt;/code&gt; - for warnings</source>
          <target state="translated">&lt;code&gt;:warn&lt;/code&gt; -警告</target>
        </trans-unit>
        <trans-unit id="8897349b08555a476d4d32bf64bf637a91daee5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn_on_unnecessary_quotes&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, does not warn when atoms, keywords or calls have unnecessary quotes on them. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:warn_on_unnecessary_quotes&lt;/code&gt; -如果为 &lt;code&gt;false&lt;/code&gt; ，则当原子，关键字或调用上带有不必要的引号时不发出警告。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b142347ad2985921b40e9d4f2b41f245a5ea2680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn_test_pattern&lt;/code&gt; - a pattern to match potentially misnamed test files and display a warning. Defaults to &lt;code&gt;*_test.ex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:warn_test_pattern&lt;/code&gt; -一种匹配可能被错误命名的测试文件并显示警告的模式。默认为 &lt;code&gt;*_test.ex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b69954b8616460123488d7e49e31c3f41ede8d95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warnings_as_errors&lt;/code&gt; - causes compilation to fail when warnings are generated. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:warnings_as_errors&lt;/code&gt; -生成警告时导致编译失败。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0388681f52d7a3593391ced5d12986df6c7ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:width&lt;/code&gt; - defaults to 80 characters, used when pretty is &lt;code&gt;true&lt;/code&gt; or when printing to IO devices. Set to 0 to force each item to be printed on its own line. If you don't want to limit the number of items to a particular number, use &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; -默认为80个字符，当 &lt;code&gt;true&lt;/code&gt; 为true或打印到IO设备时使用。设置为0可以强制每个项目单独打印。如果您不想将项目数量限制为特定数量，请使用 &lt;code&gt;:infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7d69d648c9f7b6c21f4f63f8b22f6cb9790f034" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:workers&lt;/code&gt; - the count of all workers, whether or not the child process is still alive</source>
          <target state="translated">&lt;code&gt;:workers&lt;/code&gt; -所有工人的数量，无论子进程是否仍然存在</target>
        </trans-unit>
        <trans-unit id="334cc70397dfdbf2e8f49b9a5c8da45b65cfee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:workers&lt;/code&gt; - the count of all workers, whether or not these child workers are still alive</source>
          <target state="translated">&lt;code&gt;:workers&lt;/code&gt; -所有工人的总数，这些童工是否还活着</target>
        </trans-unit>
        <trans-unit id="0f80205292677fed0fe9f8b3f5a559aeecfd0ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:write&lt;/code&gt; - the file is opened for writing. It is created if it does not exist.</source>
          <target state="translated">&lt;code&gt;:write&lt;/code&gt; -打开文件进行写入。如果不存在，则创建它。</target>
        </trans-unit>
        <trans-unit id="09715b1f90ef6627a93d9acfa01177825316b0eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:yecc_options&lt;/code&gt; - compilation options that apply to Yecc's compiler.</source>
          <target state="translated">&lt;code&gt;:yecc_options&lt;/code&gt; -适用于Yecc编译器的编译选项。</target>
        </trans-unit>
        <trans-unit id="0fefd30d847d0341dd6b85fb040758a0c5fb2fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=&amp;gt;&lt;/code&gt; (valid syntax only inside &lt;code&gt;%{}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; （仅在 &lt;code&gt;%{}&lt;/code&gt; 内部有效的语法）</target>
        </trans-unit>
        <trans-unit id="f772920ee2b8149ecd45efca6c94a408441c5967" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;=~&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;!==&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;=~&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;!==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30dbfa13a150bcf3624e9ca02561b827e1f10970" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; - matches one character.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; -匹配一个字符。</target>
        </trans-unit>
        <trans-unit id="8fff3a404ea676594d737e706c90d88f4f595921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\a&lt;/code&gt; - Bell</source>
          <target state="translated">&lt;code&gt;?\a&lt;/code&gt; a-贝尔</target>
        </trans-unit>
        <trans-unit id="613f9bcb89eecba54532c8aaec33df641326ae00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\b&lt;/code&gt; - Backspace</source>
          <target state="translated">&lt;code&gt;?\b&lt;/code&gt; 退格键</target>
        </trans-unit>
        <trans-unit id="e5ecf6f761279616c3d32f47521aec8133a4e290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\e&lt;/code&gt; - Escape</source>
          <target state="translated">&lt;code&gt;?\e&lt;/code&gt; 逃生</target>
        </trans-unit>
        <trans-unit id="39d2d4d0c7cc57ab6723bacaa43078296d967029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\f&lt;/code&gt; - Form feed</source>
          <target state="translated">&lt;code&gt;?\f&lt;/code&gt; 换页</target>
        </trans-unit>
        <trans-unit id="23e3f2abd16162eb807b9232767c5ace80662783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\n&lt;/code&gt; - Line feed</source>
          <target state="translated">&lt;code&gt;?\n&lt;/code&gt; 换行</target>
        </trans-unit>
        <trans-unit id="95a05724bb974cbfc0c47983a4723149096071b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\r&lt;/code&gt; - Carriage return</source>
          <target state="translated">&lt;code&gt;?\r&lt;/code&gt; 回车</target>
        </trans-unit>
        <trans-unit id="bca888af28a2983a4c7577d14529f75cf25fb175" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\t&lt;/code&gt; - Horizontal tab</source>
          <target state="translated">&lt;code&gt;?\t&lt;/code&gt; 水平标签</target>
        </trans-unit>
        <trans-unit id="df9cea6c334078b1be9dce7f59ef87281fa242d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\v&lt;/code&gt; - Vertical tab</source>
          <target state="translated">&lt;code&gt;?\v&lt;/code&gt; 垂直标签</target>
        </trans-unit>
        <trans-unit id="37a3265ca91a672634680057bcfb31fce197ab8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@before_compile&lt;/code&gt; - provides a hook that will be invoked before the module is compiled. This makes it possible to inject functions inside the module exactly before compilation.</source>
          <target state="translated">&lt;code&gt;@before_compile&lt;/code&gt; -提供一个在编译模块之前将被调用的钩子。这样就可以在编译之前就将功能注入模块内部。</target>
        </trans-unit>
        <trans-unit id="b5006c789ded71d15ca28be2b24956a998969c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@behaviour&lt;/code&gt; - (notice the British spelling) used for specifying an</source>
          <target state="translated">&lt;code&gt;@behaviour&lt;/code&gt; -（请注意英文拼写）用于指定</target>
        </trans-unit>
        <trans-unit id="a27e3e245e0b9d802a39440f4800291c27791121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; - provides a specification for a behaviour callback</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; -提供行为回调的规范</target>
        </trans-unit>
        <trans-unit id="2b99fba722dcddee5b4e812a35c1a4ae382006f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; module attribute (v1.0)</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; 模块属性（v1.0）</target>
        </trans-unit>
        <trans-unit id="d3ad364f188f9d6529caf420bd702cacfcfd7c8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile :debug_info&lt;/code&gt; - includes &lt;code&gt;:debug_info&lt;/code&gt; regardless of the corresponding setting in &lt;a href=&quot;code#compiler_options/1&quot;&gt;&lt;code&gt;Code.compiler_options/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile :debug_info&lt;/code&gt; 包括 &lt;code&gt;:debug_info&lt;/code&gt; debug_info，无论&lt;a href=&quot;code#compiler_options/1&quot;&gt; &lt;code&gt;Code.compiler_options/1&lt;/code&gt; &lt;/a&gt;中的相应设置如何</target>
        </trans-unit>
        <trans-unit id="5910f1418f6efbba1a18f2905a498692fe1df693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:autoload, false}&lt;/code&gt; - disables automatic loading of modules after compilation. Instead, the module will be loaded after it is dispatched to</source>
          <target state="translated">&lt;code&gt;@compile {:autoload, false}&lt;/code&gt; -禁用编译后自动加载模块。取而代之的是，模块将在分派给</target>
        </trans-unit>
        <trans-unit id="0389a458fd16e5d2ea5409d9cccc30f2ad04f1c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:debug_info, false}&lt;/code&gt; - disables &lt;code&gt;:debug_info&lt;/code&gt; regardless of the corresponding setting in &lt;a href=&quot;code#compiler_options/1&quot;&gt;&lt;code&gt;Code.compiler_options/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile {:debug_info, false}&lt;/code&gt; -禁用 &lt;code&gt;:debug_info&lt;/code&gt; debug_info，无论&lt;a href=&quot;code#compiler_options/1&quot;&gt; &lt;code&gt;Code.compiler_options/1&lt;/code&gt; &lt;/a&gt;中的相应设置如何</target>
        </trans-unit>
        <trans-unit id="97e47694ebddaaa4418902dea32c44caad53bf34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:inline, some_fun: 2, other_fun: 3}&lt;/code&gt; - inlines the given name/arity pairs. Inlining is applied locally, calls from another module are not affected by this option</source>
          <target state="translated">&lt;code&gt;@compile {:inline, some_fun: 2, other_fun: 3}&lt;/code&gt; -内联给定的名称/别名对。内联在本地应用，来自另一个模块的调用不受此选项影响</target>
        </trans-unit>
        <trans-unit id="77e73a5ef9dce8313d7bfd5b64cbcbaee21df0a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:parse_transform, _}&lt;/code&gt; in &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile {:parse_transform, _}&lt;/code&gt; 在&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e96152207ec3eb21d84903fe60382b1b081d4289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; - provides documentation for the function or macro that follows the attribute.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; -提供属性后的函数或宏的文档。</target>
        </trans-unit>
        <trans-unit id="f15234e54e9e652b13174cfaa49be965b1680a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@typedoc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; 和 &lt;code&gt;@typedoc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59af86a43d50330626df1552fc92e1a38a7fb747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; module attribute (v1.0)</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; 模块属性（v1.0）</target>
        </trans-unit>
        <trans-unit id="934e98fc755a06331804d907ade934513ee502fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; - declares an implementation of a callback function or macro</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; -声明回调函数或宏的实现</target>
        </trans-unit>
        <trans-unit id="17819c89ee896cbaf7bd2d2e886773c6fce57eec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; also helps with maintainability by making it clear to other developers that the function is implementing a callback.</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; 还可以通过使其他开发人员清楚该函数正在实现回调来帮助实现可维护性。</target>
        </trans-unit>
        <trans-unit id="a88e78800c83e0b772a5ac19b1fe178e99242f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; works on a per-context basis. If you generate a function through a macro and mark it with &lt;code&gt;@impl&lt;/code&gt;, that won't affect the module where that function is generated in.</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; 是基于上下文的。如果通过宏生成函数并用 &lt;code&gt;@impl&lt;/code&gt; 标记，则不会影响生成该函数的模块。</target>
        </trans-unit>
        <trans-unit id="f2bccc6948542760dcd3c3f6f7b7199679e2fa95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@macrocallback&lt;/code&gt; - provides a specification for a macro behaviour callback</source>
          <target state="translated">&lt;code&gt;@macrocallback&lt;/code&gt; -提供宏行为回调的规范</target>
        </trans-unit>
        <trans-unit id="381a38bb94c99bb9edf99588bac350cd814a717c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@moduledoc&lt;/code&gt; - provides documentation for the current module.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; -提供当前模块的文档。</target>
        </trans-unit>
        <trans-unit id="437861897b2e92f1b4983b067489afc4d19b2f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@moduledoc&lt;/code&gt; and &lt;code&gt;@doc&lt;/code&gt; are by far the most used attributes, and we expect you to use them a lot. Elixir treats documentation as first-class and provides many functions to access documentation. You can read more about &lt;a href=&quot;https://hexdocs.pm/elixir/writing-documentation.html&quot;&gt;writing documentation in Elixir in our official documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; ， &lt;code&gt;@doc&lt;/code&gt; moduledoc和@doc是最常用的属性，我们希望您经常使用它们。Elixir将文档视为一流文档，并提供许多访问文档的功能。您可以&lt;a href=&quot;https://hexdocs.pm/elixir/writing-documentation.html&quot;&gt;在我们的官方文档中&lt;/a&gt;阅读有关使用Elixir编写文档的更多信息。</target>
        </trans-unit>
        <trans-unit id="451e2829b6a116284e15823242417d31cdf4fd8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@opaque&lt;/code&gt; - defines an opaque type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@opaque&lt;/code&gt; -定义要在 &lt;code&gt;@spec&lt;/code&gt; 中使用的不透明类型</target>
        </trans-unit>
        <trans-unit id="85a017da91a01cbf5dc930c0f088328c5e12a293" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@optional_callbacks&lt;/code&gt; - specifies which behaviour callbacks and macro behaviour callbacks are optional</source>
          <target state="translated">&lt;code&gt;@optional_callbacks&lt;/code&gt; -指定哪些行为回调和宏行为回调是可选的</target>
        </trans-unit>
        <trans-unit id="07bf37b9ee7e6e2d160fd237b741b014ae960ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@preferred_cli_env&lt;/code&gt; - recommends environment to run task. It is used in absence of a Mix project recommendation, or explicit &lt;code&gt;MIX_ENV&lt;/code&gt;, and it only works for tasks in the current project. &lt;code&gt;@preferred_cli_env&lt;/code&gt; is not loaded from dependencies as we need to know the environment before dependencies are loaded.</source>
          <target state="translated">&lt;code&gt;@preferred_cli_env&lt;/code&gt; -推荐运行任务的环境。它在没有Mix项目建议或显式 &lt;code&gt;MIX_ENV&lt;/code&gt; 的情况下使用，并且仅适用于当前项目中的任务。 &lt;code&gt;@preferred_cli_env&lt;/code&gt; 不会从依赖项中加载，因为我们需要在加载依赖项之前了解环境。</target>
        </trans-unit>
        <trans-unit id="ca908949bd667b235800ff24cb022d02b2c7b22f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@recursive&lt;/code&gt; - runs the task recursively in umbrella projects</source>
          <target state="translated">&lt;code&gt;@recursive&lt;/code&gt; recursive-在伞项目中递归运行任务</target>
        </trans-unit>
        <trans-unit id="cbfdcfb85b0218f0ecbce848006d6e4018957214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@shortdoc&lt;/code&gt; - makes the task public with a short description that appears on &lt;a href=&quot;mix.tasks.help&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@shortdoc&lt;/code&gt; -使用&lt;a href=&quot;mix.tasks.help&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt;中显示的简短说明公开任务</target>
        </trans-unit>
        <trans-unit id="efee48c5a9b83b5d61138f95175ab7ba3a1452ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@spec&lt;/code&gt; - provides a specification for a function</source>
          <target state="translated">&lt;code&gt;@spec&lt;/code&gt; -提供函数的规范</target>
        </trans-unit>
        <trans-unit id="158af346d3f53b1378f06a1d8efff2de54c7e218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; - defines a type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; -定义要在 &lt;code&gt;@spec&lt;/code&gt; 中使用的类型</target>
        </trans-unit>
        <trans-unit id="0d93ce7d4632d38027a52a9295a9a40662cdf05f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typep&lt;/code&gt; - defines a private type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typep&lt;/code&gt; -定义要在 &lt;code&gt;@spec&lt;/code&gt; 中使用的私有类型</target>
        </trans-unit>
        <trans-unit id="be2c80ff23d06188671d40d1e4258d13bb6998da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Any&lt;/code&gt; (see below)</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; （请参见下文）</target>
        </trans-unit>
        <trans-unit id="cab1a8a7a7f40a3fa2c2093e4a4bbf8aec7bfe18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C:\TMP&lt;/code&gt; on Windows or &lt;code&gt;/tmp&lt;/code&gt; on Unix</source>
          <target state="translated">&lt;code&gt;C:\TMP&lt;/code&gt; Windows上为C：\ TMP或Unix 上为 &lt;code&gt;/tmp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83b7688814bc4bb8e003a5dec38f284a5a872dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CoverModule&lt;/code&gt; can be any module that exports &lt;code&gt;start/2&lt;/code&gt;, receiving the compilation path and the &lt;code&gt;test_coverage&lt;/code&gt; options as arguments. It must return either &lt;code&gt;nil&lt;/code&gt; or an anonymous function of zero arity that will be run after the test suite is done.</source>
          <target state="translated">&lt;code&gt;CoverModule&lt;/code&gt; 可以是导出 &lt;code&gt;start/2&lt;/code&gt; ，接收编译路径和 &lt;code&gt;test_coverage&lt;/code&gt; 选项作为参数的任何模块。它必须返回 &lt;code&gt;nil&lt;/code&gt; 或零Arity的匿名函数，该函数将在测试套件完成后运行。</target>
        </trans-unit>
        <trans-unit id="ac3a6bcf59cce82a9597afb726db205333f00d59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; expects the name of the supervisor and the child specification of the child to be started.</source>
          <target state="translated">&lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; 要求启动主管的名称和该子级的子级规范。</target>
        </trans-unit>
        <trans-unit id="4be1d465a033470e0d13e03f803f35a23df2fbc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; - can be used to give default compile options. The value must be a valid Erlang term. If the value is a list, it will be used as is. If it is not a list, it will be put into a list.</source>
          <target state="translated">&lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; -可用于提供默认的编译选项。该值必须是有效的Erlang术语。如果该值为列表，则将按原样使用它。如果不是列表，它将被放入列表中。</target>
        </trans-unit>
        <trans-unit id="6f324bdba6e17d20eaca2ae660b30254ca8ff092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Enum.chunk/2&lt;/code&gt;&lt;a href=&quot;%60enum.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Enum.chunk/2&lt;/code&gt;&lt;a href=&quot;%60enum.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed541833a5f66414f125983720593b8ffac0eb96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IEx.pry/0&lt;/code&gt; and &lt;code&gt;IEx.break!/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IEx.pry/0&lt;/code&gt; 和 &lt;code&gt;IEx.break!/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c577ef1c31238772ee8831a83e168e224b3891" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO.inspect/2&lt;/code&gt; also provides the ability to decorate the output with a &lt;code&gt;label&lt;/code&gt; option. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IO.inspect/2&lt;/code&gt; 还提供了使用 &lt;code&gt;label&lt;/code&gt; 选项装饰输出的功能。标签将在检查 &lt;code&gt;item&lt;/code&gt; 之前打印：</target>
        </trans-unit>
        <trans-unit id="ab245843059173dbf82eb4fe6e1efb8953b384a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KVServer.Command.run/1&lt;/code&gt;&amp;rsquo;s implementation is sending commands directly to the server named &lt;code&gt;KV.Registry&lt;/code&gt;, which is registered by the &lt;code&gt;:kv&lt;/code&gt; application. This means this server is global and if we have two tests sending messages to it at the same time, our tests will conflict with each other (and likely fail). We need to decide between having unit tests that are isolated and can run asynchronously, or writing integration tests that work on top of the global state, but exercise our application&amp;rsquo;s full stack as it is meant to be exercised in production.</source>
          <target state="translated">&lt;code&gt;KVServer.Command.run/1&lt;/code&gt; 的实现是将命令直接发送到名为 &lt;code&gt;KV.Registry&lt;/code&gt; 的服务器，该服务器由 &lt;code&gt;:kv&lt;/code&gt; 应用程序注册。这意味着该服务器是全局服务器，如果我们有两个同时向其发送消息的测试，则我们的测试将相互冲突（并且可能会失败）。我们需要决定是隔离的，可以异步运行的单元测试，还是编写可以在全局状态之上工作的集成测试，但是要行使应用程序的完整堆栈，因为它打算在生产环境中行使。</target>
        </trans-unit>
        <trans-unit id="da6d4153744f3433ed1a5402789f34e812c03af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; -指定要将档案安装到的目录</target>
        </trans-unit>
        <trans-unit id="9e3878570d540f1dc8a3f3f892fd2b11f01cccaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project build_path config</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; -设置项目的build_path配置</target>
        </trans-unit>
        <trans-unit id="0140498ebd7646b788b6566801c7befbab061cb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEBUG&lt;/code&gt; - outputs debug information about each task before running it</source>
          <target state="translated">&lt;code&gt;MIX_DEBUG&lt;/code&gt; -在运行每个任务之前输出有关每个任务的调试信息</target>
        </trans-unit>
        <trans-unit id="329ed8db0c467fa57966c2408385f46d68602c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ENV&lt;/code&gt; - specifies which environment should be used. See &lt;a href=&quot;#module-environments&quot;&gt;Environments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_ENV&lt;/code&gt; -指定应使用的环境。查看&lt;a href=&quot;#module-environments&quot;&gt;环境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d50621b63f1f2c2227991dd4eff2fd82684592f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_EXS&lt;/code&gt; - changes the full path to the &lt;code&gt;mix.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;MIX_EXS&lt;/code&gt; -将完整路径更改为 &lt;code&gt;mix.exs&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="0c7e96e7109921de42973a61dead2b979ac90fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; -Mix的主目录的路径，存储配置文件和Mix使用的脚本</target>
        </trans-unit>
        <trans-unit id="553587fa68acdae7dd360d62677c233b8de4b6a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_PATH&lt;/code&gt; - appends extra code paths</source>
          <target state="translated">&lt;code&gt;MIX_PATH&lt;/code&gt; -附加额外的代码路径</target>
        </trans-unit>
        <trans-unit id="e5e1141c719d2a85373ac124af8fe76e6cceea81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_QUIET&lt;/code&gt; - does not print information messages to the terminal</source>
          <target state="translated">&lt;code&gt;MIX_QUIET&lt;/code&gt; -不向终端打印信息消息</target>
        </trans-unit>
        <trans-unit id="7254592f8891c8c6dd40bd7299fc6ec41c04871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; -覆盖一个Mix安装的rebar3命令的路径</target>
        </trans-unit>
        <trans-unit id="06ea93f78b26d8cfb7ce48134404d1f745e0f50b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; -覆盖一个Mix安装的rebar命令的路径</target>
        </trans-unit>
        <trans-unit id="9971767c5036a2608426896f053fa0cf39812d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_TARGET&lt;/code&gt; - specifies which target should be used. See &lt;a href=&quot;#module-targets&quot;&gt;Targets&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_TARGET&lt;/code&gt; -指定应使用的目标。查看&lt;a href=&quot;#module-targets&quot;&gt;目标&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d25413013d7642f8cf841919f8270de1f43ed5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Macro.expand_once/2&lt;/code&gt; receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about &lt;code&gt;__ENV__&lt;/code&gt; later in this chapter).</source>
          <target state="translated">&lt;code&gt;Macro.expand_once/2&lt;/code&gt; 接收一个带引号的表达式，并根据当前环境对其进行扩展。在这种情况下，它扩展/调用了 &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; 宏并返回了其结果。然后，我们将返回的带引号的表达式转换为字符串并打印（我们将在本章稍后讨论 &lt;code&gt;__ENV__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3fc6929a951f92925b08e51e26456aa3d1b43853" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c79ae2e0183612283b4bdd763f31738afe6b32e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.ljust/3&lt;/code&gt; and &lt;code&gt;String.rjust/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.ljust/3&lt;/code&gt; 和 &lt;code&gt;String.rjust/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6971e188b1f5ca6887f36a1aabb3d9f4803817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/1&lt;/code&gt; and &lt;code&gt;String.rstrip/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/1&lt;/code&gt; 和 &lt;code&gt;String.rstrip/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4f8fac69d745e565219ca9c212f205a839b4d94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/2&lt;/code&gt; and &lt;code&gt;String.rstrip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/2&lt;/code&gt; 和 &lt;code&gt;String.rstrip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dba6d3f4606546ef740ff6427a2da28113bd080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.strip/1&lt;/code&gt; and &lt;code&gt;String.strip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.strip/1&lt;/code&gt; 和 &lt;code&gt;String.strip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd32067781123d89c1ac8e4f997b876beb9c3863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; is capable of building a child specification from a given module and/or tuple, and it also accepts values that override the underlying child specification. Now we have an always running acceptor that starts temporary task processes under an always running task supervisor.</source>
          <target state="translated">&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 能够从给定的模块和/或元组构建子规范，并且它还接受覆盖基础子规范的值。现在，我们有了一个始终运行的接受器，可以在始终运行的任务管理程序下启动临时任务进程。</target>
        </trans-unit>
        <trans-unit id="ad77d229f6cbfcafcb4f7741c0dc27b0f4b740b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="088aa7cd9bf1e6a8427fd52deb0693f6c10b18ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[char1,char2,...]&lt;/code&gt; - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;[char1,char2,...]&lt;/code&gt; -匹配列出的任何字符；用连字符分隔的两个字符将匹配一系列字符。请勿在逗号前后添加空格，否则会匹配包含空格字符本身的路径。</target>
        </trans-unit>
        <trans-unit id="39c640871ce2526ab4fa5310ef6480273c950ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\0&lt;/code&gt; - null byte</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 空字节</target>
        </trans-unit>
        <trans-unit id="65ed13dac56222bcbf8e3e216b956a7a2244b177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; &amp;ndash; single backslash</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; &amp;ndash;单反斜杠</target>
        </trans-unit>
        <trans-unit id="b174b497cb3a1cc6880a9950599e3a0b77cab5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; is used to specify a default value for a parameter of a function. For example:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 用于指定函数参数的默认值。例如：</target>
        </trans-unit>
        <trans-unit id="6f9d9ffe5a9bac743656529800fff03c95336241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; &amp;ndash; bell/alert</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; &amp;ndash;贝尔/警报</target>
        </trans-unit>
        <trans-unit id="14886ebc85cca038dec60a61c0e91b8b4ead61c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; &amp;ndash; backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; &amp;ndash;退格键</target>
        </trans-unit>
        <trans-unit id="0bb4d977ed1327929c1a92021eb0613308fd0ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; - delete</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 删除</target>
        </trans-unit>
        <trans-unit id="ccb79b2d6e647a0cac1fd9c56eabf463190b35ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 逃生</target>
        </trans-unit>
        <trans-unit id="7df87f44b5903cdd4ae86383ef920d5afcb83fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; 换页</target>
        </trans-unit>
        <trans-unit id="74c29c02b88f493e0b8a40781b5dd5c63d7f01bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; &amp;ndash; newline</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; &amp;ndash;换行符</target>
        </trans-unit>
        <trans-unit id="f63d66cab57190093b88defb77e6fab011870475" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; &amp;ndash; carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; &amp;ndash;回车</target>
        </trans-unit>
        <trans-unit id="0a1c5bdfb07d4e036fe4810e5550d502e2f30408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; &amp;ndash; space</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; &amp;ndash;空间</target>
        </trans-unit>
        <trans-unit id="547d5d52bd4fa577be6f348f6604137b954496a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; &amp;ndash; tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; &amp;ndash;标签</target>
        </trans-unit>
        <trans-unit id="736c96e8078aabb67ae94f12f2958e5765eb382c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uDDDD&lt;/code&gt; and &lt;code&gt;\u{D...}&lt;/code&gt; - represents a Unicode codepoint in hexadecimal (such as &lt;code&gt;\u{1F600}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\uDDDD&lt;/code&gt; 和 &lt;code&gt;\u{D...}&lt;/code&gt; -以十六进制表示Unicode代码点（例如 &lt;code&gt;\u{1F600}&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="46eb12f311d0fe7aa10c40fac2213a97f6692013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uXXXX&lt;/code&gt; or &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</source>
          <target state="translated">&lt;code&gt;\uXXXX&lt;/code&gt; 或 &lt;code&gt;\u{X*}&lt;/code&gt; （v1.1）</target>
        </trans-unit>
        <trans-unit id="c0b1167bef21cda9a624d04841f631aeb54af646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; &amp;ndash; vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; &amp;ndash;垂直标签</target>
        </trans-unit>
        <trans-unit id="38a8f23f2eb09ba8af053d2c20b167de36d6466a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xDD&lt;/code&gt; - represents a single byte in hexadecimal (such as &lt;code&gt;\x13&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\xDD&lt;/code&gt; 代表十六进制的单个字节（例如 &lt;code&gt;\x13&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3210dc14496231e2d2fc4514864f15323c30fdbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{X*}&lt;/code&gt; inside strings/sigils/charlists</source>
          <target state="translated">&lt;code&gt;\x{X*}&lt;/code&gt; 在字符串/签名/字符列表中</target>
        </trans-unit>
        <trans-unit id="3cde9d9e85c4c0b53108719f116e97eb679ac877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ENV__&lt;/code&gt; returns an instance of the &lt;code&gt;Macro.Env&lt;/code&gt; struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires and so on:</source>
          <target state="translated">&lt;code&gt;__ENV__&lt;/code&gt; 返回 &lt;code&gt;Macro.Env&lt;/code&gt; 结构的实例，该实例包含有关编译环境的有用信息，包括当前模块，文件和行，当前作用域中定义的所有变量以及导入，需求等：</target>
        </trans-unit>
        <trans-unit id="e61733caa542452527b202971f1b67c6052df9a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__protocol__/1&lt;/code&gt; - returns the protocol information. The function takes one of the following atoms:</source>
          <target state="translated">&lt;code&gt;__protocol__/1&lt;/code&gt; 返回协议信息。该函数采用以下原子之一：</target>
        </trans-unit>
        <trans-unit id="ead78218949f957d38127d6c0b9181cecc79bdc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 通常用于需要在调用者中设置一些状态（通过模块属性）或回调（例如 &lt;code&gt;@before_compile&lt;/code&gt; ，请参见&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;的文档以获取更多信息）的情况。</target>
        </trans-unit>
        <trans-unit id="18fec841d33b1eed5707722ba145fa8e46469457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; may also be used to alias, require, or import functionality from different modules:</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 还可用于别名，要求或从不同模块导入功能：</target>
        </trans-unit>
        <trans-unit id="5888cfe9b0257d8c48e3413d54a04e07ef4f2f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;: words in the list are atoms</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; ：列表中的单词是原子</target>
        </trans-unit>
        <trans-unit id="5dd0df57ca13d192483ae4afa8ee7dcd66ac716e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt;; the current system access to the file.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt; ; 当前系统对该文件的访问。</target>
        </trans-unit>
        <trans-unit id="5bf576af207250aae2f10f4b1a3367c771a70828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="8e3d214af6b3554314446ba0e18e374c3577cbda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; 迭代完成后将调用after_fun，并且还必须返回 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 或 &lt;code&gt;{:cont, acc}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72b02de91b9af39aa2a7c9496b9788f7c36c0544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias&lt;/code&gt; allows you to set up aliases for any given module name.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 允许您为任何给定的模块名称设置别名。</target>
        </trans-unit>
        <trans-unit id="c880b6a07ca827b5812f7f974a1fcacab19aaf4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aliases&lt;/code&gt; - a list of two-element tuples, where the first element is the aliased name and the second one the actual name</source>
          <target state="translated">&lt;code&gt;aliases&lt;/code&gt; -两元素元组的列表，其中第一个元素是别名，第二个元素是实际名称</target>
        </trans-unit>
        <trans-unit id="8d4e8eef689e82c072f90c3d43dbd352d218bf09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anchored&lt;/code&gt; - not available, use &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;\A&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;anchored&lt;/code&gt; -不提供，使用 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;\A&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="4458fc9a4b25b25b5a15d3aebebe9b878cfddf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 在规范的 &lt;code&gt;:start&lt;/code&gt; 字段中作为&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt;的参数传递。</target>
        </trans-unit>
        <trans-unit id="d15eca1e275872ac68dbab33a4fcdc7d4900f368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 必须是布尔值；如果不是，则会&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="c766db9327568eebb91c2c7ede208193b9693614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; is a list of the remaining arguments in &lt;code&gt;argv&lt;/code&gt; as strings</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 是 &lt;code&gt;argv&lt;/code&gt; 中作为字符串的其余参数的列表</target>
        </trans-unit>
        <trans-unit id="67b55e613b38ca10448abedd47d027b2fda5747b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must be a list of binaries which the executable will receive as its arguments as is. This means that:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 必须是可执行文件将按其原样接收的二进制文件列表。这意味着：</target>
        </trans-unit>
        <trans-unit id="6116c0e3ccd4227ebffa3336ec78198214587e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; 在&lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; 中为&lt;/a&gt; false，并且&lt;a href=&quot;kernel.specialforms#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="822629b7db721ef2933cb934e45149d4a945780c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;enum#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; 存在as_boolean（t）来向用户发送信号，将给定值视为布尔值，其中 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 将被评估为 &lt;code&gt;false&lt;/code&gt; ,而其他所有条件均为 &lt;code&gt;true&lt;/code&gt; 。例如，&lt;a href=&quot;enum#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt;具有以下规范： &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9d720388f308d192f8429307f6fcab52f0e1f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 会反省基础表达式，并在出现故障时提供良好的报告。例如，如果表达式使用比较运算符，则该消息将显示两侧的值。断言</target>
        </trans-unit>
        <trans-unit id="b8c959da5563d8804e6c5ab088f8ce78ed2be376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; provides a very simple mechanism to compute values concurrently. Not only that, &lt;code&gt;async/await&lt;/code&gt; can also be used with the same &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; we have used in previous chapters. We just need to call &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; instead of &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; and use &lt;code&gt;Task.await/2&lt;/code&gt; to read the result later on.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 提供了一种非常简单的机制来同时计算值。不仅如此， &lt;code&gt;async/await&lt;/code&gt; 还可以与前面章节中使用的&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;一起使用。我们只需要调用 &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 而不是 &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; ,然后使用 &lt;code&gt;Task.await/2&lt;/code&gt; 来读取结果。</target>
        </trans-unit>
        <trans-unit id="5cbc2fd902dcfa9a0d5b3b03629aa9a39e8105cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atime&lt;/code&gt; - the last time the file was read.</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; -上次读取文件的时间。</target>
        </trans-unit>
        <trans-unit id="a1bc563adc7ed0327db5ff505175d84400d984ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_nodes&lt;/code&gt; - is a list of nodes that either did not exist or where a server with the given &lt;code&gt;name&lt;/code&gt; did not exist or did not reply</source>
          <target state="translated">&lt;code&gt;bad_nodes&lt;/code&gt; -是不存在的节点或具有给定 &lt;code&gt;name&lt;/code&gt; 的服务器不存在或未答复的节点的列表</target>
        </trans-unit>
        <trans-unit id="b0f9d352deff5e6bef483d40252e8c579ec823db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; can be an integer between 2 and 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 可以是2到36之间的整数。</target>
        </trans-unit>
        <trans-unit id="f8fd140ab9c10a0cfc1c2df9c9a53282f52de13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;big&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; （默认）</target>
        </trans-unit>
        <trans-unit id="683140005c82637887b9603468709538ca7e8c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo daemon&lt;/code&gt; and &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; - to start the system as a daemon on Unix-like systems</source>
          <target state="translated">&lt;code&gt;bin/foo daemon&lt;/code&gt; 和bin / foo守护程序 &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; 在类Unix系统上作为守护程序启动系统</target>
        </trans-unit>
        <trans-unit id="decd6a4e6f8eff7dd632caccc3c36fce1d0d44bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - to start a fresh system that runs a single command and then shuts down</source>
          <target state="translated">&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; -启动一个运行单个命令然后关闭的新系统</target>
        </trans-unit>
        <trans-unit id="432eeca34ed295a1f1ff0e49167671eefec3e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo install&lt;/code&gt; - to install the system as a service on Windows machines</source>
          <target state="translated">&lt;code&gt;bin/foo install&lt;/code&gt; -在Windows机器上将系统作为服务安装</target>
        </trans-unit>
        <trans-unit id="8eb1dbc6df6a7ebd68488f9c558335906ced9632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; and &lt;code&gt;bin/foo remote&lt;/code&gt; - for running commands on the running system or to connect to the running system</source>
          <target state="translated">&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; 和 &lt;code&gt;bin/foo remote&lt;/code&gt; -用于在正在运行的系统上运行命令或连接到正在运行的系统</target>
        </trans-unit>
        <trans-unit id="61afcc7c9d27662591ec64aeb53fbe50494c9c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo start&lt;/code&gt;, &lt;code&gt;bin/foo start_iex&lt;/code&gt;, &lt;code&gt;bin/foo restart&lt;/code&gt;, and &lt;code&gt;bin/foo stop&lt;/code&gt; - for general management of the release</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; ， &lt;code&gt;bin/foo start_iex&lt;/code&gt; ， &lt;code&gt;bin/foo restart&lt;/code&gt; 和 &lt;code&gt;bin/foo stop&lt;/code&gt; -用于释放的一般管理</target>
        </trans-unit>
        <trans-unit id="1d72332764c11e123f7347708663156c1233e11a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a keyword list with the value of all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 是一个关键字列表，其中包含在评估 &lt;code&gt;string&lt;/code&gt; 之后所有变量绑定的值。绑定键通常是一个原子，但对于在不同上下文中定义的变量，它可能是一个元组。</target>
        </trans-unit>
        <trans-unit id="1c823d3a888334fa369393bafb696100163d27f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bits&lt;/code&gt; (alias for &lt;code&gt;bitstring&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bits&lt;/code&gt; （ &lt;code&gt;bitstring&lt;/code&gt; 的别名）</target>
        </trans-unit>
        <trans-unit id="15d4a43121fe32de8967a969e91d058bcf17a84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes&lt;/code&gt; (alias for &lt;code&gt;binary&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; （ &lt;code&gt;binary&lt;/code&gt; 别名）</target>
        </trans-unit>
        <trans-unit id="834919dffb47cc92a7a48cd0b0701a70f30f53b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: words in the list are charlists</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; ：列表中的单词是字符列表</target>
        </trans-unit>
        <trans-unit id="b2ccd200c0a8ea5eab26b2092f3c2628e13ebdda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; 或 &lt;code&gt;info&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="f8c3b2d3da64ab6cc3b0a518b860cadf593c568e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; is a function that receives no arguments and runs in a separate process than the caller.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 函数是不接收任何参数的函数，它在与调用者不同的进程中运行。</target>
        </trans-unit>
        <trans-unit id="95b68f4cda4012cbd6bf09e1c90d22f081c35df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; allows us to compare a value against many patterns until we find a matching one:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 允许我们将值与许多模式进行比较，直到找到匹配的模式：</target>
        </trans-unit>
        <trans-unit id="e2e836bef50ccfd75e73db047504ecafbbd45966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; is useful when you need to match against different values. However, in many circumstances, we want to check different conditions and find the first one that does not evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. In such cases, one may use &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 当您需要匹配不同的值时，case很有用。但是，在许多情况下，我们要检查不同的条件，并找到第一个不 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的条件。在这种情况下，可以使用 &lt;code&gt;cond&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93db9ef7d76055eccf64ca125a1bd08e2afa0ce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caseless&lt;/code&gt; (i) - adds case insensitivity</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; （ⅰ） -将不区分大小写</target>
        </trans-unit>
        <trans-unit id="81988c264165854eebe013b354206a9d80761cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;kernel#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 可以用来捕获&lt;a href=&quot;kernel#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; &lt;/a&gt;抛出的值：</target>
        </trans-unit>
        <trans-unit id="cb7c5d439fab5f4770d5cbbe8aa9adfa7fda6776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="db91933fecb8b9776531516395537a60984fe8c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changed&lt;/code&gt; is a keyword list of keys and their changed values in the application environment. &lt;code&gt;new&lt;/code&gt; is a keyword list with all new keys and their values. &lt;code&gt;removed&lt;/code&gt; is a list with all removed keys.</source>
          <target state="translated">&lt;code&gt;changed&lt;/code&gt; 是应用程序环境中键及其更改值的关键字列表。 &lt;code&gt;new&lt;/code&gt; 是包含所有新键及其值的关键字列表。 &lt;code&gt;removed&lt;/code&gt; 是具有所有被删除键的列表。</target>
        </trans-unit>
        <trans-unit id="60538f44591b66b504b274f4df6fe77688be99e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_list/0&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;char_list/0&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="343cfd2a019aa43de8f9ab53908dba3ccb94d728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process or the atom &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; -相应的子过程或原子的PID &lt;code&gt;:restarting&lt;/code&gt; 过程是否要被重新启动</target>
        </trans-unit>
        <trans-unit id="8b19e01788ee36713a234b5a35b8998444e68a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process, &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted, or &lt;code&gt;:undefined&lt;/code&gt; if there is no such process</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; -相应的子进程的PID， &lt;code&gt;:restarting&lt;/code&gt; 过程是否要重新启动，或者 &lt;code&gt;:undefined&lt;/code&gt; 如果没有这样的过程</target>
        </trans-unit>
        <trans-unit id="4b785aaae874a7f7ac89b390425e4e181327565b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;child_spec/1&quot; section of the documentation for &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 应该是有效的子规范，如&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;文档的&amp;ldquo; child_spec / 1&amp;rdquo;部分中所述。子进程将按照子规范中的定义启动。</target>
        </trans-unit>
        <trans-unit id="d9984de2b8855daeaef81ef2dcc1396c0705a01d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 应该是有效的子规范。子进程将按照子规范中的定义启动。</target>
        </trans-unit>
        <trans-unit id="9f93140b69bea94d444900d436d05d80b21439d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; 接收当前元素和累加器，并且必须返回 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 来发出给定的块并继续累加器，或者 &lt;code&gt;{:cont, acc}&lt;/code&gt; 不发出任何块并继续返回累加器。</target>
        </trans-unit>
        <trans-unit id="1a4d8126ef5b5ce5f93f354fe8074bc265f819b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client&lt;/code&gt; must be the &lt;code&gt;from&lt;/code&gt; argument (the second argument) accepted by &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callbacks. &lt;code&gt;reply&lt;/code&gt; is an arbitrary term which will be given back to the client as the return value of the call.</source>
          <target state="translated">&lt;code&gt;client&lt;/code&gt; 必须是&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt;回调接受的 &lt;code&gt;from&lt;/code&gt; 参数（第二个参数）。 &lt;code&gt;reply&lt;/code&gt; 是一个任意术语，它将作为调用的返回值返回给客户端。</target>
        </trans-unit>
        <trans-unit id="74ea1ebde7d25d8d5b3afc102cd5079c21ac3674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; is expected to be an executable available in PATH unless an absolute path is given.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 除非给出绝对路径，否则该命令应该是PATH中可用的可执行文件。</target>
        </trans-unit>
        <trans-unit id="dcd9856e60a10b0680192123ebbb0d9096956b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which is executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; （和 &lt;code&gt;config/prod.exs&lt;/code&gt; ）-提供构建时应用程序配置，该配置在发行版组装后执行</target>
        </trans-unit>
        <trans-unit id="238fad20b64f6752094e989e81c47221593a4dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time the release boots and is further extensible via config providers</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; -提供运行时应用程序配置。它在每次发行版引导时执行，并可通过配置提供程序进一步扩展</target>
        </trans-unit>
        <trans-unit id="a8ff7a040c02a1351d6dbd358d27db3517eb600c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to a regular &lt;code&gt;config/config.exs&lt;/code&gt; but it may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; 文件的工作与常规 &lt;code&gt;config/config.exs&lt;/code&gt; 非常相似，但是可能会有一些限制。您可以&lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;阅读文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8f3eb732cc99e5e8d0e7d53c8f3927e2f14fdbcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; must be &lt;code&gt;iodata&lt;/code&gt; (a list of bytes or a binary). Setting the encoding for this function has no effect.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 必须是 &lt;code&gt;iodata&lt;/code&gt; （字节列表或二进制文件）。设置此功能的编码无效。</target>
        </trans-unit>
        <trans-unit id="3deab4bf4d8695b2db46398f128ebe3680400d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contents&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 可以是字符串，字符串列表或编译模式。</target>
        </trans-unit>
        <trans-unit id="4068af36af3815a173cb8e9bbb5840dd4f7966e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context&lt;/code&gt; - the context of the environment; it can be &lt;code&gt;nil&lt;/code&gt; (default context), &lt;code&gt;:guard&lt;/code&gt; (inside a guard) or &lt;code&gt;:match&lt;/code&gt; (inside a match)</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; -环境的上下文；它可以是 &lt;code&gt;nil&lt;/code&gt; （默认上下文） &lt;code&gt;:guard&lt;/code&gt; （在守卫内部）或 &lt;code&gt;:match&lt;/code&gt; （在比赛内）</target>
        </trans-unit>
        <trans-unit id="e65d01ac3d70dd939e249ff006400606c24ca6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context_modules&lt;/code&gt; - a list of modules defined in the current context</source>
          <target state="translated">&lt;code&gt;context_modules&lt;/code&gt; -当前上下文中定义的模块列表</target>
        </trans-unit>
        <trans-unit id="5d9edb2d993802ba4716d7849368f4f8e74a86f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cprof&lt;/code&gt; can be useful when you want to discover the bottlenecks related to function calls.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 当您想发现与函数调用相关的瓶颈时，cprof可能会很有用。</target>
        </trans-unit>
        <trans-unit id="38a38cdb98964403a68aee6e3174c867d51569e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; -此时间字段的解释取决于操作系统。在Unix上，这是最后一次更改文件或inode的时间。在Windows中，这是创建时间。</target>
        </trans-unit>
        <trans-unit id="f1205b070fab0c83d6c993c3f3960abb127d2ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the characters in the line terminated by a line-feed (LF) or end of file (EOF)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -行中以换行（LF）或文件结尾（EOF）结尾的字符</target>
        </trans-unit>
        <trans-unit id="65ebe7dc5a6cbe47bb0f679ee7ef6cf59418d356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the input characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输入字符</target>
        </trans-unit>
        <trans-unit id="3d4410c596b384477fdcae0b3c0d2b1de73cede5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output bytes</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输出字节</target>
        </trans-unit>
        <trans-unit id="d66ff6e276982cb027d53bd1f1e405fd861fcfe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; -输出字符</target>
        </trans-unit>
        <trans-unit id="f1e314b3d0f6ce196df7c11d73e42319ca204a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 是一个嵌套结构（即实现&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;行为的映射，关键字列表或结构）。</target>
        </trans-unit>
        <trans-unit id="e5cb8b51e466bd529414676deb5702007605833f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt; may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 可以是远程或本地PID，本地端口，本地注册名称，也可以是 &lt;code&gt;{registered_name, node}&lt;/code&gt; 形式的元组，表示另一个节点上的注册名称。</target>
        </trans-unit>
        <trans-unit id="06cb04154e21b24c69f9c8bad5656b7a39545bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device&lt;/code&gt; - the IO device</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; -IO设备</target>
        </trans-unit>
        <trans-unit id="48cd3cb1cdaa44a2d6bca7edd5d1a1fc56abbc4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 块</target>
        </trans-unit>
        <trans-unit id="325351821945a7973f1da881d3d9c9177ab84e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks are a syntactic convenience built on top of the keywords one. That&amp;rsquo;s why &lt;code&gt;do/end&lt;/code&gt; blocks do not require a comma between the previous argument and the block. They are useful exactly because they remove the verbosity when writing blocks of code. These are equivalent:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 块是建立在关键字one之上的语法便利。这就是为什么 &lt;code&gt;do/end&lt;/code&gt; 块在前一个参数和该块之间不需要逗号的原因。它们之所以有用，正是因为它们在编写代码块时消除了冗长的内容。这些是等效的：</target>
        </trans-unit>
        <trans-unit id="ade8e208e831b5d198ac3add386fe1dab9834807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; - used in do/end blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ， &lt;code&gt;rescue&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; -在做/结束块</target>
        </trans-unit>
        <trans-unit id="3985298d4759592d757f0cb9a9e4f9b15e52aa5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块</target>
        </trans-unit>
        <trans-unit id="43edbc936cf9ae8a8d1677e787957e43950a7cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dollar_endonly&lt;/code&gt; - not available, use &lt;code&gt;\z&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;dollar_endonly&lt;/code&gt; -不提供，使用 &lt;code&gt;\z&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="81166ee1fc1c5f6aa3345e5c1516903114a049ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description in &lt;code&gt;xref_graph.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -产生以点图形描述 &lt;code&gt;xref_graph.dot&lt;/code&gt; 在当前目录。警告：这将覆盖任何先前生成的文件</target>
        </trans-unit>
        <trans-unit id="5aa86ef28d23f77d91172ba542c09d2cc5b7637b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dotall&lt;/code&gt; (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; according to &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;dotall&lt;/code&gt; （s）-使点与换行符匹配，并将换行符设置为anycrlf；可以根据 &lt;code&gt;:re&lt;/code&gt; 文档设置 &lt;code&gt;(*CR)&lt;/code&gt; 或 &lt;code&gt;(*LF)&lt;/code&gt; 或 &lt;code&gt;(*CRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANY)&lt;/code&gt; 来覆盖新行设置</target>
        </trans-unit>
        <trans-unit id="df6f1675aa9801dfb22096bcea57d03ccca2fb4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="d4c769601399680023c8ba6fd6b77d7373a374a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses allow the result of the body passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; to be pattern matched on:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 子句允许传递给&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;的正文的结果在以下位置进行模式匹配：</target>
        </trans-unit>
        <trans-unit id="cddbb9fd21a3bab1166f759ba9181e02747b988c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; can also be &amp;ldquo;caught&amp;rdquo; using &lt;code&gt;try/catch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 也可以使用 &lt;code&gt;try/catch&lt;/code&gt; 来&amp;ldquo;捕获&amp;rdquo; 出口：</target>
        </trans-unit>
        <trans-unit id="17e496cdf50605afa594c0a2b3b48bf5f1fd62d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; signals are an important part of the fault tolerant system provided by the Erlang</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 信号是Erlang提供的容错系统的重要组成部分</target>
        </trans-unit>
        <trans-unit id="db3067f33775b9f16e85d2c27602d9e6760ad782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extended&lt;/code&gt; (x) - whitespace characters are ignored except when escaped and allow &lt;code&gt;#&lt;/code&gt; to delimit comments</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; （x）-空格字符将被忽略，除非已转义，并且允许 &lt;code&gt;#&lt;/code&gt; 分隔注释</target>
        </trans-unit>
        <trans-unit id="5dd94be61300bd55483654aaa07e30abd3dae510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - ignores padding from the input string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; -忽略输入字符串的填充</target>
        </trans-unit>
        <trans-unit id="0f2f2cad3367ff4259e6a85005d20253c790cbd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - omit padding from the output string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; -省略输出字符串中的填充</target>
        </trans-unit>
        <trans-unit id="0dd4008fc42804b6bf3e46bd4df4d0ea81c26c3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; - the current file name as a binary</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; -当前文件名（二进制）</target>
        </trans-unit>
        <trans-unit id="89e027d1ed05b4018b4a08d0262f23b3ff60ce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstline&lt;/code&gt; (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline</source>
          <target state="translated">&lt;code&gt;firstline&lt;/code&gt; （f）-强制未锚定模式在第一个换行符之前或在第一行换行，尽管匹配的文本可能会在换行符上继续</target>
        </trans-unit>
        <trans-unit id="6908e3631ddb64d7fcca5b3480aa8fd1cfac7e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; - used for anonymous function definitions</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; -用于匿名函数定义</target>
        </trans-unit>
        <trans-unit id="7b569c1f1b88d633c8ae41253689a2f767acd2bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; - accesses a map/struct field; in case the field is not present, an error is raised</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; -访问一个map / struct字段；如果该字段不存在，则会引发错误</target>
        </trans-unit>
        <trans-unit id="f4b838ac959304b5441479216a13abe7cbdbbcf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo[bar]&lt;/code&gt; - accesses the key &lt;code&gt;bar&lt;/code&gt; in &lt;code&gt;foo&lt;/code&gt;; in case &lt;code&gt;foo&lt;/code&gt; is nil, &lt;code&gt;nil&lt;/code&gt; is returned</source>
          <target state="translated">&lt;code&gt;foo[bar]&lt;/code&gt; -访问该键 &lt;code&gt;bar&lt;/code&gt; 中 &lt;code&gt;foo&lt;/code&gt; ; 如果 &lt;code&gt;foo&lt;/code&gt; 为nil，则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eef0f2d09999efe1c1a474dc48a013215ea64e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprof&lt;/code&gt; can be useful when you want to discover the bottlenecks of a sequential code.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 当您想发现顺序代码的瓶颈时，fprof很有用。</target>
        </trans-unit>
        <trans-unit id="2c7bedba0b383b7f10d86c6ad80100844e60be3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 是调用下的电流值， &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map&lt;/code&gt; （或 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 不在当前 &lt;code&gt;map&lt;/code&gt; ），并且必须返回一个两个元素的元组：&amp;ldquo;获取&amp;rdquo;值（检索到的值，可以在返回前进行操作）以及将要存储在新映射中 &lt;code&gt;key&lt;/code&gt; 下的新值。 &lt;code&gt;fun&lt;/code&gt; 可能还会返回 &lt;code&gt;:pop&lt;/code&gt; ，这意味着当前值将从 &lt;code&gt;map&lt;/code&gt; 中删除并返回（使此函数的行为类似于 &lt;code&gt;Map.pop(map, key)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="73987292ec55c205146407f70cc34101bc201e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the module name of the given &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt;. The return value of this function is the return value of &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 是所谓的与给定的模块名称&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;。该函数的返回值是 &lt;code&gt;fun&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="0344ca817de66fc2cf01667d06d78a915e393ff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 必须是零arity匿名函数。</target>
        </trans-unit>
        <trans-unit id="bec4f976c611de0387ba3b8e5bc5a82998ebd9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 必须是零arity匿名函数。此功能产生一个链接到调用者进程并受其监视的进程。一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;结构返回一个包含相关信息。</target>
        </trans-unit>
        <trans-unit id="ba04c9a31c6587cb12b54223a008938c6c36fce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt; - a tuple as &lt;code&gt;{atom, integer}&lt;/code&gt;, where the first element is the function name and the second its arity; returns &lt;code&gt;nil&lt;/code&gt; if not inside a function</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; - &lt;code&gt;{atom, integer}&lt;/code&gt; 的元组，其中第一个元素是函数名称，第二个元素是函数名称；如果不在函数内，则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdce62b51d95c967bffec92639abb05fa80a816f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;functions&lt;/code&gt; - a list of functions imported from each module</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; -从每个模块导入的功能列表</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 是检索到的值（可以在返回之前对其进行操作）</target>
        </trans-unit>
        <trans-unit id="24a178311ad224c4a60feb7863864b4d30e88cd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; -指示拥有文件的组。对于非Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="64ea8480a297125c017fea9dde76f546c7b7fe47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_leader&lt;/code&gt; is the group leader of the process which logged the message</source>
          <target state="translated">&lt;code&gt;group_leader&lt;/code&gt; 是记录消息的过程的组长</target>
        </trans-unit>
        <trans-unit id="7e4a6ea58f48db7fc69ef53cf936a56a08b467db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_call/3&lt;/code&gt; must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful backpressure mechanism.</source>
          <target state="translated">&lt;code&gt;handle_call/3&lt;/code&gt; 必须用于同步请求。这应该是默认选择，因为等待服务器回复是一种有用的反压机制。</target>
        </trans-unit>
        <trans-unit id="a2af7471be23ef0937ae1a0fe2c62f92e8f8d066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_cast/2&lt;/code&gt; must be used for asynchronous requests, when you don&amp;rsquo;t care about a reply. A cast does not even guarantee the server has received the message and, for this reason, should be used sparingly. For example, the &lt;code&gt;create/2&lt;/code&gt; function we have defined in this chapter should have used &lt;code&gt;call/2&lt;/code&gt;. We have used &lt;code&gt;cast/2&lt;/code&gt; for didactic purposes.</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 当您不关心答复时，必须将handle_cast / 2用于异步请求。强制转换甚至不能保证服务器已收到该消息，因此，应谨慎使用。例如，我们在本章中定义的 &lt;code&gt;create/2&lt;/code&gt; 函数应该使用 &lt;code&gt;call/2&lt;/code&gt; 。我们已将 &lt;code&gt;cast/2&lt;/code&gt; 用于教学目的。</target>
        </trans-unit>
        <trans-unit id="ba53ab70dc78f0a9b7412ec3b2bb0f747a7d63ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_info/2&lt;/code&gt; must be used for all other messages a server may receive that are not sent via &lt;code&gt;GenServer.call/2&lt;/code&gt; or &lt;code&gt;GenServer.cast/2&lt;/code&gt;, including regular messages sent with &lt;code&gt;send/2&lt;/code&gt;. The monitoring &lt;code&gt;:DOWN&lt;/code&gt; messages are an example of this.</source>
          <target state="translated">&lt;code&gt;handle_info/2&lt;/code&gt; 必须将handle_info / 2用于服务器可能未通过 &lt;code&gt;GenServer.call/2&lt;/code&gt; 或 &lt;code&gt;GenServer.cast/2&lt;/code&gt; 发送的所有其他消息，包括使用 &lt;code&gt;send/2&lt;/code&gt; 发送的常规消息。监视 &lt;code&gt;:DOWN&lt;/code&gt; 消息就是一个例子。</target>
        </trans-unit>
        <trans-unit id="8e34c824ac05b21ab757c5fbf6100951dcd8cb12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -在子规范中定义</target>
        </trans-unit>
        <trans-unit id="a955d26c8cf2d713bf003551df2c96067ee51799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - it is always &lt;code&gt;:undefined&lt;/code&gt; for dynamic supervisors</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -它始终是 &lt;code&gt;:undefined&lt;/code&gt; 动态监管</target>
        </trans-unit>
        <trans-unit id="1f9254b1d6d22c5cafac5af8f10ed37f33275d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;unless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89169d2e3dce0e0e3f3d300ab237fbc286465d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for!/1&lt;/code&gt; - same as above but raises an error if an implementation is not found</source>
          <target state="translated">&lt;code&gt;impl_for!/1&lt;/code&gt; -与上述相同，但是如果找不到实现，则会引发错误</target>
        </trans-unit>
        <trans-unit id="dd4dcd3de4db76dbf5cd688389ee6bc144a73c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - receives a structure and returns the module that implements the protocol for the structure, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; -接收结构并返回实现该结构协议的模块，否则返回 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77adafb3f8e1c04dc649c8a27bf4a028398d3422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;import Config&lt;/code&gt; 将导入功能&lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; ,&lt;/a&gt;以帮助您管理配置。</target>
        </trans-unit>
        <trans-unit id="4616b488ff51bfbaf80546fbb756faeba6d758dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; also supports &lt;code&gt;:macros&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; to be given to &lt;code&gt;:only&lt;/code&gt;. For example, to import all macros, one could write:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 还支持 &lt;code&gt;:macros&lt;/code&gt; 和 &lt;code&gt;:functions&lt;/code&gt; 赋予 &lt;code&gt;:only&lt;/code&gt; 。例如，要导入所有宏，可以编写：</target>
        </trans-unit>
        <trans-unit id="6778e8370969e09cdb7b6d95b8411befab07014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;&lt;code&gt;not in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; &lt;code&gt;not in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c71b4bbf5308a944ca78d7e8a7957ad9301c49e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; 必须是&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;。给定一个 &lt;code&gt;enumerable&lt;/code&gt; ，它将元素 &lt;code&gt;index_range.first&lt;/code&gt; 之前（零基），然后将元素 &lt;code&gt;index_range.last&lt;/code&gt; 元素index_range.last之前（包括端点）。</target>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_arg&lt;/code&gt; 是传递给&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;的参数项（第二个参数）。</target>
        </trans-unit>
        <trans-unit id="42ccdeed4cb31f96c120a6107473e17cfa988fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; -给出索引号。在非Unix文件系统上，该字段为零。</target>
        </trans-unit>
        <trans-unit id="a082bb1049b72730ef91489b19d870c7f2e5f5fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cac343e7ca30a47b6b2cafdd3b896dfb0b1254c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; ， &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f662fb245490dd208672d79aaf08db7f1d03ffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; ， &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04dc3cb7748f4ca9dc612c4051de3bbd8865f718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;invalid&lt;/code&gt; is a list of invalid options as &lt;code&gt;{option_name, value}&lt;/code&gt; where &lt;code&gt;option_name&lt;/code&gt; is the raw option and &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option</source>
          <target state="translated">&lt;code&gt;invalid&lt;/code&gt; 是无效的选项列表 &lt;code&gt;{option_name, value}&lt;/code&gt; 其中 &lt;code&gt;option_name&lt;/code&gt; 是原始选项和 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;nil&lt;/code&gt; ，如果是没有预料到的选项或字符串值，如果值没有在相应的选项预期的类型</target>
        </trans-unit>
        <trans-unit id="55411785328be352b733c3e64dd054a411983253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 实际上是处理文件的进程的PID。此过程链接到最初打开文件的过程。如果链接到 &lt;code&gt;io_device&lt;/code&gt; 的任何进程终止，该文件将关闭，并且进程本身将终止。</target>
        </trans-unit>
        <trans-unit id="5af2f0d60c8ca31bd9daa14054f2d8834771b498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iodata&lt;/code&gt; and &lt;code&gt;chardata&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iodata&lt;/code&gt; 和 &lt;code&gt;chardata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea30f7281c750bcdb363bf792a71040fa82420b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e622f1b70f9ca4dde650995469cb5ac546f01dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_&lt;/code&gt; prefix (&lt;code&gt;is_foo&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;is_&lt;/code&gt; 前缀（ &lt;code&gt;is_foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0ae12fa1bd5cefeb45ca87984e5434aa6c1ab55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner&lt;/code&gt; can be either a binary or a list and the result will be of the same type as &lt;code&gt;joiner&lt;/code&gt;. If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty binary.</source>
          <target state="translated">&lt;code&gt;joiner&lt;/code&gt; 可以是二进制文件也可以是列表，并且结果将与 &lt;code&gt;joiner&lt;/code&gt; 属于同一类型。如果完全没有传递 &lt;code&gt;joiner&lt;/code&gt; ，则默认为空二进制文件。</target>
        </trans-unit>
        <trans-unit id="050495ebb57fd238ad025920a895b7b1b31f5954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; - if the message is a &lt;code&gt;:report&lt;/code&gt; or &lt;code&gt;:format&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; -如果消息是 &lt;code&gt;:report&lt;/code&gt; 或 &lt;code&gt;:format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="341383e5f6f763ffb092f6be26a117949ada5934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; can be any of &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt;, or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 可以是 &lt;code&gt;:def&lt;/code&gt; ， &lt;code&gt;:defp&lt;/code&gt; ， &lt;code&gt;:defmacro&lt;/code&gt; 或 &lt;code&gt;:defmacrop&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="43a606e3b01bc357576e2067b4913ba6530c37d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - set it to &lt;code&gt;:erlang&lt;/code&gt; for Erlang projects managed by Mix. Doing so will ensure Elixir is not embedded by default. Your app will still be started as part of escript loading, with the config used during build.</source>
          <target state="translated">&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; 对于由Mix管理的Erlang项目，将其设置为 &lt;code&gt;:erlang&lt;/code&gt; 。这样做将确保默认情况下未嵌入Elixir。您的应用仍将作为escript加载的一部分启动，并使用在构建过程中使用的配置。</target>
        </trans-unit>
        <trans-unit id="1615078eab6862c1223e38ceca7c0c858e7fb3ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left not in right&lt;/code&gt; is parsed by the compiler into the AST:</source>
          <target state="translated">&lt;code&gt;left not in right&lt;/code&gt; 编译器将左不右的内容解析为AST：</target>
        </trans-unit>
        <trans-unit id="04daa36a0e26e29c02251806cbf56bde90f72442" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - the level of the message being translated</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; -正在翻译的消息的级别</target>
        </trans-unit>
        <trans-unit id="a0cdec75a5c5e0d6470766585fef67da68441fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 是 &lt;code&gt;:debug&lt;/code&gt; ， &lt;code&gt;:info&lt;/code&gt; ， &lt;code&gt;:warn&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 之一，如先前所述</target>
        </trans-unit>
        <trans-unit id="ad467d7b51aa9a22263cef951086b6316700c37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_tracker&lt;/code&gt; - PID of the lexical tracker which is responsible for keeping user info</source>
          <target state="translated">&lt;code&gt;lexical_tracker&lt;/code&gt; -词法跟踪器的PID，负责保留用户信息</target>
        </trans-unit>
        <trans-unit id="00b7f69aa97db45047c5fc9677b43d58013c72d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the current line as an integer</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; -当前行为整数</target>
        </trans-unit>
        <trans-unit id="8a637d2453fa7712dde78a4184c51cb4f28ba3e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line_or_bytes&lt;/code&gt; - if reading should read lines or a given number of bytes</source>
          <target state="translated">&lt;code&gt;line_or_bytes&lt;/code&gt; -如果读取应读取行或给定数量的字节</target>
        </trans-unit>
        <trans-unit id="de043cb51af4ab5a147a2fd2fb7510e6d4f6968b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;links&lt;/code&gt; - the number of links to this file. This is always 1 for file systems which have no concept of links.</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; -到此文件的链接数。对于没有链接概念的文件系统，该值始终为1。</target>
        </trans-unit>
        <trans-unit id="b6df45129219eb88ff0e445a634f5ec40fa7565a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list(binary)&lt;/code&gt; - a list of named captures to capture</source>
          <target state="translated">&lt;code&gt;list(binary)&lt;/code&gt; -要捕获的命名捕获的列表</target>
        </trans-unit>
        <trans-unit id="b30b2f2ca39cc18127aed43526b57922054977d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro_aliases&lt;/code&gt; - a list of aliases defined inside the current macro</source>
          <target state="translated">&lt;code&gt;macro_aliases&lt;/code&gt; -当前宏内定义的别名列表</target>
        </trans-unit>
        <trans-unit id="e68229a8f305b62b43dd03a0bee3d8371fd691cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macros&lt;/code&gt; - a list of macros imported from each module</source>
          <target state="translated">&lt;code&gt;macros&lt;/code&gt; -从每个模块导入的宏的列表</target>
        </trans-unit>
        <trans-unit id="da01a0ff55acb30995528624346541bfd079654b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_device&lt;/code&gt; - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">&lt;code&gt;major_device&lt;/code&gt; -标识文件所在的文件系统。在Windows中，数字表示驱动器，如下所示：0表示A :， 1表示B :，依此类推。</target>
        </trans-unit>
        <trans-unit id="122658d8aed547a03014a89daa76d75e7458af25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - the message to format. If it is &lt;code&gt;:report&lt;/code&gt;, it is a tuple with &lt;code&gt;{report_type, report_data}&lt;/code&gt;, if it is &lt;code&gt;:format&lt;/code&gt;, it is a tuple with &lt;code&gt;{format_message, format_args}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; -要格式化的消息。如果为 &lt;code&gt;:report&lt;/code&gt; ，则为具有 &lt;code&gt;{report_type, report_data}&lt;/code&gt; 的元组；如果为 &lt;code&gt;:format&lt;/code&gt; ，则为具有 &lt;code&gt;{format_message, format_args}&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="758cc0c5ee8acd71fe0b83a3e86f48dd145a827c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; is the actual message (as chardata)</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 是实际的消息（作为chardata）</target>
        </trans-unit>
        <trans-unit id="876c3f9a8c4fd0d3cc2d1f037866f3debf0464cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; is a keyword list of metadata used when logging the message</source>
          <target state="translated">&lt;code&gt;metadata&lt;/code&gt; 是记录消息时使用的元数据的关键字列表</target>
        </trans-unit>
        <trans-unit id="a589d4f6762768ff5257c5bba38458ca30db3f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_level&lt;/code&gt; - the current Logger level</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; -当前记录器级别</target>
        </trans-unit>
        <trans-unit id="3885fa3becd34b396b52f6d8056bdc58ee479e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -仅对Unix上的字符设备有效。在所有其他情况下，此字段为零。</target>
        </trans-unit>
        <trans-unit id="b6340174a39f21a758f5572a672b194a9d24cc3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; - the file permissions.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; -文件权限。</target>
        </trans-unit>
        <trans-unit id="8a3927965ac3d6f77c51036b665e6f351a35212d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:always&lt;/code&gt;, which means nesting always happen, or &lt;code&gt;:break&lt;/code&gt;, which means nesting only happens inside a group that has been broken.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:always&lt;/code&gt; ，这意味着总是发生嵌套，或者是 &lt;code&gt;:break&lt;/code&gt; ，这意味着嵌套只发生在已断开的组中。</target>
        </trans-unit>
        <trans-unit id="58c0879f979115e580bc917136d2b58ff8c9f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:enabled&lt;/code&gt; or &lt;code&gt;:disabled&lt;/code&gt;. When &lt;code&gt;:enabled&lt;/code&gt;, it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; in search of the next break.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:enabled&lt;/code&gt; 或 &lt;code&gt;:disabled&lt;/code&gt; 。当 &lt;code&gt;:enabled&lt;/code&gt; 时，它将在找到下一个中​​断后立即认为文档合适，从而有效地取消了该中断。在搜索下一个中断时，它将也忽略任何&lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50100399cfb27f3841672acd2f4af9b485e65862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; lowercases only the letters A to Z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:default&lt;/code&gt; ， &lt;code&gt;:ascii&lt;/code&gt; 或 &lt;code&gt;:greek&lt;/code&gt; 。的 &lt;code&gt;:default&lt;/code&gt; 模式认为Unicode标准中列出的所有非条件的转换。 &lt;code&gt;:ascii&lt;/code&gt; 仅将字母A到Z小写。 &lt;code&gt;:greek&lt;/code&gt; 包括在希腊语中找到的上下文相关映射。</target>
        </trans-unit>
        <trans-unit id="a1aa428e4e231b54bacb63710c1631f262151d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; uppercases only the letters a to z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可以是 &lt;code&gt;:default&lt;/code&gt; ， &lt;code&gt;:ascii&lt;/code&gt; 或 &lt;code&gt;:greek&lt;/code&gt; 。的 &lt;code&gt;:default&lt;/code&gt; 模式认为Unicode标准中列出的所有非条件的转换。 &lt;code&gt;:ascii&lt;/code&gt; 仅将字母a到z大写。 &lt;code&gt;:greek&lt;/code&gt; 包括希腊语中的上下文相关映射。</target>
        </trans-unit>
        <trans-unit id="a86fdaff8bc5148e78a1c4c04f8fce0a3900889d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes&lt;/code&gt; - the file modes</source>
          <target state="translated">&lt;code&gt;modes&lt;/code&gt; -文件模式</target>
        </trans-unit>
        <trans-unit id="8d0e52c287df97f7b63fd739d48b6d486974eb14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes_or_function&lt;/code&gt; can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt;. See the documentation for &lt;a href=&quot;#open/3&quot;&gt;&lt;code&gt;open/3&lt;/code&gt;&lt;/a&gt; for more information on this function.</source>
          <target state="translated">&lt;code&gt;modes_or_function&lt;/code&gt; 可以是模式列表或函数。如果是列表，则将其视为模式列表（在下面记录）。如果它是一个函数，则等效于调用 &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt; 。有关此功能的更多信息，请参见&lt;a href=&quot;#open/3&quot;&gt; &lt;code&gt;open/3&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="34262bd30becc8991857017eb2e5b09e7a70e4f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - the current module name</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; -当前模块名称</target>
        </trans-unit>
        <trans-unit id="698d9c8f57c8e28a58401b70d215fc5e4dfe9978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; has to be an Elixir module, as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; won't work with Erlang-style modules (for example, &lt;code&gt;split(:lists)&lt;/code&gt; raises an error).</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 必须是Elixir模块，因为&lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt;不适用于Erlang样式的模块（例如， &lt;code&gt;split(:lists)&lt;/code&gt; 会引发错误）。</target>
        </trans-unit>
        <trans-unit id="548b3515fdb43f8aa1119d92ad82f1b43b9de201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; -子规范中定义</target>
        </trans-unit>
        <trans-unit id="5b0d17e736b2173d4e4a1a204473eec63e0cda5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as specified by the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; -由子规范指定</target>
        </trans-unit>
        <trans-unit id="b3e68cee7399cd5a129a86e8776d09db0b50d6de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; is the message and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. When a timeout occurs the message is &lt;code&gt;:timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 是消息， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。发生超时时，消息为 &lt;code&gt;:timeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235eae13b2d8f1e8b35533fb20776ffccdd37a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mtime&lt;/code&gt; - the last time the file was written.</source>
          <target state="translated">&lt;code&gt;mtime&lt;/code&gt; -上次写入文件的时间。</target>
        </trans-unit>
        <trans-unit id="4413bd051f5b2ef5173fbddf4ea926ec05b4ccf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt; (m) - causes &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to mark the beginning and end of each line; use &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; to match the end or beginning of the string</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt; （m）-使 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 标记每行的开始和结束；使用 &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 匹配字符串的结尾或开头</target>
        </trans-unit>
        <trans-unit id="1aa7f499be35910aae1a7c96d198532426312d81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, &lt;code&gt;v(-2)&lt;/code&gt; returns the value of the expression evaluated before the last evaluated expression. In particular, &lt;code&gt;v(-1)&lt;/code&gt; returns the result of the last evaluated expression and &lt;code&gt;v()&lt;/code&gt; does the same.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 可以是负值：如果是，则返回相对于当前表达式的相应表达式值。例如， &lt;code&gt;v(-2)&lt;/code&gt; 返回在最后一个求值表达式之前求值的表达式的值。特别是， &lt;code&gt;v(-1)&lt;/code&gt; 返回最后一个求值表达式的结果，而 &lt;code&gt;v()&lt;/code&gt; 则执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="45c8a3e19ab3e2ddbc2090990f79c346b752b3be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is an integer greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 是大于或等于 &lt;code&gt;0&lt;/code&gt; 的整数。</target>
        </trans-unit>
        <trans-unit id="5659d6236346e538cb5cb8cba7c914efd4b16565" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/0&lt;/code&gt; to create a new record with default values for all fields</source>
          <target state="translated">&lt;code&gt;name/0&lt;/code&gt; 以使用所有字段的默认值创建新记录</target>
        </trans-unit>
        <trans-unit id="f6ba1c0b71b535b43431e95788b71f1fdb5ee903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/1&lt;/code&gt; to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list</source>
          <target state="translated">&lt;code&gt;name/1&lt;/code&gt; 以创建具有给定字段和值的新记录，以获取记录中给定字段的从零开始的索引，或将给定记录转换为关键字列表</target>
        </trans-unit>
        <trans-unit id="cd9835c312b0e62d1d19feb8dd6a112dd5f5a0e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/2&lt;/code&gt; to update an existing record with the given fields and values or to access a given field in a given record</source>
          <target state="translated">&lt;code&gt;name/2&lt;/code&gt; 以使用给定的字段和值更新现有记录，或访问给定记录中的给定字段</target>
        </trans-unit>
        <trans-unit id="64a47b8a0625c2774e6a643cd7191d74cfc61cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 必须是一个原子，并且在使用&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;发送消息时可以代替PID /端口标识符。</target>
        </trans-unit>
        <trans-unit id="91d48a3d18e54472d43b317cb1d047ea37a8ead4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;, which is the name of the extracted record, is expected to be an atom &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ，它是提取记录的名称，&lt;em&gt;在编译时&lt;/em&gt;应该是一个原子。</target>
        </trans-unit>
        <trans-unit id="ec3f729a0f6c717fcfbc43d515a7ec59810c5367" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native&lt;/code&gt; is determined by the VM at startup and will depend on the host operating system.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 由虚拟机在启动时确定，并将取决于主机操作系统。</target>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 是使用 &lt;code&gt;update_value&lt;/code&gt; 更新 &lt;code&gt;key&lt;/code&gt; 的值之后的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f28f31350f1c7665853e6d4b5999e6152b971b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline&lt;/code&gt; - not available, use &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANYCRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; at the beginning of the regexp according to the &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;newline&lt;/code&gt; -不可用，根据 &lt;code&gt;:re&lt;/code&gt; 文档，在正则表达式的开头使用 &lt;code&gt;(*CR)&lt;/code&gt; 或 &lt;code&gt;(*LF)&lt;/code&gt; 或 &lt;code&gt;(*CRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANYCRLF)&lt;/code&gt; 或 &lt;code&gt;(*ANY)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22526a6e658f1a28d28bf75f04eb407c154f8ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; （v1.0）</target>
        </trans-unit>
        <trans-unit id="6fab3275a5dbf0c17e6bb5dbfbc499091c5cb4ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; if the task keeps running past the timeout</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 如果任务持续超过超时，则为nil</target>
        </trans-unit>
        <trans-unit id="0d2d366e73b9ec112919fa2886cd3525aa66ea55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_auto_capture&lt;/code&gt; - not available, use &lt;code&gt;?:&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;no_auto_capture&lt;/code&gt; -不可用，使用 &lt;code&gt;?:&lt;/code&gt; 代替</target>
        </trans-unit>
        <trans-unit id="408ece252fdd1021e44cd3be96e784b7803ec157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nodes&lt;/code&gt; is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</source>
          <target state="translated">&lt;code&gt;nodes&lt;/code&gt; 是将请求发送到的节点名称的列表。默认值为所有已知节点（包括该节点）的列表。</target>
        </trans-unit>
        <trans-unit id="8137eb4c3f6c478804bd118d3101e44c85663fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 必须是非负整数。</target>
        </trans-unit>
        <trans-unit id="f3b3f1b4b4b341558fb4af537b367fd2795f31d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either a &lt;code&gt;pid&lt;/code&gt; of the monitored process (if monitoring a PID) or &lt;code&gt;{name, node}&lt;/code&gt; (if monitoring a remote or local name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 是受监视进程的 &lt;code&gt;pid&lt;/code&gt; （如果监视PID）或 &lt;code&gt;{name, node}&lt;/code&gt; （如果监视远程或本地名称）；</target>
        </trans-unit>
        <trans-unit id="60373c8878902ec332f31b76bff00eee4691253c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either the &lt;code&gt;port&lt;/code&gt; being monitored (when monitoring by port ID) or &lt;code&gt;{name, node}&lt;/code&gt; (when monitoring by a port name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 是正在监视的 &lt;code&gt;port&lt;/code&gt; （通过端口ID监视时）或 &lt;code&gt;{name, node}&lt;/code&gt; （通过端口名称监视）；</target>
        </trans-unit>
        <trans-unit id="f4103502bdc67af84a755c711febd0144e731649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_vsn&lt;/code&gt; is the previous version of the module (defined by the &lt;code&gt;@vsn&lt;/code&gt; attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element &lt;code&gt;:down&lt;/code&gt;. &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;extra&lt;/code&gt; is any extra data required to change the state.</source>
          <target state="translated">&lt;code&gt;old_vsn&lt;/code&gt; 是升级时模块的先前版本（由 &lt;code&gt;@vsn&lt;/code&gt; 属性定义）。降级时，以前的版本将打包为带有第一个元素 &lt;code&gt;:down&lt;/code&gt; 的2元组。 &lt;code&gt;state&lt;/code&gt; 是当前状态&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;extra&lt;/code&gt; 就是要改变状态所需的任何额外数据。</target>
        </trans-unit>
        <trans-unit id="571d94e13302249f0de59d56d782ae3e234cacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options_or_function&lt;/code&gt; can be a keyword list of options or a function.</source>
          <target state="translated">&lt;code&gt;options_or_function&lt;/code&gt; 可以是选项或函数的关键字列表。</target>
        </trans-unit>
        <trans-unit id="3bab089b1bf1e41f034e7ae6bdb132bc0001b94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;and&lt;/code&gt; 是短路运算符。仅当左侧不足以确定结果时，它们才执行右侧：</target>
        </trans-unit>
        <trans-unit id="ccbe854a095f6f33ceeba28c9b8d43c2cbc1d56a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is a keyword list of parsed switches with &lt;code&gt;{switch_name, value}&lt;/code&gt; tuples in it; &lt;code&gt;switch_name&lt;/code&gt; is the atom representing the switch name while &lt;code&gt;value&lt;/code&gt; is the value for that switch parsed according to &lt;code&gt;opts&lt;/code&gt; (see the &quot;Examples&quot; section for more information)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是其中包含 &lt;code&gt;{switch_name, value}&lt;/code&gt; 元组的已解析开关的关键字列表； &lt;code&gt;switch_name&lt;/code&gt; 是代表交换机名称的原子，而 &lt;code&gt;value&lt;/code&gt; 是根据 &lt;code&gt;opts&lt;/code&gt; 解析的该交换机的值（有关更多信息，请参见&amp;ldquo;示例&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="b1fbee1588161b4bf8e5a810b28d741081f25011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是已解析的开关的列表（与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; 中的&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="2788d1165c4896248d485fc9d7605024d3d940c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 是已解析的开关的列表（与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; 中的&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="56a1d646feea00078c3dafde93470f5d90c7d9db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the file path</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; -文件路径</target>
        </trans-unit>
        <trans-unit id="c68a85ae9613cab9896c95f71c08475d4a1e6f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; has to be a literal string and is automatically expanded via &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 必须是文字字符串，并通过&lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt;自动扩展。</target>
        </trans-unit>
        <trans-unit id="bff908c352a7c02daae4149d788dab257dcc7734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdict_and_state&lt;/code&gt; is a two-elements list &lt;code&gt;[pdict, state]&lt;/code&gt; where &lt;code&gt;pdict&lt;/code&gt; is a list of &lt;code&gt;{key, value}&lt;/code&gt; tuples representing the current process dictionary of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pdict_and_state&lt;/code&gt; 是两元件列表 &lt;code&gt;[pdict, state]&lt;/code&gt; 其中 &lt;code&gt;pdict&lt;/code&gt; 是列表 &lt;code&gt;{key, value}&lt;/code&gt; 元组代表的当前进程字典&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;state&lt;/code&gt; 是所述的当前状态&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c00f6b21503d6f14ec9e351116f82e98a1a573d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="283bbf3a7e63361529544f57e65445c33be2473a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; is the PID of the caller and &lt;code&gt;tag&lt;/code&gt; is a unique term used to identify the call.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 是呼叫者的PID，而 &lt;code&gt;tag&lt;/code&gt; 是用于识别呼叫的唯一术语。</target>
        </trans-unit>
        <trans-unit id="7472d33de0e4e4c6d6bc5be3bc64d1117f76ab97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 必须引用在本地节点上运行的进程，否则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="167a28851306fdaf355a0b9d87bd9e06c3264602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - the same as pretty except ASCII characters are used instead of Unicode characters. This is the default on Windows;</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -除了使用ASCII字符代替Unicode字符外，其他均与Pretty相同。这是Windows上的默认设置。</target>
        </trans-unit>
        <trans-unit id="d8a4a973778edbc3b9292682c2961c04afdada51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 可以是字符串，字符串列表或已编译模式。</target>
        </trans-unit>
        <trans-unit id="d7a7b88e7dfa1815defebaaadeadc69b2b64802d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - prints the graph to the terminal using Unicode characters. Each prints each file followed by the files it depends on. This is the default except on Windows;</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; -使用Unicode字符将图形打印到终端。每个都打印每个文件，然后打印它所依赖的文件。这是默认设置，Windows除外。</target>
        </trans-unit>
        <trans-unit id="a5c6719a29e3444d2a98704658b2abe3abc07b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;raw&lt;/code&gt; - a boolean indicating if bin functions should be used</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; -一个布尔值，指示是否应使用bin函数</target>
        </trans-unit>
        <trans-unit id="2413f2dcbac9c52ab69f886cdee3aec797acde03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is exit reason and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 是退出原因， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="3d14f1d74048b142cf9c3c866e8baef03f5f628e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is the exit reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 是退出的原因。</target>
        </trans-unit>
        <trans-unit id="017b38f6c3a63b34a77cb61fad862a0108619da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; is a monitor reference returned by this function;</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 是此函数返回的监视器引用；</target>
        </trans-unit>
        <trans-unit id="f1dac4945e37fa410a22296831615f2618a6f8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and executed on every command to set up environment variables, including ones specific to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 和 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; -复制到每个发行版中并在每个命令上执行以设置环境变量（包括特定于VM的环境变量）的模板文件</target>
        </trans-unit>
        <trans-unit id="c19918b14a9453c91c643c933cd15244538fc1e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - a template file that is copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags</source>
          <target state="translated">&lt;code&gt;rel/vm.args.eex&lt;/code&gt; -复制到每个发行版中的模板文件，并提供Erlang虚拟机的静态配置和其他运行时标志</target>
        </trans-unit>
        <trans-unit id="7f40a3451ab81b3153487e704b02d37b9b6a4ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replies&lt;/code&gt; - is a list of &lt;code&gt;{node, reply}&lt;/code&gt; tuples where &lt;code&gt;node&lt;/code&gt; is the node that replied and &lt;code&gt;reply&lt;/code&gt; is its reply</source>
          <target state="translated">&lt;code&gt;replies&lt;/code&gt; -是 &lt;code&gt;{node, reply}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;node&lt;/code&gt; 是被 &lt;code&gt;reply&lt;/code&gt; 的节点，reply是其答复</target>
        </trans-unit>
        <trans-unit id="1e85e74a7cd5534b5dc26bb806f6e8445febf275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from&lt;/code&gt; is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 是由&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;发送的请求消息， &lt;code&gt;from&lt;/code&gt; 一个2元组，包含调用者的PID和唯一标识该调用的术语， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。</target>
        </trans-unit>
        <trans-unit id="04e74abb0f4cf0d18536a2a96e905cc0f6069b33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 是由&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;发送的请求消息， &lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的当前状态。</target>
        </trans-unit>
        <trans-unit id="93816bb90205c96752dc4b1f4768e5dfd91ffd4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; - the list of required modules</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; 所需模块列表</target>
        </trans-unit>
        <trans-unit id="6c48083bf2c441634af8637cbd181b09103d558d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt; 条款</target>
        </trans-unit>
        <trans-unit id="c088bb2e30718916b5822f6df8045124d80cf2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fafec51a6ba058e17a08730a003c35a45d91a237" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 是参数列表（与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="99d571b4f50dd13d3d5dab2e90c0858010d81600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 是参数列表（与&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; 中&lt;/a&gt;相同）</target>
        </trans-unit>
        <trans-unit id="3bfa723258218ecec6b8ad74fe2b88b2c40ccf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: words in the list are strings (default)</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ：列表中的单词是字符串（默认）</target>
        </trans-unit>
        <trans-unit id="62965b3fa200d2fcdd302a063393661d33658602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2218676f02b43a5d86faf5ba604881574737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serve/1&lt;/code&gt; is another loop that reads a line from the socket and writes those lines back to the socket. Note that the &lt;code&gt;serve/1&lt;/code&gt; function uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;the pipe operator &lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/a&gt; to express this flow of operations. The pipe operator evaluates the left side and passes its result as the first argument to the function on the right side. The example above:</source>
          <target state="translated">&lt;code&gt;serve/1&lt;/code&gt; 是另一个循环，它从套接字读取一行并将这些行写回到套接字。请注意， &lt;code&gt;serve/1&lt;/code&gt; 函数使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;管道运算符 &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;/a&gt;表示此操作流程。管道运算符评估左侧，并将其结果作为第一个参数传递给右侧的函数。上面的例子：</target>
        </trans-unit>
        <trans-unit id="4035242838ff6348de2918394188b203c1cec888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 可以是此模块文档的&amp;ldquo;名称注册&amp;rdquo;部分中描述的任何值。</target>
        </trans-unit>
        <trans-unit id="2bd4d2b94c9ed5de47dab724a819b4256c36fb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks can be defined by a block, by passing an atom naming a one-arity function, or by passing a list of such atoms. Both can opt to receive the current context by specifying it as parameter if defined by a block. Functions used to define a test setup must accept the context as single argument.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;setup_all&lt;/code&gt; 回调可以由一个块定义，可以通过传递一个命名为一元函数的原子，也可以通过传递此类原子的列表来定义。两者都可以通过将当前上下文指定为参数（如果由块定义）来选择接收当前上下文。用于定义测试设置的函数必须接受上下文作为单个参数。</target>
        </trans-unit>
        <trans-unit id="74e50f77430f1a1bdfe5ca63476784209360d3eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; and &lt;code&gt;unsigned&lt;/code&gt; are only used for matching binaries (see below) and are only used for integers.</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 仅用于匹配二进制文件（请参见下文），并且仅用于整数。</target>
        </trans-unit>
        <trans-unit id="cfa5ba00cd0c9fad3ce7a3c8fe2e154e61d87770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - size of file in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; -文件大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="0a4f18566a210c559013bf9a5086044257909566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source_file&lt;/code&gt; and &lt;code&gt;destination_file&lt;/code&gt; must be a file or a symbolic link to one, or in the case of destination, a path to a non-existent file. If either one of them is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;source_file&lt;/code&gt; 和 &lt;code&gt;destination_file&lt;/code&gt; 必须是一个文件或指向一个文件的符号链接，或者如果是Destination，则是一个不存在的文件的路径。如果其中一个是目录，将返回 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38212c1b9d372738da7952d34b2b9942eed99263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt; are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let&amp;rsquo;s see the most common one, called tasks.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 和 &lt;code&gt;spawn_link/1&lt;/code&gt; 是在Elixir中创建进程的基本原语。尽管到目前为止我们仅使用它们，但是大多数时候我们将使用基于它们的抽象。让我们看看最常见的一种，称为任务。</target>
        </trans-unit>
        <trans-unit id="ef8e38976f8ee83eeb6656542cc862dd86ba301d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; takes a function which it will execute in another process.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 具有一个将在另一个进程中执行的功能。</target>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 是在 &lt;code&gt;:mod&lt;/code&gt; 规范密钥（例如， &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ）中传递给应用程序的参数。</target>
        </trans-unit>
        <trans-unit id="fe417925fd6a03a1cadb38a84034165856ff0856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_link/2&lt;/code&gt;, &lt;code&gt;init/2&lt;/code&gt;, and strategies</source>
          <target state="translated">&lt;code&gt;start_link/2&lt;/code&gt; ， &lt;code&gt;init/2&lt;/code&gt; 和策略</target>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 定义如何启动应用程序：</target>
        </trans-unit>
        <trans-unit id="bed6184e7c750cc712f2203171e1d9b7e789646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. If the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt; is present, &lt;code&gt;state&lt;/code&gt; is its return value instead.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 是&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;返回的状态（如果已返回），否则为 &lt;code&gt;[]&lt;/code&gt; 。如果存在可选的回调&lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;state&lt;/code&gt; 为其返回值。</target>
        </trans-unit>
        <trans-unit id="2e6893ab1b754c2ae7dc9f997ecb10ec083f344f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt; - prints general statistics about the graph;</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; -打印有关图形的常规统计信息；</target>
        </trans-unit>
        <trans-unit id="2790d8f945460f49048af9ed95a7afa73085f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer value which is returned by the runtime system to the operating system.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 必须是非负整数值，由运行时系统返回给操作系统。</target>
        </trans-unit>
        <trans-unit id="8c1f069e75f041dd495821b88b772c17da451669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer, the atom &lt;code&gt;:abort&lt;/code&gt; or a binary.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 必须是非负整数，原子 &lt;code&gt;:abort&lt;/code&gt; 或二进制。</target>
        </trans-unit>
        <trans-unit id="d6ac53a1094c979479b6f1b561f3e74f3968e85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; is optional and, if not passed, defaults to &lt;code&gt;count&lt;/code&gt;, i.e. chunks do not overlap.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 是可选的，如果未通过，则默认为 &lt;code&gt;count&lt;/code&gt; ，即块不重叠。</target>
        </trans-unit>
        <trans-unit id="07277647df2178950f06633decd26215f156ae7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;float#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是包含小数点的浮点数的字符串表示形式。为了将不带小数点的字符串解析为浮点数，应使用&lt;a href=&quot;float#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; &lt;/a&gt;。否则，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a57ce393e0bf34dc0ca576de7675a4598947d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;integer#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 必须是整数的字符串表示形式。否则，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。如果要解析可能包含格式错误的整数的字符串，请使用&lt;a href=&quot;integer#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a8f508a843dbaf6b9d5439d982a8903dd2999cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; will be the initial input of the newly created device.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 将是新创建的设备的初始输入。</target>
        </trans-unit>
        <trans-unit id="572985c443231f1ffed373013f737ade9f044914" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suffixes&lt;/code&gt; can be either a single suffix or a list of suffixes.</source>
          <target state="translated">&lt;code&gt;suffixes&lt;/code&gt; 可以是单个后缀，也可以是后缀列表。</target>
        </trans-unit>
        <trans-unit id="bdbf5dd9e7ab5c58f01c1dec17c4fb41c8b81931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是一个大于零的整数，它指定代理执行该功能并返回结果值之前允许的毫秒数，或者原子 &lt;code&gt;:infinity&lt;/code&gt; 无限期等待。如果在指定时间内未收到结果，则函数调用失败，并且调用者退出。</target>
        </trans-unit>
        <trans-unit id="1d95411839d7e41402b228ea7bab4f308778467d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. The default value is &lt;code&gt;5000&lt;/code&gt;. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是一个大于零的整数，它指定等待答复的毫秒数，或者原子 &lt;code&gt;:infinity&lt;/code&gt; 无限期等待。默认值为 &lt;code&gt;5000&lt;/code&gt; 。如果在指定的时间内未收到答复，则函数调用失败，并且调用者退出。如果呼叫者发现了故障并继续运行，并且服务器的回复很晚，则它可能会在以后的任何时间到达呼叫者的消息队列中。在这种情况下，调用者必须为此做好准备，并丢弃所有包含两个元素元组的垃圾消息，并以引用作为第一个元素。</target>
        </trans-unit>
        <trans-unit id="4f68b2a1cb84499ed2c00c6482e49eeac64039aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is either the number of milliseconds to sleep as an integer or the atom &lt;code&gt;:infinity&lt;/code&gt;. When &lt;code&gt;:infinity&lt;/code&gt; is given, the current process will sleep forever, and not consume or reply to messages.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 是以毫秒为单位的整数，也可以是atom &lt;code&gt;:infinity&lt;/code&gt; 。当给出 &lt;code&gt;:infinity&lt;/code&gt; 时，当前进程将永远休眠，并且不会消耗或回复消息。</target>
        </trans-unit>
        <trans-unit id="0d03dca1cbfe2406a67e381ab2870ef2bddd059b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is the timestamp for when the message was logged, as a &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; tuple</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 是记录消息的时间戳，以 &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; 元组记录</target>
        </trans-unit>
        <trans-unit id="08d7a6e449b07af8124dddd49b8a31de7399fb11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - pad the output string to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; -垫输出字符串到8（默认）最接近的倍数</target>
        </trans-unit>
        <trans-unit id="4948e3624434de9113da8f38917d02367479d2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - requires the input string to be padded to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; -要求将输入字符串填充为最接近的8的倍数（默认）</target>
        </trans-unit>
        <trans-unit id="37f317994df4c5094e8b2eff3348d68fdc66f93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5f7234d664879c7a94dbc62ea230645de6ab29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f74a2bb6fb5fbbcf93b8f217f0cc291412b0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; - used as atoms</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; -用作原子</target>
        </trans-unit>
        <trans-unit id="040c2cc20f87605723b2be4cdc0803a474de3d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt; are reserved words that are represented by the atoms &lt;code&gt;:true&lt;/code&gt;, &lt;code&gt;:false&lt;/code&gt; and &lt;code&gt;:nil&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;nil&lt;/code&gt; 是保留字，分别由原子 &lt;code&gt;:true&lt;/code&gt; ， &lt;code&gt;:false&lt;/code&gt; 和 &lt;code&gt;:nil&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="256ad4bcf7e37fd9a26fac8676e48361c0ed6b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt;; the type of the file.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt; ; 文件的类型。</target>
        </trans-unit>
        <trans-unit id="300d31ca0e6078f76938d4d6e305aff178a1dd44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt; as defined in the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:supervisor&lt;/code&gt; ，在子规范中定义</target>
        </trans-unit>
        <trans-unit id="1b592d0e2922f716b9d2f7ecf2cb31932d6201bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt;, as specified by the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 或 &lt;code&gt;:supervisor&lt;/code&gt; ，由子规范指定</target>
        </trans-unit>
        <trans-unit id="c53830ff73ee4bc1cf4e63694e58c8a37efe371d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; -指示文件的所有者。对于非Unix文件系统，该值为零。</target>
        </trans-unit>
        <trans-unit id="11d146eb39b484665d14fa72a8f2163b4c09bdef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ungreedy&lt;/code&gt; (U) - inverts the &quot;greediness&quot; of the regexp (the previous &lt;code&gt;r&lt;/code&gt; option is deprecated in favor of &lt;code&gt;U&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ungreedy&lt;/code&gt; （U）-反转正则表达式的&amp;ldquo;贪婪性&amp;rdquo;（不推荐使用以前的 &lt;code&gt;r&lt;/code&gt; 选项，而推荐使用 &lt;code&gt;U&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="2b1493a8644a9f711c2b660f18b2fd58dc57c6be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and change modifiers like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and friends to also match on Unicode. It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; （u）-使Unicode特定模式（例如 &lt;code&gt;\p&lt;/code&gt; 和更改修饰符（例如 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 和朋友）也可以在Unicode上匹配。它期望在匹配时给出有效的Unicode字符串</target>
        </trans-unit>
        <trans-unit id="3e21f4d0f150e8661e7894e55a7889cd5ea7c932" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unquote&lt;/code&gt; can even be used to inject function names:</source>
          <target state="translated">&lt;code&gt;unquote&lt;/code&gt; 甚至可以用来注入函数名称：</target>
        </trans-unit>
        <trans-unit id="b17f1b91056678deff5c7f31333a1d38b43965f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; （默认）</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 是要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值</target>
        </trans-unit>
        <trans-unit id="be70aa90b34d9b75607b8ad2c0d7e7068392c466" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Agent&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Agent&lt;/code&gt; 还接受用于配置子级规范的选项列表，并因此配置其在管理程序下的运行方式。可以使用以下选项来自定义生成的&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d929111db564f10be37ff4f2d784720755bf5dc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; defines a default implementation of this function which does nothing and just returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 定义了此函数的默认实现，该实现不执行任何操作，仅返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 没有为&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调提供默认实现。</target>
        </trans-unit>
        <trans-unit id="8a3cd0a6ee94294da88b60ba9da6b647450af00b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use ExUnit.Case&lt;/code&gt; is responsible for setting up our module for testing and imports many test-related functionality, such as the &lt;code&gt;test/2&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 负责设置我们的测试模块，并导入许多与测试相关的功能，例如 &lt;code&gt;test/2&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="0384590b7214948d657738c3d5bfaf0a2cce9c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use GenServer&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;code&gt;child_spec/1&lt;/code&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use GenServer&lt;/code&gt; 还接受用于配置子级规范的选项列表，并因此配置其在管理程序下的运行方式。可以使用以下选项来自定义生成的 &lt;code&gt;child_spec/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="19aacd0bb192aebbc1eaab7675d05f8b371c3c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Supervisor&lt;/code&gt; also defines a &lt;code&gt;child_spec/1&lt;/code&gt; function which allows us to run &lt;code&gt;MyApp.Supervisor&lt;/code&gt; as a child of another supervisor or at the top of your supervision tree as:</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 还定义了 &lt;code&gt;child_spec/1&lt;/code&gt; 函数，该函数使我们可以将 &lt;code&gt;MyApp.Supervisor&lt;/code&gt; 作为其他主管的孩子或在您的主管树的顶部运行：</target>
        </trans-unit>
        <trans-unit id="32f3cdd98eaec66584c149fc480cbffd83f3560c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Task&lt;/code&gt; defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, allowing the defined module to be put under a supervision tree. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Task&lt;/code&gt; 定义了&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;函数，允许将定义的模块放在监视树下。可以使用以下选项来自定义生成的&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9001f343f267d4f2ca6c3f31d0f08dd106421221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; - a list keeping all defined variables as &lt;code&gt;{var, context}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; -将所有定义的变量保留为 &lt;code&gt;{var, context}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f4537522a5331ce77a3c7353321177c38c05b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; - used as operators</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; -作为运营商</target>
        </trans-unit>
        <trans-unit id="a2513b6e343efdb3f9d26eeabec520aa38f1a707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 将导致&lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="2f10cb46a7888b0c5592ef3405b96b453cace5d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; - exit signals in case the port crashes. If reason is not &lt;code&gt;:normal&lt;/code&gt;, this message will only be received if the owner process is trapping exits</source>
          <target state="translated">&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; -如果端口崩溃，则退出信号。如果原因不是 &lt;code&gt;:normal&lt;/code&gt; ，则仅当所有者进程正在捕获出口时才会收到此消息</target>
        </trans-unit>
        <trans-unit id="9a4a7ed7743b808212846bc29e7788b55113c253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:cont, acc}&lt;/code&gt; to continue the reduction with &lt;code&gt;acc&lt;/code&gt; as the new accumulator or</source>
          <target state="translated">&lt;code&gt;{:cont, acc}&lt;/code&gt; 继续使用 &lt;code&gt;acc&lt;/code&gt; 作为新累加器进行折减，或者</target>
        </trans-unit>
        <trans-unit id="d680d1ab4f34debbf293fabb4c907ec127e5d9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - other (rare) error condition; for instance, &lt;code&gt;{:error, :estale}&lt;/code&gt; if reading from an NFS volume</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -其他（罕见）错误情况；例如，如果从NFS卷读取，则 &lt;code&gt;{:error, :estale}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="583a02e135d23d6e385e3fd6dec1ef2ebace7264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - the file could not be opened.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -无法打开文件。</target>
        </trans-unit>
        <trans-unit id="4b6d8de35ac50e9117049f505f7b0ce980f3a49c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, rest}&lt;/code&gt; - there are no switches at the head of the given &lt;code&gt;argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:error, rest}&lt;/code&gt; -给定 &lt;code&gt;argv&lt;/code&gt; 的开头没有开关</target>
        </trans-unit>
        <trans-unit id="905947e36e510a423fa76acaab54776f74a95e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has died</source>
          <target state="translated">&lt;code&gt;{:exit, reason}&lt;/code&gt; 如果任务已终止</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; -如果由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而将应用程序分发并在当前节点上启动，并且应用程序规范键 &lt;code&gt;:start_phases&lt;/code&gt; 不是 &lt;code&gt;:undefined&lt;/code&gt; 时使用。</target>
        </trans-unit>
        <trans-unit id="6493ada3691c289f4563082f5504570c40c851bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; - accesses file descriptors, &lt;code&gt;fd_in&lt;/code&gt; and &lt;code&gt;fd_out&lt;/code&gt; opened by the VM.</source>
          <target state="translated">&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; -访问由VM打开的文件描述符 &lt;code&gt;fd_in&lt;/code&gt; 和 &lt;code&gt;fd_out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14377d50e215463748eff219d9c02d214d948fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; - the GenServer is registered globally with the given term using the functions in the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; -GenServer使用&lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 模块中&lt;/a&gt;的功能在给定的术语下全局注册。</target>
        </trans-unit>
        <trans-unit id="53c120865859b22092af466d2b931e7ac0b771c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; if the server is globally registered</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; 如果服务器已全局注册）</target>
        </trans-unit>
        <trans-unit id="ef45711b970d4f5ebbd374f8b94ce469f1caf938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:halt, acc}&lt;/code&gt; to halt the reduction</source>
          <target state="translated">&lt;code&gt;{:halt, acc}&lt;/code&gt; 停止减少</target>
        </trans-unit>
        <trans-unit id="df2e65d7200b3a773f87421feb6af3b00afa9729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is invalid with &lt;code&gt;value&lt;/code&gt; (returned when the value cannot be parsed according to the switch type)</source>
          <target state="translated">&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; -选项 &lt;code&gt;key&lt;/code&gt; 对 &lt;code&gt;value&lt;/code&gt; 无效（当无法根据开关类型解析值时返回）</target>
        </trans-unit>
        <trans-unit id="70b5edb9ec5c74f3f67332fddbfa4c82e88ce245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; - if the message translation with its metadata</source>
          <target state="translated">&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; -如果消息翻译有其元数据</target>
        </trans-unit>
        <trans-unit id="996ab638f8c8d4d802e499bedf1f4770ab7fbb80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata}&lt;/code&gt; - the translated message</source>
          <target state="translated">&lt;code&gt;{:ok, chardata}&lt;/code&gt; -翻译后的消息</target>
        </trans-unit>
        <trans-unit id="e3a6f52fcc50382042712f66d3261d0c08067f8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, io_device}&lt;/code&gt; - the file has been opened in the requested mode.</source>
          <target state="translated">&lt;code&gt;{:ok, io_device}&lt;/code&gt; -文件已以请求的模式打开。</target>
        </trans-unit>
        <trans-unit id="a0b6d7c9a83237db145690056b0e8a37a74e66c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; was successfully parsed</source>
          <target state="translated">&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - 具有 &lt;code&gt;value&lt;/code&gt; 的选项 &lt;code&gt;key&lt;/code&gt; 已成功解析</target>
        </trans-unit>
        <trans-unit id="7268c1f7f90baff55c1875a554395341ede463ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, term}&lt;/code&gt; if the task has successfully reported its result back in the given time interval</source>
          <target state="translated">&lt;code&gt;{:ok, term}&lt;/code&gt; 如果任务已在给定的时间间隔内成功报告了其结果</target>
        </trans-unit>
        <trans-unit id="15f17eecf5beefa66ca856a267346c5b572581dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn, command}&lt;/code&gt; - runs an external program. &lt;code&gt;command&lt;/code&gt; must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option.</source>
          <target state="translated">&lt;code&gt;{:spawn, command}&lt;/code&gt; -运行一个外部程序。 &lt;code&gt;command&lt;/code&gt; 必须包含程序名称以及（可选）由空格分隔的参数列表。如果传递名称中带有空格的程序或参数，请使用下一个选项。</target>
        </trans-unit>
        <trans-unit id="d6ebca30f0cc1777601d5fcf5ac5189ec02cece8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; - spawns so-called port drivers.</source>
          <target state="translated">&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; -产生所谓的端口驱动程序。</target>
        </trans-unit>
        <trans-unit id="66e3057e6196a07aafd175143d071fd417be195c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; - runs the executable given by the absolute file name &lt;code&gt;filename&lt;/code&gt;. Arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; -运行绝对文件名 &lt;code&gt;filename&lt;/code&gt; 给出的可执行文件。可以通过 &lt;code&gt;:args&lt;/code&gt; 选项传递参数。</target>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -如果应用程序是分布式的，并且由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而在当前节点上启动，则使用它。</target>
        </trans-unit>
        <trans-unit id="c26b97b81c2506b473edb7172c2f617dcec5b26d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms)</source>
          <target state="translated">&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; -选项 &lt;code&gt;key&lt;/code&gt; 是不确定的（当开关未知或原子不存在时，以严格模式返回）</target>
        </trans-unit>
        <trans-unit id="85bdb5005d451e7a63cf262238f500974e283030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, name}&lt;/code&gt; if the server is registered through an alternative registry</source>
          <target state="translated">&lt;code&gt;{:via, module, name}&lt;/code&gt; 如果通过备用注册表注册了服务器）</target>
        </trans-unit>
        <trans-unit id="8b29339dcb62621d0d8075c996c9fab09ff31622" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer已使用给定的机制和名称进行注册。的 &lt;code&gt;:via&lt;/code&gt; 选项期望的模块，出口 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; 和&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt;。一个这样的例子是&lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 模块&lt;/a&gt;，它使用这些功能来保存进程名称及其关联的PID的列表，这些列表可全局用于Elixir节点的网络。Elixir还附带了一个名为&lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt;的本地，分散和可扩展的注册表，用于本地存储动态生成的名称。</target>
        </trans-unit>
        <trans-unit id="cc2c818f59492934d15abff13439c0782289f3e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c6157992132973e0f3d822fb7bbb7d409431fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; is a tuple containing information about the logged message:</source>
          <target state="translated">&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; 是一个元组，其中包含有关所记录消息的信息：</target>
        </trans-unit>
        <trans-unit id="db1f5193dbaaf9fec82f82738b42e72b2810c7d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{atom, node}&lt;/code&gt; if the server is locally registered at another node</source>
          <target state="translated">&lt;code&gt;{atom, node}&lt;/code&gt; 如果服务器在另一节点本地注册）</target>
        </trans-unit>
        <trans-unit id="2d5e8a342d00497e80fb0e1378891350b6989d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{item1,item2,...}&lt;/code&gt; - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;{item1,item2,...}&lt;/code&gt; -匹配替代项之一。请勿在逗号前后添加空格，否则会匹配包含空格字符本身的路径。</target>
        </trans-unit>
        <trans-unit id="ac157d52ecf1d75482d9d1aeecc889281122e50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, :close}&lt;/code&gt; - closes the port. Unless the port is already closed, the port will reply with &lt;code&gt;{port, :closed}&lt;/code&gt; message once it has flushed its buffers and effectively closed. See &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, :close}&lt;/code&gt; -关闭端口。除非端口已经关闭，否则端口将在刷新缓冲区并有效关闭后以 &lt;code&gt;{port, :closed}&lt;/code&gt; 消息进行回复。参见&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a895632430cc7c653dfc0e0b7e07abf543b5e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; - sends the given data to the port. See &lt;a href=&quot;#command/3&quot;&gt;&lt;code&gt;command/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; -将给定的数据发送到端口。参见&lt;a href=&quot;#command/3&quot;&gt; &lt;code&gt;command/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288f6592e3c497e594f8671f3ea30d712d05da67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - sets the &lt;code&gt;new_pid&lt;/code&gt; as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes &lt;code&gt;new_pid&lt;/code&gt; the new connected processes. Unless the port is dead, the port will reply to the old owner with &lt;code&gt;{port, :connected}&lt;/code&gt;. See &lt;a href=&quot;#connect/2&quot;&gt;&lt;code&gt;connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; -将 &lt;code&gt;new_pid&lt;/code&gt; 设置为端口的新所有者。打开端口后，该端口将链接并连接到呼叫者进程，并且仅通过连接的进程与该端口进行通信。此消息使 &lt;code&gt;new_pid&lt;/code&gt; 成为新连接的进程。除非端口失效，否则端口将通过 &lt;code&gt;{port, :connected}&lt;/code&gt; 回复旧所有者。参见&lt;a href=&quot;#connect/2&quot;&gt; &lt;code&gt;connect/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e874c9f986bcbc4835de87b79c60801c982748f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :closed}&lt;/code&gt; - reply to the &lt;code&gt;{pid, :close}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :closed}&lt;/code&gt; -回复 &lt;code&gt;{pid, :close}&lt;/code&gt; 消息</target>
        </trans-unit>
        <trans-unit id="fa93e43d244395859c46aade03423cd222f87032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :connected}&lt;/code&gt; - reply to the &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :connected}&lt;/code&gt; -回复 &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; 消息</target>
        </trans-unit>
        <trans-unit id="efc9c7697827d4669aad3228ed4c07741bb10c50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, {:data, data}}&lt;/code&gt; - data sent by the port</source>
          <target state="translated">&lt;code&gt;{port, {:data, data}}&lt;/code&gt; -端口发送的数据</target>
        </trans-unit>
        <trans-unit id="8331cbf97282804d067bb29ba8bd9b7caf6144bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a1fc7b83a3791c9f16933b021a993fc251a976d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c515caea553b7a18b81d363c568a315a5150f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="036d3dd0689aaa1e1f2cd3395422e4acf8dcaf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&amp;gt;&lt;/code&gt; will never include pre-release versions of its upper bound, regardless of the usage of the &lt;code&gt;:allow_pre&lt;/code&gt; option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for &lt;code&gt;~&amp;gt;&lt;/code&gt; requirements and their corresponding translations.</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; 永远不会包含其上限的预发行版本，无论 &lt;code&gt;:allow_pre&lt;/code&gt; 选项的用法如何，还是操作数是否为预发行版本。它也可以用于仅在主要版本部分上设置上限。请参阅下表以了解 &lt;code&gt;~&amp;gt;&lt;/code&gt; 要求及其相应的翻译。</target>
        </trans-unit>
        <trans-unit id="d3a808d1b26854bfff9e3a0b3845ea1a05448e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09579eaf4feb9e28fce9fc17746e4ff55890bca0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;None&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;None&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d79e4e6ea4fe26e44ae09fe2933d731631027ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: unlike &lt;code&gt;@after_compile&lt;/code&gt;, the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist).</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：与 &lt;code&gt;@after_compile&lt;/code&gt; 不同，回调函数/宏必须放在单独的模块中（因为调用回调时，当前模块尚不存在）。</target>
        </trans-unit>
        <trans-unit id="4f08c9a12c9ca68459deea27c07cfa5cbf312698" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The leading underscore in &lt;code&gt;_sep&lt;/code&gt; means that the variable will be ignored in this function; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;_sep&lt;/code&gt; 中的下划线表示该函数将忽略该变量；请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;命名约定&lt;/a&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d76d0c90116afc56a7d7c36ee9aa1c61ab7189e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The trailing question mark in &lt;code&gt;zero?&lt;/code&gt; means that this function returns a boolean; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;尾随问号 &lt;code&gt;zero?&lt;/code&gt; 表示此函数返回一个布尔值；请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;命名约定&lt;/a&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64b3259a23cbcee4b6f5269de5bf892f183bee1a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API Reference</source>
          <target state="translated">&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API参考</target>
        </trans-unit>
        <trans-unit id="f3775fefac93bd98a436d0d00b0aab5a204bb7bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a test-unit based framework that ships with Elixir;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;是Elixir附带的基于测试单元的框架；</target>
        </trans-unit>
        <trans-unit id="79fc31f88ea6f7006047293577c94843734d6c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;是Elixir随附的构建工具，它提供创建，编译，测试应用程序，管理依赖项等任务。</target>
        </trans-unit>
        <trans-unit id="7760e740159ba1e4a18006d398566be346370d1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;(Open Telecom Platform)&lt;/em&gt; is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;（开放电信平台）&lt;/em&gt;是Erlang附带的一组库。Erlang开发人员使用OTP来构建强大的容错应用程序。在本章中，我们将探讨OTP与Elixir集成的方面，包括监督树，事件管理器等等。</target>
        </trans-unit>
        <trans-unit id="45bdb2bd826dc57156f3bf24a36a9c22bb6b679a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our &lt;a href=&quot;library-guidelines&quot;&gt;library guidelines&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;重要提示：&lt;/strong&gt;如果要编写供其他开发人员使用的库，通常建议避免使用应用程序环境，因为该应用程序环境实际上是全局存储。有关更多信息，请阅读我们的&lt;a href=&quot;library-guidelines&quot;&gt;磁带库指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cebf98b4bce979e6d8b77444f797642d0aeb4c22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: in Elixir, you don&amp;rsquo;t have to define the &lt;code&gt;Foo&lt;/code&gt; module before being able to define the &lt;code&gt;Foo.Bar&lt;/code&gt; module, as the language translates all module names to atoms. You can define arbitrarily-nested modules without defining any module in the chain (e.g., &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; without defining &lt;code&gt;Foo&lt;/code&gt; or &lt;code&gt;Foo.Bar&lt;/code&gt; first).</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在Elixir中，无需定义 &lt;code&gt;Foo&lt;/code&gt; 模块即可定义 &lt;code&gt;Foo.Bar&lt;/code&gt; 模块，因为该语言会将所有模块名称转换为atom。您可以定义任意嵌套的模块，而无需定义链中的任何模块（例如， &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; ,而无需先定义 &lt;code&gt;Foo&lt;/code&gt; 或 &lt;code&gt;Foo.Bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4830045d3f9fb785bdafea364ad01a0303638b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this function must be used only for debugging purposes.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此功能只能用于调试目的。</target>
        </trans-unit>
        <trans-unit id="f5c1f94fbf601c6ec501544925ca954903163e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this function with extreme care&lt;/strong&gt;. For almost all situations where you would use &lt;a href=&quot;#sleep/1&quot;&gt;&lt;code&gt;sleep/1&lt;/code&gt;&lt;/a&gt; in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing.</source>
          <target state="translated">&lt;strong&gt;请格外小心地使用此功能&lt;/strong&gt;。对于几乎所有在Elixir中使用&lt;a href=&quot;#sleep/1&quot;&gt; &lt;code&gt;sleep/1&lt;/code&gt; 的&lt;/a&gt;情况，都可能有更正确，更快和更精确的方式来通过消息传递实现相同的目的。</target>
        </trans-unit>
        <trans-unit id="6d8fa24c5f50dfc16b2c10bf309baf5a47726342" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;file#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;每次调用此函数时，都会打开文件描述符，并产生一个新进程来写入文件。因此，如果您要在循环中进行多次写入，则通过&lt;a href=&quot;file#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt;打开文件并使用&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 中&lt;/a&gt;的函数写入文件将比多次调用此函数产生更好的性能。</target>
        </trans-unit>
        <trans-unit id="365ce4331359866dc083be4a975f43b82fadac5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#compile_string/2&quot;&gt;&lt;code&gt;compile_string/2&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;string&lt;/code&gt; 可以是任何Elixir代码，并且可以与Erlang VM相同的特权执行代码：这意味着此类代码可能会危害计算机（例如，通过执行系统命令）。不要将&lt;a href=&quot;#compile_string/2&quot;&gt; &lt;code&gt;compile_string/2&lt;/code&gt; &lt;/a&gt;与不受信任的输入（例如来自网络的字符串）一起使用。</target>
        </trans-unit>
        <trans-unit id="9a9945569acc699104fbc382a7f6902cdbb849ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;string&lt;/code&gt; 可以是任何Elixir代码，并且将以与Erlang VM相同的特权执行：这意味着此类代码可能会危害计算机（例如，通过执行系统命令）。不要将&lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt;与不受信任的输入（例如来自网络的字符串）一起使用。</target>
        </trans-unit>
        <trans-unit id="2875bd2bb7c9486ad98cafa18ea844a4e68bfa0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：在宏内调用此函数被认为是不好的做法，因为它将尝试在编译时评估运行时值。宏参数通常通过将其取消引用到返回的带引号的表达式中（而不是被评估的）来转换。</target>
        </trans-unit>
        <trans-unit id="993e7a2f2e8a8af096a402bf2629008a4fb49467" translate="yes" xml:space="preserve">
          <source>= (2)</source>
          <target state="translated">=（2）</target>
        </trans-unit>
        <trans-unit id="070f4bb5062b181b2dab5baebd4e926e8227b544" translate="yes" xml:space="preserve">
          <source>== (2)</source>
          <target state="translated">==（2）</target>
        </trans-unit>
        <trans-unit id="80782192fde18010086342ec452afa4a2968c387" translate="yes" xml:space="preserve">
          <source>=== (2)</source>
          <target state="translated">===（2）</target>
        </trans-unit>
        <trans-unit id="7d042330e275b9df07c1b99a60576379d66570eb" translate="yes" xml:space="preserve">
          <source>=~ (2)</source>
          <target state="translated">=〜（2）</target>
        </trans-unit>
        <trans-unit id="3ac5ef8377daeb708c25b635e6c467ff0bfcb4e4" translate="yes" xml:space="preserve">
          <source>@expr</source>
          <target state="translated">@expr</target>
        </trans-unit>
        <trans-unit id="3fb5c30970be466c24df6f91f050369f404a45eb" translate="yes" xml:space="preserve">
          <source>@expr (1)</source>
          <target state="translated">@expr（1）</target>
        </trans-unit>
        <trans-unit id="212381917bbc6314dd3515bae3faeae224b2edde" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use GenServer&lt;/code&gt;, it automatically defines a &lt;code&gt;child_spec/1&lt;/code&gt; function that allows us to start the &lt;code&gt;Stack&lt;/code&gt; directly under a supervisor. To start a default stack of &lt;code&gt;[:hello]&lt;/code&gt; under a supervisor, one may do:</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;被监督树底下最常见的开始。当我们 &lt;code&gt;use GenServer&lt;/code&gt; 调用时，它会自动定义 &lt;code&gt;child_spec/1&lt;/code&gt; 函数，该函数使我们可以直接在管理程序下启动 &lt;code&gt;Stack&lt;/code&gt; 。要在主管下启动默认的 &lt;code&gt;[:hello]&lt;/code&gt; 堆栈，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b04250c280e3b81f91e1d5dd337c0df8de26b240" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is represented internally using the &lt;code&gt;%MapSet{}&lt;/code&gt; struct. This struct can be used whenever there's a need to pattern match on something being a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;使用内部表示 &lt;code&gt;%MapSet{}&lt;/code&gt; 结构。每当需要在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;上进行模式匹配时，都可以使用此结构：</target>
        </trans-unit>
        <trans-unit id="96991deff4ed5a082a254d0673af19964e04b750" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; 的&lt;/a&gt; IO设备可以作为&amp;ldquo;设备&amp;rdquo;到在大部分功能被传递&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="11c30e3595630fd2ed85f755977f5e0806af282c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">甲&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt;被绑定到相同的名称注册规则作为&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中了解有关它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="04a844239e65727f5eb23023aa50bf8c3c86fe4c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;task#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;结构返回一个包含相关信息。开发人员必须最终调用&lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;task#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt;，然后&lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;上返回的任务。</target>
        </trans-unit>
        <trans-unit id="6b893cfed0032b8cee12fcb9d4b611446984d618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:name&lt;/code&gt; option could also be given to &lt;code&gt;Agent.start_link/2&lt;/code&gt; and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called &lt;code&gt;GenServer&lt;/code&gt;), tasks, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt; which will build a complete Elixir application from start to finish.</source>
          <target state="translated">也可以将 &lt;code&gt;:name&lt;/code&gt; 选项提供给 &lt;code&gt;Agent.start_link/2&lt;/code&gt; 并将其自动注册。除代理程序外，Elixir还提供了一个API，用于构建通用服务器（称为 &lt;code&gt;GenServer&lt;/code&gt; ），任务等，所有这些均由下面的进程提供支持。这些以及监督树将在&lt;strong&gt;&lt;em&gt;Mix and OTP指南中&lt;/em&gt;&lt;/strong&gt;进行更详细的探讨，该&lt;strong&gt;&lt;em&gt;指南&lt;/em&gt;&lt;/strong&gt;将从头到尾构建一个完整的Elixir应用程序。</target>
        </trans-unit>
        <trans-unit id="e18a4ffc55e5c9028c4e176af5316103f1339b8d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;post_config&lt;/code&gt; can be passed that will be merged into the project configuration.</source>
          <target state="translated">一个 &lt;code&gt;post_config&lt;/code&gt; 可以通过将被合并到项目配置。</target>
        </trans-unit>
        <trans-unit id="953f85d383aa733b4232421e096ff53630a36ae0" translate="yes" xml:space="preserve">
          <source>A Date struct and functions.</source>
          <target state="translated">一个Date结构和功能。</target>
        </trans-unit>
        <trans-unit id="41bff3f5550cc14457144dffbdae442d3deffbd2" translate="yes" xml:space="preserve">
          <source>A GUI should pop-up containing all sorts of information about our system, from general statistics to load charts as well as a list of all running processes and applications.</source>
          <target state="translated">一个GUI应该弹出,包含所有关于我们系统的信息,从一般的统计数据到加载图表,以及所有正在运行的进程和应用程序的列表。</target>
        </trans-unit>
        <trans-unit id="ce30e5498af53503d24e931e06501bf314a92d8d" translate="yes" xml:space="preserve">
          <source>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</source>
          <target state="translated">GenServer和其他Elixir进程一样是一个进程,它可以用来保持状态,异步执行代码等。使用本模块实现的通用服务器进程(GenServer)的优势在于,它将拥有一套标准的接口函数,并包含跟踪和错误报告的功能。它也将适合于监督树。</target>
        </trans-unit>
        <trans-unit id="e1d021610e2e2d5fff8dcc8068b986d35f87da19" translate="yes" xml:space="preserve">
          <source>A GenServer is a process that invokes a limited set of functions under specific conditions. When we used an &lt;code&gt;Agent&lt;/code&gt;, we would keep both the client code and the server code side by side, like this:</source>
          <target state="translated">GenServer是在特定条件下调用一组有限功能的过程。当使用 &lt;code&gt;Agent&lt;/code&gt; 时，我们将同时保留客户端代码和服务器代码，如下所示：</target>
        </trans-unit>
        <trans-unit id="fa09e34f4344d6d1e3072b5dbac5303f17145bcc" translate="yes" xml:space="preserve">
          <source>A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we&amp;rsquo;ll use a single module for both the server callbacks and the client API.</source>
          <target state="translated">GenServer分两部分实现：客户端API和服务器回调。您可以将这两个部分组合成一个模块，也可以将它们分为客户端模块和服务器模块。客户端是调用客户端功能的任何进程。服务器始终是我们将作为参数显式传递给客户端API的进程标识符或进程名称。在这里，我们将对服务器回调和客户端API使用一个模块。</target>
        </trans-unit>
        <trans-unit id="2c3564c401d9bcae5f982375952ba5b0f96579bf" translate="yes" xml:space="preserve">
          <source>A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes.</source>
          <target state="translated">一个GenServer,或一般的进程,必须用来模拟你的系统的运行时特性。GenServer决不能用于代码组织的目的。</target>
        </trans-unit>
        <trans-unit id="4c204de36640465711bc67da137f234cf9e4f98d" translate="yes" xml:space="preserve">
          <source>A Mix project is defined by calling &lt;code&gt;use Mix.Project&lt;/code&gt; in a module, usually placed in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">通过在模块中调用 &lt;code&gt;use Mix.Project&lt;/code&gt; 来定义Mix项目，通常将其放置在 &lt;code&gt;mix.exs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="4077ad8fe6f71eae596391489d6e96f0ea24015b" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module starting with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and defining the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">只需在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; s开头&lt;/a&gt;的模块中使用Mix.Task即可定义Mix任务 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 并定义&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="ed54926907bf0ba78a3375ef0d22019252f3389e" translate="yes" xml:space="preserve">
          <source>A NaiveDateTime struct (without a time zone) and functions.</source>
          <target state="translated">一个NaiveDateTime结构(没有时区)和函数。</target>
        </trans-unit>
        <trans-unit id="555fb6c5e065889ab4dcadeaa574e32486d7fb5d" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind it is not guaranteed two regular expressions from the same source are equal, for example:</source>
          <target state="translated">正则表达式在内部表示为正则&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;结构。因此，只要需要匹配，就可以使用 &lt;code&gt;%Regex{}&lt;/code&gt; 。请记住，不能保证来自同一源的两个正则表达式相等，例如：</target>
        </trans-unit>
        <trans-unit id="2afaaf5f34eb9535b346406765e25f28777ebcbf" translate="yes" xml:space="preserve">
          <source>A String in Elixir is a UTF-8 encoded binary.</source>
          <target state="translated">Elixir中的字符串是一个UTF-8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="1d40f8897ae8fea751dfe1a3787ebde9eaf60e69" translate="yes" xml:space="preserve">
          <source>A TCP server, in broad strokes, performs the following steps:</source>
          <target state="translated">一个TCP服务器,大体上要执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="9b4c21dfcd9b32e19a4da6bba2ed1b078799abfe" translate="yes" xml:space="preserve">
          <source>A Time struct and functions.</source>
          <target state="translated">A 时间结构和功能。</target>
        </trans-unit>
        <trans-unit id="8ed92df07fe6e75daa797531db7710c5a365538d" translate="yes" xml:space="preserve">
          <source>A UTF-8 code point. It may be one or more bytes.</source>
          <target state="translated">一个UTF-8码点。它可以是一个或多个字节。</target>
        </trans-unit>
        <trans-unit id="d4551e142fcb8c6dfcab6f6c771c1757c5d408c6" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded binary.</source>
          <target state="translated">一个UTF-8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="c6baac594934e18050d15b336369478a962b486d" translate="yes" xml:space="preserve">
          <source>A basic setup for ExUnit is shown below:</source>
          <target state="translated">ExUnit的基本设置如下所示。</target>
        </trans-unit>
        <trans-unit id="d872a4d789410051d4047736ebac85378931dcb1" translate="yes" xml:space="preserve">
          <source>A beginning is inclusive. An ending is exclusive. Eg. if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00, the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00.</source>
          <target state="translated">开始是包容的。结尾是包含性的。例如:如果一个时期是从2015-03-29 01:00:00开始到2015-10-25 01:00:00为止,那么这个时期包括并从2015-03-29 01:00:00开始到2015-10-25 01:00:00之前。</target>
        </trans-unit>
        <trans-unit id="4b46e9949a74e5098958730c1a927a02cf0e1c74" translate="yes" xml:space="preserve">
          <source>A beginning or end for certain periods are infinite. For instance the latest period for time zones without DST or plans to change. However for the purpose of this behaviour they are only used for gaps in wall time where the needed period limits are at a certain time.</source>
          <target state="translated">某些时期的开始或结束是无限的。例如,对于没有DST或计划改变的时区,最新的时期。然而,为了这种行为的目的,它们只用于所需的时期限制在某一时间的墙时间的间隙。</target>
        </trans-unit>
        <trans-unit id="eb34fc850ae56e44c450bb71c054995b2321814e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">行为模块定义了一组函数和宏（称为&lt;em&gt;回调&lt;/em&gt;），实现该行为的回调模块必须将其导出。该&amp;ldquo;接口&amp;rdquo;标识组件的特定部分。例如，&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 的&lt;/a&gt;行为和功能从特定的部分（例如该服务器进程必须执行的动作）中抽象出&amp;ldquo;服务器&amp;rdquo;进程可能希望实现的所有消息传递（发送和接收）和错误报告。</target>
        </trans-unit>
        <trans-unit id="7c9e867bc2a6fb80d40eab6dcf2caa49046c25ae" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing supervisors.</source>
          <target state="translated">实施监督员的行为模块。</target>
        </trans-unit>
        <trans-unit id="605d4ad9d9fdab9c7d0d8facad9343748a300de2" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing the server of a client-server relation.</source>
          <target state="translated">一个行为模块,用于实现客户与服务器关系的服务器。</target>
        </trans-unit>
        <trans-unit id="00f8ebc260124e1ab7b63ede984d78166228dd40" translate="yes" xml:space="preserve">
          <source>A better function definition would be:</source>
          <target state="translated">更好的职能定义是:</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">一个二进制总是包含一个完整的字节数。</target>
        </trans-unit>
        <trans-unit id="d08e886402089500f760cd62e9be33847d11368c" translate="yes" xml:space="preserve">
          <source>A binary is a sequence of bytes. Those bytes can be organized in any way, even in a sequence that does not make them a valid string:</source>
          <target state="translated">二进制是一个字节的序列。这些字节可以以任何方式组织起来,即使是一个不能使其成为有效字符串的序列。</target>
        </trans-unit>
        <trans-unit id="6f4b7277d1938d9dc02215252a72af388262f382" translate="yes" xml:space="preserve">
          <source>A bitstring generator can be mixed with &amp;ldquo;regular&amp;rdquo; enumerable generators, and supports filters as well.</source>
          <target state="translated">比特串生成器可以与&amp;ldquo;常规&amp;rdquo;可枚举生成器混合使用，并且还支持过滤器。</target>
        </trans-unit>
        <trans-unit id="18fa63ca56fa56c911a7c87acd788299f0b5e786" translate="yes" xml:space="preserve">
          <source>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</source>
          <target state="translated">一个比特串是由许多段组成的,每个段有一个类型。比特串中使用的类型有9种。</target>
        </trans-unit>
        <trans-unit id="ea8cc225102a641a743fb78156d8a9bef53771d8" translate="yes" xml:space="preserve">
          <source>A byte of Erlang</source>
          <target state="translated">埃尔兰的一个字节</target>
        </trans-unit>
        <trans-unit id="79fd446d748480ae656763877da9c4cf859f5647" translate="yes" xml:space="preserve">
          <source>A calendar implementation</source>
          <target state="translated">执行日历</target>
        </trans-unit>
        <trans-unit id="45adc33f9e352c348aeb6f71e9cae2cc39cef184" translate="yes" xml:space="preserve">
          <source>A calendar implementation that follows to ISO 8601.</source>
          <target state="translated">遵循ISO 8601的日历实施。</target>
        </trans-unit>
        <trans-unit id="4983d0390c0cc88fb62df8a53e3ded20887e73ee" translate="yes" xml:space="preserve">
          <source>A charlist is nothing more than a list of code points. Char lists may be created with single-quoted literals:</source>
          <target state="translated">charlist不过是一个代码点的列表。Char list可以用单引号创建。</target>
        </trans-unit>
        <trans-unit id="e14e2847d8fdb35b747294036ae2ad35a22ccd61" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to a string to see its inner binary representation:</source>
          <target state="translated">Elixir中的一个常见技巧是将空字节 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 到字符串以查看其内部二进制表示形式：</target>
        </trans-unit>
        <trans-unit id="1bfb26f32033c8d890b9980e9f88f657ab247fd3" translate="yes" xml:space="preserve">
          <source>A common use case of &lt;code&gt;:into&lt;/code&gt; can be transforming values in a map, without touching the keys:</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 的常见用例可以是在不触摸键的情况下转换映射中的值：</target>
        </trans-unit>
        <trans-unit id="27f0ae652ebbfbd5531320563e778f58becfe7bb" translate="yes" xml:space="preserve">
          <source>A compiled pattern can also be given:</source>
          <target state="translated">也可以给出一个编译的模式。</target>
        </trans-unit>
        <trans-unit id="e76869e54063c0294aaea20a8943a0f7504376d4" translate="yes" xml:space="preserve">
          <source>A compiled pattern:</source>
          <target state="translated">编制的模式。</target>
        </trans-unit>
        <trans-unit id="d3ab1c60e70dbccd5bb3b6385dfc22cb20961df9" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;. This concludes our tour of bitstrings, binaries and strings. A string is a UTF-8 encoded binary and a binary is a bitstring where the number of bits is divisible by 8. Although this shows the flexibility Elixir provides for working with bits and bytes, 99% of the time you will be working with binaries and using the &lt;code&gt;is_binary/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;在Elixir文档中&lt;/a&gt;可以找到有关二进制/位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 的完整参考。到此结束我们的位串，二进制和字符串之旅。字符串是UTF-8编码的二进制，而二进制是位串，其中位数可以被8整除。尽管这表明Elixir提供了灵活的位和字节处理能力，但您有99％的时间使用二进制文件并使用 &lt;code&gt;is_binary/1&lt;/code&gt; 和 &lt;code&gt;byte_size/1&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="105058c6913b6aca65f638c1f413a6d39b69929a" translate="yes" xml:space="preserve">
          <source>A comprehension accepts many generators and filters. Enumerable generators are defined using &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">理解可以接受许多生成器和过滤器。可枚举的生成器使用 &lt;code&gt;&amp;lt;-&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="f2254d1e3c598efd95bae0fbcd5261dc7a19b584" translate="yes" xml:space="preserve">
          <source>A comprehension is made of three parts: generators, filters, and collectables.</source>
          <target state="translated">理解力由三部分组成:发电机、过滤器、收藏品。</target>
        </trans-unit>
        <trans-unit id="57e82275e50252bbe2085b03c1d0b32e426de8c6" translate="yes" xml:space="preserve">
          <source>A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback is useful to verify the arguments given to the provider and prepare the state that will be given to &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配置提供程序通常在组装系统的机器上而不是在目标机器上初始化。该&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调是验证给定到提供者的参数，并准备将被提供给状态有用&lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2d91cecc19bd9b6373cb65cc2b96981847455a7" translate="yes" xml:space="preserve">
          <source>A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.</source>
          <target state="translated">只要reduce函数是以尾递归的方式定义的,就可以琐碎地实现延续。如果函数是尾递归的,所有的状态都作为参数传递,所以延续是部分应用了还原函数。</target>
        </trans-unit>
        <trans-unit id="d9d07f696d7dfca22202afba7e8f633e04a8e575" translate="yes" xml:space="preserve">
          <source>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</source>
          <target state="translated">一个方便的宏,用于检查右侧(一个表达式)是否与左侧(一个模式)匹配。</target>
        </trans-unit>
        <trans-unit id="519bb29b1d6986fcd05f0a99d472d916cc9bd057" translate="yes" xml:space="preserve">
          <source>A datetime implementation with a time zone.</source>
          <target state="translated">一个带时区的日期时间实现。</target>
        </trans-unit>
        <trans-unit id="78f3b8cdfef736d240c67d26318dec43ff774694" translate="yes" xml:space="preserve">
          <source>A developer can filter to import only macros or functions via the only option:</source>
          <target state="translated">开发者可以通过 &quot;唯一 &quot;选项过滤,只导入宏或函数。</target>
        </trans-unit>
        <trans-unit id="5a911f4ab0ec30f4f88b0aebbdc462456eb2bb1d" translate="yes" xml:space="preserve">
          <source>A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as:</source>
          <target state="translated">开发者决不能为了代码组织的目的而使用进程。流程必须用于模拟运行时属性,如:。</target>
        </trans-unit>
        <trans-unit id="4d1073f62e845462d6a9fa22958360b75968c4eb" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, often under a supervisor with the supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;) and a name:</source>
          <target state="translated">动态的主管是从没有孩子开始的，通常是在具有主管策略（当前支持的唯一策略是 &lt;code&gt;:one_for_one&lt;/code&gt; ）的主管的领导下：</target>
        </trans-unit>
        <trans-unit id="206a7ca6f86f975f7d383ad0847c73bb36ab55be" translate="yes" xml:space="preserve">
          <source>A event manager with event handlers behaviour.</source>
          <target state="translated">一个具有事件处理程序行为的事件管理器。</target>
        </trans-unit>
        <trans-unit id="5b9f82bdf9353661bdb7bfb129accfcfc67cacc8" translate="yes" xml:space="preserve">
          <source>A file can also be opened with &lt;code&gt;:utf8&lt;/code&gt; encoding, which tells the &lt;code&gt;File&lt;/code&gt; module to interpret the bytes read from the file as UTF-8-encoded bytes.</source>
          <target state="translated">也可以使用 &lt;code&gt;:utf8&lt;/code&gt; 编码打开文件，该 &lt;code&gt;File&lt;/code&gt; 告诉File模块将从文件中读取的字节解释为UTF-8编码的字节。</target>
        </trans-unit>
        <trans-unit id="26174891cb43d56e620f230c7e58f6661e413141" translate="yes" xml:space="preserve">
          <source>A file named &lt;code&gt;mix.exs&lt;/code&gt; was generated inside our new project folder (&lt;code&gt;kv&lt;/code&gt;) and its main responsibility is to configure our project. Let&amp;rsquo;s take a look at it:</source>
          <target state="translated">在我们的新项目文件夹（ &lt;code&gt;kv&lt;/code&gt; ）内生成了一个名为 &lt;code&gt;mix.exs&lt;/code&gt; 的文件，其主要职责是配置我们的项目。让我们看一下：</target>
        </trans-unit>
        <trans-unit id="b7f8081cbb17a898eeed9fb6829112a813894639" translate="yes" xml:space="preserve">
          <source>A finished test can be in one of five states:</source>
          <target state="translated">完成的测试可以有五种状态之一。</target>
        </trans-unit>
        <trans-unit id="4fed755e476e5364797de1ef4e79f28c16e21183" translate="yes" xml:space="preserve">
          <source>A first attempt at improving it could be with ranges:</source>
          <target state="translated">改进的第一个尝试可能是与范围。</target>
        </trans-unit>
        <trans-unit id="433ee9a9f829c196fd1ee1abea74ddd48c74e24a" translate="yes" xml:space="preserve">
          <source>A flex break still causes a group to break, like &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;, but it is re-evaluated when the documented is rendered.</source>
          <target state="translated">弹性中断仍然会导致组中断，例如&lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt;，但是在呈现文档时会重新评估它。</target>
        </trans-unit>
        <trans-unit id="c789b9878ed6a8416701bcc8a3653070d47748c6" translate="yes" xml:space="preserve">
          <source>A full match spec used when selecting objects in the registry</source>
          <target state="translated">在注册表中选择对象时使用的完全匹配规格。</target>
        </trans-unit>
        <trans-unit id="7d5721d8d9a91361a538da41fa6ecb3b70b6fe95" translate="yes" xml:space="preserve">
          <source>A function that expects arguments can be defined as follows:</source>
          <target state="translated">一个期望参数的函数可以定义如下。</target>
        </trans-unit>
        <trans-unit id="d355151786999a1eeed6fd34569b3fb108130e3c" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;application#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">一般指导原则是仅在监视树的顶部（通常在&lt;a href=&quot;application#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;回调中）使用不带回调模块的管理程序。我们建议对应用程序中的任何其他主管使用基于模块的主管，以便它们可以作为树中其他主管的子代运行。可以使用以下选项来自定义&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;自动生成的 &lt;code&gt;child_spec/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6b4711dc1275381e6488c7af769cb77bdc74fad" translate="yes" xml:space="preserve">
          <source>A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute:</source>
          <target state="translated">给定的字节码或协议实现可以通过分析协议属性来检查是否合并。</target>
        </trans-unit>
        <trans-unit id="78b0b35ef86b280f67197dee5c9182e1ddbec041" translate="yes" xml:space="preserve">
          <source>A given include/exclude filter can be given more than once:</source>
          <target state="translated">一个给定的include/exclude过滤器可以给定一次以上。</target>
        </trans-unit>
        <trans-unit id="ace5acb901e1cf11450076f19fc37584bf1d2ad7" translate="yes" xml:space="preserve">
          <source>A group with linebreaks will fit if all lines in the group fit.</source>
          <target state="translated">如果组中所有的线都符合,那么一个有断线的组就会符合。</target>
        </trans-unit>
        <trans-unit id="d57f1441409523fcaba5ede0a6bbc3934bffdaa3" translate="yes" xml:space="preserve">
          <source>A guard to be evaluated when matching on objects in a registry</source>
          <target state="translated">匹配注册表中的对象时要评估的保护。</target>
        </trans-unit>
        <trans-unit id="f530d85d2682e767c664f63f19c8edab6f12a410" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, in particular, &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; allows creating new keywords without removing duplicated keys, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">存在一些用于处理重复键的函数，特别是&lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;允许创建新关键字而不删除重复键，&lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt;返回给定键的所有值，而&lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt;仅删除现有条目之一。</target>
        </trans-unit>
        <trans-unit id="596a9b5a3a8aa9b50ec41bf23a4f842662a8cb81" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled.</source>
          <target state="translated">在模块编译前调用的钩子。</target>
        </trans-unit>
        <trans-unit id="a0a0a51df914ce59ba1556541b6506e53ae5b94d" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled. Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">在编译模块之前将调用的挂钩。接受模块或 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 元组。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="6987134a6eff9f82a6141f1c9cc8c83ffe79d180" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled.</source>
          <target state="translated">在当前模块编译完成后立即调用的钩子。</target>
        </trans-unit>
        <trans-unit id="83dcc203e6f45c9ceed02fc70bb7ce0dc9022031" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled. Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt;. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">在编译当前模块后将立即调用的钩子。接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="7281774c2eebc7eedcdde8f4eb9495e25954bfba" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</source>
          <target state="translated">当当前模块中的每个函数或宏被定义时,将被调用的钩子。在注释函数时很有用。</target>
        </trans-unit>
        <trans-unit id="b574e1f9586eced8b5deb66bb46ac24d0c228cae" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked whenever the module is loaded.</source>
          <target state="translated">一个钩子,每当模块被加载时就会被调用。</target>
        </trans-unit>
        <trans-unit id="3230b053994c4f824d19b0f0c39c5b461d162140" translate="yes" xml:space="preserve">
          <source>A keyword list can also be given if there is a need to change the child specification for the given child process:</source>
          <target state="translated">如果需要更改给定子流程的子规范,也可以给出一个关键字列表。</target>
        </trans-unit>
        <trans-unit id="27f0445b17da9c462d7db8862e1b68f43ab27b20" translate="yes" xml:space="preserve">
          <source>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</source>
          <target state="translated">一个关键字列表,包含shell在打印表达式评估结果时使用的检查选项。默认为pretty格式,限制为50个条目。</target>
        </trans-unit>
        <trans-unit id="61fe73f02ff5a301c92071887b054a01257fbb87" translate="yes" xml:space="preserve">
          <source>A keyword list is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</source>
          <target state="translated">关键字列表是一个双元素元组的列表,其中元组的第一个元素是原子,第二个元素可以是任何值。</target>
        </trans-unit>
        <trans-unit id="352c6325949d916dfbf48e00d1fe4d030d4dc592" translate="yes" xml:space="preserve">
          <source>A keyword list that encapsulates all color settings used by the shell. See documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt;&lt;code&gt;IO.ANSI&lt;/code&gt;&lt;/a&gt; module for the list of supported colors and attributes.</source>
          <target state="translated">关键字列表，封装了外壳使用的所有颜色设置。有关支持的颜色和属性的列表，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt; &lt;code&gt;IO.ANSI&lt;/code&gt; &lt;/a&gt;模块的文档。</target>
        </trans-unit>
        <trans-unit id="90fd8fbcd55ac37d5c84cb3c58c955ad51a59d87" translate="yes" xml:space="preserve">
          <source>A keyword list:</source>
          <target state="translated">一个关键词列表。</target>
        </trans-unit>
        <trans-unit id="207a17d66a4d274303a0b808b876e2f07cab4cdc" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">关键字可能具有重复的键，因此严格来说不是键值存储。但是，此模块中的大多数功能完全像字典一样工作，因此它们的工作方式与您在&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;模块中找到的功能类似。</target>
        </trans-unit>
        <trans-unit id="7d3c9948a05d7abcab99c9cefbe9438aa010a2dc" translate="yes" xml:space="preserve">
          <source>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return &lt;code&gt;false&lt;/code&gt; if it does not support the concept of leap years.</source>
          <target state="translated">year年是比正常更长的一年。确切含义取决于日历。如果日历不支持leap年的概念，则必须返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9fe9c85fbf7d3fb18bb99ccf2350f33242ce20" translate="yes" xml:space="preserve">
          <source>A library should not provide &lt;code&gt;use MyLib&lt;/code&gt; functionality if all &lt;code&gt;use MyLib&lt;/code&gt; does is to &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;alias&lt;/code&gt; the module itself. For example, this is an anti-pattern:</source>
          <target state="translated">如果 &lt;code&gt;use MyLib&lt;/code&gt; 全部 &lt;code&gt;use MyLib&lt;/code&gt; 是 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;alias&lt;/code&gt; 模块本身，则库不应提供use MyLib功能。例如，这是一个反模式：</target>
        </trans-unit>
        <trans-unit id="86a187cb80a7c4ad0fb8e723a871bc21c28d506c" translate="yes" xml:space="preserve">
          <source>A link is created between the calling process and the new process, atomically. If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason &lt;code&gt;:noconnection&lt;/code&gt; will be received).</source>
          <target state="translated">原子地在调用过程和新过程之间创建一个链接。如果 &lt;code&gt;node&lt;/code&gt; 不存在，则返回无用的PID（并且由于链接，将收到退出原因为 &lt;code&gt;:noconnection&lt;/code&gt; 的退出信号）。</target>
        </trans-unit>
        <trans-unit id="f32efab7c564ee44d8dbdb445e6ef037578935c8" translate="yes" xml:space="preserve">
          <source>A list also supports matching on its own head and tail:</source>
          <target state="translated">列表也支持在自己的头部和尾部进行匹配。</target>
        </trans-unit>
        <trans-unit id="b51c3a4547f02d7e7f4e5168a995c1a16dcdbcfa" translate="yes" xml:space="preserve">
          <source>A list can be checked if it is made of only printable ASCII characters with &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果列表仅由具有&lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; 的&lt;/a&gt;可打印ASCII字符组成，则可以进行检查。</target>
        </trans-unit>
        <trans-unit id="09109009b595afbd12ae9a2a04f05c373522edd5" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;code#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">环境选项列表也可以作为参数给出。有关更多信息，请参见&lt;a href=&quot;code#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fa40d2c95d1592c3f577816c839f4bfb9a0eb32" translate="yes" xml:space="preserve">
          <source>A list of files can be given after the task name in order to select the files to compile:</source>
          <target state="translated">可以在任务名称后面给出一个文件列表,以便选择要编译的文件。</target>
        </trans-unit>
        <trans-unit id="e4f891471b493829a13afb97466625b0b354b781" translate="yes" xml:space="preserve">
          <source>A list of guards to be evaluated when matching on objects in a registry</source>
          <target state="translated">匹配注册表中的对象时要评估的防护措施列表</target>
        </trans-unit>
        <trans-unit id="a09af47acaa10fb69360523f8594ec6d2a340887" translate="yes" xml:space="preserve">
          <source>A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents.</source>
          <target state="translated">返回一个列表,其中主列表中的每个条目代表一个匹配,副列表中的每个条目代表捕获的内容。</target>
        </trans-unit>
        <trans-unit id="ea96d09747a4aa343151e0377aac270bb2119eb2" translate="yes" xml:space="preserve">
          <source>A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on &lt;code&gt;start_link/1&lt;/code&gt; to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</source>
          <target state="translated">选项列表，可用于指定诸如服务器名称之类的内容。现在，我们将在 &lt;code&gt;start_link/1&lt;/code&gt; 上收到的选项列表转发到 &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14180540c9dfb80b1033daf7503e57620771cedc" translate="yes" xml:space="preserve">
          <source>A list of patterns:</source>
          <target state="translated">一系列的模式。</target>
        </trans-unit>
        <trans-unit id="bfadb8e1f57e1fb13ad2e8d3a0b69f6c2d5144ae" translate="yes" xml:space="preserve">
          <source>A local, decentralized and scalable key-value process storage.</source>
          <target state="translated">一个本地的、分散的、可扩展的键值过程存储。</target>
        </trans-unit>
        <trans-unit id="fea558b9d01d10708bd232eedeea8d9affdc8614" translate="yes" xml:space="preserve">
          <source>A logger for Elixir applications.</source>
          <target state="translated">一个用于Elixir应用的记录器。</target>
        </trans-unit>
        <trans-unit id="0f699b34255da40ccc76a38c897571c0c579e349" translate="yes" xml:space="preserve">
          <source>A mandatory linebreak.</source>
          <target state="translated">一个强制性的断线。</target>
        </trans-unit>
        <trans-unit id="a06294fa5d8aaf5ba345cd5c76ff398b3966ffbf" translate="yes" xml:space="preserve">
          <source>A map representing the results of running a test suite</source>
          <target state="translated">代表测试套件运行结果的地图。</target>
        </trans-unit>
        <trans-unit id="3d6bcd31c59bce4c517c58779221986c48c5763e" translate="yes" xml:space="preserve">
          <source>A meta task that compiles source files.</source>
          <target state="translated">一个编译源文件的元任务。</target>
        </trans-unit>
        <trans-unit id="6a1a9dcccbb902320d46c5c63b16e41809e26be8" translate="yes" xml:space="preserve">
          <source>A module for working with applications and defining application callbacks.</source>
          <target state="translated">一个用于处理应用程序和定义应用程序回调的模块。</target>
        </trans-unit>
        <trans-unit id="8dd0cdfde3f3104d72c5cb46bfa86d5986868373" translate="yes" xml:space="preserve">
          <source>A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.</source>
          <target state="translated">如果一个模块目前正在被定义,并且它的属性和功能可以被修改,那么这个模块就是 &quot;开放 &quot;的。</target>
        </trans-unit>
        <trans-unit id="db0c1125a7c9859ba806c52d2b8389c8da71008d" translate="yes" xml:space="preserve">
          <source>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with &lt;code&gt;@doc false&lt;/code&gt;, &lt;code&gt;@impl true&lt;/code&gt;, or functions that aren't explicitly documented and where the function name is in the form of &lt;code&gt;__foo__&lt;/code&gt;.</source>
          <target state="translated">模块可能会导出不希望直接使用的功能：IEX不会自动完成这些功能。IEx不会自动完成以 &lt;code&gt;@doc false&lt;/code&gt; ， &lt;code&gt;@impl true&lt;/code&gt; 注释的函数或未明确记录且函数名称为 &lt;code&gt;__foo__&lt;/code&gt; 形式的函数。</target>
        </trans-unit>
        <trans-unit id="32cd185a5680fc74f94a90987dd36d929f10c20a" translate="yes" xml:space="preserve">
          <source>A module responsible for compiling and requiring files in parallel.</source>
          <target state="translated">一个负责并行编译和要求文件的模块。</target>
        </trans-unit>
        <trans-unit id="29645843a5110b928d9faeadea534106995dc37f" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; fetches the last element).</source>
          <target state="translated">可以传递一个负 &lt;code&gt;index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且 &lt;code&gt;index&lt;/code&gt; 从末尾开始计数（例如， &lt;code&gt;-1&lt;/code&gt; 提取最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="26cdfdc092bdd1d22ed3029d691848711d9f566b" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; finds the last element).</source>
          <target state="translated">可以传递一个负 &lt;code&gt;index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且 &lt;code&gt;index&lt;/code&gt; 从末尾开始计数（例如 &lt;code&gt;-1&lt;/code&gt; 找到最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="7237cde12b43d44a106f66033ee7470522a9c3a4" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;length&lt;/code&gt; can be used to extract bytes that come &lt;em&gt;before&lt;/em&gt; the byte at &lt;code&gt;start&lt;/code&gt;:</source>
          <target state="translated">负 &lt;code&gt;length&lt;/code&gt; 可用于提取 &lt;code&gt;start&lt;/code&gt; 字节&lt;em&gt;之前&lt;/em&gt;的字节：</target>
        </trans-unit>
        <trans-unit id="36a3b9605725fcc95fe9b23e674356e7e27c98c9" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;start_index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the index is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; starts slicing from the last element).</source>
          <target state="translated">可以传递一个负的 &lt;code&gt;start_index&lt;/code&gt; ，这意味着 &lt;code&gt;enumerable&lt;/code&gt; 枚举一次被枚举，并且索引从末尾开始计数（例如 &lt;code&gt;-1&lt;/code&gt; 从最后一个元素开始切片）。</target>
        </trans-unit>
        <trans-unit id="81c58f8de418e8cd25d1b22380a53e0273247707" translate="yes" xml:space="preserve">
          <source>A negative assertion, expects the expression to be &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">否定断言期望表达式为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f88876dd5bc14e91399b8aa67a2ddb2e03a67c34" translate="yes" xml:space="preserve">
          <source>A non-local return from a function.</source>
          <target state="translated">一个函数的非本地返回。</target>
        </trans-unit>
        <trans-unit id="0eaabe61fdbf51208eaa83fc1dc3996aba60b1e8" translate="yes" xml:space="preserve">
          <source>A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;a href=&quot;#restart_child/2&quot;&gt;&lt;code&gt;restart_child/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#delete_child/2&quot;&gt;&lt;code&gt;delete_child/2&lt;/code&gt;&lt;/a&gt; to remove the child specification.</source>
          <target state="translated">管理员以后可以重新启动非临时子进程。子进程也可以通过调用&lt;a href=&quot;#restart_child/2&quot;&gt; &lt;code&gt;restart_child/2&lt;/code&gt; &lt;/a&gt;显式重启。使用&lt;a href=&quot;#delete_child/2&quot;&gt; &lt;code&gt;delete_child/2&lt;/code&gt; &lt;/a&gt;删除子级规范。</target>
        </trans-unit>
        <trans-unit id="8f2c93e683b0d27c8800a0f19ebf6094692e37b8" translate="yes" xml:space="preserve">
          <source>A partially applied reduce function.</source>
          <target state="translated">部分应用还原功能。</target>
        </trans-unit>
        <trans-unit id="e00db969c5f31283ff3f80e6b605d47156f36587" translate="yes" xml:space="preserve">
          <source>A path may start with a variable, local or remote call, and must be followed by one or more:</source>
          <target state="translated">一个路径可以以变量、本地或远程调用开始,后面必须有一个或多个。</target>
        </trans-unit>
        <trans-unit id="5e11bed9e1e8a8a0b7c8ded2d01ff3d9a7368c94" translate="yes" xml:space="preserve">
          <source>A path pointing to a configuration file.</source>
          <target state="translated">指向配置文件的路径。</target>
        </trans-unit>
        <trans-unit id="41835ab5b136f3e0eaefd676f9827017842ad941" translate="yes" xml:space="preserve">
          <source>A pattern match error will occur if the sides can&amp;rsquo;t be matched, for example if the tuples have different sizes:</source>
          <target state="translated">如果边不能匹配，则会发生模式匹配错误，例如，如果元组的大小不同：</target>
        </trans-unit>
        <trans-unit id="79fa4792dd24d1c9ce95071d9547feb6a4d474ba" translate="yes" xml:space="preserve">
          <source>A pattern to match on objects in a registry</source>
          <target state="translated">在注册表中匹配对象的模式。</target>
        </trans-unit>
        <trans-unit id="3d346e75c8c6987f80b82de7253d52d8aba958ff" translate="yes" xml:space="preserve">
          <source>A pattern used to representing the output format part of a match spec</source>
          <target state="translated">用于表示匹配规格的输出格式部分的一种模式。</target>
        </trans-unit>
        <trans-unit id="a00cd65793f8f99aab040156d050cf1a0b39a869" translate="yes" xml:space="preserve">
          <source>A period where a certain combination of UTC offset, standard offset and zone abbreviation is in effect.</source>
          <target state="translated">在一个时期内,UTC偏移、标准偏移和区域缩写的某种组合是有效的。</target>
        </trans-unit>
        <trans-unit id="a5288558e1086c80bf20bc1087103275b3133199" translate="yes" xml:space="preserve">
          <source>A port can be closed via the &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; function or by sending a &lt;code&gt;{pid, :close}&lt;/code&gt; message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but &lt;strong&gt;it won't be automatically terminated&lt;/strong&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt;函数或发送 &lt;code&gt;{pid, :close}&lt;/code&gt; 消息来关闭端口。但是，如果VM崩溃，则由该端口启动的长时间运行的程序将关闭其stdin和stdout通道，但&lt;strong&gt;不会自动终止&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b2122c1973c2dda96664be48d7e0ad6fbebe03e1" translate="yes" xml:space="preserve">
          <source>A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters:</source>
          <target state="translated">Elixir中的可打印字符表仅包含标准七位ASCII字符编码中的可打印字符,这些字符的十进制符号范围为32至126,再加上以下控制字符。</target>
        </trans-unit>
        <trans-unit id="b3af7c971656040987518db1c82f85c014263d8e" translate="yes" xml:space="preserve">
          <source>A process destination.</source>
          <target state="translated">一个进程的目的地。</target>
        </trans-unit>
        <trans-unit id="fcf40e109a152697e452d59c6feb366ea55241fd" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">协议指定应由其实现定义的API。甲协议与定义&lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;以及其与实施方式&lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40779d1515587d6db075e7f5314df3d534311c89" translate="yes" xml:space="preserve">
          <source>A protocol to traverse data structures.</source>
          <target state="translated">一个遍历数据结构的协议。</target>
        </trans-unit>
        <trans-unit id="faabe41c6f24d8fc609c47ff799c87b178b75359" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">范围实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于范围：</target>
        </trans-unit>
        <trans-unit id="c2bc069750ea0a5631ff0d83641bb81ba15fed6b" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;kernel#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">范围在内部以结构表示。但是，在范围上创建和匹配的最常见形式是通过&lt;a href=&quot;kernel#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt;宏（从&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;自动导入）：</target>
        </trans-unit>
        <trans-unit id="28e7d9d80973e28b2fb29cdc49aa8ec0aa8cccf3" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">日期范围实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，这意味着&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中的函数可用于范围：</target>
        </trans-unit>
        <trans-unit id="ef459269461f63f29663369bbbf33d383fe471b6" translate="yes" xml:space="preserve">
          <source>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</source>
          <target state="translated">日期范围表示一个离散的日期数,其中第一个和最后一个值是匹配日历的日期。</target>
        </trans-unit>
        <trans-unit id="857a01be27effa9640fcaf21a35ced2eddd4ea08" translate="yes" xml:space="preserve">
          <source>A range represents a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">一个范围表示一个或多个,升序或降序,连续的整数序列。</target>
        </trans-unit>
        <trans-unit id="3fb37b0dc70a7a2ede2ae25048520f07b813bb7c" translate="yes" xml:space="preserve">
          <source>A regular expression:</source>
          <target state="translated">正则表达式。</target>
        </trans-unit>
        <trans-unit id="be263ca652770d8e713a67b34a6b5d617a6d08fc" translate="yes" xml:space="preserve">
          <source>A release is a self-contained directory that consists of your application code, all of its dependencies, plus the whole Erlang Virtual Machine (VM) and runtime. Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.</source>
          <target state="translated">一个版本是一个独立的目录,它包含了你的应用程序代码,所有的依赖关系,加上整个Erlang虚拟机(VM)和运行时。一旦一个发行版被组装好,它就可以被打包并部署到目标机上,只要目标机运行在与组装发行版的机器相同的操作系统(OS)发行版和版本上。</target>
        </trans-unit>
        <trans-unit id="c42536b2192014c69ae4b22e18c222e0b18ad99c" translate="yes" xml:space="preserve">
          <source>A remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">远程或本地PID，本地端口，本地注册名称或 &lt;code&gt;{registered_name, node}&lt;/code&gt; 形式的元组，表示另一个节点上的注册名称。</target>
        </trans-unit>
        <trans-unit id="ed74d2fa39cb6d22ba41097b9f56baec46115768" translate="yes" xml:space="preserve">
          <source>A runtime error can be raised any time by using &lt;code&gt;raise/1&lt;/code&gt;:</source>
          <target state="translated">可以随时通过使用 &lt;code&gt;raise/1&lt;/code&gt; 引发运行时错误：</target>
        </trans-unit>
        <trans-unit id="ecf229e1b88c6de3ab419f5af0149c86ba96a100" translate="yes" xml:space="preserve">
          <source>A set can contain any kind of elements, and elements in a set don't have to be of the same type. By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op.</source>
          <target state="translated">一个集合可以包含任何种类的元素,而且集合中的元素不一定是同一类型的。根据定义,集合不能包含重复的元素:当在集合中插入一个已经存在的元素时,插入的元素只是一个无操作。</target>
        </trans-unit>
        <trans-unit id="69129ee232976b3cda2ab262254ae0307e0e66f5" translate="yes" xml:space="preserve">
          <source>A set of aliases can be specified in the &lt;code&gt;:aliases&lt;/code&gt; option:</source>
          <target state="translated">可以在 &lt;code&gt;:aliases&lt;/code&gt; 选项中指定一组别名：</target>
        </trans-unit>
        <trans-unit id="e06834fc00f6bb288e0de824ba38e921ca02021c" translate="yes" xml:space="preserve">
          <source>A set of functions for creating and manipulating algebra documents.</source>
          <target state="translated">一组用于创建和操作代数文档的函数。</target>
        </trans-unit>
        <trans-unit id="88d1b0f8b81589767cdd10b2d4eb2dac1c18cfad" translate="yes" xml:space="preserve">
          <source>A set of functions for working with functions.</source>
          <target state="translated">一套用于处理函数的函数。</target>
        </trans-unit>
        <trans-unit id="730d44e1645bfae97fe7c12ff77a7bf08210ea3c" translate="yes" xml:space="preserve">
          <source>A set of functions for working with keywords.</source>
          <target state="translated">一套用于处理关键词的功能。</target>
        </trans-unit>
        <trans-unit id="dfb7a76606ff3c8779b3a99cd95301d320dbf7d1" translate="yes" xml:space="preserve">
          <source>A set of functions for working with maps.</source>
          <target state="translated">一套用于处理地图的功能。</target>
        </trans-unit>
        <trans-unit id="5f326a556060d175497aed660d915fb196c3082f" translate="yes" xml:space="preserve">
          <source>A set of macros that perform calculations on bits.</source>
          <target state="translated">一组对比特进行计算的宏。</target>
        </trans-unit>
        <trans-unit id="7d47059c046e5014c34e11ea59ece30879e2953e" translate="yes" xml:space="preserve">
          <source>A short example is:</source>
          <target state="translated">一个简单的例子是:</target>
        </trans-unit>
        <trans-unit id="cbb763bbb5e88ec5f61d4da245e4ae7009da3216" translate="yes" xml:space="preserve">
          <source>A similar example is when the formatter breaks a function definition over multiple clauses:</source>
          <target state="translated">一个类似的例子是当formatter将一个函数定义分解到多个子句上。</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="70f5ef2ef60f95969333b92d42f3f374f63b82f9" translate="yes" xml:space="preserve">
          <source>A simple keyword-based configuration API.</source>
          <target state="translated">一个简单的基于关键字的配置API。</target>
        </trans-unit>
        <trans-unit id="c8561655e8b17e9fc3693ef2633482210d43ebb9" translate="yes" xml:space="preserve">
          <source>A simple module that provides conveniences for creating, loading and manipulating tasks.</source>
          <target state="translated">一个简单的模块,为创建、加载和操作任务提供便利。</target>
        </trans-unit>
        <trans-unit id="15571e3a35bf5ea9940001cd7a008535588aae55" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">一个更简单的选择是将理解用于字母的映射和过滤，然后调用&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;来构建映射，例如：</target>
        </trans-unit>
        <trans-unit id="42b7224e7f04fc46b45efe7b42b88ffb7dce900f" translate="yes" xml:space="preserve">
          <source>A slicing function that receives the initial position and the number of elements in the slice.</source>
          <target state="translated">一个接收初始位置和切片中元素数量的切片函数。</target>
        </trans-unit>
        <trans-unit id="9542d8f0337c374d610ba8edde94615ef17ee5bc" translate="yes" xml:space="preserve">
          <source>A solution is to make sure the child processes listen to the standard input and terminate when standard input is closed. We discuss this topic at length in the &quot;Zombie operating system processes&quot; of the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">一种解决方案是确保子进程监听标准输入并在标准输入关闭时终止。我们将在&lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;僵尸操作系统进程&amp;rdquo;中详细讨论此主题。</target>
        </trans-unit>
        <trans-unit id="c87e0295b0434ce8d6e0bea2a0090734199f18b2" translate="yes" xml:space="preserve">
          <source>A specification for a function can be defined as follows:</source>
          <target state="translated">一个函数的规格可以定义如下:</target>
        </trans-unit>
        <trans-unit id="cb5a957f0b3dafd85aa37ba4fcf8ab83b116491b" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;process#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">必须将stacktrace作为参数。如果不是，则从&lt;a href=&quot;process#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt;检索stacktrace 。</target>
        </trans-unit>
        <trans-unit id="024c57bba13b29b29ec58526f15dcb1593786c12" translate="yes" xml:space="preserve">
          <source>A string is a UTF-8 encoded binary. In order to understand exactly what we mean by that, we need to understand the difference between bytes and code points.</source>
          <target state="translated">字符串是一个UTF-8编码的二进制。为了准确理解我们所说的意思,我们需要了解字节和码点的区别。</target>
        </trans-unit>
        <trans-unit id="3135dbc4cf4ce228f4aedafff7fb3268b76ca8f3" translate="yes" xml:space="preserve">
          <source>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</source>
          <target state="translated">结构体是一个标签化的映射,它允许开发者为键提供默认值,在多态派遣和编译时断言中使用的标签。</target>
        </trans-unit>
        <trans-unit id="9134cc0bb82067454750b89f0528401b6a9bc1d3" translate="yes" xml:space="preserve">
          <source>A struct that holds compile time environment information.</source>
          <target state="translated">一个保存编译时环境信息的结构。</target>
        </trans-unit>
        <trans-unit id="2aab307089f5f9db7819dc7a115a812e5a3fa578" translate="yes" xml:space="preserve">
          <source>A struct that holds file information.</source>
          <target state="translated">一个存放文件信息的结构。</target>
        </trans-unit>
        <trans-unit id="682f2bb617fd3f67f3ee1da2f3c9e406cf26c520" translate="yes" xml:space="preserve">
          <source>A struct that holds version requirement information.</source>
          <target state="translated">一个保存版本需求信息的结构。</target>
        </trans-unit>
        <trans-unit id="41babc3e64f09380f0db683d589523654ce213d8" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test case.</source>
          <target state="translated">一个保存测试用例信息的结构。</target>
        </trans-unit>
        <trans-unit id="977bdad55f17ecd8ee2f048b6fc658fc29753b9a" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test.</source>
          <target state="translated">一个保存测试信息的结构。</target>
        </trans-unit>
        <trans-unit id="ac118fd8485fc091bbf3bccd439369617ac9e067" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as &lt;em&gt;child processes&lt;/em&gt;. Supervisors are used to build a hierarchical process structure called a &lt;em&gt;supervision tree&lt;/em&gt;. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.</source>
          <target state="translated">主管是监督其他过程的过程，我们称其为&lt;em&gt;子过程&lt;/em&gt;。主管用于构建称为&lt;em&gt;监督树&lt;/em&gt;的分层过程结构。监督树提供了容错能力，并封装了我们的应用程序如何启动和关闭。</target>
        </trans-unit>
        <trans-unit id="55d0b2c21ea69ec921c9ed14e37c45764559b92c" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities. The first one is to start child processes. Once a child process is running, the supervisor may restart a child process, either because it terminated abnormally or because a certain condition was reached. For example, a supervisor may restart all children if any child dies. Finally, a supervisor is also responsible for shutting down the child processes when the system is shutting down. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; module for a more in-depth discussion.</source>
          <target state="translated">主管是监督其他流程的流程，我们将其称为子流程。监督流程的行为包括三个不同的职责。第一个是启动子进程。子进程运行后，主管可能会重新启动子进程，这可能是因为该子进程异常终止或达到了特定条件。例如，如果任何一个孩子死亡，那么主管可以重新启动所有孩子。最后，主管还负责在系统关闭时关闭子进程。请参阅&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt;模块以进行更深入的讨论。</target>
        </trans-unit>
        <trans-unit id="2148e1ac9ba1ddbf69713d1fe8062e24faf800f8" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">主管与&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;具有相同的名称注册规则。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的文档中阅读有关这些规则的更多信息。</target>
        </trans-unit>
        <trans-unit id="789257e49c9248f0d549832ff687e69eea5012dc" translate="yes" xml:space="preserve">
          <source>A supervisor may be started directly with a list of children via &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; or you may define a module-based supervisor that implements the required callbacks. The sections below use &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; to start supervisors in most examples, but it also includes a specific section on module-based ones.</source>
          <target state="translated">可以通过&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;从子列表直接启动管理程序，或者您可以定义一个基于模块的管理程序，以实现所需的回调。在大多数示例中，以下部分使用&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;来启动管理程序，但其中还包括有关基于模块的管理程序的特定部分。</target>
        </trans-unit>
        <trans-unit id="73975472006297ae3fcad167925a215d573e02d7" translate="yes" xml:space="preserve">
          <source>A supervisor restarts a child process depending on its &lt;code&gt;:restart&lt;/code&gt; configuration. For example, when &lt;code&gt;:restart&lt;/code&gt; is set to &lt;code&gt;:transient&lt;/code&gt;, the supervisor does not restart the child in case it exits with reason &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">管理员根据其 &lt;code&gt;:restart&lt;/code&gt; 配置重启子进程。例如，当 &lt;code&gt;:restart&lt;/code&gt; 设置为 &lt;code&gt;:transient&lt;/code&gt; 时，监督者不会重启子节点，以防其退出原因是 &lt;code&gt;:normal&lt;/code&gt; ， &lt;code&gt;:shutdown&lt;/code&gt; 或 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60c5977b15b358f6b78f3ae1aad052bb829be570" translate="yes" xml:space="preserve">
          <source>A supervisor that starts children dynamically.</source>
          <target state="translated">一个动态启动孩子的主管。</target>
        </trans-unit>
        <trans-unit id="615c68fd3df9515609693344bfb85db4d952662a" translate="yes" xml:space="preserve">
          <source>A tag can be set for all tests in a module or describe block by setting &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; inside each context respectively:</source>
          <target state="translated">可以为模块中的所有测试设置标签，也可以通过分别在每个上下文中设置 &lt;code&gt;@moduletag&lt;/code&gt; 或 &lt;code&gt;@describetag&lt;/code&gt; 来描述模块：</target>
        </trans-unit>
        <trans-unit id="0662f79c653f0ec45efdb5f488b2e4dad7e4bc27" translate="yes" xml:space="preserve">
          <source>A task needs to implement &lt;code&gt;run&lt;/code&gt; which receives a list of command line args.</source>
          <target state="translated">一个任务需要实现 &lt;code&gt;run&lt;/code&gt; ，该运行接收命令行参数列表。</target>
        </trans-unit>
        <trans-unit id="e97df0f46736141ff7a6d7cb0a21370015757093" translate="yes" xml:space="preserve">
          <source>A task supervisor is started with no children, often under a supervisor and a name:</source>
          <target state="translated">任务督导是在没有孩子的情况下开始的,往往是在一个督导和一个名字之下。</target>
        </trans-unit>
        <trans-unit id="ff48cedfb7c96d7c2ed5d2fcc23ecbe5aa13422a" translate="yes" xml:space="preserve">
          <source>A task supervisor is typically started under a supervision tree using the tuple format:</source>
          <target state="translated">任务监督员通常是在监督树下使用元组格式启动的。</target>
        </trans-unit>
        <trans-unit id="400405b3406f1f222a1d0498ff7d0e89bdd37f83" translate="yes" xml:space="preserve">
          <source>A task supervisor.</source>
          <target state="translated">一个任务主管。</target>
        </trans-unit>
        <trans-unit id="2894abc710a014ff1c5c80e21ac1103d9d069763" translate="yes" xml:space="preserve">
          <source>A term of type &lt;strong&gt;IO data&lt;/strong&gt; is a binary or a list containing bytes (integers in &lt;code&gt;0..255&lt;/code&gt;) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &lt;code&gt;&quot;hello&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;IO数据&lt;/strong&gt;类型的术语是二进制或包含字节（ &lt;code&gt;0..255&lt;/code&gt; 中的整数）或嵌套IO数据的列表。类型是递归的。让我们看一个代表二进制 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 的可能的IO数据之一的示例：</target>
        </trans-unit>
        <trans-unit id="7c720a57b20bbb00d7cd6e1d7bb642e1d8d5947c" translate="yes" xml:space="preserve">
          <source>A test module can define multiple &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks, and they are invoked in order of appearance.</source>
          <target state="translated">一个测试模块可以定义多个 &lt;code&gt;setup&lt;/code&gt; 和 &lt;code&gt;setup_all&lt;/code&gt; 回调，并按出现顺序调用它们。</target>
        </trans-unit>
        <trans-unit id="ec4945e7afe50419c6b9cae97faa15dec66d7711" translate="yes" xml:space="preserve">
          <source>A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in &lt;code&gt;1 / parts_per_second&lt;/code&gt; seconds. For example, using the &lt;code&gt;:millisecond&lt;/code&gt; time unit is equivalent to using &lt;code&gt;1000&lt;/code&gt; as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).</source>
          <target state="translated">时间单位也可以是严格的正整数。在这种情况下，它表示&amp;ldquo;每秒的零件数&amp;rdquo;：时间将以 &lt;code&gt;1 / parts_per_second&lt;/code&gt; 秒的形式返回。例如，使用 &lt;code&gt;:millisecond&lt;/code&gt; 时间单位等效于使用 &lt;code&gt;1000&lt;/code&gt; 作为时间单位（因为时间将以1/1000秒-毫秒返回）。</target>
        </trans-unit>
        <trans-unit id="f8027bb61ebc1be6167e83dd5aa3351e16405a8f" translate="yes" xml:space="preserve">
          <source>A timeout in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">超时值可以是毫秒或 &lt;code&gt;:infinity&lt;/code&gt; ，默认值是 &lt;code&gt;5000&lt;/code&gt; 。如果超过了超时，则当前进程将退出。如果任务进程链接到当前进程（使用 &lt;code&gt;async&lt;/code&gt; 启动任务时就是这种情况），那么任务进程也将退出。如果任务进程正在捕获出口或未链接到当前进程，则它将继续运行。</target>
        </trans-unit>
        <trans-unit id="198be1f82bcaf7ef6e87003105d7f1bb0913880a" translate="yes" xml:space="preserve">
          <source>A timeout of 0 can be given when you already expect the message to be in the mailbox.</source>
          <target state="translated">当你已经期待邮件进入邮箱时,可以给出0的超时。</target>
        </trans-unit>
        <trans-unit id="cdda64adffbe29ce867f4e13216350c2cecaa35a" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。</target>
        </trans-unit>
        <trans-unit id="68fd1acb1d049659698dd0e6399a2faf0bb992be" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the time runs out before a message from the task is received, this function will return &lt;code&gt;nil&lt;/code&gt; and the monitor will remain active. Therefore &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; can be called multiple times on the same task.</source>
          <target state="translated">可以使用默认值 &lt;code&gt;5000&lt;/code&gt; 来指定超时（以毫秒或 &lt;code&gt;:infinity&lt;/code&gt; 表示）。如果在收到任务消息之前时间已到，此函数将返回 &lt;code&gt;nil&lt;/code&gt; 并且监视器将保持活动状态。因此，可以在同一任务上多次调用&lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d0d4ddbed899c477cc9f6352b9a36db821efe20" translate="yes" xml:space="preserve">
          <source>A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.</source>
          <target state="translated">尾部的bang(感叹号)表示一个函数或宏,其中失败情况会引发异常。</target>
        </trans-unit>
        <trans-unit id="595193044562313fed22c09af41ccc775c92d1e5" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;logger#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">转换程序只是一个包含模块和功能的元组，可以通过&lt;a href=&quot;logger#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;logger#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt;函数进行添加和删除，并为具有最低参数级别的每个Erlang消息调用以下四个参数：</target>
        </trans-unit>
        <trans-unit id="977fa89e1a9a5fcdc6a2202879cd6a99f38e175d" translate="yes" xml:space="preserve">
          <source>A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals.</source>
          <target state="translated">一个元组可以包含不同类型的元素,这些元素连续地存储在内存中。访问任何元素都需要恒定的时间,但修改一个元组,产生一个浅层副本,需要线性时间。元组适合读取数据,而列表则更适合遍历。</target>
        </trans-unit>
        <trans-unit id="3b70a1f3c40082637faa4be4833ceb4685eae005" translate="yes" xml:space="preserve">
          <source>A type defined with &lt;code&gt;@typep&lt;/code&gt; is private. An opaque type, defined with &lt;code&gt;@opaque&lt;/code&gt; is a type where the internal structure of the type will not be visible, but the type is still public.</source>
          <target state="translated">用 &lt;code&gt;@typep&lt;/code&gt; 定义的类型是私有的。用 &lt;code&gt;@opaque&lt;/code&gt; 定义的不透明类型是一种类型，其中该类型的内部结构不可见，但该类型仍然是公共的。</target>
        </trans-unit>
        <trans-unit id="8d3bd389baf78dba20b0d8db318aee60b33e011c" translate="yes" xml:space="preserve">
          <source>A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup.</source>
          <target state="translated">还必须给出一个与该注册相关联的值。这个值将在每次发送或进行键查询时被检索。</target>
        </trans-unit>
        <trans-unit id="e27b2906462bb426d4db8b9c875eb3719eb195a6" translate="yes" xml:space="preserve">
          <source>A variable assigned inside a function does not affect its surrounding environment:</source>
          <target state="translated">在函数内部赋值的变量不会影响其周围环境。</target>
        </trans-unit>
        <trans-unit id="eefe91c5b1f2dca4795e8c30b3e66948a135ee4c" translate="yes" xml:space="preserve">
          <source>A variable can only be assigned on the left side of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">只能在 &lt;code&gt;=&lt;/code&gt; 的左侧分配变量：</target>
        </trans-unit>
        <trans-unit id="bc60d48fd93ed889b691c632db601f39d5eb520c" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;version#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">版本是特定格式的字符串，或者是通过&lt;a href=&quot;version#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; &lt;/a&gt;解析后生成的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ddca9755179e1f59903c4ddf6f15ddbb4628e05" translate="yes" xml:space="preserve">
          <source>A warning will be printed on missing assigns. Future versions will raise.</source>
          <target state="translated">缺少赋值将被打印警告。未来的版本将提出。</target>
        </trans-unit>
        <trans-unit id="8ca63c80632d0cf1aa32c53e95d09843a1d1dd72" translate="yes" xml:space="preserve">
          <source>A word on distributed agents</source>
          <target state="translated">谈谈分布式代理</target>
        </trans-unit>
        <trans-unit id="be1bb8f888ee7021de890698fb2afa717b6c1550" translate="yes" xml:space="preserve">
          <source>ACC - total time spent in the function</source>
          <target state="translated">ACC ----在该功能中花费的总时间</target>
        </trans-unit>
        <trans-unit id="586d4163da04d5ab6791e3c06e9ffe5c9db509ec" translate="yes" xml:space="preserve">
          <source>ANSI escapes in &lt;code&gt;string&lt;/code&gt; are not processed in any way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 中的ANSI转义符不会以任何方式处理。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="08955ef48e12709a927739991a3df46487d19807" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于读取使用&lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;定义的配置文件的API 。</target>
        </trans-unit>
        <trans-unit id="8b349aa6f5c8405e74e0ce2c3f7201bebe1b4de3" translate="yes" xml:space="preserve">
          <source>AST considerations</source>
          <target state="translated">AST的考虑</target>
        </trans-unit>
        <trans-unit id="722e9952d5c095e4d71bce17445a76597f676acc" translate="yes" xml:space="preserve">
          <source>AST representation</source>
          <target state="translated">AST表示</target>
        </trans-unit>
        <trans-unit id="266c0ed1029b1e5c3251173a36c9d608b25b8d14" translate="yes" xml:space="preserve">
          <source>Aborts when a command exits with a non-zero status.</source>
          <target state="translated">当命令以非零的状态退出时,就会中止。</target>
        </trans-unit>
        <trans-unit id="fff456f1c782da0b35f8fa5b303ce271025c27f6" translate="yes" xml:space="preserve">
          <source>Abstract Syntax Tree (AST)</source>
          <target state="translated">抽象语法树(AST)</target>
        </trans-unit>
        <trans-unit id="16d98934b253153ce90ef5967a4ab32ed934fb4d" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;ignore: :whitespace&lt;/code&gt; option which will ignore all the whitespace characters in the input string.</source>
          <target state="translated">接受 &lt;code&gt;ignore: :whitespace&lt;/code&gt; 选项，它将忽略输入字符串中的所有空白字符。</target>
        </trans-unit>
        <trans-unit id="ff9572ac36a4e1f1c2d3b6e7fe1206f556bcd6be" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will ignore padding from the input string.</source>
          <target state="translated">接受 &lt;code&gt;padding: false&lt;/code&gt; 选项，它将忽略输入字符串中的padding。</target>
        </trans-unit>
        <trans-unit id="e6606a70939f51500cf29d0104ea455b8e57bbbd" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will omit padding from the output string.</source>
          <target state="translated">接受 &lt;code&gt;padding: false&lt;/code&gt; 选项，它将省略输出字符串中的padding。</target>
        </trans-unit>
        <trans-unit id="d11f73644b7b3add855698ef69a041b85cac741e" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located.</source>
          <target state="translated">接受 &lt;code&gt;relative_to&lt;/code&gt; 作为参数来告诉文件位于何处。</target>
        </trans-unit>
        <trans-unit id="312c5b592fe6d7dd571d6c8037a1f4c663f75282" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located. If the file was already required, &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; doesn't do anything and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">接受 &lt;code&gt;relative_to&lt;/code&gt; 作为参数来告诉文件位于何处。如果已经需要该文件，则&lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt;不执行任何操作，并返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a8f51a20bef3da7c165ebe3b333dbb26c7d054f" translate="yes" xml:space="preserve">
          <source>Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms.</source>
          <target state="translated">接受一个原子形式的块或一元函数的名称,或一个这样的原子列表。</target>
        </trans-unit>
        <trans-unit id="8001c91fcbcc7035c433992b44685f5330523f6b" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。请参阅下面的&amp;ldquo;编译回调&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c68ab20eebd551a8183d8a271c2a11f2f59f798e" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take 6 arguments:</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。该函数必须采用6个参数：</target>
        </trans-unit>
        <trans-unit id="7bebfa805f9fa42810edbee6281c1119c222c690" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be &lt;code&gt;__after_compile__/2&lt;/code&gt;.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_name}&lt;/code&gt; 元组。该函数必须采用两个参数：模块环境及其字节码。仅提供模块时，该函数假定为 &lt;code&gt;__after_compile__/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e8eec1dc724492ff94d0553bb6ff5b22253d396" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts.</source>
          <target state="translated">接受模块或 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 元组。函数/宏必须带有一个参数：模块环境。如果是宏，则其返回值将在编译开始之前在模块定义的末尾注入。</target>
        </trans-unit>
        <trans-unit id="b8a02787b1528282c9b913825c8890849c97b169" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@doc false&lt;/code&gt; will make the entity invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">接受字符串（通常为heredoc）或 &lt;code&gt;false&lt;/code&gt; ，其中 &lt;code&gt;@doc false&lt;/code&gt; 将使该实体对于诸如&lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; 之&lt;/a&gt;类的文档提取工具不可见。例如：</target>
        </trans-unit>
        <trans-unit id="e201112d9033197e821f8bcdf23e660e950b4fd3" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@moduledoc false&lt;/code&gt; will make the module invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受字符串（通常为heredoc）或 &lt;code&gt;false&lt;/code&gt; ，其中 &lt;code&gt;@moduledoc false&lt;/code&gt; 将使该模块对诸如&lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; 之&lt;/a&gt;类的文档提取工具不可见。</target>
        </trans-unit>
        <trans-unit id="a5cd37e51e05c989f61c56fcc8057339b69ee344" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">以 &lt;code&gt;amount_to_add&lt;/code&gt; &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt;可用的任何 &lt;code&gt;unit&lt;/code&gt; 接受amount_to_add。负值将在时间上向后移动。</target>
        </trans-unit>
        <trans-unit id="9c7e182b3105eb309155a16cd4d01036199f0e2d" translate="yes" xml:space="preserve">
          <source>Accepts an atom, a tuple, or a list of atoms and tuples. For example:</source>
          <target state="translated">接受一个原子、一个元组或一个原子和元组的列表。例如:</target>
        </trans-unit>
        <trans-unit id="3e6f11dba90273a10068990877edcdfb26f22547" translate="yes" xml:space="preserve">
          <source>Accepts the function name (as an atom) of a function in the current module or &lt;code&gt;{function_name, 0}&lt;/code&gt; tuple where &lt;code&gt;function_name&lt;/code&gt; is the name of a function in the current module. The function must be public and have an arity of 0 (no arguments). If the function does not return &lt;code&gt;:ok&lt;/code&gt;, the loading of the module will be aborted. For example:</source>
          <target state="translated">接受当前模块中函数的函数名称（作为原子）或 &lt;code&gt;{function_name, 0}&lt;/code&gt; 元组，其中 &lt;code&gt;function_name&lt;/code&gt; 是当前模块中函数的名称。该函数必须是公共函数，且Arity为0（无参数）。如果函数未返回 &lt;code&gt;:ok&lt;/code&gt; ，则模块的加载将被中止。例如：</target>
        </trans-unit>
        <trans-unit id="2f81a22de0af5e9eab19326e19693f86ce612518" translate="yes" xml:space="preserve">
          <source>Access</source>
          <target state="translated">Access</target>
        </trans-unit>
        <trans-unit id="61eeb1ced62d9d70c3a7da771b7e65111efa9eeb" translate="yes" xml:space="preserve">
          <source>Access &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">访问&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="32cc0e2e72b4a5cd8e1d10f3088022c273757f9c" translate="yes" xml:space="preserve">
          <source>Access syntax</source>
          <target state="translated">访问语法</target>
        </trans-unit>
        <trans-unit id="ffaea95d2c8c2a121901ac8053918362a2259c0d" translate="yes" xml:space="preserve">
          <source>Accesses an already bound variable in match clauses. Also known as the pin operator.</source>
          <target state="translated">访问匹配子句中已经绑定的变量。也称为pin操作符。</target>
        </trans-unit>
        <trans-unit id="114bded9b29083adea70f97a0e2b9cca28f2f55b" translate="yes" xml:space="preserve">
          <source>Accessing and updating structs</source>
          <target state="translated">访问和更新结构</target>
        </trans-unit>
        <trans-unit id="778701a39f61d1d0d376ec6add6756493d3c6f48" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;system#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">不建议在营救/捕获之外访问stacktrace。如果只想支持Elixir &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; +，则必须在救援/捕获中访问__STACKTRACE __ / 0。如果您想支持早期的Elixir版本，请将&lt;a href=&quot;system#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; &lt;/a&gt;移到急救/捕获中。</target>
        </trans-unit>
        <trans-unit id="c08435b6ee1c53e0f3db32fa2d67cb282966fb48" translate="yes" xml:space="preserve">
          <source>According to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table. Since this is a race condition, you may not be able to reproduce it on your machine, but it is there.</source>
          <target state="translated">根据失败消息,我们期待的是表上已经不存在 bucket 了,但它还是存在的!这就是我们刚刚解决的问题:以前创建 bucket 的命令和更新表之间有延迟,现在 bucket 进程死亡和它的条目被从表上删除之间有延迟。这个问题与我们刚刚解决的问题正好相反:之前在创建bucket的命令和更新表之间有延迟,而现在在bucket进程死亡和它的条目从表上删除之间有延迟。由于这是一个竞赛条件,你可能无法在你的机器上重现,但它是存在的。</target>
        </trans-unit>
        <trans-unit id="f82c99de451613d4c3468e6d7fc04fc56efcc179" translate="yes" xml:space="preserve">
          <source>Actually expands to:</source>
          <target state="translated">其实扩展到。</target>
        </trans-unit>
        <trans-unit id="9e4e792ab5793275266dbf12ecb483ea47d35fb1" translate="yes" xml:space="preserve">
          <source>Adding explicit parentheses is enough to bind the block to &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">添加显式括号足以将块绑定到 &lt;code&gt;if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="be05b1119a34ef95ba3623420677cc256aa4984b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">此外，&lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt;会将所有AST的所有出现转换为 &lt;code&gt;left not in right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="084086258188a6f83f3c0621f1d91c6afb01428b" translate="yes" xml:space="preserve">
          <source>Additionally, the following functions and operators for lists are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此外，在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中可以找到以下列表的函数和运算符：</target>
        </trans-unit>
        <trans-unit id="b78d4c95ca68cd548509bceede9d001db1a210fc" translate="yes" xml:space="preserve">
          <source>Additionally, the following scope values can be configured:</source>
          <target state="translated">此外,还可以配置以下范围值。</target>
        </trans-unit>
        <trans-unit id="edc18d92bf1b07aac7b2b79037d7ed0c830219fc" translate="yes" xml:space="preserve">
          <source>Adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">将子级规范添加到 &lt;code&gt;supervisor&lt;/code&gt; 并启动该子级。</target>
        </trans-unit>
        <trans-unit id="af3a79b1bbb83ca34755ad54eebe67e43975dc73" translate="yes" xml:space="preserve">
          <source>Adds a new backend.</source>
          <target state="translated">增加了一个新的后台。</target>
        </trans-unit>
        <trans-unit id="4547e3e08756cb2ef5ae23175de234a94738c653" translate="yes" xml:space="preserve">
          <source>Adds a new translator.</source>
          <target state="translated">增加了一个新的翻译器。</target>
        </trans-unit>
        <trans-unit id="9653b7fdeddd56fa913d9c1e6e4dd46142fe6bb5" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将指定的时间量添加到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fefe8eff4657ca8af82a86c4c01dcdded8f65fb" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将指定的时间量添加到&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b33fc73fd1c20e1aa238dde8be82279974905542" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;number&lt;/code&gt; of &lt;code&gt;unit&lt;/code&gt;s to the given &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">增加了 &lt;code&gt;number&lt;/code&gt; 的 &lt;code&gt;unit&lt;/code&gt; s到给定的 &lt;code&gt;time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad9a4469809cf0d6f045e57922aa36fef739da3f" translate="yes" xml:space="preserve">
          <source>Adds the number of days to the given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">将天数与给定 &lt;code&gt;date&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="789089ca60682ff54ac072e501a17b9c7a45b283" translate="yes" xml:space="preserve">
          <source>Adopting a behaviour is straightforward:</source>
          <target state="translated">采用一种行为是直接的。</target>
        </trans-unit>
        <trans-unit id="3aa1232b05d45b3e4a3b9d5865607daf60ef5d9b" translate="yes" xml:space="preserve">
          <source>Adopting behaviours</source>
          <target state="translated">采纳行为</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="9ffdfdf4928b7893065d8f9388d98cfc7e4718e4" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;IO.write/2&lt;/code&gt;, we can see the request sent by the &lt;code&gt;IO&lt;/code&gt; module (a four-elements tuple) printed out. Soon after that, we see that it fails since the &lt;code&gt;IO&lt;/code&gt; module expected some kind of result, which we did not supply.</source>
          <target state="translated">在 &lt;code&gt;IO.write/2&lt;/code&gt; 之后，我们可以看到 &lt;code&gt;IO&lt;/code&gt; 模块（一个四元素元组）发送的请求已打印出来。此后不久，我们发现它失败了，因为 &lt;code&gt;IO&lt;/code&gt; 模块预期会有某种结果，而我们没有提供。</target>
        </trans-unit>
        <trans-unit id="83a04e6c0b27ee981def4e7b4af06e562bbb3d2e" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">编译模块后，使用此模块中的许多功能会引发错误，因为检查运行时数据超出了它们的范围。大部分运行时数据都可以通过附加到每个已编译模块的&lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt;函数进行检查。</target>
        </trans-unit>
        <trans-unit id="6dcdc4f162ba136a3bc34f25783a0a1ec25d1f72" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;shell&lt;/code&gt; becomes the shell that is returned by &lt;a href=&quot;#shell/0&quot;&gt;&lt;code&gt;shell/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;shell&lt;/code&gt; 成为&lt;a href=&quot;#shell/0&quot;&gt; &lt;code&gt;shell/0&lt;/code&gt; &lt;/a&gt;返回的shell。</target>
        </trans-unit>
        <trans-unit id="015771d68b1b737818fe24be939749860bc0bbd0" translate="yes" xml:space="preserve">
          <source>After closing the pair, zero or more ASCII letters can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with &lt;code&gt;sigil_&lt;/code&gt; where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers:</source>
          <target state="translated">关闭该对之后，可以给出零个或多个ASCII字母作为修饰符。标记以表示为sigil_的无条件调用的形式表示，其中第一个参数是字符串的 &lt;code&gt;sigil_&lt;/code&gt; 内容，第二个参数是修饰符的整数列表：</target>
        </trans-unit>
        <trans-unit id="08a92d7d688a663eb3eb033ee1302c04449e9c25" translate="yes" xml:space="preserve">
          <source>After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:</source>
          <target state="translated">在熟悉了语言的基础知识后,您可能想尝试编写简单的程序。这可以通过将以下Elixir代码放到一个文件中来实现。</target>
        </trans-unit>
        <trans-unit id="01d3a5404436a56254e32994bb8c7a88df4d1e46" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Notice the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;port#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">发送完这两条消息后，我们调用了IEx帮助程序 &lt;code&gt;flush()&lt;/code&gt; ，它打印了从端口接收到的所有消息，在本例中，我们返回了&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; world&amp;rdquo;。注意消息是二进制的，因为在&lt;a href=&quot;port#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; 中&lt;/a&gt;打开端口时我们通过了 &lt;code&gt;:binary&lt;/code&gt; 选项。如果没有这样的选择，它将产生一个字节列表。</target>
        </trans-unit>
        <trans-unit id="d8c5a6d820a4e4b08554b8cba7d6f0f399ab90d4" translate="yes" xml:space="preserve">
          <source>After the child specification is retrieved, the fields on &lt;code&gt;overrides&lt;/code&gt; are directly applied on the child spec. If &lt;code&gt;overrides&lt;/code&gt; has keys that do not map to any child specification field, an error is raised.</source>
          <target state="translated">检索子规范后， &lt;code&gt;overrides&lt;/code&gt; 中的字段将直接应用于子规范。如果 &lt;code&gt;overrides&lt;/code&gt; 具有未映射到任何子指定字段的键，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="1e6e228112ef9b4259dcc6e0928e5df6bda71427" translate="yes" xml:space="preserve">
          <source>After the parsing is done, we will update our server to dispatch the parsed commands to the &lt;code&gt;:kv&lt;/code&gt; application we built previously.</source>
          <target state="translated">解析完成后，我们将更新服务器，以将解析的命令分派到我们先前构建的 &lt;code&gt;:kv&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="126c87f3f297e14cbbd86077daaca606cae164a1" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">创建端口后，我们使用&lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt;以消息的形式向其发送了两个命令。第一个命令的二进制有效载荷为&amp;ldquo; hello&amp;rdquo;，第二个命令的&amp;ldquo; world&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1a727cf7abfa15b42a8b410dabb9bf09752b2748" translate="yes" xml:space="preserve">
          <source>After the supervisor retrieves all child specifications, it proceeds to start its children one by one, in the order they were defined, using the information in the &lt;code&gt;:start&lt;/code&gt; key in the child specification. For our current specification, it will call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;.</source>
          <target state="translated">主管检索完所有子级规范后，将使用子级规范中 &lt;code&gt;:start&lt;/code&gt; 键中的信息，按照定义的顺序逐一启动其子级。对于我们当前的规范，它将调用 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ae1d560c6b4b698d633609ab136df680bf93a49" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;list#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">在上述两次导入调用之后，仅&lt;a href=&quot;list#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt;将被导入。</target>
        </trans-unit>
        <trans-unit id="5d98e7e2a0b904bdc0ce797580a3b0c7291ef112" translate="yes" xml:space="preserve">
          <source>After this function is called, &lt;code&gt;port&lt;/code&gt; will be returned by &lt;a href=&quot;#default_port/1&quot;&gt;&lt;code&gt;default_port/1&lt;/code&gt;&lt;/a&gt; for the given scheme &lt;code&gt;scheme&lt;/code&gt;. Note that this function changes the default port for the given &lt;code&gt;scheme&lt;/code&gt;&lt;em&gt;globally&lt;/em&gt;, meaning for every application.</source>
          <target state="translated">调用此函数后，&lt;a href=&quot;#default_port/1&quot;&gt; &lt;code&gt;default_port/1&lt;/code&gt; &lt;/a&gt;将返回给定方案 &lt;code&gt;scheme&lt;/code&gt; 的 &lt;code&gt;port&lt;/code&gt; 。请注意，此函数会&lt;em&gt;全局&lt;/em&gt;更改给定 &lt;code&gt;scheme&lt;/code&gt; 的默认端口，即针对每个应用程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ce2e6f40299204d94dfc0abf19fa8ab52d6c211" translate="yes" xml:space="preserve">
          <source>Agent</source>
          <target state="translated">Agent</target>
        </trans-unit>
        <trans-unit id="64acf7e2a7590f731f683acd7aa2c04794d8cfee" translate="yes" xml:space="preserve">
          <source>Agents</source>
          <target state="translated">Agents</target>
        </trans-unit>
        <trans-unit id="42dff267934990ba61a679256d1501706a0e086a" translate="yes" xml:space="preserve">
          <source>Agents are a simple abstraction around state.</source>
          <target state="translated">代理是一个围绕状态的简单抽象。</target>
        </trans-unit>
        <trans-unit id="471de3b97e03acd6d8c9e778e9edad48b7ff717f" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">代理在客户端和服务器API之间提供隔离（类似于&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;）。特别是，作为参数传递给对&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;函数的调用的函数是在Agent（服务器）内部调用的。这种区别很重要，因为您可能要避免在代理程序内部进行昂贵的操作，因为它们会有效地阻止代理程序，直到满足请求为止。</target>
        </trans-unit>
        <trans-unit id="e95c6b8e92e1e60f6213d7958b0da2f180bb6e84" translate="yes" xml:space="preserve">
          <source>Alias shortcut</source>
          <target state="translated">别名快捷方式</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="d5851935f3ef549bdaa12137353f49d219f63837" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">别名是在编译时扩展为原子的构造。别名&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;扩展为原子 &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 。别名必须以ASCII大写字符开头，后跟任何ASCII字母，数字或下划线。别名不支持非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7f30b783a5f1e139f6a5d96cc53a7d69f34c844f" translate="yes" xml:space="preserve">
          <source>Aliases are expanded (if possible) and return atoms</source>
          <target state="translated">扩展别名(如果可能的话)并返回原子。</target>
        </trans-unit>
        <trans-unit id="4a6b274949d1238578afe2d23ab6b398292dddae" translate="yes" xml:space="preserve">
          <source>Aliases are frequently used to define shortcuts. In fact, calling &lt;code&gt;alias&lt;/code&gt; without an &lt;code&gt;:as&lt;/code&gt; option sets the alias automatically to the last part of the module name, for example:</source>
          <target state="translated">别名通常用于定义快捷方式。实际上，不带 &lt;code&gt;:as&lt;/code&gt; 选项调用 &lt;code&gt;alias&lt;/code&gt; 将自动将别名设置为模块名称的最后一部分，例如：</target>
        </trans-unit>
        <trans-unit id="47bc7db39f959bb0d4762319a37898eaad71d649" translate="yes" xml:space="preserve">
          <source>Aliases are represented by an &lt;code&gt;__aliases__&lt;/code&gt; call with each segment separated by dot as an argument:</source>
          <target state="translated">别名用 &lt;code&gt;__aliases__&lt;/code&gt; 调用表示，每个段用点分隔作为参数：</target>
        </trans-unit>
        <trans-unit id="e23b34bcabd70da598f18dfcddb8220122d3216a" translate="yes" xml:space="preserve">
          <source>Aliases are shortcuts or tasks specific to the current project.</source>
          <target state="translated">别名是针对当前项目的快捷方式或任务。</target>
        </trans-unit>
        <trans-unit id="dc86688ecfcf9059408582f98b57b9f4cbad8152" translate="yes" xml:space="preserve">
          <source>Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example:</source>
          <target state="translated">别名可以非常强大地用于也运行Elixir脚本和shell命令,例如。</target>
        </trans-unit>
        <trans-unit id="6dd7a63c3cd9394fafd3a4d7cedc21c8e943565f" translate="yes" xml:space="preserve">
          <source>Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.</source>
          <target state="translated">在当前项目中定义的别名不影响其依赖关系,在依赖关系中定义的别名不能从当前项目中访问。</target>
        </trans-unit>
        <trans-unit id="abd1a8b6bae9484ed0f8605fb305658910cefe92" translate="yes" xml:space="preserve">
          <source>Aliases expand to atoms because in the Erlang</source>
          <target state="translated">别名扩展为原子,因为在Erlang的</target>
        </trans-unit>
        <trans-unit id="f82ba68692bccb420e6f34813f0fa1ce8af8c883" translate="yes" xml:space="preserve">
          <source>Aliases inside quote are hygienic by default. Consider the following example:</source>
          <target state="translated">引号内的别名默认是卫生的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="fb42d78167a0f8c042ef1bf76a5e556ce9a643e9" translate="yes" xml:space="preserve">
          <source>Aliases may also be lists, specifying multiple tasks to be run consecutively:</source>
          <target state="translated">别名也可以是列表,指定要连续运行的多个任务。</target>
        </trans-unit>
        <trans-unit id="f8d1c898fa93e8bcfa2c17a37c421760581f9672" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常用作模块名称的别名是一个例外，因为它们必须大写并用 &lt;code&gt;CamelCase&lt;/code&gt; 编写，例如&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt;。对于别名，大写字母保留在首字母缩写词中，例如&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="493ad9ebd988ff9d7cf101317d6dd33763da348c" translate="yes" xml:space="preserve">
          <source>All Elixir code runs inside processes that communicate with each other. When a process dies of &amp;ldquo;natural causes&amp;rdquo; (e.g., unhandled exceptions), it sends an &lt;code&gt;exit&lt;/code&gt; signal. A process can also die by explicitly sending an &lt;code&gt;exit&lt;/code&gt; signal:</source>
          <target state="translated">所有的Elixir代码都在相互通信的进程中运行。当进程死于&amp;ldquo;自然原因&amp;rdquo;（例如，未处理的异常）时，它将发送 &lt;code&gt;exit&lt;/code&gt; 信号。也可以通过显式发送 &lt;code&gt;exit&lt;/code&gt; 信号来终止进程：</target>
        </trans-unit>
        <trans-unit id="bc3c548d2fd0d5198604c9d4a51b137d915ab1ca" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again.</source>
          <target state="translated">所有的应用程序都被顺利拿下,所有的代码被卸载,所有的端口被关闭,系统才会再次启动所有的应用程序。</target>
        </trans-unit>
        <trans-unit id="32c3b583cda24a964ba5c0b1c5db5a5180eab7bc" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在系统通过调用&lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt;终止之前，所有应用程序均顺利关闭，所有代码均已卸载，并且所有端口都已关闭。</target>
        </trans-unit>
        <trans-unit id="ea13d46d1a7a005cc3e73f0e566c97f99798c880" translate="yes" xml:space="preserve">
          <source>All arguments, except the first, are guaranteed to be atoms.</source>
          <target state="translated">除第一个参数外,其他参数都保证是原子。</target>
        </trans-unit>
        <trans-unit id="a450b0f803f6ae1fce87a01c5eeb4990d00edaa1" translate="yes" xml:space="preserve">
          <source>All available modes are discussed below.</source>
          <target state="translated">下面将讨论所有可用的模式。</target>
        </trans-unit>
        <trans-unit id="d0506e345cce0be172d12fdeec69c477b8538823" translate="yes" xml:space="preserve">
          <source>All bitwise macros can be used in guards:</source>
          <target state="translated">所有的位元宏都可以在卫士中使用。</target>
        </trans-unit>
        <trans-unit id="7f24df6aca6fef7279aa46c984d854c8399f1b8a" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;logger#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过配置文件（例如 &lt;code&gt;config/config.exs&lt;/code&gt; ）设置以下所有配置，但也可以在运行时通过&lt;a href=&quot;logger#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; &lt;/a&gt;动态更改。</target>
        </trans-unit>
        <trans-unit id="f86cb886460af2d7afbabd4518c2a4ae8d572dd7" translate="yes" xml:space="preserve">
          <source>All configuration for Xref should be placed under the key &lt;code&gt;:xref&lt;/code&gt;.</source>
          <target state="translated">Xref的所有配置都应放在键 &lt;code&gt;:xref&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="7e0d2ee2fbfbf3acfd326c27d7a8c9cdf22d871f" translate="yes" xml:space="preserve">
          <source>All duplicated keys are removed. See &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; for removing only the first entry.</source>
          <target state="translated">删除所有重复的密钥。请参阅&lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt;仅删除第一个条目。</target>
        </trans-unit>
        <trans-unit id="962493e8f49621899a7a8fb10598ca516db9a007" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 中的所有元素都必须可转换为二进制，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="75780da216d4a9fe9a0de4cd507f0ecf910086a9" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">调用 &lt;code&gt;mapper&lt;/code&gt; 返回的所有元素都必须可转换为二进制，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="a81afb8178e29a9385a90fd94857e3690f36f499" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">所有向模板输出内容的表达式都&lt;strong&gt;必须&lt;/strong&gt;使用等号（ &lt;code&gt;=&lt;/code&gt; ）。由于Elixir中的所有内容都是表达式，因此该规则没有例外。例如，虽然某些模板语言将特殊使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;子句，但在EEx中将它们视为相同，并且也需要 &lt;code&gt;=&lt;/code&gt; 才能打印其结果：</target>
        </trans-unit>
        <trans-unit id="64dc310c834981873443bb0c895820130d8003ed" translate="yes" xml:space="preserve">
          <source>All functions in this module accept EEx-related options. They are:</source>
          <target state="translated">本模块中的所有函数都接受与 EEx 相关的选项。它们是:</target>
        </trans-unit>
        <trans-unit id="1f14031fee2bc02634aba88d8e6180547c70d0ae" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;, overriding any existing one (i.e., the keys in &lt;code&gt;map2&lt;/code&gt; &quot;have precedence&quot; over the ones in &lt;code&gt;map1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 中的所有键都将添加到 &lt;code&gt;map1&lt;/code&gt; 中，从而覆盖任何现有的键（即 &lt;code&gt;map2&lt;/code&gt; 中的键&amp;ldquo;具有优先于 &lt;code&gt;map1&lt;/code&gt; 中的键&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="c4382006c46118de92713063dd12ca0d2391ea22" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;. The given function will be invoked when there are duplicate keys; its arguments are &lt;code&gt;key&lt;/code&gt; (the duplicate key), &lt;code&gt;value1&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map1&lt;/code&gt;), and &lt;code&gt;value2&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map2&lt;/code&gt;). The value returned by &lt;code&gt;fun&lt;/code&gt; is used as the value under &lt;code&gt;key&lt;/code&gt; in the resulting map.</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 中的所有键都将添加到 &lt;code&gt;map1&lt;/code&gt; 中。当有重复的键时，将调用给定的函数；它的参数是 &lt;code&gt;key&lt;/code&gt; （重复键）， &lt;code&gt;value1&lt;/code&gt; （价值 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map1&lt;/code&gt; ），和 &lt;code&gt;value2&lt;/code&gt; （价值 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;map2&lt;/code&gt; ）。 &lt;code&gt;fun&lt;/code&gt; 返回的值用作结果映射中 &lt;code&gt;key&lt;/code&gt; 下的值。</target>
        </trans-unit>
        <trans-unit id="81067fca2a4826fa2b861dc9ccff01a040457240" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;, overriding any existing one.</source>
          <target state="translated">&lt;code&gt;keywords2&lt;/code&gt; 给出的所有关键字（包括重复的关键字）都将添加到 &lt;code&gt;keywords1&lt;/code&gt; ，从而覆盖所有现有关键字。</target>
        </trans-unit>
        <trans-unit id="e2c2426bd83d495cefd1511dd9e29d2650392f21" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;. The given function will be invoked to solve conflicts.</source>
          <target state="translated">&lt;code&gt;keywords2&lt;/code&gt; 给出的所有关键字（包括重复的关键字）都将添加到 &lt;code&gt;keywords1&lt;/code&gt; 。给定的函数将被调用以解决冲突。</target>
        </trans-unit>
        <trans-unit id="5e5fd7c77cbce8d2bd6aeafdabf4cfeac9e29a80" translate="yes" xml:space="preserve">
          <source>All modifiers listed above can be combined; repeated modifiers in &lt;code&gt;modifiers&lt;/code&gt; will be ignored.</source>
          <target state="translated">上面列出的所有修饰语都可以组合使用；修饰符中重复的 &lt;code&gt;modifiers&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="c9db69ff5fd80f1c32d968ebb750da1bd96e5703" translate="yes" xml:space="preserve">
          <source>All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that &quot;desugar&quot; to one of the constructs explored above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence.</source>
          <target state="translated">以上所有的构造都是Elixir语法的一部分,并有自己的表示,作为Elixir AST的一部分。本节将讨论其余的构造,这些构造 &quot;去糖 &quot;到上面探讨的其中一个构造。换句话说,下面的构造可以在你的Elixir代码中以一种以上的方式表示,并保留AST的等价性。</target>
        </trans-unit>
        <trans-unit id="efecbd33be6692e33153d5c191da2fd42dffe301" translate="yes" xml:space="preserve">
          <source>All operators in Elixir are also valid atoms. Valid examples are &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:FOO&lt;/code&gt;, &lt;code&gt;:foo_42&lt;/code&gt;, &lt;code&gt;:foo@bar&lt;/code&gt;, and &lt;code&gt;:++&lt;/code&gt;. Invalid examples are &lt;code&gt;:@foo&lt;/code&gt; (&lt;code&gt;@&lt;/code&gt; is not allowed at start), &lt;code&gt;:123&lt;/code&gt; (numbers are not allowed at start), and &lt;code&gt;:(*)&lt;/code&gt; (not a valid operator).</source>
          <target state="translated">Elixir中的所有运算符也是有效原子。有效的示例是 &lt;code&gt;:foo&lt;/code&gt; ， &lt;code&gt;:FOO&lt;/code&gt; ， &lt;code&gt;:foo_42&lt;/code&gt; ， &lt;code&gt;:foo@bar&lt;/code&gt; 和 &lt;code&gt;:++&lt;/code&gt; 。无效的示例包括 &lt;code&gt;:@foo&lt;/code&gt; （在开始处不允许 &lt;code&gt;@&lt;/code&gt; ）、: &lt;code&gt;:123&lt;/code&gt; （在开始处不允许数字）和 &lt;code&gt;:(*)&lt;/code&gt; （无效的运算符）。</target>
        </trans-unit>
        <trans-unit id="a68a6061ed529e7321fbab2a1e1466c173d56718" translate="yes" xml:space="preserve">
          <source>All terms in Elixir can be compared with each other.</source>
          <target state="translated">Elixir的所有术语都可以相互比较。</target>
        </trans-unit>
        <trans-unit id="cd8a32aefda3f349478b8a4289ce78ffc774e378" translate="yes" xml:space="preserve">
          <source>All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests:</source>
          <target state="translated">所有测试都会收到一个上下文作为参数。上下文对于回调和测试之间的信息共享特别有用。</target>
        </trans-unit>
        <trans-unit id="46f1e0081d7ff3ef1598ee1f4611d0858df9a878" translate="yes" xml:space="preserve">
          <source>All tests start with a state of &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">所有测试 &lt;code&gt;nil&lt;/code&gt; 状态开始。</target>
        </trans-unit>
        <trans-unit id="471fbe4680a438c1f34492b7155396825fbf6e7e" translate="yes" xml:space="preserve">
          <source>All the functions in the &lt;code&gt;Enum&lt;/code&gt; module are eager. Many functions expect an enumerable and return a list back:</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 模块中的所有功能都非常渴望。许多函数需要一个可枚举的对象并返回列表：</target>
        </trans-unit>
        <trans-unit id="ad97f344ca26467cc845b62f0e8a053c5eb38fe0" translate="yes" xml:space="preserve">
          <source>All the values of caller functions describe the marked function. For example, the first row means that &lt;code&gt;Mod.caller1/0&lt;/code&gt; invoked &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3 times. 200ms of the total time spent in &lt;code&gt;Mod.some_function/0&lt;/code&gt; was spent processing calls from this particular caller.</source>
          <target state="translated">调用者函数的所有值都描述了标记的函数。例如，第一行表示 &lt;code&gt;Mod.caller1/0&lt;/code&gt; 调用了 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3次。在 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 中花费的总时间中有200毫秒用于处理来自此特定呼叫者的呼叫。</target>
        </trans-unit>
        <trans-unit id="ab62fee1181d53e168d5ddca4b76c2a3f0f14d49" translate="yes" xml:space="preserve">
          <source>All these macros are public macros (as defined by &lt;code&gt;defmacro&lt;/code&gt;).</source>
          <target state="translated">所有这些宏都是公共宏（由 &lt;code&gt;defmacro&lt;/code&gt; 定义）。</target>
        </trans-unit>
        <trans-unit id="34f3030dbffbd799437c8acd75092b93db7172e2" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses.</source>
          <target state="translated">允许在防护条款中使用。</target>
        </trans-unit>
        <trans-unit id="16b8d71f3125091140d0f8672105255771ac2803" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses. Inlined by the compiler.</source>
          <target state="translated">允许在保护子句中使用。由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="translated">允许在防护试验中。</target>
        </trans-unit>
        <trans-unit id="af6c8de133dbdc2f69863328f74fb83aacfb7360" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests. Inlined by the compiler.</source>
          <target state="translated">允许在防护测试中使用。由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="2b173cc6a1f043289cd7c3164ac03625499e4950" translate="yes" xml:space="preserve">
          <source>Allows a developer to customize the using block when the case template is used.</source>
          <target state="translated">允许开发者在使用案例模板时自定义使用块。</target>
        </trans-unit>
        <trans-unit id="ce229aa087121abe44456ef91f4d85fd2c83436e" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;cprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 中对表达式执行 &lt;code&gt;cprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="36e890e59c1727dd986c090acbf3706458233a86" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;eprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 上对表达式执行 &lt;code&gt;eprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="cec7e6385a65f90ce774de5cfa85e6c67d629db7" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;fprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">允许以编程方式在 &lt;code&gt;fun&lt;/code&gt; 中对表达式运行 &lt;code&gt;fprof&lt;/code&gt; 分析器。</target>
        </trans-unit>
        <trans-unit id="9fb76106047518ce4fb611a343f5cfc33db811df" translate="yes" xml:space="preserve">
          <source>Alongside the observer application, Erlang also includes a &lt;code&gt;:crashdump_viewer&lt;/code&gt; to view crash dumps</source>
          <target state="translated">除了观察者应用程序之外，Erlang还包括 &lt;code&gt;:crashdump_viewer&lt;/code&gt; 来查看故障转储。</target>
        </trans-unit>
        <trans-unit id="7b9345037b9e6e5f6f050e0e1c3ba89d21df3bda" translate="yes" xml:space="preserve">
          <source>Alphanumeric characters: &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;</source>
          <target state="translated">字母数字字符： &lt;code&gt;A-Z&lt;/code&gt; ， &lt;code&gt;a-z&lt;/code&gt; ， &lt;code&gt;0-9&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc66c0fdb05c288a2d0be6731b80e56ea10955b8" translate="yes" xml:space="preserve">
          <source>Also note that Erlang&amp;rsquo;s formatting functions require special attention to Unicode handling.</source>
          <target state="translated">还要注意，Erlang的格式化功能需要特别注意Unicode处理。</target>
        </trans-unit>
        <trans-unit id="25e5fdf8b80ad209b572bf379ee2d97f709f491c" translate="yes" xml:space="preserve">
          <source>Also note the &lt;code&gt;async: true&lt;/code&gt; option passed to &lt;code&gt;ExUnit.Case&lt;/code&gt;. This option makes the test case run in parallel with other &lt;code&gt;:async&lt;/code&gt; test cases by using multiple cores in our machine. This is extremely useful to speed up our test suite. However, &lt;code&gt;:async&lt;/code&gt; must &lt;em&gt;only&lt;/em&gt; be set if the test case does not rely on or change any global values. For example, if the test requires writing to the filesystem or access a database, keep it synchronous (omit the &lt;code&gt;:async&lt;/code&gt; option) to avoid race conditions between tests.</source>
          <target state="translated">还要注意传递给 &lt;code&gt;ExUnit.Case&lt;/code&gt; 的 &lt;code&gt;async: true&lt;/code&gt; 选项。通过使用我们计算机中的多个内核，此选项可使测试用例与其他 &lt;code&gt;:async&lt;/code&gt; 测试用例并行运行。这对于加快我们的测试套件非常有用。然而， &lt;code&gt;:async&lt;/code&gt; 必须&lt;em&gt;只&lt;/em&gt;进行，如果测试情况下不依赖于或更改任何全局值设置。例如，如果测试需要写入文件系统或访问数据库，则使其保持同步（忽略 &lt;code&gt;:async&lt;/code&gt; 选项），以避免测试之间的竞争状况。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99f95b6ecaf40ea41137c6dd421e917e63ab648f" translate="yes" xml:space="preserve">
          <source>Also, keep in mind that profiling might significantly increase the running time of the profiled processes. This might skew your results if, for example, those processes perform some I/O operations, since running time of those operations will remain unchanged, while CPU bound operations of the profiled processes might take significantly longer. Thus, when profiling some intensive program, try to reduce such dependencies, or be aware of the resulting bias.</source>
          <target state="translated">此外,请记住,剖析可能会大大增加剖析进程的运行时间。例如,如果这些进程执行了一些I/O操作,这可能会扭曲你的结果,因为这些操作的运行时间将保持不变,而被剖析的进程的CPU绑定操作可能需要更长的时间。因此,在剖析一些密集型程序时,尽量减少这种依赖性,或者注意由此产生的偏差。</target>
        </trans-unit>
        <trans-unit id="92516fadfd2f18efb90c2a6ec6fde01d43c3b8e5" translate="yes" xml:space="preserve">
          <source>Also, note that we started the documentation string using &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt;. The &lt;code&gt;~S&lt;/code&gt; prevents the &lt;code&gt;\r\n&lt;/code&gt; characters from being converted to a carriage return and line feed until they are evaluated in the test.</source>
          <target state="translated">另外请注意，我们开始使用文档字符串 &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt; 。在 &lt;code&gt;~S&lt;/code&gt; 防止 &lt;code&gt;\r\n&lt;/code&gt; 字符被转换为一个回车和换行，直到它们在试验进行评价。</target>
        </trans-unit>
        <trans-unit id="48be7d4f57a1ff8c0c8de01d6b7c49d0f740172b" translate="yes" xml:space="preserve">
          <source>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</source>
          <target state="translated">在同步和异步模式之间交替使用,以便在需要时保持性能,但在压力下也能施加背压。</target>
        </trans-unit>
        <trans-unit id="56a32fedc781d04589b1e27a4190731f2b801a94" translate="yes" xml:space="preserve">
          <source>Alternatively to pattern matching, filters can be used to select some particular elements. For example, we can select the multiples of 3 and discard all others:</source>
          <target state="translated">除了模式匹配,还可以使用过滤器来选择一些特定的元素。例如,我们可以选择3的倍数,而放弃所有其他元素。</target>
        </trans-unit>
        <trans-unit id="738072000214e7dd8d85de9d3d93ddc937487ae4" translate="yes" xml:space="preserve">
          <source>Alternatively, Elixir allows a developer to pass pairs of name/arities to &lt;code&gt;:only&lt;/code&gt; or &lt;code&gt;:except&lt;/code&gt; as a fine grained control on what to import (or not):</source>
          <target state="translated">另外，Elixir允许开发人员将成对的名称/别名传递给 &lt;code&gt;:only&lt;/code&gt; 或 &lt;code&gt;:except&lt;/code&gt; ,作为对导入（或不导入）内容的精细控制：</target>
        </trans-unit>
        <trans-unit id="6f1d115c4cc71092e4215eb5349ece403f7a97dc" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">或者，可以通过传递 &lt;code&gt;stops&lt;/code&gt; 参数来增加停止的数量。&lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt;可用于将数字重置为零。请注意，即使在所有断点上的所有停止都被消耗之后，模块仍处于&amp;ldquo;仪表&amp;rdquo;状态。您可以通过调用&lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt;删除给定模块中的检测，并通过调用&lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; 删除&lt;/a&gt;所有模块中的检测。</target>
        </trans-unit>
        <trans-unit id="7f6b64d93c6e1bd876f47c2efd90152e6697540d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;在您无法控制的给定模块，功能和特性上设置断点。尽管&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;更加灵活，但它不包含有关源代码中的导入和别名的信息。</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="b0a8089f58c0c54576c2250b325fc6b97e8e0b35" translate="yes" xml:space="preserve">
          <source>Alters the current process metadata according the given keyword list.</source>
          <target state="translated">根据给定的关键字列表改变当前进程元数据。</target>
        </trans-unit>
        <trans-unit id="6b160e130daad190a032bd2c82f16a239367a706" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">改变下存储的值 &lt;code&gt;key&lt;/code&gt; 到 &lt;code&gt;value&lt;/code&gt; ，但只有当进入 &lt;code&gt;key&lt;/code&gt; 在已经存在 &lt;code&gt;keywords&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9aed7587419c22040987ccddf36342ed35dbbef" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">将存储在 &lt;code&gt;key&lt;/code&gt; 下的值更改为 &lt;code&gt;value&lt;/code&gt; ，但前提是 &lt;code&gt;map&lt;/code&gt; 中已经存在输入 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="375d49ba0682b4200a357c23af57a8fe3e771407" translate="yes" xml:space="preserve">
          <source>Although Elixir includes specific functions such as &lt;code&gt;tuple_size&lt;/code&gt;, &lt;code&gt;binary_size&lt;/code&gt; and &lt;code&gt;map_size&lt;/code&gt;, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:</source>
          <target state="translated">尽管Elixir包含诸如 &lt;code&gt;tuple_size&lt;/code&gt; ， &lt;code&gt;binary_size&lt;/code&gt; 和 &lt;code&gt;map_size&lt;/code&gt; 之类的特定功能，但有时我们希望能够检索数据结构的大小而不管其类型如何。在Elixir中，我们可以使用协议编写多态代码，即适用于不同形状/类型的代码。大小协议可以实现如下：</target>
        </trans-unit>
        <trans-unit id="271db6153eba80f48b3cb5615c2c7cf2befa189f" translate="yes" xml:space="preserve">
          <source>Although Mix generates and maintains the &lt;code&gt;.app&lt;/code&gt; file for us, we can customize its contents by adding new entries to the &lt;code&gt;application/0&lt;/code&gt; function inside the &lt;code&gt;mix.exs&lt;/code&gt; project file. We are going to do our first customization soon.</source>
          <target state="translated">尽管Mix 为我们生成并维护了 &lt;code&gt;.app&lt;/code&gt; 文件，但我们可以通过在 &lt;code&gt;mix.exs&lt;/code&gt; 项目文件内的 &lt;code&gt;application/0&lt;/code&gt; 函数中添加新条目来自定义其内容。我们将很快进行首次定制。</target>
        </trans-unit>
        <trans-unit id="b17471efb7e8b7966f0aa39356cf0b8489d5f43b" translate="yes" xml:space="preserve">
          <source>Although code points could be represented as integers, this module represents all code points as strings. For example:</source>
          <target state="translated">虽然代码点可以用整数表示,但本模块将所有代码点表示为字符串。例如:</target>
        </trans-unit>
        <trans-unit id="14fda69fb3ca698206ce8ef9fa7ae0f578b2ed83" translate="yes" xml:space="preserve">
          <source>Although doing so is not recommended as it may affect your test suite performance.</source>
          <target state="translated">虽然不建议这样做,因为它可能会影响你的测试套件性能。</target>
        </trans-unit>
        <trans-unit id="7089c4bbd915ddfe4f12d574def40357ae4ad792" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">尽管通常会避免使用不正确的列表，但是它们会在某些特殊情况下使用，例如iodata和chardata实体（请参见&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块）。</target>
        </trans-unit>
        <trans-unit id="1fac951d9acd827630fc984ba5e390c89493d219" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;genserver#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">尽管在上面的示例中，我们已经使用&lt;a href=&quot;genserver#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt;和朋友直接启动服务器并与服务器进行通信，但是在大多数情况下，我们并不直接调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;函数。相反，我们将调用包装在代表服务器公共API的新函数中。</target>
        </trans-unit>
        <trans-unit id="05cad5e03ed101afeda99f24e9baf0f87a53f9f2" translate="yes" xml:space="preserve">
          <source>Although our tests pass, our testing structure is getting more complex. In particular, running tests with only &lt;code&gt;mix test&lt;/code&gt; causes failures in our suite, since our test requires a connection to another node.</source>
          <target state="translated">尽管我们的测试通过了，但我们的测试结构却变得越来越复杂。特别是，仅使用 &lt;code&gt;mix test&lt;/code&gt; 运行测试会导致我们的套件失败，因为我们的测试需要连接到另一个节点。</target>
        </trans-unit>
        <trans-unit id="ff729d77091a6064c1d998a90b46541e7d7f75c9" translate="yes" xml:space="preserve">
          <source>Although pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:</source>
          <target state="translated">虽然模式匹配可以让我们建立强大的构造,但它的使用是有限的。例如,你不能在匹配的左侧进行函数调用。下面的例子是无效的。</target>
        </trans-unit>
        <trans-unit id="e1d430d2d6fb0548beb47e18ecfea58c354f9cde" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">尽管结构是映射，但默认情况下，结构不实现为映射实现的任何协议。检查&lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt;以获取有关如何将结构与多态调度协议一起使用的更多信息。有关如何动态创建和更新结构的示例，另请参见&lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;kernel#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="870fe0c59e3d007685ea9833cb1390f52f0e514b" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the &lt;code&gt;User&lt;/code&gt; struct leads to an error:</source>
          <target state="translated">尽管结构是映射，但默认情况下，结构不实现为映射实现的任何协议。例如，尝试将协议与 &lt;code&gt;User&lt;/code&gt; 结构一起使用会导致错误：</target>
        </trans-unit>
        <trans-unit id="431f21d40dbb5403d9bd326700ba842d9364814b" translate="yes" xml:space="preserve">
          <source>Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute &lt;code&gt;:spawn_executable&lt;/code&gt;.</source>
          <target state="translated">尽管上面的方法很方便，但是这意味着无法调用名称或参数中带有空格的可执行文件。由于这些原因，大多数时候最好执行 &lt;code&gt;:spawn_executable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fb3fdd978f27b5125e369d37a21e919df537b80" translate="yes" xml:space="preserve">
          <source>Although the directory can be accessed as &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">尽管可以通过 &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt; 来访问目录，但是此宏是一种方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="08556dd674acbaa5235d5a6dd7ba968777f84148" translate="yes" xml:space="preserve">
          <source>Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!</source>
          <target state="translated">虽然最终的结果是一样的,但打印元素的顺序却发生了变化!对于流,我们打印第一个元素,然后打印它的双倍。对于流,我们打印第一个元素,然后打印它的双倍。在这个例子中,列表只列举了一次!</target>
        </trans-unit>
        <trans-unit id="34317ca951c3b1fca45985dcc2015a9c9f8ee491" translate="yes" xml:space="preserve">
          <source>Although the example above is made of two characters, it is perceived by users as one.</source>
          <target state="translated">虽然上面的例子是由两个字符组成的,但却被用户认为是一个字符。</target>
        </trans-unit>
        <trans-unit id="a4ac7eba93e375ca0b8410e005578a589bad8a11" translate="yes" xml:space="preserve">
          <source>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;full&lt;/code&gt; strings, then slice the &lt;code&gt;full&lt;/code&gt; one, traversing it again.</source>
          <target state="translated">尽管上面的功能有效，但性能较差。为了计算字符串的长度，我们需要充分穿越它，所以我们遍历都 &lt;code&gt;prefix&lt;/code&gt; 和 &lt;code&gt;full&lt;/code&gt; 的字符串，然后切片的 &lt;code&gt;full&lt;/code&gt; 一个，再次穿越它。</target>
        </trans-unit>
        <trans-unit id="2ad64b2ae9d7779aeafe9f53ba81c4ac6a8c3bcb" translate="yes" xml:space="preserve">
          <source>Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of &lt;code&gt;0&lt;/code&gt;. That's one of the reasons why &lt;code&gt;@fallback_to_any&lt;/code&gt; is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour.</source>
          <target state="translated">尽管上面的实现可以说是不合理的。例如，说PID或整数的大小为 &lt;code&gt;0&lt;/code&gt; 毫无意义。这就是 &lt;code&gt;@fallback_to_any&lt;/code&gt; 是一种选择行为的原因之一。对于大多数协议，当未实现协议时引发错误是正确的行为。</target>
        </trans-unit>
        <trans-unit id="2d80e43bdc8417d6590a2fd8779a42e453b4510f" translate="yes" xml:space="preserve">
          <source>Although the module can be accessed in the &lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">尽管可以在&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;访问该模块，但此宏是方便的快捷方式。</target>
        </trans-unit>
        <trans-unit id="523bba024fe01ece815e7c56ce1e3c3d7d5ff12a" translate="yes" xml:space="preserve">
          <source>Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections.</source>
          <target state="translated">虽然上一节可以概括为 &quot;避免宏&quot;,但这两个主题都很重要,值得单独开一节。</target>
        </trans-unit>
        <trans-unit id="8a45380bdb24cc0394ac693565319d64e7fe3702" translate="yes" xml:space="preserve">
          <source>Although this chapter was the first time we implemented a supervisor, it was not the first time we used one! In the previous chapter, when we used &lt;code&gt;start_supervised!&lt;/code&gt; to start the registry during our tests, &lt;code&gt;ExUnit&lt;/code&gt; started the registry under a supervisor managed by the ExUnit framework itself. By defining our own supervisor, we provide more structure on how we initialize, shutdown and supervise processes in our applications, aligning our production code and tests with best practices.</source>
          <target state="translated">尽管本章是我们第一次配置主管，但这并不是我们第一次使用监督员！在上一章中，当我们使用 &lt;code&gt;start_supervised!&lt;/code&gt; 为了在测试期间启动注册表， &lt;code&gt;ExUnit&lt;/code&gt; 在由ExUnit框架本身管理的主管下启动了注册表。通过定义自己的主管，我们提供了更多有关如何初始化，关闭和监督应用程序中的流程，使生产代码和测试与最佳实践保持一致的结构。</target>
        </trans-unit>
        <trans-unit id="3c9f4ae19a7eeeab2983d7dec1f1792d10b1c1ba" translate="yes" xml:space="preserve">
          <source>Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions. Binaries are already represented by the underlying bytes and as such their representation is always &amp;ldquo;raw&amp;rdquo;.</source>
          <target state="translated">尽管这是一个细微的差别，但是如果您打算将列表传递给这些功能，则只需担心这些细节。二进制文件已经由底层字节表示，因此它们的表示始终为&amp;ldquo;原始&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="84c3d8b250459ad3c47db87432253967c9d495f1" translate="yes" xml:space="preserve">
          <source>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</source>
          <target state="translated">虽然我们可以在关键词列表上进行模式匹配,但由于列表上的模式匹配需要匹配的项目数量和顺序,所以实际操作中很少进行。</target>
        </trans-unit>
        <trans-unit id="1624e83a6f323b5d4e4763fd7f94a95a8d4f3768" translate="yes" xml:space="preserve">
          <source>Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:</source>
          <target state="translated">虽然我们希望绝大多数程序能够随着时间的推移而保持兼容,但不可能保证未来的任何更改都不会破坏任何程序。在一些不太可能的情况下,我们可能会引入会破坏现有代码的更改。</target>
        </trans-unit>
        <trans-unit id="2b17a13f88c530e5861a53d56146266cecae866f" translate="yes" xml:space="preserve">
          <source>Although we have overlooked some details, this is the main idea behind creating domain-specific modules in Elixir. Macros enable us to return quoted expressions that are executed in the caller, which we can then use to transform code and store relevant information in the target module via module attributes. Finally, callbacks such as &lt;code&gt;@before_compile&lt;/code&gt; allow us to inject code into the module when its definition is complete.</source>
          <target state="translated">尽管我们忽略了一些细节，但这是在Elixir中创建特定于域的模块的主要思想。宏使我们能够返回在调用程序中执行的带引号的表达式，然后我们可以使用它们来转换代码，并通过模块属性将相关信息存储在目标模块中。最后，诸如 &lt;code&gt;@before_compile&lt;/code&gt; 之类的回调使我们可以在其定义完成时将代码注入模块。</target>
        </trans-unit>
        <trans-unit id="3359c56da801ba4eef5b9504bfbf16ddf4e8ca4b" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;:ok&lt;/code&gt; and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; to read more about the &quot;owner&quot;.</source>
          <target state="translated">始终返回 &lt;code&gt;:ok&lt;/code&gt; ，如果没有更多与当前进程关联的键，则自动取消当前进程与所有者的链接。另请参阅&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt;以了解有关&amp;ldquo;所有者&amp;rdquo;的更多信息。</target>
        </trans-unit>
        <trans-unit id="72c0244fa532d1e23d46ac34ccb91bfb72ffc273" translate="yes" xml:space="preserve">
          <source>Ambiguous function/macro names</source>
          <target state="translated">含糊不清的函数/宏名称</target>
        </trans-unit>
        <trans-unit id="a049ff1aa2d29c7c72357b2f704f3d8dea2f8d78" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use Agent&lt;/code&gt;, it automatically defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do:</source>
          <target state="translated">一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt;是一个监督树下最常用的开始。调用 &lt;code&gt;use Agent&lt;/code&gt; 时，它会自动定义&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;函数，该函数使我们可以直接在主管下启动代理。要在初始计数器为0的主管下启动座席，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="0cd52ac6bbd448008fc9991be40af1235993cec9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">一个&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;如果填充是不正确或非字母表字符存在于串中引发异常。</target>
        </trans-unit>
        <trans-unit id="e7f62694e798684b6b70596713962c709a802b67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">一个&lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt;同时实现了&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;，允许它被用于读取和写入。</target>
        </trans-unit>
        <trans-unit id="afe086c320e6384512964bd01dec4f5547e66922" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;after&lt;/code&gt; clause allows you to define cleanup logic that will be invoked both when the block of code passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the &lt;code&gt;after&lt;/code&gt; clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</source>
          <target state="translated">一个 &lt;code&gt;after&lt;/code&gt; 子句允许定义当代码块传递给将被调用二者清理逻辑&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;时引发错误成功，并且也。请注意，当接收到退出信号导致该过程突然退出时，该过程将照常退出，因此不能保证 &lt;code&gt;after&lt;/code&gt; 子句被执行。幸运的是，Elixir中的大多数资源（例如打开的文件，ETS表，端口，套接字等）都链接到或监视拥有的进程，如果该进程退出，它们将自动清理自身。</target>
        </trans-unit>
        <trans-unit id="d9b71baa3ec4aca419614eb83a6884fce9738af0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to modify what is being returned from &lt;code&gt;with&lt;/code&gt; in the case of a failed match:</source>
          <target state="translated">一个 &lt;code&gt;else&lt;/code&gt; 可以给选项来修改什么被从返回 &lt;code&gt;with&lt;/code&gt; 一个失败的比赛的情况下：</target>
        </trans-unit>
        <trans-unit id="ff7e359bf597a6fd9ce8084d91ed80c5b7ad85f6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to specify the opposite:</source>
          <target state="translated">可以使用 &lt;code&gt;else&lt;/code&gt; 选项指定相反的内容：</target>
        </trans-unit>
        <trans-unit id="e95cabc5495eb242ab85459b1aeff5cf96a48942" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">从此调用返回的 &lt;code&gt;io_device&lt;/code&gt; 可用作&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;模块功能的参数。</target>
        </trans-unit>
        <trans-unit id="f97b9473a3f0b32057fd9dcd3bc6ae93dc6f50c3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;edit script&lt;/em&gt; is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring &lt;code&gt;list1&lt;/code&gt; closer to being equal to &lt;code&gt;list2&lt;/code&gt;; a key can be &lt;code&gt;:eq&lt;/code&gt;, &lt;code&gt;:ins&lt;/code&gt;, or &lt;code&gt;:del&lt;/code&gt;. Each value is a sublist of either &lt;code&gt;list1&lt;/code&gt; or &lt;code&gt;list2&lt;/code&gt; that should be inserted (if the corresponding key &lt;code&gt;:ins&lt;/code&gt;), deleted (if the corresponding key is &lt;code&gt;:del&lt;/code&gt;), or left alone (if the corresponding key is &lt;code&gt;:eq&lt;/code&gt;) in &lt;code&gt;list1&lt;/code&gt; in order to be closer to &lt;code&gt;list2&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;编辑的脚本&lt;/em&gt;是一个关键词列表。每个键描述为使 &lt;code&gt;list1&lt;/code&gt; 更接近于 &lt;code&gt;list2&lt;/code&gt; 而采取的&amp;ldquo;编辑动作&amp;rdquo; ；键可以是 &lt;code&gt;:eq&lt;/code&gt; ， &lt;code&gt;:ins&lt;/code&gt; 或 &lt;code&gt;:del&lt;/code&gt; 。每个值都是 &lt;code&gt;list1&lt;/code&gt; 或 &lt;code&gt;list2&lt;/code&gt; 的子列表，应按顺序在 &lt;code&gt;list1&lt;/code&gt; 中插入（如果对应的键 &lt;code&gt;:ins&lt;/code&gt; ），删除（如果对应的键是 &lt;code&gt;:del&lt;/code&gt; ）或单独放置（如果对应的键是 &lt;code&gt;:eq&lt;/code&gt; ）。接近 &lt;code&gt;list2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b968d4ec51b4353a379f80bf32b0dc9347be2642" translate="yes" xml:space="preserve">
          <source>An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:</source>
          <target state="translated">IO设备可以是一个原子或PID。如果是原子,原子必须是注册进程的名称。此外,Elixir还提供了两个快捷方式。</target>
        </trans-unit>
        <trans-unit id="d60cf8ae86edc9af73dfcd3cc01f5bc137486aa4" translate="yes" xml:space="preserve">
          <source>An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named &lt;code&gt;:sample&lt;/code&gt; and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction:</source>
          <target state="translated">代理可以通过简单地将模块，函数和参数元组传递给更新指令来实时热交换其代码。例如，假设您有一个名为 &lt;code&gt;:sample&lt;/code&gt; 的代理，并且想要将其内部状态从关键字列表转换为地图。可以通过以下指令完成：</target>
        </trans-unit>
        <trans-unit id="b354895b4d9f46ba32dcc5d6d21ad6dbac64a90c" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">代理绑定到与GenServers相同的名称注册规则。在&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;文档中阅读有关它的更多信息。</target>
        </trans-unit>
        <trans-unit id="2d060fe1a8daedc42f287a49cf8e64646cafb9fe" translate="yes" xml:space="preserve">
          <source>An alias in Elixir is a capitalized identifier (like &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Keyword&lt;/code&gt;, etc) which is converted to an atom during compilation. For instance, the &lt;code&gt;String&lt;/code&gt; alias translates by default to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;:</source>
          <target state="translated">Elixir中的别名是一个大写的标识符（例如 &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Keyword&lt;/code&gt; 等），该标识符在编译期间会转换为原子。例如， &lt;code&gt;String&lt;/code&gt; 别名默认情况下转换为原子 &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f1c5142518fdf011cadf3f17245bcd8f2a562ce8" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and lifecycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;.</source>
          <target state="translated">应用程序是实现某些特定功能的组件，具有标准化的目录结构，配置和生命周期。应用程序已&lt;em&gt;加载&lt;/em&gt;，&lt;em&gt;启动&lt;/em&gt;和&lt;em&gt;停止&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e3fcb6166c3639e8ba7a2f7130be093979e1d4e4" translate="yes" xml:space="preserve">
          <source>An atom is a constant whose value is its own name. Some other languages call these symbols. They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">原子是一个常量,其值是自己的名字。其他一些语言将这些符号称为原子。它们通常用于列举不同的值,例如:</target>
        </trans-unit>
        <trans-unit id="86fb449cced27f4191bdd440f9d6ef1683f1583a" translate="yes" xml:space="preserve">
          <source>An attempt to call a macro that was not loaded will raise an error.</source>
          <target state="translated">试图调用一个未加载的宏会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="be3bd9f0eca00ecaf433384dd9dcab4453a5b9a4" translate="yes" xml:space="preserve">
          <source>An easy way to do so is by sending a synchronous request to the registry before we do the bucket lookup. The &lt;code&gt;Agent.stop/2&lt;/code&gt; operation is synchronous and only returns after the bucket process terminates and all &lt;code&gt;:DOWN&lt;/code&gt; messages are delivered. Therefore, once &lt;code&gt;Agent.stop/2&lt;/code&gt; returns, the registry has already received the &lt;code&gt;:DOWN&lt;/code&gt; message but it may not have processed it yet. In order to guarantee the processing of the &lt;code&gt;:DOWN&lt;/code&gt; message, we can do a synchronous request. Since messages are processed in order, once the registry replies to the synchronous request, then the &lt;code&gt;:DOWN&lt;/code&gt; message will definitely have been processed.</source>
          <target state="translated">一种简单的方法是在执行存储桶查找之前，向注册表发送同步请求。所述 &lt;code&gt;Agent.stop/2&lt;/code&gt; 操作是同步的，并且只有铲斗过程终止和所有后返回 &lt;code&gt;:DOWN&lt;/code&gt; 邮件传递。因此，一旦 &lt;code&gt;Agent.stop/2&lt;/code&gt; 返回，注册表就已经收到了 &lt;code&gt;:DOWN&lt;/code&gt; 消息，但它可能尚未处理它。为了保证处理 &lt;code&gt;:DOWN&lt;/code&gt; 消息，我们可以执行一个同步请求。由于消息是按顺序处理的，因此一旦注册表回复了同步请求，则 &lt;code&gt;:DOWN&lt;/code&gt; 消息肯定会被处理。</target>
        </trans-unit>
        <trans-unit id="bc95a79f72a6064f19e08b29349826dd25b216ee" translate="yes" xml:space="preserve">
          <source>An empty list can be passed to avoid stacktrace printing.</source>
          <target state="translated">可以通过一个空列表来避免堆栈跟踪打印。</target>
        </trans-unit>
        <trans-unit id="276e3d577cef8507d9164a96e53206098957da90" translate="yes" xml:space="preserve">
          <source>An empty list if there is no match.</source>
          <target state="translated">如果没有匹配,则为空列表。</target>
        </trans-unit>
        <trans-unit id="f6764a9eb225a20637ece5e74ca6e79cd54f249b" translate="yes" xml:space="preserve">
          <source>An empty list will be returned if there is no match.</source>
          <target state="translated">如果没有匹配,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="2c7a57e0b595be7bebd781fac5740e7fc7f12ace" translate="yes" xml:space="preserve">
          <source>An empty string will always match:</source>
          <target state="translated">一个空的字符串将总是匹配。</target>
        </trans-unit>
        <trans-unit id="bb794abcdf1956bbd61a3d6b9cb82432c85ee4f0" translate="yes" xml:space="preserve">
          <source>An empty suffix will always match:</source>
          <target state="translated">空后缀总是会匹配的。</target>
        </trans-unit>
        <trans-unit id="bc88b4de65545bb70648538e7fb3eb0cf86cc242" translate="yes" xml:space="preserve">
          <source>An engine may also &lt;code&gt;use EEx.Engine&lt;/code&gt; to get the default behaviour but this is not advised. In such cases, if any of the callbacks are overridden, they must call &lt;code&gt;super()&lt;/code&gt; to delegate to the underlying &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;EEx.Engine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引擎也可以 &lt;code&gt;use EEx.Engine&lt;/code&gt; 来获取默认行为，但是不建议这样做。在这种情况下，如果重写了任何回调，则它们必须调用 &lt;code&gt;super()&lt;/code&gt; 委派给基础&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;EEx.Engine&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2319178933b7fc280516f48198d763f0d06241ea" translate="yes" xml:space="preserve">
          <source>An engine needs to implement all callbacks below.</source>
          <target state="translated">一个引擎需要实现下面所有的回调。</target>
        </trans-unit>
        <trans-unit id="7d57834eea31257f109e7c789d7d41f86df67542" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a list:</source>
          <target state="translated">如果被访问的结构不是一个列表,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="5f8f5a5cd7e9dceea4cbf840417ae0c08edc2e95" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map or a struct:</source>
          <target state="translated">如果访问的结构不是映射或结构体,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="50fb59be68cf5f14388edcb66f9d042d984c8dde" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map/struct:</source>
          <target state="translated">如果被访问的结构不是一个地图/结构,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="55f9d11748bcf3c144604b93c6b2ae25f8aeccb1" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a tuple:</source>
          <target state="translated">如果访问的结构不是一个元组,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="de94d63a6d219c4ead87b23e065fc7de46de12f5" translate="yes" xml:space="preserve">
          <source>An error is raised if the predicate is not a function or is of the incorrect arity:</source>
          <target state="translated">如果谓词不是函数或者是不正确的数组,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="8b078cb3fc34c37337f004467d0ce9378efe754a" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">发生错误，将通过与&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;不同的机制来处理。这种方法可能涉及延迟尝试重新启动后调用&lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee6f2f4da896a18384f200b0e36a0f349ec99076" translate="yes" xml:space="preserve">
          <source>An escript is an executable that can be invoked from the command line. An escript can run on any machine that has Erlang/OTP installed and by default does not require Elixir to be installed, as Elixir is embedded as part of the escript.</source>
          <target state="translated">escript是可以从命令行调用的可执行文件。escript可以在任何安装了Erlang/OTP的机器上运行,默认情况下不需要安装Elixir,因为Elixir被嵌入到escript中。</target>
        </trans-unit>
        <trans-unit id="21ae8235dad3d0eb05c1b7a4b8d8a02b347ddf84" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;code#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">不能手动修改&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;的实例。如果您需要创建一个自定义环境以传递给&lt;a href=&quot;code#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt;，请使用以下技巧：</target>
        </trans-unit>
        <trans-unit id="dd8bc729544e66eee698242f46c5404236f10a6e" translate="yes" xml:space="preserve">
          <source>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of &lt;code&gt;:io.columns&lt;/code&gt;. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</source>
          <target state="translated">一个整数，指示要在输出中使用的最大列数。默认值为80列。实际输出宽度是该数字和 &lt;code&gt;:io.columns&lt;/code&gt; 结果的最小值。这样，您可以将IEx配置为最大的屏幕尺寸，并且它应始终占据当前终端屏幕的整个宽度。</target>
        </trans-unit>
        <trans-unit id="62dfd3ff7081b119a8a16043b2a10c06d4c45481" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;after&lt;/code&gt; clause can be given in case the message was not received after the given timeout period, specified in milliseconds:</source>
          <target state="translated">如果在指定的超时时间（以毫秒为单位）内未收到消息，则可以提供可选的 &lt;code&gt;after&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="509d438b27e12dd94c38e2a190b7ee190fb17b57" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; to the corresponding integer can be provided. If &lt;code&gt;base&lt;/code&gt; is not given, 10 will be used.</source>
          <target state="translated">可以提供相应整数的可选 &lt;code&gt;base&lt;/code&gt; 。如果没有给出 &lt;code&gt;base&lt;/code&gt; ，将使用10。</target>
        </trans-unit>
        <trans-unit id="bda79df01bfb65a34e0eb465b572e1c22d155d69" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the &lt;code&gt;digits&lt;/code&gt;. Base has to be an integer greater than or equal to &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">可以提供一个可选的 &lt;code&gt;base&lt;/code&gt; 值，代表 &lt;code&gt;digits&lt;/code&gt; 的基数。基数必须是大于或等于 &lt;code&gt;2&lt;/code&gt; 的整数。</target>
        </trans-unit>
        <trans-unit id="5139348d1208b18f1412d9ff5406b136dc7222e8" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the returned digits. This one must be an integer &amp;gt;= 2.</source>
          <target state="translated">可以提供一个可选的 &lt;code&gt;base&lt;/code&gt; 值，代表返回数字的基数。这个必须是大于等于2的整数。</target>
        </trans-unit>
        <trans-unit id="68a979cd20856e6e7b0398abc497d56ec40c554a" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will be emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">可以传递一个可选的布尔参数来启用或禁用发出实际的ANSI代码。如果为 &lt;code&gt;false&lt;/code&gt; ，则不会发出ANSI代码。默认情况下，检查是否使用&lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt;功能启用了ANSI 。</target>
        </trans-unit>
        <trans-unit id="141cb8c089b77fc45a4b599501be2124087d63c3" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">可以传递一个可选的布尔参数来启用或禁用发出实际的ANSI代码。如果为 &lt;code&gt;false&lt;/code&gt; ，则不会发出ANSI代码。默认情况下，检查是否使用&lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt;功能启用了ANSI 。</target>
        </trans-unit>
        <trans-unit id="670e0435cab9da74bff554f172d6191175f5b29a" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;kernel#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">懒惰定义了一个可覆盖的函数，允许开发人员对其进行自定义。有关更多信息和文档，请参见&lt;a href=&quot;kernel#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f06ca58408ebbb2e2d18da83ab38dd0e2381bfd3" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to override it.</source>
          <target state="translated">一个可覆盖的函数被懒得定义,允许开发人员覆盖它。</target>
        </trans-unit>
        <trans-unit id="735f79f261a0a1398e39bb2ba9f23bdd5b445481" translate="yes" xml:space="preserve">
          <source>An unknown key:</source>
          <target state="translated">一个未知的钥匙。</target>
        </trans-unit>
        <trans-unit id="4eb360277b153c599c984a044f3a3b8d7442bbcf" translate="yes" xml:space="preserve">
          <source>An update operation specific for structs is also available:</source>
          <target state="translated">此外,还提供了针对结构的更新操作。</target>
        </trans-unit>
        <trans-unit id="dbebd5f66bf57539f1cae5d05912dfd58e43605d" translate="yes" xml:space="preserve">
          <source>Ancestor and Caller Tracking</source>
          <target state="translated">祖先和来电追踪</target>
        </trans-unit>
        <trans-unit id="4bf59e857bc43e008d05f39c6798933eabe92a7b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;:greek&lt;/code&gt; properly handles the context sensitive sigma in Greek:</source>
          <target state="translated">和 &lt;code&gt;:greek&lt;/code&gt; 正确处理希腊语中上下文相关的sigma：</target>
        </trans-unit>
        <trans-unit id="57f523660878f0ae5422d81e21ff0f2d992fab43" translate="yes" xml:space="preserve">
          <source>And also in umbrella dependencies:</source>
          <target state="translated">而且还在伞形依赖中。</target>
        </trans-unit>
        <trans-unit id="7475479141d0c8752fe853a18f88400575acc441" translate="yes" xml:space="preserve">
          <source>And also when comparing different types:</source>
          <target state="translated">而且在比较不同类型的时候,也。</target>
        </trans-unit>
        <trans-unit id="ddcbca0482883ea8e4091eaadee210a79869f2e4" translate="yes" xml:space="preserve">
          <source>And execute it as:</source>
          <target state="translated">并将其执行为。</target>
        </trans-unit>
        <trans-unit id="419827a34eea4ec811bd9357533fc68ae720c124" translate="yes" xml:space="preserve">
          <source>And finally successfully boot it:</source>
          <target state="translated">并最终成功启动。</target>
        </trans-unit>
        <trans-unit id="72688afe4af65ced53cacec5689d360d88950fb2" translate="yes" xml:space="preserve">
          <source>And here is an example of how you can define &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; from the above configuration:</source>
          <target state="translated">这是一个示例，说明如何从上述配置中定义 &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f0d1bd4c59aaee11683223b356559849183e2699" translate="yes" xml:space="preserve">
          <source>And it then returned a quoted expression as follows:</source>
          <target state="translated">然后它返回了一个引用的表达式,如下所示。</target>
        </trans-unit>
        <trans-unit id="e0b5f0362b86f72e75548b22466dd13d5a1cf84b" translate="yes" xml:space="preserve">
          <source>And it will provide the same behaviour. You may use &lt;code&gt;do:&lt;/code&gt; for one-liners but always use &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; for functions spanning multiple lines.</source>
          <target state="translated">并且它将提供相同的行为。您可以将 &lt;code&gt;do:&lt;/code&gt; 用于单行，但始终将 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 用于跨越多行的函数。</target>
        </trans-unit>
        <trans-unit id="a3be6c2d0cb8b49833135e767d2d7a4fbac9b3c5" translate="yes" xml:space="preserve">
          <source>And it works!</source>
          <target state="translated">而且还能用!</target>
        </trans-unit>
        <trans-unit id="e5ff9d5b10d267dee51c69e79f2c679b450ef8f6" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s connect to it and issue a request in another terminal:</source>
          <target state="translated">然后连接到它并在另一个终端中发出请求：</target>
        </trans-unit>
        <trans-unit id="aef6f548c63d313f3e6febdf170c4b53e23d4948" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s try to start our application again:</source>
          <target state="translated">让我们尝试再次启动我们的应用程序：</target>
        </trans-unit>
        <trans-unit id="0a3e48a60746f6b847d997fa0fbe9c121a13a5e1" translate="yes" xml:space="preserve">
          <source>And more</source>
          <target state="translated">还有更多</target>
        </trans-unit>
        <trans-unit id="3975c92bca370daedd767ed422d2ad2a60b72331" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it once more:</source>
          <target state="translated">现在让我们再次组装它：</target>
        </trans-unit>
        <trans-unit id="d14e640d4bda56647f06d50190912bc628cfe672" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it:</source>
          <target state="translated">现在让我们组装它：</target>
        </trans-unit>
        <trans-unit id="450675268dca95ea69df946fd7052040689b26b5" translate="yes" xml:space="preserve">
          <source>And now run tests with:</source>
          <target state="translated">而现在运行测试与。</target>
        </trans-unit>
        <trans-unit id="91c1d6064e2642eec275bb2697301c83bf002443" translate="yes" xml:space="preserve">
          <source>And play a bit with agents:</source>
          <target state="translated">还跟代理商玩了一下。</target>
        </trans-unit>
        <trans-unit id="2dadb42bf111f89bf23b4940e02183ac02eb51a8" translate="yes" xml:space="preserve">
          <source>And play with those definitions:</source>
          <target state="translated">而玩这些定义。</target>
        </trans-unit>
        <trans-unit id="16ce5c350460be5d7d537d13e7f1131d9b8fad50" translate="yes" xml:space="preserve">
          <source>And the variable can be defined in the match itself (prior to its use):</source>
          <target state="translated">而变量可以在匹配本身中定义(在使用之前)。</target>
        </trans-unit>
        <trans-unit id="0e8b021dea943d8ac4bd67ab292eb615322244df" translate="yes" xml:space="preserve">
          <source>And then a module may use it as:</source>
          <target state="translated">然后一个模块可以把它作为。</target>
        </trans-unit>
        <trans-unit id="a9c544212c0f62fab7a929bdf6254c14ee92c57a" translate="yes" xml:space="preserve">
          <source>And then passing it to the supervisor:</source>
          <target state="translated">然后传给主管。</target>
        </trans-unit>
        <trans-unit id="75d0f7371704fa5ce1ab31b056a3610c4f01dd6d" translate="yes" xml:space="preserve">
          <source>And then start it:</source>
          <target state="translated">然后启动它。</target>
        </trans-unit>
        <trans-unit id="46195fee28b6f3924859b2e05c7f84e26d2f56e8" translate="yes" xml:space="preserve">
          <source>And then you can define the implementations specific to the test environment inside &lt;code&gt;test/support/some_file.ex&lt;/code&gt;.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;test/support/some_file.ex&lt;/code&gt; 中定义特定于测试环境的实现。</target>
        </trans-unit>
        <trans-unit id="462519e135281467088215ccc649f512ae9b84ce" translate="yes" xml:space="preserve">
          <source>Anonymous functions</source>
          <target state="translated">匿名功能</target>
        </trans-unit>
        <trans-unit id="bb9a933ae349228e32e1f073b740f4f65715b58c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;</source>
          <target state="translated">匿名函数被报告为-func/arity-anonfn-count-,其中func是外层函数的名称。转换为 &quot;func/arity中的匿名fn&quot;。</target>
        </trans-unit>
        <trans-unit id="8e2e0b675b3d9b8858e0c45385fd95f27e5170f3" translate="yes" xml:space="preserve">
          <source>Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:</source>
          <target state="translated">匿名函数也可以有多个子句。所有子句都应该期待相同数量的参数。</target>
        </trans-unit>
        <trans-unit id="bfa301a3c21795199d13e7b6588d342af94a24a1" translate="yes" xml:space="preserve">
          <source>Anonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a function is of any given arity by using &lt;code&gt;is_function/2&lt;/code&gt;:</source>
          <target state="translated">Elixir中的匿名函数还通过它们收到的参数数量来标识。我们可以使用 &lt;code&gt;is_function/2&lt;/code&gt; 来检查一个函数是否具有给定的Arity：</target>
        </trans-unit>
        <trans-unit id="cc3478c83b0f2c05d9c65b14ae56037cbfc0b5c6" translate="yes" xml:space="preserve">
          <source>Anonymous functions with no expression after &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-&amp;gt;&lt;/code&gt; 之后没有表达式的匿名函数</target>
        </trans-unit>
        <trans-unit id="3f9ea76dc507dd1537d2a78a7f363a18e4775cd5" translate="yes" xml:space="preserve">
          <source>Another alternative to &lt;code&gt;@derive&lt;/code&gt; is to explicitly tell the protocol to fallback to &lt;code&gt;Any&lt;/code&gt; when an implementation cannot be found. This can be achieved by setting &lt;code&gt;@fallback_to_any&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 的另一种选择是在找不到实现时，明确告诉协议回退到 &lt;code&gt;Any&lt;/code&gt; 。这可以通过在协议定义 &lt;code&gt;@fallback_to_any&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="2ce311858ef69483871a91631dbd1d6d4dde210e" translate="yes" xml:space="preserve">
          <source>Another approach is to disable protocol consolidation during tests in your mix.exs:</source>
          <target state="translated">另一种方法是在mix.exs的测试中禁用协议合并。</target>
        </trans-unit>
        <trans-unit id="cd6916cf153042850a0d4907b1527f29fbe844df" translate="yes" xml:space="preserve">
          <source>Another common metadata is &lt;code&gt;:deprecated&lt;/code&gt;, which emits a warning in the documentation, explaining that its usage is discouraged:</source>
          <target state="translated">另一个常见的元数据是 &lt;code&gt;:deprecated&lt;/code&gt; ，它在文档中发出警告，说明不鼓励使用它：</target>
        </trans-unit>
        <trans-unit id="2b8f4fcb03038d3204cf32a1e07964ca7ae1e5e9" translate="yes" xml:space="preserve">
          <source>Another common need in releases is to compute configuration when the release runs, not when the release is assembled. The &lt;code&gt;config/config.exs&lt;/code&gt; file we defined at the beginning of this chapter runs on every Mix command, when we build, test and run our application. This is great, because it provides a unified configuration for dev, test, and prod.</source>
          <target state="translated">版本中的另一个常见需求是在版本运行时（而不是在组装版本时）计算配置。在构建，测试和运行应用程序时，我们将在本章开头定义的 &lt;code&gt;config/config.exs&lt;/code&gt; 文件在每个Mix命令上运行。很好，因为它为开发，测试和生产提供了统一的配置。</target>
        </trans-unit>
        <trans-unit id="d2d6bcdc6f9dd5a9edc0684e098b03c84e550047" translate="yes" xml:space="preserve">
          <source>Another example comes from &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;the ExUnit framework&lt;/a&gt; which uses module attributes as annotation and storage:</source>
          <target state="translated">另一个示例来自&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit框架&lt;/a&gt;，该框架使用模块属性作为注释和存储：</target>
        </trans-unit>
        <trans-unit id="fa358ec240cab1628444ba9ff9bd76a8046b33fc" translate="yes" xml:space="preserve">
          <source>Another example while using an imported or local function:</source>
          <target state="translated">另一个例子是在使用导入或本地函数时。</target>
        </trans-unit>
        <trans-unit id="dbe451732076cc22d41fb430c0f2cb877351509f" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;module#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;kernel#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">另一个重要的区别是&lt;a href=&quot;module#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; &lt;/a&gt;允许您控制定义模块时使用的环境变量，而&lt;a href=&quot;kernel#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; 则&lt;/a&gt;自动使用在其上调用的环境。</target>
        </trans-unit>
        <trans-unit id="5b885d633868b72a3319e18e467d568e3f820f4a" translate="yes" xml:space="preserve">
          <source>Another interesting function is &lt;code&gt;Stream.resource/3&lt;/code&gt; which can be used to wrap around resources, guaranteeing they are opened right before enumeration and closed afterwards, even in the case of failures. For example, we can use it to stream a file:</source>
          <target state="translated">另一个有趣的功能是 &lt;code&gt;Stream.resource/3&lt;/code&gt; ，它可以用于包装资源，以确保它们在枚举之前就已打开并且在发生故障后也可以在之后关闭。例如，我们可以使用它来流式传输文件：</target>
        </trans-unit>
        <trans-unit id="99dd3549eee17cdcf074d50bea27d1a61c1fe1b2" translate="yes" xml:space="preserve">
          <source>Another interesting property of maps is that they provide their own syntax for accessing atom keys:</source>
          <target state="translated">地图的另一个有趣的属性是,它们提供了自己的语法来访问原子键。</target>
        </trans-unit>
        <trans-unit id="9a1777838dac8ee28fe902db2218ed802abd5034" translate="yes" xml:space="preserve">
          <source>Another option is to make the routing table configurable. This means we can change the routing table on specific tests to assert for specific behaviour. As we will learn in the next chapter, changing the routing table this way has the downside that those particular tests can no longer run asynchronously, so it is a technique that should be used sparingly.</source>
          <target state="translated">另一种选择是使路由表可配置。这意味着我们可以改变特定测试上的路由表,以断言特定行为。正如我们将在下一章中学习到的那样,以这种方式改变路由表有一个缺点,即那些特定的测试不能再异步运行,所以应该少用这种技术。</target>
        </trans-unit>
        <trans-unit id="24a9327535a522b50c90a3875aaafa4123543d75" translate="yes" xml:space="preserve">
          <source>Another use case for tags and filters is to exclude all tests that have a particular tag by default, regardless of its value, and include only a certain subset:</source>
          <target state="translated">标签和过滤器的另一个用例是排除所有默认具有特定标签的测试,无论其值如何,而只包括某个子集。</target>
        </trans-unit>
        <trans-unit id="726155227c06c751e3edc99ac5a96aa24ef74e16" translate="yes" xml:space="preserve">
          <source>Another useful example is the &lt;code&gt;String.Chars&lt;/code&gt; protocol, which specifies how to convert a data structure with characters to a string. It&amp;rsquo;s exposed via the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">另一个有用的示例是 &lt;code&gt;String.Chars&lt;/code&gt; 协议，该协议指定如何将带有字符的数据结构转换为字符串。它通过 &lt;code&gt;to_string&lt;/code&gt; 函数公开：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
