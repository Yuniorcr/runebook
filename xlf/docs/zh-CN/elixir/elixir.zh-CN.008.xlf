<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="translated">总而言之,文档是与你的API的用户签订的合同,他们不一定能访问源代码;而代码注释是给那些直接与源代码交互的用户的。你可以通过分离这两个概念来了解和表达你的软件的不同保证。</target>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="translated">在 &quot;Mix.Task &quot;部分,我们已经定义了一个任务,它将对使用我们的项目作为依赖的每个人都可用。如果我们希望这个任务只对我们的项目可用呢?只需定义一个别名。</target>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="translated">在&lt;a href=&quot;agent&quot;&gt;上一章中&lt;/a&gt;，我们使用代理来代表我们的存储桶。在&lt;a href=&quot;introduction-to-mix&quot;&gt;mix&lt;/a&gt;的简介中，我们指定了要命名每个存储桶的名称，因此我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="translated">在&lt;a href=&quot;basic-types&quot;&gt;上一章中&lt;/a&gt;，我们看到Elixir提供 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 作为算术运算符，以及用于整数除法和余数的函数 &lt;code&gt;div/2&lt;/code&gt; 和 &lt;code&gt;rem/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="translated">在&lt;a href=&quot;structs&quot;&gt;上一章中&lt;/a&gt;，我们了解到，尽管结构是映射，但它们并不与映射共享协议实现。例如，&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;（基于地图的集合）被实现为结构。让我们尝试将 &lt;code&gt;Size&lt;/code&gt; 协议与 &lt;code&gt;MapSet&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="translated">在 &lt;code&gt;__using__/1&lt;/code&gt; 实现中，我们将名为 &lt;code&gt;@tests&lt;/code&gt; 的模块属性初始化为一个空列表，然后将每个已定义测试的名称存储在此属性中，以便可以从 &lt;code&gt;run&lt;/code&gt; 函数调用这些测试。</target>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="translated">在&amp;ldquo;应用程序&amp;rdquo;选项卡中，您将在其监视树旁边看到系统中当前正在运行的所有应用程序。您可以选择 &lt;code&gt;kv&lt;/code&gt; 应用程序以进一步探索它：</target>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="translated">上面的过程终止是指失败的终止，由 &lt;code&gt;:restart&lt;/code&gt; 选项决定。</target>
        </trans-unit>
        <trans-unit id="7821fdeb2e1e82ffc7914547f20081eb14c31b6f" translate="yes" xml:space="preserve">
          <source>In the case a value is stored multiple times in the keyword list, later occurrences are removed.</source>
          <target state="translated">如果一个值在关键字列表中存储了多次,则会删除后面出现的值。</target>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="translated">在调用匿名函数的情况下,具有点特殊形式的内元组只有一个参数,反映了运算符是单数的事实。</target>
        </trans-unit>
        <trans-unit id="0c98e9cf9dcf59ac9fca17a0c41969297e7c44d2" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;Logger.flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于事件 &lt;code&gt;:flush&lt;/code&gt; 处理程序应该刷新所有未决的数据。此事件由&lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;Logger.flush/0&lt;/code&gt; &lt;/a&gt;触发。</target>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于事件 &lt;code&gt;:flush&lt;/code&gt; 处理程序应该刷新所有未决的数据。此事件由&lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;flush/0&lt;/code&gt; &lt;/a&gt;触发。</target>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="translated">在上面的代码中，我们有一个过程，我们称之为&amp;ldquo;客户端&amp;rdquo;，向代理&amp;ldquo;服务器&amp;rdquo;发送请求。该请求包含一个匿名函数，必须由服务器执行。</target>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="translated">在环境中可以访问当前的文件名、行号、设置别名、当前函数等。</target>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="translated">在环境中,你可以访问文件名、行号、设置别名、函数等。</target>
        </trans-unit>
        <trans-unit id="608b24d6e5e5edc7ece0be6b5cce2c71fcef971e" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Cmd.html&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">在上面的示例中，我们创建了别名 &lt;code&gt;some_alias&lt;/code&gt; ，该别名将运行任务 &lt;code&gt;mix hex.info&lt;/code&gt; ，然后&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;运行Elixir脚本，然后&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Cmd.html&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;执行命令行shell脚本。这显示了混合任务可以混合使用强大的别名。</target>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">在上面的示例中，我们创建了别名 &lt;code&gt;some_alias&lt;/code&gt; ，它将运行任务 &lt;code&gt;mix hex.info&lt;/code&gt; ，然后&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;运行Elixir脚本，然后&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;执行命令行shell脚本。这显示了与Mix任务混合使用的强大别名。</target>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。这可以通过使用&lt;a href=&quot;#max_by/3&quot;&gt; &lt;code&gt;max_by/3&lt;/code&gt; &lt;/a&gt;并依靠最高有效数字在前的结构来解决。在这种情况下，我们可以使用&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;来获取具有年，月和日字段的元组表示形式：</target>
        </trans-unit>
        <trans-unit id="d50a70865839f28bf705bef682c6bf3df4c9c940" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。因此，大多数结构都提供&amp;ldquo;比较&amp;rdquo;功能，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;，该函数接收两个结构并返回 &lt;code&gt;:lt&lt;/code&gt; （小于） &lt;code&gt;:eq&lt;/code&gt; （等于）和 &lt;code&gt;:gt&lt;/code&gt; （大于） 。如果将模块作为排序功能传递，Elixir将自动使用该模块的 &lt;code&gt;compare/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能，例如&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27e3001adb27cd38424db873e11a855a0fabd25e" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt;返回3月31日而不是4月1日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能（例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; )&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。这可以通过使用&lt;a href=&quot;#min_by/3&quot;&gt; &lt;code&gt;min_by/3&lt;/code&gt; &lt;/a&gt;并依靠最高有效数字在前的结构来解决。在这种情况下，我们可以使用&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;来获取具有年，月和日字段的元组表示形式：</target>
        </trans-unit>
        <trans-unit id="b47db09b5466e9e31fe82800684896500461db1f" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。因此，大多数结构都提供&amp;ldquo;比较&amp;rdquo;功能，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;，该函数接收两个结构并返回 &lt;code&gt;:lt&lt;/code&gt; （小于） &lt;code&gt;:eq&lt;/code&gt; （等于）和 &lt;code&gt;:gt&lt;/code&gt; （大于） 。如果将模块作为排序功能传递，Elixir将自动使用该模块的 &lt;code&gt;compare/2&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能，例如&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6741cfc7caed86bbef15f21d887f8bb7d9a69a68" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt;返回4月1日而不是3月31日，因为结构比较比较了一年前的日期。在这种情况下，模块通常会提供执行语义比较的功能（例如&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; )&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="baf0386ec100f9836f02578a5562d4a28953ca57" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;将每个 &lt;code&gt;fun&lt;/code&gt; 的调用结果以相反的顺序累加到一个列表中，该列表最后通过调用&lt;a href=&quot;#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt;正确地排序。</target>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;将每个 &lt;code&gt;fun&lt;/code&gt; 的调用结果以相反的顺序累积到一个列表中，该列表在最后通过调用&lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt;正确地进行了排序。</target>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; 返回一个数据类型，即实际流，它表示范围为 &lt;code&gt;1..100_000&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 计算：</target>
        </trans-unit>
        <trans-unit id="05fc4140bc39b53558f26707ec168a4d86893856" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;ExUnit&lt;/code&gt; stores the value of &lt;code&gt;async: true&lt;/code&gt; in a module attribute to change how the module is compiled. Tags are also defined as &lt;code&gt;accumulate: true&lt;/code&gt; attributes, and they store tags that can be used to setup and filter tests. For example, you can avoid running external tests on your machine because they are slow and dependent on other services, while they can still be enabled in your build system.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;ExUnit&lt;/code&gt; 将 &lt;code&gt;async: true&lt;/code&gt; 的值存储在模块属性中，以更改模块的编译方式。标记也定义为&amp;ldquo; &lt;code&gt;accumulate: true&lt;/code&gt; 属性，它们存储可用于设置和过滤测试的标记。例如，您可以避免在计算机上运行外部测试，因为它们运行缓慢且依赖于其他服务，而仍然可以在构建系统中启用它们。</target>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="translated">在上面的示例中，即使宏显然将其设置为1 ， &lt;code&gt;a&lt;/code&gt; 也会返回10，因为在宏中定义的变量不会影响宏在其中执行的上下文。如果要在调用者的上下文中设置或获取变量，则可以可以在 &lt;code&gt;var!&lt;/code&gt; 的帮助下做到这一点！巨集：</target>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">在上面的示例中，如果 &lt;code&gt;foo&lt;/code&gt; 的值为真值（既不是 &lt;code&gt;false&lt;/code&gt; 也不是 &lt;code&gt;nil&lt;/code&gt; ），则将返回 &lt;code&gt;bar&lt;/code&gt; 。否则，将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;value&lt;/code&gt; 取决于 &lt;code&gt;lucky?&lt;/code&gt; 值是 &lt;code&gt;7&lt;/code&gt; 还是 &lt;code&gt;13&lt;/code&gt; 。。如果 &lt;code&gt;value&lt;/code&gt; 在case 之前没有先前的值，则没有显式绑定值的子句会将变量绑定到 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29dddd8ca2fe8a806f189d92127cef817ecb30da" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; regardless of the value of &lt;code&gt;lucky?&lt;/code&gt;. The variable &lt;code&gt;value&lt;/code&gt; bound in the clause and the variable &lt;code&gt;value&lt;/code&gt; bound in the outer context are two entirely separate variables.</source>
          <target state="translated">在上面的示例中，无论 &lt;code&gt;lucky?&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 是多少，值都将是 &lt;code&gt;7&lt;/code&gt; 。。变量 &lt;code&gt;value&lt;/code&gt; 的子句和变量绑定中 &lt;code&gt;value&lt;/code&gt; 在外部上下文约束是两个完全独立的变量。</target>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，由于 &lt;code&gt;x&lt;/code&gt; 是在 &lt;code&gt;try&lt;/code&gt; 子句中定义的，因此无法访问。解决此问题的一种常见做法是返回在 &lt;code&gt;try&lt;/code&gt; 内部定义的变量：</target>
        </trans-unit>
        <trans-unit id="6f83ecedbf7273a5aa4b952ec92a7a095991da80" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; starts without a value and has &lt;code&gt;1&lt;/code&gt; assigned to it. Then, we compare the value of &lt;code&gt;x&lt;/code&gt; to the literal &lt;code&gt;1&lt;/code&gt;, which succeeds as they are both &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;x&lt;/code&gt; 开始时没有值，并且为其分配了 &lt;code&gt;1&lt;/code&gt; 。然后，我们的值进行比较 &lt;code&gt;x&lt;/code&gt; 字面 &lt;code&gt;1&lt;/code&gt; ，其成功，因为他们都是 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="translated">在上面的示例中，定义了 &lt;code&gt;sum/2&lt;/code&gt; 函数；该函数接收两个参数并返回它们的和。</target>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="translated">在上面的示例中，将定义一组名为 &lt;code&gt;user&lt;/code&gt; 但具有不同Arity 的宏来操作基础记录。</target>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="translated">在上面的示例中，通过将监管结构传递给&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt;来启动监管器。但是，也可以通过显式定义监督模块来创建监督者：</target>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="translated">在上面的示例中，当我们在范围内进行映射时，在枚举过程中被枚举的元素是一一创建的。该&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;模块我们可以映射范围，而不会触发其列举：</target>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="translated">在上面的示例中，通过使用 &lt;code&gt;TestCase&lt;/code&gt; ，我们可以使用 &lt;code&gt;test&lt;/code&gt; 宏编写测试，该宏定义了一个名为 &lt;code&gt;run&lt;/code&gt; 的函数来自动为我们运行所有测试。我们的原型将依靠match运算符（ &lt;code&gt;=&lt;/code&gt; ）作为执行断言的机制。</target>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，即使宏注入 &lt;code&gt;a = 1&lt;/code&gt; ，它也不会影响 &lt;code&gt;go&lt;/code&gt; 函数定义的变量 &lt;code&gt;a&lt;/code&gt; 。如果宏要显式影响上下文，则可以使用 &lt;code&gt;var!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">在上面的示例中，即使右列表中的条目比左列表中的条目更多，但解构工作正常。如果右边的列表较小，则将其余元素简单地设置为 &lt;code&gt;nil&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="translated">在上面的示例中，模式匹配之所以有效，是因为结构下方是具有固定字段集的裸露地图。作为地图，结构存储一个名为 &lt;code&gt;__struct__&lt;/code&gt; 的&amp;ldquo;特殊&amp;rdquo;字段，其中包含该结构的名称：</target>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="translated">在上面的示例中，由于我们要在 &lt;code&gt;plus/2&lt;/code&gt; 函数内调用 &lt;code&gt;alias&lt;/code&gt; ，因此该别名仅在 &lt;code&gt;plus/2&lt;/code&gt; 函数内有效。 &lt;code&gt;minus/2&lt;/code&gt; 将完全不受影响。</target>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;|&amp;gt;&lt;/code&gt; 管道是最右边的管道； &lt;code&gt;arg1&lt;/code&gt; 是 &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt; 的AST ，而 &lt;code&gt;arg2&lt;/code&gt; 是 &lt;code&gt;div(2)&lt;/code&gt; 的AST 。</target>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="translated">在上面的示例中，导入的 &lt;code&gt;List.duplicate/2&lt;/code&gt; 仅在该特定函数中可见。在该模块（或与此相关的任何其他模块）的任何其他功能中， &lt;code&gt;duplicate/2&lt;/code&gt; 将不可用。</target>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="translated">在上面的示例中，链接的进程因发送值为1 的 &lt;code&gt;exit&lt;/code&gt; 信号而死亡。Elixir Shell自动处理这些消息并将其打印到终端。</target>
        </trans-unit>
        <trans-unit id="4c70f5b2fc854619c8625c6a22c3a81ffb99e2fe" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">在上面的示例中，列表 &lt;code&gt;[1, [2], 3]&lt;/code&gt; 作为第一个参数传递给&lt;a href=&quot;https://hexdocs.pm/elixir/List.html#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt;函数，然后扁平化的列表作为第一个参数传递给&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;函数。将列表中的每个元素加倍。</target>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">在上面的示例中，列表 &lt;code&gt;[1, [2], 3]&lt;/code&gt; 作为第一个参数传递给&lt;a href=&quot;list#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt;函数，然后将扁平化的列表作为第一个参数传递给&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;函数。将列表中的每个元素加倍。</target>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="translated">在上面的例子中,shell会期待更多的输入,直到它找到结束引号。有时并不清楚shell期待的是哪一个字符,用户可能会发现自己陷入了不完整表达的状态,除了退出shell之外,没有任何能力终止它。</target>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="translated">在上面的例子中,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="translated">在上面的例子中，两个模块- &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Foo.Bar&lt;/code&gt; -被创建。嵌套时，Elixir会自动为内部模块创建一个别名，从而允许第二个模块 &lt;code&gt;Foo.Bar&lt;/code&gt; 在其定义的相同词法范围（ &lt;code&gt;Foo&lt;/code&gt; 模块）中作为 &lt;code&gt;Bar&lt;/code&gt; 进行访问。仅当嵌套模块通过别名定义时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="translated">在上面的示例中，我们为该模块显式设置了version属性。 &lt;code&gt;@vsn&lt;/code&gt; 由Erlang中的代码重载机制使用</target>
        </trans-unit>
        <trans-unit id="a373d89a73cb82089c1340de9b4a2f42e3a9dea1" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. However, data structures in Elixir are immutable. For this reason, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">在上面的示例中，我们同时对数组和变量 &lt;code&gt;i&lt;/code&gt; 进行了变异。但是，Elixir中的数据结构是不可变的。因此，函数式语言依赖于递归：递归地调用函数，直到达到阻止递归操作继续进行的条件为止。在此过程中，没有数据发生突变。考虑下面的示例，该示例可任意多次打印字符串：</target>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">在上面的示例中，我们同时对数组和变量 &lt;code&gt;i&lt;/code&gt; 进行了变异。在Elixir中无法进行突变。相反，函数式语言依赖于递归：递归地调用函数，直到达到阻止递归操作继续进行的条件为止。在此过程中，没有数据发生突变。考虑下面的示例，该示例可任意多次打印字符串：</target>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="translated">在上面的示例中，我们可以使用 &lt;code&gt;@foo&lt;/code&gt; &lt;code&gt;assigns&lt;/code&gt; 的绑定下访问值 &lt;code&gt;foo&lt;/code&gt; 。这很有用，因为模板在编​​译后可以接收不同的赋值，并且不需要为每个变量集重新编译。</target>
        </trans-unit>
        <trans-unit id="67d3a850b4e721008a9a33c249f890ed36ddb4d7" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">在上面的示例中，我们将&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt;捕获为匿名函数，然后调用了它。</target>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">在上面的示例中，我们将&lt;a href=&quot;kernel#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt;捕获为匿名函数，然后调用了它。</target>
        </trans-unit>
        <trans-unit id="ca7f8c9d2062b97da89273704dad9ed0703a8452" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">在上面的示例中，我们创建了休眠时间从1到10秒的任务，并返回了他们睡过的秒数。如果您一次执行所有代码，则应该看到1到5的打印内容，因为这些是在给定时间内执行的任务。所有其他任务将通过&lt;a href=&quot;#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;调用关闭。</target>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">在上面的示例中，我们创建了休眠时间从1到10秒的任务，并返回了他们睡过的秒数。如果您一次执行所有代码，则应该看到1到5的打印内容，因为这些是在给定时间内已完成的任务。所有其他任务将通过&lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;调用关闭。</target>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们定义了一个匿名函数，该函数接收两个参数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，并返回 &lt;code&gt;a + b&lt;/code&gt; 的结果。参数始终在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的左侧，要执行的代码在右侧。匿名函数存储在变量 &lt;code&gt;add&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="translated">在上面的例子中,我们定义了工人和主管的规格。这些规范(包括工人和主管)接受以下选项。</target>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">在上面的示例中，我们创建了一个新端口，用于执行程序 &lt;code&gt;cat&lt;/code&gt; 。 &lt;code&gt;cat&lt;/code&gt; 是UNIX系统上可用的程序，该程序从多个输入接收数据并将它们串联在输出中。</target>
        </trans-unit>
        <trans-unit id="156803f5c97e61fd27214bc1371c5ad133572347" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on Unix-like operating systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">在上面的示例中，我们创建了一个新端口，用于执行程序 &lt;code&gt;cat&lt;/code&gt; 。 &lt;code&gt;cat&lt;/code&gt; 是在类似Unix的操作系统上可用的程序，该程序从多个输入接收数据并将它们连接在输出中。</target>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="translated">在上面的示例中，我们定义了一个名为 &lt;code&gt;:cd&lt;/code&gt; 的标记，可以在设置回调中读取该标记，以配置测试将在其上运行的工作目录。</target>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="translated">在上面的示例中，我们定义了一个名为 &lt;code&gt;mix all&lt;/code&gt; 的别名，该别名打印&amp;ldquo; Hello world&amp;rdquo;，然后获取特定于当前环境的依赖项，并编译项目。</target>
        </trans-unit>
        <trans-unit id="660bac6b0180ebfa96d383b78487f5cdbac50030" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">在上面的示例中，我们定义了两个别名。一个是 &lt;code&gt;mix c&lt;/code&gt; ，它是&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;的快捷方式。另一个名为 &lt;code&gt;mix hello&lt;/code&gt; ，与我们在&amp;ldquo; Mix.Task&amp;rdquo;部分中定义的 &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">在上面的示例中，我们定义了两个别名。一个是 &lt;code&gt;mix c&lt;/code&gt; ，它是&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;的快捷方式。另一个名为 &lt;code&gt;mix hello&lt;/code&gt; ，与我们在&amp;ldquo; Mix.Task&amp;rdquo;部分中定义的 &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="translated">在上面的示例中，我们动态生成了函数 &lt;code&gt;foo/0&lt;/code&gt; 和 &lt;code&gt;bar/0&lt;/code&gt; 。现在，假设我们想将此功能转换为宏：</target>
        </trans-unit>
        <trans-unit id="eb997411d2a35ea49834890c6520f8f8d681bd86" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;MyKeyword&lt;/code&gt; 设置为别名作为&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。因此，现在，任何对&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; 的&lt;/a&gt;引用都将被 &lt;code&gt;MyKeyword&lt;/code&gt; 自动替换。</target>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;MyKeyword&lt;/code&gt; 设置为别名作为&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;。因此，现在，任何对&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; 的&lt;/a&gt;引用都将被 &lt;code&gt;MyKeyword&lt;/code&gt; 自动替换。</target>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="translated">在上面的示例中，我们使用了 &lt;code&gt;plug/1&lt;/code&gt; 宏来连接将在存在Web请求时调用的函数。在内部，每次调用 &lt;code&gt;plug/1&lt;/code&gt; 时，插件库都会将给定参数存储在 &lt;code&gt;@plugs&lt;/code&gt; 属性中。在编译模块之前，Plug运行一个回调，该回调定义了一个处理HTTP请求的函数（ &lt;code&gt;call/2&lt;/code&gt; ）。此函数将按顺序运行 &lt;code&gt;@plugs&lt;/code&gt; 中的所有插件。</target>
        </trans-unit>
        <trans-unit id="245b9813cb08572f08e7ce35fd5f72dcd40372ab" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">在上面的示例中，我们从 &lt;code&gt;MyMacros&lt;/code&gt; 导入了宏，在该特定函数中用我们自己的宏替换了原来的&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。该模块中的所有其他功能仍将能够使用原始功能。</target>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">在上面的示例中，我们从 &lt;code&gt;MyMacros&lt;/code&gt; 导入了宏，在该特定函数中用我们自己的宏替换了原来的&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。该模块中的所有其他功能仍将能够使用原始功能。</target>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;thing&lt;/code&gt; 与每个子句&amp;ldquo; head&amp;rdquo; 匹配，并执行与匹配的第一个子句相对应的子句&amp;ldquo; body&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="translated">在上面的示例中，我们传递了一个 &lt;code&gt;\n&lt;/code&gt; 转义的字符串，并返回了一个未转义的版本。</target>
        </trans-unit>
        <trans-unit id="d7a1701f06e939aba29cc4e178e9955eb9fec15b" translate="yes" xml:space="preserve">
          <source>In the example above, we prefixed the function names with the command name used to execute them, but that is entirely optional.</source>
          <target state="translated">在上面的例子中,我们在函数名前加上了用于执行它们的命令名,但这完全是可选的。</target>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="translated">在上面的例子中,我们展示了如何在函数子句中使用守护。有几个结构允许使用guards,例如。</target>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="translated">在下面的例子中,我们注册当前进程,并询问注册表中的键数。</target>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="translated">在下面的例子中,我们注册当前进程,并从自身和其他进程中查找。</target>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="translated">在下面的例子中,我们在重复的注册表中用相同的键注册当前的进程,但数值不同。</target>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="translated">在下面的示例中，我们有一个宏，该宏生成一个带有名为 &lt;code&gt;name_length&lt;/code&gt; 的函数的模块，该函数返回模块名称的长度。该函数的值将在编译时而不是在运行时计算。</target>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="translated">在下面的示例中，我们将目录传递到&lt;a href=&quot;#c/2&quot;&gt; &lt;code&gt;c/2&lt;/code&gt; &lt;/a&gt;函数将已编译的 &lt;code&gt;.beam&lt;/code&gt; 文件写入的目录。该目录在Erlang / Elixir系统中通常称为&amp;ldquo; ebin&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">在下面的例子中,我们使用一个函数来获取一个列表内的所有地图。</target>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="translated">在上面的示例中，所有的理解都返回列表作为结果。但是，通过将 &lt;code&gt;:into&lt;/code&gt; 选项传递给理解，可以将理解的结果插入到不同的数据结构中。</target>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">在上面的示例中，理解返回的结果始终是一个列表。可以通过传递 &lt;code&gt;:into&lt;/code&gt; 选项来配置返回的结果，该选项可以接受任何结构，只要它实现了&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议即可。</target>
        </trans-unit>
        <trans-unit id="73e547c48fc4efe942c1938b956ce334b82c040a" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">在上面的示例中，理解返回的结果始终是一个列表。可以通过传递 &lt;code&gt;:into&lt;/code&gt; 选项来配置返回的结果，该选项可以接受任何结构，只要它实现&lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;协议即可。</target>
        </trans-unit>
        <trans-unit id="dec1f7ea6cca2c448adce8e9cc2f35e0ad761d20" translate="yes" xml:space="preserve">
          <source>In the examples above, we have used the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards.</source>
          <target state="translated">在上面的示例中，我们使用了match运算符（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt;）和function子句分别展示了模式和防护。这是Elixir中支持模式和防护的内置构造的列表。</target>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="translated">在上面的表达式中， &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; 是&lt;strong&gt;生成器&lt;/strong&gt;。它实际上是在生成用于理解的值。任何可枚举都可以在生成器表达式的右侧传递：</target>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="translated">在第一个例子中,重音在元音之前,所以它被认为是两个词素。但是,当你把它倒过来一次,你的元音后面是重音,这就变成了一个词素。再颠倒一次,就会保持为一个单音节。</target>
        </trans-unit>
        <trans-unit id="81851c5f2cda0fa01d07a6553b4cc2343064b54a" translate="yes" xml:space="preserve">
          <source>In the first scenario, a lock is received in &lt;code&gt;opts&lt;/code&gt; and the repository must be updated to the lock. In the second, no lock is given and the repository can be updated freely.</source>
          <target state="translated">在第一种情况下，在 &lt;code&gt;opts&lt;/code&gt; 中接收到锁，并且必须将存储库更新为该锁。在第二个中，没有给出锁定，并且存储库可以自由更新。</target>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="translated">在以下各节中，我们的示例将变得更长，而在shell中键入它们可能很棘手。现在该是我们学习如何编译Elixir代码以及如何运行Elixir脚本的时候了。</target>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="translated">在下一章中，我们将通过使用match运算符 &lt;code&gt;=&lt;/code&gt; 来讨论模式匹配。</target>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="translated">在下一章中,我们将探讨GenServers,客户端和服务器之间的隔离更加明显。</target>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="translated">在下一章,我们将开始解析客户端请求并发送响应,完成我们的服务器。</target>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="translated">在下一章中，我们将探讨结构和协议，然后再转向异常处理和诸如信号和理解之类的其他结构。</target>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="translated">在有关 &lt;code&gt;GenServer&lt;/code&gt; 的上一章中，我们实现了 &lt;code&gt;KV.Registry&lt;/code&gt; 来管理存储桶。在某个时候，我们开始监视存储桶，以便能够在 &lt;code&gt;KV.Bucket&lt;/code&gt; 崩溃时采取措施。尽管变化相对较小，但它引入了一个问题，这是Elixir开发人员经常提出的问题：发生故障时会发生什么？</target>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="translated">在前面的章节中，我们始终直接启动流程。例如，我们将调用 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; ，它将返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; ，这将使我们能够通过其 &lt;code&gt;pid&lt;/code&gt; 与注册表进行交互。现在，流程由主管启动，我们必须直接询问主管其子级是谁，然后从返回的子级列表中获取pid。实际上，每次这样做都是非常昂贵的。为了解决这个问题，我们经常给进程起名字，使它们可以在一台机器上从代码中的任何地方唯一地标识出来。</target>
        </trans-unit>
        <trans-unit id="d89af771bb31edf816f69ac576dd476d68e9b7c3" translate="yes" xml:space="preserve">
          <source>In the previous example, we read the application environment at runtime:</source>
          <target state="translated">在前面的例子中,我们在运行时读取应用环境。</target>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="translated">在前面的例子中,我们对将一个值关联到流程不感兴趣。</target>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="translated">在返回的结果中,键是变量名,值是对应的变量值。</target>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="translated">在失败的第二行中，在测试名称的正下方，有定义测试的位置。如果您完整复制测试位置（包括文件和行号），并将其附加到 &lt;code&gt;mix test&lt;/code&gt; ，则Mix将加载并运行该特定测试：</target>
        </trans-unit>
        <trans-unit id="f677b0be0ad961b242015e2787d48da5351af3eb" translate="yes" xml:space="preserve">
          <source>In the sections above, we have configured an application in the &lt;code&gt;application/0&lt;/code&gt; section of the &lt;code&gt;mix.exs&lt;/code&gt; file. Ultimately, Mix will use this configuration to create an &lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;application resource file&lt;/em&gt;&lt;/a&gt;, which is a file called &lt;code&gt;APP_NAME.app&lt;/code&gt;. For example, the application resource file of the OTP application &lt;code&gt;ex_unit&lt;/code&gt; is called &lt;code&gt;ex_unit.app&lt;/code&gt;.</source>
          <target state="translated">在上面的部分中，我们在 &lt;code&gt;mix.exs&lt;/code&gt; 文件的 &lt;code&gt;application/0&lt;/code&gt; 部分中配置了一个应用程序。最终，Mix将使用此配置来创建&lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;应用程序资源文件&lt;/em&gt;&lt;/a&gt;，该文件是名为 &lt;code&gt;APP_NAME.app&lt;/code&gt; 的文件。例如，OTP应用程序 &lt;code&gt;ex_unit&lt;/code&gt; 的应用程序资源文件称为 &lt;code&gt;ex_unit.app&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="translated">在上面的会话中，我们与&amp;ldquo;购物&amp;rdquo;存储区进行了交互。</target>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="translated">在这种情况下,答案是肯定的:如果接受器崩溃,就没有必要崩溃现有的连接。另一方面,如果任务主管崩溃,也没有必要让接受器崩溃。</target>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="translated">在这种情况下，没有模块，因此我们选择了名称 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 。可能是其他任何名称。我们还选择了 &lt;code&gt;:one_for_one&lt;/code&gt; 策略，这是当前动态主管唯一可用的策略。</target>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">在这种情况下，我们仅从 &lt;code&gt;List&lt;/code&gt; 导入功能 &lt;code&gt;duplicate&lt;/code&gt; （含偶数2）。尽管 &lt;code&gt;:only&lt;/code&gt; 是可选的，但是建议使用它，以避免将给定模块的所有功能导入名称空间内。 &lt;code&gt;:except&lt;/code&gt; 也可以作为一个选项提供，以导入模块中&lt;em&gt;除&lt;/em&gt;功能列表&lt;em&gt;以外&lt;/em&gt;的所有内容。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="translated">在本章中,我们将进一步了解Elixir的基本类型:整数、浮点数、布尔运算、原子、字符串、列表和元组。一些基本类型是:</target>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="translated">在本章中，我们将探索信号，信号是语言提供的用于处理文本表示的机制之一。标记以波浪号（ &lt;code&gt;~&lt;/code&gt; ）字符开头，后跟字母（标识标记），然后是定界符；可选地，可以在最终定界符之后添加修饰符。</target>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="translated">在本章中，我们将学习如何使用&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang的 &lt;code&gt;:gen_tcp&lt;/code&gt; 模块&lt;/a&gt;来处理请求。这提供了探索Elixir &lt;code&gt;Task&lt;/code&gt; 模块的绝好机会。在以后的章节中，我们将扩展服务器，以便它可以实际服务命令。</target>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="translated">在本章中，我们了解了有关Mix依赖项和伞项目的更多信息。虽然我们可以在没有服务器的情况下运行 &lt;code&gt;kv&lt;/code&gt; ,但我们的 &lt;code&gt;kv_server&lt;/code&gt; 直接取决于 &lt;code&gt;kv&lt;/code&gt; 。通过将它们分解为单独的应用程序，我们可以更好地控制它们的开发和测试方式。</target>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="translated">在本章中,我们将使用Mix创建我们的第一个项目,并探索Mix中的不同功能。</target>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="translated">在本章中,我们将讨论如何在Mix中管理依赖关系。</target>
        </trans-unit>
        <trans-unit id="1d38e5f6537d823a5c3903caf420e15d1b2908d8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will gain clarity on what exactly binaries are, how they relate to strings, and what single-quoted values, &lt;code&gt;'like this'&lt;/code&gt;, mean in Elixir. Although strings are one of the most common data types in computer languages, they are subtly complex and are often misunderstood. To understand strings in Elixir, we have to educate ourselves about &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; and character encodings, specifically the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding.</source>
          <target state="translated">在本章中，我们将清楚地了解二进制文件的确切含义，它们与字符串的关系以及在Elixir中单引号的值 &lt;code&gt;'like this'&lt;/code&gt; 含义。尽管字符串是计算机语言中最常见的数据类型之一，但它们有些复杂，而且常常被误解。要了解Elixir中的字符串，我们必须对&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;和字符编码（特别是&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;编码）进行自我教育。</target>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="translated">在本章中，我们将返回 &lt;code&gt;:kv&lt;/code&gt; 应用程序，并添加一个路由层，该路由层将允许我们根据存储桶名称在节点之间分配请求。</target>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="translated">在本章中,我们将实现解析我们在第一章中描述的命令的代码。</target>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="translated">在本章中,我们将学习ETS(Erlang Term Storage),以及如何将其作为一种缓存机制。</target>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="translated">在本章中，我们将学习 &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;cond&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt; 控制流结构。</target>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="translated">在本章中,我们将学习催生新进程的基本构造,以及在进程之间发送和接收消息。</target>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="translated">在本章中,我们将学习如何在多个实体之间保持和共享状态。如果你以前有编程经验,你可能会想到全局共享变量,但我们在这里将学习的模型是完全不同的。接下来的章节将对这里介绍的概念进行概括。</target>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="translated">在本章中，我们将学习如何通过监督 &lt;code&gt;KV.Registry&lt;/code&gt; 流程将这些概念付诸实践。毕竟，如果注册表出现问题，则整个注册表都会丢失，并且永远找不到存储桶！为了解决这个问题，我们将定义一个 &lt;code&gt;KV.Supervisor&lt;/code&gt; 模块，以确保我们的 &lt;code&gt;KV.Registry&lt;/code&gt; 在任何给定时刻启动并运行。</target>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="translated">在本章中，我们将展示Elixir中的 &lt;code&gt;=&lt;/code&gt; 运算符实际上是一个匹配运算符，以及如何使用它来对数据结构内部的模式进行匹配。最后，我们将了解用于访问先前绑定值的pin运算符 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="translated">在本章中，我们将了解二进制文件是什么，二进制文件如何与字符串相关联，以及单引号 &lt;code&gt;'like this'&lt;/code&gt; 在Elixir中的含义。</target>
        </trans-unit>
        <trans-unit id="f80acbf2877628032b5dc355543214de25ec8ae5" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">在上面的示例中，我们使用了 &lt;code&gt;.&lt;/code&gt; 调用&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;downcase&lt;/code&gt; ，并传递 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">在上面的示例中，我们使用了 &lt;code&gt;.&lt;/code&gt; 调用&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;downcase&lt;/code&gt; ，并传递 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">在此示例中，以关键字列表 &lt;code&gt;[async: true]&lt;/code&gt; 作为参数调用了&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt; &lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt;转换为：</target>
        </trans-unit>
        <trans-unit id="f2fc4f7ce9494d0ca1b19525b3d662418384d95e" translate="yes" xml:space="preserve">
          <source>In this example, Elixir will call the &lt;code&gt;__using__/1&lt;/code&gt; macro in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument.</source>
          <target state="translated">在此示例中，Elixir将使用关键字列表 &lt;code&gt;[async: true]&lt;/code&gt; 作为其参数调用&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;模块中的 &lt;code&gt;__using__/1&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="626c073c42c41fdffe192fe74593219354688844" translate="yes" xml:space="preserve">
          <source>In this example, the order that the application callbacks are called in is:</source>
          <target state="translated">在本例中,应用程序回调的调用顺序是。</target>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="translated">在这个例子中,我们也会将分区的数量设置为在线的调度器数量,这将使注册表在高并发环境下的性能更强。</target>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="translated">在此功能中，创建电子邮件地址将复制 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;domain&lt;/code&gt; 二进制文件。现在，假设您想在另一个二进制文件中使用生成的电子邮件：</target>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="translated">在本指南中,我们将学习如何构建一个完整的Elixir应用程序,拥有自己的监督树、配置、测试等。</target>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="translated">在本简介中，我们为最终编写第一个宏奠定了基础，因此让我们进入下一章。</target>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="translated">在最后一章中,我们将对我们的分布式键值存储的路由表进行配置,最后对软件进行打包生产。</target>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="translated">在这个菜单中,开发者能够启动新的外壳并在它们之间交替使用。让我们试一试吧。</target>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="translated">在本节中,我们记录了编写库时要避免的常见反模式。</target>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="translated">在本节中,我们将实现解析功能,将其文档化,并确保我们的文档是最新的doctests。这有助于我们提供具有准确代码样本的文档。</target>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="translated">在此设置中，Elixir将转义以下内容： &lt;code&gt;\0&lt;/code&gt; ， &lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 。字节可以通过 &lt;code&gt;\xNN&lt;/code&gt; 和Unicode代码点以十六进制形式给出，而 &lt;code&gt;\uNNNN&lt;/code&gt; 转义。</target>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="translated">在本教程中，我们将向您介绍Elixir基础知识-语言语法，如何定义模块，如何操作常见数据结构的特性等等。本章将重点介绍确保已安装Elixir，并且您可以成功运行名为IEx的Elixir交互式Shell。</target>
        </trans-unit>
        <trans-unit id="e88b9f3b5b9f4ee90610e431c8c812f026786e56" translate="yes" xml:space="preserve">
          <source>In your app's logger configuration, you would need to include the &lt;code&gt;:error_code&lt;/code&gt; key and you would need to include &lt;code&gt;$metadata&lt;/code&gt; as part of your log format template:</source>
          <target state="translated">在应用程序的记录器配置中，您需要包括 &lt;code&gt;:error_code&lt;/code&gt; 键，并且需要在日志格式模板中包括 &lt;code&gt;$metadata&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="translated">在你的主管树中,你会写道。</target>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="translated">内存重装</target>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="translated">索引已标准化，这意味着将从末开始计算负索引（例如 &lt;code&gt;-1&lt;/code&gt; 表示 &lt;code&gt;enumerable&lt;/code&gt; 的最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="translated">表示当前任务是否为循环任务。</target>
        </trans-unit>
        <trans-unit id="cc7fb80993cfbaec0cc1b10ecafb323d9e5355f1" translate="yes" xml:space="preserve">
          <source>Indicates no meaningful value for a field.</source>
          <target state="translated">表示该字段没有意义的值。</target>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的位与位。</target>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的bitwise OR。</target>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="translated">Infix运算符;计算其参数的位XOR。</target>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">Infix运算符;计算算术左位移位的结果。</target>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">Infix运算符;计算算术右位移位的结果。</target>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="translated">初始化、关机和重启逻辑(见于主管部门)</target>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="translated">将文件内容插入 &lt;code&gt;path&lt;/code&gt; 就像在外壳中键入文件一样。</target>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="translated">将流值作为一个副作用注入到给定的收集器中。</target>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="translated">由编译器内嵌。</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="translated">输入将被消耗,直到按下Enter键。</target>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="translated">将这些更改插入代码中，现在您可以使用以下命令 &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt; 来启动应用程序，请注意我们如何将端口作为变量传递，但如果未给出则默认为4040。</target>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 到 &lt;code&gt;map_set&lt;/code&gt; 如果 &lt;code&gt;map_set&lt;/code&gt; 没有包含它。</target>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入给定 &lt;code&gt;index&lt;/code&gt; &lt;code&gt;tuple&lt;/code&gt; 中。如果 &lt;code&gt;index&lt;/code&gt; 为负或大于 &lt;code&gt;tuple&lt;/code&gt; 的长度，则引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="1f08770187662583a163ac728c2c3de32f5a374d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入给定 &lt;code&gt;index&lt;/code&gt; &lt;code&gt;tuple&lt;/code&gt; 中。如果 &lt;code&gt;index&lt;/code&gt; 为负或大于 &lt;code&gt;tuple&lt;/code&gt; 的长度，则引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。索引从零开始。</target>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="translated">在两个文件之间插入强制性的换行符。</target>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="translated">在两份文件之间插入一个强制性的单一空格。</target>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="translated">在元组的末尾插入一个元素。</target>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="translated">在元组中插入一个元素。</target>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="translated">根据转换函数将给定的 &lt;code&gt;enumerable&lt;/code&gt; 插入到 &lt;code&gt;collectable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="translated">将给定的 &lt;code&gt;enumerable&lt;/code&gt; 插入到 &lt;code&gt;collectable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40d18588e5bd7683cf2537e97eac6badfff84230" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt;内部，您可以使用 &lt;code&gt;@protocol&lt;/code&gt; 访问正在实现的协议，并使用@for访问正在 &lt;code&gt;@for&lt;/code&gt; 定义的模块。</target>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">在&lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt;内部，您可以使用 &lt;code&gt;@protocol&lt;/code&gt; 访问正在实施的协议，并使用@for访问正在 &lt;code&gt;@for&lt;/code&gt; 定义的模块。</target>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="translated">里面 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块可能会引入其他的关键词，如 &lt;code&gt;else&lt;/code&gt; 在使用 &lt;code&gt;if&lt;/code&gt; 以上。 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 之间支持的关键字是静态的，并且是：</target>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="translated">在IEx内部， &lt;code&gt;Ctrl+C&lt;/code&gt; 将打开 &lt;code&gt;BREAK&lt;/code&gt; 菜单。在此菜单中，您可以退出外壳程序，查看进程和ETS表信息等等。</target>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="translated">在模块内部，我们可以使用 &lt;code&gt;def/2&lt;/code&gt; 定义函数，并使用 &lt;code&gt;defp/2&lt;/code&gt; 定义私有函数。可以从其他模块调用由 &lt;code&gt;def/2&lt;/code&gt; 定义的函数，而只能在本地调用私有函数。</target>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="translated">伞内。</target>
        </trans-unit>
        <trans-unit id="113a1b9884a89043121b7d7c5d9c0a394636f751" translate="yes" xml:space="preserve">
          <source>Inside your umbrella, you can define multiple releases:</source>
          <target state="translated">在你的保护伞里面,你可以定义多个版本。</target>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="translated">数字中不重要的数字将保持不变。然而,格式化程序总是为超过5位的十进制数字插入下划线,并将十六进制数字转换为大写字母。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">检查&lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Inspect.Error &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="translated">检查.检查 (2)</target>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="translated">Inspect.t (0)</target>
        </trans-unit>
        <trans-unit id="728cbccfe7f399bad0002a59ae5fe929d7156d22" translate="yes" xml:space="preserve">
          <source>Inspecting behaviours</source>
          <target state="translated">检查行为</target>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">使用IO &lt;code&gt;device&lt;/code&gt; 根据给定的选项检查 &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="translated">检查给定 &lt;code&gt;item&lt;/code&gt; 并将其写入设备。</target>
        </trans-unit>
        <trans-unit id="bf74027804ecc526da780a7ae1724e9dedba411f" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">根据&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议检查给定的参数。第二个参数是关键字列表，其中包含用于控制检查的选项。</target>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">根据&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;协议检查给定的参数。第二个参数是关键字列表，其中包含用于控制检查的选项。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">安装外部依赖项很简单。最常见的是，我们使用&lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;，通过在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中的deps函数中列出依赖项：</target>
        </trans-unit>
        <trans-unit id="8ba9749301614c940b015d94dafda1de33dee733" translate="yes" xml:space="preserve">
          <source>Installs Hex locally.</source>
          <target state="translated">在本地安装Hex。</target>
        </trans-unit>
        <trans-unit id="fe27c68af6ef5819f7f323521831724db906052b" translate="yes" xml:space="preserve">
          <source>Installs an archive locally.</source>
          <target state="translated">在本地安装存档。</target>
        </trans-unit>
        <trans-unit id="ac37dc92363c2e268a61314e8483b955fcaa10e1" translate="yes" xml:space="preserve">
          <source>Installs an escript locally.</source>
          <target state="translated">在本地安装一个脚本。</target>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">相反，&lt;strong&gt;这样做&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="translated">取而代之的 &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt; ， &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; 可以使用。</target>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="translated">代替 &lt;code&gt;spawn/1&lt;/code&gt; 和 &lt;code&gt;spawn_link/1&lt;/code&gt; ，我们使用 &lt;code&gt;Task.start/1&lt;/code&gt; 和 &lt;code&gt;Task.start_link/1&lt;/code&gt; 返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 而不是PID。这就是使任务可以在监督树中使用的原因。此外， &lt;code&gt;Task&lt;/code&gt; 提供了便利功能，例如 &lt;code&gt;Task.async/1&lt;/code&gt; 和 &lt;code&gt;Task.await/1&lt;/code&gt; ，以及简化分发的功能。</target>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="translated">我们将创建自己的&lt;em&gt;进程注册表&lt;/em&gt;，而不是使用内置名称工具，该&lt;em&gt;进程注册表&lt;/em&gt;将存储桶名称与存储桶进程相关联。</target>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="translated">与其问&amp;ldquo;如何在Elixir中做X&amp;rdquo;，不如问&amp;ldquo;如何在Elixir中解决Y&amp;rdquo;。换句话说，不要问如何实施特定的解决方案，而要描述眼前的问题。说明问题可以提供更多的背景信息，并减少对正确答案的偏见。</target>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="translated">流不生成中间列表，而是构建一系列计算，这些计算仅在将基础流传递给 &lt;code&gt;Enum&lt;/code&gt; 模块时才被调用。在处理大型（&lt;em&gt;可能无限&lt;/em&gt;）的集合时，流非常有用。</target>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="translated">结构不需要与映射共享协议实现，而是需要它们自己的协议实现。由于 &lt;code&gt;MapSet&lt;/code&gt; 具有预先计算的大小，可以通过 &lt;code&gt;MapSet.size/1&lt;/code&gt; 访问，因此我们可以为其定义 &lt;code&gt;Size&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="translated">相反，您可以存储 &lt;code&gt;try&lt;/code&gt; 表达式的值：</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="translated">整数码点</target>
        </trans-unit>
        <trans-unit id="6329201f484f49f6ec697e329c43d6e6707a772f" translate="yes" xml:space="preserve">
          <source>Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">代表一周的整数,其中1是星期一,7是星期天。</target>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="translated">Elixir中的整数（ &lt;code&gt;1234&lt;/code&gt; ）和浮点（ &lt;code&gt;123.4&lt;/code&gt; ）表示为数字序列，出于可读性目的，这些数字可以用下划线分隔，例如 &lt;code&gt;1_000_000&lt;/code&gt; 。整数在其表示中绝不包含点（ &lt;code&gt;.&lt;/code&gt; ）。浮点数包含一个点和该点之后的至少一位数字。浮点数也支持科学计数法，例如 &lt;code&gt;123.4e10&lt;/code&gt; 或 &lt;code&gt;123.4E10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">整数可以带 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; ，默认为 &lt;code&gt;unsigned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="translated">其他基数和Unicode码点中的整数。</target>
        </trans-unit>
        <trans-unit id="cca6e2eff6c59ea0c8e68e40ac9ddccb40190ce0" translate="yes" xml:space="preserve">
          <source>Integrates with Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; to convert terms to Elixir syntax.</source>
          <target state="translated">与Erlang的&lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt;集成以将术语转换为Elixir语法。</target>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="translated">与Mix的整合</target>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="translated">与操作系统级别的&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;跟踪&lt;/a&gt;器（例如Linux Trace Toolkit，&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE&lt;/a&gt;和&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap）&lt;/a&gt;集成</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="f4f8ff7b4770e825fb6a5a6969991c0326746be8" translate="yes" xml:space="preserve">
          <source>Internal and external functions</source>
          <target state="translated">内部和外部职能</target>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="translated">内部依赖性</target>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="translated">内部依赖关系是特定于您的项目的依赖关系。在您的项目/公司/组织范围之外，它们通常没有任何意义。大多数时候，无论出于技术，经济还是业务原因，您都希望对它们进行保密。</target>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="translated">块表达式的内部特殊形式。</target>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="translated">内部特殊表格,用于保存别名信息。</target>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">在内部，&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;的实现如下：</target>
        </trans-unit>
        <trans-unit id="d4d06a23df2e5f8415d5588be7a06fbd36f8ee7c" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">在内部，&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;的实现如下：</target>
        </trans-unit>
        <trans-unit id="444e75baf2b8d0e94b94fc3e049285ea03c10723" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">在内部，此功能使用&lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;与外界进行交互。但是，如果您计划运行一个长时间运行的程序，则端口将确保关闭stdin / stdout设备，但不会自动终止该程序。&lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;模块的文档在&amp;ldquo;僵尸进程&amp;rdquo;部分下描述了此问题以及可能的解决方案。</target>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">在内部，此功能使用&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;与外界进行交互。但是，如果您计划运行一个长时间运行的程序，则端口将确保关闭stdin / stdout设备，但不会自动终止该程序。&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;模块的文档在&amp;ldquo;僵尸进程&amp;rdquo;部分下描述了此问题以及可能的解决方案。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="translated">符号中的插值和逃逸功能</target>
        </trans-unit>
        <trans-unit id="d142f547e062671930a17d6dfc85716aa23453f5" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in string sigils</source>
          <target state="translated">字符串中的插值和转义功能。</target>
        </trans-unit>
        <trans-unit id="5064a21ec7e025e2514366b24e54341fcd2022ec" translate="yes" xml:space="preserve">
          <source>Interpreting integers as codepoints may lead to some surprising behavior. For example, if you are storing a list of integers that happen to range between 0 and 127, by default IEx will interpret this as a charlist and it will display the corresponding ASCII characters.</source>
          <target state="translated">将整数解释为代码点可能会导致一些令人惊讶的行为。例如,如果您存储的整数列表恰好在0到127之间,默认情况下,IEx会将其解释为一个charlist,并显示相应的ASCII字符。</target>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">将 &lt;code&gt;element&lt;/code&gt; 散布在枚举的每个元素之间。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="translated">搅拌器介绍</target>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="translated">无效(当setup_all失败时)</target>
        </trans-unit>
        <trans-unit id="44c16916fee38218c7470ca5f830ff4fbd096ffc" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfd_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfd_binary/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfc_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfc_binary/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkd_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfkd_binary/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkc_binary-1&quot;&gt;&lt;code&gt;:unicode.characters_to_nfkc_binary/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">无效的Unicode代码点将被跳过，其余字符串将被转换。如果希望算法停止并在无效的代码点上返回，请改用&lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfd_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfd_binary/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfc_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfc_binary/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkd_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfkd_binary/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://www.erlang.org/doc/man/unicode.html#characters_to_nfkc_binary-1&quot;&gt; &lt;code&gt;:unicode.characters_to_nfkc_binary/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用所需的回调&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="translated">在每次嵌套开始时调用。</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">为了访问给定术语 &lt;code&gt;term&lt;/code&gt; 中存储在 &lt;code&gt;key&lt;/code&gt; 下的值而调用。</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">为了访问 &lt;code&gt;key&lt;/code&gt; 下的值并同时更新它而调用。</target>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="translated">在某些情况&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;用以获取GenServer状态的格式化版本。</target>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">调用以从给定的数据结构中&amp;ldquo;弹出&amp;rdquo; &lt;code&gt;key&lt;/code&gt; 下的值。</target>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="translated">当加载了不同版本的模块（热代码交换）并且应更改状态的术语结构时，调用此命令以更改&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;的状态。</target>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="translated">调用以处理 &lt;code&gt;continue&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="translated">调用来处理所有其他信息。</target>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="translated">调用以处理异步&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;消息。</target>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="translated">调用以处理同步&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;消息。&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;将一直阻塞，直到收到答复为止（除非呼叫超时或节点断开连接）。</target>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="translated">初始化配置提供者时调用。</target>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="translated">当服务器即将退出时调用。它应该做任何必要的清理工作。</target>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="translated">启动服务器时调用。&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt;将阻塞直到返回。</target>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="translated">为累加器中 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="translated">在嵌套结束时调用。</target>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">为给定 &lt;code&gt;registry&lt;/code&gt; 在每个分区的 &lt;code&gt;key&lt;/code&gt; 下的所有条目调用回调。</target>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用给定的 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 列表调用给定的匿名函数 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 列表从 &lt;code&gt;module&lt;/code&gt; 调用给定函数。</target>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="translated">对 &lt;code&gt;enumerable&lt;/code&gt; 每个元素调用给定的函数，以将其简化为单个元素，同时保留一个累加器。</target>
        </trans-unit>
        <trans-unit id="1dc0b084acbb8122b7369800b4f64ab048152c7c" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;mix&lt;/code&gt; is the same as &lt;code&gt;mix run&lt;/code&gt;. Therefore, if you want to pass a flag to &lt;code&gt;mix&lt;/code&gt; or &lt;code&gt;iex -S mix&lt;/code&gt;, we just need to add the task name and the desired flags. For example, run &lt;code&gt;iex -S mix run --no-start&lt;/code&gt;:</source>
          <target state="translated">调用 &lt;code&gt;mix&lt;/code&gt; 与 &lt;code&gt;mix run&lt;/code&gt; 相同。因此，如果要传递标志进行 &lt;code&gt;mix&lt;/code&gt; 或 &lt;code&gt;iex -S mix&lt;/code&gt; ，则只需添加任务名称和所需的标志。例如，运行 &lt;code&gt;iex -S mix run --no-start&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e66a67e4e899cac7ac07ae70b407650c10def5dc" translate="yes" xml:space="preserve">
          <source>Invoking this function when the distribution has already been started, either via the command line interface or dynamically, will return an error.</source>
          <target state="translated">当发行版已经启动时,无论是通过命令行接口还是动态启动,调用这个函数都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">是与。</target>
        </trans-unit>
        <trans-unit id="b48400f8fe9d35749daa7cbd1527dc39de359530" translate="yes" xml:space="preserve">
          <source>It MUST &lt;code&gt;import Config&lt;/code&gt; at the top instead of the deprecated &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">它必须在顶部 &lt;code&gt;import Config&lt;/code&gt; 而不是不建议 &lt;code&gt;use Mix.Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3354e4898e62c5bb42e290c77847d16af508d4f" translate="yes" xml:space="preserve">
          <source>It MUST NOT access &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt; in any way, as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt; is a build tool and it is not available inside releases</source>
          <target state="translated">它绝不能以任何方式访问&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;，因为&lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;是构建工具，并且在发行版中不可用</target>
        </trans-unit>
        <trans-unit id="7e1d9cf438c969dee7915e9b562a69ea08c11e60" translate="yes" xml:space="preserve">
          <source>It MUST NOT import any other configuration file via &lt;code&gt;import_config&lt;/code&gt;</source>
          <target state="translated">它一定不能通过 &lt;code&gt;import_config&lt;/code&gt; 导入任何其他配置文件</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="translated">它接受一个import_paths列表，如果尝试再次 &lt;code&gt;imported_paths&lt;/code&gt; 该列表应提高（以避免递归导入）。</target>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">它接受一组用于配置&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;options&lt;/code&gt; （&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt;接受的选项相同）。</target>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="translated">它接受与&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;相同的选项，因为这两个函数都建立在此函数之上。该函数可能返回：</target>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="translated">它接受struct模块或结构本身，并从给定结构或从给定模块生成的新结构中删除 &lt;code&gt;__struct__&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="translated">它允许开发人员动态地添加、删除和注册属性,附加文档等。</target>
        </trans-unit>
        <trans-unit id="2ac59abc929bedbd71d6ab74f36247bff27a3d81" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 process. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">它允许开发人员使用给定的密钥查找一个或多个进程。如果注册表具有 &lt;code&gt;:unique&lt;/code&gt; 键，则键指向0或1进程。如果注册表允许 &lt;code&gt;:duplicate&lt;/code&gt; 键，则单个键可能指向任意数量的进程。在这两种情况下，不同的密钥可以标识相同的过程。</target>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">它允许开发人员使用给定的密钥查找一个或多个进程。如果注册表具有 &lt;code&gt;:unique&lt;/code&gt; 键，则键指向0或1个进程。如果注册表允许 &lt;code&gt;:duplicate&lt;/code&gt; 键，则单个键可能指向任意数量的进程。在这两种情况下，不同的密钥可以标识相同的过程。</target>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它还接受其他选项，有关可用选项的列表，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="translated">它还接受格式为 &lt;code&gt;function/arity&lt;/code&gt; 和 &lt;code&gt;module.function/arity&lt;/code&gt; 的函数，例如：</target>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="translated">它还接受单个模块参数来列出所有可用的行为回调。</target>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="translated">它还会检查收件箱是否有匹配的输入信息。</target>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">它还可以与运算符和其他构造一起使用（尝试 &lt;code&gt;h +/2&lt;/code&gt; ）。不带参数调用 &lt;code&gt;h&lt;/code&gt; 将显示 &lt;code&gt;IEx.Helpers&lt;/code&gt; 的文档，这是定义 &lt;code&gt;h&lt;/code&gt; 和其他功能的位置。</target>
        </trans-unit>
        <trans-unit id="66bb36cef2226ba0f885d74efad89fc9715f130c" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;:ok&lt;/code&gt;. Raises an error for invalid options.</source>
          <target state="translated">它总是返回 &lt;code&gt;:ok&lt;/code&gt; 。针对无效选项引发错误。</target>
        </trans-unit>
        <trans-unit id="5c52aede24529ec1285e253d78f2de5411948ef5" translate="yes" xml:space="preserve">
          <source>It assumes the application exists in the release.</source>
          <target state="translated">它假设应用程序存在于版本中。</target>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="translated">它可以是常规文件，目录，套接字，符号链接，命名管道或设备文件。对于指向不存在的目标的符号链接返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="translated">可以这样升级到DynamicSupervisor。</target>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="translated">它可以在 &lt;code&gt;mix.exs&lt;/code&gt; 中使用，以将新的编译器添加到Mix之前或之后：</target>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="translated">它包含以下领域:</target>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="translated">它包含这些领域。</target>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">也可以通过使用多个守卫来纠正,这样如果一个异常导致一个守卫失败,下一个守卫就会被评估。</target>
        </trans-unit>
        <trans-unit id="d0ae36b9918c76d1dbdaba834a0193896ca365cc" translate="yes" xml:space="preserve">
          <source>It defaults to safely download a Rebar copy from Hex's CDN. However, a URL can be given as argument, usually for an existing local copy of Rebar:</source>
          <target state="translated">默认情况下,它可以从Hex的CDN安全下载Rebar副本。但是,可以给出一个URL作为参数,通常是Rebar的现有本地副本。</target>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="translated">这取决于。只要我们仅依赖于该状态的非共享分区，就可以依靠共享状态。尽管多个注册表可以在共享存储桶管理器上启动存储桶，但是这些存储桶和注册表彼此隔离。如果使用诸如 &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; 之类的函数，该函数将计算所有注册表中的所有存储桶，并发运行时可能会得出不同的结果，这只会导致并发问题。</target>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="translated">区别在于，使用 &lt;code&gt;--only&lt;/code&gt; 选项时，如果不执行任何测试，则测试套件将失败。</target>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="translated">它似乎根本不起作用。那是因为我们在接受连接的同一过程中处理请求。连接一个客户端后，我们将无法接受另一个客户端。</target>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，它启用漂亮的打印，宽度为80个字符。可以通过显式传递 &lt;code&gt;:width&lt;/code&gt; 选项来更改宽度。</target>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="translated">为了方便起见而存在。例如，您可以在 &lt;code&gt;mix.exs&lt;/code&gt; 内部调用它以读取您决定移至配置文件的一些外部数据：</target>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="translated">它期望一个 &lt;code&gt;radius&lt;/code&gt; ，该半径选择我们应该在当前行之前和之后打印多少行。默认情况下， &lt;code&gt;radius&lt;/code&gt; 为两行：</target>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="translated">它需要一个子规范或模块，类似于为&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt;提供的规范。例如，如果您的应用程序通过运行以下内容启动监管树：</target>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="translated">它需要一个要编译的文件列表和一个可选的路径来写入编译后的代码。默认情况下,文件是在内存中编译的。要将编译后的文件写入当前目录,可以给一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6adc6a5d8736969f9827e5e4d2dbab0ae103ab01" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is not passed it will default to &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt;, which always succeeds. Otherwise, the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它期望将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;放入时区。如果未通过时区，则默认为 &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt; ，该方法始终会成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="8a2620b634b0dd22db12b71fb16f9100f9f18265" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is not passed it will default to &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt;, which always succeeds. Otherwise, the DateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它期望将&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;放入时区。如果未通过时区，则默认为 &lt;code&gt;&quot;Etc/UTC&quot;&lt;/code&gt; ，该方法始终会成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查DateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="546a02d155d91f970f8b486494def9374e27bedc" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它需要一个时区来放置&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;。如果时区为&amp;ldquo; Etc / UTC&amp;rdquo;，则它总是成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查NaiveDateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它需要一个时区来放置&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;。如果时区为&amp;ldquo; Etc / UTC&amp;rdquo;，则它总是成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查NaiveDateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">它需要一个时区来放置NaiveDateTime。如果时区为&amp;ldquo; Etc / UTC&amp;rdquo;，则它总是成功。否则，将根据指定为 &lt;code&gt;time_zone_database&lt;/code&gt; 的时区数据库检查NaiveDateTime 。请参阅模块文档中的&amp;ldquo;时区数据库&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">它期望一个累加器和一个函数来接收每个可枚举的元素，并且必须返回一个包含新的可枚举（通常是列表）的元组，并以新的累加器或以 &lt;code&gt;:halt&lt;/code&gt; 作为第一个元素，以累加器为第二个元组。</target>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">它需要一个累加器和一个函数来接收每个流元素和一个累加器，并且必须返回一个包含新流（通常是列表）的元组，其中包含新的累加器，或者以 &lt;code&gt;:halt&lt;/code&gt; 作为第一个元素，而将累加器作为第二个元组。</target>
        </trans-unit>
        <trans-unit id="cccf2ce5212dd9d14c0a4002d35324d8f82c2fda" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator. It must return a tuple, where the first element is a new stream (often a list) or the atom &lt;code&gt;:halt&lt;/code&gt;, and the second element is the accumulator to be used by the next element, if any, in both cases.</source>
          <target state="translated">它期望一个累加器和一个函数来接收每个流元素和一个累加器。它必须返回一个元组，其中第一个元素是一个新流（通常是一个列表）或atom &lt;code&gt;:halt&lt;/code&gt; ，第二个元素是下一个元素（如果有）在两种情况下都将使用的累加器。</target>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="translated">碰巧我们也可以使用这种同样的语法来更新值。</target>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="translated">它必须被替换为:</target>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="translated">它包括分配（例如 &lt;code&gt;@foo&lt;/code&gt; ）以及将来可能的其他便利。</target>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="translated">它包括许多功能。</target>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="translated">这是应传递给&lt;a href=&quot;#to_argv/2&quot;&gt; &lt;code&gt;to_argv/2&lt;/code&gt; &lt;/a&gt;组相同的 &lt;code&gt;options&lt;/code&gt; 给&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;。只能使用 &lt;code&gt;:switches&lt;/code&gt; 信息正确地重构某些开关。</target>
        </trans-unit>
        <trans-unit id="7eb61a3d0a7df51c644f050632b4aa72ddabe51e" translate="yes" xml:space="preserve">
          <source>It is also common to define your setup as a series of functions, which are put together by calling &lt;code&gt;setup&lt;/code&gt; or &lt;code&gt;setup_all&lt;/code&gt; with a list of atoms. Each of these functions receive the context and can return any of the values allowed in &lt;code&gt;setup&lt;/code&gt; blocks:</source>
          <target state="translated">将设置定义为一系列功能也是很常见的，这些功能可以通过使用原子列表调用 &lt;code&gt;setup&lt;/code&gt; 或 &lt;code&gt;setup_all&lt;/code&gt; 来组合在一起。这些函数中的每一个都接收上下文，并且可以返回 &lt;code&gt;setup&lt;/code&gt; 块中允许的任何值：</target>
        </trans-unit>
        <trans-unit id="c0856684d2283019235a3b8fb6bf7df63dcb5c31" translate="yes" xml:space="preserve">
          <source>It is also possible to capture public module functions and pass them around as if they were anonymous functions by using the capture operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;amp;/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.&amp;amp;/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">也可以通过使用捕获运算符&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;amp;/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.&amp;amp;/1&lt;/code&gt; &lt;/a&gt;来捕获公共模块函数，并将它们像匿名函数一样传递：</target>
        </trans-unit>
        <trans-unit id="56aeb1cfede9d1959649b5d6d4fd4f20a2043a1a" translate="yes" xml:space="preserve">
          <source>It is also possible to format code across the whole project by passing a list of patterns and files to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix format&lt;/code&gt;&lt;/a&gt;, as shown at the top of this task documentation. This list can also be set in the &lt;code&gt;.formatter.exs&lt;/code&gt; file under the &lt;code&gt;:inputs&lt;/code&gt; key.</source>
          <target state="translated">也可以通过传递一系列模式和文件以&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix format&lt;/code&gt; &lt;/a&gt;来格式化整个项目的代码，如本任务文档顶部所示。这个列表还可以在设置 &lt;code&gt;.formatter.exs&lt;/code&gt; 下文件 &lt;code&gt;:inputs&lt;/code&gt; 关键。</target>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="translated">也可以使用 &lt;code&gt;put_elem/3&lt;/code&gt; 在一个元组的特定索引处放置一个元素：</target>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="translated">还可以注册 &lt;code&gt;pid&lt;/code&gt; ，为其指定一个名称，并允许知道该名称的每个人向其发送消息：</target>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="translated">也可以在主管下生成任务。所述&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;模块实现&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;功能，这允许其被直接主管下通过使一个元组与运行功能开始：</target>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="translated">它在 &lt;code&gt;fn/end&lt;/code&gt; 之间也用于构建匿名函数：</target>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="translated">将 &lt;code&gt;IO.inspect/2&lt;/code&gt; 与&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;binding()&lt;/code&gt; &lt;/a&gt;一起使用也很常见，该方法返回所有变量名及其值：</target>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="translated">它是一个从1到366的整数。</target>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="translated">它是一个从1到4的整数。</target>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">它是1到7的整数,其中1是周一,7是周日。</target>
        </trans-unit>
        <trans-unit id="9d6b7aa9053923985210f1530605583decd65914" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is the given &lt;code&gt;starting_on&lt;/code&gt; weekday. For example, if &lt;code&gt;starting_on&lt;/code&gt; is set to &lt;code&gt;:monday&lt;/code&gt;, then 1 is Monday and 7 is Sunday.</source>
          <target state="translated">整数形式，取值范围是1到7，其中1是指定的工作日 &lt;code&gt;starting_on&lt;/code&gt; 。例如，如果 &lt;code&gt;starting_on&lt;/code&gt; 设置为 &lt;code&gt;:monday&lt;/code&gt; ，则1是星期一，7是星期日。</target>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">它仅在&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;表达式的 &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;rescue&lt;/code&gt; 子句中可用。</target>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="translated">正是这种监督系统使Elixir中的 &lt;code&gt;try/catch&lt;/code&gt; 和 &lt;code&gt;try/rescue&lt;/code&gt; 之类的构造如此罕见。我们宁愿&amp;ldquo;快速失败&amp;rdquo;，也不愿挽救错误，因为监督树将确保我们的应用程序在错误发生后将返回已知的初始状态。</target>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="translated">&lt;strong&gt;格式化功能不要失败&lt;/strong&gt;非常重要，因为它会使特定的记录器实例关闭，从而导致系统暂时丢失消息。如有必要，请将函数包装在 &lt;code&gt;rescue&lt;/code&gt; 消息中，并记录一条默认消息：</target>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="translated">在使用宏之前定义宏非常重要。如果在宏调用之前未定义宏，则会在运行时引发错误，因为该宏将不会展开，并且会转换为函数调用：</target>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="translated">重要的是,你要选择一个不阻塞也不试图直接在终端中运行编辑器的编辑器命令。基于命令行的编辑器可能需要额外的配置,所以它们会在一个单独的窗口中打开给定的文件和行。</target>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="translated">重要的是要记住，在 &lt;code&gt;try/catch/rescue/after&lt;/code&gt; 块内定义的变量不会泄漏到外部上下文。这是因为 &lt;code&gt;try&lt;/code&gt; 块可能会失败，因此这些变量可能永远都不会被绑定。换句话说，此代码无效：</target>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="translated">重要的是要考虑分布式代理的局限性。代理提供了两个API,一个是与匿名函数一起工作的API,另一个是期望显式模块、函数和参数的API。</target>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="translated">重要的是要强调步骤2是阻塞性步骤。主管的终止触发子级终止的递归链，因此有序地关闭了所有后代进程。该&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;回调只是整个监督树终止后调用。</target>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="translated">需要注意的是,有几点很重要。</target>
        </trans-unit>
        <trans-unit id="3bb3eb88d00232d84e73101145b87680a8e850e6" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">重要的是要注意&lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;是词法的。这意味着您可以在特定的函数中导入特定的宏：</target>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">重要的是要注意一个没有 &lt;code&gt;!&lt;/code&gt; 并不意味着一个函数永远不会提高。例如，在参数错误的情况下，即使&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;也会失败：</target>
        </trans-unit>
        <trans-unit id="aa95687972f4da1c12036d1d732365101465e0f4" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">重要的是要注意一个没有 &lt;code&gt;!&lt;/code&gt; 的名字！并不意味着一个函数永远不会提高。例如，在参数错误的情况下，即使&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;也会失败：</target>
        </trans-unit>
        <trans-unit id="0c642ed82cafd6a24d5b1cc716988f94df5a4508" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">重要的是要注意，读取属性会获取其当前值的快照。换句话说，该值是在编译时而不是在运行时读取的。检查&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;模块的其他功能，以操作模块属性。</target>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">重要的是要注意，读取属性会获取其当前值的快照。换句话说，该值是在编译时而不是在运行时读取的。检查&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;模块的其他功能，以操作模块属性。</target>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">重要的是要注意&lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;是词法的。这意味着您可以在特定的函数中导入特定的宏：</target>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不建议在OTP行为（例如&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; )中&lt;/a&gt; &lt;code&gt;await&lt;/code&gt; 长时间运行的任务。相反，您应该匹配来自&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调内部任务的消息。有关消息格式的更多信息，请参见&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="a27744ee2d67c05a1fd73d07307738a8c486c4d3" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">建议不要在OTP行为（例如&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; )中&lt;/a&gt; &lt;code&gt;await&lt;/code&gt; 长时间运行的任务。相反，您应该匹配来自&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;回调内的任务的消息。有关消息格式的更多信息，请参见&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="f4e76fae45b6859058ea6f91264d2611d753a491" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; long-running tasks inside an OTP behaviour such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#await/2&quot;&gt;&lt;code&gt;await/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">不建议在OTP行为（例如&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; )中&lt;/a&gt; &lt;code&gt;await&lt;/code&gt; 长时间运行的任务。有关更多信息，请参见&lt;a href=&quot;#await/2&quot;&gt; &lt;code&gt;await/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="translated">终止调用方时，不需要调用此函数，除非是由于 &lt;code&gt;:normal&lt;/code&gt; 退出或任务正在捕获而退出。如果调用方由于 &lt;code&gt;:normal&lt;/code&gt; 以外的原因而退出，并且任务未捕获退出，则调用方的退出信号将停止任务。调用者可以使用 &lt;code&gt;:shutdown&lt;/code&gt; 退出，以关闭其所有链接的进程，包括任务，这些进程不会捕获退出而不生成任何日志消息。</target>
        </trans-unit>
        <trans-unit id="8334dc9705c04a7a750a85ba594ba8cd9d9eec49" translate="yes" xml:space="preserve">
          <source>It is possible to add one or more steps before and after the release is assembled. This can be done with the &lt;code&gt;:steps&lt;/code&gt; option:</source>
          <target state="translated">可以在发行发行版前后添加一个或多个步骤。这可以通过 &lt;code&gt;:steps&lt;/code&gt; 选项来完成：</target>
        </trans-unit>
        <trans-unit id="d286fc13ee24e748fd4ca773cb4fabc977988588" translate="yes" xml:space="preserve">
          <source>It is possible to configure the level to capture with &lt;code&gt;:level&lt;/code&gt;, which will set the capturing level for the duration of the capture, for instance, if the log level is set to :error any message with the lower level will be ignored. The default level is &lt;code&gt;nil&lt;/code&gt;, which will capture all messages. The behaviour is undetermined if async tests change Logger level.</source>
          <target state="translated">可以使用 &lt;code&gt;:level&lt;/code&gt; 配置捕获级别，这将在捕获期间设置捕获级别，例如，如果日志级别设置为：error，则任何较低级别的消息都将被忽略。默认级别为 &lt;code&gt;nil&lt;/code&gt; ，它将捕获所有消息。如果异步测试更改了Logger级别，则该行为不确定。</target>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="translated">可以通过在虚拟机中传递一些启用它的选项来获取shell历史记录。这可以在启动 IEx 时根据需要进行。</target>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="translated">它可以实现所有Elixir类型的协议。</target>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="translated">通过为IEx 提供 &lt;code&gt;--dot-iex&lt;/code&gt; 选项，可以加载另一个文件。请参阅 &lt;code&gt;iex --help&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="translated">它由格式员接收,包含以下字段:</target>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="translated">建议在你的应用程序的启动回调中调用这个函数,以防你想注册新的URI。</target>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="translated">建议后端至少支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="translated">建议处理程序忽略组长与安装处理程序的节点不同的消息。例如:</target>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="translated">建议定义结构的类型。按照惯例，这种类型称为 &lt;code&gt;t&lt;/code&gt; 。要在类型内部定义结构，请使用struct文字语法：</target>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="translated">建议仅在定义结构的类型时使用结构语法。当引用另一个结构时，最好使用 &lt;code&gt;User.t&lt;/code&gt; 代替 &lt;code&gt;%User{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 之间的 &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; 构造上可以看到：</target>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="translated">它是&lt;a href=&quot;#os_time/0&quot;&gt; &lt;code&gt;os_time/0&lt;/code&gt; &lt;/a&gt;的VM视图。在时间扭曲的情况下，它们可能不匹配，尽管VM会努力使其对齐。这次不是单调的。</target>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">它对于在初始化后执行工作,或者在回调中分步进行工作,沿途更新进程状态很有用。</target>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="translated">它通常被编译成一个原子。</target>
        </trans-unit>
        <trans-unit id="8399d5e7ea32483e0653c8979fe14b6e85b08287" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;&lt;code&gt;mix format&lt;/code&gt;&lt;/a&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">值得一提的是，某些任务（例如上例中的&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt; &lt;code&gt;mix format&lt;/code&gt; &lt;/a&gt;命令）可以接受多个文件，因此可以将其重写为：</target>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">值得一提的是，某些任务（例如上例中的 &lt;code&gt;format&lt;/code&gt; 命令）可以接受多个文件，因此可以将其重写为：</target>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">值得注意的是,IO流是有副作用的,每次复盘都可能得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="translated">但是,可以通过调用以下命令来自定义操作系统的退出信号。</target>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="translated">它主要包括:</target>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="translated">它也可以在位串中用来指定一个给定位段的类型。</target>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">它可以被&lt;em&gt;完成&lt;/em&gt;时，枚举由到达其端部结束，或者&lt;em&gt;停止&lt;/em&gt; / &lt;em&gt;暂停&lt;/em&gt;时枚举被终止或暂停的&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;的功能。</target>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">如果找不到别名或任务或该任务无效，则可能会引发异常。检查&lt;a href=&quot;#get!/1&quot;&gt; &lt;code&gt;get!/1&lt;/code&gt; &lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="29d3bbbc7e626b9af27ea95ab16c0ff3bafa7043" translate="yes" xml:space="preserve">
          <source>It may return:</source>
          <target state="translated">它可能会回来。</target>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="translated">它仅记录了一个错误，但父进程仍在运行。那是因为流程是孤立的。如果我们希望一个过程中的故障传播到另一个过程中，则应将它们链接起来。这可以通过 &lt;code&gt;spawn_link/1&lt;/code&gt; 完成：</target>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="translated">它必须是一个带有以下 &quot;标签 &quot;的元组。</target>
        </trans-unit>
        <trans-unit id="30bfead53f6532d0dcb4d8f1a07f530eb7b28e4c" translate="yes" xml:space="preserve">
          <source>It must be added to &lt;a href=&quot;#t:utc_offset/0&quot;&gt;&lt;code&gt;utc_offset/0&lt;/code&gt;&lt;/a&gt; to get the total offset from UTC used for &quot;wall time&quot;.</source>
          <target state="translated">必须将其添加到&lt;a href=&quot;#t:utc_offset/0&quot;&gt; &lt;code&gt;utc_offset/0&lt;/code&gt; 中,&lt;/a&gt;以获取用于&amp;ldquo;挂墙时间&amp;rdquo;的UTC的总偏移量。</target>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="translated">它必须返回Elixir的引用表达式进行嵌套。</target>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="translated">它必须返回Elixir的模板的引用表达式。</target>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="translated">它必须返回仅在嵌套内部使用的新状态。嵌套终止后，将恢复当前 &lt;code&gt;state&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9f2946629b87a86268abeeb2d37b8eeaaa2dbc9" translate="yes" xml:space="preserve">
          <source>It must return the current lock.</source>
          <target state="translated">它必须返回当前的锁。</target>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="translated">它必须返回初始状态。</target>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="translated">它必须返回更新后的状态。</target>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="translated">它在比较字符串之前,对它们进行归一化形式正则分解(NFD)。这个功能相当于。</target>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 不是本地进程，则会引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">当index为负或超出tuple元素范围时，将引发&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76fb97ed0a7148c60ad0f98f15c424a1449add5a" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;pid&lt;/code&gt; 不是本地进程，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51c53ba47f1eded5769c444b1e03509454cd6f04" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">当index为负或超出tuple元素范围时，将引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edab83575d7f73053cab67ad9c4668e68f7c32f0" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;https://hexdocs.pm/elixir/BadMapError.html&quot;&gt;&lt;code&gt;BadMapError&lt;/code&gt;&lt;/a&gt; if the first element is not a map.</source>
          <target state="translated">如果第一个元素不是地图，则会引发&lt;a href=&quot;https://hexdocs.pm/elixir/BadMapError.html&quot;&gt; &lt;code&gt;BadMapError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="translated">如果定义中使用了不允许在守卫中使用的表达式,它就会在编译时引发,否则就会创建一个可以在守卫内部或外部使用的宏。</target>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="translated">如果定义中使用了不允许在守卫中使用的表达式,它就会在编译时引发,否则就会创建一个私有的宏,可以在当前模块的守卫内部或外部使用。</target>
        </trans-unit>
        <trans-unit id="dd862729751c13eb6c25128449accf571b5c5e26" translate="yes" xml:space="preserve">
          <source>It receives a path to the boot file, without extension, such as &lt;code&gt;releases/0.1.0/start&lt;/code&gt; and this command will write &lt;code&gt;start.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, and &lt;code&gt;start.script&lt;/code&gt; to the given path, returning &lt;code&gt;{:ok, rel_path}&lt;/code&gt; or &lt;code&gt;{:error, message}&lt;/code&gt;.</source>
          <target state="translated">它接收到引导文件的路径，不带扩展名，例如 &lt;code&gt;releases/0.1.0/start&lt;/code&gt; ，此命令会将 &lt;code&gt;start.rel&lt;/code&gt; ， &lt;code&gt;start.boot&lt;/code&gt; 和 &lt;code&gt;start.script&lt;/code&gt; 写入给定路径，并返回 &lt;code&gt;{:ok, rel_path}&lt;/code&gt; 或 &lt;code&gt;{:error, message}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68ba5419581bb056603e98e4fbe37e8377520d3d" translate="yes" xml:space="preserve">
          <source>It receives the &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt; and the snippet &lt;code&gt;radius&lt;/code&gt; and returns &lt;code&gt;{:ok, lines}&lt;/code&gt;, where lines is a list of chardata containing each formatted line, or &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">它接收 &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;line&lt;/code&gt; 和代码段 &lt;code&gt;radius&lt;/code&gt; 并返回 &lt;code&gt;{:ok, lines}&lt;/code&gt; ，其中lines是包含每个格式化行或 &lt;code&gt;:error&lt;/code&gt; 的chardata列表。</target>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">它接收当前 &lt;code&gt;config&lt;/code&gt; 和&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的 &lt;code&gt;state&lt;/code&gt; 。然后，通常您会从外部来源读取额外的配置，并将其合并到接收的 &lt;code&gt;config&lt;/code&gt; 。合并应使用&lt;a href=&quot;config.reader#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; 完成&lt;/a&gt;，因为它执行深度合并。它应该返回更新的配置。</target>
        </trans-unit>
        <trans-unit id="45b33d74133687a9a3b23bdb8a29834a7bdc904c" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">它接收当前 &lt;code&gt;config&lt;/code&gt; 和&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的 &lt;code&gt;state&lt;/code&gt; 。然后，您通常会从外部来源读取额外的配置，然后将其合并到接收的 &lt;code&gt;config&lt;/code&gt; 。合并应使用&lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; 完成&lt;/a&gt;，因为它执行深度合并。它应该返回更新的配置。</target>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">它接受与&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt;相同的选项。返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59be0f6a9003a8021cb33c59b00cb9642811fc44" translate="yes" xml:space="preserve">
          <source>It receives the time spent running the tests and optionally the time spent loading the test suite.</source>
          <target state="translated">它接收运行测试的时间和加载测试套件的时间。</target>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="translated">它依靠&lt;a href=&quot;#format_banner/3&quot;&gt; &lt;code&gt;format_banner/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#format_stacktrace/1&quot;&gt; &lt;code&gt;format_stacktrace/1&lt;/code&gt; &lt;/a&gt;生成最终格式。</target>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="translated">它表示时间为一天的一部分（从午夜开始）。 &lt;code&gt;parts_in_day&lt;/code&gt; 指定一天中已经过了多少天，而 &lt;code&gt;parts_per_day&lt;/code&gt; 表示一天中可以容纳多少个零件。</target>
        </trans-unit>
        <trans-unit id="1b4a09c3103a4b1384852ae0065066d0ba0ed3ed" translate="yes" xml:space="preserve">
          <source>It requires an &lt;code&gt;env&lt;/code&gt; to be given to make the expansion of the guards.</source>
          <target state="translated">它需要一个 &lt;code&gt;env&lt;/code&gt; 给予，使警卫的扩张。</target>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="translated">如果代理由于给定的原因终止，则返回 &lt;code&gt;:ok&lt;/code&gt; 。如果座席因其他原因终止，呼叫将退出。</target>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="translated">如果表达式有效，则返回 &lt;code&gt;:ok&lt;/code&gt; 。否则，它以 &lt;code&gt;{:error, remainder}&lt;/code&gt; 的形式返回一个元组，其中 &lt;code&gt;remainder&lt;/code&gt; 是引用表达式的无效部分。</target>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="translated">如果主管由于指定原因终止，则返回 &lt;code&gt;:ok&lt;/code&gt; 。如果由于其他原因终止，则呼叫退出。</target>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">它返回 &lt;code&gt;:ok&lt;/code&gt; ，如果有这样的监督过程 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;{:error, :not_found}&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">如果 &lt;code&gt;amount&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;start_index&lt;/code&gt; 超出范围，则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="translated">它返回 &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; 或 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="translated">它返回 &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">如果成功，它将返回 &lt;code&gt;{:ok, regex}&lt;/code&gt; ，否则返回{： &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">它像返回一个单引号字符串一样返回一个charlist,取消字符的封装并替换插值。</target>
        </trans-unit>
        <trans-unit id="a009c09b517ab0e5d3d4c4e196c2ea69f3fa9d2a" translate="yes" xml:space="preserve">
          <source>It returns a charlist without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">它返回一个无插值和无转义字符的字符表,除了收尾符号字符本身的转义。</target>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="translated">它返回一个用空格分割的 &quot;单词 &quot;列表,不进行转义,也不解释插值。</target>
        </trans-unit>
        <trans-unit id="282736101413fcdaca5aa663365cdb6c77665dfd" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">它返回一个用空格分割的 &quot;单词 &quot;列表,除了结尾符号字符本身的转义外,没有插值和转义字符。</target>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="translated">它返回一个以空格分割的 &quot;单词 &quot;列表。每一个字都会进行字符拆分和插值。</target>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="translated">它以 &lt;code&gt;[{name, arity}, ...]&lt;/code&gt; 的形式返回一个列表，其中包含所有已定义的函数和宏（公共和私有）。</target>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="translated">它返回一个正则表达式模式,不需要转义,也不需要解释插值。</target>
        </trans-unit>
        <trans-unit id="15ffdd78fcfc5d45572c98d243590020d3b93dea" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without interpolations and without escape characters. Note it still supports escape of Regex tokens (such as escaping &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;) and it also requires you to escape the closing sigil character itself if it appears on the Regex.</source>
          <target state="translated">它返回没有插值且没有转义字符的正则表达式模式。请注意，它仍然支持对正则表达式令牌进行转义（例如转义 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; ），并且还要求您转义结束符本身（如果出现在正则表达式上）。</target>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="translated">它返回了一个正则表达式模式,取消了字符的逃逸并替换了插值。</target>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">它像返回一个双引号字符串一样返回一个字符串,取消字符大小写并替换插值。</target>
        </trans-unit>
        <trans-unit id="a90d4a90b12398793185e7dc61f47bfd041a9450" translate="yes" xml:space="preserve">
          <source>It returns a string without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</source>
          <target state="translated">它返回的是一个没有插值和没有转义字符的字符串,除了收尾符号字符本身的转义。</target>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="translated">它返回一个三元素元组，格式为 &lt;code&gt;{parsed, args, invalid}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">它返回形状为 &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; 的元组，其中 &lt;code&gt;module&lt;/code&gt; 是模块名称， &lt;code&gt;binary&lt;/code&gt; 是模块字节码， &lt;code&gt;term&lt;/code&gt; 是带 &lt;code&gt;quoted&lt;/code&gt; 的最后一个表达式的结果。</target>
        </trans-unit>
        <trans-unit id="ad0c31c6f4bb3fda034b624191c0766e4bec1f10" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module bytecode and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">它返回形状为 &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; 的元组，其中 &lt;code&gt;module&lt;/code&gt; 是模块名称， &lt;code&gt;binary&lt;/code&gt; 是模块字节码， &lt;code&gt;term&lt;/code&gt; 是带 &lt;code&gt;quoted&lt;/code&gt; 的最后一个表达式的结果。</target>
        </trans-unit>
        <trans-unit id="3f7bd0c8a3a6137c5122d78d75fdfc59b0d95055" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is a list of values for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{[], keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">它返回一个元组，其中第一个元素是 &lt;code&gt;key&lt;/code&gt; 的值列表，第二个元素是关键字列表，其中所有与 &lt;code&gt;key&lt;/code&gt; 关联的条目都已删除。如果 &lt;code&gt;key&lt;/code&gt; 不在关键字列表中，则返回 &lt;code&gt;{[], keyword_list}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">它返回一个元组，其中第一个元素是 &lt;code&gt;key&lt;/code&gt; 的第一个值，第二个元素是关键字列表，其中删除了与 &lt;code&gt;key&lt;/code&gt; 相关的所有条目。如果 &lt;code&gt;key&lt;/code&gt; 不在关键字列表中，则返回 &lt;code&gt;{default, keyword_list}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="translated">它返回一个包含配置和导入路径的元组。</target>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="translated">它返回一个包含两个元素列表的双元素元组。触发分割的元素是第二个列表的一部分。</target>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="translated">它返回 &lt;code&gt;mix.exs&lt;/code&gt; 文件，锁清单，并在所有配置文件 &lt;code&gt;config&lt;/code&gt; 目录不具有领先的周期开始（例如， &lt;code&gt;.my_config.exs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ae16c311c39efb30b710f0d18b8495dac13e0f28" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;https://hexdocs.pm/elixir/TokenMissingError.html&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;https://hexdocs.pm/elixir/SyntaxError.html&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">如果成功，它将返回ast，否则将引发异常。如果缺少令牌（通常是因为表达式不完整），则例外是&lt;a href=&quot;https://hexdocs.pm/elixir/TokenMissingError.html&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt;，否则为&lt;a href=&quot;https://hexdocs.pm/elixir/SyntaxError.html&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">如果成功，它将返回ast，否则将引发异常。如果缺少令牌（通常是因为表达式不完整），则异常是&lt;a href=&quot;tokenmissingerror&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt;，否则，则&lt;a href=&quot;syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="translated">它返回已删除的属性值（如果未设置，则返回 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="translated">它返回编译后的模块名称。</target>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="translated">它返回编译器选项的新地图。</target>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="translated">它返回日期之间的公历天数。这样只能比较遵循相同或兼容日历的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;结构。如果两个日历不兼容，它将升高。</target>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="translated">它返回的内容与内置的 &lt;code&gt;node()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="translated">它以&lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt;或 &lt;code&gt;{:error, reason}&lt;/code&gt; 定义的格式返回存储在文档块中的术语（如果该块不可用）。</target>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="translated">它返回协议字节码的更新版本。如果元组的第一个元素是 &lt;code&gt;:ok&lt;/code&gt; ，则表示协议已合并。</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">它返回。</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="translated">看来我们已经准备好了!我们将在接下来的章节中大量使用交互式shell。在接下来的章节中,我们将大量使用交互式shell,从下一章开始,我们将进一步熟悉语言结构和基本类型。</target>
        </trans-unit>
        <trans-unit id="5f614aba654107e82be85c23faa333a8020b0a23" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">如果您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;来检查 &lt;code&gt;enumerable&lt;/code&gt; 给定元素的成员资格而不遍历整个可枚举 &lt;code&gt;{:ok, boolean}&lt;/code&gt; 它应该返回{：ok，boolean}。</target>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">如果您可以使用&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;来检查 &lt;code&gt;enumerable&lt;/code&gt; 给定元素的成员资格而不遍历整个可枚举 &lt;code&gt;{:ok, boolean}&lt;/code&gt; 它应该返回{：ok，boolean}。</target>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">如果您可以计算 &lt;code&gt;enumerable&lt;/code&gt; 中的元素数量，则应返回 &lt;code&gt;{:ok, count}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="translated">如果 &lt;code&gt;enumerable&lt;/code&gt; 具有已知范围，并且可以访问该 &lt;code&gt;enumerable&lt;/code&gt; 的位置而无需遍历所有先前元素，则应返回 &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="translated">它只是简单地将信息打印到stdio和stderr。</target>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="translated">它只是返回一个没有转义字符和没有插值的charlist。</target>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="translated">它只是返回一个没有转义字符和没有插值的字符串。</target>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="translated">它只是运行在你的项目中注册的编译器,并返回一个包含编译状态和诊断程序列表的元组。</target>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="translated">它支持以下选项:</target>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="translated">它接受一个带有两个元素的元组的 &lt;code&gt;enumerable&lt;/code&gt; ，并返回一个包含两个列表的元组，每个列表分别由每个元组的第一个和第二个元素组成。</target>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="translated">它以 &lt;code&gt;catch&lt;/code&gt; 溢出的 &lt;code&gt;kind&lt;/code&gt; 作为参数，并且仅对 &lt;code&gt;:error&lt;/code&gt; 进行规范化，为其他用户返回未修改的有效负载。</target>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">它使用&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;检查是否不存在或不赞成使用任何远程调用，并在这种情况下发出警告。此任务不会显示已弃用的本地调用（在同一模块中对已弃用的函数或宏的调用），也不会在Elixir本身中显示对已弃用的功能的调用。</target>
        </trans-unit>
        <trans-unit id="3f274a1513094f60249f099c239e9ebf65b2ef59" translate="yes" xml:space="preserve">
          <source>It uses the following release options to customize its behaviour:</source>
          <target state="translated">它使用以下发布选项来定制其行为:</target>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="translated">它使用给定的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的文件作为周边和分离文件 &lt;code&gt;separator&lt;/code&gt; 到独立的项目 &lt;code&gt;docs&lt;/code&gt; 。如果集合中的所有条目都是简单的文档（文本或字符串），则此函数尝试将尽可能多的内容放在同一行上。如果它们不简单，则如果不合适，则每行仅显示一个条目。</target>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="translated">它根据《SIGPLAN'96编程语言设计与实现会议论文集》中 &quot;快速准确地打印浮点数 &quot;中描述的算法,使用最短的表示方法。</target>
        </trans-unit>
        <trans-unit id="8c45e1d7dd527f5dc5b63b0e91b53d37c7df9f32" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">执行转换时，还将在&lt;a href=&quot;#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt;附加IO.ANSI.reset / 0。如果您不希望这种行为，请使用&lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">执行转换时，还将在&lt;a href=&quot;io.ansi#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt;附加IO.ANSI.reset / 0。如果您不希望这种行为，请使用&lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="translated">它还将卸载所有 &lt;code&gt;:included_applications&lt;/code&gt; 。请注意，该功能不会清除应用程序模块。</target>
        </trans-unit>
        <trans-unit id="8f9afeda7f3ae15ea1269533344b9ee72aa71396" translate="yes" xml:space="preserve">
          <source>It will define a private function with the &lt;code&gt;name&lt;/code&gt; followed by &lt;code&gt;_template&lt;/code&gt; that expects assigns as arguments.</source>
          <target state="translated">它将定义一个私有函数，其 &lt;code&gt;name&lt;/code&gt; 后跟 &lt;code&gt;_template&lt;/code&gt; ，期望将assigns作为参数。</target>
        </trans-unit>
        <trans-unit id="b14179a0fb239e1b0a7f866572618fb6a7e039c8" translate="yes" xml:space="preserve">
          <source>It will define a private function with the &lt;code&gt;name&lt;/code&gt; followed by &lt;code&gt;_text&lt;/code&gt; that expects no arguments.</source>
          <target state="translated">它将定义一个私有函数，其 &lt;code&gt;name&lt;/code&gt; 后跟 &lt;code&gt;_text&lt;/code&gt; ，且不包含任何参数。</target>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">如果该结构不可用，它将引发&lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fe073227420180d1f3a4b21845f2700d1e729eb" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">如果该结构不可用，它将引发&lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a06e9516c751736de535751e4a5286672c93ce3" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;，它将以给定的单位返回整数。</target>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;，它将以给定的单位返回整数。</target>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="translated">它与不恰当的列表一起工作。</target>
        </trans-unit>
        <trans-unit id="56c7bd1e0de49688ba67dc0411a013f58a48e6b1" translate="yes" xml:space="preserve">
          <source>It would be repetitive to write every time we need this check. Instead you can use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt; to create guard macros. Here's an example how:</source>
          <target state="translated">每次需要此检查时都要重复写。相反，您可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; &lt;/a&gt;创建保护宏。这是一个示例：</target>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="translated">可以为所有Elixir数据类型实现协议：</target>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="translated">也可以将一个块传递给&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;宏。上面的第一个示例将转换为：</target>
        </trans-unit>
        <trans-unit id="d7133394c8c36d8e6246933599c2f2817f5680a9" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">重要的是要注意，它会不变地返回给定的 &lt;code&gt;item&lt;/code&gt; 。这样就可以通过在代码中几乎任何地方（例如在管道中间）插入&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用来&amp;ldquo;监视&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">重要的是要注意，它会不变地返回给定的 &lt;code&gt;item&lt;/code&gt; 。这样可以通过在代码中几乎任何地方（例如在管道中间）插入&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;调用来&amp;ldquo;监视&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="92b1830c83da0ae2da9d26b113dc7191ad06496e" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Shell.IO.html&quot;&gt;&lt;code&gt;Mix.Shell.IO&lt;/code&gt;&lt;/a&gt;, but prints far less.</source>
          <target state="translated">就像&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Shell.IO.html&quot;&gt; &lt;code&gt;Mix.Shell.IO&lt;/code&gt; &lt;/a&gt;一样，但是打印的更少。</target>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="translated">将这样一个管道的AST作为一个函数应用的列表通常是很有用的。这个函数正是这样做的。</target>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="translated">斜体:上。未得到广泛支持。有时作为反义词处理。</target>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">遍历 &lt;code&gt;enumerable&lt;/code&gt; 并在每个元素上调用 &lt;code&gt;fun&lt;/code&gt; 。当 &lt;code&gt;fun&lt;/code&gt; 的调用返回 &lt;code&gt;false&lt;/code&gt; 值（false或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止并返回 &lt;code&gt;false&lt;/code&gt; 。在所有其他情况下，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">遍历 &lt;code&gt;enumerable&lt;/code&gt; 并在每个元素上调用 &lt;code&gt;fun&lt;/code&gt; 。当 &lt;code&gt;fun&lt;/code&gt; 的调用返回真值（ &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ）时，迭代立即停止，并返回 &lt;code&gt;true&lt;/code&gt; 。在所有其他情况下，将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">它的领域是:</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="translated">加入一个路径列表。</target>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">使用 &lt;code&gt;joiner&lt;/code&gt; 器作为分隔符将给定的 &lt;code&gt;enumerable&lt;/code&gt; 连接到二进制文件中。</target>
        </trans-unit>
        <trans-unit id="d5f55ddf6fc97ad5dc177a84ea138ceb1275620d" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a string using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">使用 &lt;code&gt;joiner&lt;/code&gt; 器作为分隔符将给定的 &lt;code&gt;enumerable&lt;/code&gt; 连接到字符串中。</target>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="translated">连接两条路径。</target>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">就像&lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; 一样&lt;/a&gt;，除了接受主题或主题列表。例如，主题 &lt;code&gt;:applications&lt;/code&gt; 将列出已加载的应用程序。</target>
        </trans-unit>
        <trans-unit id="8adcf69a0184ea8241a6a5279c84b711dfcc1fd2" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. For example, topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">就像&lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; 一样&lt;/a&gt;，除了接受主题或主题列表。例如，主题 &lt;code&gt;:applications&lt;/code&gt; 将列出已加载的应用程序。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="translated">请记住， &lt;code&gt;@enforce_keys&lt;/code&gt; 是一个简单的编译时保证，可在构建结构时帮助开发人员。它不会在更新时强制执行，并且不提供任何类型的值验证。</target>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="translated">请记住,防护罩的错误不会泄露,而只是让防护罩失效。</target>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="translated">请记住,将同一个字符串反转两次不一定能得到原来的字符串。</target>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="translated">请记住,单引号和双引号的表示方式在Elixir中并不等同,因为它们由不同的类型表示。</target>
        </trans-unit>
        <trans-unit id="26f5b5d2244e5042fbdc36e2b692a508ea25622f" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">请记住，&lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;在调用者进程中运行，从而在评估周期中阻止了调用者。可以通过调用&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt;释放调用者进程，这将启动一个新的IEx评估周期，让这一步继续进行：</target>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">请记住，&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;在调用者进程中运行，从而在评估周期中阻止了调用者。可以通过调用&lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt;释放调用者进程，这将启动一个新的IEx评估周期，让这一步继续进行：</target>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="translated">请记住， &lt;code&gt;assert&lt;/code&gt; 不会根据表达式更改其语义。换句话说，仍然需要该表达式返回真实值。例如，以下操作将失败：</target>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="translated">请记住， &lt;code&gt;filter&lt;/code&gt; 不能同时过滤和转换元素。如果您愿意，请考虑使用&lt;a href=&quot;#flat_map/2&quot;&gt; &lt;code&gt;flat_map/2&lt;/code&gt; &lt;/a&gt;。例如，如果要转换代表整数的所有字符串，并一次性放弃无效的字符串：</target>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="translated">请记住， &lt;code&gt;refute&lt;/code&gt; 不会改变给定表达式的语义。换句话说，以下操作将失败：</target>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="translated">请记住，默认情况下包括所有测试，因此除非首先将它们排除在外，否则 &lt;code&gt;include&lt;/code&gt; 选项将无效。</target>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="translated">请记住,您可以随时调用帮助任务来列出所有可用任务。</target>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="translated">请记住，按照约定，每当检查的值以 &lt;code&gt;#&lt;/code&gt; 开头时，它就以无效的Elixir语法表示数据结构。这意味着检查协议不可逆，因为在此过程中可能会丢失信息：</target>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="translated">请记住,为了知道一个元素是否唯一,这个函数需要存储流发出的所有唯一值。因此,如果流是无限的,存储的元素数量将无限增长,永远不会被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">请记住，无论使用 &lt;code&gt;async_nolink&lt;/code&gt; 创建的任务如何终止，调用者的进程将始终收到带有与任务结构相同的 &lt;code&gt;ref&lt;/code&gt; 值的 &lt;code&gt;:DOWN&lt;/code&gt; 消息。如果任务正常终止，则 &lt;code&gt;:DOWN&lt;/code&gt; 消息中的原因将是 &lt;code&gt;:normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">请记住，在撬入预编译的源代码（例如Elixir本身）时，&lt;a href=&quot;#open/0&quot;&gt; &lt;code&gt;open/0&lt;/code&gt; &lt;/a&gt;位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">请记住，在撬入预编译的源代码（例如Elixir本身）时，&lt;a href=&quot;#whereami/1&quot;&gt; &lt;code&gt;whereami/1&lt;/code&gt; &lt;/a&gt;位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="translated">请记住,当打开预编译的源代码时,该位置可能不存在。</target>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="translated">请记住，对代理执行&amp;ldquo;滚动升级&amp;rdquo;时也会出现此问题。通过滚动升级，我们意味着以下情况：您希望通过&lt;em&gt;关闭&lt;/em&gt;某些节点并将其替换为运行新版本软件的节点来部署新版本的软件。在此设置中，环境的一部分将具有给定模块的一个版本，另一部分将具有同一模块的另一个版本（较新的版本）。</target>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="translated">使文档的第一段简洁明了，通常为一行。诸如&lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt;之类的工具使用第一行来生成摘要。</target>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="translated">保持用户的格式化</target>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="translated">内核功能</target>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="translated">每个元组中的键和值将是二进制的,并且将被百分数取消编码。</target>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="translated">基于密钥的数据结构访问。</target>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="translated">地图中的键值对不遵循任何顺序(这就是为什么上面例子中打印的地图与创建的地图顺序不同的原因)。</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">KeyError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8ac2c89719f9c04525d63e66e24d2789f2aee53c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">键和值可以是任何实现&lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议的术语，但列表除外，列表是明确禁止的。</target>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">键和值可以是任何实现&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;协议的术语，但列表除外，列表是明确禁止的。</target>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="translated">钥匙的顺序,由开发商指定。</target>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="translated">钥匙可以给一次以上。</target>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 中没有条目的键将被忽略。</target>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="translated">关键词列表中没有条目的键将被忽略。</target>
        </trans-unit>
        <trans-unit id="9070f3bb1af9cd3030e97dc551b3b692914950e9" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">可以通过此模块中的某些功能（例如&lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt;）或&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块提供的 &lt;code&gt;map[]&lt;/code&gt; 语法来访问地图中的键：</target>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">可以通过此模块中的某些功能（例如&lt;a href=&quot;map#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;map#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt;）或&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块提供的 &lt;code&gt;map[]&lt;/code&gt; 语法来访问地图中的键：</target>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="translated">结构中不存在的&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的键会被自动丢弃。请注意，键必须是原子，因为在定义结构时仅允许原子。</target>
        </trans-unit>
        <trans-unit id="c2baa536dd3a58a170c5f916697821f33d1d1197" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If keys in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are duplicated, the last entry will be taken (same behaviour as &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#new/1&quot;&gt;&lt;code&gt;Map.new/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">结构中不存在的&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的键会被自动丢弃。请注意，键必须是原子，因为在定义结构时仅允许原子。如果&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;中的键重复，则将采用最后一个条目（与&lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#new/1&quot;&gt; &lt;code&gt;Map.new/1&lt;/code&gt; &lt;/a&gt;相同的行为）。</target>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="translated">钥匙必须是原子。</target>
        </trans-unit>
        <trans-unit id="e9113610f402cf2ff1bf899fb9498e85baba2c5a" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">键必须是原子。丢弃值为 &lt;code&gt;nil&lt;/code&gt; 的键，将布尔值转换为 &lt;code&gt;--key&lt;/code&gt; 或 &lt;code&gt;--no-key&lt;/code&gt; （如果分别为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ），则使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt;转换所有其他值。</target>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">键必须是原子。丢弃值为 &lt;code&gt;nil&lt;/code&gt; 的键，将布尔值转换为 &lt;code&gt;--key&lt;/code&gt; 或 &lt;code&gt;--no-key&lt;/code&gt; （如果分别为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ），则使用&lt;a href=&quot;kernel#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt;转换所有其他值。</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="translated">关键字列表</target>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="translated">关键词列表和地图</target>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="translated">关键字列表总是被深度合并。</target>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="translated">关键字列表总是深度合并的。</target>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="translated">关键词列表之所以重要,是因为它们有三个特殊的特点。</target>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="translated">关键字列表在该语言中起着重要作用，并且在许多功能和宏中非常常见。在以后的章节中，我们将进一步探讨它们。现在该讨论&amp;ldquo;二进制文件，字符串和字符列表&amp;rdquo;了。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e5689d3967f1a5dbb297e088da0c45eb1176eca9" translate="yes" xml:space="preserve">
          <source>Keywords are mostly used to work with optional values.</source>
          <target state="translated">关键词主要用于与可选的值一起工作。</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="translated">关键词作为最后的参数</target>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="translated">Elixir中的关键字是由两个元素组成的元组列表,其中第一个元素是一个原子。使用基础结构,它们将被表示为。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="translated">已知标签</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="translated">上次我们通过更换异步操作，一个固定的比赛条件 &lt;code&gt;cast&lt;/code&gt; ，由 &lt;code&gt;call&lt;/code&gt; ，这是同步的。不幸的是，我们用来接收 &lt;code&gt;:DOWN&lt;/code&gt; 消息并从ETS表中删除条目的 &lt;code&gt;handle_info/2&lt;/code&gt; 回调没有同步的等效项。这次，我们需要找到一种方法来确保注册表处理了存储桶进程终止时发送的 &lt;code&gt;:DOWN&lt;/code&gt; 通知。</target>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="translated">稍后，我们将学习如何编译Elixir代码（在&lt;a href=&quot;modules-and-functions&quot;&gt;第8章中&lt;/a&gt;）以及如何使用Mix构建工具（在&lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix＆OTP指南中&lt;/a&gt;）。现在，让我们继续&lt;a href=&quot;basic-types&quot;&gt;第二章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">在给定函数返回truthhy值的同时,懒惰地放弃枚举的元素。</target>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="translated">懒惰地删除可枚举中的下 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">懒惰地点缀 &lt;code&gt;intersperse_element&lt;/code&gt; 枚举的各元件之间。</target>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">懒惰地返回并删除与关键字列表中的 &lt;code&gt;key&lt;/code&gt; 关联的所有值。</target>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">懒洋洋地返回并删除相关联的价值 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">在给定函数返回truthhy值的同时,懒惰地获取枚举元素。</target>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="translated">懒惰地从可枚举中获取下一个 &lt;code&gt;count&lt;/code&gt; 元素，并停止枚举。</target>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="translated">闰秒不计入。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="translated">从左到右</target>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="translated">从左到右箭头</target>
        </trans-unit>
        <trans-unit id="1401741d3c80953c9e3f5d95f783a5ec74cfbaff" translate="yes" xml:space="preserve">
          <source>Less-than operator.</source>
          <target state="translated">小于运算符。</target>
        </trans-unit>
        <trans-unit id="25e1e02fa6fbaded2f6f1e2459649cc19db9b44a" translate="yes" xml:space="preserve">
          <source>Less-than or equal to operator.</source>
          <target state="translated">小于或等于运算符。</target>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="translated">我们还向 &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; 添加一个测试，以确保存储桶是临时的：</target>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="translated">让我们将该代码分开一下：</target>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="translated">让我们再次更改 &lt;code&gt;start/2&lt;/code&gt; ，以将监管者添加到我们的树中：</target>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="translated">让我们将 &lt;code&gt;KV.Registry&lt;/code&gt; 更改为使用ETS表。第一个更改是修改注册表以要求使用name参数，我们将使用它来命名ETS表和注册表进程本身。ETS名称和进程名称存储在不同的位置，因此不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="translated">让我们逐一检查每个案例。</target>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="translated">让我们创建一个新的Mix项目。我们将创造性地将其命名为 &lt;code&gt;kv_umbrella&lt;/code&gt; ，并且这个新项目将同时包含现有的 &lt;code&gt;kv&lt;/code&gt; 应用程序和新的 &lt;code&gt;kv_server&lt;/code&gt; 应用程序。目录结构如下所示：</target>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="translated">让我们在 &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; 中创建命令解析器，并从doctest开始：</target>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="translated">让我们通过从命令行调用 &lt;code&gt;mix new&lt;/code&gt; 来创建我们的第一个项目。我们将通过该项目的名称作为参数（ &lt;code&gt;kv&lt;/code&gt; ，在这种情况下），并告诉驴友，我们的主要模块应该是全大写的 &lt;code&gt;KV&lt;/code&gt; ，而不是默认的，这将有 &lt;code&gt;Kv&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="translated">让我们在此shell中定义一个名为 &lt;code&gt;Hello&lt;/code&gt; 的模块：</target>
        </trans-unit>
        <trans-unit id="c3e19d4b698bea8666353bff2803ed53fb2593f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both &amp;ldquo;remove&amp;rdquo; tests at &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt;:</source>
          <target state="translated">让我们通过在两个 &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; 的&amp;ldquo;删除&amp;rdquo;测试中的 &lt;code&gt;Agent.stop/2&lt;/code&gt; 之后创建一个&amp;ldquo;虚假&amp;rdquo;存储桶，这是一个同步请求：</target>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="translated">通过在两个测试中的 &lt;code&gt;Agent.stop/2&lt;/code&gt; 之后创建一个&amp;ldquo;虚假&amp;rdquo;存储桶（这是一个同步请求）来进行操作：</target>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="translated">我们开工吧。</target>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">让我们首先通过使用 &lt;code&gt;iex -S mix&lt;/code&gt; 启动新控制台来与显示器一起玩：</target>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="translated">让我们开始吧！</target>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="translated">让我们通过运行 &lt;code&gt;iex kv.exs&lt;/code&gt; 来尝试一下：</target>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="translated">试一试吧。打开 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; ，然后将 &lt;code&gt;start/2&lt;/code&gt; 函数中的超级用户更改为以下内容：</target>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">让我们在 &lt;code&gt;iex -S mix&lt;/code&gt; 内尝试更新的主管：</target>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="translated">让我们回到前几章中定义的 &lt;code&gt;Math&lt;/code&gt; 模块，添加一些文档并将其保存到 &lt;code&gt;math.ex&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="translated">让我们在 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 中实现集成测试，如下所示：</target>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="translated">让我们实现这些步骤。移至 &lt;code&gt;apps/kv_server&lt;/code&gt; 应用程序，打开 &lt;code&gt;lib/kv_server.ex&lt;/code&gt; ，并添加以下功能：</target>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="translated">让我们学习如何做。</target>
        </trans-unit>
        <trans-unit id="95fbfcaeec6c28ee848bbee5b849155b25cee14c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example to understand how to define more complex types. Say we have a &lt;code&gt;LousyCalculator&lt;/code&gt; module, which performs the usual arithmetic operations (sum, product, and so on) but, instead of returning numbers, it returns tuples with the result of an operation as the first element and a random remark as the second element.</source>
          <target state="translated">让我们看另一个示例，以了解如何定义更复杂的类型。假设我们有一个 &lt;code&gt;LousyCalculator&lt;/code&gt; 模块，该模块执行常规的算术运算（求和，乘积等），但是，它不返回数字，而是返回元组，其中运算结果作为第一个元素，而随机说明作为第二个元素。</target>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="translated">让我们再举一个使用流的例子。由于 &lt;code&gt;IO&lt;/code&gt; 模块提供了流（既是 &lt;code&gt;Enumerable&lt;/code&gt; 还是 &lt;code&gt;Collectable&lt;/code&gt; ），因此可以使用以下理解实现一个回显终端，该终端回显所键入内容的大写版本：</target>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="translated">让我们进入apps目录并开始构建 &lt;code&gt;kv_server&lt;/code&gt; 。这次，我们将传递 &lt;code&gt;--sup&lt;/code&gt; 标志，它将告诉Mix为我们自动生成一个监督树，而不是像前面的章节中那样手动构建一个监督树：</target>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="translated">让我们进入下一章。最后，我们将通过添加存储桶路由机制来使我们的系统分布式。我们将利用这个机会来改善我们的测试印章。</target>
        </trans-unit>
        <trans-unit id="678e1823b091b3645ecead3457dcbde5e2e4d606" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;. Additionally we will set the &lt;code&gt;cookie&lt;/code&gt; option on both releases to &lt;code&gt;weknoweachother&lt;/code&gt; in order for them to allow connections from each other. See the &lt;a href=&quot;http://erlang.org/doc/reference_manual/distributed.html&quot;&gt;Distributed Erlang Documentation&lt;/a&gt; for further information on this topic:</source>
          <target state="translated">现在让我们为 &lt;code&gt;:bar&lt;/code&gt; 定义一个发行版。其中第一步是界定酷似释放 &lt;code&gt;foo&lt;/code&gt; 内 &lt;code&gt;mix.exs&lt;/code&gt; 。此外，我们会将两个版本的 &lt;code&gt;cookie&lt;/code&gt; 选项设置为 &lt;code&gt;weknoweachother&lt;/code&gt; ，以使它们允许彼此连接。有关此主题的更多信息，请参见&lt;a href=&quot;http://erlang.org/doc/reference_manual/distributed.html&quot;&gt;Distributed Erlang文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">现在让我们为 &lt;code&gt;:bar&lt;/code&gt; 定义一个发行版。第一步可能是在 &lt;code&gt;mix.exs&lt;/code&gt; 中定义一个与 &lt;code&gt;foo&lt;/code&gt; 完全相同的发行版：</target>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="translated">现在，让我们看一下如何使用递归的能力对数字列表求和：</target>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="translated">让我们放在一起，并在进程之间发送消息：</target>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">让我们回顾一下正在发生的事情。每当我们调用 &lt;code&gt;iex -S mix&lt;/code&gt; 时，它都会通过调用 &lt;code&gt;Application.start(:kv)&lt;/code&gt; 来自动启动应用程序，然后调用应用程序回调。应用程序回调工作是启动&lt;strong&gt;监督树&lt;/strong&gt;。现在，我们只有一个主管，但有时也要监督一个主管，使之像一棵树。到目前为止，我们的主管有一个独生子 &lt;code&gt;KV.Registry&lt;/code&gt; ，其名称为 &lt;code&gt;KV.Registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36a4ac644ae7aee151cedc8249d95bbb7eb1151f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback&amp;rsquo;s job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">让我们回顾一下正在发生的事情。每当我们调用 &lt;code&gt;iex -S mix&lt;/code&gt; 时，它都会通过调用 &lt;code&gt;Application.start(:kv)&lt;/code&gt; 自动启动我们的应用程序，然后调用应用程序回调。应用程序回调的工作是启动&lt;strong&gt;监督树&lt;/strong&gt;。现在，我们只有一个主管，但有时也要督导一个主管，使之像一棵树。到目前为止，我们的主管有一个独生子 &lt;code&gt;KV.Registry&lt;/code&gt; ，其名称为 &lt;code&gt;KV.Registry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="translated">让我们重新实现服务器回调以修复错误并通过测试。首先，我们将GenServer状态修改为两个字典：一个包含name- &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; ，另一个包含ref- &lt;code&gt;ref -&amp;gt; name&lt;/code&gt; 。然后，我们需要监视 &lt;code&gt;handle_cast/2&lt;/code&gt; 上的存储桶，并实现 &lt;code&gt;handle_info/2&lt;/code&gt; 回调以处理监视消息。完整的服务器回调实现如下所示：</target>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="translated">让我们重写测试用例以使用回调：</target>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="translated">让我们再次运行测试。但是这次，我们将传递 &lt;code&gt;--trace&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="translated">让我们更详细地了解当您请求 &lt;code&gt;IO.write(pid, binary)&lt;/code&gt; 时会发生什么。在 &lt;code&gt;IO&lt;/code&gt; 模块将消息发送到由所标识的过程 &lt;code&gt;pid&lt;/code&gt; 与期望的操作。一个小的临时过程可以帮助我们看到它：</target>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="translated">让我们在实践中看一下。使用 &lt;code&gt;iex -S mix&lt;/code&gt; 启动控制台，然后尝试：</target>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="translated">让我们将子级定义（在 &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt; 中）稍微更改为一个元组列表，而不是原子列表：</target>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="translated">让我们从 &lt;code&gt;iex&lt;/code&gt; 的模块开始iex：</target>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="translated">让我们使用 &lt;code&gt;mix new&lt;/code&gt; 开始一个新项目。这个新项目将被命名为 &lt;code&gt;kv_umbrella&lt;/code&gt; ，我们需要在创建它时传递 &lt;code&gt;--umbrella&lt;/code&gt; 选项。不要在现有的 &lt;code&gt;kv&lt;/code&gt; 项目中创建这个新项目！</target>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="translated">让我们开始创建一个模块，该模块在使用时定义并导入 &lt;code&gt;test&lt;/code&gt; 宏：</target>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="translated">让我们从一个测试开始，该测试描述了在存储桶停止或崩溃时我们希望注册表如何运行：</target>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="translated">让我们简要看一下那些生成的文件。</target>
        </trans-unit>
        <trans-unit id="4fd5f73d356b99a110fa9e76edf1bdd8cb9fd455" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt; and, while we&amp;rsquo;re at it, its lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">让我们更深入地研究 &lt;code&gt;Enumerable&lt;/code&gt; 以及它的懒惰对象 &lt;code&gt;Stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="translated">让我们更深入地研究 &lt;code&gt;Enumerable&lt;/code&gt; ,以及它们的懒惰对象 &lt;code&gt;Stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="translated">让我们来看看上司：</target>
        </trans-unit>
        <trans-unit id="753880cccfa8315b0ba2213f8e81608e972f525e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervisor for a spin:</source>
          <target state="translated">让我们来监督一下：</target>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="translated">让我们编写一个测试来验证我们的路由器是否正常工作。创建一个名为 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; 的文件，其中包含：</target>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="translated">让我们写一些代码！</target>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="translated">让我们建立一个流,然后列举它。</target>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="translated">让我们通过连接两个字符串并在它们之间断开来创建一个文档。</target>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="translated">让我们探索用于调试的&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 模块&lt;/a&gt;的基本功能：</target>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="translated">让我们解决我们的宏。</target>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="translated">我们来试一试。首先启动一个新的shell。</target>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="translated">让我们来看一个快速的案例分析:我们想检查一个函数参数是偶数还是奇数。使用模式匹配,这是不可能的,因为有无限的整数,因此我们不能在单个偶数/奇数上进行模式匹配。让我们把重点放在对偶数的检查上,因为对奇数的检查几乎是一样的。</target>
        </trans-unit>
        <trans-unit id="af9fd18fc73d83d65ff9f7021afd43158fe10001" translate="yes" xml:space="preserve">
          <source>Let's see a simple example that shows the difference between functions and macros:</source>
          <target state="translated">让我们看一个简单的例子,说明函数和宏之间的区别。</target>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">让我们看一个简单的例子。试想一下，你实现打破两个部分基础上划线的第一次出现的字符串库 &lt;code&gt;-&lt;/code&gt; 性格：</target>
        </trans-unit>
        <trans-unit id="4c56c3643f8f926eb1db1e031cb602d1e685c584" translate="yes" xml:space="preserve">
          <source>Let's see an example &lt;code&gt;MyApp.application/0&lt;/code&gt; function:</source>
          <target state="translated">让我们看一个示例 &lt;code&gt;MyApp.application/0&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="translated">让我们来看看一个在函数子句中使用守护的例子。</target>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="translated">我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="translated">让我们看看如何使用这些函数来调试我们前面定义的栈服务器。</target>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="translated">我们来看看一些例子。下面的代码。</target>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="translated">让我们从一个代码示例开始,然后探索可用的回调。想象一下,我们想要一个像堆栈一样工作的GenServer,允许我们推送和弹出元素。</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">我们先来举个例子。</target>
        </trans-unit>
        <trans-unit id="c1e622e103cbf1ed1953980d1ec1467158ec5553" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">假设您在 &lt;code&gt;MyMacros&lt;/code&gt; 模块中创建了自己的&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。如果要调用它，首先需要明确要求 &lt;code&gt;MyMacros&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">假设您在 &lt;code&gt;MyMacros&lt;/code&gt; 模块中创建了自己的&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;实现。如果要调用它，首先需要明确要求 &lt;code&gt;MyMacros&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a0f18507825fffb50cb06a0af30333ce99e8402" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">假设您想调查某些特定功能的情况。通过从该函数调用&lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，IEX将允许您访问其绑定（变量），验证其词法信息并访问过程信息。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">假设您要研究某些特定功能的情况。通过从该函数调用&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;，IEX将允许您访问其绑定（变量），验证其词法信息并访问过程信息。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="translated">让我们了解一下 &lt;code&gt;:shutdown&lt;/code&gt; 和 &lt;code&gt;:restart&lt;/code&gt; 选项所控制的内容。</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="translated">词汇范围</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="translated">图书馆指南</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">与&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;一样，此模块中的函数以线性时间运行。这意味着执行操作所花费的时间与列表的长度以相同的速率增长。这在&lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; 之类的&lt;/a&gt;操作上是预期的。毕竟，如果要遍历流中的每个元素，则流越长，需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="9a69b557caf2f4f9ed4d8f872b75f17d33faa2d9" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">像&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;一样，此模块中的函数以线性时间运行。这意味着执行操作所需的时间以与列表长度相同的速度增长。这在&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; 之类的&lt;/a&gt;操作上是预期的。毕竟，如果要遍历流中的每个元素，则流越长，需要遍历的元素越多，花费的时间也越长。</target>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="translated">限制某个时区的开始或结束时间。</target>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="translated">行 &lt;code&gt;0&lt;/code&gt; 和列 &lt;code&gt;0&lt;/code&gt; 将意味着左上角。</target>
        </trans-unit>
        <trans-unit id="f75f7d7f1f9d02250730e14081c315ebe6091bed" translate="yes" xml:space="preserve">
          <source>Line numbers are one-based, and column numbers in a range are zero-based and refer to the cursor position at the start of the character at that index. For example, to indicate that a diagnostic applies to the first &lt;code&gt;n&lt;/code&gt; characters of the first line, the range would be &lt;code&gt;{1, 0, 1, n}&lt;/code&gt;.</source>
          <target state="translated">行号是从1开始的，范围中的列号是从0开始的，并且引用该索引处字符开头的光标位置。例如，要表明诊断适用于第一行的前 &lt;code&gt;n&lt;/code&gt; 个字符，范围应为 &lt;code&gt;{1, 0, 1, n}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d6c7e0d9491c204ea28cf1ccec11cd1021b58d" translate="yes" xml:space="preserve">
          <source>Linked lists hold zero, one, or more elements in the chosen order.</source>
          <target state="translated">关联列表按照选择的顺序容纳零、一个或多个元素。</target>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="translated">也可以通过调用 &lt;code&gt;Process.link/1&lt;/code&gt; 手动完成链接。我们建议您查看&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;&amp;ldquo; &lt;code&gt;Process&lt;/code&gt; 模块&lt;/a&gt;，了解流程提供的其他功能。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="translated">链接是双向的。如果你链接了两个进程,其中一个进程崩溃了,另一边也会崩溃(除非它是陷阱退出)。监控器是单向的:只有监控进程才会收到关于被监控进程的通知。换句话说:当你想要链接崩溃时就使用链接,而当你只想得到崩溃、退出等通知时就使用监视器。</target>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="translated">链接是双向的,这意味着 bucket 的崩溃将使注册表崩溃。虽然我们现在有了监督器,保证了注册表的恢复和运行,但注册表的崩溃仍然意味着我们失去了所有将 bucket 名称与其各自进程关联的数据。</target>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">链接是双向的。可以使用&lt;a href=&quot;#unlink/1&quot;&gt; &lt;code&gt;unlink/1&lt;/code&gt; &lt;/a&gt;取消链接的进程。</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="d8c15547c73710a89415334a00b0ee5a2c8790ae" translate="yes" xml:space="preserve">
          <source>List concatenation operator. Concatenates a proper list and a term, returning a list.</source>
          <target state="translated">列表连接操作符。将一个合适的列表和一个术语连接起来,返回一个列表。</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="translated">允许的表达方式列表</target>
        </trans-unit>
        <trans-unit id="3bc1afebc9f88b8646bec755bebbd01b76058e82" translate="yes" xml:space="preserve">
          <source>List of allowed functions and operators</source>
          <target state="translated">允许的函数和运算符列表</target>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="translated">关键字列表中支持的键列表。</target>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="translated">列表运算符从不修改现有列表。连接到列表或从列表中删除元素将返回一个新列表。我们说Elixir数据结构是&lt;em&gt;不可变的&lt;/em&gt;。不变性的一个优点是可以使代码更清晰。您可以自由传递数据，并保证没有人会在内存中对其进行突变-仅对其进行转换。</target>
        </trans-unit>
        <trans-unit id="ad56da9a17e3e3df18feffc154b101554e4c5019" translate="yes" xml:space="preserve">
          <source>List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">列表减法运算符。对右边列表中的每一个元素去除左边列表中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">List.Chars &lt;small&gt;协议&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="translated">List.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="translated">List.Chars.to_charlist (1)</target>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="translated">侦听一个端口,直到该端口可用,并获得套接字。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="translated">列出所有依赖关系及其状态。</target>
        </trans-unit>
        <trans-unit id="d0400b695b82b7f117940b8b0f5038dea1a03963" translate="yes" xml:space="preserve">
          <source>Lists all installed archives.</source>
          <target state="translated">列出所有已安装的存档。</target>
        </trans-unit>
        <trans-unit id="ab1fcad81755990415fb928f4bb6482b9fa8177c" translate="yes" xml:space="preserve">
          <source>Lists all installed escripts.</source>
          <target state="translated">列出所有已安装的脚本。</target>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="translated">列出所有需要的文件。</target>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="translated">列出所有任务和别名,或打印指定任务或别名的文档。</target>
        </trans-unit>
        <trans-unit id="4b514bc4e3164c52bfb95195bf0bb5ba74e08baf" translate="yes" xml:space="preserve">
          <source>Lists also implement the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, so many functions to work with lists are found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions and operators for lists are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">列表还实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，因此在&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到许多用于列表的功能。此外，在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中可以找到以下列表的函数和运算符：</target>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="translated">列表是逐元素比较的。</target>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="translated">列表以链接列表的形式存储在内存中,这意味着列表中的每个元素都会保持其值,并指向下一个元素,直到到达列表的末端。这意味着访问一个列表的长度是一个线性操作:我们需要遍历整个列表,才能算出它的大小。</target>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="translated">列出命令行参数。</target>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="translated">Elixir中的列表是有效的链接列表,这意味着它们在内部以包含列表头和尾的对来表示。</target>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="translated">Elixir中的列表是在方括号中指定的。</target>
        </trans-unit>
        <trans-unit id="8b24ff6edd5f61dd85578b462cfb5ccb5e1d7ec5" translate="yes" xml:space="preserve">
          <source>Lists local tasks.</source>
          <target state="translated">列出本地任务。</target>
        </trans-unit>
        <trans-unit id="de7c16fdcb7dbcdae885c936e8e70fdad2dfea81" translate="yes" xml:space="preserve">
          <source>Lists manifest files for the compiler.</source>
          <target state="translated">列出编译器的清单文件。</target>
        </trans-unit>
        <trans-unit id="d0f09ee3032c9247a8875448970636dcb5d79ece" translate="yes" xml:space="preserve">
          <source>Lists may appear in patterns using the square brackets syntax (&lt;code&gt;[]&lt;/code&gt;). A list in a pattern will match only lists of the same size, where each individual list element must also match:</source>
          <target state="translated">列表可以使用方括号语法（ &lt;code&gt;[]&lt;/code&gt; ）出现在模式中。模式中的列表将仅匹配相同大小的列表，其中每个单独的列表元素也必须匹配：</target>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="translated">列表还是元组?</target>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="translated">列表、元组和二进制</target>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="translated">列表、元组、位串、映射、结构和函数调用,如果在开头括号中跟了一个新行,在结尾括号中又跟了一个新行,那么它们将被分成多行。</target>
        </trans-unit>
        <trans-unit id="5d726676b1647ae189afafe7c0135c21ac5baa4c" translate="yes" xml:space="preserve">
          <source>Literal &quot;%&quot; character</source>
          <target state="translated">字面&quot;%&quot;字符</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="7513abc36384d31942a5cf7f931786fd04bb1c73" translate="yes" xml:space="preserve">
          <source>Literals (numbers and atoms)</source>
          <target state="translated">字母(数字和原子)</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="translated">加载应用程序&lt;em&gt;不会&lt;/em&gt;加载其模块。</target>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="translated">加载应用程序</target>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="translated">加载应用程序不会启动它,也不会加载它的模块,但会加载它的环境。</target>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="translated">载入所有代码路径中的所有任务。</target>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">加载给定 &lt;code&gt;paths&lt;/code&gt; 中的所有任务。</target>
        </trans-unit>
        <trans-unit id="1b73d169b01f0a9c5dd68ce5c80ad0b78253a148" translate="yes" xml:space="preserve">
          <source>Loads and configures all registered apps.</source>
          <target state="translated">加载并配置所有注册的应用程序。</target>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="translated">加载并坚持给定的配置。</target>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="translated">加载配置(通常在系统启动时)。</target>
        </trans-unit>
        <trans-unit id="0685e493c999d9e080786726a9b793b9cc769fbe" translate="yes" xml:space="preserve">
          <source>Loads the application and its dependencies paths.</source>
          <target state="translated">加载应用程序和它的依赖路径。</target>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">加载给定的 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="translated">加载给定模块的BEAM代码(并确保之前的旧版本已被正确清除)。</target>
        </trans-unit>
        <trans-unit id="9e384585def890d25c96b1f4a34ccaee1ed94be4" translate="yes" xml:space="preserve">
          <source>Local dependencies (i.e. non-fetchable ones) are automatically recompiled every time the parent project is compiled.</source>
          <target state="translated">每次编译父项目时,都会自动重新编译本地依赖关系(即不可获取的依赖关系)。</target>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="translated">无需模块即可捕获局部或导入的函数，例如 &lt;code&gt;is_function/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="translated">定位系统中的一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="translated">日志采集</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="translated">Logger通过提供一个翻译器,允许开发人员将OTP应用程序提供的日志消息改写成与Elixir日志消息更兼容的格式。</target>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="translated">Logger还允许通过 &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; 选项（参见下文）完全删除日志命令。</target>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="ca109e8fe3eb4c16a27a7e4635e900addd5e8cb0" translate="yes" xml:space="preserve">
          <source>Logging a message (string or iodata):</source>
          <target state="translated">记录一个消息(字符串或碘数据)。</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="translated">当系统中发生感兴趣的事件时,日志记录对跟踪非常有用。例如,每当有用户被删除时,进行记录可能会很有用。</target>
        </trans-unit>
        <trans-unit id="1deadf9242ff4446fca380a5ed4fc63d13e68620" translate="yes" xml:space="preserve">
          <source>Logs a alert message.</source>
          <target state="translated">记录一条警报信息。</target>
        </trans-unit>
        <trans-unit id="77f07031049dd01cb883823bd003f010766fb98e" translate="yes" xml:space="preserve">
          <source>Logs a critical message.</source>
          <target state="translated">记录一条重要信息。</target>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="translated">记录一个调试信息。</target>
        </trans-unit>
        <trans-unit id="ec3ae95bdedeebd38a4944614cd25bc06633c042" translate="yes" xml:space="preserve">
          <source>Logs a emergency message.</source>
          <target state="translated">记录紧急信息。</target>
        </trans-unit>
        <trans-unit id="fa35a8e5fcaecac8caac4e767a74fc390a160600" translate="yes" xml:space="preserve">
          <source>Logs a error message.</source>
          <target state="translated">记录错误信息。</target>
        </trans-unit>
        <trans-unit id="7c874de52b4d39e2e1de53a70efcaf18caaa4708" translate="yes" xml:space="preserve">
          <source>Logs a info message.</source>
          <target state="translated">登录到信息留言。</target>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="translated">动态地记录消息。</target>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">记录具有给定 &lt;code&gt;level&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="420c25c0985bad40d128abfb9b86ebd0f486c510" translate="yes" xml:space="preserve">
          <source>Logs a notice message.</source>
          <target state="translated">记录通知信息。</target>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="translated">记录一条警告信息。</target>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="translated">记录错误信息。</target>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="translated">记录信息消息。</target>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="translated">查询、派遣和注册是高效和即时的,但代价是延迟退订。例如,如果一个进程崩溃了,它的键会自动从注册表中删除,但变化可能不会立即传播。这意味着某些操作可能会返回已经死亡的进程。当这种情况可能发生时,将在函数文档中明确说明。</target>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="translated">通过递归循环</target>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="translated">解析一个选项的低级函数。</target>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">对我们来说幸运的是， &lt;code&gt;use GenServer&lt;/code&gt; 已经完全像上面一样定义了 &lt;code&gt;Stack.child_spec/1&lt;/code&gt; 。如果需要自定义&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则可以直接传递选项以 &lt;code&gt;use GenServer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e8fb2a57a7b8ddbc8b24f39765395e01d2d1bdb2" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">对我们来说幸运的是， &lt;code&gt;use GenServer&lt;/code&gt; 已经完全像上面一样定义了 &lt;code&gt;Stack.child_spec/1&lt;/code&gt; 。如果需要自定义&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;，则可以直接传递选项以 &lt;code&gt;use GenServer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="translated">幸运的是,Elixir自带的功能可以将我们到目前为止所写的所有代码打包到一个单一的目录中,这个目录也包括Elixir和Erlang虚拟机,它有一个简单的入口点,并且支持自定义配置。这个功能叫做发布,它还提供了很多其他的好处,我们接下来会看到。</target>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="translated">幸运的是，ExUnit附带了一种标记测试的功能，使我们能够运行特定的回调，甚至基于这些标记完全过滤测试。我们已经在上一章中使用了 &lt;code&gt;:capture_log&lt;/code&gt; 标记，它的语义由ExUnit本身指定。</target>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="translated">幸运的是，理解力还支持 &lt;code&gt;:reduce&lt;/code&gt; 选项，这使我们可以将上述两个步骤融合为一个步骤：</target>
        </trans-unit>
        <trans-unit id="9bf35e953e645f158229003437875eb9a242b162" translate="yes" xml:space="preserve">
          <source>Luckily, releases also provide runtime configuration, which we will see next.</source>
          <target state="translated">幸运的是,发行版也提供了运行时配置,我们接下来会看到。</target>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="translated">幸运的是，由于服务器是由管理员监督的，因此管理员将自动使用初始堆栈 &lt;code&gt;[:hello]&lt;/code&gt; 启动一个新服务器：</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="translated">宏观卫生</target>
        </trans-unit>
        <trans-unit id="5233ccb9ab0c07b3e0b3cdc52940cec0284d06af" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;的基于宏的快捷方式。</target>
        </trans-unit>
        <trans-unit id="d968e46fbcd656cb5ecfaafa8dee8956d86aa485" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;的基于宏的快捷方式。</target>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;的基于宏的快捷方式。</target>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="translated">宏(本地或远程)</target>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="translated">宏是一种强大的结构,Elixir提供了许多机制来确保它们得到负责任的使用。</target>
        </trans-unit>
        <trans-unit id="ef424c7d55cc728523759a674154684c4f327b7f" translate="yes" xml:space="preserve">
          <source>Macros are also commonly used to implement custom sigils. To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="translated">宏也通常用于实现自定义信号。要创建自定义 &lt;code&gt;sigil_{identifier}&lt;/code&gt; ，请定义一个名称为sigil_ {identifier}的函数，该函数带有两个参数。第一个参数是字符串，第二个参数是包含任何修饰符的字符列表。如果sigil是小写字母（例如 &lt;code&gt;sigil_x&lt;/code&gt; ），则字符串参数将允许插值。如果 &lt;code&gt;sigil_X&lt;/code&gt; 是大写字母（例如sigil_X），则不会插入字符串。</target>
        </trans-unit>
        <trans-unit id="27ec1b0b3e3d4a112e7fe3bb95a5cd9f904ce5fc" translate="yes" xml:space="preserve">
          <source>Macros are compile-time constructs that are invoked with Elixir's AST as input and a superset of Elixir's AST as output.</source>
          <target state="translated">宏是以Elixir的AST为输入,以Elixir的AST的超集为输出的编译时构造。</target>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="translated">宏是显式的:如果不显式地调用一个宏,就不可能运行它。例如,一些语言允许开发人员在幕后完全重写函数,通常是通过解析变换或通过一些反射机制。在Elixir中,在编译时必须在调用者中显式调用宏。</target>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="translated">宏是卫生的:默认情况下,在宏内定义的变量不会影响用户代码。此外,在宏上下文中可用的函数调用和别名也不会泄露到用户上下文中。</target>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="translated">宏是词汇性的：不可能全局注入代码或宏。为了使用宏，您需要显式 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 定义宏的模块。</target>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="translated">宏不能被覆盖为函数,反之亦然。</target>
        </trans-unit>
        <trans-unit id="c199f825b0b9d3f3318f2eda4ea955409324187c" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">由以上防护组成的任意组合构成的宏也是有效的防护，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见下面显示的&amp;ldquo;定义自定义保护表达式&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">由以上防护组成的任意组合构成的宏也是有效的防护，例如&lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见下面显示的&amp;ldquo;定义自定义保护表达式&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="translated">Elixir中的宏是通过 &lt;code&gt;defmacro/2&lt;/code&gt; 定义的。</target>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="translated">在使用前必须定义宏。</target>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="translated">宏接收引号表达式,必须返回引号表达式。但是,在执行宏的过程中,有时可能需要处理值,需要区分值和引号表达式。</target>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="translated">巨集的语言很明确：许多语言都提供了 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;unquote&lt;/code&gt; 的语法快捷方式。在Elixir中，我们希望将它们明确地拼写清楚，以便清楚地界定宏定义及其引用表达式的边界。</target>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="translated">同步调用 &lt;code&gt;server&lt;/code&gt; 并等待其回复。</target>
        </trans-unit>
        <trans-unit id="d01394a676b90ea711ca71b9dfa799f50b31e6c1" translate="yes" xml:space="preserve">
          <source>Makes boot scripts.</source>
          <target state="translated">制作启动脚本。</target>
        </trans-unit>
        <trans-unit id="63d944684b8d8c1cbe7b41a5decc0950233badf7" translate="yes" xml:space="preserve">
          <source>Makes the &lt;code&gt;sys.config&lt;/code&gt; structure.</source>
          <target state="translated">制作 &lt;code&gt;sys.config&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="translated">使 &lt;code&gt;module&lt;/code&gt; 的给定函数可重写。</target>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="translated">使当前模块中给定的函数可以被覆盖。</target>
        </trans-unit>
        <trans-unit id="f520067303f9e8a9444961effdfbec09ca46a18f" translate="yes" xml:space="preserve">
          <source>Makes the start_erl.data file with the ERTS version and release versions.</source>
          <target state="translated">使start_erl.data文件包含ERTS版本和发布版本。</target>
        </trans-unit>
        <trans-unit id="dc0be1241754d06d600f6c1517dbc4ddf83878d3" translate="yes" xml:space="preserve">
          <source>Management scripts. Releases come with scripts to start, restart, connect to the running system remotely, execute RPC calls, run as daemon, run as a Windows service, and more.</source>
          <target state="translated">管理脚本。发行版带有启动、重启、远程连接到正在运行的系统、执行RPC调用、作为守护进程运行、作为Windows服务运行等脚本。</target>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">手动实现所有类型的协议会很快变得重复且乏味。在这种情况下，Elixir提供了两种选择：我们可以显式派生我们类型的协议实现，或自动实现所有类型的协议。在这两种情况下，我们都需要实现 &lt;code&gt;Any&lt;/code&gt; 的协议。</target>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="translated">手动可以启动为:</target>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">许多功能是成对出现的，例如&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;将返回成功或失败的元组，而&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;将返回纯值或引发异常：</target>
        </trans-unit>
        <trans-unit id="260e168370d5fc4a6827bad1c03fb6fbeedd23a4" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">许多功能是成对出现的，例如&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;将返回成功或失败的元组，而&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;将返回纯值或引发异常：</target>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到许多实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的地图功能。此外，在&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;可以找到以下地图功能：</target>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，对于任何其他时区都返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad947ef91255ef33c3330d92501cc4ddd6db30bf" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，并且对于任何其他时区返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 模块中的许多函数接受任何可枚举的参数作为参数，并作为结果返回流。它还提供用于创建流的功能。例如， &lt;code&gt;Stream.cycle/1&lt;/code&gt; 可用于创建无限循环给定枚举的流。注意不要在此类流上调用像 &lt;code&gt;Enum.map/2&lt;/code&gt; 这样的函数，因为它们会永远循环：</target>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="translated">标准库中的许多函数都遵循具有引发异常的对象而不是返回要匹配的元组的模式。该公约是创建一个函数（ &lt;code&gt;foo&lt;/code&gt; ）返回 &lt;code&gt;{:ok, result}&lt;/code&gt; 或 &lt;code&gt;{:error, reason}&lt;/code&gt; 元组和另一个函数（ &lt;code&gt;foo!&lt;/code&gt; ，名称相同，但后面有个 &lt;code&gt;!&lt;/code&gt; 是采用相同的参数）， &lt;code&gt;foo&lt;/code&gt; 但如果有错误，则会引发异常。 &lt;code&gt;foo!&lt;/code&gt; 如果一切正常，则应返回结果（不包装在元组中）。该&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; 模块&lt;/a&gt;是本公约的一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="translated">该模块中的许多功能都希望将IO设备作为参数。IO设备必须是PID或表示过程的原子。为了方便起见，Elixir提供了 &lt;code&gt;:stdio&lt;/code&gt; 和 &lt;code&gt;:stderr&lt;/code&gt; 作为Erlang的 &lt;code&gt;:standard_io&lt;/code&gt; 和 &lt;code&gt;:standard_error&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="translated">该模块中的许多功能都通过 &lt;code&gt;:capture&lt;/code&gt; 选项处理在正则表达式匹配中捕获的内容。支持的值为：</target>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">该模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，对于任何其他时区都返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4dd6fb3c009dd1400eb7be40f23b4fda3b4e022" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">该模块中的许多功能都需要时区数据库。默认情况下，它使用&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;返回的默认时区数据库，该数据库默认为&lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.UTCOnlyTimeZoneDatabase.html&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;，该数据库仅处理&amp;ldquo; Etc / UTC&amp;rdquo;日期时间，并且对于任何其他时区返回 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0260e8c22bbeb10fe3ca38f76f4ac2485f643f27" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;String.split/3&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">该模块中的许多功能都与模式一起使用。例如，&lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;String.split/3&lt;/code&gt; &lt;/a&gt;可以在给定模式的情况下将一个字符串拆分为多个字符串。该模式可以是字符串，字符串列表或已编译模式：</target>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">该模块中的许多功能都与模式一起使用。例如，&lt;a href=&quot;string#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt;可以将一个字符串分成给定模式的多个字符串。此模式可以是字符串，字符串列表或已编译模式：</target>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="translated">许多模块共享相同的公共API。看一下&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;，正如其描述所指出的那样，它是Web应用程序中可组合模块的&lt;strong&gt;规范&lt;/strong&gt;。每个&lt;em&gt;插件&lt;/em&gt;都是一个模块，&lt;strong&gt;必须&lt;/strong&gt;至少实现两个公共功能： &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;模块中定义的许多功能都在内部调用此功能。当使用方括号访问语法（ &lt;code&gt;structure[key]&lt;/code&gt; ）时，也会使用此函数：调用由定义 &lt;code&gt;structure&lt;/code&gt; struct 的模块实现的&lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt;回调，如果返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 则 &lt;code&gt;value&lt;/code&gt; 为返回，或者如果返回 &lt;code&gt;:error&lt;/code&gt; ,则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; 模块中的许多功能都需要一个环境。您可以&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;在 &lt;code&gt;Macro&lt;/code&gt; 模块的文档中&lt;/a&gt;阅读有关这些功能的更多信息，并在&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;文档中了解有关编译环境的更多信息。</target>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">在&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到为列表提供的许多实现&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议的功能。</target>
        </trans-unit>
        <trans-unit id="fa5e426d610f0d4aaac317eed422e316664919b2" translate="yes" xml:space="preserve">
          <source>Many of those can be used in guards; consult the &lt;a href=&quot;patterns-and-guards#list-of-allowed-functions-and-operators&quot;&gt;list of allowed guard functions and operators&lt;/a&gt;.</source>
          <target state="translated">其中许多可以用作警卫。查阅&lt;a href=&quot;patterns-and-guards#list-of-allowed-functions-and-operators&quot;&gt;允许的警卫职能和操作人员清单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="translated">通过使用 &lt;code&gt;-&lt;/code&gt; 作为分隔符，可以提供许多选项。顺序是任意的，因此以下各项都是等效的：</target>
        </trans-unit>
        <trans-unit id="330c1202fe630194f41c59eea84f6ea0bc1f1fd0" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">很多时候，可以根据现有实体的功能来执行结构检查。例如，这是&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">很多时候，可以根据现有实体的功能来执行结构检查。例如，这是&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">映射/字典作为&lt;a href=&quot;enum#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="ea310bdd1d4cb6664bd2860f16abce50b8e7ac8b" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">映射/字典作为&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="translated">地图允许任何值作为键。</target>
        </trans-unit>
        <trans-unit id="7dc037a00a16f714fab195785c4e6e9d7695f9d0" translate="yes" xml:space="preserve">
          <source>Maps also implement the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, so many functions to work with maps are found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">映射还实现了&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;协议，因此在&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;模块中可以找到许多与映射一起使用的功能。此外，在&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;可以找到以下地图功能：</target>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="translated">映射还支持特定的更新语法来更新存储在&lt;em&gt;现有&lt;/em&gt;原子键下的值：</target>
        </trans-unit>
        <trans-unit id="4f807f1c0861c6353d131aaf6d1b3433f38ae0fe" translate="yes" xml:space="preserve">
          <source>Maps and intersperses the given enumerable in one pass.</source>
          <target state="translated">绘制地图,并将给定的枚举一次穿插起来。</target>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="translated">一次映射并加入给定的 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="translated">地图和关键词列表</target>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="translated">映射并减少一个 &lt;code&gt;enumerable&lt;/code&gt; ，将给定的结果展平（仅深一层）。</target>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="translated">地图先按大小比较,然后按升项顺序比较键,再按键顺序比较值。在地图键排序的具体情况下,整数总是被认为小于浮点数。</target>
        </trans-unit>
        <trans-unit id="8c98c45a1d23b0146ef1d00e97519c4b3c41bb31" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir.</source>
          <target state="translated">地图是Elixir中 &quot;常用的 &quot;键值数据结构。</target>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">映射是Elixir中的&amp;ldquo;转到&amp;rdquo;键值数据结构。可以使用 &lt;code&gt;%{}&lt;/code&gt; 语法创建映射，并且键值对可以表示为 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="70c51c829f32f40117be9c91f009f5fddc39b569" translate="yes" xml:space="preserve">
          <source>Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;%{}&lt;/code&gt; 语法创建映射，并且键值对可以表示为 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="translated">地图可以在上进行模式匹配。当地图在模式匹配的左侧时,如果右侧的地图包含了左侧的键,并且它们的值与左侧的键相匹配,那么该地图就会匹配。这意味着空地图会匹配每一张地图。</target>
        </trans-unit>
        <trans-unit id="2f34883281b6a723f6b44b386e5d7882db692c68" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">映射不对键类型施加任何限制：任何东西都可以是映射中的键。作为键值结构，映射不允许重复的键。使用精确相等运算符（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）比较密钥。如果在地图文字中定义了冲突键，则以最后一个为准。</target>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">映射不对键类型施加任何限制：任何东西都可以是映射中的键。作为键值结构，映射不允许重复的键。使用精确相等运算符（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）比较密钥。如果在地图文字中定义了冲突键，则以最后一个为准。</target>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="translated">映射具有以下用于更新键值的语法：</target>
        </trans-unit>
        <trans-unit id="df4d74f64dad54de9172b6ef5d50d38fbf79035b" translate="yes" xml:space="preserve">
          <source>Maps may appear in patterns using the percentage sign followed by the curly brackets syntax (&lt;code&gt;%{}&lt;/code&gt;). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern.</source>
          <target state="translated">地图可能会使用百分号后跟大括号语法（ &lt;code&gt;%{}&lt;/code&gt; ）的方式显示在模式中。与列表和元组相反，地图执行子集匹配。这意味着地图模式将与至少具有该模式中所有键的任何其他地图匹配。</target>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="translated">映射给定的 &lt;code&gt;fun&lt;/code&gt; 在 &lt;code&gt;enumerable&lt;/code&gt; 和变平的结果。</target>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="translated">地图使用 &lt;code&gt;%{...}&lt;/code&gt; 表示法，并且每个键值均由带有 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的标记对给出，例如 &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="translated">地图的键不遵循任何顺序。</target>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="translated">Markdown使用反引号（ &lt;code&gt;`&lt;/code&gt; ）引用代码。Elixir在此基础上构建，以在引用模块或函数名称时自动生成链接。因此，请始终使用完整的模块名称。如果您有一个名为 &lt;code&gt;MyApp.Hello&lt;/code&gt; 的模块，则始终将其引用为 &lt;code&gt;`MyApp.Hello`&lt;/code&gt; 而永远不要将其引用为 &lt;code&gt;`Hello`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标记 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 仅用于自定义EEx引擎，默认情况下未实现。在没有适当实现的情况下使用它们会引发&lt;a href=&quot;eex.syntaxerror&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afbf70382126809dcc83d5a0baa9b100761627b8" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SyntaxError.html&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标记 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 仅用于自定义EEx引擎，默认情况下未实现。在没有适当实现的情况下使用它们会引发&lt;a href=&quot;https://hexdocs.pm/eex/EEx.SyntaxError.html&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="translated">标志着系统是否应该在ARGV处理结束时停止。</target>
        </trans-unit>
        <trans-unit id="daa3ede97b95d72b81888db9393f9e1bcea3ccac" translate="yes" xml:space="preserve">
          <source>Marks that the given variable should not be hygienized.</source>
          <target state="translated">标志着给定的变量不应该被卫生化。</target>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="translated">掌握Markdown</target>
        </trans-unit>
        <trans-unit id="85919633d0c1a681dd648ed32addd8fdbee372f3" translate="yes" xml:space="preserve">
          <source>Match operator. Matches the value on the right against the pattern on the left.</source>
          <target state="translated">匹配运算符。将右边的数值与左边的图案进行匹配。</target>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">MatchError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="translated">匹配或建立一个结构。</target>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="translated">将给定的表达式与给定的子句进行匹配。</target>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">匹配的术语 &lt;code&gt;left&lt;/code&gt; 反对对正则表达式或字符串 &lt;code&gt;right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="translated">将右边的数值与左边的图案进行匹配。</target>
        </trans-unit>
        <trans-unit id="e5c433e838d8cf469d6f4b86a0a4976ce8db4a93" translate="yes" xml:space="preserve">
          <source>Matching &lt;code&gt;x&lt;/code&gt; against 2 would raise:</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 与2匹配将引发：</target>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="translated">处理行为的机制。</target>
        </trans-unit>
        <trans-unit id="b873cd45985fe1c621dd194bc36973e23339f383" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">成员资格使用match（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）运算符进行测试。</target>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">成员资格使用match（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）运算符进行测试。</target>
        </trans-unit>
        <trans-unit id="9184827d2046a26e76cbe3bdb691f2ddb10c2fb1" translate="yes" xml:space="preserve">
          <source>Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side.</source>
          <target state="translated">成员资格操作符。检查左手边的元素是否是右手边集合的成员。</target>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="translated">合并两个URI。</target>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="translated">合并两个配置。</target>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="translated">将两个关键词列表合并为一个。</target>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">将两张地图合并为一张，通过给定的 &lt;code&gt;fun&lt;/code&gt; 解决冲突。</target>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="translated">将两张地图合并为一张。</target>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="translated">消息和函数API</target>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="translated">信息格式</target>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="translated">元编程指南</target>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="translated">Elixir中的元编程</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="translated">元数据可以有任何键。文档工具经常使用元数据为读者提供更多数据,丰富用户体验。</target>
        </trans-unit>
        <trans-unit id="2d84d1f82b3284c403ade0a511b9ae944c022317" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">可以使用&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;函数读写要发送到记录器的元数据。例如，您可以设置 &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; 将user_id元数据添加到当前进程。用户可以配置后端以选择要打印的 &lt;code&gt;$metadata&lt;/code&gt; ，它将替换$ metadata值。</target>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">可以使用&lt;a href=&quot;logger#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;函数读写要发送到记录器的元数据。例如，您可以设置 &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; 将user_id元数据添加到当前进程。用户可以配置后端以选择要打印的 &lt;code&gt;$metadata&lt;/code&gt; ，它将替换$ metadata值。</target>
        </trans-unit>
        <trans-unit id="d6e66778ed96781c28086fcc3541fc2af93e8299" translate="yes" xml:space="preserve">
          <source>Microseconds &lt;em&gt;(does not support width and padding modifiers)&lt;/em&gt;</source>
          <target state="translated">微秒&lt;em&gt;（不支持width和padding修饰符）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="translated">微秒也可以给出一个精度,这个精度必须是0到6之间的整数。</target>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="translated">储存精度的微秒。</target>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;use Mix.Config&lt;/code&gt; 迁移</target>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="translated">从主管的:simple_one_for_one进行迁移。</target>
        </trans-unit>
        <trans-unit id="c1335d3e7a03c5a9cce93a720fba00fd5265fb99" translate="yes" xml:space="preserve">
          <source>Minute</source>
          <target state="translated">Minute</target>
        </trans-unit>
        <trans-unit id="c92a133e8e92ffcf0c9578a6d4506ea98170ba24" translate="yes" xml:space="preserve">
          <source>Mirrors</source>
          <target state="translated">Mirrors</target>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">缺少父目录已创建。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">没有创建丢失的父目录。如果成功，则返回 &lt;code&gt;:ok&lt;/code&gt; ,如果发生 &lt;code&gt;{:error, reason}&lt;/code&gt; 则返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">混合任务</target>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="translated">当存储Mix 的内容和配置时，它还会回 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 和 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="translated">Mix还生成了一个名为 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 的文件，该文件负责设置测试框架：</target>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="translated">Mix还生成了用于运行我们的项目测试的适当结构。Mix项目通常遵循以下惯例：对于 &lt;code&gt;lib&lt;/code&gt; 目录中的每个文件，在 &lt;code&gt;test&lt;/code&gt; 目录中均具有 &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; 文件。因此，我们已经可以找到与我们的 &lt;code&gt;lib/kv.ex&lt;/code&gt; 文件相对应的 &lt;code&gt;test/kv_test.exs&lt;/code&gt; 。在这一点上，它并没有做很多事情：</target>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">Mix还在 &lt;code&gt;lib/kv.ex&lt;/code&gt; 处生成一个文件，该文件包含一个模块，该模块包含一个仅称为 &lt;code&gt;hello&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="translated">Mix还可以管理您的依赖项，并与&lt;a href=&quot;https://hex.pm&quot;&gt;Hex软件包管理器&lt;/a&gt;很好地集成。</target>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="translated">Mix还支持Git和路径依赖。</target>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="translated">混合和OTP</target>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="translated">混合和OTP指南</target>
        </trans-unit>
        <trans-unit id="5fa528ba639f2c7c836de5f176cd81f9105e7965" translate="yes" xml:space="preserve">
          <source>Mix by default ships with a public key but new ones can be added on demand.</source>
          <target state="translated">默认情况下,mix有一个公钥,但可以根据需要添加新的公钥。</target>
        </trans-unit>
        <trans-unit id="3c49eb51ca3d0ac562423c46ed5a59028d459767" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mix可以用于管理没有任何Elixir代码的Erlang项目。为了确保Mix任务对于Erlang项目正确运行， &lt;code&gt;language: :erlang&lt;/code&gt; 必须是 &lt;code&gt;project/0&lt;/code&gt; 返回的配置的一部分。此设置还确保不会将Elixir作为依赖项添加到生成的 &lt;code&gt;.app&lt;/code&gt; 文件或使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; 等&lt;/a&gt;生成的escript中。</target>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mix可用于管理没有任何Elixir代码的Erlang项目。为了确保Mix任务对于Erlang项目正确运行， &lt;code&gt;language: :erlang&lt;/code&gt; 必须是 &lt;code&gt;project/0&lt;/code&gt; 返回的配置的一部分。此设置还确保不会将Elixir作为依赖项添加到生成的 &lt;code&gt;.app&lt;/code&gt; 文件或使用&lt;a href=&quot;mix.tasks.escript.build&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;生成的escript中，依此类推。</target>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="translated">Mix是一种构建工具，因此预计不会在生产中提供。因此，建议访问 &lt;code&gt;Mix.env&lt;/code&gt; 只在配置文件和内部 &lt;code&gt;mix.exs&lt;/code&gt; ，从来没有在应用程序代码（ &lt;code&gt;lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="translated">Mix是一个构建工具,它提供了创建、编译、测试Elixir项目、管理其依赖关系等任务。</target>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="translated">Mix是Elixir的项目管理和构建工具。从命令行调用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;将在每个文件中运行测试，这些文件与在项目的 &lt;code&gt;test&lt;/code&gt; 目录中找到的模式 &lt;code&gt;*_test.exs&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="translated">Mix区分项目和应用程序。根据 &lt;code&gt;mix.exs&lt;/code&gt; 文件的内容，我们可以说我们有一个Mix项目，它定义了 &lt;code&gt;:kv&lt;/code&gt; 应用程序。正如我们将在后面的章节中看到的，有些项目没有定义任何应用程序。</target>
        </trans-unit>
        <trans-unit id="be2005a661cc869ecef72b52d2f918c6a1c2bad6" translate="yes" xml:space="preserve">
          <source>Mix projects can specify required archives using the &lt;code&gt;:archives&lt;/code&gt; option:</source>
          <target state="translated">Mix项目可以使用 &lt;code&gt;:archives&lt;/code&gt; 选项指定所需的档案：</target>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="translated">Mix提供了许多处理依赖项的任务，可以在 &lt;code&gt;mix help&lt;/code&gt; 看到：</target>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="translated">Mix提供了&amp;ldquo;环境&amp;rdquo;的概念。它们允许开发人员针对特定情况自定义编译和其他选项。默认情况下，Mix了解三种环境：</target>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="translated">混合对以下变量作出反应:</target>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="translated">混合壳使用当前进程邮箱进行通信。</target>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="translated">Mix在 &lt;code&gt;profile&lt;/code&gt; 名称空间下附带了许多任务，例如 &lt;code&gt;cprof&lt;/code&gt; 和 &lt;code&gt;fprof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="translated">Mix支持不同的环境。环境允许开发人员针对不同的场景专门准备和组织他们的项目。默认情况下,Mix提供了三种环境。</target>
        </trans-unit>
        <trans-unit id="83b58a0b5c1a90355989a0e6c6c83aa3b187f7ca" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">混合任务只能运行一次。这样可以防止同一任务多次执行。例如，如果有多个任务取决于&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;，则代码将被编译一次。如果使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; &lt;/a&gt;显式重新启用了任务，则可以再次执行任务：</target>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">混合任务只能运行一次。这样可以防止同一任务多次执行。例如，如果有多个任务取决于&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;，则代码将被编译一次。如果使用&lt;a href=&quot;mix.task#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; &lt;/a&gt;显式重新启用了任务，则可以再次执行任务：</target>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="translated">Mix将创建一个名为 &lt;code&gt;kv&lt;/code&gt; 的目录，其中包含一些文件：</target>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="translated">Mix将默认为 &lt;code&gt;:dev&lt;/code&gt; 环境，但 &lt;code&gt;test&lt;/code&gt; 任务将默认为 &lt;code&gt;:test&lt;/code&gt; 环境。可以通过 &lt;code&gt;MIX_ENV&lt;/code&gt; 环境变量来更改环境：</target>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在执行测试之前，Mix将加载 &lt;code&gt;test_helper.exs&lt;/code&gt; 文件。这是没有必要 &lt;code&gt;require&lt;/code&gt; 的 &lt;code&gt;test_helper.exs&lt;/code&gt; 在您的测试文件的文件。有关更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;Mix.Tasks.Test&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee77903e91bd71aaf1d44a1d48282536084b696b" translate="yes" xml:space="preserve">
          <source>Mix.Config</source>
          <target state="translated">Mix.Config</target>
        </trans-unit>
        <trans-unit id="e7628834f3db8ecf170e414a049c01be9012e895" translate="yes" xml:space="preserve">
          <source>Mix.ElixirVersionError</source>
          <target state="translated">Mix.ElixirVersionError</target>
        </trans-unit>
        <trans-unit id="5d3ee672a247963bfe70c641177c1ba0a41ff083" translate="yes" xml:space="preserve">
          <source>Mix.ElixirVersionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.ElixirVersionError&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ba0c0d562a5605e3a981b412bfebf8f39b9cb8cd" translate="yes" xml:space="preserve">
          <source>Mix.Error</source>
          <target state="translated">Mix.Error</target>
        </trans-unit>
        <trans-unit id="2f66ee90982acc2333482e324e66f83680cb1f82" translate="yes" xml:space="preserve">
          <source>Mix.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.Error&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b88ebcf3bbdbb70cb1e50aee5837165ee0fe04e4" translate="yes" xml:space="preserve">
          <source>Mix.Generator</source>
          <target state="translated">Mix.Generator</target>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.InvalidTaskError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoProjectError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoTaskError &lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="b27a97deee7753ee8eb8c3806c9cd74d0bb623c8" translate="yes" xml:space="preserve">
          <source>Mix.Release</source>
          <target state="translated">Mix.Release</target>
        </trans-unit>
        <trans-unit id="7bf1594ecaa648fd474444d9f33117c28b7ba143" translate="yes" xml:space="preserve">
          <source>Mix.SCM</source>
          <target state="translated">Mix.SCM</target>
        </trans-unit>
        <trans-unit id="12559e0f7b32d5fd2155ad9ecec382ea1f9fb246" translate="yes" xml:space="preserve">
          <source>Mix.SCM &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.SCM&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="147dd88a75a0c786898d12b4f3b2f0d6509bdbbe" translate="yes" xml:space="preserve">
          <source>Mix.Shell</source>
          <target state="translated">Mix.Shell</target>
        </trans-unit>
        <trans-unit id="db6ddc34f19b653dd6682b35bc47a0feda16df77" translate="yes" xml:space="preserve">
          <source>Mix.Shell &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Shell&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="c13560925a5e68a093665c40b5877151b400f1d5" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Quiet</source>
          <target state="translated">Mix.Shell.Quiet</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Task &lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6f91ff2c65c62a79e11d8c360e69332bd77495df" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler</source>
          <target state="translated">Mix.Task.Compiler</target>
        </trans-unit>
        <trans-unit id="53feeecd2c589ebee644042d57a6c38decab8485" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Task.Compiler&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d2bcc64e4a2da01e6d8df9586fbe7326fe6c2619" translate="yes" xml:space="preserve">
          <source>Mix.Task.Compiler.Diagnostic</source>
          <target state="translated">Mix.Task.Compiler.Diagnostic</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="translated">修改命令行参数。</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">模块&lt;small&gt;行为&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">模块属性</target>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="translated">模块和描述标签</target>
        </trans-unit>
        <trans-unit id="ff725127805595b93c72cd98d8e8f3dbd5984820" translate="yes" xml:space="preserve">
          <source>Module attribute unary operator. Reads and writes attributes in the current module.</source>
          <target state="translated">模块属性单列运算符。读取和写入当前模块的属性。</target>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="translated">模块属性</target>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="translated">Elixir中的模块属性有三个用途。</target>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="translated">模块属性读取器（ &lt;code&gt;@foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="translated">模块嵌套</target>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="translated">用于处理、定义和导入记录的模块。</target>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="translated">基于模块的监督员</target>
        </trans-unit>
        <trans-unit id="82bcbad43b8fe828d8612d7cf59577c71448624a" translate="yes" xml:space="preserve">
          <source>Module.Types.Error</source>
          <target state="translated">Module.Types.Error</target>
        </trans-unit>
        <trans-unit id="2835d1253cc2dd6d4f2059714db091dee1de72c4" translate="yes" xml:space="preserve">
          <source>Module.Types.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Module.Types.Error&lt;small&gt;异常&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f355677d6ea7dd474a7c5dc3db11334d6f6003dc" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; attribute. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; attribute we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">采用 &lt;code&gt;Parser&lt;/code&gt; 行为的模块将必须实现使用 &lt;code&gt;@callback&lt;/code&gt; 属性定义的所有功能。如您所见， &lt;code&gt;@callback&lt;/code&gt; 需要一个函数名称，但也需要一个函数规范，例如上面我们与 &lt;code&gt;@spec&lt;/code&gt; 属性一起使用的函数规范。还要注意， &lt;code&gt;term&lt;/code&gt; 类型用于表示解析后的值。在Elixir中， &lt;code&gt;term&lt;/code&gt; 类型是表示任何类型的快捷方式。</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">采用 &lt;code&gt;Parser&lt;/code&gt; 行为的模块将必须实现使用 &lt;code&gt;@callback&lt;/code&gt; 指令定义的所有功能。如您所见， &lt;code&gt;@callback&lt;/code&gt; 需要一个函数名称，但也需要一个函数规范，例如上面我们在 &lt;code&gt;@spec&lt;/code&gt; 指令中使用的函数规范。另请注意， &lt;code&gt;term&lt;/code&gt; 类型用于表示解析后的值。在Elixir中， &lt;code&gt;term&lt;/code&gt; 类型是表示任何类型的快捷方式。</target>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="translated">模块和功能</target>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="translated">用HiPE编译的模块不会调用这个钩子。</target>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="translated">尚未加载的模块将不会显示。如果要预加载所有任务，请检查&lt;a href=&quot;#load_all/0&quot;&gt; &lt;code&gt;load_all/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="translated">与基础系统接口的模块,如:</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="translated">监控器还是链接?</target>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="translated">监控节点的状态。</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="translated">如果提供 &lt;code&gt;--callers&lt;/code&gt; 和 &lt;code&gt;--details&lt;/code&gt; 选项，则返回更多详细信息。</target>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配对函数的更多示例：&lt;a href=&quot;base#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;base#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;file#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a76b5d6cb0550f163be45d1ffe3dd80feed4cca5" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配对函数的更多示例：&lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="translated">有关字素的更多信息，请参见&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode标准附件＃29&lt;/a&gt;。当前的Elixir版本实现了扩展字素簇算法。</target>
        </trans-unit>
        <trans-unit id="088ca4e64f0525b9190a46a6e7d28dc2bb334d89" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Tuple.html&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在&lt;a href=&quot;https://hexdocs.pm/elixir/Tuple.html&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;模块中可以找到有关元组数据类型和操作元组的函数的更多信息。&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中还提供了一些用于元组的函数（例如&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在&lt;a href=&quot;tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;模块中可以找到有关元组数据类型和操作元组的函数的更多信息。&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;中还提供了一些用于元组的函数（例如&lt;a href=&quot;kernel#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期时间的更多信息，请参见&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="e04894dfd3a6bb66a7491537a157990555658def" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期时间的更多信息，可以在&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期的更多信息，请参见&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="ad7f92deccb05da471db41290bd58b1c393e4789" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关日期的更多信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="45f71097bb0f5266ed4f78a2e99026509e61b3b6" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关原始日期时间的更多信息，可以在&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关原始日期时间的更多信息，可以在&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="fade606b3bd42ef1829481b3da2ebb0df791e41d" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="d0e509c546dcb0afd4dc86df671153581bf407f3" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可在&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;模块中找到有关正则表达式的更多信息。</target>
        </trans-unit>
        <trans-unit id="57430af0cc488dc7ee178424fa4b1f09dd9b2473" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关时间的更多信息，可以在&amp;ldquo;&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">有关时间的更多信息，可以在&amp;ldquo; &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;模块中找到。</target>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="translated">更有趣的是，我们可以匹配特定的值。下面的示例断言，仅当右侧是以原子 &lt;code&gt;:ok&lt;/code&gt; 开头的元组时，左侧才与右侧匹配：</target>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有更多选项可用；有关可用选项的完整列表，请检查&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="translated">而且，即使在退出陷阱时，如果任务已终止但未将其结果送回，则调用 &lt;code&gt;await&lt;/code&gt; 仍将退出。</target>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="translated">大多数Elixir代码都对其底层引用表达式进行了直接转换。我们建议您尝试不同的代码示例，看看结果如何。例如， &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; 扩展为什么？我们还了解到 &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; 与 &lt;code&gt;if true do :this else :that end&lt;/code&gt; 。这种肯定如何与带引号的表达式一起使用？</target>
        </trans-unit>
        <trans-unit id="7ef32c667bd728bf6d46696a457f5ed0e7db5896" translate="yes" xml:space="preserve">
          <source>Most commonly, this module is used to define your own configuration:</source>
          <target state="translated">最常见的是,这个模块用来定义自己的配置。</target>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="translated">大多数编辑器都提供了与格式化器的内置集成,允许在保存时或通过选定的键绑定对文件进行格式化。如果你正在学习Elixir,编辑器集成可以让你在学习Elixir语法时得到有用而快速的反馈。</target>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="translated">如果成功，此模块中的大多数功能将返回 &lt;code&gt;:ok&lt;/code&gt; 或 &lt;code&gt;{:ok, result}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。这些功能还有一个以 &lt;code&gt;!&lt;/code&gt; 结尾的变体！如果成功则返回结果（而不是 &lt;code&gt;{:ok, result}&lt;/code&gt; 元组），如果失败则抛出异常。例如：</target>
        </trans-unit>
        <trans-unit id="fe4747de8e4154287a567beb557c39a3a7ea6b63" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">该模块中的大多数功能都是线性工作的。这意味着执行操作所花费的时间与列表的长度以相同的速率增长。例如&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt;将在线性时间内运行，因为它们需要遍历列表中的每个元素，而&lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt;将在恒定时间内运行，因为它仅需要第一个元素。</target>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">该模块中的大多数功能都是线性工作的。这意味着执行操作所需的时间以与列表长度相同的速率增长。例如&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt;将在线性时间内运行，因为它们需要遍历列表中的每个元素，而&lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt;将在恒定时间内运行，因为它仅需要第一个元素。</target>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="translated">本模块中的大部分函数都是以线性时间工作的。这意味着,执行一个操作所需的时间与列表的长度以相同的速度增长。</target>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="translated">在捕捉函数时,可以看到大部分内联函数的效果。</target>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;中的大多数操作都是按照reduce来实现的。此函数应将给定的&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数应用于 &lt;code&gt;enumerable&lt;/code&gt; 每个元素，并按返回的累加器的预期进行。</target>
        </trans-unit>
        <trans-unit id="2bbbf699ba5529e80a9e0479fc3b9c7618a46171" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;中的大多数操作都是按照reduce来实现的。此函数应将给定的&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;函数应用于 &lt;code&gt;enumerable&lt;/code&gt; 每个元素，并按返回的累加器的预期进行。</target>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">在大多数情况下，将模块写入文件很方便，因此可以对其进行编译和重用。假设我们有一个名为 &lt;code&gt;math.ex&lt;/code&gt; 的文件，其中包含以下内容：</target>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="translated">大多数时候,在某个时区的某个日期和时间,只有一个有效的日期时间。</target>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="translated">大多数时候，Elixir会引导您做正确的事。例如，有一个 &lt;code&gt;elem/2&lt;/code&gt; 函数可以访问一个元组项，但是列表没有内置的等效项：</target>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="translated">将未记录的函数移至具有 &lt;code&gt;@moduledoc false&lt;/code&gt; 的模块（例如 &lt;code&gt;MyApp.Hidden&lt;/code&gt; )，以确保不会意外暴露或导入该函数。记住，您可以使用 &lt;code&gt;@moduledoc false&lt;/code&gt; 来隐藏整个模块，并仍然使用 &lt;code&gt;@doc&lt;/code&gt; 记录每个函数。工具仍将忽略该模块。</target>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="translated">好多了！ &lt;code&gt;with&lt;/code&gt; 将检索 &lt;code&gt;&amp;lt;-&lt;/code&gt; 右侧返回的值，并将其与左侧的模式匹配。如果值与模式匹配，则 &lt;code&gt;with&lt;/code&gt; 移至下一个表达式。如果没有匹配项，则返回不匹配的值。</target>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="translated">多重别名/进口/要求/使用。</target>
        </trans-unit>
        <trans-unit id="56c84318ece5d60a2edc2a745e9430721117f115" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; 中的&lt;/a&gt;多字母别名</target>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; 中的&lt;/a&gt;多字母别名</target>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="translated">多行字符列表用三个单引号（ &lt;code&gt;'''&lt;/code&gt; ）编写，与多行字符串相同。</target>
        </trans-unit>
        <trans-unit id="7c20d594d29120427ee2ec63c03ac466e7b133f7" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, and the like</source>
          <target state="translated">多行列表、地图、元组等。</target>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="translated">多行列表、地图、元组等。</target>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="translated">Elixir中的多行字符串用三个双引号引起来，并且其中可以包含未转义的引号。结果字符串将以换行符结尾。最后一个 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 缩进用于从内部字符串中去除缩进。例如：</target>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="translated">多个码点可能被读者认为是一个字符。</target>
        </trans-unit>
        <trans-unit id="4f0084cccc0c20805d1c2152e4b316e391ff55d4" translate="yes" xml:space="preserve">
          <source>Multiple elements may prefix the &lt;code&gt;| tail&lt;/code&gt; construct:</source>
          <target state="translated">多个元素可以加 &lt;code&gt;| tail&lt;/code&gt; 前缀。尾部构造：</target>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="translated">多个生成器也可以用来计算两个列表的卡提斯积。</target>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="translated">同一条款中的多个卫士</target>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="translated">多重执行</target>
        </trans-unit>
        <trans-unit id="ff8681bd747154b9388af5f672277e70fb2f689c" translate="yes" xml:space="preserve">
          <source>Multiple instances of the same backend can be specified by adding tuples in the format &lt;code&gt;{BackendModuleName, :backend_name}&lt;/code&gt;:</source>
          <target state="translated">可以通过添加格式为 &lt;code&gt;{BackendModuleName, :backend_name}&lt;/code&gt; 元组来指定同一后端的多个实例：</target>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="translated">多个版本。你可以根据每个应用程序的不同配置来组合不同的版本,甚至可以将不同的应用程序完全组合在一起。</target>
        </trans-unit>
        <trans-unit id="7568f33631ddb2754ee748a9c6bc2f4f8eceabd0" translate="yes" xml:space="preserve">
          <source>Multiple results can be checked within the same test:</source>
          <target state="translated">在同一个测试中可以检查多个结果。</target>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; 的多种用法会累积而不是覆盖以前的用法。请参阅下面的&amp;ldquo;编译选项&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="translated">&lt;code&gt;@dialyzer&lt;/code&gt; 的多次使用将累积而不是覆盖以前的用途。</target>
        </trans-unit>
        <trans-unit id="b5df1b82e3f5abfb84a6922491ed88fb7f160033" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, and others)</source>
          <target state="translated">可变状态和对共享资源(如ETS、文件等)的访问。</target>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="translated">可变状态和对共享资源(如ETS、文件等)的访问。</target>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="translated">我的计算机名为 &lt;code&gt;jv&lt;/code&gt; ，因此在上面的示例中看到 &lt;code&gt;foo@jv&lt;/code&gt; ，但是您将得到不同的结果。在以下示例中，我们将使用 &lt;code&gt;foo@computer-name&lt;/code&gt; ，并且在尝试代码时应相应地对其进行更新。</target>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="translated">可以通过键入 &lt;code&gt;ctrl + ]&lt;/code&gt; ，键入 &lt;code&gt;quit&lt;/code&gt; 并按 &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; 退出我特定的telnet客户端，但是您的客户端可能需要不同的步骤。</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="translated">姓名登记</target>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="translated">已命名的职能</target>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="translated">Elixir中的命名函数也支持默认参数。</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">命名惯例</target>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="translated">命名过程</target>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="translated">负极开关</target>
        </trans-unit>
        <trans-unit id="69411c8fc84402fa538d77b5600d2c036cb1597e" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported up to -377705116800 seconds:</source>
          <target state="translated">负的Unix时间支持到-377705116800秒。</target>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="translated">支持负的Unix时间,最高可达-62167219200秒,相当于 &quot;0000-01-01T00:00:00Z &quot;或0格里高利秒。</target>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="translated">负索引表示与 &lt;code&gt;list&lt;/code&gt; 末尾的偏移量。如果 &lt;code&gt;index&lt;/code&gt; 超出范围，则返回原始 &lt;code&gt;list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4450fa2237a90a818e8d5b18c9055436f51758cb" translate="yes" xml:space="preserve">
          <source>Nerves fetches all dependencies and looks for the system specific deps</source>
          <target state="translated">Nerves获取所有的依赖关系,并寻找系统特定的deps。</target>
        </trans-unit>
        <trans-unit id="0a5394a4bdb01b4c672f5bf8a58f03c03a747671" translate="yes" xml:space="preserve">
          <source>Nerves then clears the cache, forcing dependencies to be loaded again</source>
          <target state="translated">然后,Nerves会清除缓存,迫使依赖关系再次被加载。</target>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="translated">嵌套数据结构</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="translated">将一个模块嵌套在另一个模块中会影响嵌套模块的名称。</target>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">将给定文档嵌套在给定 &lt;code&gt;level&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66de056dde6e1fb5274c22b3b843bcd5283eddba" translate="yes" xml:space="preserve">
          <source>New events may be added at any time in the future, therefore it is advised for the &lt;code&gt;trace/2&lt;/code&gt; function to have a &quot;catch-all&quot; clause.</source>
          <target state="translated">将来可能会随时添加新事件，因此建议 &lt;code&gt;trace/2&lt;/code&gt; 函数具有&amp;ldquo; catch-all&amp;rdquo;子句。</target>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新版本在只读&lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;公告邮件列表中宣布&lt;/a&gt;。所有安全发行版&lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;都将标有 &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4091960ca8d66c5badd353d052ed80265508fa3" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新版本在只读&lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;公告邮件列表中宣布&lt;/a&gt;。所有安全发行版&lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date&quot;&gt;都将标有 &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="translated">在某些运营商(如管道运营商)之前和其他运营商(如比较运营商)之前添加新行。</target>
        </trans-unit>
        <trans-unit id="6de3ffff606ff25e1f43c0e5340bf371120e5de6" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for:</source>
          <target state="translated">除以下情况外,块内的新行与输入中的新行保持一致。</target>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="translated">块内的新行与输入中一样,除此之外。1)多行的表达式前后总是有一个空行 2)空行总是被挤在一起成为一个空行。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">今后的步骤</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="translated">接下来，让我们讨论外部和内部依赖性以及Mix如何帮助我们管理大型代码库。</target>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="translated">接下来，我们将看一下Elixir的核心功能Processes，它使我们能够以简单易懂的方式编写并发，并行和分布式程序。</target>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非我们调用&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;函数之一或&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; ,&lt;/a&gt;否则不会进行任何计算。</target>
        </trans-unit>
        <trans-unit id="ac00c06be47df8189da7f703834d94ee1ef7d289" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除非我们调用&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;函数之一或&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; ,&lt;/a&gt;否则不会进行任何计算。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="696cc484902450dc478328260fab02dcefae6c92" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">非映射作为&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="b6e83d3c9cef0e0783f020702595feef71f3f20e" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;uri#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">非映射作为&lt;a href=&quot;uri#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; 中的&lt;/a&gt;第二个参数</target>
        </trans-unit>
        <trans-unit id="071e8151474691189ee1733bdecf01a3f3e2cb81" translate="yes" xml:space="preserve">
          <source>Non-qualified calls (local calls)</source>
          <target state="translated">不合格电话(本地电话)</target>
        </trans-unit>
        <trans-unit id="53cb3754c560024cfd1bcc5260b860f30909000c" translate="yes" xml:space="preserve">
          <source>Non-qualified calls, such as &lt;code&gt;add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscore. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">非限定调用（例如 &lt;code&gt;add(1, 2)&lt;/code&gt; 必须以下划线或Unicode字母（大写或大写字母除外）开头。可以继续使用Unicode字母，数字和下划线序列进行呼叫。通话可能以 &lt;code&gt;?&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 。有关正式规范，请参见&lt;a href=&quot;unicode-syntax&quot;&gt;Unicode语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b40e406bdf08c15d5973db15d0796f73afa2bc3f" translate="yes" xml:space="preserve">
          <source>Normal color or intensity.</source>
          <target state="translated">正常的颜色或强度。</target>
        </trans-unit>
        <trans-unit id="485af32f6fc1eec7f09815a3b0ede51b1a6f1fe7" translate="yes" xml:space="preserve">
          <source>Normalization forms &lt;code&gt;:nfkc&lt;/code&gt; and &lt;code&gt;:nfkd&lt;/code&gt; should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets.</source>
          <target state="translated">规范化形式 &lt;code&gt;:nfkc&lt;/code&gt; 和 &lt;code&gt;:nfkd&lt;/code&gt; 不应盲目地应用于任意文本。因为它们消除了许多格式上的区别，所以它们将防止往返于许多旧式字符集的往返转换。</target>
        </trans-unit>
        <trans-unit id="522111b8eee38d26714335d6779562bdf0c0d1fc" translate="yes" xml:space="preserve">
          <source>Normalizes &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; filters to remove duplicates and keep precedence.</source>
          <target state="translated">规范化 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 过滤器以删除重复项并保持优先级。</target>
        </trans-unit>
        <trans-unit id="16efb8f5278c1947b297b82bf3c74d4bdac2d0d7" translate="yes" xml:space="preserve">
          <source>Normalizes an exception, converting Erlang exceptions to Elixir exceptions.</source>
          <target state="translated">规范化异常,将 Erlang 异常转换为 Elixir 异常。</target>
        </trans-unit>
        <trans-unit id="ca65eca931881f00085a8c21384007ac72711fde" translate="yes" xml:space="preserve">
          <source>Normalizes and formats any throw/error/exit.</source>
          <target state="translated">规范和格式化任何抛出/错误/退出。</target>
        </trans-unit>
        <trans-unit id="d040545513c396d6f00a60b9e02e4a5efcfb1b55" translate="yes" xml:space="preserve">
          <source>Normalizes and formats throw/errors/exits and stacktraces.</source>
          <target state="translated">规范和格式化抛出/错误/退出和堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="b4a7a922ef3ff8bef51868270a40e0256a78a3f8" translate="yes" xml:space="preserve">
          <source>Normally, repeating a module attribute will cause its value to be reassigned, but there are circumstances where you may want to &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;configure the module attribute&lt;/a&gt; so that its values are accumulated:</source>
          <target state="translated">通常，重复模块属性将导致其值被重新分配，但是在某些情况下，您可能需要&lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;配置模块属性&lt;/a&gt;以使其值被累积：</target>
        </trans-unit>
        <trans-unit id="343f0ad200dae1f7321bdbca2861d3e1cec1c9d9" translate="yes" xml:space="preserve">
          <source>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.</source>
          <target state="translated">并不是所有的表达方式都可以用在卫句中,而是只有少数几种。这是一个刻意的选择。这样一来,Elixir(和Erlang)可以确保在执行guards时不会发生任何不好的事情,也不会在任何地方发生突变。这也让编译器能够有效地优化与guards相关的代码。</target>
        </trans-unit>
        <trans-unit id="63cc6d4577351584189eae49ee593bacbcaa1a41" translate="yes" xml:space="preserve">
          <source>Not allowed in guard clauses.</source>
          <target state="translated">不允许在防护条款中使用。</target>
        </trans-unit>
        <trans-unit id="7bbb840640c8ed788ab616e2c3f9edd23f97d87a" translate="yes" xml:space="preserve">
          <source>Not equal to operator.</source>
          <target state="translated">不等于运营商。</target>
        </trans-unit>
        <trans-unit id="4f4ee146dc15494c81d4bd8a2a2759820080e7c5" translate="yes" xml:space="preserve">
          <source>Not framed or encircled.</source>
          <target state="translated">没有装裱或包围。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
