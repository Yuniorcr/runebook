<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">然而这样做效率不高。</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">但是，该语言的更高版本可能会将其更改为&amp;ldquo;从主体推断参数的类型&amp;rdquo;。那么上述 &lt;code&gt;foo&lt;/code&gt; 将被拒绝，因为无法从空的 &lt;code&gt;discard&lt;/code&gt; 语句中推断出参数的类型。</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">然而,这样的功能对上下文不敏感,只是简单地进行字符串匹配,这在Nim中可能是个问题,特别是由于语言的大小写不敏感(加上下划线作为分隔符!)。</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">但是，最大的问题是消除无效代码会破坏模块化！若要了解原因，请考虑以下情形：编译模块 &lt;code&gt;G&lt;/code&gt; （例如巨大的Gtk2模块...）时，打开了消除死代码的功能。因此， &lt;code&gt;G&lt;/code&gt; 的proc完全不会生成。</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">但是，您不必一定要分隔格式模式，像 &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; 这样的明确格式字符串也是有效的（尽管仅适用于1..9999范围内的年份）。</target>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">但是，如果文字的值适合该较小的类型，则可以将 &lt;code&gt;int&lt;/code&gt; 文字隐式转换为较小的整数类型，并且这种转换比其他隐式转换便宜，因此 &lt;code&gt;myInt16 + 34&lt;/code&gt; 会生成 &lt;code&gt;int16&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">但是，不能在通用代码中推断出 &lt;code&gt;void&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">但是，根据用例，也可以像这样包装 &lt;code&gt;new Foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">但是，对于类似C的目标，您需要静态或动态链接外部代码。集成本机代码的首选方法是使用动态链接，因为它允许您编译Nim程序而无需安装相关的开发库。尽管可以使用&lt;a href=&quot;dynlib&quot;&gt;dynlib模块&lt;/a&gt;获得更具体的控制，但是这可以通过&lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib实用程序进行导入&lt;/a&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">但是,如果需要进行不止一次的统计计算,那么将数据一次性推送到RunningStat对象中,再调用RunningStat对象的众多统计procs,效率更高。</target>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">但是，它不再是序数，因此无法将这些枚举用作数组的索引类型。程序 &lt;code&gt;inc&lt;/code&gt; ， &lt;code&gt;dec&lt;/code&gt; ， &lt;code&gt;succ&lt;/code&gt; 和 &lt;code&gt;pred&lt;/code&gt; 也不可用。</target>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">但是,由于模板不能对varargs进行迭代,所以这个功能一般对宏更有用。</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">但是,有时候必须要优化。按照以下顺序进行。</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">但是， &lt;code&gt;header&lt;/code&gt; 实用程序通常是更好的选择。</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">但是，上面的代码无法编译：原因是您必须覆盖 &lt;code&gt;n&lt;/code&gt; 可能包含的每个值，但是代码仅处理值 &lt;code&gt;0..8&lt;/code&gt; 。由于列出所有其他可能的整数不是很实际（尽管可以使用范围表示法来列出），因此我们通过告诉编译器对于其他每个值都不应该进行处理来解决此问题：</target>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">但是，约束 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;noalias&lt;/code&gt; 在普通例程中不可用。</target>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">但是,生成的C代码并不独立于平台。例如,为Linux生成的C代码不能在Windows上编译。C文件顶部的注释列出了该文件被编译的操作系统、CPU和CC。</target>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">但是，模块&lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;，&lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;和&lt;a href=&quot;times&quot;&gt;time&lt;/a&gt;可用！要访问DOM，请使用仅适用于JavaScript平台的&lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">但是，符号 &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;writeLine&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 已绑定，不再再次查找。如示例所示， &lt;code&gt;bindSym&lt;/code&gt; 确实可以隐式处理重载符号。</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">但是，字符串/ json的值存在很大问题：许多在编译时生成的查找表都嵌入了&lt;em&gt;proc var&lt;/em&gt;和没有明显字符串表示形式的类型...似乎AST diff仍然是最好的主意，因为它不需要使用外部API，并且至少与某些现有的Nimble软件包一起使用。</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">但是，这不起作用。问题在于该过程不仅应 &lt;code&gt;return&lt;/code&gt; ，而且应在迭代完成后返回并&lt;strong&gt;继续&lt;/strong&gt;。此&lt;em&gt;返回并继续&lt;/em&gt;称为&lt;em&gt;yield&lt;/em&gt;语句。现在剩下要做的就是用 &lt;code&gt;iterator&lt;/code&gt; 替换 &lt;code&gt;proc&lt;/code&gt; 关键字，这就是我们的第一个迭代器：</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">但是，这很少需要。最常见的情况是从 &lt;code&gt;e&lt;/code&gt; 提取错误消息，对于这种情况，使用 &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">但是，您也可以使用 &lt;code&gt;closure&lt;/code&gt; 迭代器来获得一组不同的限制。有关详细信息，请参见&lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;一流的迭代器&lt;/a&gt;。迭代器可以具有与proc相同的名称和参数，因为本质上它们具有自己的名称空间。因此，通常的做法是将迭代器包装在同名的&lt;a href=&quot;strutils&quot;&gt;proc中&lt;/a&gt;，这些proc会累积迭代器的结果，然后将其作为序列返回，例如从strutils模块 &lt;code&gt;split&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 人性化字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">模板中的卫生</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">我在这里使用&amp;ldquo; &lt;em&gt;单元格&lt;/em&gt; &amp;rdquo;一词来指代所追踪的所有内容（序列，引用，字符串）。本节介绍GC的工作方式。</target>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">IO效应。</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">IPv4映射地址。</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">IPv4兼容地址。</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">识别符混淆</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">确定建筑</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">识别符平等</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">标识符和关键字</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">标识符是 &lt;code&gt;nnkIdent&lt;/code&gt; 节点。通过名称查找后，这些节点将被转移到 &lt;code&gt;nnkSym&lt;/code&gt; 节点中。</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">标识符从其声明之时起至声明发生的区块结束时有效。标识符已知的范围就是标识符的范围。一个标识符的确切范围取决于它的声明方式。</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Nim中的标识符可以是字母，数字和下划线（以字母开头）的任何字符串。紧随其后的两个下划线 &lt;code&gt;__&lt;/code&gt; 是不允许的：</target>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">识别块的版本</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">Idetools调用</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Idetools输出始终在由制表符（ &lt;code&gt;\t&lt;/code&gt; ）分隔的单行上返回。每列的值为：</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">如果找不到与查询位置相匹配的有效符号,Idetools将始终以单个定义或无定义来回答。</target>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">如果 &lt;code&gt;address&lt;/code&gt; 为&amp;ldquo;&amp;rdquo;，则将绑定ADDR_ANY。</target>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">如果 &lt;code&gt;async&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则在错误是由于没有可用的数据读取引起的情况下，不会引发任何错误。</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">如果 &lt;code&gt;async&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则在错误是由于无法读取任何数据而导致的情况下，不会引发任何错误。</target>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;break&lt;/code&gt; 而没有跳转到的位置，则 &lt;code&gt;nnkEmpty&lt;/code&gt; 替换 &lt;code&gt;nnkIdent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;cache&lt;/code&gt; 不为空，则 &lt;code&gt;staticExec&lt;/code&gt; 的结果将缓存在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。然后使用 &lt;code&gt;--forceBuild&lt;/code&gt; 摆脱这种缓存行为。 &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; （连接的字符串）用于确定高速缓存中的条目是否仍然有效。您可以将版本信息用于 &lt;code&gt;cache&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">如果无法立即发送 &lt;code&gt;data&lt;/code&gt; ，它将在 &lt;code&gt;sock&lt;/code&gt; 变为可写状态时（在 &lt;code&gt;handleWrite&lt;/code&gt; 事件期间）进行缓冲和发送。有可能只立即发送一部分 &lt;code&gt;data&lt;/code&gt; ，而其余​​部分将被缓冲并稍后发送。</target>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">如果 &lt;code&gt;err&lt;/code&gt; 不小于0，则不会引发异常。</target>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。&lt;em&gt;precision&lt;/em&gt;的默认值是Nim的 &lt;code&gt;biggestFloat&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">如果 &lt;code&gt;format == ffDecimal&lt;/code&gt; 则precision是小数点后要打印的位数。如果 &lt;code&gt;format == ffScientific&lt;/code&gt; 则精度是要打印的最大有效位数。&lt;em&gt;precision&lt;/em&gt;的默认值是Nim的 &lt;code&gt;float&lt;/code&gt; 类型的小数点后的最大有效位数。</target>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">如果 &lt;code&gt;fut&lt;/code&gt; 首先完成，则返回的future将保持为true，否则，如果首先经过 &lt;code&gt;timeout&lt;/code&gt; 毫秒，则返回的future将为false。</target>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">如果 &lt;code&gt;in&lt;/code&gt; 被声明为 &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; 则 &lt;code&gt;T&lt;/code&gt; 将绑定到 &lt;code&gt;char&lt;/code&gt; 。但是 &lt;code&gt;s&lt;/code&gt; 与 &lt;code&gt;set[char]&lt;/code&gt; 类型不兼容！解决方案是将 &lt;code&gt;T&lt;/code&gt; 绑定到 &lt;code&gt;range['a'..'z']&lt;/code&gt; 。这是通过反转 &lt;code&gt;contains&lt;/code&gt; 的参数来实现的； &lt;code&gt;in&lt;/code&gt; 然后将其参数传递顺序相反。</target>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则二进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则十六进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">如果 &lt;code&gt;maxLen == 0&lt;/code&gt; ，则八进制数的长度没有上限。否则，最多解析 &lt;code&gt;start + maxLen&lt;/code&gt; 字符+ maxLen个字符，直到字符串的长度。</target>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">如果 &lt;code&gt;nested&lt;/code&gt; 为true，则在 &lt;code&gt;constructor&lt;/code&gt; AST中的所有位置替换文字，否则仅考虑第一级：</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">如果 &lt;code&gt;oneshot&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则计时器将仅被通知一次。</target>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">如果 &lt;code&gt;precision == -1&lt;/code&gt; ，它将尝试很好地格式化它。</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; ，则返回&lt;em&gt;true&lt;/em&gt;。如果 &lt;code&gt;s&lt;/code&gt; 是以下值之一： &lt;code&gt;n, no, false, 0, off&lt;/code&gt; ，则返回&lt;em&gt;false&lt;/em&gt;。如果 &lt;code&gt;s&lt;/code&gt; 是其他值，则会引发 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有字符均为字母且小写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有字符均为字母大写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有符文均为字母且小写时才返回true 。</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为false，则仅当 &lt;code&gt;s&lt;/code&gt; 中的所有符文均为字母和大写字母时，才返回true 。</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母字符均为小写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有字符都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母字符均为大写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有字符都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母符文均为小写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有符文都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">如果 &lt;code&gt;skipNonAlpha&lt;/code&gt; 为true，则如果 &lt;code&gt;s&lt;/code&gt; 中的所有字母符文均为大写，则返回true 。如果 &lt;code&gt;s&lt;/code&gt; 中的所有符文都不是字母，则返回false 。</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 是SSL套接字，则将自动执行握手。</target>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">如果 &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; 则返回true。</target>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ,则等待 &lt;code&gt;fv&lt;/code&gt; 不会阻塞。</target>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">如果将 &lt;code&gt;type&lt;/code&gt; 用于确定proc / iterator / converter调用 &lt;code&gt;c(X)&lt;/code&gt; 的结果类型（其中 &lt;code&gt;X&lt;/code&gt; 表示可能为空的参数列表），则 &lt;code&gt;c&lt;/code&gt; 是迭代器的解释优于其他解释：</target>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">如果设置了&lt;em&gt;fromRoot&lt;/em&gt;，则遍历将从文件系统根目录开始。如果设置了&lt;em&gt;inclusive&lt;/em&gt;，则遍历中将包含原始参数。</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">如果&lt;em&gt;前导&lt;/em&gt;为真，则剥离前导&lt;em&gt;字符&lt;/em&gt;。如果&lt;em&gt;尾随&lt;/em&gt;为真，则除去尾随的&lt;em&gt;字符&lt;/em&gt;。如果两者均为假，则字符串将保持不变。</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">如果&lt;em&gt;linkTitle&lt;/em&gt;或&lt;em&gt;linkDesc&lt;/em&gt;不是空字符串，则将添加两个附加列及其内容。</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;xnElement&lt;/em&gt;，则在每个子节点上递归运行并连接结果。</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;xnText&lt;/em&gt;或&lt;em&gt;xnEntity&lt;/em&gt;，则返回其内容。</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JArray&lt;/em&gt;，则返回元素数。如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JObject&lt;/em&gt;，则返回对数。否则返回0。</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;SList&lt;/em&gt;，则返回元素数。如果&lt;em&gt;n&lt;/em&gt;是&lt;em&gt;JObject&lt;/em&gt;，则返回对数。否则返回0。</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">如果&lt;em&gt;path&lt;/em&gt;没有扩展名，则&lt;em&gt;ext&lt;/em&gt;是空字符串。如果&lt;em&gt;path&lt;/em&gt;没有目录组件，则&lt;em&gt;dir&lt;/em&gt;是空字符串。如果&lt;em&gt;path&lt;/em&gt;没有文件名部分，则&lt;em&gt;name&lt;/em&gt;和&lt;em&gt;ext&lt;/em&gt;为空字符串。</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">如果&lt;em&gt;place&lt;/em&gt;为0（或省略），则遵循正常的数学舍入规则将舍入到最接近的整数值（例如，&lt;em&gt;round（54.5）-&amp;gt; 55.0&lt;/em&gt;）。如果&lt;em&gt;位数&lt;/em&gt;大于0，则舍入到给定的小数位数，例如&lt;em&gt;round（54.346，2）-&amp;gt; 54.35&lt;/em&gt;。如果&lt;em&gt;places&lt;/em&gt;为负数，则四舍五入到小数点左边，例如，&lt;em&gt;round（537.345，-1）-&amp;gt; 540.0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">如果&lt;em&gt;s不&lt;/em&gt;包含&lt;em&gt;chars&lt;/em&gt;中的任何&lt;em&gt;字符&lt;/em&gt;，则返回-1。</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不以 &lt;code&gt;prefix&lt;/code&gt; 开头和以 &lt;code&gt;suffix&lt;/code&gt; 结尾，则将引发ValueError异常。</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的二进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0b&lt;/code&gt; ， &lt;code&gt;0B&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的十六进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0X&lt;/code&gt; ， &lt;code&gt;#&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">如果&lt;em&gt;s&lt;/em&gt;不是有效的八进制整数，则引发&lt;em&gt;ValueError&lt;/em&gt;。&lt;em&gt;s&lt;/em&gt;可以具有以下可选前缀之一： &lt;code&gt;0o&lt;/code&gt; ， &lt;code&gt;0O&lt;/code&gt; 。&lt;em&gt;s&lt;/em&gt;中的下划线将被忽略。</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">如果&lt;em&gt;siPrefix&lt;/em&gt;设置为true，则将显示该数字以及与该指数对应的SI前缀。例如，4100将显示为&amp;ldquo; 4.1 k&amp;rdquo;而不是&amp;ldquo; 4.1e3&amp;rdquo;。请注意，&lt;em&gt;u&lt;/em&gt;用于代替ISO 2955的希腊字母mu（&amp;mu;）。绝对值超出1e-18 &amp;lt;f &amp;lt;1000e18（1a &amp;lt;f &amp;lt;1000E）范围的数字将显示为指数，而不是SI前缀，而不管&lt;em&gt;siPrefix&lt;/em&gt;是否为true。</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">如果&lt;em&gt;spread&lt;/em&gt;为false并且&lt;em&gt;s&lt;/em&gt;的长度不是&lt;em&gt;num&lt;/em&gt;的倍数，则proc将使用 &lt;code&gt;1 + len(s) div num&lt;/code&gt; 个条目最大化第一个子序列，而其余​​元素保留到最后一个序列。</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">如果&lt;em&gt;trim&lt;/em&gt;设置为true，则尾随零将被删除；如果为false，则始终显示由&lt;em&gt;precision&lt;/em&gt;指定的位数。</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">如果&lt;em&gt;useUnitSpace&lt;/em&gt;为true，则将提供的单位追加到字符串（SI标准要求的空格）。这种行为与将单位附加到结果上略有不同，因为根据是否存在指数而改变了空间的位置。</target>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">如果已声明的符号带有&lt;span id=&quot;asterisk_1&quot;&gt;星号&lt;/span&gt;，则会从当前模块中将其导出：</target>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索整行；返回 &lt;code&gt;ReadFullLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索整行； &lt;code&gt;RecvFullLine&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">如果读取了整行 &lt;code&gt;\r\L&lt;/code&gt; 不会添加到 &lt;code&gt;line&lt;/code&gt; ，但是如果仅读取 &lt;code&gt;\r\L&lt;/code&gt; ，则将 &lt;code&gt;line&lt;/code&gt; 设置为它。</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">如果读取了整行，则不会将 &lt;code&gt;\r\L&lt;/code&gt; 添加到结果中，但是如果仅读取 &lt;code&gt;\r\L&lt;/code&gt; ，则将结果设置为该行。</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">如果收到的全系列 &lt;code&gt;\r\L&lt;/code&gt; 未添加到 &lt;code&gt;line&lt;/code&gt; ，但是如果仅仅 &lt;code&gt;\r\L&lt;/code&gt; 收到然后 &lt;code&gt;line&lt;/code&gt; 将被设置为它。</target>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">如果一行以 &lt;code&gt;#&lt;/code&gt; 开头，它将被完全忽略，因此您可以将其用作注释。</target>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">如果一个模块由两个不同的模块导入一个标识符,标识符的每一次出现都要进行限定,除非它是一个重载的过程或迭代器,在这种情况下,就会发生重载解析。</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">如果一个节点被用在与创建它的文档不同的文档中(该文档不支持它</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">如果一个参数或一个操作不被底层对象支持。</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">如果proc带有 &lt;code&gt;noinit&lt;/code&gt; 注释，则引用其隐式 &lt;code&gt;result&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果引用&lt;em&gt;没有&lt;/em&gt;指向&lt;em&gt;任何内容&lt;/em&gt;，则其值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">如果一段代码持有 &lt;code&gt;M&lt;/code&gt; 级锁，那么它也可以获得 &lt;code&gt;N &amp;lt; M&lt;/code&gt; 级的任何锁。无法获取另一个级别 &lt;code&gt;M&lt;/code&gt; 的锁。只能在单个 &lt;code&gt;locks&lt;/code&gt; 节中&lt;em&gt;同时&lt;/em&gt;获取相同级别的锁：</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">如果一个结构化类型具有一个可反构类型的字段,而用户没有提供一个明确的实现,那么该结构化类型的反构函数将被自动生成。在用户定义的和生成的析构器中,都会插入对基类析构器的调用。</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">如果一个类型部分使用了通用参数,则在这里进行处理。</target>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">如果在Nim的内存管理器或GC中的断言失败,堆栈跟踪就会一直分配内存! 因此,堆栈溢出可能会发生,隐藏了真正的问题。</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">如果试图添加一个已在其他地方使用的属性</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">如果试图以不正确的命名空间方式创建或更改对象。</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">如果试图在不允许修改的地方修改一个对象</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">如果试图修改基础对象的类型。</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">如果尝试在一个不存在的上下文中引用一个节点</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">如果试图使用一个不可用或不再可用的对象;</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">如果等待的将来以错误完成，则 &lt;code&gt;await&lt;/code&gt; 将重新引发此错误。为了避免这种情况，可以使用 &lt;code&gt;yield&lt;/code&gt; 关键字代替 &lt;code&gt;await&lt;/code&gt; 。下一节将介绍在异步处理中处理异常的不同方法。</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">如果发生错误,EOS将被提出。</target>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">如果发生错误,将引发一个EOS异常。否则返回值将是接收到的数据长度。</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">如果发生错误,将引发OSError异常。</target>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">如果发生错误，则返回值为 &lt;code&gt;-1&lt;/code&gt; 。否则，返回值将是接收到的数据的长度。</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">如果偶数的反斜杠后面有双引号,那么每一对反斜杠就会在argv数组中放置一个反斜杠,双引号被解释为字符串定界符。</target>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">如果给定了初始化器,可以省略类型:那么变量的类型与初始化表达式相同。如果没有初始化表达式,变量总是用默认值初始化。默认值取决于类型,在二进制中总是一个零。</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">如果指定了一个无效或非法的字符串。</target>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">如果奇数的反斜杠后面是双引号,那么每一对反斜杠在argv数组中放置一个反斜杠,双引号被剩下的反斜杠 &quot;转义&quot;,导致一个字面的双引号(&quot;)被放置在argv中。</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">如果存在一个可选参数,则使用以下查找算法。</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">如果一元运算符的第一个字符是 &lt;code&gt;@&lt;/code&gt; ，则它是&lt;span id=&quot;sigilminuslike_1&quot;&gt;类似于sigil的&lt;/span&gt;运算符，其绑定强度大于 &lt;code&gt;primarySuffix&lt;/code&gt; ： &lt;code&gt;@x.abc&lt;/code&gt; 解析为 &lt;code&gt;(@x).abc&lt;/code&gt; &lt;code&gt;$x.abc&lt;/code&gt; ）.abc，而$ x.abc解析为 &lt;code&gt;$(x.abc)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">如果有任何节点被插入了不属于它的地方。</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">如果断言被关闭,它什么都不做。如果开启了断言,以后的版本会检查字符串的有效语法。</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">如果异步调度程序未运行，则 &lt;code&gt;cbproc&lt;/code&gt; 将立即执行。</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">如果异步调度程序正在运行，则 &lt;code&gt;cbproc&lt;/code&gt; 将在下一个调度程序滴答期间执行。</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">如果调用 &lt;code&gt;recv&lt;/code&gt; 失败； &lt;code&gt;RecvFail&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">如果调用 &lt;code&gt;recv&lt;/code&gt; 失败；&lt;strong&gt;引发EOS异常。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">如果为一个不支持数据的节点指定了数据</target>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">如果定义了环境变量 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; ，则 &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; 或 &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; （POSIX）或 &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; （Windows）。可以使用 &lt;code&gt;--skipUserCfg&lt;/code&gt; 命令行选项跳过此文件。</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">如果表达式</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">如果将来已经完成，那么 &lt;code&gt;cb&lt;/code&gt; 将立即被调用。</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">如果head是空字符串,则返回尾部。如果tail是空字符串,则返回带有尾部路径分隔符的head。如果尾巴以路径分隔符开始,那么它将在连接到head时被移除。其他不在边界上的路径分隔符不会被修改。更多关于Unix的例子。</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">如果在上面的例子模块 &lt;code&gt;B&lt;/code&gt; 是重新编译，但 &lt;code&gt;A&lt;/code&gt; 不那么 &lt;code&gt;B&lt;/code&gt; 需要注意的 &lt;code&gt;toBool&lt;/code&gt; 即使 &lt;code&gt;toBool&lt;/code&gt; 不中引用 &lt;code&gt;B&lt;/code&gt; &lt;em&gt;明确&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">如果指数或大小为负值,或者大于允许值</target>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">如果预计将增加更多的项目,只需在调用此函数之前将预计的额外数量添加到参数中即可。</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">如果需要更精确的控制，可以在提供的模式中使用撇号 &lt;code&gt;'&lt;/code&gt; 来表示通用类型的具体类型参数。有关更多详细信息，请参见proc模式中的撇号运算符的用法。</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">如果nimcache已经包含来自同一项目的不同编译器的编译代码，请添加 &lt;code&gt;-f&lt;/code&gt; 标志以强制重新编译所有文件。</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">如果无法检索到数据； &lt;code&gt;ReadNone&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">如果没有给出异常名称，则&lt;span id=&quot;reminusraised_1&quot;&gt;重新引发&lt;/span&gt;当前异常。该&lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt;如果没有例外的再次加注异常。因此， &lt;code&gt;raise&lt;/code&gt; 语句&lt;em&gt;始终&lt;/em&gt;会引发异常。</target>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">如果对象 &lt;code&gt;a&lt;/code&gt; 从 &lt;code&gt;b&lt;/code&gt; 继承，则 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;b&lt;/code&gt; 的子类型。此子类型关系扩展为 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ptr&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">如果可能的话,name参数应该与tz数据库中使用的名称相匹配,如果时区在tz数据库中不存在,或者时区名称未知,那么可以使用任何描述时区的字符串。如果时区不存在于tz数据库中,或者时区名称不详,那么可以使用任何能够明确描述时区的字符串。请注意,时区名称是用来检查平等性的!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">如果可能的话,名称将是tz数据库中使用的名称。如果时区在tz数据库中不存在,或者时区名称不详,那么可以使用任何能够明确描述时区的字符串。例如,字符串 &quot;LOCAL &quot;被用来表示系统的本地时区。</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果套接字断开连接并且没有数据可读取，则将来将以 &lt;code&gt;&quot;&quot;&lt;/code&gt; 值结束。</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果套接字已断开并且没有可用数据读取，则将来将以 &lt;code&gt;0&lt;/code&gt; 值结束。</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">如果socket在recv操作过程中被断开,那么未来可能只完成部分请求数据。</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索到一些数据； &lt;code&gt;ReadPartialLine&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">如果已检索到一些数据；返回 &lt;code&gt;RecvPartialLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">如果声明</target>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">如果存在'#'字符,整数将使用'交替形式'进行格式化。这意味着二进制、八进制和十六进制输出将分别以'0b'、'0o'和'0x'作为前缀。</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">如果&lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;实验模式&lt;/a&gt;处于活动状态且未找到其他匹配项，则如果第一个参数 &lt;code&gt;a&lt;/code&gt; 是指针类型，则会自动取消引用该参数，并尝试使用 &lt;code&gt;a[]&lt;/code&gt; 尝试重载分辨率。</target>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; pragma与参数一起使用，则该参数需要为 &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; 。如果不带参数使用它，则使用 &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">如果 &lt;code&gt;raise&lt;/code&gt; 关键字后没有表达式，则&lt;em&gt;重新引发&lt;/em&gt;最后一个异常。为了避免重复该共同的代码图案为目的，模板 &lt;code&gt;newException&lt;/code&gt; 中 &lt;code&gt;system&lt;/code&gt; 模块可用于：</target>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">如果打开 &lt;code&gt;stackTrace&lt;/code&gt; 选项，则生成的C包含代码，以确保在程序崩溃或引发未捕获的异常时给出正确的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">如果&lt;em&gt;文件名&lt;/em&gt;没有扩展名，则将添加&lt;em&gt;ext&lt;/em&gt;。如果&lt;em&gt;ext&lt;/em&gt; ==&amp;ldquo;&amp;rdquo;，则所有扩展名都将被删除。&lt;em&gt;Ext&lt;/em&gt;应该不带前导&amp;ldquo;。&amp;rdquo;，因为某些文件系统可能使用不同的字符。（尽管我不知道有这样的野兽。）</target>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">如果使用GNU汇编器,则会自动插入引号和换行。</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">如果等待的期货&lt;em&gt;是&lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; ，则此proc返回 &lt;code&gt;Future[void]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">如果等待的期货不是 &lt;code&gt;Future[void]&lt;/code&gt; ，则返回的期货将按顺序保存所有等待的期货的值。</target>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">如果文件不存在，则会引发&lt;em&gt;EIO&lt;/em&gt;。从迭代行中删除尾随换行符。例：</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">如果文件指针已经过了文件的末端,那么将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">如果文件指针超出了文件的末尾，则返回零，并且没有字节读取到 &lt;code&gt;buf&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">如果for循环表达式 &lt;code&gt;e&lt;/code&gt; 不表示迭代器，并且for循环正好具有1个变量，则for循环表达式将重写为 &lt;code&gt;items(e)&lt;/code&gt; ；即。一个 &lt;code&gt;items&lt;/code&gt; 迭代器被隐式调用：</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">如果for循环恰好具有2个变量，则将隐式调用 &lt;code&gt;pairs&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">如果除了普通类型检查之外，形式参数 &lt;code&gt;f&lt;/code&gt; 的类型也为 &lt;code&gt;var T&lt;/code&gt; ，则将参数检查为&lt;span id=&quot;lminusvalue_1&quot;&gt;l值&lt;/span&gt;。 &lt;code&gt;var T&lt;/code&gt; 匹配不仅仅是好 &lt;code&gt;T&lt;/code&gt; 呢。</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">如果将来的流已经有数据或已完成，则 &lt;code&gt;cb&lt;/code&gt; 将立即被调用。</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">如果处理程序没有引发异常,则普通控制流继续进行,程序终止。</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">如果实现不支持所请求的对象或操作类型。</target>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">如果不能检索到信息,比如文件句柄无效,就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">如果信息无法检索,比如路径不存在,或者权限限制使程序无法检索文件信息,就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">如果迭代器产生一个元组,那么元组中有多少个分量,就可以有多少个迭代变量。第i个迭代变量的类型就是第i个组件的类型。换句话说,在for循环上下文中支持隐式元组解包。</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">如果与操作者的端部 &lt;code&gt;=&lt;/code&gt; 和其第一个字符是没有的 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; ，它是具有第二低优先级的&lt;em&gt;赋值运算符&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">如果proc声明没有主体，则为&lt;span id=&quot;forward_1&quot;&gt;前向&lt;/span&gt;声明。如果proc返回一个值，则过程主体可以访问一个隐式声明的名为&lt;span id=&quot;result_2&quot;&gt;result的&lt;/span&gt;变量，该变量表示返回值。过程可能会超载。重载解析算法确定哪个proc最适合参数。例：</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">如果该过程需要修改调用方的参数，则可以使用 &lt;code&gt;var&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">如果未来的结果是一个错误,那么这个错误将被提出。</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">如果产生的字符串不比原始输入字符串长,只需要分配一次内存。</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">如果插座已断开； &lt;code&gt;ReadDisconnected&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">如果插座已断开； &lt;code&gt;RecvDisconnected&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">如果套接字在一行中间断开（在读取 &lt;code&gt;\r\L&lt;/code&gt; 之前），则该行将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。分线&lt;strong&gt;将丢失&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">如果套接字断开连接，则将 &lt;code&gt;line&lt;/code&gt; 设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 并返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果插座断开，则 &lt;code&gt;line&lt;/code&gt; 将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果套接字断开连接，则结果将设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">如果指定的文字范围不能放入DOMString中 目前不使用(因为DOMString只是字符串)</target>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">如果关闭异味模式，则 &lt;code&gt;TaintedString&lt;/code&gt; 只是 &lt;code&gt;string&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">如果打开异味模式（通过 &lt;code&gt;--taintMode:on&lt;/code&gt; 命令行选项），则它是一种独特的字符串类型，有助于检测输入验证错误：</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">如果模板的参数没有类型，则 &lt;code&gt;nnkFormalParams&lt;/code&gt; 内部的类型标识符将变为 &lt;code&gt;nnkEmpty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">如果模板没有显式的返回类型，则将 &lt;code&gt;void&lt;/code&gt; 用于与proc和方法保持一致。</target>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">如果宽度字段前有零('0')字符,则启用零填充。</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">如果有 &lt;code&gt;finally&lt;/code&gt; 部分，则总是在异常处理程序之后执行。</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">如果有一个&lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt;子句，它总是在异常处理程序之后执行。</target>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">如果没有要从套接字读取的数据，将返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">如果该算法返回，执行&amp;ldquo;模糊&amp;rdquo;进一步消歧：如果参数 &lt;code&gt;a&lt;/code&gt; 匹配两个参数类型 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的 &lt;code&gt;q&lt;/code&gt; 经由子类型关系，继承深度是考虑到：</target>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。在Windows平台上，此proc会将属性从&lt;em&gt;源&lt;/em&gt;复制到&lt;em&gt;dest&lt;/em&gt;。在其他平台上，创建的文件和目录将为用户继承新创建的文件/目录的默认权限。要在这些平台上递归保留属性，请使用&lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。在Windows平台上，此proc将把源文件的属性复制到dest。在其他平台上，您需要使用&lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions（）&lt;/a&gt;和&lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions（）&lt;/a&gt;手动复制它们（或使用便捷的&lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions（）&lt;/a&gt; proc），否则&lt;em&gt;dest&lt;/em&gt;将为用户继承新创建文件的默认权限。如果&lt;em&gt;dest&lt;/em&gt;已经存在，则将保留文件属性，并覆盖内容。</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。如果目录从不存在，这不会失败。</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。这是在非Windows平台上围绕&lt;a href=&quot;#copyDir&quot;&gt;copyDir（）&lt;/a&gt;和&lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions（）&lt;/a&gt;的包装过程。在Windows上，此proc只是&lt;a href=&quot;#copyDir&quot;&gt;copyDir（）&lt;/a&gt;的包装，因为该proc已经复制了属性。</target>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">如果我们使用 &lt;code&gt;from ... import&lt;/code&gt; ，结果也将不同。</target>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">如果您使用简单的标准类型（例如 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; )作为表的键，则不会有任何问题，但是，一旦尝试将更复杂的对象用作键，就会遇到奇怪的编译器错误：</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">如果您不想运行所有测试用例文件，则可以将任何子字符串作为参数传递给 &lt;code&gt;caasdriver&lt;/code&gt; 。只有与传递的子字符串匹配的文件才会运行。过滤不使用任何全局元字符，这是简单匹配。例如，仅以详细模式运行 &lt;code&gt;*-compile*.txt&lt;/code&gt; 测试：</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">如果你超链接一个纯名符号,而同一HTML文件上还有其他匹配的符号,大多数浏览器会转到第一个。为了区分其他的符号,您需要使用复名。一个可调用类型的复名是由几个部分组成的。</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">如果您知道自己在做什么，还可以将单个字符串（或序列）对象标记为&amp;ldquo; &lt;span id=&quot;shallow_1&quot;&gt;浅&amp;rdquo;&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">如果需要异步服务器套接字，但希望同步处理客户端，则可以使用 &lt;code&gt;getSocket&lt;/code&gt; 转换器从 &lt;code&gt;AsyncSocket&lt;/code&gt; 对象获取 &lt;code&gt;Socket&lt;/code&gt; ，然后可以将其与 &lt;code&gt;accept&lt;/code&gt; 结合使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">如果需要带有键的序列，则可以在迭代器上使用&lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq（）&lt;/a&gt;。用法示例：</target>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">如果您需要&lt;em&gt;访问&lt;/em&gt;内部的实际的异常对象或消息 &lt;code&gt;except&lt;/code&gt; 分支您可以使用&lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException（）&lt;/a&gt;和&lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg（）&lt;/a&gt;特效从&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块。例：</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">如果需要允许rst &lt;code&gt;include&lt;/code&gt; 指令或调整生成的输出，则必须使用 &lt;code&gt;initRstGenerator&lt;/code&gt; 和相关 &lt;code&gt;RstGenerator&lt;/code&gt; 创建自己的RstGenerator。</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">如果需要创建多个标识符，则需要使用较低级别的 &lt;code&gt;newNimNode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">如果需要将Nim分配的内存传递给C，则可以使用procs &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 将对象标记为引用对象，以免GC释放它们。您可以用来跟踪内存的&lt;a href=&quot;system&quot;&gt;系统中&lt;/a&gt;其他有用的过程是：</target>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">如果使用Nim的灵活调用语法（如 &lt;code&gt;x.len()&lt;/code&gt; 所示），则结果与上面相同，但包装在 &lt;code&gt;nnkCall&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">如果你使用这个函数,你不需要使用asyncdispatch.recv()或asyncdispatch.accept(),因为它们使用的是IOCP,请使用nativesockets.recv()和nativesockets.accept()代替。</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">如果你使用这个函数,你不需要使用asyncdispatch.send()或asyncdispatch.connect(),因为它们使用的是IOCP,请使用nativesockets.send()和nativesockets.connect()代替。</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">如果要将 &lt;code&gt;{.raises.}&lt;/code&gt; 注添加到现有代码中，编译器也可以为您提供帮助。您可以在您的proc中添加 &lt;code&gt;{.effects.}&lt;/code&gt; pragma语句，然后编译器将输出所有推断的效果，直到这一点为止（异常跟踪是Nim效果系统的一部分）。找出proc引发的异常列表的另一种回旋方式是使用Nim &lt;code&gt;doc2&lt;/code&gt; 命令，该命令为整个模块生成文档，并用引发的异常列表装饰所有proc 。您可以&lt;a href=&quot;manual#effect-system&quot;&gt;在手册中&lt;/a&gt;详细了解Nim的效果系统和相关的语用。</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">如果你想为你的自定义类型实现哈希程序,你最终会写出以下的代码骨架。</target>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">如果你想在每次重载时重置全局变量的状态,只需在顶层代码的任何地方重新分配一个值即可。</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">如果要在自己的文档中重用此功能，则必须修改 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 以包含 &lt;code&gt;doc.item.seesrc&lt;/code&gt; 值，并带有指向自己代码存储库的超链接。正如您在该文件中的注释所看到的那样，在命令行中传递的 &lt;code&gt;txt&lt;/code&gt; 值将与其他 &lt;code&gt;$path&lt;/code&gt; 和 &lt;code&gt;$line&lt;/code&gt; 一起在HTML模板中使用。</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">如果你想使用stdin/stdout作为通讯方式启动服务器,你需要输入。</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">如果你想使用tcp和端口启动服务器,你需要输入。</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果您想删除回调，只需将其设置为 &lt;code&gt;nil&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">如果您的自定义类型包含已经存在哈希处理的字段，例如由 &lt;code&gt;strings&lt;/code&gt; 组成的对象，则可以简单地将各个字段的哈希值哈希在一起：</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">忽略存储过程的返回值而不使用丢弃语句是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">具体实施方法</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">实现&lt;span id=&quot;deque_1&quot;&gt;双端队列&lt;/span&gt;（双端队列）。基础实现使用 &lt;code&gt;seq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">单链和双链列表的实现。因为这样做没有意义,所以'next'和'prev'指针不会被你隐藏,可以直接操作,提高效率。</target>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">实施尼姆的 &quot;产卵&quot;。</target>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">隐含的项目/对子的调用</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">进口部分</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">进口声明</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">ImportCpp pragma</target>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC pragma</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">Importc pragma</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">为enums导入cpp</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">导入对象的cpp</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">为procs导入cpp</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">进口的例外情况</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">将一个节点从另一个文档导入到这个文档。</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">不纯的图书馆</target>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">在 &lt;code&gt;if&lt;/code&gt; 语句中，新作用域在 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 关键字之后立即开始，并在相应的&lt;em&gt;then&lt;/em&gt;块之后结束。出于可视化目的，范围已包含在 &lt;code&gt;{| |}&lt;/code&gt; 在以下示例中：</target>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">在Nim中，对象是例外。按照约定，异常类型的后缀为&amp;ldquo;错误&amp;rdquo;。该&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块定义的异常层次结构，你可能要坚持到。异常来自提供公共接口的 &lt;code&gt;system.Exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">在Nim中，可以在 &lt;code&gt;type&lt;/code&gt; 语句中定义新的类型：</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">在Nim中,编译器不能总是知道一个引用是否存储在堆栈上。这是由var参数造成的。考虑一下这个例子。</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">在Nim中，&lt;em&gt;简单语句&lt;/em&gt;和&lt;em&gt;复杂语句&lt;/em&gt;之间是有区别的。&lt;em&gt;简单语句&lt;/em&gt;不能包含其他语句：赋值，过程调用或 &lt;code&gt;return&lt;/code&gt; 语句属于简单语句。诸如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 的&lt;em&gt;复杂语句&lt;/em&gt;可以包含其他语句。为避免歧义，复杂的语句必须始终缩进，但单个简单的语句则不能：</target>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">在UTF-8模式下，其值大于128个字符永远不会匹配 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ，或 &lt;code&gt;\w&lt;/code&gt; ，并总是匹配 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ，和 &lt;code&gt;\W&lt;/code&gt; 。即使提供了Unicode字符属性支持，也是如此。</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">在 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 语句中，可以执行元组拆包。特殊标识符 &lt;code&gt;_&lt;/code&gt; 可用于忽略元组的某些部分：</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">在调用 &lt;code&gt;p(args)&lt;/code&gt; 中，选择最匹配的例程 &lt;code&gt;p&lt;/code&gt; 。如果多个例程匹配得很好，则会在编译时报告歧义。</target>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">在语句列表中，除最后一个表达式外，每个表达式都必须具有 &lt;code&gt;void&lt;/code&gt; 类型。除此规则外，对内置 &lt;code&gt;result&lt;/code&gt; 符号的赋值还会触发后续表达式的强制性 &lt;code&gt;void&lt;/code&gt; 上下文：</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">在多方法中,所有具有对象类型的参数都会被用于调度。</target>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">除了 &lt;code&gt;GC_ref&lt;/code&gt; 和 &lt;code&gt;GC_unref&lt;/code&gt; 您可以通过像特效手动分配内存避免了GC &lt;code&gt;alloc&lt;/code&gt; ， &lt;code&gt;allocShared&lt;/code&gt; ，或 &lt;code&gt;allocCStringArray&lt;/code&gt; 。GC不会尝试释放它们，完成处理后，您需要调用它们各自的&lt;em&gt;dealloc&lt;/em&gt;对，否则它们将泄漏。</target>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">除了字段外,例程应用也会被重写,但前提是不能对调用进行其他解释。</target>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">除了可以防止类型检查的未 &lt;code&gt;untyped&lt;/code&gt; 元类型之外，还可以使用 &lt;code&gt;varargs[untyped]&lt;/code&gt; 以便甚至无法固定参数数量：</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">除了前几级转储调试堆栈跟踪,供编译器开发者使用。</target>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">除了用于带符号和无符号整数的常用算术运算符（ &lt;code&gt;+ - *&lt;/code&gt; 等）之外，还有一些运算符可以对带&lt;em&gt;符号&lt;/em&gt;整数进行正式处理，但是将其参数视为&lt;em&gt;无符号&lt;/em&gt;：大多数情况下，提供它们是为了与该语言的较旧版本向后兼容缺少无符号整数类型。这些带符号整数的无符号运算使用 &lt;code&gt;%&lt;/code&gt; 后缀作为约定：</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">在对象类型的所有后代类型中。</target>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">在这两种情况下,服务器会启动并等待进一步的命令。现在你可以向服务器发送的命令的语法实际上和在命令行上运行nim编译器是一样的,你只需要去掉编译器的名字,因为你已经在和它说话了。服务器会用它认为必要的文字行数加上空行来回答,表示回答的结束。</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">与此相反，可以更自由地传递&lt;span id=&quot;closure-iterator_1&quot;&gt;闭包迭代器&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">在调试模式下,异常存储了导致它们的堆栈跟踪。一个StackTraceEntry是堆栈跟踪的单个条目。</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">在每次编译模块时,将变量重置为默认值。</target>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">事实上,每一个元组结构都允许使用尾部逗号。</target>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">实际上，这描述了AST应该如何作为&amp;ldquo;浅&amp;rdquo;树存储在数据库中。假设我们用以下内容编译模块 &lt;code&gt;m&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">一般来说,case语句用于子范围类型或枚举,它对编译器检查你是否覆盖了任何可能的值有很大帮助。</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">通常，声明类型反映了此语法（即，对于 &lt;code&gt;static&lt;/code&gt; 等，为 &lt;code&gt;nnkStaticTy&lt;/code&gt; ）。示例如下（带 &lt;code&gt;*&lt;/code&gt; 标记的例外）：</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">通常，导入动态库不需要任何特殊的链接器选项或与导入库链接。这也意味着不需要安装&lt;em&gt;devel&lt;/em&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">不过在非常特殊的情况下(例如字节码解释器的调度循环),它可能会带来好处。</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">在许多情况下，Nim允许您将类型的名称视为常规值。这些值仅在编译阶段存在，但是由于所有值都必须具有类型，因此将 &lt;code&gt;type&lt;/code&gt; 视为其特殊类型。</target>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">在正常的调试和发布版本中，将忽略 &lt;code&gt;runnableExamples&lt;/code&gt; 部分中的代码。</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">为了开始任何类型的文件传输，您必须首先连接到FTP服务器。您可以使用 &lt;code&gt;connect&lt;/code&gt; 过程进行操作。</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">为了检查符号是否接受 &lt;code&gt;type&lt;/code&gt; 参数，必须在类型前面加上显式的 &lt;code&gt;type&lt;/code&gt; 修饰符。类型的已命名实例（在 &lt;code&gt;concept&lt;/code&gt; 关键字之后）也被视为具有显式修饰符，并且仅作为类型进行匹配。</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">为了正确编译Nim,类型检查必须与解析分离。否则通用性就无法工作。</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">为了对一些文本进行编码，只需调用 &lt;code&gt;encode&lt;/code&gt; 过程：</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">为了简化结构类型检查,递归的元组是无效的。</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">为了使用此模块中定义的SSL过程，您将需要使用 &lt;code&gt;-d:ssl&lt;/code&gt; 标志来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">在普通的面向对象语言中，过程（也称为&lt;em&gt;方法&lt;/em&gt;）绑定到一个类。这有缺点：</target>
        </trans-unit>
        <trans-unit id="95f94a22baed9e59f27d8a4126864041ec912710" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite.</source>
          <target state="translated">换句话说， &lt;code&gt;result&lt;/code&gt; 指向的生命周期附加到第一个参数的生命周期，并且这是足够的知识来验证呼叫站点的内存安全性。</target>
        </trans-unit>
        <trans-unit id="102f6667e274b32df706ad020620d76cc4f12944" translate="yes" xml:space="preserve">
          <source>In other words, the macro needs to transform the full &lt;code&gt;case&lt;/code&gt; statement but only the statement's selector expression is used to determine which macro to call.</source>
          <target state="translated">换句话说，宏需要转换完整的 &lt;code&gt;case&lt;/code&gt; 语句，但是仅使用语句的选择器表达式来确定要调用哪个宏。</target>
        </trans-unit>
        <trans-unit id="f0ffdfd405410c78e024047ef7872e44df7c644e" translate="yes" xml:space="preserve">
          <source>In practice, things are worse still, consider &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt;. We only know the root is &lt;code&gt;someGlobal&lt;/code&gt; but the concrete path to the data is unknown as is the value that is added. We could compute a &quot;diff&quot; between the global states and use that to compute a symbol patchset, but this is quite some work, expensive to do at runtime (it would need to run after every module has been compiled) and also would break for hash tables.</source>
          <target state="translated">实际上，情况仍然更糟，请考虑 &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt; 。我们只知道根是 &lt;code&gt;someGlobal&lt;/code&gt; ,但是数据的具体路径以及所添加的值都是未知的。我们可以计算全局状态之间的&amp;ldquo;差异&amp;rdquo;，并使用它来计算符号补丁集，但这是相当多的工作，在运行时需要花费很多钱（它需要在编译完每个模块后运行），并且还会中断哈希表。</target>
        </trans-unit>
        <trans-unit id="b855cc2f2c105e6dd103557865ed5b380e3a2628" translate="yes" xml:space="preserve">
          <source>In raw literals the backslash is not an escape character.</source>
          <target state="translated">在生字中,反斜杠不是转义字。</target>
        </trans-unit>
        <trans-unit id="c7f10b9ab29ce16208f7daf440d19bf68a4e424e" translate="yes" xml:space="preserve">
          <source>In templates identifiers can be constructed with the backticks notation:</source>
          <target state="translated">在模板中,标识符可以用回标符号来构造。</target>
        </trans-unit>
        <trans-unit id="b2768586236fda36fbb8835c6640e3bbf9f72b7a" translate="yes" xml:space="preserve">
          <source>In the above example, because the string ends in a period, to get the portion of the string that is &quot;useless&quot; and replace it with &quot;useful&quot;.</source>
          <target state="translated">在上面的例子中,因为字符串以句号结束,所以要得到字符串中 &quot;无用 &quot;的部分,并用 &quot;有用 &quot;代替。</target>
        </trans-unit>
        <trans-unit id="1c735dfcff9ac999e211c2de3309c6b523627b0e" translate="yes" xml:space="preserve">
          <source>In the above example, providing the -d flag causes the symbol &lt;code&gt;FooBar&lt;/code&gt; to be overwritten at compile time, printing out 42. If the &lt;code&gt;-d:FooBar=42&lt;/code&gt; were to be omitted, the default value of 5 would be used.</source>
          <target state="translated">在上面的示例中，提供-d标志会使符号 &lt;code&gt;FooBar&lt;/code&gt; 在编译时被覆盖，打印出42。如果要省略 &lt;code&gt;-d:FooBar=42&lt;/code&gt; ，则将使用默认值5。</target>
        </trans-unit>
        <trans-unit id="6ef0c534b48c5ddbaf66e5a1fa0de3c409abe7be" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;recv&lt;/code&gt; function will return a brand new &lt;code&gt;Future&lt;/code&gt; instance once the request for data to be read from the socket is made. This &lt;code&gt;Future&lt;/code&gt; instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to &lt;code&gt;stdout&lt;/code&gt;. The &lt;code&gt;read&lt;/code&gt; function is used for this and it checks whether the future completes with an error for you (if it did it will simply raise the error), if there is no error however it returns the value of the future.</source>
          <target state="translated">在上面的示例中，一旦请求从套接字读取数据， &lt;code&gt;recv&lt;/code&gt; 函数将返回一个全新的 &lt;code&gt;Future&lt;/code&gt; 实例。读取请求的数据量后，此 &lt;code&gt;Future&lt;/code&gt; 实例将完成，在这种情况下为100字节。第二行在此未来上设置回调，一旦未来完成，将调用该回调。回调所做的只是将将来存储的数据写入 &lt;code&gt;stdout&lt;/code&gt; 。该 &lt;code&gt;read&lt;/code&gt; 功能被用于此，它检查是否有你的一个错误以后完成（如果它没有它只会引发错误），如果没有错误但它返回的未来价值。</target>
        </trans-unit>
        <trans-unit id="21c40f021cb3285301a10da6c518a7dfee56f66a" translate="yes" xml:space="preserve">
          <source>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</source>
          <target state="translated">在上面的例子中,搜索循环的展开因子为4。展开因子也可以不放,编译器会选择一个合适的展开因子。</target>
        </trans-unit>
        <trans-unit id="447fba0bf5092295ea3ef5df369d20395a2954e0" translate="yes" xml:space="preserve">
          <source>In the age of HTTP, HTML, FTP, TCP, IP, UTF, WWW it is foolish to pretend these are somewhat special words requiring all uppercase. Instead treat them as what they are: Real words. So it's &lt;code&gt;parseUrl&lt;/code&gt; rather than &lt;code&gt;parseURL&lt;/code&gt;, &lt;code&gt;checkHttpHeader&lt;/code&gt; instead of &lt;code&gt;checkHTTPHeader&lt;/code&gt; etc.</source>
          <target state="translated">在HTTP，HTML，FTP，TCP，IP，UTF，WWW时代，假装这些是需要全部大写的特殊单词是愚蠢的。而是将它们视作它们是什么：真实的单词。因此，它是 &lt;code&gt;parseUrl&lt;/code&gt; 而不是 &lt;code&gt;parseURL&lt;/code&gt; ， &lt;code&gt;checkHttpHeader&lt;/code&gt; 而不是 &lt;code&gt;checkHTTPHeader&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="1aaaccd5328576322733f4b1a0d0cfc0189406e9" translate="yes" xml:space="preserve">
          <source>In the case of Nim's own documentation, the &lt;code&gt;txt&lt;/code&gt; value is just a commit hash to append to a formatted URL to &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt;. The &lt;code&gt;tools/nimweb.nim&lt;/code&gt; helper queries the current git commit hash during doc generation, but since you might be working on an unpublished repository, it also allows specifying a &lt;code&gt;githash&lt;/code&gt; value in &lt;code&gt;web/website.ini&lt;/code&gt; to force a specific commit in the output.</source>
          <target state="translated">对于Nim自己的文档， &lt;code&gt;txt&lt;/code&gt; 值只是一个提交哈希，可以附加到&lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt;的格式化URL上。该 &lt;code&gt;tools/nimweb.nim&lt;/code&gt; 助手查询当前的git文档生成期间提交哈希值，但是因为你可能在一个未发布的库中工作，这也让指定 &lt;code&gt;githash&lt;/code&gt; 价值 &lt;code&gt;web/website.ini&lt;/code&gt; 强制输出特定的提交。</target>
        </trans-unit>
        <trans-unit id="222b18bf0bb9eca48a64b5eb7ba691094c380acc" translate="yes" xml:space="preserve">
          <source>In the current implementation &lt;code&gt;FloatDivByZeroError&lt;/code&gt; and &lt;code&gt;FloatInexactError&lt;/code&gt; are never raised. &lt;code&gt;FloatOverflowError&lt;/code&gt; is raised instead of &lt;code&gt;FloatDivByZeroError&lt;/code&gt;. There is also a &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt; pragma that is a short-cut for the combination of &lt;code&gt;nanChecks&lt;/code&gt; and &lt;code&gt;infChecks&lt;/code&gt; pragmas. &lt;code&gt;floatChecks&lt;/code&gt; are turned off as default.</source>
          <target state="translated">在当前实现中，永远不会引发 &lt;code&gt;FloatDivByZeroError&lt;/code&gt; 和 &lt;code&gt;FloatInexactError&lt;/code&gt; 。 &lt;code&gt;FloatOverflowError&lt;/code&gt; 而不是 &lt;code&gt;FloatDivByZeroError&lt;/code&gt; 。还有一个&lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt;编译指示，它是 &lt;code&gt;nanChecks&lt;/code&gt; 和 &lt;code&gt;infChecks&lt;/code&gt; 编译指示的组合的捷径。 &lt;code&gt;floatChecks&lt;/code&gt; 默认关闭。</target>
        </trans-unit>
        <trans-unit id="bff2144a51b7a2c294698601ad8d94335ce9f207" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;name&lt;/code&gt; is instantiated with &lt;code&gt;myint&lt;/code&gt;, so `T name` becomes &lt;code&gt;Tmyint&lt;/code&gt;.</source>
          <target state="translated">在示例中， &lt;code&gt;name&lt;/code&gt; 用 &lt;code&gt;myint&lt;/code&gt; 实例化，因此`T name`成为 &lt;code&gt;Tmyint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3d915c7fda05ffa880f1a94fe575c45d57c7e6" translate="yes" xml:space="preserve">
          <source>In the example a new pragma named &lt;code&gt;rtl&lt;/code&gt; is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</source>
          <target state="translated">在示例中，引入了一个名为 &lt;code&gt;rtl&lt;/code&gt; 的新编译指示，该编译指示从动态库中导入符号或导出该符号以用于动态库生成。</target>
        </trans-unit>
        <trans-unit id="93f65483d248fc770a9b18bebde69fbd09a74d5c" translate="yes" xml:space="preserve">
          <source>In the example a tree structure is declared with the &lt;code&gt;Node&lt;/code&gt; type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The &lt;code&gt;acyclic&lt;/code&gt; pragma passes the information that this cannot happen to the GC. If the programmer uses the &lt;code&gt;acyclic&lt;/code&gt; pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</source>
          <target state="translated">在示例中，使用 &lt;code&gt;Node&lt;/code&gt; 类型声明树结构。请注意，类型定义是递归的，GC必须假定这种类型的对象可以形成循环图。该 &lt;code&gt;acyclic&lt;/code&gt; 编译通过，这不能发生在GC的信息。如果程序员将 &lt;code&gt;acyclic&lt;/code&gt; 编译指示用于实际上是循环的数据类型，则GC可能会泄漏内存，但没有更糟的事情发生。</target>
        </trans-unit>
        <trans-unit id="c223baf4c7b9145e95ff7b9ff3609cc1168a5f2c" translate="yes" xml:space="preserve">
          <source>In the example c2nim treats the declaration of &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; as if it has been defined via &lt;code&gt;#def&lt;/code&gt;.</source>
          <target state="translated">在示例中，c2nim将 &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; 的声明视为已通过 &lt;code&gt;#def&lt;/code&gt; 进行了定义。</target>
        </trans-unit>
        <trans-unit id="4931fb24c88d4a3add48a67517bb1d6df1d7d83b" translate="yes" xml:space="preserve">
          <source>In the example the &lt;code&gt;kind&lt;/code&gt; field is called the &lt;span id=&quot;discriminator_1&quot;&gt;discriminator&lt;/span&gt;: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch &lt;code&gt;system.reset&lt;/code&gt; has to be used. Also, when the fields of a particular branch are specified during object construction, the correct value for the discriminator must be supplied at compile-time.</source>
          <target state="translated">在示例中， &lt;code&gt;kind&lt;/code&gt; 字段称为&lt;span id=&quot;discriminator_1&quot;&gt;鉴别符&lt;/span&gt;：为安全起见，不能采用其地址，并且对其的分配受到限制：新值一定不能导致活动对象分支的更改。对于对象分支交换机 &lt;code&gt;system.reset&lt;/code&gt; 必须使用。同样，当在对象构造期间指定了特定分支的字段时，必须在编译时提供鉴别符的正确值。</target>
        </trans-unit>
        <trans-unit id="f870d1827ccced8c4dc81fc21ba54ed53d3b7fa4" translate="yes" xml:space="preserve">
          <source>In the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because they should use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">在示例中，构造函数 &lt;code&gt;newLit&lt;/code&gt; 和 &lt;code&gt;newPlus&lt;/code&gt; 是proc，因为它们应该使用静态绑定，但是 &lt;code&gt;eval&lt;/code&gt; 是一种方法，因为它需要动态绑定。</target>
        </trans-unit>
        <trans-unit id="ffcf0c9fc73817d81ec1bb90e18296fae7f0e1e3" translate="yes" xml:space="preserve">
          <source>In the example the external name of &lt;code&gt;p&lt;/code&gt; is set to &lt;code&gt;prefixp&lt;/code&gt;. Only &lt;code&gt;$1&lt;/code&gt; is available and a literal dollar sign must be written as &lt;code&gt;$$&lt;/code&gt;.</source>
          <target state="translated">在示例中， &lt;code&gt;p&lt;/code&gt; 的外部名称设置为 &lt;code&gt;prefixp&lt;/code&gt; 。只有 &lt;code&gt;$1&lt;/code&gt; 可用，并且文字美元符号必须写为 &lt;code&gt;$$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207cdaa4265565920d4f81786bf2ce395e20de1e" translate="yes" xml:space="preserve">
          <source>In the example the generic &lt;code&gt;==&lt;/code&gt; for tuples (as defined in the system module) uses the &lt;code&gt;==&lt;/code&gt; operators of the tuple's components. However, the &lt;code&gt;==&lt;/code&gt; for the &lt;code&gt;Index&lt;/code&gt; type is defined &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;==&lt;/code&gt; for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</source>
          <target state="translated">在示例中，元组的通用 &lt;code&gt;==&lt;/code&gt; （在系统模块中定义）使用元组组件的 &lt;code&gt;==&lt;/code&gt; 运算符。然而， &lt;code&gt;==&lt;/code&gt; 为 &lt;code&gt;Index&lt;/code&gt; 型被定义&lt;em&gt;后&lt;/em&gt;的 &lt;code&gt;==&lt;/code&gt; 元组; 但是该示例在编译时也实例化了当前定义的符号。</target>
        </trans-unit>
        <trans-unit id="e3d09a6862f895be9685356eda8db42c91b15ade" translate="yes" xml:space="preserve">
          <source>In the example the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;body&lt;/code&gt; parameter. The &lt;code&gt;withFile&lt;/code&gt; template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the &lt;code&gt;let fn = filename&lt;/code&gt; statement ensures that &lt;code&gt;filename&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">在示例中，两个 &lt;code&gt;writeLine&lt;/code&gt; 语句绑定到 &lt;code&gt;body&lt;/code&gt; 参数。该 &lt;code&gt;withFile&lt;/code&gt; 模板包含样板代码，并有助于避免常见错误：忘记关闭文件。请注意 &lt;code&gt;let fn = filename&lt;/code&gt; 语句如何确保 &lt;code&gt;filename&lt;/code&gt; 仅被评估一次。</target>
        </trans-unit>
        <trans-unit id="6e573c188d155c097bab8635e952a84f3906a513" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.</source>
          <target state="translated">在此示例中， &lt;code&gt;res&lt;/code&gt; 和 &lt;code&gt;remainder&lt;/code&gt; 为&lt;em&gt;var参数&lt;/em&gt;。可以通过该过程修改Var参数，并且更改对调用者可见。请注意，上面的示例将更好地利用元组作为返回值，而不是使用var参数。</target>
        </trans-unit>
        <trans-unit id="e99258ef6102af84c3e85eb151f26d0965f922fd" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</source>
          <target state="translated">在此示例中， &lt;code&gt;res&lt;/code&gt; 和 &lt;code&gt;remainder&lt;/code&gt; 为&lt;em&gt;var参数&lt;/em&gt;。可以通过该过程修改Var参数，并且更改对调用者可见。传递给var参数的参数必须为l值。Var参数实现为隐藏的指针。上面的示例等效于：</target>
        </trans-unit>
        <trans-unit id="2ce83aae39fe686c17231fc96b454e933bdbf835" translate="yes" xml:space="preserve">
          <source>In the example, the case branches &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</source>
          <target state="translated">在该示例中，案例分支 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 比其他案例更为常见。因此，生成的汇编代码应首先测试这些值，以便CPU的分支预测器有很大的机会成功（避免昂贵的CPU管道停顿）。其他情况可能会放入O（1）开销的跳转表中，但会（非常可能）导致管道停顿。</target>
        </trans-unit>
        <trans-unit id="449891737730fed7e4e9e268f5440bde8cd00a54" translate="yes" xml:space="preserve">
          <source>In the example, the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;actions&lt;/code&gt; parameter.</source>
          <target state="translated">在示例中，两个 &lt;code&gt;writeLine&lt;/code&gt; 语句绑定到 &lt;code&gt;actions&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="05f29e9409204f7156a8b49a6edfe66f0ff90993" translate="yes" xml:space="preserve">
          <source>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</source>
          <target state="translated">在这些例子中,var参数或指针被用来提供两个返回值。这可以通过返回一个元组的方式来实现。</target>
        </trans-unit>
        <trans-unit id="cf1b069c247f4187c31c21ebbe40e040b094bad5" translate="yes" xml:space="preserve">
          <source>In the following sections &lt;em&gt;global&lt;/em&gt; means &lt;em&gt;shared between modules&lt;/em&gt; or &lt;em&gt;property of the whole program&lt;/em&gt;.</source>
          <target state="translated">在以下各节中，&lt;em&gt;全局&lt;/em&gt;表示&lt;em&gt;在整个程序的&lt;/em&gt;&lt;em&gt;模块&lt;/em&gt;或&lt;em&gt;属性&lt;/em&gt;&lt;em&gt;之间共享&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f42fa9bad92a4bca57282426b4b7870e70495fb5" translate="yes" xml:space="preserve">
          <source>In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</source>
          <target state="translated">在前面的例子中,分片是用来修改字符串的一部分。分片的边界可以容纳其类型所支持的任何值,但使用分片对象的 proc 定义了接受的值。</target>
        </trans-unit>
        <trans-unit id="d9143e669402c29ee0475ca379b33b947a4800d5" translate="yes" xml:space="preserve">
          <source>In the previous sections the &lt;code&gt;NimMain()&lt;/code&gt; function reared its head. Since JavaScript already provides automatic memory management, you can freely pass objects between the two language without problems. In C and derivate languages you need to be careful about what you do and how you share memory. The previous examples only dealt with simple scalar values, but passing a Nim string to C, or reading back a C string in Nim already requires you to be aware of who controls what to avoid crashing.</source>
          <target state="translated">在前面的部分中， &lt;code&gt;NimMain()&lt;/code&gt; 函数抬起了头。由于JavaScript已经提供了自动内存管理，因此您可以在两种语言之间自由地传递对象，而不会出现问题。在C语言和派生语言中，您需要注意自己的工作方式和共享内存的方式。前面的示例仅处理简单的标量值，但是将Nim字符串传递给C或在Nim中读回C字符串已经要求您知道谁控制什么来避免崩溃。</target>
        </trans-unit>
        <trans-unit id="1678b121aeb51003f37c84a3a8b55dda38dde0ae" translate="yes" xml:space="preserve">
          <source>In the standard library every name of a routine that returns a &lt;code&gt;var&lt;/code&gt; type starts with the prefix &lt;code&gt;m&lt;/code&gt; per convention.</source>
          <target state="translated">在标准库中，根据惯例，返回 &lt;code&gt;var&lt;/code&gt; 类型的例程的每个名称都以前缀 &lt;code&gt;m&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="3573423166a3714205c4fd8df064a462e9f793fc" translate="yes" xml:space="preserve">
          <source>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</source>
          <target state="translated">在此上下文中,行是由换行组合隔开的任何字符串。一个行可以是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="f0c0be54e609e08ad5ac67f5c3b4c12362798deb" translate="yes" xml:space="preserve">
          <source>In this example &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. Note that &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; applied to strings is a nop.</source>
          <target state="translated">在此示例中，&lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt;应用于传递给参数 &lt;code&gt;a&lt;/code&gt; 的任何参数。请注意，应用于字符串的&lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt;是nop。</target>
        </trans-unit>
        <trans-unit id="cd49a3b7329e865d00fe88035f180e3a31be031d" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;$&lt;/code&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. (Note that &lt;code&gt;$&lt;/code&gt; applied to strings is a nop.)</source>
          <target state="translated">在此示例中， &lt;code&gt;$&lt;/code&gt; 应用于传递给参数 &lt;code&gt;a&lt;/code&gt; 的任何参数。（请注意，应用于字符串的 &lt;code&gt;$&lt;/code&gt; 是nop。）</target>
        </trans-unit>
        <trans-unit id="caf41cefb1ec542e92b76fcef06da5301961d50c" translate="yes" xml:space="preserve">
          <source>In this example both macros are combined seamlessly in order to maximise efficiency and perform different checks.</source>
          <target state="translated">在这个例子中,为了最大限度地提高效率,两个宏都是无缝结合,并执行不同的检查。</target>
        </trans-unit>
        <trans-unit id="fbd15640684b666f33817b98a57e6ad3f6b44475" translate="yes" xml:space="preserve">
          <source>In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.</source>
          <target state="translated">在这个例子中,自定义模式用于描述如何将Nim对象映射到关系数据库的模式。自定义模式可以有零个或多个参数。为了传递多个参数,请使用模板调用语法之一。所有的参数都是类型化的,并且遵循模板的标准重载解析规则。因此,可以为参数设置默认值,通过名称、varargs等方式传递。</target>
        </trans-unit>
        <trans-unit id="664c924f4e9ba31a6bee85a98d981b31c47a324a" translate="yes" xml:space="preserve">
          <source>In this example, we define a helper proc &lt;code&gt;someSep&lt;/code&gt; that skips some separators which we then use in our scanf pattern to help us in the matching process:</source>
          <target state="translated">在此示例中，我们定义了一个辅助过程proc &lt;code&gt;someSep&lt;/code&gt; ，该过程跳过了一些分隔符，这些分隔符随后在scanf模式中使用以帮助我们进行匹配过程：</target>
        </trans-unit>
        <trans-unit id="534570485c11beb7704f319727846b8b4f022eb5" translate="yes" xml:space="preserve">
          <source>Include statement</source>
          <target state="translated">包括声明</target>
        </trans-unit>
        <trans-unit id="bbc642ae58ad84741186ba01bd7a4f6256a9bccf" translate="yes" xml:space="preserve">
          <source>Includes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was added to &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">包括&lt;em&gt;键&lt;/em&gt;在设置&lt;em&gt;小号&lt;/em&gt;，如果告诉&lt;em&gt;键&lt;/em&gt;加入&lt;em&gt;小号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="64f932923a0eaeac8401c0d332e7ec2bbdcdc32c" translate="yes" xml:space="preserve">
          <source>Includes all elements from &lt;em&gt;other&lt;/em&gt; into &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;其他&lt;/em&gt;所有元素都包含到&lt;em&gt;s中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9a1bf1db1ba56c9fed3c108674752a59dfcd9da4" translate="yes" xml:space="preserve">
          <source>Includes an element &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;s中&lt;/em&gt;包含一个元素&lt;em&gt;键&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="122d72fb5f4934f490f955173c3eef92832e3bcb" translate="yes" xml:space="preserve">
          <source>IncompleteStruct pragma</source>
          <target state="translated">IncompleteStruct pragma</target>
        </trans-unit>
        <trans-unit id="e458e98e024804e2195312b10a3a11a67d6582fd" translate="yes" xml:space="preserve">
          <source>Increments an ordinal</source>
          <target state="translated">递增一个序数</target>
        </trans-unit>
        <trans-unit id="3579152b0f13082bc2ed763d516b6eeee04f5e41" translate="yes" xml:space="preserve">
          <source>Increments in place a floating point number</source>
          <target state="translated">以浮点数递增。</target>
        </trans-unit>
        <trans-unit id="3917b825256b71ec29e2860d96b9f3c57a46e2bf" translate="yes" xml:space="preserve">
          <source>Indent with two spaces.</source>
          <target state="translated">缩进两个空格。</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="3e69016e62b22706518f7fd44403f71f6f86a464" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;const&lt;/code&gt; keyword to list a whole section of constants:</source>
          <target state="translated">可以在 &lt;code&gt;const&lt;/code&gt; 关键字之后使用缩进来列出整个常量部分：</target>
        </trans-unit>
        <trans-unit id="6f45c825c4626280194b953ea0dec3e48ce7fccc" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;var&lt;/code&gt; keyword to list a whole section of variables:</source>
          <target state="translated">可以在 &lt;code&gt;var&lt;/code&gt; 关键字之后使用缩进来列出变量的整个部分：</target>
        </trans-unit>
        <trans-unit id="520792c3a2538ee8e56f0b4f71803ca37955634d" translate="yes" xml:space="preserve">
          <source>Indents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">缩进在每行 &lt;code&gt;s&lt;/code&gt; 通过 &lt;code&gt;count&lt;/code&gt; 的量 &lt;code&gt;padding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="f2171e3002af9c53c4ea2469894d127d907cca3e" translate="yes" xml:space="preserve">
          <source>Index (idx) file format</source>
          <target state="translated">索引(idx)文件格式</target>
        </trans-unit>
        <trans-unit id="7086b5dce7145d779101ccd8901d9bbb698cae3d" translate="yes" xml:space="preserve">
          <source>Index files are line oriented and tab separated (newline and tab characters have to be escaped). Each line represents a record with at least two fields, but can have up to four (additional columns are ignored). The content of these columns is:</source>
          <target state="translated">索引文件是面向行和制表符分开的(换行和制表符必须被转义)。每一行代表一条记录,至少有两个字段,但最多可以有四个字段(额外的列会被忽略)。这些列的内容是:</target>
        </trans-unit>
        <trans-unit id="0c5d6204871842ba1c9f7cd8b0f7f94f787509f2" translate="yes" xml:space="preserve">
          <source>Index switch</source>
          <target state="translated">索引开关</target>
        </trans-unit>
        <trans-unit id="7d2d080b9c23631882a620ee4cef31b37b3e5e98" translate="yes" xml:space="preserve">
          <source>Index the collection with the proc provided.</source>
          <target state="translated">用所提供的proc对集合进行索引。</target>
        </trans-unit>
        <trans-unit id="9b0343473193cfc7e99b7802a4d65dded5509d30" translate="yes" xml:space="preserve">
          <source>Indicates that a leading space should be used on positive numbers.</source>
          <target state="translated">表示在正数上应使用前导空格。</target>
        </trans-unit>
        <trans-unit id="2c549fa4a0ba269a959c6226777ab5a0b50f1df5" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used for both positive as well as negative numbers.</source>
          <target state="translated">表示正数和负数都要用符号。</target>
        </trans-unit>
        <trans-unit id="a0c8cf09bdbe9d14558c3f28be789e07866609de" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used only for negative numbers (this is the default behavior).</source>
          <target state="translated">表示符号只能用于负数(这是默认行为)。</target>
        </trans-unit>
        <trans-unit id="02d4b08a1673b232bf3018ee2f9d0a8e9fa2025c" translate="yes" xml:space="preserve">
          <source>Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.</source>
          <target state="translated">不精确:操作产生的结果不能用无限精度表示,例如,2.0/3.0,log(1.1)和0.1的输入。</target>
        </trans-unit>
        <trans-unit id="63d5b176942ca6a8ddb9add205f21b0d98945888" translate="yes" xml:space="preserve">
          <source>Infix operator call</source>
          <target state="translated">Infix操作员呼叫</target>
        </trans-unit>
        <trans-unit id="eb712e4e263d88043891e59382c4f31c8c4157de" translate="yes" xml:space="preserve">
          <source>Inheritance is done with the &lt;code&gt;object of&lt;/code&gt; syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, &lt;code&gt;RootObj&lt;/code&gt; can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt;. You can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;. (This is used in the GTK wrapper for instance.)</source>
          <target state="translated">继承是通过语法 &lt;code&gt;object of&lt;/code&gt; 完成的。当前不支持多重继承。如果对象类型没有合适的祖先， &lt;code&gt;RootObj&lt;/code&gt; 可以将RootObj用作其祖先，但这只是一个约定。没有祖先的对象隐式为 &lt;code&gt;final&lt;/code&gt; 。除了 &lt;code&gt;system.RootObj&lt;/code&gt; 之外，还可以使用 &lt;code&gt;inheritable&lt;/code&gt; 编译指示引入新的对象根。（例如，在GTK包装器中使用。）</target>
        </trans-unit>
        <trans-unit id="862fae5c64569c192f0058ccd3bbb5d19a019f65" translate="yes" xml:space="preserve">
          <source>Inhibit dynamic method resolution via procCall</source>
          <target state="translated">通过procCall抑制动态方法解析</target>
        </trans-unit>
        <trans-unit id="5c4f1d9bb4b4c00271c428db76888f539a5526ec" translate="yes" xml:space="preserve">
          <source>Init procs must not be &quot;forgotten&quot; to be called.</source>
          <target state="translated">Init procs不能被 &quot;忘记 &quot;调用。</target>
        </trans-unit>
        <trans-unit id="e0133811d52fc5e0ce7548998427d86c5ecbabc3" translate="yes" xml:space="preserve">
          <source>Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised.</source>
          <target state="translated">初始化一个AsyncSocket对象。如果一个套接字不能被初始化,EOS会被引发。</target>
        </trans-unit>
        <trans-unit id="0e8796999c73166ae179e51a98cc0d932f6227e2" translate="yes" xml:space="preserve">
          <source>Initialize SSL using OPENSSL_init_ssl for OpenSSL &amp;gt;= 1.1.0 otherwise SSL_library_init</source>
          <target state="translated">使用OpenSSL&amp;gt; = 1.1.0的OPENSSL_init_ssl初始化SSL，否则使用SSL_library_init</target>
        </trans-unit>
        <trans-unit id="881e0294c3d407bde48feb8c4affbeeef0f33574" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RstGenerator&lt;/code&gt;.</source>
          <target state="translated">初始化 &lt;code&gt;RstGenerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40151f2c3d201480764280228665dd4a245cb8ae" translate="yes" xml:space="preserve">
          <source>Initializes a URI.</source>
          <target state="translated">初始化一个URI。</target>
        </trans-unit>
        <trans-unit id="405224e088cd409637c05da8068dcfb0b7324f95" translate="yes" xml:space="preserve">
          <source>Initializes a hash set.</source>
          <target state="translated">初始化一个哈希集。</target>
        </trans-unit>
        <trans-unit id="e84a4c040ee7b5e4ea1966bc93e94a695c273213" translate="yes" xml:space="preserve">
          <source>Initializes an ordered hash set.</source>
          <target state="translated">初始化一个有序的哈希集。</target>
        </trans-unit>
        <trans-unit id="580bcf0259f858c591c1bdfb9fe2dbcc9bf29a6d" translate="yes" xml:space="preserve">
          <source>Initializes the default random number generator with a specific seed.</source>
          <target state="translated">用一个特定的种子初始化默认的随机数发生器。</target>
        </trans-unit>
        <trans-unit id="dacee3e957999d4c882a7ef1c7b8e6793e30746e" translate="yes" xml:space="preserve">
          <source>Initializes the given condition variable.</source>
          <target state="translated">初始化给定的条件变量。</target>
        </trans-unit>
        <trans-unit id="0f32d11dbd1ff544f08160af91e946d34a75cd48" translate="yes" xml:space="preserve">
          <source>Initializes the given lock.</source>
          <target state="translated">初始化给定的锁。</target>
        </trans-unit>
        <trans-unit id="6ede6304ec6e7bf4a6a2e3d80c6b1eeb81cc73f8" translate="yes" xml:space="preserve">
          <source>Initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. Note: Does not work for NimScript.</source>
          <target state="translated">用一个 &quot;随机 &quot;数初始化随机数生成器,即 tickcount。注意:不适用于NimScript。</target>
        </trans-unit>
        <trans-unit id="7656a50f2e0ac5db2e06ce5648c4594fc345f831" translate="yes" xml:space="preserve">
          <source>InjectStmt pragma</source>
          <target state="translated">InjectStmt pragma</target>
        </trans-unit>
        <trans-unit id="1ee7de66fcff05572c93c829536da75cc7683b42" translate="yes" xml:space="preserve">
          <source>Input flags.</source>
          <target state="translated">输入标志。</target>
        </trans-unit>
        <trans-unit id="f9e1ac91d7701d8e495d0f11ba5f1b00fdf6ed7f" translate="yes" xml:space="preserve">
          <source>Insert node B into A at pos</source>
          <target state="translated">将节点B插入A的位置</target>
        </trans-unit>
        <trans-unit id="2db3b3fd15b7bb4b34dad30c689dad9d16b24896" translate="yes" xml:space="preserve">
          <source>Inserting data</source>
          <target state="translated">插入数据</target>
        </trans-unit>
        <trans-unit id="dd923f823166b6196d06cbdd3db676002c784b17" translate="yes" xml:space="preserve">
          <source>Inserts items from &lt;em&gt;src&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt; at position &lt;em&gt;pos&lt;/em&gt;. This modifies &lt;em&gt;dest&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">将&lt;em&gt;src中的&lt;/em&gt;项目插入&lt;em&gt;dest&lt;/em&gt;位置&lt;em&gt;pos处&lt;/em&gt;。这将修改&lt;em&gt;dest&lt;/em&gt;本身，而不返回副本。</target>
        </trans-unit>
        <trans-unit id="04298198949aebc6d2892e5fc955264070b8ebb9" translate="yes" xml:space="preserve">
          <source>Inserts the node &lt;code&gt;newChild&lt;/code&gt; before the existing child node &lt;code&gt;refChild&lt;/code&gt;. If &lt;code&gt;refChild&lt;/code&gt; is nil, insert &lt;code&gt;newChild&lt;/code&gt; at the end of the list of children.</source>
          <target state="translated">插入节点 &lt;code&gt;newChild&lt;/code&gt; 对象现有的子节点之前 &lt;code&gt;refChild&lt;/code&gt; 。如果 &lt;code&gt;refChild&lt;/code&gt; 是零，插入 &lt;code&gt;newChild&lt;/code&gt; 对象在孩子的列表的末尾。</target>
        </trans-unit>
        <trans-unit id="786ea42ccb1f6bb0efafd8f2b61725cd22b7b01c" translate="yes" xml:space="preserve">
          <source>Inserts the separator &lt;em&gt;sep&lt;/em&gt; after &lt;em&gt;digits&lt;/em&gt; digits from right to left.</source>
          <target state="translated">在从右到左的&lt;em&gt;数字&lt;/em&gt;位后面插入分隔符&lt;em&gt;sep&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="873af15bd68c477178748ca072cfddf8b2be43af" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">在一个字符类内,或者如果十进制数大于9,并且没有那么多的捕获子模式,PCRE会在反斜杠后重新读取最多3个八进制数,并从值的最小有意义的8位生成一个字节。任何后续的数字都是自成一格的。例如</target>
        </trans-unit>
        <trans-unit id="ca77b6367a8fe2f8a03241e2199780113a61f688" translate="yes" xml:space="preserve">
          <source>Inside asynchronous procedures &lt;code&gt;await&lt;/code&gt; can be used to call any procedures which return a &lt;code&gt;Future&lt;/code&gt;; this includes asynchronous procedures. When a procedure is &quot;awaited&quot;, the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</source>
          <target state="translated">内部异步过程 &lt;code&gt;await&lt;/code&gt; 可以用来调用任何返回 &lt;code&gt;Future&lt;/code&gt; 的过程；这包括异步过程。当&amp;ldquo;等待&amp;rdquo;过程时，等待它的异步过程将暂停其执行，直到等待过程的Future完成。此时异步过程将继续执行。在异步过程暂停期间，调度程序将运行其他异步过程。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="58445a9dc8fa874d6c0999c2be877243221f8374" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;#@ @#&lt;/code&gt; Nim's pragma brackets &lt;code&gt;{. .}&lt;/code&gt; can also be used, but not nested since the &lt;code&gt;.}&lt;/code&gt; doesn't have to be on a line of its own:</source>
          <target state="translated">而不是 &lt;code&gt;#@ @#&lt;/code&gt; Nim的实用括号 &lt;code&gt;{. .}&lt;/code&gt; 也可以使用。}，但不能嵌套使用，因为 &lt;code&gt;.}&lt;/code&gt; 不必自己一行：</target>
        </trans-unit>
        <trans-unit id="ed085b50e598c9e9c3c998d8d02d824b13f51bfb" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;self&lt;/code&gt; any other identifier can be used too, but &lt;code&gt;{.this: self.}&lt;/code&gt; will become the default directive for the whole language eventually.</source>
          <target state="translated">除了 &lt;code&gt;self&lt;/code&gt; 以外，还可以使用其他任何标识符，但是 &lt;code&gt;{.this: self.}&lt;/code&gt; 最终将成为整个语言的默认指令。</target>
        </trans-unit>
        <trans-unit id="5150cf2c23ac3058436fce11d312cb4ab7dd9726" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;code&gt;try finally&lt;/code&gt; statement a &lt;code&gt;defer&lt;/code&gt; statement can be used.</source>
          <target state="translated">代替的 &lt;code&gt;try finally&lt;/code&gt; 语句中的 &lt;code&gt;defer&lt;/code&gt; 可以使用的语句。</target>
        </trans-unit>
        <trans-unit id="03665382599317cc60a7efd5af43d25b36a35438" translate="yes" xml:space="preserve">
          <source>Instead of depending on the generation of the individual &lt;code&gt;.c&lt;/code&gt; files you can also ask the Nim compiler to generate a statically linked library:</source>
          <target state="translated">除了依赖于各个 &lt;code&gt;.c&lt;/code&gt; 文件的生成之外，您还可以要求Nim编译器生成一个静态链接的库：</target>
        </trans-unit>
        <trans-unit id="ff60c5d0007a18ea981f49f0360da2385ccc4565" translate="yes" xml:space="preserve">
          <source>Instead of keeping 2 versions of &lt;code&gt;define foo&lt;/code&gt; around, one &lt;code&gt;#def foo&lt;/code&gt; for c2nim and one ordinary &lt;code&gt;#define foo&lt;/code&gt; for C/C++, it is often more convenient to tell c2nim that &lt;code&gt;foo&lt;/code&gt; is to be interpreted as a &lt;code&gt;#def&lt;/code&gt;. This is what the &lt;code&gt;#pp&lt;/code&gt; directive accomplishes:</source>
          <target state="translated">与其保留两个版本的 &lt;code&gt;define foo&lt;/code&gt; ，而不是一个 &lt;code&gt;#def foo&lt;/code&gt; 和一个用于C / C ++的普通的 &lt;code&gt;#define foo&lt;/code&gt; ，通常更方便的是告诉c2nim &lt;code&gt;foo&lt;/code&gt; 被解释为 &lt;code&gt;#def&lt;/code&gt; 。这是 &lt;code&gt;#pp&lt;/code&gt; 指令完成的工作：</target>
        </trans-unit>
        <trans-unit id="c7301e8180a639fec5b0ce81d171622b155df52d" translate="yes" xml:space="preserve">
          <source>Instead of removing &lt;code&gt;EXTERN()&lt;/code&gt; from the input source file (which cannot be done reliably even with a regular expression!), one can tell c2nim that &lt;code&gt;EXTERN&lt;/code&gt; is a macro that should be expanded by c2nim too:</source>
          <target state="translated">不必从输入源文件中删除 &lt;code&gt;EXTERN()&lt;/code&gt; （即使使用正则表达式也无法可靠地完成！），您可以告诉c2nim &lt;code&gt;EXTERN&lt;/code&gt; 是也应由c2nim扩展的宏：</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="84737859654b67b2b9a33e5c2db83b51683c5344" translate="yes" xml:space="preserve">
          <source>Instead this code has to be used:</source>
          <target state="translated">而是要用这个代码。</target>
        </trans-unit>
        <trans-unit id="ec54b2dcce7fd1b6d6a547c96c19205ad88a3d5d" translate="yes" xml:space="preserve">
          <source>Int values of &lt;em&gt;x&lt;/em&gt; are simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x的&lt;/em&gt; int值被简单地转换为 &lt;code&gt;float&lt;/code&gt; ,并且调用了另一个push操作。</target>
        </trans-unit>
        <trans-unit id="2adc71fa12ee88a61833caad8062097e6410346c" translate="yes" xml:space="preserve">
          <source>Integer division for durations.</source>
          <target state="translated">期限的整数除法。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="584a126c172b3ef1ff0c69307f68a5ebdd0d1d09" translate="yes" xml:space="preserve">
          <source>Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types &lt;code&gt;uint&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; are not ordinal types.</source>
          <target state="translated">整数，布尔，字符和枚举类型（以及这些类型的子范围）属于序数类型。为了简化实现， &lt;code&gt;uint&lt;/code&gt; 和 &lt;code&gt;uint64&lt;/code&gt; 类型不是序数类型。</target>
        </trans-unit>
        <trans-unit id="90c35cf1c7e9e4b6aa47b681a51fc9aa23f2f3de" translate="yes" xml:space="preserve">
          <source>Integral conversion match: &lt;code&gt;a&lt;/code&gt; is convertible to &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is some integer or floating point type.</source>
          <target state="translated">整数转换匹配： &lt;code&gt;a&lt;/code&gt; 可以转换为 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; ,而 &lt;code&gt;a&lt;/code&gt; 是某种整数或浮点类型。</target>
        </trans-unit>
        <trans-unit id="2cea7df8891dd1065020c3b86bf5bf912b6baca2" translate="yes" xml:space="preserve">
          <source>Interfacing</source>
          <target state="translated">Interfacing</target>
        </trans-unit>
        <trans-unit id="a954e42be7d65d0d68df6c2475675a3e2ab46fae" translate="yes" xml:space="preserve">
          <source>Internal documentation</source>
          <target state="translated">内部文件</target>
        </trans-unit>
        <trans-unit id="6be940d65e52db18b5d8edc969f415c8720649fa" translate="yes" xml:space="preserve">
          <source>Internal type representation</source>
          <target state="translated">内部类型表示</target>
        </trans-unit>
        <trans-unit id="664fc2f86af06c6988fa72f769d3e17fcd2731e8" translate="yes" xml:space="preserve">
          <source>Internally, we want mustRehash(rightSize(x), x) == false.</source>
          <target state="translated">在内部,我们希望 mustRehash(rightSize(x),x)==false。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2938da18cdb579e62b1141f39929cc36fdc8e917" translate="yes" xml:space="preserve">
          <source>Internals of the Nim Compiler</source>
          <target state="translated">Nim编译器的内部结构</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">互联网协议和支持</target>
        </trans-unit>
        <trans-unit id="c77102105a7e484189908c6c3aaa8b4fde6d5bd4" translate="yes" xml:space="preserve">
          <source>Interpolates a format string with the values from &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">插值格式字符串从值&lt;em&gt;一&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1a2e25ef70924b9dc72d6e9cae42a42464d5c3ae" translate="yes" xml:space="preserve">
          <source>Invalid SQL encountered</source>
          <target state="translated">遇到无效的SQL</target>
        </trans-unit>
        <trans-unit id="3579c51a9cfa004f6051766e66c67a34af9f5d6d" translate="yes" xml:space="preserve">
          <source>Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).</source>
          <target state="translated">无效:操作数在数学上无效的操作,例如0.0/0.0、sqrt(-1.0)和log(-37.8)。</target>
        </trans-unit>
        <trans-unit id="e0c13b2efd4e2d6dec9f73473d4c5e30f853cc74" translate="yes" xml:space="preserve">
          <source>Invocation context</source>
          <target state="translated">调用背景</target>
        </trans-unit>
        <trans-unit id="45e47edcb41b8a29e3a098022eba6bd2db5b9ca3" translate="yes" xml:space="preserve">
          <source>Invocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">多方法的调用不能是模棱两可的：碰撞2优于碰撞1，因为分辨率从左到右起作用。在示例 &lt;code&gt;Unit, Thing&lt;/code&gt; 优于 &lt;code&gt;Thing, Unit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="a8f35cc2588d6df7883512e310eaf3cfe55f22b5" translate="yes" xml:space="preserve">
          <source>Is operator</source>
          <target state="translated">是运营商</target>
        </trans-unit>
        <trans-unit id="3bcc962b75eed7b2e391c690e8701aa2754af2d5" translate="yes" xml:space="preserve">
          <source>Is rewritten to:</source>
          <target state="translated">是改写为:</target>
        </trans-unit>
        <trans-unit id="41e7fee403015340d1195de277c32fe1acf8a866" translate="yes" xml:space="preserve">
          <source>Is short for:</source>
          <target state="translated">是简称。</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">是与。</target>
        </trans-unit>
        <trans-unit id="ae0bcdcfc983072ff2e5010acbd964825c34f849" translate="yes" xml:space="preserve">
          <source>Is translated into:</source>
          <target state="translated">被翻译成。</target>
        </trans-unit>
        <trans-unit id="6f20666fec7d3538d857abddfabb7eb0323d351c" translate="yes" xml:space="preserve">
          <source>Is translated to:</source>
          <target state="translated">被翻译成:</target>
        </trans-unit>
        <trans-unit id="90d19d41b3a53b1379c3459c0faab9f64cca3759" translate="yes" xml:space="preserve">
          <source>It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake_style, and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like &lt;code&gt;var foo: Foo&lt;/code&gt; to be parsed unambiguously.</source>
          <target state="translated">它允许程序员主要使用自己喜欢的拼写样式（无论是humpStyle还是snake_style），并且由不同程序员编写的库不能使用不兼容的约定。Nim感知编辑器或IDE可以将标识符显示为首选。另一个优点是它使程序员不必记住标识符的确切拼写。关于第一个字母的例外允许诸如 &lt;code&gt;var foo: Foo&lt;/code&gt; 这样的通用代码被明确地解析。</target>
        </trans-unit>
        <trans-unit id="2fe9d58777a4819a056f680773675b458bc59f43" translate="yes" xml:space="preserve">
          <source>It also possible to pass arguments to a user definable matcher:</source>
          <target state="translated">也可以将参数传递给用户定义的匹配器。</target>
        </trans-unit>
        <trans-unit id="4b2feef416362147669a39cf0c612de62bb2d19e" translate="yes" xml:space="preserve">
          <source>It also provides some fast iterators over lines in text files (or other &quot;line-like&quot;, variable length, delimited records).</source>
          <target state="translated">它还提供了一些快速迭代文本文件中的行(或其他 &quot;类似行 &quot;的、可变长度、定界记录)。</target>
        </trans-unit>
        <trans-unit id="dff3ae584541038e537e5a342c1930160c45bf0a" translate="yes" xml:space="preserve">
          <source>It can also be used when defines are being referred to, as c2nim currently does not expand defines:</source>
          <target state="translated">它也可以在引用定义时使用,因为c2nim目前没有扩展定义。</target>
        </trans-unit>
        <trans-unit id="f0075f000dd30ff460292c5c1bbbe6ad98332e6c" translate="yes" xml:space="preserve">
          <source>It can be used to parse a wild HTML document and output it as valid XHTML document (well, if you are lucky):</source>
          <target state="translated">它可以用来解析一个野生的HTML文档,并将其输出为有效的XHTML文档(如果你幸运的话)。</target>
        </trans-unit>
        <trans-unit id="589d528fa76550fcfe67d75a7cc3b724508c0925" translate="yes" xml:space="preserve">
          <source>It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:</source>
          <target state="translated">用一元钱乘一元钱,而用没有单位的数乘一元钱,是没有意义的;除法也是如此。</target>
        </trans-unit>
        <trans-unit id="c9187f5ee38c2d68fe98474af10e0521e2ff318b" translate="yes" xml:space="preserve">
          <source>It helps to think that the iterator actually returns a pair &lt;code&gt;(value, done)&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; is used to access the hidden &lt;code&gt;done&lt;/code&gt; field.</source>
          <target state="translated">可以认为迭代器实际上返回了一个对 &lt;code&gt;(value, done)&lt;/code&gt; ， &lt;code&gt;finished&lt;/code&gt; 用于访问隐藏的 &lt;code&gt;done&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="b7934ea36bb3abaeb6de1ae68617ee4fa3e89f7c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; safe to disable the garbage collector and enable it after the call from your background thread even if the code you are calling is short lived.</source>
          <target state="translated">它是&lt;strong&gt;不是&lt;/strong&gt;安全禁用垃圾收集器，并从你的后台线程调用，即使你是调用代码短命后启用它。</target>
        </trans-unit>
        <trans-unit id="0ce32c42207b074e8614eb82e24a7a71033a751d" translate="yes" xml:space="preserve">
          <source>It is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</source>
          <target state="translated">如果隐式引入的指针可以被用来访问一个超过其寿命的位置,这是一个编译时错误。</target>
        </trans-unit>
        <trans-unit id="654b26d139effb1815e88b12fee61a0a858572c0" translate="yes" xml:space="preserve">
          <source>It is also important that the replay involves the &lt;code&gt;import&lt;/code&gt; statement so that the dependencies are resolved properly.</source>
          <target state="translated">重播涉及 &lt;code&gt;import&lt;/code&gt; 语句，以便正确解决依赖关系也很重要。</target>
        </trans-unit>
        <trans-unit id="2d729a9913be11aee103dc8aea1b73a4c4edcc41" translate="yes" xml:space="preserve">
          <source>It is an essential property of abstract types that they &lt;strong&gt;do not&lt;/strong&gt; imply a subtype relation between the abstract type and its base type. Explicit type conversions from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;SQL&lt;/code&gt; are allowed:</source>
          <target state="translated">抽象类型的本质属性是它们&lt;strong&gt;不&lt;/strong&gt;暗示抽象类型与其基本类型之间存在子类型关系。允许从 &lt;code&gt;string&lt;/code&gt; 到 &lt;code&gt;SQL&lt;/code&gt; 的显式类型转换：</target>
        </trans-unit>
        <trans-unit id="3e31fcf4a46656a66279b459e1a0815babbcc226" translate="yes" xml:space="preserve">
          <source>It is important to note that reordering &lt;em&gt;only&lt;/em&gt; works for symbols at top level scope. Therefore, the following will &lt;em&gt;fail to compile:&lt;/em&gt;</source>
          <target state="translated">请务必注意，重新排序&lt;em&gt;仅&lt;/em&gt;适用于顶级范围的符号。因此，以下将&lt;em&gt;无法编译：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eccab016e9c85070b264d0771a05edb52b43822b" translate="yes" xml:space="preserve">
          <source>It is not checked that the &lt;code&gt;except&lt;/code&gt; list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</source>
          <target state="translated">不检查是否确实从模块中导出了 &lt;code&gt;except&lt;/code&gt; 列表。此功能允许针对不导出这些标识符的较旧版本的模块进行编译。</target>
        </trans-unit>
        <trans-unit id="f56aa33e889a1d3e8b0dbe2f53303f6d1de0ebdc" translate="yes" xml:space="preserve">
          <source>It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma &lt;code&gt;pragma&lt;/code&gt;:</source>
          <target state="translated">可以定义自定义类型的编译指示。自定义实用程序不会直接影响代码生成，但是宏可以检测到它们的存在。使用带有pragma &lt;code&gt;pragma&lt;/code&gt; 注释的模板来定义自定义实用程序：</target>
        </trans-unit>
        <trans-unit id="bc420b00d95b0079b6bcd9cda3e4f93970825224" translate="yes" xml:space="preserve">
          <source>It is possible to raise/catch imported C++ exceptions. Types imported using &lt;em&gt;importcpp&lt;/em&gt; can be raised or caught. Exceptions are raised by value and caught by reference. Example:</source>
          <target state="translated">可以引发/捕获导入的C ++异常。可以引发或捕获使用&lt;em&gt;importcpp&lt;/em&gt;导入的类型。异常是通过值引发的，并通过引用来捕获的。例：</target>
        </trans-unit>
        <trans-unit id="82b23252352db8b301d0df8ca78112f74b272448" translate="yes" xml:space="preserve">
          <source>It is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</source>
          <target state="translated">数组从零开始是很常见的,所以有一个快捷语法来指定从零到指定索引减一的范围。</target>
        </trans-unit>
        <trans-unit id="82118804703a69ba666b11e8579a1411bb333d2a" translate="yes" xml:space="preserve">
          <source>It may be surprising but the function as a whole can take longer than the specified timeout, only individual internal calls on the socket are affected. In practice this means that as long as the server is sending data an exception will not be raised, if however data does not reach the client within the specified timeout a &lt;code&gt;TimeoutError&lt;/code&gt; exception will be raised.</source>
          <target state="translated">可能令人惊讶，但是整个函数所花费的时间可能超过指定的超时时间，仅影响套接字上的各个内部调用。实际上，这意味着只要服务器正在发送数据，就不会引发异常，但是，如果数据在指定的超时时间内未到达客户端，则会引发 &lt;code&gt;TimeoutError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="919d2993bd870949c788657a2aacbe74a9e6d3fc" translate="yes" xml:space="preserve">
          <source>It must be a call expression &lt;code&gt;f(a, ...)&lt;/code&gt;.</source>
          <target state="translated">它必须是调用表达式 &lt;code&gt;f(a, ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1bdeab513f38cc4e202661fc69c3b7e5aa7c684" translate="yes" xml:space="preserve">
          <source>It must contain &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">它必须包含 &lt;code&gt;else&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="9f548d24fefd8a46690cd32590a6cce7dfd8f4a7" translate="yes" xml:space="preserve">
          <source>It must not contain &lt;code&gt;elif&lt;/code&gt; branches.</source>
          <target state="translated">它不能包含 &lt;code&gt;elif&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="a0657d7c3802eac9139afa1fdbbc00243500a126" translate="yes" xml:space="preserve">
          <source>It's a static error if the compiler cannot perform the evaluation at compile time.</source>
          <target state="translated">如果编译器在编译时不能执行评估,这是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="b08a29bb41e597ad7a05123c2e5513c91c059874" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;from module import nil&lt;/code&gt; if one wants to import the module but wants to enforce fully qualified access to every symbol in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">它也可以使用 &lt;code&gt;from module import nil&lt;/code&gt; 如果一个人想导入模块，但要强制执行的在每一个符号完全合格的接入 &lt;code&gt;module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de95b4993b261b85e3332b1324f8a0290c259dec" translate="yes" xml:space="preserve">
          <source>It's recommended to use &lt;code&gt;addCallback&lt;/code&gt; or &lt;code&gt;then&lt;/code&gt; instead.</source>
          <target state="translated">我们推荐使用 &lt;code&gt;addCallback&lt;/code&gt; 或 &lt;code&gt;then&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="cadaa83ad0b6b331d838560da721266dc244b734" translate="yes" xml:space="preserve">
          <source>Iterate over all the directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">遍历所有与&lt;em&gt;模式&lt;/em&gt;匹配的目录。在POSIX上，它使用&lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt;调用。</target>
        </trans-unit>
        <trans-unit id="e75e34b52a6961303566d6b4dd5b3c4b21d77274" translate="yes" xml:space="preserve">
          <source>Iterate over all the files and directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">遍历所有与&lt;em&gt;模式&lt;/em&gt;匹配的文件和目录。在POSIX上，它使用&lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt;调用。</target>
        </trans-unit>
        <trans-unit id="9d643234b1583c1062d05608e19e2329372f5e89" translate="yes" xml:space="preserve">
          <source>Iterate over all the files that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">遍历所有与&lt;em&gt;模式&lt;/em&gt;匹配的文件。在POSIX上，它使用&lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt;调用。</target>
        </trans-unit>
        <trans-unit id="584cc308ff50e7947ff5a4e8292a45088ef391f4" translate="yes" xml:space="preserve">
          <source>Iterate over any line in the file &lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">遍历文件&lt;em&gt;f&lt;/em&gt;中的任何行。</target>
        </trans-unit>
        <trans-unit id="7a1c0deeb78059911d4801816fdd1f4f108e438a" translate="yes" xml:space="preserve">
          <source>Iterates over [optional &lt;em&gt;eat&lt;/em&gt;] &lt;em&gt;delim&lt;/em&gt;-delimited slices in MemFile &lt;em&gt;mfile&lt;/em&gt;.</source>
          <target state="translated">循环访问MemFile &lt;em&gt;mfile中的&lt;/em&gt; [可选&lt;em&gt;eat&lt;/em&gt; ]以&lt;em&gt;delim&lt;/em&gt;分隔的切片。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52d58a07e8a9d8fd6b99e5571402712d73dfd13e" translate="yes" xml:space="preserve">
          <source>Iterates over all the children of &lt;em&gt;n&lt;/em&gt; returning those matching &lt;em&gt;tag&lt;/em&gt;.</source>
          <target state="translated">迭代&lt;em&gt;n的&lt;/em&gt;所有子代，返回匹配的&lt;em&gt;tag&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b19228b3b231795b187dec3bdf8a6cb478e6ffc7" translate="yes" xml:space="preserve">
          <source>Iterates over any line in the file named &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">遍历文件名&lt;em&gt;filename&lt;/em&gt;中的任何行。</target>
        </trans-unit>
        <trans-unit id="232f547ddc65be9624e107036fe1044b4d2a410d" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning runes</source>
          <target state="translated">遍历任何Unicode字符串的字符 &lt;code&gt;s&lt;/code&gt; 返回符文</target>
        </trans-unit>
        <trans-unit id="8bc06e9d0c093f624eaf1ffbfc94ebe52d5cb792" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning utf8 values</source>
          <target state="translated">迭代返回utf8值的字符串 &lt;code&gt;s&lt;/code&gt; 任何unicode字符</target>
        </trans-unit>
        <trans-unit id="0388ab64e5b2bc44c4842558d16b95e6873ca62a" translate="yes" xml:space="preserve">
          <source>Iterates over every field of &lt;em&gt;x&lt;/em&gt; returning their name and value.</source>
          <target state="translated">遍历&lt;em&gt;x的&lt;/em&gt;每个字段，以返回其名称和值。</target>
        </trans-unit>
        <trans-unit id="00e6300c1169713ff3c5939859f36401dc5c4eee" translate="yes" xml:space="preserve">
          <source>Iterates over every line in the stream. The iteration is based on &lt;code&gt;readLine&lt;/code&gt;.</source>
          <target state="translated">遍历流中的每一行。迭代基于 &lt;code&gt;readLine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d86ccc2321238c55eb2895e898e51e2cea46b931" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the ordered set &lt;em&gt;s&lt;/em&gt; in insertion order.</source>
          <target state="translated">以插入顺序遍历有序集合&lt;em&gt;s&lt;/em&gt;中的键。</target>
        </trans-unit>
        <trans-unit id="c71c7420dcf70891eaaf12e2494e2aabe991e2e1" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">遍历set中&lt;em&gt;的&lt;/em&gt;键。</target>
        </trans-unit>
        <trans-unit id="46bdee16e1d678daf2434ac56d4f6f640c4d7297" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt; and its indices.</source>
          <target state="translated">遍历NimNode &lt;code&gt;n&lt;/code&gt; 的子级及其索引。</target>
        </trans-unit>
        <trans-unit id="a478441af6bfca796118a06d6ecf3801a9262e8d" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">遍历NimNode &lt;code&gt;n&lt;/code&gt; 的子级。</target>
        </trans-unit>
        <trans-unit id="019eedce602970f3a59ce2f86870397544031ca8" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if every item fulfills the predicate.</source>
          <target state="translated">遍历一个容器,并检查每个项目是否满足谓词。</target>
        </trans-unit>
        <trans-unit id="3501cb1c35511e4764121e28692134446b5075eb" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if some item fulfills the predicate.</source>
          <target state="translated">遍历一个容器,检查是否有项目满足了谓词。</target>
        </trans-unit>
        <trans-unit id="7fbdcafeaa504e0cbb5d1d512e8dfbaba8410003" translate="yes" xml:space="preserve">
          <source>Iterates through a container and yields every item that fulfills the predicate.</source>
          <target state="translated">遍历一个容器,产生每一个满足谓词的项目。</target>
        </trans-unit>
        <trans-unit id="81ad0b1b4463be831a5785f4d06c130b3622cb6b" translate="yes" xml:space="preserve">
          <source>Iterator declaration</source>
          <target state="translated">迭代器声明</target>
        </trans-unit>
        <trans-unit id="edfa2bc8a9c8c3896d560c27f80be0217d6f76a5" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject.</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;的子元素的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是JObject。</target>
        </trans-unit>
        <trans-unit id="7b68d08a7df61a331ce7105b12ff381cd2542871" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject. Values can be modified</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;的子元素的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是JObject。值可以修改</target>
        </trans-unit>
        <trans-unit id="6229022bcfa1dd29b2c2a761afb0d2b506503b49" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray.</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;项的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是JArray。</target>
        </trans-unit>
        <trans-unit id="937eeb4e7eb8e59ed90bf865be25f2439aa4af89" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray. Items can be modified.</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;项的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是JArray。可以修改项目。</target>
        </trans-unit>
        <trans-unit id="853abfbfe15cced2111de5887bb206586352e215" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList.</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;项的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是SList。</target>
        </trans-unit>
        <trans-unit id="cba2124d3f6e176e90018e400cd94d03ff65e532" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList. Items can be modified.</source>
          <target state="translated">&lt;em&gt;节点&lt;/em&gt;项的迭代器。&lt;em&gt;节点&lt;/em&gt;必须是SList。可以修改项目。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e0b6581a3426edca0a47a508b898e82d9d301321" translate="yes" xml:space="preserve">
          <source>Iterators and the for statement</source>
          <target state="translated">迭代器和for语句</target>
        </trans-unit>
        <trans-unit id="c425b7e3d2bb19788f1181a2d9b7a44e6225c0c2" translate="yes" xml:space="preserve">
          <source>Iterators can only be called from for loops.</source>
          <target state="translated">迭代器只能从for循环中调用。</target>
        </trans-unit>
        <trans-unit id="df973b05a9a30c48e0cd32ea43a5a32471fddcf5" translate="yes" xml:space="preserve">
          <source>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</source>
          <target state="translated">迭代器不能被向前声明,因为编译器必须能够内联迭代器。(这个限制将在未来的编译器版本中消失。)</target>
        </trans-unit>
        <trans-unit id="5ab10982165c8e92be42e548c908af50f06450ed" translate="yes" xml:space="preserve">
          <source>Iterators cannot contain a &lt;code&gt;return&lt;/code&gt; statement (and procs cannot contain a &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">迭代器不能包含 &lt;code&gt;return&lt;/code&gt; 语句（而proc不能包含 &lt;code&gt;yield&lt;/code&gt; 语句）。</target>
        </trans-unit>
        <trans-unit id="6bf87542270934bc52223ff3fd2180cee9913ce5" translate="yes" xml:space="preserve">
          <source>Iterators do not support recursion.</source>
          <target state="translated">迭代器不支持递归。</target>
        </trans-unit>
        <trans-unit id="f13b815d55263a0262e1d3f448ea1ef694f0c5ac" translate="yes" xml:space="preserve">
          <source>Iterators have no implicit &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">迭代器没有隐式 &lt;code&gt;result&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="876bf01455350b312419f0cdb54d8032bb9cad66" translate="yes" xml:space="preserve">
          <source>Iterators look very similar to procedures, but there are several important differences:</source>
          <target state="translated">迭代器看起来与程序非常相似,但有几个重要的区别。</target>
        </trans-unit>
        <trans-unit id="6bc9cd0b4b1a838a8dbe53e1eea311fe67780b4c" translate="yes" xml:space="preserve">
          <source>Iterators that are neither marked &lt;code&gt;{.closure.}&lt;/code&gt; nor &lt;code&gt;{.inline.}&lt;/code&gt; explicitly default to being inline, but this may change in future versions of the implementation.</source>
          <target state="translated">既不是标记迭代器 &lt;code&gt;{.closure.}&lt;/code&gt; 也不是 &lt;code&gt;{.inline.}&lt;/code&gt; 明确默认为是线上，但这可能在执行的未来版本中改变。</target>
        </trans-unit>
        <trans-unit id="38589c6c98e2050e493732fa1ecf1db5355eff6a" translate="yes" xml:space="preserve">
          <source>Its expression must always be &lt;code&gt;nimvm&lt;/code&gt;. More complex expressions are not allowed.</source>
          <target state="translated">其表达式必须始终为 &lt;code&gt;nimvm&lt;/code&gt; 。不允许使用更复杂的表达式。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="cc51bafafaa93b2fbf580ec2042f2d93d08d2a66" translate="yes" xml:space="preserve">
          <source>JSON node</source>
          <target state="translated">JSON节点</target>
        </trans-unit>
        <trans-unit id="10e429d7ec1e1bc197f5757d96b736f7f4406dc2" translate="yes" xml:space="preserve">
          <source>JSON representation is stored in the passed &lt;em&gt;result&lt;/em&gt;</source>
          <target state="translated">JSON表示形式存储在传递的&lt;em&gt;结果中&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d58199ede61c8be4b203d8081423f4280c50eb7c" translate="yes" xml:space="preserve">
          <source>JavaScript compatibility</source>
          <target state="translated">JavaScript兼容性</target>
        </trans-unit>
        <trans-unit id="f916a308bc581d1790072c2938487f3e908716e7" translate="yes" xml:space="preserve">
          <source>JavaScript invocation example</source>
          <target state="translated">JavaScript调用示例</target>
        </trans-unit>
        <trans-unit id="763eb4bbded920e91a4a60898d473e2e59d035cd" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;delete&lt;/em&gt; operator</source>
          <target state="translated">JavaScript的&lt;em&gt;删除&lt;/em&gt;运算符</target>
        </trans-unit>
        <trans-unit id="7069adda83e85fa6bdd1af127a53c1cd02199edc" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;require&lt;/em&gt; function</source>
          <target state="translated">JavaScript的&lt;em&gt;require&lt;/em&gt;函数</target>
        </trans-unit>
        <trans-unit id="e59bd4e62783475d358a55e576f9e1db556cc458" translate="yes" xml:space="preserve">
          <source>JavaScript's __dirname pseudo-variable</source>
          <target state="translated">JavaScript的__dirname伪变量</target>
        </trans-unit>
        <trans-unit id="c05cec6255459be0665ced8c38873552b1af2710" translate="yes" xml:space="preserve">
          <source>JavaScript's __filename pseudo-variable</source>
          <target state="translated">JavaScript的__filename伪变量</target>
        </trans-unit>
        <trans-unit id="48e39cbab3720cf60b021ee6573c7b065c55248f" translate="yes" xml:space="preserve">
          <source>JavaScript's arguments pseudo-variable</source>
          <target state="translated">JavaScript的参数伪变量。</target>
        </trans-unit>
        <trans-unit id="54d029c76d92f4b9cfa620d278a0227c9c10f25f" translate="yes" xml:space="preserve">
          <source>JavaScript's null literal</source>
          <target state="translated">JavaScript的null literal</target>
        </trans-unit>
        <trans-unit id="cf269e0f71fff143464c4dce0ba8941aff38d4fb" translate="yes" xml:space="preserve">
          <source>JavaScript's undefined literal</source>
          <target state="translated">JavaScript的未定义文字</target>
        </trans-unit>
        <trans-unit id="dcbcd7e22ce06dbd66e5b01adffbd52ed0a91c58" translate="yes" xml:space="preserve">
          <source>Joins two URLs together, separating them with / if needed.</source>
          <target state="translated">将两个URL连接在一起,必要时用/分隔。</target>
        </trans-unit>
        <trans-unit id="6b949efa98af5de2c9a9e2aa57c0ac512664c7bb" translate="yes" xml:space="preserve">
          <source>Joins two directory names to one.</source>
          <target state="translated">将两个目录名连接成一个。</target>
        </trans-unit>
        <trans-unit id="f916106b08687c9b3604d03769854685d4185a21" translate="yes" xml:space="preserve">
          <source>Just like an &lt;em&gt;if expression&lt;/em&gt;, but corresponding to the when statement.</source>
          <target state="translated">就像&lt;em&gt;if表达式一样&lt;/em&gt;，但是对应于when语句。</target>
        </trans-unit>
        <trans-unit id="1f5a23579b9dec30ee62832658d6b0b949930854" translate="yes" xml:space="preserve">
          <source>Just like in regular type classes, Nim discriminates between &lt;code&gt;bind once&lt;/code&gt; and &lt;code&gt;bind many&lt;/code&gt; types when matching the concept. You can add the &lt;code&gt;distinct&lt;/code&gt; modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:</source>
          <target state="translated">就像在常规类型类中一样，Nim 在匹配概念时区分 &lt;code&gt;bind once&lt;/code&gt; &lt;code&gt;bind many&lt;/code&gt; 和多次绑定。您可以将 &lt;code&gt;distinct&lt;/code&gt; 修饰符添加到任何其他可推断类型中，以得到将被匹配而不会永久推断的类型。当您需要匹配多个接受相同广泛类型的proc时，这可能会很有用：</target>
        </trans-unit>
        <trans-unit id="3706f82fc751aa40a365d4e0255b0c559571efe9" translate="yes" xml:space="preserve">
          <source>Just like in this example we pass the path to the &lt;code&gt;mylib.a&lt;/code&gt; library (and we could as well pass &lt;code&gt;logic.o&lt;/code&gt;) we could be passing switches to link any other static C library.</source>
          <target state="translated">就像在此示例中一样，我们将路径传递到 &lt;code&gt;mylib.a&lt;/code&gt; 库（并且我们也可以传递 &lt;code&gt;logic.o&lt;/code&gt; ），我们可以传递用于链接任何其他静态C库的开关。</target>
        </trans-unit>
        <trans-unit id="ec69238a91ddb84ddd174a422a2bc6d89e341833" translate="yes" xml:space="preserve">
          <source>Just like strings, custom data types that are to be shared between Nim and the backend will need careful consideration of who controls who. If you want to hand a Nim reference to C code, you will need to use &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; to mark the reference as used, so it does not get freed. And for the C backend you will need to expose the &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc to clean up this memory when it is not required any more.</source>
          <target state="translated">就像字符串一样，要在Nim和后端之间共享的自定义数据类型将需要仔细考虑谁控制谁。如果要将Nim引用交给C代码，则需要使用&lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt;将引用标记为已使用，因此不会释放该引用。对于C后端，您将需要公开&lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc来清理不再需要的内存。</target>
        </trans-unit>
        <trans-unit id="a1934a4d1d0bfda8c814a6f373c36bed11fcc1a9" translate="yes" xml:space="preserve">
          <source>Just like with regular pointers, covariance will be enabled only for immutable values:</source>
          <target state="translated">就像普通指针一样,协方差只对不可变的值启用。</target>
        </trans-unit>
        <trans-unit id="ba04be8caff7a5b413c929b67abe644a93a8234c" translate="yes" xml:space="preserve">
          <source>Keeping track of memory</source>
          <target state="translated">追踪记忆</target>
        </trans-unit>
        <trans-unit id="c3cc4a28dc3c7c50a7cedf645fccd862a77c3448" translate="yes" xml:space="preserve">
          <source>Keeps the items in the passed sequence if they fulfilled the predicate. Same as the &lt;code&gt;filter&lt;/code&gt; proc, but modifies the sequence directly.</source>
          <target state="translated">如果项目满足谓词，则将它们保持在传递的顺序中。与 &lt;code&gt;filter&lt;/code&gt; 相同，但是直接修改序列。</target>
        </trans-unit>
        <trans-unit id="cd0b9402bb38009f565aff1f5e64a66bff29662b" translate="yes" xml:space="preserve">
          <source>Kill the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill()&lt;/code&gt; is simply an alias for &lt;code&gt;terminate()&lt;/code&gt;.</source>
          <target state="translated">终止进程&lt;em&gt;p&lt;/em&gt;。在Posix OS上，该过程将 &lt;code&gt;SIGKILL&lt;/code&gt; 发送到该进程。在Windows &lt;code&gt;kill()&lt;/code&gt; 仅仅是一个别名 &lt;code&gt;terminate()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">已知的局限性。</target>
        </trans-unit>
        <trans-unit id="71e0d9df3f621a55340e5e059ae130eb41a5eb1c" translate="yes" xml:space="preserve">
          <source>Lambda lifting is implemented as part of the &lt;code&gt;transf&lt;/code&gt; pass. The &lt;code&gt;transf&lt;/code&gt; pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is &lt;code&gt;void*&lt;/code&gt; and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying &lt;code&gt;s.ast[paramPos]&lt;/code&gt; to contain the formal hidden parameter, but not &lt;code&gt;s.typ&lt;/code&gt;!</source>
          <target state="translated">Lambda提升是 &lt;code&gt;transf&lt;/code&gt; Pass的一部分。该 &lt;code&gt;transf&lt;/code&gt; 过程生成的代码来设置环境，并通过它周围。但是，此通行证不会更改类型！所以我们这里有些不匹配；一方面proc表达式成为显式元组，另一方面tyProc（ccClosure）类型未更改。对于C代码生成，隐藏的形式参数是 &lt;code&gt;void*&lt;/code&gt; 而不是更专业的东西也很重要。但是，更专业的env类型需要以某种方式传递给后端。我们通过修改 &lt;code&gt;s.ast[paramPos]&lt;/code&gt; 使其包含正式的隐藏参数来解决此问题，而不是 &lt;code&gt;s.typ&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="6f81dcaf384dc8f0c6782aafff539ab7cb63534e" translate="yes" xml:space="preserve">
          <source>Language Manual</source>
          <target state="translated">语文手册</target>
        </trans-unit>
        <trans-unit id="f1a81de77c30016ff417d2dc8525d90f0c658140" translate="yes" xml:space="preserve">
          <source>Large example</source>
          <target state="translated">大例子</target>
        </trans-unit>
        <trans-unit id="309493ddacc4fb8306467fc937e00c3cfc275435" translate="yes" xml:space="preserve">
          <source>Larger example</source>
          <target state="translated">更大的例子</target>
        </trans-unit>
        <trans-unit id="84d8b12a98abf233ce61b735b7f623dfa748d624" translate="yes" xml:space="preserve">
          <source>Later versions of Nim can be more precise about the borrowing rule with a syntax like:</source>
          <target state="translated">后期版本的Nim可以用类似这样的语法更精确地说明借用规则。</target>
        </trans-unit>
        <trans-unit id="b84ad3bb11b5b72ae8064b2e03ac6593bfc14c79" translate="yes" xml:space="preserve">
          <source>Later versions of the language will weaken the requirements for forward declarations.</source>
          <target state="translated">以后的语言版本会弱化对前向声明的要求。</target>
        </trans-unit>
        <trans-unit id="b6e6ff1bcd7ed1a5e8f4c37ec0106d2e2587cae3" translate="yes" xml:space="preserve">
          <source>Lazy type resolution for untyped</source>
          <target state="translated">无类型的懒惰类型解析</target>
        </trans-unit>
        <trans-unit id="a4f7fe013eb75f3bd7abaac6e67f4376f5da9c25" translate="yes" xml:space="preserve">
          <source>Leaf nodes/Atoms</source>
          <target state="translated">叶节/原子</target>
        </trans-unit>
        <trans-unit id="a6702a5291853b1308e7bd674d53f7e0975e6409" translate="yes" xml:space="preserve">
          <source>Left-Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">将字符串&lt;em&gt;s&lt;/em&gt;与&lt;em&gt;padding&lt;/em&gt;左对齐，使其长度为&lt;em&gt;count&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="581f4b8c009369b50e3d9ba5325d87417e6534b8" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 16-bits value.</source>
          <target state="translated">在16位值中左旋位。</target>
        </trans-unit>
        <trans-unit id="d3409f80fea6038549fe1206956266f2e8a6fbb1" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 32-bits value.</source>
          <target state="translated">在一个32位的值中左旋位。</target>
        </trans-unit>
        <trans-unit id="0aef55ce888f5b32fb20afe0a6d757edd1ce8821" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 64-bits value.</source>
          <target state="translated">64位值中的左旋位。</target>
        </trans-unit>
        <trans-unit id="73e3851ee7450c9ad9c84aa2c1e0ca99eeb3856b" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 8-bits value.</source>
          <target state="translated">8位值中的左旋位。</target>
        </trans-unit>
        <trans-unit id="08b05a7cc45a3cfbb0bd52f3553051c002b98ea9" translate="yes" xml:space="preserve">
          <source>Let section</source>
          <target state="translated">让部分</target>
        </trans-unit>
        <trans-unit id="aa344992ab3c9cce0c812154c891a2082a0f43d5" translate="yes" xml:space="preserve">
          <source>Let us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.</source>
          <target state="translated">让我们更详细地看看Nim的词素:和其他编程语言一样,Nim由(字符串)字元、标识符、关键字、注释、运算符和其他标点符号组成。</target>
        </trans-unit>
        <trans-unit id="b472892cf2e180fd60510de81af55b7e2fd6e956" translate="yes" xml:space="preserve">
          <source>Let's return to the simple counting example:</source>
          <target state="translated">我们再来看看简单的计数例子。</target>
        </trans-unit>
        <trans-unit id="3714e6d8f0e24eacd7b52251a4d193e3636ffbc7" translate="yes" xml:space="preserve">
          <source>Let's start with an example: a procedure that finds the index of a character in a string.</source>
          <target state="translated">让我们从一个例子开始:一个在字符串中查找字符索引的过程。</target>
        </trans-unit>
        <trans-unit id="1be636c6149d23a6ac7030b7b471d95740b30580" translate="yes" xml:space="preserve">
          <source>Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.</source>
          <target state="translated">我们来看看一个有很多有趣的方面的程序,来感受一下程序调用是如何分解的。</target>
        </trans-unit>
        <trans-unit id="f090ebad1e9028f1098a5af4e5a797eb536bf181" translate="yes" xml:space="preserve">
          <source>Lets</source>
          <target state="translated">Lets</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="0948974278e3b95cbbb246e9eab8bec6da78b254" translate="yes" xml:space="preserve">
          <source>Lexical Analysis</source>
          <target state="translated">词汇分析</target>
        </trans-unit>
        <trans-unit id="484504bca1de9d78289cf5ed0ff59489797fb25f" translate="yes" xml:space="preserve">
          <source>Lexical elements</source>
          <target state="translated">词汇要素</target>
        </trans-unit>
        <trans-unit id="fd70e598fcf927041c896f6dc4b87e917b2286bf" translate="yes" xml:space="preserve">
          <source>Library documentation</source>
          <target state="translated">图书馆文件</target>
        </trans-unit>
        <trans-unit id="850e532a72f1397362ed6c2e2c7768467301292f" translate="yes" xml:space="preserve">
          <source>Licence of the PCRE library</source>
          <target state="translated">PCRE图书馆的许可证</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="7babbd6a13612f2b75fad2536bf20e3a90be6f3a" translate="yes" xml:space="preserve">
          <source>Lifting Procs</source>
          <target state="translated">吊装程序</target>
        </trans-unit>
        <trans-unit id="133720a88f4f0b2480df1a722653e8f80be2609a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exportc&lt;/code&gt; or &lt;code&gt;importc&lt;/code&gt;, the &lt;code&gt;extern&lt;/code&gt; pragma affects name mangling. The string literal passed to &lt;code&gt;extern&lt;/code&gt; can be a format string:</source>
          <target state="translated">像 &lt;code&gt;exportc&lt;/code&gt; 或 &lt;code&gt;importc&lt;/code&gt; 一样， &lt;code&gt;extern&lt;/code&gt; 编译指示会影响名称修饰。传递给 &lt;code&gt;extern&lt;/code&gt; 的字符串文字可以是格式字符串：</target>
        </trans-unit>
        <trans-unit id="a89c659521de912108568798c30a4d3b9390dd11" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkDiscardStmt&lt;/code&gt; kind.</source>
          <target state="translated">像 &lt;code&gt;return&lt;/code&gt; 一样，但是具有 &lt;code&gt;nnkDiscardStmt&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="70b76be5ae3e05bda0dbd20d90abcc0ff40f9de9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkYieldStmt&lt;/code&gt; kind.</source>
          <target state="translated">像 &lt;code&gt;return&lt;/code&gt; 一样，但是具有 &lt;code&gt;nnkYieldStmt&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="b4cf638ae85ebba4736e92856cb8c627ef275c96" translate="yes" xml:space="preserve">
          <source>Like a plain &lt;code&gt;import&lt;/code&gt; statement but with &lt;code&gt;nnkIncludeStmt&lt;/code&gt;.</source>
          <target state="translated">就像一个简单的 &lt;code&gt;import&lt;/code&gt; 语句，但是带有 &lt;code&gt;nnkIncludeStmt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63a95e62d7c911dbac4f0639f9bb4cb823deae98" translate="yes" xml:space="preserve">
          <source>Like in many other programming languages, a &lt;code&gt;continue&lt;/code&gt; statement starts the next iteration immediately:</source>
          <target state="translated">像在许多其他编程语言中一样， &lt;code&gt;continue&lt;/code&gt; 语句立即开始下一次迭代：</target>
        </trans-unit>
        <trans-unit id="35a4297befbf3cbceda9715d4684f55b9e927a9e" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;if&lt;/code&gt; statement, but the root has the kind &lt;code&gt;nnkWhenStmt&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;if&lt;/code&gt; 语句，但是根的类型为 &lt;code&gt;nnkWhenStmt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab04aac5a7e1d598d2f186753e388a3731d77143" translate="yes" xml:space="preserve">
          <source>Like tuples, objects are a means to pack different values together in a structured way. However, objects provide many features that tuples do not: They provide inheritance and information hiding. Because objects encapsulate data, the &lt;code&gt;T()&lt;/code&gt; object constructor should only be used internally and the programmer should provide a proc to initialize the object (this is called a &lt;em&gt;constructor&lt;/em&gt;).</source>
          <target state="translated">像元组一样，对象是一种以结构化方式将不同值打包在一起的方法。但是，对象提供了许多元组所没有的功能：它们提供了继承和信息隐藏。因为对象封装了数据，所以 &lt;code&gt;T()&lt;/code&gt; 对象构造函数只能在内部使用，程序员应提供proc来初始化对象（这称为&lt;em&gt;构造函数&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="07bc01629a98c42a6a26d28d793349cd9ddcb413" translate="yes" xml:space="preserve">
          <source>Likewise &lt;code&gt;T = ref T&lt;/code&gt; is an invalid type.</source>
          <target state="translated">同样， &lt;code&gt;T = ref T&lt;/code&gt; 是无效类型。</target>
        </trans-unit>
        <trans-unit id="012148b3c7c09fe4183a821ac0dfc3df94a4644a" translate="yes" xml:space="preserve">
          <source>Likewise for generic matches the most specialized generic type (that still matches) is preferred:</source>
          <target state="translated">同样,对于通用匹配,也是优先选择最专业的通用类型(仍然匹配)。</target>
        </trans-unit>
        <trans-unit id="9fe316ffb5c502363f1602369491e5771962db68" translate="yes" xml:space="preserve">
          <source>Likewise the following does not make sense as the name is &lt;code&gt;strutils&lt;/code&gt; already:</source>
          <target state="translated">同样，以下名称也没有意义，因为名称已经是 &lt;code&gt;strutils&lt;/code&gt; 了：</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="79cb6c70879ccadb6a188effd65c3c269014aee8" translate="yes" xml:space="preserve">
          <source>Limitations of the method call syntax</source>
          <target state="translated">方法调用语法的局限性</target>
        </trans-unit>
        <trans-unit id="7556b5753ea0ca8128d6f780d7fa036fc5b03486" translate="yes" xml:space="preserve">
          <source>Limitations/Bugs</source>
          <target state="translated">Limitations/Bugs</target>
        </trans-unit>
        <trans-unit id="81e5623d345118d762dbee1a0e1de32ed5723969" translate="yes" xml:space="preserve">
          <source>Limitations: If used within nim VM context &lt;code&gt;sizeof&lt;/code&gt; will only work for simple types.</source>
          <target state="translated">限制：如果在nim VM上下文中使用， &lt;code&gt;sizeof&lt;/code&gt; 仅适用于简单类型。</target>
        </trans-unit>
        <trans-unit id="4c46adaafc40b789df2ecf20dd985f671faba467" translate="yes" xml:space="preserve">
          <source>Line exceeds the maximum length.</source>
          <target state="translated">线路超过最大长度。</target>
        </trans-unit>
        <trans-unit id="223cc1feb0fa894d9ee9937b64e7b5859c71bc96" translate="yes" xml:space="preserve">
          <source>Line where the symbol is located in the file. Lines start to count at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">符号在文件中所在的行。行从&lt;strong&gt;1&lt;/strong&gt;开始计数。</target>
        </trans-unit>
        <trans-unit id="6975daf276430ee5b07e3f0247df76b80c98d27d" translate="yes" xml:space="preserve">
          <source>LineDir option</source>
          <target state="translated">LineDir选项</target>
        </trans-unit>
        <trans-unit id="268d8379173ac37e106048c36fff01d9c9b4910e" translate="yes" xml:space="preserve">
          <source>LineTooLong</source>
          <target state="translated">LineTooLong</target>
        </trans-unit>
        <trans-unit id="064387f46f31232c3427cd5f69fac7318fd9f966" translate="yes" xml:space="preserve">
          <source>LineTrace option</source>
          <target state="translated">线路追踪选项</target>
        </trans-unit>
        <trans-unit id="ac3679d78b17b02969cddb03c164e6e2d4dc3390" translate="yes" xml:space="preserve">
          <source>Lines should be no longer than 80 characters. Limiting the amount of information present on each line makes for more readable code - the reader has smaller chunks to process.</source>
          <target state="translated">行数不应超过80个字符。限制每行的信息量可以使代码更易读--读者有更小的块来处理。</target>
        </trans-unit>
        <trans-unit id="b0876c4bcec0ae3cbb0d666f7829f1981ec34562" translate="yes" xml:space="preserve">
          <source>Lines starting with &lt;code&gt;&amp;gt;&lt;/code&gt; indicate a command to be sent to the compiler and the lines following a command include checks for expected or forbidden output (&lt;code&gt;!&lt;/code&gt; for forbidden).</source>
          <target state="translated">以 &lt;code&gt;&amp;gt;&lt;/code&gt; 开头的行表示要发送到编译器的命令，而该命令后的行包括检查预期或禁止的输出（ &lt;code&gt;!&lt;/code&gt; 表示禁止）。</target>
        </trans-unit>
        <trans-unit id="d0517071aa376e797705058bbad4b658954b9930" translate="yes" xml:space="preserve">
          <source>Link</source>
          <target state="translated">Link</target>
        </trans-unit>
        <trans-unit id="1c3cb2684d19be6954dbbdc4f8e73df679e8e5d0" translate="yes" xml:space="preserve">
          <source>Link pragma</source>
          <target state="translated">链接原则</target>
        </trans-unit>
        <trans-unit id="9da74ab1a4b986bea87990a9a620e399e5636c76" translate="yes" xml:space="preserve">
          <source>Linking phase.</source>
          <target state="translated">链接阶段。</target>
        </trans-unit>
        <trans-unit id="29298813156f944560ccc7706430702f6f4ee582" translate="yes" xml:space="preserve">
          <source>List comprehension, returns a sequence. &lt;em&gt;comp&lt;/em&gt; is the actual list comprehension, for example &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt;. &lt;em&gt;typ&lt;/em&gt; is the type that will be stored inside the result seq.</source>
          <target state="translated">列表理解，返回一个序列。&lt;em&gt;comp&lt;/em&gt;是实际的列表理解，例如 &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt; 。&lt;em&gt;typ&lt;/em&gt;是将存储在结果序列中的类型。</target>
        </trans-unit>
        <trans-unit id="f8243f1d71ba9600f36e4fd5c7ce82f383a50045" translate="yes" xml:space="preserve">
          <source>List of hints</source>
          <target state="translated">提示列表</target>
        </trans-unit>
        <trans-unit id="5516fee04290d8fb240eb1035f9649b7af9c46bc" translate="yes" xml:space="preserve">
          <source>List of warnings</source>
          <target state="translated">警告清单</target>
        </trans-unit>
        <trans-unit id="104e72166267b2e14189f97dfc051685f78e0501" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory.</source>
          <target state="translated">列出 &lt;code&gt;dir&lt;/code&gt; 中的所有文件。如果 &lt;code&gt;dir&lt;/code&gt; 为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，则使用当前工作目录。</target>
        </trans-unit>
        <trans-unit id="1ab878ae07a9cde029575d5b2c8f1f1831aa46a7" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory. If &lt;code&gt;async&lt;/code&gt; is true, this function will return immediately and it will be your job to call asyncio's &lt;code&gt;poll&lt;/code&gt; to progress this operation.</source>
          <target state="translated">列出 &lt;code&gt;dir&lt;/code&gt; 中的所有文件。如果 &lt;code&gt;dir&lt;/code&gt; 为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，则使用当前工作目录。如果 &lt;code&gt;async&lt;/code&gt; 为true，则此函数将立即返回，调用asyncio的 &lt;code&gt;poll&lt;/code&gt; 以进行此操作将是您的工作。</target>
        </trans-unit>
        <trans-unit id="236263cf5e9fb34d2dba2a5c051ef5dc5349c21d" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">文字 &lt;code&gt;&quot;&lt;/code&gt; 等</target>
        </trans-unit>
        <trans-unit id="b0e13df3237422a975bbec14b9ac839dee36c914" translate="yes" xml:space="preserve">
          <source>Literal match: &lt;code&gt;a&lt;/code&gt; is an integer literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a signed or unsigned integer type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range. Or: &lt;code&gt;a&lt;/code&gt; is a floating point literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a floating point type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range.</source>
          <target state="translated">文字匹配： &lt;code&gt;a&lt;/code&gt; 是值 &lt;code&gt;v&lt;/code&gt; 的整数文字，而 &lt;code&gt;f&lt;/code&gt; 是有符号或无符号整数类型，并且 &lt;code&gt;v&lt;/code&gt; 在 &lt;code&gt;f&lt;/code&gt; 的范围内。或者： &lt;code&gt;a&lt;/code&gt; 是值的浮点字面 &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 是一个浮点型和 &lt;code&gt;v&lt;/code&gt; 是在 &lt;code&gt;f&lt;/code&gt; 的范围。</target>
        </trans-unit>
        <trans-unit id="b9727a86e89a8cbd82800b60294dabca16499a86" translate="yes" xml:space="preserve">
          <source>Literals are bounds checked so that they fit the datatype. Non base-10 literals are used mainly for flags and bit pattern representations, therefore bounds checking is done on bit width, not value range. If the literal fits in the bit width of the datatype, it is accepted. Hence: 0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1 instead of causing an overflow error.</source>
          <target state="translated">字符是经过边界检查的,以使它们符合数据类型。非基数为10的字元主要用于标志和位模式表示,因此边界检查是在位宽而非值范围内进行的。如果字符符合数据类型的位宽,它就被接受。因此,在数据类型的位宽中,它是被接受的。0b10000000'u8 ==0x80'u8 ==128,但是,0b10000000'i8 ==0x80'i8 ==-1,而不会造成溢出错误。</target>
        </trans-unit>
        <trans-unit id="8b2a6eba528cf2e8ab33fb4a2bec0b163b834789" translate="yes" xml:space="preserve">
          <source>Literals are compile-time computable.</source>
          <target state="translated">字符是可以在编译时计算的。</target>
        </trans-unit>
        <trans-unit id="de51bd63110c92754499c41c1b9fc0a1062026bc" translate="yes" xml:space="preserve">
          <source>Load the specified configuration file into a new Config instance.</source>
          <target state="translated">将指定的配置文件加载到一个新的Config实例中。</target>
        </trans-unit>
        <trans-unit id="1a9e1513745115068212c830b486292757f91900" translate="yes" xml:space="preserve">
          <source>Load the specified configuration from stream into a new Config instance. &lt;em&gt;filename&lt;/em&gt; parameter is only used for nicer error messages.</source>
          <target state="translated">从流中将指定的配置加载到新的Config实例中。&lt;em&gt;filename&lt;/em&gt;参数仅用于更好的错误消息。</target>
        </trans-unit>
        <trans-unit id="a139e4bbf5ca5504f1d17d1d98e927f4b59c9a47" translate="yes" xml:space="preserve">
          <source>Loading a simple C function</source>
          <target state="translated">加载一个简单的C函数</target>
        </trans-unit>
        <trans-unit id="d468cd435069219754afbbe7d097d97a919d76a4" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">从 &lt;code&gt;path&lt;/code&gt; 指定的文件加载并解析HTML ，并返回 &lt;code&gt;XmlNode&lt;/code&gt; 。所有解析错误都将被忽略。</target>
        </trans-unit>
        <trans-unit id="e13175d1bc7af2e5d6755aeb721e7338069be90d" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">从 &lt;code&gt;path&lt;/code&gt; 指定的文件加载并解析HTML ，并返回 &lt;code&gt;XmlNode&lt;/code&gt; 。每个发生的解析错误都会添加到&lt;em&gt;错误&lt;/em&gt;序列中。</target>
        </trans-unit>
        <trans-unit id="4296f849be147d08fdb9d341d2ab77c8da850fd7" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;path&lt;/code&gt; 指定的文件中加载和解析XML ，然后返回 &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e2e2e83d566103f2e7459a72bbf8e836f49d66" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a stream specified by &lt;code&gt;stream&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">从stream指定的 &lt;code&gt;stream&lt;/code&gt; 加载和解析XML ，并返回 &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="045d13349b264d2eba76a0804c08fa59e6a17cff" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a string specified by &lt;code&gt;xml&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;xml&lt;/code&gt; 指定的字符串中加载和解析XML ，然后返回 &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9e01e6b541364451c7b06cd42daa257c56a015" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">从 &lt;code&gt;path&lt;/code&gt; 指定的文件加载并解析XML ，然后返回 &lt;code&gt;XmlNode&lt;/code&gt; 。所有解析错误都将变成 &lt;code&gt;XmlError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="58715b2c04bf6ee07528232196803acf3ddcf9e8" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">从 &lt;code&gt;path&lt;/code&gt; 指定的文件加载并解析XML ，然后返回 &lt;code&gt;XmlNode&lt;/code&gt; 。每个发生的解析错误都会添加到 &lt;code&gt;errors&lt;/code&gt; 序列中。</target>
        </trans-unit>
        <trans-unit id="d7db461111deca6d0f8236779f0bb1263494a8e8" translate="yes" xml:space="preserve">
          <source>Lock levels</source>
          <target state="translated">锁定级别</target>
        </trans-unit>
        <trans-unit id="98f1e767de995c2aa21fe38394145cda4db0f95d" translate="yes" xml:space="preserve">
          <source>Lock levels are used to enforce a global locking order in order to prevent deadlocks at compile-time. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</source>
          <target state="translated">锁定级别用于强制执行全局锁定顺序,以防止在编译时出现死锁。锁定级别是一个范围为0...1_000的常数。锁定级别为0意味着根本不获取任何锁。</target>
        </trans-unit>
        <trans-unit id="a026b72d4824601afcdf130fca670d0c8d13f97d" translate="yes" xml:space="preserve">
          <source>Locks and routines can be annotated with &lt;span id=&quot;lock-levels_1&quot;&gt;lock levels&lt;/span&gt; to prevent deadlocks at compile time.</source>
          <target state="translated">可以使用&lt;span id=&quot;lock-levels_1&quot;&gt;锁级别&lt;/span&gt;对锁和例程进行注释，以防止在编译时出现死锁。</target>
        </trans-unit>
        <trans-unit id="8e5c380132554658df14cbe018d3eebcce0b49de" translate="yes" xml:space="preserve">
          <source>Logs a debug message to all registered handlers.</source>
          <target state="translated">给所有注册的处理程序记录一条调试信息。</target>
        </trans-unit>
        <trans-unit id="4c7f919536de93b8ad43c3247437839e50803cac" translate="yes" xml:space="preserve">
          <source>Logs a fatal error message to all registered handlers.</source>
          <target state="translated">向所有注册的处理程序记录一个致命的错误信息。</target>
        </trans-unit>
        <trans-unit id="5dfc8bdbe4c51442cb3331391bf133dae2303823" translate="yes" xml:space="preserve">
          <source>Logs a message to all registered handlers at the given level.</source>
          <target state="translated">将消息记录到给定级别的所有注册处理程序。</target>
        </trans-unit>
        <trans-unit id="57d8e0636873737f16f4b7cc780f237140e75837" translate="yes" xml:space="preserve">
          <source>Logs a warning message to all registered handlers.</source>
          <target state="translated">向所有注册的处理程序记录一条警告信息。</target>
        </trans-unit>
        <trans-unit id="9317adaad7621328486bdf8c1ddb1b9fc41f1e55" translate="yes" xml:space="preserve">
          <source>Logs an error message to all registered handlers.</source>
          <target state="translated">向所有注册的处理程序记录错误信息。</target>
        </trans-unit>
        <trans-unit id="4b60a8dc51101a47288a87fdd0bfadc5f86cbf8e" translate="yes" xml:space="preserve">
          <source>Logs an info message to all registered handlers.</source>
          <target state="translated">向所有注册的处理者记录信息消息。</target>
        </trans-unit>
        <trans-unit id="d163792610c410f93f355f367ec68f39a5ba2888" translate="yes" xml:space="preserve">
          <source>Logs an notice message to all registered handlers.</source>
          <target state="translated">向所有注册的处理者记录通知信息。</target>
        </trans-unit>
        <trans-unit id="968b9d0e2a2ece8aa91b1cc23a28091c21b0a82f" translate="yes" xml:space="preserve">
          <source>Logs to a file using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">仅使用 &lt;code&gt;logger&lt;/code&gt; 记录到文件。</target>
        </trans-unit>
        <trans-unit id="1a9ec4044346457b95a04e72c6feb17b0ce890ff" translate="yes" xml:space="preserve">
          <source>Logs to a file using rolling &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">仅使用滚动 &lt;code&gt;logger&lt;/code&gt; 记录到文件。</target>
        </trans-unit>
        <trans-unit id="50128c469a86270a2da91f8b00b431458f68392b" translate="yes" xml:space="preserve">
          <source>Logs to the console using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">仅使用 &lt;code&gt;logger&lt;/code&gt; 登录到控制台。</target>
        </trans-unit>
        <trans-unit id="e8ee53aa3b26fe91c5819ca15b134a56f645ac1e" translate="yes" xml:space="preserve">
          <source>Lookup rules for template parameters</source>
          <target state="translated">模板参数的查询规则</target>
        </trans-unit>
        <trans-unit id="ce44bf0dea95522d8571be7ae1c1bf020f1c61c5" translate="yes" xml:space="preserve">
          <source>Loopback address.</source>
          <target state="translated">回环地址。</target>
        </trans-unit>
        <trans-unit id="ed3b229a877674fc9085bfff9aad369487b7967d" translate="yes" xml:space="preserve">
          <source>Lossless &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; exception is raised (if the error cannot be detected at compile time).</source>
          <target state="translated">在使用不同类型的整数类型的表达式中执行无损&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;自动类型转换&lt;/span&gt;。但是，如果类型转换将导致信息丢失，则会引发&lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt;异常（如果在编译时无法检测到错误）。</target>
        </trans-unit>
        <trans-unit id="5ca6f7c7b2f3fcead3d5cf315885d15734fca9dc" translate="yes" xml:space="preserve">
          <source>Lots of other small issues...</source>
          <target state="translated">其他很多小问题...</target>
        </trans-unit>
        <trans-unit id="b8a68b12b71fd0a8e62d67043581d497f4e0c387" translate="yes" xml:space="preserve">
          <source>Macro declaration</source>
          <target state="translated">宏观声明</target>
        </trans-unit>
        <trans-unit id="d5f312834ff09b9cbab1f1a3ebc0bbe0f1a19b93" translate="yes" xml:space="preserve">
          <source>Macro which converts normal procedures into javascript-compatible async procedures</source>
          <target state="translated">将普通程序转换为javascript兼容的async程序的宏。</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="bcf4850e55a2614c2efa81a2629e41ec19afef8b" translate="yes" xml:space="preserve">
          <source>Macros as pragmas</source>
          <target state="translated">巨集的实用性</target>
        </trans-unit>
        <trans-unit id="980cf51d761ff2e575f35b48bf655118288e07f9" translate="yes" xml:space="preserve">
          <source>Macros behave like templates, but &lt;code&gt;nnkTemplateDef&lt;/code&gt; is replaced with &lt;code&gt;nnkMacroDef&lt;/code&gt;.</source>
          <target state="translated">宏的行为类似于模板，但是 &lt;code&gt;nnkTemplateDef&lt;/code&gt; 替换为 &lt;code&gt;nnkMacroDef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fabe264274a80515010384b77dc0559e962ca19d" translate="yes" xml:space="preserve">
          <source>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;foreign function interface (FFI)&lt;/a&gt; is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</source>
          <target state="translated">宏可以启用高级编译时代码转换，但是它们不能更改Nim的语法。但是，这并不是真正的限制，因为Nim的语法足够灵活。如果未在编译器中启用&lt;a href=&quot;manual#foreign-function-interface&quot;&gt;外部功能接口（FFI），&lt;/a&gt;则必须使用纯Nim代码实现宏，但是除了该限制（将来会消失）之外，您可以编写任何种类的Nim代码并编译器将在编译时运行它。</target>
        </trans-unit>
        <trans-unit id="4316199fa5a1551b8a3aa00b57acfb7552982193" translate="yes" xml:space="preserve">
          <source>Macros module includes helpers which can be used to simplify custom pragma access &lt;em&gt;hasCustomPragma&lt;/em&gt;, &lt;em&gt;getCustomPragmaVal&lt;/em&gt;. Please consult macros module documentation for details. These macros are no magic, they don't do anything you cannot do yourself by walking AST object representation.</source>
          <target state="translated">宏模块包括帮助程序，可用于简化自定义&lt;em&gt;杂&lt;/em&gt;注访问&lt;em&gt;hasCustomPragma&lt;/em&gt;和&lt;em&gt;getCustomPragmaVal&lt;/em&gt;。有关详细信息，请查阅宏模块文档。这些宏不是魔术，它们不会执行AST对象表示形式无法做的任何事情。</target>
        </trans-unit>
        <trans-unit id="fcb1a29368fba3810f040b19c708029e63713744" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;osproc&lt;/code&gt; use &lt;code&gt;fork&lt;/code&gt; instead of &lt;code&gt;posix_spawn&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;osproc&lt;/code&gt; 使用 &lt;code&gt;fork&lt;/code&gt; 而不是 &lt;code&gt;posix_spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c651f2d69bb1c5e0aa5eb7b1418517d939a6973" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log.</source>
          <target state="translated">让Nim将堆栈跟踪输出到stdout,而不是服务器日志。</target>
        </trans-unit>
        <trans-unit id="499d78e3579f7c7ce46ccd08c0c7e05dcf497fe4" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout.</source>
          <target state="translated">让 Nim 将栈跟踪输出到 stdout,而不是服务器日志。setStackTraceStdout的变形别名。</target>
        </trans-unit>
        <trans-unit id="2e3d974a9298c4b4ebf6fa1f9cde4cea6a610923" translate="yes" xml:space="preserve">
          <source>Makes Nim use C's &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; instead of Nim's own memory manager, ableit prefixing each allocation with its size to support clearing memory on reallocation. This only works with &lt;code&gt;gc:none&lt;/code&gt;.</source>
          <target state="translated">使Nim使用C的&lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt;而不是Nim自己的内存管理器，从而能够在每个分配之前为其大小加上前缀，以支持在重新分配时清除内存。这仅适用于 &lt;code&gt;gc:none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c24f6fa722204e68ea302ade8ca94caa0a75902" translate="yes" xml:space="preserve">
          <source>Mandatory term being indexed. Terms can include quoting according to Nim's rules (eg. `^`).</source>
          <target state="translated">被索引的强制性术语。根据Nim的规则,术语可以包括引用(例如`^`)。</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="8b04fd7fca9bde6ca081d5a883719b86d91603ee" translate="yes" xml:space="preserve">
          <source>Manual: AST based overloading</source>
          <target state="translated">手册。基于AST的超载</target>
        </trans-unit>
        <trans-unit id="defb0de64fe7ca08a6ed982374de4bb9a85c2662" translate="yes" xml:space="preserve">
          <source>Manual: Effect system</source>
          <target state="translated">手册。效果系统</target>
        </trans-unit>
        <trans-unit id="c96afc4df608947a129115509fc6ac1d02f56202" translate="yes" xml:space="preserve">
          <source>Manual: Exception handling</source>
          <target state="translated">手册。异常情况处理</target>
        </trans-unit>
        <trans-unit id="ddfc1de56c3bd1d03afdd4142362226685aca4b2" translate="yes" xml:space="preserve">
          <source>Manual: Foreign function interface</source>
          <target state="translated">手动。外来函数接口</target>
        </trans-unit>
        <trans-unit id="e56aa0932cbe0a4d0a9778061468fdfecc37f816" translate="yes" xml:space="preserve">
          <source>Manual: Generics</source>
          <target state="translated">手册:非专利产品</target>
        </trans-unit>
        <trans-unit id="5774a3094051cc1a01178d4abbdf9174054d2afa" translate="yes" xml:space="preserve">
          <source>Manual: Guards and locks</source>
          <target state="translated">手册。警卫和锁</target>
        </trans-unit>
        <trans-unit id="034ba2f8aa22d8c1659925669461f5c6bb46d48d" translate="yes" xml:space="preserve">
          <source>Manual: Implementation Specific Pragmas</source>
          <target state="translated">手册。具体实施办法</target>
        </trans-unit>
        <trans-unit id="5b04a062ff7cc9d86ce05472065106035a8097fa" translate="yes" xml:space="preserve">
          <source>Manual: Import statement Include statement Module names in imports Collective imports from a directory Pseudo import/include paths From import statement Export statement</source>
          <target state="translated">手动。导入语句 包含语句 导入中的模块名称 从目录中集体导入 伪导入/包含路径 从导入语句导出语句</target>
        </trans-unit>
        <trans-unit id="fd76cbedf6737eb16d94623f5ae0365ae0d604f1" translate="yes" xml:space="preserve">
          <source>Manual: Iterators and the for statement</source>
          <target state="translated">手册。迭代器和for语句</target>
        </trans-unit>
        <trans-unit id="a243b6fe56c421c23e6ef513dd30b788f1257a68" translate="yes" xml:space="preserve">
          <source>Manual: Lexical Analysis</source>
          <target state="translated">手册。词汇分析</target>
        </trans-unit>
        <trans-unit id="ed3d84a9118355ed8740c1a7b3f3b4c841535124" translate="yes" xml:space="preserve">
          <source>Manual: Macros</source>
          <target state="translated">手册:宏</target>
        </trans-unit>
        <trans-unit id="4bafc4dbfa5c0e3c58d2fb274d692bbf25d243fc" translate="yes" xml:space="preserve">
          <source>Manual: Modules</source>
          <target state="translated">手册。模块</target>
        </trans-unit>
        <trans-unit id="9a290e826830f6686d0f05fcc67ab7c270d95dbb" translate="yes" xml:space="preserve">
          <source>Manual: Multi-methods</source>
          <target state="translated">手册。多方法</target>
        </trans-unit>
        <trans-unit id="11714535fa66e7fe2732c23bbc152d68d14f704d" translate="yes" xml:space="preserve">
          <source>Manual: Overloading resolution</source>
          <target state="translated">手动。超载决议</target>
        </trans-unit>
        <trans-unit id="856ff8f109b24f9933255ac3581aadee568cd2dc" translate="yes" xml:space="preserve">
          <source>Manual: Parallel &amp;amp; Spawn</source>
          <target state="translated">手册：并行和生成</target>
        </trans-unit>
        <trans-unit id="7ec22936b55b7f305c2be8dba10aa5109567b287" translate="yes" xml:space="preserve">
          <source>Manual: Pragmas</source>
          <target state="translated">手册:实用主义</target>
        </trans-unit>
        <trans-unit id="770e4cc3468cd2ab34e2292349c2fc7f1254bba1" translate="yes" xml:space="preserve">
          <source>Manual: Procedures</source>
          <target state="translated">手册。程序</target>
        </trans-unit>
        <trans-unit id="1b494587e353e28a4fb14cede5251f048106d63a" translate="yes" xml:space="preserve">
          <source>Manual: Special Operators</source>
          <target state="translated">手册。特别操作员</target>
        </trans-unit>
        <trans-unit id="67456811ead6b001268c25ae75d8eb80bf9b78d4" translate="yes" xml:space="preserve">
          <source>Manual: Special Types</source>
          <target state="translated">手册。特殊类型</target>
        </trans-unit>
        <trans-unit id="6decf7713585353b542d22a07833a9e3f4608374" translate="yes" xml:space="preserve">
          <source>Manual: Statements and expressions</source>
          <target state="translated">手册。语句和表达方式</target>
        </trans-unit>
        <trans-unit id="c06b311819398e9a7a08be8caed1736017ac7522" translate="yes" xml:space="preserve">
          <source>Manual: Syntax</source>
          <target state="translated">手动。语法</target>
        </trans-unit>
        <trans-unit id="bacd5ce7b4fc6c233337b20743738357eb3d4917" translate="yes" xml:space="preserve">
          <source>Manual: Templates</source>
          <target state="translated">手册:模板</target>
        </trans-unit>
        <trans-unit id="817f3b64b7fab30fc4fa2987f47b2de7d799191c" translate="yes" xml:space="preserve">
          <source>Manual: Term rewriting macros</source>
          <target state="translated">手册。术语改写宏</target>
        </trans-unit>
        <trans-unit id="cbe3bd9f8e9a36414594a7b27bafcc1a597a3da5" translate="yes" xml:space="preserve">
          <source>Manual: Threads</source>
          <target state="translated">手册。线程</target>
        </trans-unit>
        <trans-unit id="aafb451a891596fbad0f0184b0ad302e74ebffc7" translate="yes" xml:space="preserve">
          <source>Manual: Type bound operations</source>
          <target state="translated">手册。类型约束操作</target>
        </trans-unit>
        <trans-unit id="166a47f26935d8e4d08a27d4c17c4e1d1999f722" translate="yes" xml:space="preserve">
          <source>Manual: Type relations</source>
          <target state="translated">手册。类型关系</target>
        </trans-unit>
        <trans-unit id="bd029877fffa549daa894766df47948479afd2f1" translate="yes" xml:space="preserve">
          <source>Manual: Types</source>
          <target state="translated">手册。类型</target>
        </trans-unit>
        <trans-unit id="2a1633f65bbc398d71c3ebfc3241c0af807273d5" translate="yes" xml:space="preserve">
          <source>Mark the test as skipped. Should be used directly in case when it is not possible to perform test for reasons depending on outer environment, or certain application logic conditions or configurations. The test code is still executed.</source>
          <target state="translated">标记为跳过测试。当由于外部环境或某些应用逻辑条件或配置等原因无法进行测试时,可直接使用。测试代码仍然被执行。</target>
        </trans-unit>
        <trans-unit id="1d3b7aa9b4c642f5735f40da06dfed06fbca163e" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;socket&lt;/code&gt; as accepting connections. &lt;code&gt;Backlog&lt;/code&gt; specifies the maximum length of the queue of pending connections.</source>
          <target state="translated">将 &lt;code&gt;socket&lt;/code&gt; 标记为接受连接。 &lt;code&gt;Backlog&lt;/code&gt; 指定未决连接队列的最大长度。</target>
        </trans-unit>
        <trans-unit id="f07f226b4437e06fea4e70beb870cd20dccb2b33" translate="yes" xml:space="preserve">
          <source>Matches a binary integer. This uses &lt;code&gt;parseutils.parseBin&lt;/code&gt;.</source>
          <target state="translated">匹配二进制整数。这使用 &lt;code&gt;parseutils.parseBin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61f72fda5d63c33af385805c251186ac41827a95" translate="yes" xml:space="preserve">
          <source>Matches a character set</source>
          <target state="translated">匹配一个字符集</target>
        </trans-unit>
        <trans-unit id="7c21df5bb89686108056b549eda7fc196d394426" translate="yes" xml:space="preserve">
          <source>Matches a decimal integer. This uses &lt;code&gt;parseutils.parseInt&lt;/code&gt;.</source>
          <target state="translated">匹配十进制整数。这使用 &lt;code&gt;parseutils.parseInt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a12cb4b049a1da7e03f068b60b69ca0670549bfd" translate="yes" xml:space="preserve">
          <source>Matches a floating pointer number. Uses &lt;code&gt;parseFloat&lt;/code&gt;.</source>
          <target state="translated">与浮点数匹配。使用 &lt;code&gt;parseFloat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2464cd36660069f3fcf2e58ee0a418607e32a9bc" translate="yes" xml:space="preserve">
          <source>Matches a hex integer. This uses &lt;code&gt;parseutils.parseHex&lt;/code&gt;.</source>
          <target state="translated">匹配十六进制整数。这使用 &lt;code&gt;parseutils.parseHex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="532fa54ee42246846545dbf2fc331f03ad0daeed" translate="yes" xml:space="preserve">
          <source>Matches a single character</source>
          <target state="translated">匹配单个字符</target>
        </trans-unit>
        <trans-unit id="e01edc99d3df652b0b10d0cd88889a4c6db28db5" translate="yes" xml:space="preserve">
          <source>Matches a single dollar sign.</source>
          <target state="translated">匹配一个一元符号。</target>
        </trans-unit>
        <trans-unit id="56b8550638d15898163432e2ef863037d24cf3ab" translate="yes" xml:space="preserve">
          <source>Matches a string</source>
          <target state="translated">匹配一个字符串</target>
        </trans-unit>
        <trans-unit id="2b0f27dc90ddd03570b6691c4598abffade1d014" translate="yes" xml:space="preserve">
          <source>Matches an ASCII identifier: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt;.</source>
          <target state="translated">匹配ASCII标识符： &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f19ab90d0dfde58576111f53aea6162591341ee" translate="yes" xml:space="preserve">
          <source>Matches an octal integer. This uses &lt;code&gt;parseutils.parseOct&lt;/code&gt;.</source>
          <target state="translated">匹配八进制整数。这使用 &lt;code&gt;parseutils.parseOct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8507509e46ea139d748c7c784f7cdc32a09d48f7" translate="yes" xml:space="preserve">
          <source>Matches if the end of the input string has been reached.</source>
          <target state="translated">匹配是否已经到达输入字符串的末端。</target>
        </trans-unit>
        <trans-unit id="44e83eb14a6d865158691b6ead9b69eedf905cb4" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$*&lt;/code&gt; was found. The match is allowed to be of 0 length.</source>
          <target state="translated">匹配直到找到 &lt;code&gt;$*&lt;/code&gt; 之后的令牌。匹配长度为0。</target>
        </trans-unit>
        <trans-unit id="548a91d3213ffddd1a11e82050c55439466aaf2f" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$+&lt;/code&gt; was found. The match must consist of at least one char.</source>
          <target state="translated">匹配直到找到 &lt;code&gt;$+&lt;/code&gt; 之后的令牌。比赛必须包含至少一个字符。</target>
        </trans-unit>
        <trans-unit id="ac458e6963c6ebdd9c5ca1f8b279a9eb42dfc913" translate="yes" xml:space="preserve">
          <source>Math libraries</source>
          <target state="translated">数学图书馆</target>
        </trans-unit>
        <trans-unit id="6e4c4838bcc55297c563147e236843926c319da6" translate="yes" xml:space="preserve">
          <source>Max line length is 80 characters.</source>
          <target state="translated">最大行长为80个字符。</target>
        </trans-unit>
        <trans-unit id="353de93dd15ff6db8a4b838f009f42da8fc085cc" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">32位浮点数的最大(正)指数。</target>
        </trans-unit>
        <trans-unit id="1d2ac0d1ca31ee91cf5ff6056f9a16027dd8fd2a" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">64位浮点数的最大(正)指数。</target>
        </trans-unit>
        <trans-unit id="8bbd4cef55a64a4e58be3f1e60ec750e94d7d807" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">对于32位浮点数的最大(正)指数,以10为基数。</target>
        </trans-unit>
        <trans-unit id="50184f5eb64ad277177d238e645f028ed1a230ab" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">64位浮点数的最大(正)指数,以10为基数。</target>
        </trans-unit>
        <trans-unit id="ed71d9f1d146dd9fd80c9fea6cf2280768a6a052" translate="yes" xml:space="preserve">
          <source>Maybe you didn't notice, but in the &lt;code&gt;dumpTree&lt;/code&gt; example the first constant explicitly specifies the type of the constant. That's why in the tree output the two last constants have their second child &lt;code&gt;Empty&lt;/code&gt; but the first has a string identifier. So basically a &lt;code&gt;const&lt;/code&gt; definition is made up from an identifier, optionally a type (can be an &lt;em&gt;empty&lt;/em&gt; node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</source>
          <target state="translated">也许您没有注意到，但是在 &lt;code&gt;dumpTree&lt;/code&gt; 示例中，第一个常量明确指定了常量的类型。这就是为什么在树输出中，最后两个常量的第二个子 &lt;code&gt;Empty&lt;/code&gt; 但是第一个常量的字符串标识符。因此，基本上， &lt;code&gt;const&lt;/code&gt; 定义由标识符，可选的类型（可以是&lt;em&gt;空&lt;/em&gt;节点）和值组成。掌握了这些知识之后，我们来看一下AST建筑宏的最终版本：</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">内存管理</target>
        </trans-unit>
        <trans-unit id="9baa9878dfbef1d35fc905168a10b0c4a8c0fbd9" translate="yes" xml:space="preserve">
          <source>Memory safety for returning by &lt;code&gt;var T&lt;/code&gt; is ensured by a simple borrowing rule: If &lt;code&gt;result&lt;/code&gt; does not refer to a location pointing to the heap (that is in &lt;code&gt;result = X&lt;/code&gt; the &lt;code&gt;X&lt;/code&gt; involves a &lt;code&gt;ptr&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; access) then it has to be deviated by the routine's first parameter:</source>
          <target state="translated">对通过返回存储安全 &lt;code&gt;var T&lt;/code&gt; 通过简单的借贷规则确保：如果 &lt;code&gt;result&lt;/code&gt; 不是指一个位置指向堆（即在 &lt;code&gt;result = X&lt;/code&gt; 的 &lt;code&gt;X&lt;/code&gt; 包括一个 &lt;code&gt;ptr&lt;/code&gt; 或者 &lt;code&gt;ref&lt;/code&gt; 存取），那么它必须通过偏离例程的第一个参数：</target>
        </trans-unit>
        <trans-unit id="50ff34431595cf400d81245be2a86a83f82386dd" translate="yes" xml:space="preserve">
          <source>Merges all index files in &lt;em&gt;dir&lt;/em&gt; and returns the generated index as HTML.</source>
          <target state="translated">合并&lt;em&gt;目录中的&lt;/em&gt;所有索引文件，并将生成的索引作为HTML返回。</target>
        </trans-unit>
        <trans-unit id="c08446305ac72d52aeff6051e72faf9d7787f9fc" translate="yes" xml:space="preserve">
          <source>Merges all separated TextNodes together, and removes any empty TextNodes</source>
          <target state="translated">将所有分开的TextNodes合并在一起,并删除任何空的TextNodes。</target>
        </trans-unit>
        <trans-unit id="33ef168ac38cdf5d66a3f96ccc53c0bcb2bec97c" translate="yes" xml:space="preserve">
          <source>Messages that are generated during the normal operation of an application and are of no particular importance. Useful to aggregate for potential later analysis.</source>
          <target state="translated">在应用程序正常运行期间产生的消息,没有特别重要的意义。有助于汇总,以便日后进行分析。</target>
        </trans-unit>
        <trans-unit id="949ba2d44e279ebf601f54248d567bd067f76669" translate="yes" xml:space="preserve">
          <source>Messages that are useful to the application developer only and are usually turned off in release.</source>
          <target state="translated">只对应用开发者有用的消息,通常在发布时关闭。</target>
        </trans-unit>
        <trans-unit id="de329f9988dc07ac218d31798f3d3fb0e319aeeb" translate="yes" xml:space="preserve">
          <source>Method call syntax</source>
          <target state="translated">方法调用语法</target>
        </trans-unit>
        <trans-unit id="b768cedc4687283126d9b1ed420f777b12a98828" translate="yes" xml:space="preserve">
          <source>Method dispatchers are global.</source>
          <target state="translated">方法调度器是全球性的。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="3c397a7933a859382d85ab67743d94fecb8793cf" translate="yes" xml:space="preserve">
          <source>Methods and type converters</source>
          <target state="translated">方法和类型转换器</target>
        </trans-unit>
        <trans-unit id="70972ae112e939ad343653a1ba078194eea37b73" translate="yes" xml:space="preserve">
          <source>Methods imply &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt; and idetools performs a static analysis on the code. For this reason idetools may not return the definition of the correct method you are querying because it may be impossible to know until the code is executed. It will try to return the method which covers the most possible cases (i.e. for variations of different classes in a hierarchy it will prefer methods using the base class).</source>
          <target state="translated">方法意味着&lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;动态调度，&lt;/a&gt;而idetools对代码执行静态分析。因此，idetools可能不会返回您正在查询的正确方法的定义，因为在执行代码之前可能无法知道。它将尝试返回覆盖最可能情况的方法（即，对于层次结构中不同类的变体，它将倾向于使用基类的方法）。</target>
        </trans-unit>
        <trans-unit id="53abbdb21e81e3f2df2cf14c89d5b6dbabdbe501" translate="yes" xml:space="preserve">
          <source>Microseconds display</source>
          <target state="translated">微秒显示</target>
        </trans-unit>
        <trans-unit id="71a3c685e2a1c832e7011ccdc9b0d684ec6c5b11" translate="yes" xml:space="preserve">
          <source>Milliseconds display</source>
          <target state="translated">毫秒显示</target>
        </trans-unit>
        <trans-unit id="f0ba6bd90de6cbdc1ad731d5daa371ecb83efe18" translate="yes" xml:space="preserve">
          <source>Minimal output level for the compiler.</source>
          <target state="translated">编译器的最小输出级别。</target>
        </trans-unit>
        <trans-unit id="011feb85fd840211ebe3cbea6d10c757384f0950" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">32位浮点数的最小(负)指数。</target>
        </trans-unit>
        <trans-unit id="a6a8707c6b54291fbf3e81a23b30ec1365b0f17e" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">64位浮点数的最小(负)指数。</target>
        </trans-unit>
        <trans-unit id="c80cc0223dc92abbd631516781aea6a70a2336ee" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">对于32位浮点数的最小(负)指数,以10为基数。</target>
        </trans-unit>
        <trans-unit id="8c0da4d03317d4bba985f6d156cd17b8a1e9fe83" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">64位浮点数的最小(负)指数,以10为基数。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="fde8fd6d013071c5b0da03141012d8c86a59338b" translate="yes" xml:space="preserve">
          <source>Mixin statement</source>
          <target state="translated">混合声明</target>
        </trans-unit>
        <trans-unit id="54a58f4d81597ea468c275c465f53b922146c355" translate="yes" xml:space="preserve">
          <source>Mixing parameters that should use the &lt;code&gt;using&lt;/code&gt; declaration with parameters that are explicitly typed is possible and requires a semicolon between them.</source>
          <target state="translated">应该将应该使用 &lt;code&gt;using&lt;/code&gt; 声明的参数与显式键入的参数混合，并且需要在它们之间使用分号。</target>
        </trans-unit>
        <trans-unit id="e4544d11fd6da006e85425de7ccf9cc035a9102d" translate="yes" xml:space="preserve">
          <source>Modelling currencies</source>
          <target state="translated">建立货币模型</target>
        </trans-unit>
        <trans-unit id="aa74d48711737b61f9e3b5b05bb11e9299107ca2" translate="yes" xml:space="preserve">
          <source>Modifies the prefix of this node</source>
          <target state="translated">修改此节点的前缀</target>
        </trans-unit>
        <trans-unit id="08534cfcbbc9538479a2881f8f4160931eb1a4e4" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by adding &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">修改 &lt;code&gt;a&lt;/code&gt; 通过增加地方 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d316a8d9b4204cded1b078dfca344f13947d6088" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by subtracting &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">修改 &lt;code&gt;a&lt;/code&gt; 减去到位 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf753b23cff3eb87675698eadfe1b3df8dc21c1" translate="yes" xml:space="preserve">
          <source>Modifying a configuration file.</source>
          <target state="translated">修改配置文件。</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="37f0da15f20ceb74b60fd308e1dca9126540cb05" translate="yes" xml:space="preserve">
          <source>Module algorithm</source>
          <target state="translated">模块算法</target>
        </trans-unit>
        <trans-unit id="98195ccd152814f0ec7cb526f9dfddd0c0f2d040" translate="yes" xml:space="preserve">
          <source>Module asyncdispatch</source>
          <target state="translated">模块asyncdispatch</target>
        </trans-unit>
        <trans-unit id="4bc2eee542f289752eea25797a5b576fdb1f0212" translate="yes" xml:space="preserve">
          <source>Module asyncfile</source>
          <target state="translated">模块asyncfile</target>
        </trans-unit>
        <trans-unit id="1982b034043183e25a12a7f8201ac7aedfe1337c" translate="yes" xml:space="preserve">
          <source>Module asyncftpclient</source>
          <target state="translated">模块asyncftpclient</target>
        </trans-unit>
        <trans-unit id="c8ecdd97327b90a5e22c271e6446280bc42a28c4" translate="yes" xml:space="preserve">
          <source>Module asyncfutures</source>
          <target state="translated">模块asyncfutures</target>
        </trans-unit>
        <trans-unit id="36cb7286c251d44bed6e333ac6ff256e07f23e46" translate="yes" xml:space="preserve">
          <source>Module asynchttpserver</source>
          <target state="translated">模块asynchttpserver</target>
        </trans-unit>
        <trans-unit id="a17c24b3dfb9bd981141eb4c7df0cf7bc771a15a" translate="yes" xml:space="preserve">
          <source>Module asyncio</source>
          <target state="translated">模块asyncio</target>
        </trans-unit>
        <trans-unit id="c68f5ddf8354a55f6684c3fbe9c3bf177423a499" translate="yes" xml:space="preserve">
          <source>Module asyncjs</source>
          <target state="translated">模块asyncjs</target>
        </trans-unit>
        <trans-unit id="101489cc366780f3080d0d181d612c9897002730" translate="yes" xml:space="preserve">
          <source>Module asyncnet</source>
          <target state="translated">模块asyncnet</target>
        </trans-unit>
        <trans-unit id="6fed8121401f7f3d76d9ac08c713d6fc1d80130c" translate="yes" xml:space="preserve">
          <source>Module asyncstreams</source>
          <target state="translated">模块asyncstreams</target>
        </trans-unit>
        <trans-unit id="7760e4149a4aa9f2f5276da9842c763efe627d2d" translate="yes" xml:space="preserve">
          <source>Module base64</source>
          <target state="translated">模块base64</target>
        </trans-unit>
        <trans-unit id="90d38995e07bc5f4bab2517945813fb23c0f041c" translate="yes" xml:space="preserve">
          <source>Module bitops</source>
          <target state="translated">模块比特率</target>
        </trans-unit>
        <trans-unit id="50eadb9d8cc85daa18b406eb03722df6d8ad89ae" translate="yes" xml:space="preserve">
          <source>Module browsers</source>
          <target state="translated">模块浏览器</target>
        </trans-unit>
        <trans-unit id="541c25a9eda5bd8f8b769d4123a86bdd4573b52d" translate="yes" xml:space="preserve">
          <source>Module cgi</source>
          <target state="translated">模块cgi</target>
        </trans-unit>
        <trans-unit id="582466c566af045f4b9e5cd6e35678516157979c" translate="yes" xml:space="preserve">
          <source>Module channels</source>
          <target state="translated">模块通道</target>
        </trans-unit>
        <trans-unit id="9b8b21dabbac15d101b015114dad88029c7c9e26" translate="yes" xml:space="preserve">
          <source>Module colors</source>
          <target state="translated">模块颜色</target>
        </trans-unit>
        <trans-unit id="eed8ec6f020ff8aa124c5b37641c245a63ddde69" translate="yes" xml:space="preserve">
          <source>Module complex</source>
          <target state="translated">模块综合体</target>
        </trans-unit>
        <trans-unit id="374208eb48a6ab162ea9a9795c69a75d26d8d0d8" translate="yes" xml:space="preserve">
          <source>Module cookies</source>
          <target state="translated">模块cookies</target>
        </trans-unit>
        <trans-unit id="a4721d23b264afe3adb6840e441ad673c273dbe5" translate="yes" xml:space="preserve">
          <source>Module coro</source>
          <target state="translated">模块电晕</target>
        </trans-unit>
        <trans-unit id="0b7487264409b62ec77bc44946eb6949835043bd" translate="yes" xml:space="preserve">
          <source>Module cpuinfo</source>
          <target state="translated">模块cpuinfo</target>
        </trans-unit>
        <trans-unit id="65a4bb57d62e6d50e39758f49fa5d45582a06fcf" translate="yes" xml:space="preserve">
          <source>Module cpuload</source>
          <target state="translated">模块cpuload</target>
        </trans-unit>
        <trans-unit id="0eaf026ca68438c31c5ddb66759abefe57ca491a" translate="yes" xml:space="preserve">
          <source>Module critbits</source>
          <target state="translated">模块标准</target>
        </trans-unit>
        <trans-unit id="17fb6170e7c4b5192d13d3ef92b62003adec52ed" translate="yes" xml:space="preserve">
          <source>Module cstrutils</source>
          <target state="translated">模块结构</target>
        </trans-unit>
        <trans-unit id="dccbda4248191deb5d482692eac7fa4e615cc212" translate="yes" xml:space="preserve">
          <source>Module db_common</source>
          <target state="translated">模块db_common</target>
        </trans-unit>
        <trans-unit id="8d09576b4e94ea8a8b0016794ba4536d4b1759df" translate="yes" xml:space="preserve">
          <source>Module db_mysql</source>
          <target state="translated">模块db_mysql</target>
        </trans-unit>
        <trans-unit id="6624ca243c80fc450c0491ae2bd086e7f22e2273" translate="yes" xml:space="preserve">
          <source>Module db_odbc</source>
          <target state="translated">模块db_odbc</target>
        </trans-unit>
        <trans-unit id="fd6fae1e074c3591c208c14db853d9f0744b3fe6" translate="yes" xml:space="preserve">
          <source>Module db_postgres</source>
          <target state="translated">模块db_postgres</target>
        </trans-unit>
        <trans-unit id="b401aafda6e7b26047ce7d9b236e3e28ead3b900" translate="yes" xml:space="preserve">
          <source>Module db_sqlite</source>
          <target state="translated">模块db_sqlite</target>
        </trans-unit>
        <trans-unit id="a36cab96e59f81b2cfa2e287c992565577181e19" translate="yes" xml:space="preserve">
          <source>Module deques</source>
          <target state="translated">模块查询</target>
        </trans-unit>
        <trans-unit id="230fe8691288c49b13cd6d0d633b0aa094bba0ba" translate="yes" xml:space="preserve">
          <source>Module distros</source>
          <target state="translated">模块发行版</target>
        </trans-unit>
        <trans-unit id="b98b5015c00736657c4dd0da231c080c137bf240" translate="yes" xml:space="preserve">
          <source>Module docgen_sample</source>
          <target state="translated">模块docgen_sample</target>
        </trans-unit>
        <trans-unit id="9b3df8bd64b5aae95560173051cb9413193a2ac6" translate="yes" xml:space="preserve">
          <source>Module dom</source>
          <target state="translated">模块dom</target>
        </trans-unit>
        <trans-unit id="941b4acd398cb84658e8c03ee70acb8a6a6ad12b" translate="yes" xml:space="preserve">
          <source>Module dynlib</source>
          <target state="translated">模块 dynlib</target>
        </trans-unit>
        <trans-unit id="0b682ac70a1c85d9baf3957f2aa8f759d24240e0" translate="yes" xml:space="preserve">
          <source>Module encodings</source>
          <target state="translated">模块编码</target>
        </trans-unit>
        <trans-unit id="db5b0c91c31ae7c7d91818dc9b614356c8ac354a" translate="yes" xml:space="preserve">
          <source>Module endians</source>
          <target state="translated">模块endians</target>
        </trans-unit>
        <trans-unit id="bd74d2f3f124ee315af73875094015c9b005becf" translate="yes" xml:space="preserve">
          <source>Module fenv</source>
          <target state="translated">模块fenv</target>
        </trans-unit>
        <trans-unit id="731086b25ca52f0d4ba784e9023a512802282c5d" translate="yes" xml:space="preserve">
          <source>Module for computing MD5 checksums.</source>
          <target state="translated">计算MD5校验和的模块。</target>
        </trans-unit>
        <trans-unit id="b4be1b80500b5ac048dcc726ed598ece6701931b" translate="yes" xml:space="preserve">
          <source>Module ftpclient</source>
          <target state="translated">模块ftpclient</target>
        </trans-unit>
        <trans-unit id="3c4f086976fa89f11b3a0b18d36e2a8854016a20" translate="yes" xml:space="preserve">
          <source>Module hashes</source>
          <target state="translated">模块哈希</target>
        </trans-unit>
        <trans-unit id="a2e15c184ec6f1cb32588bee5d5ccb0d11dcc6e5" translate="yes" xml:space="preserve">
          <source>Module heapqueue</source>
          <target state="translated">模块堆栈</target>
        </trans-unit>
        <trans-unit id="83b2786d0af670a8727d352ab2cc17a4801a8fde" translate="yes" xml:space="preserve">
          <source>Module highlite</source>
          <target state="translated">高光模块</target>
        </trans-unit>
        <trans-unit id="68378bdbde20dbf762ba106c90a960cc76a0c343" translate="yes" xml:space="preserve">
          <source>Module htmlgen</source>
          <target state="translated">htmlgen模块</target>
        </trans-unit>
        <trans-unit id="11585b007040719709343df6d82764795667bb4d" translate="yes" xml:space="preserve">
          <source>Module htmlparser</source>
          <target state="translated">模块 htmlparser</target>
        </trans-unit>
        <trans-unit id="ce266765149cfec68daffab151c2d1cbb6ebb974" translate="yes" xml:space="preserve">
          <source>Module httpclient</source>
          <target state="translated">模块 httpclient</target>
        </trans-unit>
        <trans-unit id="ae17027dff9b5c5e08184e61c512b15de51aca77" translate="yes" xml:space="preserve">
          <source>Module httpcore</source>
          <target state="translated">模块httpcore</target>
        </trans-unit>
        <trans-unit id="efcdd786f2c6fa38c8e234f0d6d253c5564d8710" translate="yes" xml:space="preserve">
          <source>Module intsets</source>
          <target state="translated">模块内设</target>
        </trans-unit>
        <trans-unit id="ae1f8df6d1f31431338fdcd3f32d3d351bdb0f67" translate="yes" xml:space="preserve">
          <source>Module iup</source>
          <target state="translated">模块iup</target>
        </trans-unit>
        <trans-unit id="8abdec2103ddf3b91238dc0ef753306e3cf948a1" translate="yes" xml:space="preserve">
          <source>Module jscore</source>
          <target state="translated">模块jscore</target>
        </trans-unit>
        <trans-unit id="2445c7a3a0648ca25b67b51a400e8dde36b920dc" translate="yes" xml:space="preserve">
          <source>Module jsffi</source>
          <target state="translated">模块jsffi</target>
        </trans-unit>
        <trans-unit id="3e231af76878f00ab682498609250b7a33902b37" translate="yes" xml:space="preserve">
          <source>Module json</source>
          <target state="translated">模块json</target>
        </trans-unit>
        <trans-unit id="37345fc873fd9ef2206568b360b1c24cb44c6a79" translate="yes" xml:space="preserve">
          <source>Module lenientops</source>
          <target state="translated">模块 lenientops</target>
        </trans-unit>
        <trans-unit id="580e2f376943e7c873eabc0e8de78d45329a29d4" translate="yes" xml:space="preserve">
          <source>Module lexbase</source>
          <target state="translated">模块词库</target>
        </trans-unit>
        <trans-unit id="f7eb0bf35deb63519acf61a5dc69c51f5b06735f" translate="yes" xml:space="preserve">
          <source>Module lists</source>
          <target state="translated">模块列表</target>
        </trans-unit>
        <trans-unit id="5fa64d315f22284a510ec90f2b3766f8771aa4d3" translate="yes" xml:space="preserve">
          <source>Module locks</source>
          <target state="translated">模块锁</target>
        </trans-unit>
        <trans-unit id="d68a3f14f1246e34391c7c956005b435126a1feb" translate="yes" xml:space="preserve">
          <source>Module logging</source>
          <target state="translated">模块记录</target>
        </trans-unit>
        <trans-unit id="70e578149237a5fb397ecdf712216171be19d22c" translate="yes" xml:space="preserve">
          <source>Module macros</source>
          <target state="translated">模块宏</target>
        </trans-unit>
        <trans-unit id="8e11adceffbd4622428572ca4afc35c17c825d9b" translate="yes" xml:space="preserve">
          <source>Module marshal</source>
          <target state="translated">模块元帅</target>
        </trans-unit>
        <trans-unit id="33c70e8cca5fc846249c996c55efdccf09fa04af" translate="yes" xml:space="preserve">
          <source>Module matchers</source>
          <target state="translated">模块匹配器</target>
        </trans-unit>
        <trans-unit id="60528f0928b59cfa4557a3b1b994edb4024106b0" translate="yes" xml:space="preserve">
          <source>Module math</source>
          <target state="translated">数学模块</target>
        </trans-unit>
        <trans-unit id="56d8fbdebc1eb23f12cddf043b4f3037a450710a" translate="yes" xml:space="preserve">
          <source>Module md5</source>
          <target state="translated">模块md5</target>
        </trans-unit>
        <trans-unit id="bce77eb47d51483993e4fa0db56b0547cc3dd24c" translate="yes" xml:space="preserve">
          <source>Module memfiles</source>
          <target state="translated">模块 memfiles</target>
        </trans-unit>
        <trans-unit id="20df3a115fcb30f9b530aa03bdc18faa0ae695c2" translate="yes" xml:space="preserve">
          <source>Module mersenne</source>
          <target state="translated">模块mersenne</target>
        </trans-unit>
        <trans-unit id="cc1b82bbab0603a47f41c5adca38b87a9321bee7" translate="yes" xml:space="preserve">
          <source>Module mimetypes</source>
          <target state="translated">模块模拟类型</target>
        </trans-unit>
        <trans-unit id="6657cfabe7d07bf51cc2fb118ba722ffc96aba89" translate="yes" xml:space="preserve">
          <source>Module mysql</source>
          <target state="translated">模块 mysql</target>
        </trans-unit>
        <trans-unit id="31d0c7d344fc5c65774ddf00049b1876645f3b19" translate="yes" xml:space="preserve">
          <source>Module names in imports</source>
          <target state="translated">进口中的模块名称</target>
        </trans-unit>
        <trans-unit id="30df598104815cce6ad06791aec2a9d153b164f7" translate="yes" xml:space="preserve">
          <source>Module nativesockets</source>
          <target state="translated">模块nativesockets</target>
        </trans-unit>
        <trans-unit id="a3d7a3865b172afee6c2b7c8977de511e77b6757" translate="yes" xml:space="preserve">
          <source>Module net</source>
          <target state="translated">模块网</target>
        </trans-unit>
        <trans-unit id="6c357de2b2a9a1de2189540c4281941a77608057" translate="yes" xml:space="preserve">
          <source>Module odbcsql</source>
          <target state="translated">模块odbcsql</target>
        </trans-unit>
        <trans-unit id="9ac9afd12fcca720ece0b72dd61269f6e7843617" translate="yes" xml:space="preserve">
          <source>Module oids</source>
          <target state="translated">模块化操作</target>
        </trans-unit>
        <trans-unit id="df6c016676012b7a90d7af54c2025872180c6083" translate="yes" xml:space="preserve">
          <source>Module openssl</source>
          <target state="translated">模块openssl</target>
        </trans-unit>
        <trans-unit id="181f431ffc709c06a61935e69331ac8e4563f46c" translate="yes" xml:space="preserve">
          <source>Module options</source>
          <target state="translated">模块选项</target>
        </trans-unit>
        <trans-unit id="7f661395966d22306bb86d25ec0d945d397507a0" translate="yes" xml:space="preserve">
          <source>Module os</source>
          <target state="translated">模块操作系统</target>
        </trans-unit>
        <trans-unit id="dae29e69d6fcac477476832d0c04d256e4219700" translate="yes" xml:space="preserve">
          <source>Module ospaths</source>
          <target state="translated">模块ospaths</target>
        </trans-unit>
        <trans-unit id="5395928ecc4ce4edf1eabd8f020d30b8523fd803" translate="yes" xml:space="preserve">
          <source>Module osproc</source>
          <target state="translated">osproc模块</target>
        </trans-unit>
        <trans-unit id="2bfeeb302a2c2fb80d26255c95b4f0b069b97c41" translate="yes" xml:space="preserve">
          <source>Module parsecfg</source>
          <target state="translated">模块 parsecfg</target>
        </trans-unit>
        <trans-unit id="d9ee6d4bae252aefed2ecd2ae012f67dfe339140" translate="yes" xml:space="preserve">
          <source>Module parsecsv</source>
          <target state="translated">模块parsecsv</target>
        </trans-unit>
        <trans-unit id="348399e23d1c192b9c45e1b0c83d05337c92bf98" translate="yes" xml:space="preserve">
          <source>Module parsejson</source>
          <target state="translated">模块 parsejson</target>
        </trans-unit>
        <trans-unit id="682e643a35975c3826db50e0bb0cd0dd5c2ca34f" translate="yes" xml:space="preserve">
          <source>Module parseopt</source>
          <target state="translated">模块解析opt</target>
        </trans-unit>
        <trans-unit id="0ed92eaefc270e8b9dd075eb2dd08dbaa5b51f01" translate="yes" xml:space="preserve">
          <source>Module parsesql</source>
          <target state="translated">模块 parsesql</target>
        </trans-unit>
        <trans-unit id="855c130387d410a61e37f5b34d034cd98d89f8d8" translate="yes" xml:space="preserve">
          <source>Module parseutils</source>
          <target state="translated">工具模块</target>
        </trans-unit>
        <trans-unit id="9371c7c885849232742553f842dca9202b5ed289" translate="yes" xml:space="preserve">
          <source>Module parsexml</source>
          <target state="translated">模块 parsexml</target>
        </trans-unit>
        <trans-unit id="20024d265db3ebf3a4cb1f9d150f212626383df7" translate="yes" xml:space="preserve">
          <source>Module pcre</source>
          <target state="translated">Pcre模块</target>
        </trans-unit>
        <trans-unit id="a17a4c9cec16cef361a14841e228e5ed78a25395" translate="yes" xml:space="preserve">
          <source>Module pegs</source>
          <target state="translated">钉子模块</target>
        </trans-unit>
        <trans-unit id="5f3bf0ccd39bc7809674b2d661113030c738201e" translate="yes" xml:space="preserve">
          <source>Module posix</source>
          <target state="translated">Posix模块</target>
        </trans-unit>
        <trans-unit id="eef6ef7935050ba1da22c08049e0e742ab0545c6" translate="yes" xml:space="preserve">
          <source>Module postgres</source>
          <target state="translated">Postgres模块</target>
        </trans-unit>
        <trans-unit id="4c337d9754fa6144e8e8c63eb6714830a7bf2680" translate="yes" xml:space="preserve">
          <source>Module random</source>
          <target state="translated">随机模块</target>
        </trans-unit>
        <trans-unit id="6f3863bd09c8389a708515de060c50fe217a1fc5" translate="yes" xml:space="preserve">
          <source>Module rationals</source>
          <target state="translated">模块理由</target>
        </trans-unit>
        <trans-unit id="1c6043ad9977193e14836b1453a2c14e877b9c12" translate="yes" xml:space="preserve">
          <source>Module re</source>
          <target state="translated">模块重新</target>
        </trans-unit>
        <trans-unit id="beb8a46432b339ddaa74839d412412426afb7728" translate="yes" xml:space="preserve">
          <source>Module rlocks</source>
          <target state="translated">模块锁</target>
        </trans-unit>
        <trans-unit id="373d2a7e384e4c78df72f2a532ade493280ab5b9" translate="yes" xml:space="preserve">
          <source>Module ropes</source>
          <target state="translated">模块绳索</target>
        </trans-unit>
        <trans-unit id="791fafc4980538594d1205be2e024d8f062a8ef6" translate="yes" xml:space="preserve">
          <source>Module rst</source>
          <target state="translated">模块rst</target>
        </trans-unit>
        <trans-unit id="e62ac437c8e15e65ba3f4a9ec5166f39349d24d8" translate="yes" xml:space="preserve">
          <source>Module rstast</source>
          <target state="translated">模块rstast</target>
        </trans-unit>
        <trans-unit id="71d839f9565a57347512e1bcb1209ad6ecbd1571" translate="yes" xml:space="preserve">
          <source>Module rstgen</source>
          <target state="translated">模块rstgen</target>
        </trans-unit>
        <trans-unit id="64202e11eebaa8fdc9db2592feeeca4f21b321b4" translate="yes" xml:space="preserve">
          <source>Module rtarrays</source>
          <target state="translated">模块rtarrays</target>
        </trans-unit>
        <trans-unit id="34de3c41db61af2ec348412e142cf1de55f30e2c" translate="yes" xml:space="preserve">
          <source>Module scgi</source>
          <target state="translated">模块scgi</target>
        </trans-unit>
        <trans-unit id="9d18a075abac676c24c84bba7822fb5ce2702cec" translate="yes" xml:space="preserve">
          <source>Module scope</source>
          <target state="translated">模块范围</target>
        </trans-unit>
        <trans-unit id="b6a250923bc9b9d586fc748c435010dc3db2a298" translate="yes" xml:space="preserve">
          <source>Module segfaults</source>
          <target state="translated">模块隔离故障</target>
        </trans-unit>
        <trans-unit id="8208cbe439f9b79060081af450aa66cdb0a714b6" translate="yes" xml:space="preserve">
          <source>Module selectors</source>
          <target state="translated">模块选择器</target>
        </trans-unit>
        <trans-unit id="23026b5c559a2292c7babd2476fc9f08c5816964" translate="yes" xml:space="preserve">
          <source>Module sequtils</source>
          <target state="translated">模块化附件</target>
        </trans-unit>
        <trans-unit id="c3ea468cd06b16c0644d2bacc8da61f318bab4bb" translate="yes" xml:space="preserve">
          <source>Module sets</source>
          <target state="translated">模块组</target>
        </trans-unit>
        <trans-unit id="a16a3e9b2eb88fe04764ed85fb0218873cc38566" translate="yes" xml:space="preserve">
          <source>Module sexp</source>
          <target state="translated">模块sexp</target>
        </trans-unit>
        <trans-unit id="59d0872f6bd60a77e18aa4238e904f432277b85d" translate="yes" xml:space="preserve">
          <source>Module sha1</source>
          <target state="translated">模块sha1</target>
        </trans-unit>
        <trans-unit id="4ece62635ed6e99fbdb3e080b7996745d5c3b1f3" translate="yes" xml:space="preserve">
          <source>Module sharedlist</source>
          <target state="translated">模块共享列表</target>
        </trans-unit>
        <trans-unit id="b5e68bfc8c55fb54fde0c83c3f95af5feaf92c9b" translate="yes" xml:space="preserve">
          <source>Module sharedtables</source>
          <target state="translated">模块共享表</target>
        </trans-unit>
        <trans-unit id="c339964428c500099d3daed6fb8542e3b613f1ef" translate="yes" xml:space="preserve">
          <source>Module smtp</source>
          <target state="translated">模块smtp</target>
        </trans-unit>
        <trans-unit id="ac4edb7026adc886e3dd2c3c0e2fa6b2624eac99" translate="yes" xml:space="preserve">
          <source>Module sockets</source>
          <target state="translated">模块插座</target>
        </trans-unit>
        <trans-unit id="44b9eae64da1d100a47749f8e94861aceb4e1953" translate="yes" xml:space="preserve">
          <source>Module sqlite3</source>
          <target state="translated">模块 sqlite3</target>
        </trans-unit>
        <trans-unit id="8c907d2d3470228660aa0f1c6e876cce39cd9be0" translate="yes" xml:space="preserve">
          <source>Module ssl</source>
          <target state="translated">模块ssl</target>
        </trans-unit>
        <trans-unit id="5dddec2bc7b6889e3d6e4572f0e2abcd568ae642" translate="yes" xml:space="preserve">
          <source>Module stats</source>
          <target state="translated">模块统计</target>
        </trans-unit>
        <trans-unit id="af7ea72f6db5731696a9ec545d89e8dbf5355b5e" translate="yes" xml:space="preserve">
          <source>Module streams</source>
          <target state="translated">模块流</target>
        </trans-unit>
        <trans-unit id="d563539aac0aa375abd30d9cff848fd83c1d6b90" translate="yes" xml:space="preserve">
          <source>Module strformat</source>
          <target state="translated">模块strformat</target>
        </trans-unit>
        <trans-unit id="c5b35d487655735440b1511f4cbcb6212ffb09bf" translate="yes" xml:space="preserve">
          <source>Module strmisc</source>
          <target state="translated">模块strmisc</target>
        </trans-unit>
        <trans-unit id="39a556995953f0750f993afaabbda0fb9aa0c361" translate="yes" xml:space="preserve">
          <source>Module strscans</source>
          <target state="translated">模块strscans</target>
        </trans-unit>
        <trans-unit id="9add54a0554d7d5e3b57ccafbebed36cfff3a00a" translate="yes" xml:space="preserve">
          <source>Module strtabs</source>
          <target state="translated">模块strtabs</target>
        </trans-unit>
        <trans-unit id="2c2fe9377d124f6f70ba53c4aac93232b71c1394" translate="yes" xml:space="preserve">
          <source>Module strutils</source>
          <target state="translated">模块结构</target>
        </trans-unit>
        <trans-unit id="c427c4ed878b917bab65e9b41afb7305c3c93c47" translate="yes" xml:space="preserve">
          <source>Module subexes</source>
          <target state="translated">模块子外</target>
        </trans-unit>
        <trans-unit id="2ff9cf6c55f0b207b0fa1b96a01a770ee71c8eaa" translate="yes" xml:space="preserve">
          <source>Module sugar</source>
          <target state="translated">模块糖</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">模块系统</target>
        </trans-unit>
        <trans-unit id="e9cc05615900094d98054d721ed949701ef00a47" translate="yes" xml:space="preserve">
          <source>Module tables</source>
          <target state="translated">模块表</target>
        </trans-unit>
        <trans-unit id="12b55983071a387f9c09feaf0f6a54c990c5be1d" translate="yes" xml:space="preserve">
          <source>Module terminal</source>
          <target state="translated">模块终端</target>
        </trans-unit>
        <trans-unit id="84ba9986fea98d5aed3aa1e050cd37789056e75a" translate="yes" xml:space="preserve">
          <source>Module that implements a fixed length array whose size is determined at runtime. Note: This is not ready for other people to use!</source>
          <target state="translated">实现固定长度数组的模块,其大小在运行时确定。注意:这还没有准备好让其他人使用。</target>
        </trans-unit>
        <trans-unit id="3b2dabb54c51f17c55a0e6927caa5f742504ae33" translate="yes" xml:space="preserve">
          <source>Module threadpool</source>
          <target state="translated">模块线程池</target>
        </trans-unit>
        <trans-unit id="f92a75aeabfd1c4044569aecab8ccb991701806b" translate="yes" xml:space="preserve">
          <source>Module threads</source>
          <target state="translated">模块线程</target>
        </trans-unit>
        <trans-unit id="fb3625f5ec0037d48d6c0cb336a239dd3b00b7ca" translate="yes" xml:space="preserve">
          <source>Module times</source>
          <target state="translated">模块时间</target>
        </trans-unit>
        <trans-unit id="80fdbaacf746a3cedeab4e5928808c2384a50612" translate="yes" xml:space="preserve">
          <source>Module typeinfo</source>
          <target state="translated">模块类型信息</target>
        </trans-unit>
        <trans-unit id="2b741b4fc7fd10f81b2d720dc6c96f43017249fb" translate="yes" xml:space="preserve">
          <source>Module typetraits</source>
          <target state="translated">模块类型四</target>
        </trans-unit>
        <trans-unit id="9043c86e7cedc7aab24be69a0efdba5ddf0f80e5" translate="yes" xml:space="preserve">
          <source>Module unicode</source>
          <target state="translated">模块unicode</target>
        </trans-unit>
        <trans-unit id="7085badef4953ee4bbceb9688b13d4140b27c724" translate="yes" xml:space="preserve">
          <source>Module unittest</source>
          <target state="translated">模块单元测试</target>
        </trans-unit>
        <trans-unit id="8bbd7d4f48877a7314d216e6ebdb985da4bfafac" translate="yes" xml:space="preserve">
          <source>Module uri</source>
          <target state="translated">模块URI</target>
        </trans-unit>
        <trans-unit id="8a680992d6079b9c0e11b05251fd8f87bfbf1fe8" translate="yes" xml:space="preserve">
          <source>Module winlean</source>
          <target state="translated">模块winlean</target>
        </trans-unit>
        <trans-unit id="d8fdebbbc5615918cb9d798309cb31cd866e4994" translate="yes" xml:space="preserve">
          <source>Module xmldom</source>
          <target state="translated">模块xmldom</target>
        </trans-unit>
        <trans-unit id="f295719f36ed63526a4da7b30de4cad8a8999c32" translate="yes" xml:space="preserve">
          <source>Module xmldomparser</source>
          <target state="translated">模块xmldomparser</target>
        </trans-unit>
        <trans-unit id="634e83af2de2c8fae54f36c85ad255fa78fdc1fe" translate="yes" xml:space="preserve">
          <source>Module xmlparser</source>
          <target state="translated">模块xmlparser</target>
        </trans-unit>
        <trans-unit id="fffc921107774b45b37fb11a2ae26e6c1756df47" translate="yes" xml:space="preserve">
          <source>Module xmltree</source>
          <target state="translated">模块xmltree</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d4bb1d0c8920c90ab574ded6626feabfc7eb5056" translate="yes" xml:space="preserve">
          <source>Modules for JS backend</source>
          <target state="translated">JS后台模块</target>
        </trans-unit>
        <trans-unit id="04ed0b03aed0cadb43ffc6bfd838816a8c42b369" translate="yes" xml:space="preserve">
          <source>Modules like &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;osproc&lt;/code&gt; use the Ansi versions of the Windows API. The default build uses the Unicode version.</source>
          <target state="translated">诸如 &lt;code&gt;os&lt;/code&gt; 和 &lt;code&gt;osproc&lt;/code&gt; 之类的模块使用Windows API的Ansi版本。默认版本使用Unicode版本。</target>
        </trans-unit>
        <trans-unit id="5492a7b7e10ca5189dd3f4f7cd04aaa834acbe84" translate="yes" xml:space="preserve">
          <source>More examples with custom pragmas:</source>
          <target state="translated">更多的例子与自定义实用名词。</target>
        </trans-unit>
        <trans-unit id="02e1b6aeefcbcdce8ddb030e0d03e46f8f19c14b" translate="yes" xml:space="preserve">
          <source>More information: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt;/</source>
          <target state="translated">更多信息：&lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt; /</target>
        </trans-unit>
        <trans-unit id="2fa11c0cc6358778587e65242e73c28f8b0ce69a" translate="yes" xml:space="preserve">
          <source>Most (if not all) modules that use asyncio provide a userArg which is passed on with the events. The type that you set userArg to must be inheriting from &lt;code&gt;RootObj&lt;/code&gt;!</source>
          <target state="translated">大多数使用asyncio的模块（如果不是全部的话）都提供一个userArg，随事件一起传递。您将userArg设置为的类型必须继承自 &lt;code&gt;RootObj&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="3a3648df8257d95dad8a542820feec7313dcffba" translate="yes" xml:space="preserve">
          <source>Most calling conventions exist only for the Windows 32-bit platform.</source>
          <target state="translated">大多数调用惯例只存在于Windows 32位平台。</target>
        </trans-unit>
        <trans-unit id="d682310dcece700c3a8748a725359d19f632cdec" translate="yes" xml:space="preserve">
          <source>Most native Nim types support conversion to strings with the special &lt;code&gt;$&lt;/code&gt; proc. When calling the &lt;code&gt;echo&lt;/code&gt; proc, for example, the built-in stringify operation for the parameter is called:</source>
          <target state="translated">大多数本机Nim类型都支持使用特殊的 &lt;code&gt;$&lt;/code&gt; proc 转换为字符串。例如，在调用 &lt;code&gt;echo&lt;/code&gt; proc时，将调用参数的内置stringify操作：</target>
        </trans-unit>
        <trans-unit id="c330bf74003c40f0baff1596cb0fe1aa69f44229" translate="yes" xml:space="preserve">
          <source>Most often integers are used for counting objects that reside in memory, so &lt;code&gt;int&lt;/code&gt; has the same size as a pointer.</source>
          <target state="translated">大多数情况下，整数用于计数驻留在内存中的对象，因此 &lt;code&gt;int&lt;/code&gt; 与指针的大小相同。</target>
        </trans-unit>
        <trans-unit id="2dcc64ab52a078dbecfc23dc0e106a84a69bd521" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized ordered set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">在未初始化的有序集合的大多数操作都将崩溃在运行时&lt;a href=&quot;system#assert&quot;&gt;断言&lt;/a&gt;在调试版本。您可以在自己的proc中使用此proc来验证传递给proc的有序集是否已正确初始化。例：</target>
        </trans-unit>
        <trans-unit id="b286a20955238c202888cbd22fcba1b32dbb5ccf" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">在未初始化的集中的大部分操作都将崩溃，在运行时&lt;a href=&quot;system#assert&quot;&gt;断言&lt;/a&gt;在调试版本。您可以在自己的proc中使用此proc来验证传递给proc的集合是否已正确初始化。例：</target>
        </trans-unit>
        <trans-unit id="40f1f54ed50170dad3e2a2e1db2410306c0d2895" translate="yes" xml:space="preserve">
          <source>Most procedures raise OSError on error, but some may return &lt;code&gt;-1&lt;/code&gt; or a boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">大多数过程都会在出错时引发OSError，但是有些过程可能返回 &lt;code&gt;-1&lt;/code&gt; 或布尔值 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb5ab88dfbf525d498b45d241a40f2698fed97a" translate="yes" xml:space="preserve">
          <source>Mostly used by the &lt;a href=&quot;tables&quot;&gt;tables&lt;/a&gt; module, it can also be raised by other collection modules like &lt;a href=&quot;sets&quot;&gt;sets&lt;/a&gt; or &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt;.</source>
          <target state="translated">它通常由&lt;a href=&quot;tables&quot;&gt;表&lt;/a&gt;模块使用，也可以由其他集合模块（例如&lt;a href=&quot;sets&quot;&gt;set&lt;/a&gt;或&lt;a href=&quot;strtabs&quot;&gt;strtabs）引发&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ff0881f9033325d1090cbf272495b3ea89cd9ef" translate="yes" xml:space="preserve">
          <source>Move optimization</source>
          <target state="translated">搬迁优化</target>
        </trans-unit>
        <trans-unit id="4406458901a000581b1c862bae39b54d20d9bf38" translate="yes" xml:space="preserve">
          <source>Moves a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised.</source>
          <target state="translated">将目录从&lt;em&gt;源&lt;/em&gt;移动到&lt;em&gt;dest&lt;/em&gt;。如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8a88abf00e872b645596ba5706595492621b50d3" translate="yes" xml:space="preserve">
          <source>Moves a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. Can be used to &lt;span id=&quot;rename-files_1&quot;&gt;rename files&lt;/span&gt;</source>
          <target state="translated">将文件从&lt;em&gt;源&lt;/em&gt;移动到&lt;em&gt;dest&lt;/em&gt;。如果失败，则引发&lt;em&gt;OSError&lt;/em&gt;。可用于&lt;span id=&quot;rename-files_1&quot;&gt;重命名文件&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8720bd922009aac72de226d7d61d6fe73ea2154f" translate="yes" xml:space="preserve">
          <source>Moves the cursor backward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">将光标向后移动&lt;em&gt;计数&lt;/em&gt;列。</target>
        </trans-unit>
        <trans-unit id="5b4f5707c476bf0444f3d7ca4829bce587056960" translate="yes" xml:space="preserve">
          <source>Moves the cursor down by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">将光标向下移动&lt;em&gt;计数&lt;/em&gt;行。</target>
        </trans-unit>
        <trans-unit id="5731b74c9a2498294ab69fa71acf35d7129365e9" translate="yes" xml:space="preserve">
          <source>Moves the cursor forward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">按&lt;em&gt;计数&lt;/em&gt;列向前移动光标。</target>
        </trans-unit>
        <trans-unit id="eb4d28da6332be8ce6373d9d339c7fe48fa23486" translate="yes" xml:space="preserve">
          <source>Moves the cursor up by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">按&lt;em&gt;计数&lt;/em&gt;行向上移动光标。</target>
        </trans-unit>
        <trans-unit id="78732a3d2d5bc767bacb10d82e232dfa8d87404f" translate="yes" xml:space="preserve">
          <source>Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.</source>
          <target state="translated">就像属相一样,概念对于每个被测试的类型只被实例化一次,任何包含在主体中的静态代码只被执行一次。</target>
        </trans-unit>
        <trans-unit id="1d5f2fd6e9c15080786fa9fc4a690a2cc1e48b6a" translate="yes" xml:space="preserve">
          <source>Multi-line procedure calls should continue on the same column as the opening parenthesis (like multi-line procedure declarations).</source>
          <target state="translated">多行过程调用应在与开头括号相同的列上继续(像多行过程声明一样)。</target>
        </trans-unit>
        <trans-unit id="9254f56fa866823471402ac94c86d60cd0bf7ec3" translate="yes" xml:space="preserve">
          <source>Multi-methods</source>
          <target state="translated">Multi-methods</target>
        </trans-unit>
        <trans-unit id="f038ab50dbba14467b3f2d54ae4453034bd4e0b4" translate="yes" xml:space="preserve">
          <source>Multicast address.</source>
          <target state="translated">多播地址。</target>
        </trans-unit>
        <trans-unit id="7eef768291d80681527aa60e3df38506cba1a219" translate="yes" xml:space="preserve">
          <source>Multicast global address.</source>
          <target state="translated">多播全局地址。</target>
        </trans-unit>
        <trans-unit id="48369fed2a551361b8045057023eecff834b5fb1" translate="yes" xml:space="preserve">
          <source>Multicast link-local address.</source>
          <target state="translated">多播链路本地地址。</target>
        </trans-unit>
        <trans-unit id="24dcc40f5a40c25ac2feb7b6c8089ae89a9733cc" translate="yes" xml:space="preserve">
          <source>Multicast node-local address.</source>
          <target state="translated">多播节点本地地址。</target>
        </trans-unit>
        <trans-unit id="7b7ea2cc81efabb6fd79723109a63d77b71fcdc4" translate="yes" xml:space="preserve">
          <source>Multicast organization-local address.</source>
          <target state="translated">多播组织-本地地址。</target>
        </trans-unit>
        <trans-unit id="3867c8b804a55ef6500439f739768f84c270b65d" translate="yes" xml:space="preserve">
          <source>Multicast site-local address.</source>
          <target state="translated">多播站点本地地址。</target>
        </trans-unit>
        <trans-unit id="d8164f83c1acb0822b6c1157de32950f13f00bf8" translate="yes" xml:space="preserve">
          <source>Multiline comments</source>
          <target state="translated">多线评论</target>
        </trans-unit>
        <trans-unit id="64ad927c3d1f8a60b8de3a4dcfa11cb5f9ed2b35" translate="yes" xml:space="preserve">
          <source>Multiline comments are started with &lt;code&gt;#[&lt;/code&gt; and terminated with &lt;code&gt;]#&lt;/code&gt;. Multiline comments can also be nested.</source>
          <target state="translated">多行注释以 &lt;code&gt;#[&lt;/code&gt; 开头，并以 &lt;code&gt;]#&lt;/code&gt; 结尾。多行注释也可以嵌套。</target>
        </trans-unit>
        <trans-unit id="51b13e7abf733936d7df1349e642855933b8c93f" translate="yes" xml:space="preserve">
          <source>Multiline comments support nesting:</source>
          <target state="translated">多行注释支持嵌套。</target>
        </trans-unit>
        <trans-unit id="d8b83fc7a7727ea41499ff067b6d0dbb7149942a" translate="yes" xml:space="preserve">
          <source>Multiline documentation comments also exist and support nesting too:</source>
          <target state="translated">多行文档注释也存在,也支持嵌套。</target>
        </trans-unit>
        <trans-unit id="cbf27a3ccf0fd00bcb0f6850421450358a6cae08" translate="yes" xml:space="preserve">
          <source>Multimedia support</source>
          <target state="translated">多媒体支持</target>
        </trans-unit>
        <trans-unit id="09f3196845a8359a6ecedfa5af3141e1edccd739" translate="yes" xml:space="preserve">
          <source>Multiple arguments can be used.</source>
          <target state="translated">可以使用多个参数。</target>
        </trans-unit>
        <trans-unit id="a89c998a8939bd86eba71a1abb06f5d85c817883" translate="yes" xml:space="preserve">
          <source>Multiplies in place a floating point number</source>
          <target state="translated">将一个浮点数相乘</target>
        </trans-unit>
        <trans-unit id="fcd886e69a9b9ba9f155b8a7f1e41875370c7b1d" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;x&lt;/em&gt; with &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">乘&lt;em&gt;X&lt;/em&gt;与&lt;em&gt;Y ^&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e2f2f1bb918524a79ef38752dea6ec686cd665c1" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">乘&lt;em&gt;&amp;Yuml;&lt;/em&gt;至&lt;em&gt;X&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cf4b7cc064435e9b222c2ae1ef88a90049e33ef7" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;y&lt;/em&gt;乘以复数&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="967a2a96e493c3fa19de6d580534df7c563be46e" translate="yes" xml:space="preserve">
          <source>Multiply a duration by some scalar.</source>
          <target state="translated">将持续时间乘以某个标量。</target>
        </trans-unit>
        <trans-unit id="3992914db890fb69ae7d33ac0b14f1598d61248c" translate="yes" xml:space="preserve">
          <source>Multiply complex &lt;em&gt;x&lt;/em&gt; with float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将复数&lt;em&gt;x&lt;/em&gt;与浮点&lt;em&gt;y&lt;/em&gt;相乘。</target>
        </trans-unit>
        <trans-unit id="1b5c2c91504b80f3c83b9e589314371f1f27f89a" translate="yes" xml:space="preserve">
          <source>Multiply float &lt;em&gt;x&lt;/em&gt; with complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将float &lt;em&gt;x&lt;/em&gt;与&lt;em&gt;y&lt;/em&gt;相乘。</target>
        </trans-unit>
        <trans-unit id="0476878c0b1cabcde1afe8aa70cf6a429753af27" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;x&lt;/em&gt; with rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">将int &lt;em&gt;x&lt;/em&gt;与有理&lt;em&gt;y&lt;/em&gt;相乘。</target>
        </trans-unit>
        <trans-unit id="10cf9524fcce1f51fd3027d067a68e18439d699b" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">将&lt;em&gt;y&lt;/em&gt;乘以有理数&lt;em&gt;x&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bfb40c2a917440a979a3937c83ab1838a96e6061" translate="yes" xml:space="preserve">
          <source>Multiply rational &lt;em&gt;x&lt;/em&gt; with int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">有理&lt;em&gt;x&lt;/em&gt;与int &lt;em&gt;y&lt;/em&gt;相乘。</target>
        </trans-unit>
        <trans-unit id="be6d2d49f08d8ce52cada7a4e40308b84089a378" translate="yes" xml:space="preserve">
          <source>Multiply rationals &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">有理数乘法&lt;em&gt;&amp;Yuml;&lt;/em&gt;至&lt;em&gt;X&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="407f3e6e72365b49bada1f7c9b2babeb3f8c1e8f" translate="yes" xml:space="preserve">
          <source>Multiply two rational numbers.</source>
          <target state="translated">将两个有理数相乘。</target>
        </trans-unit>
        <trans-unit id="57d62a44db1dbaaab6871e35242edd989b03aa79" translate="yes" xml:space="preserve">
          <source>Mutually recursive types</source>
          <target state="translated">相互递归类型</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="c83bf68eaf2532d248d1885057b7fe59c910abf7" translate="yes" xml:space="preserve">
          <source>Name of the test suite that contains this test case. Can be &lt;code&gt;nil&lt;/code&gt; if the test case is not in a suite.</source>
          <target state="translated">包含此测试用例的测试套件的名称。如果测试用例不在套件中，则可以 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">已命名的参数</target>
        </trans-unit>
        <trans-unit id="dc74246cc093982dca8a3a3f276b5d8b65d59486" translate="yes" xml:space="preserve">
          <source>Named pipe, or FIFO.</source>
          <target state="translated">名管,或称FIFO。</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">命名惯例</target>
        </trans-unit>
        <trans-unit id="c6c5f0ef33b66371fc9992be0b7555afe7072e1f" translate="yes" xml:space="preserve">
          <source>Naming scheme</source>
          <target state="translated">命名方案</target>
        </trans-unit>
        <trans-unit id="9a732a9b195778d45aff4c029836d8016c6d092a" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last access.</source>
          <target state="translated">纳秒级的最后访问时间。</target>
        </trans-unit>
        <trans-unit id="44a8ea231c9b25a28c6b1bae13f6d58d8ab769bb" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last data modification.</source>
          <target state="translated">上次数据修改的纳秒级时间。</target>
        </trans-unit>
        <trans-unit id="ac4471c1eac2668f96fa75ca630c4f282bc0b52a" translate="yes" xml:space="preserve">
          <source>Nanoseconds display</source>
          <target state="translated">纳秒显示</target>
        </trans-unit>
        <trans-unit id="8b8960e4540a492b4c2ade7385f3643ce326ec71" translate="yes" xml:space="preserve">
          <source>Natural log of the gamma function</source>
          <target state="translated">伽马函数的自然对数</target>
        </trans-unit>
        <trans-unit id="40ae5bdaf41bbc2df0ddd3ba6cd0e29b307d851a" translate="yes" xml:space="preserve">
          <source>Navigation through the FTP server's directories.</source>
          <target state="translated">在FTP服务器的目录中导航。</target>
        </trans-unit>
        <trans-unit id="b5c25dae4dbbde41bb6194a297db2a60c41076f4" translate="yes" xml:space="preserve">
          <source>Negated version of &lt;em&gt;is&lt;/em&gt;. Equivalent to &lt;code&gt;not(x is y)&lt;/code&gt;.</source>
          <target state="translated">的否定版本&lt;em&gt;为&lt;/em&gt;。等效于 &lt;code&gt;not(x is y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c0ca5089d3b83be1bafc4d4d1a8a2d03a288270" translate="yes" xml:space="preserve">
          <source>Neither inline nor closure iterators can be recursive.</source>
          <target state="translated">内联和闭包迭代器都不能递归。</target>
        </trans-unit>
        <trans-unit id="0db36e51e26b9948538aa75241b28b52b8a7c448" translate="yes" xml:space="preserve">
          <source>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">未经特定的事先书面许可,不得使用剑桥大学的名称或其贡献者的姓名来认可或推广本软件的衍生产品。</target>
        </trans-unit>
        <trans-unit id="d050b1bc6d5102e8c3c43e52f8c2bc1d471d35c1" translate="yes" xml:space="preserve">
          <source>Network Programming and Internet Protocols</source>
          <target state="translated">网络编程和互联网协议</target>
        </trans-unit>
        <trans-unit id="171eece6964ab33a2181793b80b9e480760fd86a" translate="yes" xml:space="preserve">
          <source>Never used by PCRE itself</source>
          <target state="translated">PCRE本身从未使用过</target>
        </trans-unit>
        <trans-unit id="17c5fe945bffa6ac038aff7b2982abfca0575621" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;AsyncEvent&lt;/code&gt; object is not automatically registered with dispatcher like &lt;code&gt;AsyncSocket&lt;/code&gt;.</source>
          <target state="translated">新的 &lt;code&gt;AsyncEvent&lt;/code&gt; 对象不会自动向 &lt;code&gt;AsyncSocket&lt;/code&gt; 之类的调度程序注册。</target>
        </trans-unit>
        <trans-unit id="28d212a8c45cffe38583de7b76bc156d6b77f1fb" translate="yes" xml:space="preserve">
          <source>New data is written into the future stream.</source>
          <target state="translated">新的数据被写入未来流。</target>
        </trans-unit>
        <trans-unit id="567bb6ab39291d029af6c28280c594e2fe015993" translate="yes" xml:space="preserve">
          <source>New nil literal shortcut</source>
          <target state="translated">新的 &quot;无 &quot;字形快捷键</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="7793ecd2f1c81dc748001f595a446d07a21dca61" translate="yes" xml:space="preserve">
          <source>Nim Backend Integration</source>
          <target state="translated">Nim后端集成</target>
        </trans-unit>
        <trans-unit id="16df2910cd311102e24b9deaaab6834d4ce68a59" translate="yes" xml:space="preserve">
          <source>Nim Compiler</source>
          <target state="translated">Nim编译器</target>
        </trans-unit>
        <trans-unit id="21f8909f95c6aa6f948aea798f908963482f9a9e" translate="yes" xml:space="preserve">
          <source>Nim Compiler User Guide</source>
          <target state="translated">Nim编译器用户指南</target>
        </trans-unit>
        <trans-unit id="4e729000a4923f3f92aa9b54b57cd9d13b461a42" translate="yes" xml:space="preserve">
          <source>Nim DocGen Tools Guide</source>
          <target state="translated">Nim DocGen工具指南</target>
        </trans-unit>
        <trans-unit id="3e73c9c60a5f0a7a9de0b9e82a823b0e9e25a26d" translate="yes" xml:space="preserve">
          <source>Nim Documentation</source>
          <target state="translated">Nim文件</target>
        </trans-unit>
        <trans-unit id="f6faadf36850555183f2e6623ce564cd582735b7" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1</source>
          <target state="translated">Nim增强提案#1</target>
        </trans-unit>
        <trans-unit id="a017c7a8f194b967e2353a197aaf8085c32d102d" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1 - Standard Library Style Guide</source>
          <target state="translated">Nim增强提案#1--标准图书馆风格指南</target>
        </trans-unit>
        <trans-unit id="088e91f2731d3d61908df7c6c9c0f48f04e35180" translate="yes" xml:space="preserve">
          <source>Nim IDE Integration Guide</source>
          <target state="translated">Nim IDE集成指南</target>
        </trans-unit>
        <trans-unit id="ff5833e01f31589edf6457bc7ab5ad35afc09f25" translate="yes" xml:space="preserve">
          <source>Nim Manual</source>
          <target state="translated">Nim手册</target>
        </trans-unit>
        <trans-unit id="a5cb0d9617774a42fc73cf0e3f868eb3b8c421d4" translate="yes" xml:space="preserve">
          <source>Nim OID support. An OID is a global ID that consists of a timestamp, a unique counter and a random value. This combination should suffice to produce a globally distributed unique ID. This implementation was extracted from the Mongodb interface and it thus binary compatible with a Mongo OID.</source>
          <target state="translated">Nim OID支持。OID是一个全局的ID,它由一个时间戳、一个唯一的计数器和一个随机值组成。这种组合应该足以产生一个全球分布的唯一ID。这个实现是从Mongodb接口中提取的,因此它与Mongo OID二进制兼容。</target>
        </trans-unit>
        <trans-unit id="8afe44256c32445d4aba7446f16d139424f08995" translate="yes" xml:space="preserve">
          <source>Nim Standard Library</source>
          <target state="translated">Nim标准库</target>
        </trans-unit>
        <trans-unit id="322ec21475cb7cfeb95acf76114506a7658630c5" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part I)</source>
          <target state="translated">Nim教程(第一部分</target>
        </trans-unit>
        <trans-unit id="e48ab7d7dac65733835e8b6fac71558fd72d4d0c" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part II)</source>
          <target state="translated">Nim教程(第二部分</target>
        </trans-unit>
        <trans-unit id="ab4a51307d67466d1629dcfcafd64254208d0d47" translate="yes" xml:space="preserve">
          <source>Nim allows &lt;code&gt;.global, compiletime&lt;/code&gt; variables that can be filled by macro invokations across different modules. This feature breaks modularity in a severe way. Plenty of different solutions have been proposed:</source>
          <target state="translated">Nim允许 &lt;code&gt;.global, compiletime&lt;/code&gt; 变量，这些变量可由跨不同模块的宏调用填充。此功能严重破坏了模块性。提出了许多不同的解决方案：</target>
        </trans-unit>
        <trans-unit id="e7723fae5b868ab64bfd1ed4f9d563b3f719c2a6" translate="yes" xml:space="preserve">
          <source>Nim allows user defined operators. An operator is any combination of the following characters:</source>
          <target state="translated">Nim允许用户定义运算符。操作符是以下字符的任意组合。</target>
        </trans-unit>
        <trans-unit id="dec77fd63ea6f3b6392da08312e8457c86c6a4ab" translate="yes" xml:space="preserve">
          <source>Nim allows user-definable operators. Binary operators have 11 different levels of precedence.</source>
          <target state="translated">Nim允许用户定义运算符。二进制运算符有11个不同的优先级。</target>
        </trans-unit>
        <trans-unit id="bb3ac87c3ce8cafa37c2ac5913d2e44f2c0fae11" translate="yes" xml:space="preserve">
          <source>Nim also allows for type classes and regular types to be specified as &lt;span id=&quot;type-constraints_1&quot;&gt;type constraints&lt;/span&gt; of the generic type parameter:</source>
          <target state="translated">Nim还允许将类型类和常规类型指定为通用类型参数的&lt;span id=&quot;type-constraints_1&quot;&gt;类型约束&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="c7367770c702c3c07c0edb5a157905ffed2fb24f" translate="yes" xml:space="preserve">
          <source>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</source>
          <target state="translated">Nim通过不给类分配方法来避免这些问题。Nim中的所有方法都是多方法。我们将在后面看到,多方法与procs的区别只是为了动态绑定。</target>
        </trans-unit>
        <trans-unit id="5fb26fe48597e8b904be37ef641797aa814138fa" translate="yes" xml:space="preserve">
          <source>Nim can also generate &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; code through the &lt;code&gt;js&lt;/code&gt; command.</source>
          <target state="translated">Nim还可以通过 &lt;code&gt;js&lt;/code&gt; 命令生成&lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt;代码。</target>
        </trans-unit>
        <trans-unit id="af85440d1b434e6ec278854daf1f3f305d5ad156" translate="yes" xml:space="preserve">
          <source>Nim code calling the backend</source>
          <target state="translated">调用后台的Nim代码</target>
        </trans-unit>
        <trans-unit id="6b156a5e46fd0f15d386450049ef7bee6965340f" translate="yes" xml:space="preserve">
          <source>Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:</source>
          <target state="translated">Nim代码可以被编译成JavaScript。然而为了编写与JavaScript兼容的代码,你应该记住以下几点。</target>
        </trans-unit>
        <trans-unit id="0c9fa29ab6035f83a6a5d536db8f22202827f364" translate="yes" xml:space="preserve">
          <source>Nim code can interface with the backend through the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;Foreign function interface&lt;/a&gt; mainly through the &lt;a href=&quot;manual#importc-pragma&quot;&gt;importc pragma&lt;/a&gt;. The &lt;code&gt;importc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making backend symbols available in Nim and is available in all the target backends (JavaScript too). The C++ or Objective-C backends have their respective &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; and &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragmas to call methods from classes.</source>
          <target state="translated">Nim代码可以通过&lt;a href=&quot;manual#foreign-function-interface&quot;&gt;外部功能接口（&lt;/a&gt;主要通过&lt;a href=&quot;manual#importc-pragma&quot;&gt;importc编译指示）&lt;/a&gt;与后端进行接口。该 &lt;code&gt;importc&lt;/code&gt; 编译是&lt;em&gt;通用&lt;/em&gt;让位于稔提供后端符号的方式，是所有目标后端可用（JavaScript的太）。 C ++或Objective-C后端具有各自的&lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt;和&lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt;编译指示，可以从类中调用方法。</target>
        </trans-unit>
        <trans-unit id="31a93bb37537ccf8bc65c227c96a067156777ba9" translate="yes" xml:space="preserve">
          <source>Nim code renderer (AST back to its textual form)</source>
          <target state="translated">Nim代码渲染器(AST恢复到文本形式)</target>
        </trans-unit>
        <trans-unit id="fabc8c2c3d55b64590195b71fee1f8bf15a0783b" translate="yes" xml:space="preserve">
          <source>Nim condition variable</source>
          <target state="translated">Nim条件变量</target>
        </trans-unit>
        <trans-unit id="d2f3eed8f027ae703cfbb62e68bece8443bf88e7" translate="yes" xml:space="preserve">
          <source>Nim contains a sophisticated compile-time evaluator, so procedures which have no side-effect can be used in constant expressions too:</source>
          <target state="translated">Nim 包含了一个复杂的编译时评估器,所以没有副作用的过程也可以用在常量表达式中。</target>
        </trans-unit>
        <trans-unit id="5a84a384a071f2c590cf4715be4dfac5778bd58a" translate="yes" xml:space="preserve">
          <source>Nim contains language features that are &lt;em&gt;global&lt;/em&gt;. The best example for that are multi methods: Introducing a new method with the same name and some compatible object parameter means that the method's dispatcher needs to take the new method into account. So the dispatching logic is only completely known after the whole program has been translated!</source>
          <target state="translated">Nim包含&lt;em&gt;全球&lt;/em&gt;语言功能。最好的示例是多种方法：引入具有相同名称和兼容对象参数的新方法意味着该方法的调度程序需要考虑新方法。因此，只有在翻译了整个程序之后，才能完全知道调度逻辑！</target>
        </trans-unit>
        <trans-unit id="fc85ea062290958c11ff84b074507e523841a2ee" translate="yes" xml:space="preserve">
          <source>Nim coroutines implementation supports several context switching methods: ucontext: available on unix and alike (default) setjmp: available on unix and alike (x86/64 only) Fibers: available and required on windows.</source>
          <target state="translated">Nim coroutines的实现支持几种上下文切换方法:ucontext:在unix和alike上可用(默认)setjmp:在unix和alike上可用(仅x86/64)Fibers:在windows上可用且需要。</target>
        </trans-unit>
        <trans-unit id="bd26dc8c514bd37794fcd3b5dc3270d84d36b348" translate="yes" xml:space="preserve">
          <source>Nim currently generates &lt;em&gt;async/await&lt;/em&gt; JavaScript code which is supported in modern EcmaScript and most modern versions of browsers, Node.js and Electron. If you need to use this module with older versions of JavaScript, you can use a tool that backports the resulting JavaScript code, as babel.</source>
          <target state="translated">Nim当前生成&lt;em&gt;异步/等待&lt;/em&gt; JavaScript代码，现代EcmaScript和大多数现代版本的浏览器Node.js和Electron都支持该代码。如果需要将此模块与旧版JavaScript一起使用，可以使用将生成的JavaScript代码反向移植为babel的工具。</target>
        </trans-unit>
        <trans-unit id="9bb9f4917308e21a1a3ea298a44a71e622ad4adc" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;idetools&lt;/code&gt; command of &lt;a href=&quot;nimc&quot;&gt;the compiler&lt;/a&gt;, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim与许多其他编译器的不同之处在于，它的确非常快，而且速度如此之快使其适合为文本编辑器提供有关所编写源代码的外部查询。通过&lt;a href=&quot;nimc&quot;&gt;编译器&lt;/a&gt;的 &lt;code&gt;idetools&lt;/code&gt; 命令，任何IDE都可以查询 &lt;code&gt;.nim&lt;/code&gt; 源文件，并获取有用的信息，例如符号定义或完成建议。</target>
        </trans-unit>
        <trans-unit id="5f7c9cacf76b4e6e9b8bdb4149ed42fa0f2b0f03" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim与许多其他编译器的不同之处在于，它的确非常快，而且速度如此之快使其适合为文本编辑器提供有关所编写源代码的外部查询。通过 &lt;code&gt;nimsuggest&lt;/code&gt; 工具，任何IDE都可以查询 &lt;code&gt;.nim&lt;/code&gt; 源文件并获得有用的信息，例如符号定义或完成建议。</target>
        </trans-unit>
        <trans-unit id="2086951d5e25c94d3bcd3c946d696aab645c5e42" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects in a garbage collected heap, untraced references point to manually allocated objects or to objects elsewhere in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (e.g., accessing the hardware), untraced references are necessary.</source>
          <target state="translated">Nim区分&lt;span id=&quot;traced_1&quot;&gt;跟踪&lt;/span&gt;引用和未&lt;span id=&quot;untraced_1&quot;&gt;跟踪&lt;/span&gt;引用。未跟踪的引用也称为&lt;em&gt;指针&lt;/em&gt;。跟踪引用指向垃圾回收堆中的对象，未跟踪引用指向手动分配的对象或内存中其他位置的对象。因此，未跟踪的引用是&lt;em&gt;不安全的&lt;/em&gt;。但是，对于某些低级操作（例如，访问硬件），必须使用未跟踪的引用。</target>
        </trans-unit>
        <trans-unit id="ccd83d27c6d420699215e95b7549c5d18179dd95" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</source>
          <target state="translated">Nim区分&lt;span id=&quot;traced_1&quot;&gt;跟踪&lt;/span&gt;引用和未&lt;span id=&quot;untraced_1&quot;&gt;跟踪&lt;/span&gt;引用。未跟踪的引用也称为&lt;em&gt;指针&lt;/em&gt;。跟踪引用指向垃圾回收堆的对象，未跟踪引用指向手动分配的对象或内存中其他位置的对象。因此，未跟踪的引用是&lt;em&gt;不安全的&lt;/em&gt;。但是，对于某些低级操作（访问硬件），不可避免的引用是不可避免的。</target>
        </trans-unit>
        <trans-unit id="dac7bba6bc8f19f6387033c2480f36e741751cd5" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;type-casts_1&quot;&gt;type casts&lt;/span&gt; and &lt;span id=&quot;type-conversions_1&quot;&gt;type conversions&lt;/span&gt;. Casts are done with the &lt;code&gt;cast&lt;/code&gt; operator and force the compiler to interpret a bit pattern to be of another type.</source>
          <target state="translated">Nim区分&lt;span id=&quot;type-casts_1&quot;&gt;类型转换&lt;/span&gt;和&lt;span id=&quot;type-conversions_1&quot;&gt;类型转换&lt;/span&gt;。强制类型转换与完成 &lt;code&gt;cast&lt;/code&gt; 操作和强制编译器解释的位模式是另一种类型。</target>
        </trans-unit>
        <trans-unit id="0dc26f37589711a4ebd6a75d29c4f31d6f5268ca" translate="yes" xml:space="preserve">
          <source>Nim documentation tools</source>
          <target state="translated">Nim文档工具</target>
        </trans-unit>
        <trans-unit id="32a303beaf961d29337f0ffeb398d9c829260321" translate="yes" xml:space="preserve">
          <source>Nim expression</source>
          <target state="translated">Nim表情</target>
        </trans-unit>
        <trans-unit id="835ecda86802386305ce589edd8369f0e4a635cf" translate="yes" xml:space="preserve">
          <source>Nim file input</source>
          <target state="translated">Nim文件输入</target>
        </trans-unit>
        <trans-unit id="07b88f09d9e474dda1eb0ea8c1cc96c629f4c605" translate="yes" xml:space="preserve">
          <source>Nim for embedded systems</source>
          <target state="translated">嵌入式系统的Nim</target>
        </trans-unit>
        <trans-unit id="a0e42e450f6ef10bfc996fbef965403967ca2952" translate="yes" xml:space="preserve">
          <source>Nim for realtime systems</source>
          <target state="translated">实时系统的Nim</target>
        </trans-unit>
        <trans-unit id="ad31881a208f486ef9ab2bb940bdcd789a709ad9" translate="yes" xml:space="preserve">
          <source>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</source>
          <target state="translated">Nim会产生一些警告和提示(&quot;行太长&quot;),这些警告和提示可能会让用户感到厌烦。我们提供了一个禁用某些信息的机制。每条提示和警告信息都包含一个括号内的符号。这是消息的标识符,可以用来启用或禁用它。</target>
        </trans-unit>
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim具有内置线程池，可用于执行CPU密集型任务。对于IO密集型任务，应改为使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 功能。并行和生成都需要&lt;a href=&quot;threadpool&quot;&gt;线程池&lt;/a&gt;模块才能工作。</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim不需要&lt;em&gt;get-properties&lt;/em&gt;：使用&lt;em&gt;方法调用语法调用的&lt;/em&gt;普通get-procedures可以达到相同的目的。但是设置值是不同的。为此，需要特殊的setter语法：</target>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">Nim没有单独的优化器,但生成的C代码非常高效。大多数C编译器都有优秀的优化器,所以通常不需要对自己的代码进行优化。Nim被设计成鼓励高效的代码。Nim中最易读的代码往往也是最高效的代码。</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim有一个全局搜索路径(PATH)的概念,通过查询来确定在哪里可以找到导入的模块或包含的文件。如果找到多个文件就会产生歧义错误。</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">Nim内置了以下浮点类型： &lt;code&gt;float float32 float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">Nim内置以下整数类型： &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Nim有两种口味的平行性。</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">Nim idetools集成</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">从C语言中调用Nim的例子</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">从JavaScript中调用Nim的例子</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">Nim是免费软件；它是根据&lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT许可证许可的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">尼姆锁,再入式</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">尼姆锁;这是否为重入者,未作说明!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">Nim维护脚本</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim提供了一个特殊的点运算符系列,可用于拦截和重写proc调用和字段访问尝试,引用之前未声明的符号名。它们可用于为类型系统静态限制之外的对象提供流畅的接口,例如来自动态脚本语言或动态文件格式(如JSON或XML)的值。</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim提供了与目标后端的双向接口。这意味着你可以调用Nim的后端代码,而Nim代码也可以被后端代码调用。通常哪种调用方向取决于你的软件架构(Nim是你的主程序还是Nim提供的组件)。</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim为未导出和未使用的符号产生警告。在 &lt;code&gt;used&lt;/code&gt; 编译可以连接到一个符号来禁止这种警告。当符号由宏生成时，这特别有用：</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim通过idetools命令与外部IDE进行语言集成。有关更多信息，请参见&lt;a href=&quot;idetools&quot;&gt;idetool&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim提供了&lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt;和&lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt;命令，用于从 &lt;code&gt;.nim&lt;/code&gt; 源文件生成HTML文档。仅导出的符号将出现在输出中。有关更多详细信息，&lt;a href=&quot;docgen&quot;&gt;请参阅docgen文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim提供了类似于C++的重载过程的能力。</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim提供了编译指示&lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt;和&lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt;来控制是否忽略IEEE异常或捕获Nim异常：</target>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Nim搜索和替换工具。</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim通过额外的实用工具,显著提高了这些功能的安全性。</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">Nim支持&lt;span id=&quot;substitution-expressions_1&quot;&gt;替换表达式&lt;/span&gt;（&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;）。</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim支持异常跟踪。所述&lt;span id=&quot;raises_1&quot;&gt;引发&lt;/span&gt;编译指示可用于显式地定义一个PROC /迭代器/方法/转换器被允许提高哪些异常。编译器对此进行验证：</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim支持通过模块概念将程序拆分为多个部分。每个模块都必须位于其自己的文件中并具有自己的&lt;span id=&quot;namespace_1&quot;&gt;名称空间&lt;/span&gt;。模块使&lt;span id=&quot;information-hiding_1&quot;&gt;信息隐藏&lt;/span&gt;和&lt;span id=&quot;separate-compilation_1&quot;&gt;单独的编译成为可能&lt;/span&gt;。一个模块可以通过&lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt;语句访问另一个模块的符号。允许&lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;递归模块依赖性&lt;/span&gt;，但有些微妙。仅导出带有星号（ &lt;code&gt;*&lt;/code&gt; ）的顶级符号。有效的模块名称只能是有效的Nim标识符（因此，其文件名是 &lt;code&gt;identifier.nim&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim支持使用模块概念将程序拆分为多个部分。每个模块都在其自己的文件中。模块使&lt;span id=&quot;information-hiding_1&quot;&gt;信息隐藏&lt;/span&gt;和&lt;span id=&quot;separate-compilation_1&quot;&gt;单独的编译成为可能&lt;/span&gt;。一个模块可以通过使用&lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt;语句来访问另一个模块的符号。仅导出带有星号（ &lt;code&gt;*&lt;/code&gt; ）的顶级符号：</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim支持DLL的生成。但是，每个进程/地址空间只能有一个GC实例。该实例包含在 &lt;code&gt;nimrtl.dll&lt;/code&gt; 中。这意味着每个生成的Nim DLL都依赖于 &lt;code&gt;nimrtl.dll&lt;/code&gt; 。要生成&amp;ldquo; nimrtl.dll&amp;rdquo;文件，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim支持以下&lt;span id=&quot;calling-conventions_1&quot;&gt;调用约定&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim的目标是任何广泛使用的浏览器都支持的JavaScript 1.5。由于JavaScript没有可移植的方式来包含另一个模块，因此Nim只会生成一个长的 &lt;code&gt;.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">Nim型</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim对大多数类型使用结构类型对等。仅对对象，枚举和不同类型使用名称等效。以下算法&lt;em&gt;以伪代码&lt;/em&gt;确定类型相等：</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Nim使用经典的编译器架构。一个词库/扫描器将标记传送给一个解析器。解析器建立一个语法树,供代码生成器使用。这个语法树是解析器和代码生成器之间的接口。它对于理解编译器的大部分代码是必不可少的。</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Nim使用常见的语句/表达式范式:与表达式相比,语句不产生值。然而,有些表达式就是语句。</target>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">尼姆的垃圾收集器</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">Nim的 &lt;code&gt;import&lt;/code&gt; 语句实际上取决于所使用的关键字而有所不同。让我们从最简单的形式开始。</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">Nim的&lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt;（外部功能接口）范围很广，此处仅记录了可扩展到其他将来后端（例如LLVM / JavaScript后端）的部分。</target>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">尼姆的垃圾收集器</target>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">Nim的布尔类型称为 &lt;code&gt;bool&lt;/code&gt; ，由两个预定义值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 组成。while，if，elif和when语句的条件必须为bool类型。</target>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">Nim的线程内存模型与其他通用编程语言（C，Pascal）有很大不同：每个线程都有自己的（收集的垃圾）堆，并且内存共享受到限制。这有助于防止比赛情况并提高效率。有关&lt;a href=&quot;manual#threads&quot;&gt;此内存模型的详细信息，&lt;/a&gt;请参见手册。</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">Nim的线程内存模型与其他常见编程语言(C、Pascal、Java)的内存模型完全不同。每个线程都有自己的(垃圾回收)堆,内存的共享仅限于全局变量。这有助于防止竞赛条件。GC的效率提高了不少,因为GC从来不需要停止其他线程,看看他们引用了什么。内存分配完全不需要锁! 这种设计很容易扩展到正在成为标准的大规模多核处理器上。</target>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">Nim的对象语法非常丰富。让我们完整地看一下一个涉及到的例子,看看其中的一些复杂性。</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">Nim的解析器</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">Nim的标准语法描述了&lt;span id=&quot;indentation-sensitive_1&quot;&gt;缩进敏感&lt;/span&gt;语言。这意味着所有控制结构都可以通过缩进识别。缩进仅由空格组成；制表符是不允许的。</target>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">Nim的标准随机数生成器。基于 &lt;code&gt;xoroshiro128+&lt;/code&gt; （异或/旋转/移位/旋转）库。</target>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble是Nim编程语言的程序包管理器。有关如何安装Nimble软件包的说明，请参&lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;见其README&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache和C类目标</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache和Javascript目标</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">Nimcache的命名逻辑</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep对Nim的古怪&lt;em&gt;风格不敏感&lt;/em&gt;特别支持。除此之外，它是一个通用的文本处理工具。</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep是用于搜索和替换任务的命令行工具。它可以搜索正则表达式或固定模式，并且可以一次搜索整个目录。可以要求用户确认每一个替换操作。</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">支持IDE的Nimsuggest</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">Nimsuggest调用</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">Nimsuggest是Nim核心的一部分。通过构建它。</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Nimsuggest输出始终在由制表符（ &lt;code&gt;\t&lt;/code&gt; ）分隔的单行上返回。每列的值为：</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">最好比等待查询处理。查询由一个隐含的3个字母的&amp;ldquo;命令&amp;rdquo; &lt;code&gt;def&lt;/code&gt; 或 &lt;code&gt;con&lt;/code&gt; 或 &lt;code&gt;sug&lt;/code&gt; 或 &lt;code&gt;use&lt;/code&gt; 组成,后跟一个位置。查询位置包括：</target>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">如果找不到与查询位置相匹配的有效符号,Nimsuggest总是以单一定义或无定义来回答。</target>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">不再实际使用</target>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">NoDecl pragma</target>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">可以传递非默认定界符，以允许在其他类型的&amp;ldquo;行状&amp;rdquo;可变长度记录上进行迭代。通过吃= '\ 0'是严格&lt;em&gt;DELIM&lt;/em&gt; -delimited。（不支持使用等于'\ 0'的可选前缀。）</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">非打印字符</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">非纯枚举值应该使用camelCase,而纯枚举值应该使用PascalCase。</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">非终端以小写字母开头，抽象的终端符号以大写字母表示。逐字结束符（包括关键字）用 &lt;code&gt;'&lt;/code&gt; 引起来。一个例子：</target>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">从双端队列获得单个值的proc不能用于空双端队列。如果使用&lt;em&gt;boundChecks&lt;/em&gt;选项进行编译，则这些过程将在此类访问时引发&lt;em&gt;IndexError&lt;/em&gt;。不应依赖于此，因为&lt;em&gt;-d：release&lt;/em&gt;将禁用这些检查，并可能返回垃圾或使程序崩溃。</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">非过载内置</target>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">普通符号将添加到索引中，并且周围的空格已删除。目录（TOC）条目是一个例外。将TOC条目添加到索引文件中，其第三列的前缀空间与TOC中的级别一样多（至少1个字符）。前缀空格有助于从API或文本符号中过滤TOC条目。这很重要，因为使用了一定数量的空间来复制最终索引中文档TOC的层次结构，并且会丢弃在 &lt;code&gt;.nim&lt;/code&gt; 文件中找到的TOC条目。</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">归一化路径。</target>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">标准化字符串&lt;em&gt;s&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">不是零注释</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">不支持 &quot;无 &quot;注释。</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">不是谓词</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">不是谓语。如果表达式E与前面的文本匹配,则表示失败;否则表示成功。不消耗任何文本。</target>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">单独使用它不是很有用，您可以使用它来创建&lt;em&gt;倒置&lt;/em&gt;集，以使&lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find（）proc&lt;/a&gt;查找字符串中的&lt;strong&gt;无效&lt;/strong&gt;字符。例：</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">请注意，内置 &lt;code&gt;len&lt;/code&gt; proc 如何仅返回数组的第一维长度。定义 &lt;code&gt;LightTower&lt;/code&gt; 以更好地说明其嵌套性质的另一种方法是，省略之前的 &lt;code&gt;LevelSetting&lt;/code&gt; 类型定义，而直接将其嵌入作为第一维的类型：</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">注意该示例如何包含额外的C代码，以在生成的Nim代码中声明 &lt;code&gt;iupdll&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">请注意， &lt;code&gt;getCurrentException&lt;/code&gt; 始终返回 &lt;code&gt;ref Exception&lt;/code&gt; 类型。如果需要适当类型的变量（在上面的示例中， &lt;code&gt;IOError&lt;/code&gt; ），则必须显式转换它：</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">请注意， &lt;code&gt;import math as m&lt;/code&gt; 不会使用其他节点。相反，我们将 &lt;code&gt;nnkImportStmt&lt;/code&gt; 与 &lt;code&gt;as&lt;/code&gt; 中缀运算符。</target>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">请注意， &lt;code&gt;system.finished&lt;/code&gt; 易于使用，因为它仅在迭代器完成后返回 &lt;code&gt;true&lt;/code&gt; 一次迭代：</target>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;using&lt;/code&gt; 不适用于 &lt;code&gt;template&lt;/code&gt; 因为无类型的模板参数默认为 &lt;code&gt;system.untyped&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">请注意，Nim的扩展原始字符串文字支持语法 &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; 作为 &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">请注意，持续时间可以为负，因此即使 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 为真， &lt;code&gt;a&lt;/code&gt; 仍可能表示更大的绝对持续时间。使用 &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; 比较绝对持续时间。</target>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">请注意，传递给 &lt;code&gt;varargs&lt;/code&gt; 参数的显式数组构造函数不会包装在另一个隐式数组构造中：</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">请注意，此刻返回 &lt;code&gt;proc&lt;/code&gt; 单词是找到方法的签名，而不是预期 &lt;code&gt;method&lt;/code&gt; 的签名。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">请注意，使用单个赋值来声明多个变量来调用过程可能会产生意想不到的结果：编译器将&lt;em&gt;展开&lt;/em&gt;这些赋值并最终多次调用该过程。如果过程的结果取决于副作用，则变量最终可能具有不同的值！为了安全起见，如果进行多次分配，请使用无副作用的程序。</target>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">请注意,上面的第二个或第三个(或两个)参数必须存在,因为编译器需要以某种方式知道类型(它可以从给定的赋值中推断)。</target>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">请注意,对于有连续栈的系统(大多数系统都有),检查ref是否在栈上是非常便宜的(只有两次比较)。</target>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">请注意，在该示例中，构造函数 &lt;code&gt;newLit&lt;/code&gt; 和 &lt;code&gt;newPlus&lt;/code&gt; 是proc，因为使用静态绑定对它们更有意义，而 &lt;code&gt;eval&lt;/code&gt; 是一种方法，因为它需要动态绑定。</target>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">请注意，并非所有 &lt;code&gt;nnkTypeDef&lt;/code&gt; 都将 &lt;code&gt;nnkIdent&lt;/code&gt; 用作其参数。类型声明最常见的用途之一是使用对象。</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">需要注意的是,100或更大的八进制值不能用前导零引入,因为读取的八进制数永远不会超过三位。</target>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">请注意,由于这是一个迭代器,你不应该修改你正在迭代的字符串:可能会发生不好的事情。</target>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">注意， &lt;code&gt;Time&lt;/code&gt; 参数不代表时间点，而是代表当地时间！例如，如果 &lt;code&gt;adjTime&lt;/code&gt; 是 &lt;code&gt;fromUnix(0)&lt;/code&gt; 在00：，它应该被解释为1970-01-01T00：00 &lt;code&gt;zone&lt;/code&gt; 时区，而不是UTC。</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">请注意， &lt;code&gt;importcpp&lt;/code&gt; 变体使用某种神秘的模式语言以实现最大的灵活性：</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">请注意， &lt;code&gt;jsondoc&lt;/code&gt; 命令输出的是JSON而不进行漂亮打印，而 &lt;code&gt;jsondoc0&lt;/code&gt; 输出的是漂亮打印的JSON。</target>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">请注意,一旦设置了编码,就不能更改。根据SQLite3文档,在数据库创建后,任何试图改变编码的行为都将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">请注意，模块名称仍然是 &lt;code&gt;strutils&lt;/code&gt; 而不是 &lt;code&gt;lib/pure/strutils&lt;/code&gt; ，因此&lt;strong&gt;不能&lt;/strong&gt;执行以下操作：</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">注意,模式语言自然也涵盖了C++的运算符重载功能。</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">请注意，正则表达式的行为也不符合预期：在示例中 &lt;code&gt;*&lt;/code&gt; 不应太贪心，因此应使用 &lt;code&gt;\[.*?\]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">请注意，序列将被零位条目填充，这对于包含字符串的序列可能是个问题，因为其值将为 &lt;code&gt;nil&lt;/code&gt; 。创建序列后，您应该为序列分配条目，而不是添加它们。例：</target>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">注意，三角函数自然以弧度为单位。辅助函数&lt;em&gt;degToRad&lt;/em&gt;和&lt;em&gt;radToDeg&lt;/em&gt;提供弧度和度之间的转换。</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">请注意，这些规则可能会有例外。Nim尽可能灵活，该样式指南的某些部分在某些情况下没有意义。此外，正如&lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python的样式指南&lt;/a&gt;会随着时间的推移而变化一样，该样式指南也会更改。</target>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">请注意，这是一个&lt;em&gt;运行时&lt;/em&gt;调用，在宏内使用 &lt;code&gt;quit&lt;/code&gt; 不会产生任何编译时影响。如果需要在宏中停止编译器，请使用&lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;错误&lt;/a&gt;或&lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;致命的&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">请注意,这基本上是Nim中唯一存在的类型推理形式:它是简洁和可读性之间的良好折中。</target>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">请注意,这个pragma有点用词不当。其他后端确实以同样的名称提供同样的功能。</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">请注意，这种杂项有点用词不当：其他后端确实以相同的名称提供了相同的功能。另外，如果与C ++的&lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp编译指示&lt;/a&gt;接口以及与Objective-C的接口，则可以使用&lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">请注意，这需要您的输入和输出类型相同，因为它们是就地修改的。参数函数采用 &lt;code&gt;var T&lt;/code&gt; 类型参数。</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">请注意，这需要您的输入和输出类型相同，因为它们是就地修改的。参数函数接受并返回 &lt;code&gt;T&lt;/code&gt; 类型变量。</target>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">请注意，此版本的 &lt;code&gt;map&lt;/code&gt; 要求您的输入和输出类型相同，因为它们是就地修改的。</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">请注意，类型推断适用于具有默认值的参数。无需编写 &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; 例如，string =&amp;ldquo; unknown&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">请注意,除非定义了最小的字段宽度,否则字段宽度将始终与填充它的数据大小相同,所以在这种情况下,对齐选项没有意义。</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">请注意，未实现无序或有序选择运算符（ &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">请注意，添加月份时，允许月份溢出。这意味着，如果结果月份中没有足够的天数，则该月将递增，而月日将被设置为溢出的天数。因此，在&lt;em&gt;10&lt;/em&gt;月&lt;em&gt;31日之前&lt;/em&gt;增加一个月，将在&lt;em&gt;11月31日&lt;/em&gt;产生结果，在&lt;em&gt;12月1日&lt;/em&gt;将溢出并产生结果。</target>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">需要注意的是,对于多个infix运算符,命令是按照运算符的优先级进行解析的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
