<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="f6aed8cf30d89d1b5f778819ebedc002452ab169" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPure</source>
          <target state="translated">TSpecialWord.wPure</target>
        </trans-unit>
        <trans-unit id="2a9b67e5059e4097ecf36898a14af806e627495c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPush</source>
          <target state="translated">TSpecialWord.wPush</target>
        </trans-unit>
        <trans-unit id="165c068e1820e1d75b4534ad6c24dc64d16d0a36" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaise</source>
          <target state="translated">TSpecialWord.wRaise</target>
        </trans-unit>
        <trans-unit id="5e3d248206d073353634b05ebfd99c3b0babf77c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaises</source>
          <target state="translated">TSpecialWord.wRaises</target>
        </trans-unit>
        <trans-unit id="5a2b8c36797bc435a75f44083c6407c87375542c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRangeChecks</source>
          <target state="translated">TSpecialWord.wRangeChecks</target>
        </trans-unit>
        <trans-unit id="df27e08ee3fc7139bf78856f843294d62733b61a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReads</source>
          <target state="translated">TSpecialWord.wReads</target>
        </trans-unit>
        <trans-unit id="b5ce7ca8962a8b2d8ed038b3f6595e52dddebae2" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRef</source>
          <target state="translated">TSpecialWord.wRef</target>
        </trans-unit>
        <trans-unit id="be048d968653db1d3dc961ae8ebf53bd4c68f166" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRegister</source>
          <target state="translated">TSpecialWord.wRegister</target>
        </trans-unit>
        <trans-unit id="8b80e46864ec623fa9e8f5475e2541099b188af8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReinterpret_cast</source>
          <target state="translated">TSpecialWord.wReinterpret_cast</target>
        </trans-unit>
        <trans-unit id="7d8b98c8733ff1965441d54cd8cc78a95436d313" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReorder</source>
          <target state="translated">TSpecialWord.wReorder</target>
        </trans-unit>
        <trans-unit id="032050ad9efa5acd958a6511df599471d8cb2c74" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequires</source>
          <target state="translated">TSpecialWord.wRequires</target>
        </trans-unit>
        <trans-unit id="d3dffc73a1d96c3d802b32eb7e39ddc139958219" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequiresInit</source>
          <target state="translated">TSpecialWord.wRequiresInit</target>
        </trans-unit>
        <trans-unit id="543fd2e5c16f6bff5a0bb30047bfc1189d31acaf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRestrict</source>
          <target state="translated">TSpecialWord.wRestrict</target>
        </trans-unit>
        <trans-unit id="3e374bb07c496ab290d5cebb03264be429060f1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReturn</source>
          <target state="translated">TSpecialWord.wReturn</target>
        </trans-unit>
        <trans-unit id="cbf79c4fe8fd77f4412e027be0ff8ee2d47696e5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecall</source>
          <target state="translated">TSpecialWord.wSafecall</target>
        </trans-unit>
        <trans-unit id="d24950f44da9648166edc152a3ab956b5f6f6c1a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecode</source>
          <target state="translated">TSpecialWord.wSafecode</target>
        </trans-unit>
        <trans-unit id="98d95ab8a2424b472a9ba50754608cd2297953b7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShallow</source>
          <target state="translated">TSpecialWord.wShallow</target>
        </trans-unit>
        <trans-unit id="2b2a65bacbe207841c53d73ad99699011a3ae136" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShl</source>
          <target state="translated">TSpecialWord.wShl</target>
        </trans-unit>
        <trans-unit id="4a6bac00c52ffed152558dd3c086e472cf6cb3c6" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShort</source>
          <target state="translated">TSpecialWord.wShort</target>
        </trans-unit>
        <trans-unit id="dfb5bbf53d2e54bbe729b7e92403cdb823eb2b0c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShr</source>
          <target state="translated">TSpecialWord.wShr</target>
        </trans-unit>
        <trans-unit id="236e385d070b2597fdea7ced17163542a3f4d1c8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSideEffect</source>
          <target state="translated">TSpecialWord.wSideEffect</target>
        </trans-unit>
        <trans-unit id="9fa842e819283837867308a0207f383cafd19b3e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSigned</source>
          <target state="translated">TSpecialWord.wSigned</target>
        </trans-unit>
        <trans-unit id="27a8834c59f9ad98925bf00dc917db1852a27299" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSinkInference</source>
          <target state="translated">TSpecialWord.wSinkInference</target>
        </trans-unit>
        <trans-unit id="b00ad10e6017e9de11489ae00852840ef13fd225" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSize</source>
          <target state="translated">TSpecialWord.wSize</target>
        </trans-unit>
        <trans-unit id="67cb4412a3444bae39547e9a844ef819b51e5c7d" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSizeof</source>
          <target state="translated">TSpecialWord.wSizeof</target>
        </trans-unit>
        <trans-unit id="375d1a0f39af91da2e515b2dc881cc48501d5e81" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStackTrace</source>
          <target state="translated">TSpecialWord.wStackTrace</target>
        </trans-unit>
        <trans-unit id="e5bec72d25cba4d87d2c10fecc04697e4741a3f5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStar</source>
          <target state="translated">TSpecialWord.wStar</target>
        </trans-unit>
        <trans-unit id="fa3cff407c086fc0695af06925696dfcdc317e15" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic</source>
          <target state="translated">TSpecialWord.wStatic</target>
        </trans-unit>
        <trans-unit id="9bf7942ea69df57f385d4b9f506f1c877038b349" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStaticBoundchecks</source>
          <target state="translated">TSpecialWord.wStaticBoundchecks</target>
        </trans-unit>
        <trans-unit id="42b65dec3e989eade77bb9dafbc7c5603136b9a4" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_assert</source>
          <target state="translated">TSpecialWord.wStatic_assert</target>
        </trans-unit>
        <trans-unit id="6671b68735c96c610635b2311938beae4174f474" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_cast</source>
          <target state="translated">TSpecialWord.wStatic_cast</target>
        </trans-unit>
        <trans-unit id="7a3ee08adfebd48c3c46780dcafff249ba850cfa" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdErr</source>
          <target state="translated">TSpecialWord.wStdErr</target>
        </trans-unit>
        <trans-unit id="762d8648d881bf250497c16ae7ef71e0f5dc36b8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdIn</source>
          <target state="translated">TSpecialWord.wStdIn</target>
        </trans-unit>
        <trans-unit id="73aaa0ffe071ec1c213dc94616c825c8bfd89d25" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdOut</source>
          <target state="translated">TSpecialWord.wStdOut</target>
        </trans-unit>
        <trans-unit id="2c1652ef3797603ee1016b39ca7d1eaf6a994a64" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdcall</source>
          <target state="translated">TSpecialWord.wStdcall</target>
        </trans-unit>
        <trans-unit id="c84b20a5cb26b59a2c609a6aa076dc00025857ea" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStrDefine</source>
          <target state="translated">TSpecialWord.wStrDefine</target>
        </trans-unit>
        <trans-unit id="49ed6cea4f1b008c45de69c2ff5abf3cf0424c58" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStruct</source>
          <target state="translated">TSpecialWord.wStruct</target>
        </trans-unit>
        <trans-unit id="675cfe4ec331766796865804ca47bbb153bf0155" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStyleChecks</source>
          <target state="translated">TSpecialWord.wStyleChecks</target>
        </trans-unit>
        <trans-unit id="5fa5466ccba7748cd7dbda2f197138204862ea2f" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSubsChar</source>
          <target state="translated">TSpecialWord.wSubsChar</target>
        </trans-unit>
        <trans-unit id="828d45bd46fbb2489a62d5b498cf0a455bcd067b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSwitch</source>
          <target state="translated">TSpecialWord.wSwitch</target>
        </trans-unit>
        <trans-unit id="8ae17bcff106fd30cb7e44426aa7e930ae4a13bf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSyscall</source>
          <target state="translated">TSpecialWord.wSyscall</target>
        </trans-unit>
        <trans-unit id="2c4b7ce46a5d91db3d102fe8d5a6c90ba038aac8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTags</source>
          <target state="translated">TSpecialWord.wTags</target>
        </trans-unit>
        <trans-unit id="8259d5f2948abbbddb4fd282fd77796d6a1e188b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTemplate</source>
          <target state="translated">TSpecialWord.wTemplate</target>
        </trans-unit>
        <trans-unit id="1f8ec32bd5c894b2fb69a2e65aa4eff6d85b2b2c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThis</source>
          <target state="translated">TSpecialWord.wThis</target>
        </trans-unit>
        <trans-unit id="fa09f4d08ebeaa289b05115b03460b2345c5690b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThiscall</source>
          <target state="translated">TSpecialWord.wThiscall</target>
        </trans-unit>
        <trans-unit id="710884f3ea7828d070ac0172eb890ea19137e10b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread</source>
          <target state="translated">TSpecialWord.wThread</target>
        </trans-unit>
        <trans-unit id="a5abf2f68067daf03579eaec46403ce1d4fa3122" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThreadVar</source>
          <target state="translated">TSpecialWord.wThreadVar</target>
        </trans-unit>
        <trans-unit id="3347bce5195eab1d6dbe2e3a70137a6875a1bcd0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread_local</source>
          <target state="translated">TSpecialWord.wThread_local</target>
        </trans-unit>
        <trans-unit id="d38d2534840f4e350de5ea3f4d4dfa93750e0e35" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThrow</source>
          <target state="translated">TSpecialWord.wThrow</target>
        </trans-unit>
        <trans-unit id="a74866bc8c91b482d6c277feb2855538288fc026" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrMacros</source>
          <target state="translated">TSpecialWord.wTrMacros</target>
        </trans-unit>
        <trans-unit id="659906f78c39e51a41596c895c0ccd5fc9211098" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrue</source>
          <target state="translated">TSpecialWord.wTrue</target>
        </trans-unit>
        <trans-unit id="79ea1fcf98460dbb432b5051f2024d63e01bfe2a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTry</source>
          <target state="translated">TSpecialWord.wTry</target>
        </trans-unit>
        <trans-unit id="66986335415d83d7b446a919737a7731a6b47007" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTuple</source>
          <target state="translated">TSpecialWord.wTuple</target>
        </trans-unit>
        <trans-unit id="ccf870e3f2157fa7a58f23b262338a605c4a70c3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wType</source>
          <target state="translated">TSpecialWord.wType</target>
        </trans-unit>
        <trans-unit id="5d241960b2464b1d99ad110a5ab14d6c8c40cb1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypedef</source>
          <target state="translated">TSpecialWord.wTypedef</target>
        </trans-unit>
        <trans-unit id="578fe1dad51eb962bc7100551c55df0d2f910a05" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeid</source>
          <target state="translated">TSpecialWord.wTypeid</target>
        </trans-unit>
        <trans-unit id="4f7fa4c634320c3d0ac7ad82ea04ec56c867b2c0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypename</source>
          <target state="translated">TSpecialWord.wTypename</target>
        </trans-unit>
        <trans-unit id="81789f4e632314e9fc671603cc6f4504cb3d3c7e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeof</source>
          <target state="translated">TSpecialWord.wTypeof</target>
        </trans-unit>
        <trans-unit id="e82424012de52d35e49a0273d3bb8964198190f7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnchecked</source>
          <target state="translated">TSpecialWord.wUnchecked</target>
        </trans-unit>
        <trans-unit id="dbc5d36cd28889beee0705d587be6e2bf5f0ba24" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUndef</source>
          <target state="translated">TSpecialWord.wUndef</target>
        </trans-unit>
        <trans-unit id="279a751e05c27d1e929e77b6e74a8f8fcd202ff3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnion</source>
          <target state="translated">TSpecialWord.wUnion</target>
        </trans-unit>
        <trans-unit id="acd5245dafa7c73d3e19f18016ec4300935dbc52" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnroll</source>
          <target state="translated">TSpecialWord.wUnroll</target>
        </trans-unit>
        <trans-unit id="128bae39e8b7b9c9bd624e15b312f4239ed53544" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnsigned</source>
          <target state="translated">TSpecialWord.wUnsigned</target>
        </trans-unit>
        <trans-unit id="4538a950702fcf865d3ddc624772f08dc9bed770" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsed</source>
          <target state="translated">TSpecialWord.wUsed</target>
        </trans-unit>
        <trans-unit id="d5186b721a554f2af5bc7833570447bfbaee4ffb" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsing</source>
          <target state="translated">TSpecialWord.wUsing</target>
        </trans-unit>
        <trans-unit id="dd8d9f0aba1c048fda45ed8dd426cf658def8d93" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVar</source>
          <target state="translated">TSpecialWord.wVar</target>
        </trans-unit>
        <trans-unit id="01d3d47c3053cb3b7fb482f0e745f51c7df7a0f8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVarargs</source>
          <target state="translated">TSpecialWord.wVarargs</target>
        </trans-unit>
        <trans-unit id="85c9b1fce5be3772cd95801d5874b26567b30c50" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVirtual</source>
          <target state="translated">TSpecialWord.wVirtual</target>
        </trans-unit>
        <trans-unit id="cae380bec2b17f6a257f9414ce33fab2081ccb90" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVoid</source>
          <target state="translated">TSpecialWord.wVoid</target>
        </trans-unit>
        <trans-unit id="eaec574e0294d6f4cfe6975561364a6e8ed2ee73" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVolatile</source>
          <target state="translated">TSpecialWord.wVolatile</target>
        </trans-unit>
        <trans-unit id="ac2d56ae50a4ef8e57ef5e5be34355ca25d1e222" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarning</source>
          <target state="translated">TSpecialWord.wWarning</target>
        </trans-unit>
        <trans-unit id="815eb53d1f7c1a0ca216fd9787dd0db2ce819982" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarningAsError</source>
          <target state="translated">TSpecialWord.wWarningAsError</target>
        </trans-unit>
        <trans-unit id="e2c2ec1dda075dad3c4bc901affaf5549a2d2b75" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarnings</source>
          <target state="translated">TSpecialWord.wWarnings</target>
        </trans-unit>
        <trans-unit id="5b837dea019d23d30994653aeb2a6a8f303a568c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWchar_t</source>
          <target state="translated">TSpecialWord.wWchar_t</target>
        </trans-unit>
        <trans-unit id="f60e52204ae6220e3c6082c529bc3c10f836c8e0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhen</source>
          <target state="translated">TSpecialWord.wWhen</target>
        </trans-unit>
        <trans-unit id="22f35857d8fff1b871e90250921bcbad022c1596" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhile</source>
          <target state="translated">TSpecialWord.wWhile</target>
        </trans-unit>
        <trans-unit id="f7bf965945cdbc25c36d9e3dc84f071eb2b53200" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrite</source>
          <target state="translated">TSpecialWord.wWrite</target>
        </trans-unit>
        <trans-unit id="65b8c2c53f6ca0b94c75c1d256fefa69d322b613" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrites</source>
          <target state="translated">TSpecialWord.wWrites</target>
        </trans-unit>
        <trans-unit id="385a4cef4263d0f5309e1c0899a6b65221d03816" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wXor</source>
          <target state="translated">TSpecialWord.wXor</target>
        </trans-unit>
        <trans-unit id="d6f1af335750efb309789ef991ace31453c11f01" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wYield</source>
          <target state="translated">TSpecialWord.wYield</target>
        </trans-unit>
        <trans-unit id="e6d0cddee16c4a5b079344fd99dcab4c4d1b9e4c" translate="yes" xml:space="preserve">
          <source>TSpecialWord:</source>
          <target state="translated">TSpecialWord:</target>
        </trans-unit>
        <trans-unit id="be4d767100d61b72e964b4c9f210a5a6fe5a30b1" translate="yes" xml:space="preserve">
          <source>TSpecialWords:</source>
          <target state="translated">TSpecialWords:</target>
        </trans-unit>
        <trans-unit id="adb30911c6273d9d5b3b15cb0ce088b23e2ba860" translate="yes" xml:space="preserve">
          <source>TSrcGen:</source>
          <target state="translated">TSrcGen:</target>
        </trans-unit>
        <trans-unit id="6323d0dcdfc011e809275fb4eba73730c046c118" translate="yes" xml:space="preserve">
          <source>TStackFrame:</source>
          <target state="translated">TStackFrame:</target>
        </trans-unit>
        <trans-unit id="395d19944b46707114ce5ef88d888fc1f25becb7" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnHeap</source>
          <target state="translated">TStorageLoc.OnHeap</target>
        </trans-unit>
        <trans-unit id="a621c5b644c09975980371a6c506a414732361eb" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStack</source>
          <target state="translated">TStorageLoc.OnStack</target>
        </trans-unit>
        <trans-unit id="d50d78116f7b907d867a6196eb491acda5ae45b3" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStatic</source>
          <target state="translated">TStorageLoc.OnStatic</target>
        </trans-unit>
        <trans-unit id="aab718eb78528ad6e6e1c17a2c7f7fc049cb99e8" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnUnknown</source>
          <target state="translated">TStorageLoc.OnUnknown</target>
        </trans-unit>
        <trans-unit id="bcf92d0d35e49a4a230909f361cff8341d206060" translate="yes" xml:space="preserve">
          <source>TStorageLoc:</source>
          <target state="translated">TStorageLoc:</target>
        </trans-unit>
        <trans-unit id="cf7b832a47b0aa258a00e12b2bc337b5f3fbcb37" translate="yes" xml:space="preserve">
          <source>TStrTable:</source>
          <target state="translated">TStrTable:</target>
        </trans-unit>
        <trans-unit id="12d7fc329e1ae4a95222ebc188918ec1a1418652" translate="yes" xml:space="preserve">
          <source>TStringSeq:</source>
          <target state="translated">TStringSeq:</target>
        </trans-unit>
        <trans-unit id="05b487bb2b91485184c628ce10489134924aa98b" translate="yes" xml:space="preserve">
          <source>TSym:</source>
          <target state="translated">TSym:</target>
        </trans-unit>
        <trans-unit id="9330a751f32c5ee89229160cd7e81e74056f7182" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfAddrTaken</source>
          <target state="translated">TSymFlag.sfAddrTaken</target>
        </trans-unit>
        <trans-unit id="2dd6e5ad1a7670b695ce53f4d472c13e31c1b44b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfBorrow</source>
          <target state="translated">TSymFlag.sfBorrow</target>
        </trans-unit>
        <trans-unit id="a1efaba0d735377cf87b7f6858536df1dc6db3ca" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCallsite</source>
          <target state="translated">TSymFlag.sfCallsite</target>
        </trans-unit>
        <trans-unit id="edc5ff991665ff461d50658b207b93b6f8c66cda" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompileTime</source>
          <target state="translated">TSymFlag.sfCompileTime</target>
        </trans-unit>
        <trans-unit id="582d96473a233f6d011b615d47980f8d5dd93af3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompilerProc</source>
          <target state="translated">TSymFlag.sfCompilerProc</target>
        </trans-unit>
        <trans-unit id="b516b17c0bde4915c66c3305e883ed517bc783fa" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfConstructor</source>
          <target state="translated">TSymFlag.sfConstructor</target>
        </trans-unit>
        <trans-unit id="298f5d1d6d6ed080d23994ae981ee6bfc36fbd59" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCursor</source>
          <target state="translated">TSymFlag.sfCursor</target>
        </trans-unit>
        <trans-unit id="bd0596035433f9c47b27e85e2a8c35f5493ebfaf" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDeprecated</source>
          <target state="translated">TSymFlag.sfDeprecated</target>
        </trans-unit>
        <trans-unit id="5f92740cada22e9ed96755b4f6d2a928a0d66889" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscardable</source>
          <target state="translated">TSymFlag.sfDiscardable</target>
        </trans-unit>
        <trans-unit id="6e343a45d312a4042d970d9ec4a09af5398a6b72" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscriminant</source>
          <target state="translated">TSymFlag.sfDiscriminant</target>
        </trans-unit>
        <trans-unit id="b1fa4f615769249576344c340b880762b76bd5b7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDispatcher</source>
          <target state="translated">TSymFlag.sfDispatcher</target>
        </trans-unit>
        <trans-unit id="e455f5f383b9e0f6fbd1c12e034948b40017e87b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfError</source>
          <target state="translated">TSymFlag.sfError</target>
        </trans-unit>
        <trans-unit id="e1fb45f483c1d52633c02bc21bee7c53ec5788f9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExplain</source>
          <target state="translated">TSymFlag.sfExplain</target>
        </trans-unit>
        <trans-unit id="7e4b245f8a05a920c7655f9ad1d64bf2c9e477e0" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExportc</source>
          <target state="translated">TSymFlag.sfExportc</target>
        </trans-unit>
        <trans-unit id="2f8455ceee2fc2e375778732463006731b34784a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExported</source>
          <target state="translated">TSymFlag.sfExported</target>
        </trans-unit>
        <trans-unit id="a52c7cbacb40cf2d307722b243bc58981e796eec" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfForward</source>
          <target state="translated">TSymFlag.sfForward</target>
        </trans-unit>
        <trans-unit id="1196f111e6dc3efb4835c41b10074f675c379f1d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfFromGeneric</source>
          <target state="translated">TSymFlag.sfFromGeneric</target>
        </trans-unit>
        <trans-unit id="105365f8de9763fcf244284a5c9407c8aa4c2661" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGenSym</source>
          <target state="translated">TSymFlag.sfGenSym</target>
        </trans-unit>
        <trans-unit id="04e8b1287496c27529d274cec4f17fe9a6ba8697" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGeneratedOp</source>
          <target state="translated">TSymFlag.sfGeneratedOp</target>
        </trans-unit>
        <trans-unit id="534e05b2302e2356d51e38b679c263ef12cb5a20" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGlobal</source>
          <target state="translated">TSymFlag.sfGlobal</target>
        </trans-unit>
        <trans-unit id="533c0791334dc3ed4ded29375e0ea0e96faeeeb7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfImportc</source>
          <target state="translated">TSymFlag.sfImportc</target>
        </trans-unit>
        <trans-unit id="330bfbc6bd478f12eab1f5558ac4bf0df5cbc25a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInfixCall</source>
          <target state="translated">TSymFlag.sfInfixCall</target>
        </trans-unit>
        <trans-unit id="39f816cbf3f55a3030ca4c9728879a5779e2ce84" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInjectDestructors</source>
          <target state="translated">TSymFlag.sfInjectDestructors</target>
        </trans-unit>
        <trans-unit id="b0e41681dd3772b0d00504a1f624b641a1ce3b1e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMainModule</source>
          <target state="translated">TSymFlag.sfMainModule</target>
        </trans-unit>
        <trans-unit id="8e8263d25bd716de09e2495e4ea8b9bad934bbc8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMangleCpp</source>
          <target state="translated">TSymFlag.sfMangleCpp</target>
        </trans-unit>
        <trans-unit id="d47663c51704084f8beb0d796f58a03b269273d6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNamedParamCall</source>
          <target state="translated">TSymFlag.sfNamedParamCall</target>
        </trans-unit>
        <trans-unit id="3ec62b325c5a44dcf3588a04a6fbbe199da7fca8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNeverRaises</source>
          <target state="translated">TSymFlag.sfNeverRaises</target>
        </trans-unit>
        <trans-unit id="6b10b09be35a82d4e4c9f714e1e485d6c74a08d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoReturn</source>
          <target state="translated">TSymFlag.sfNoReturn</target>
        </trans-unit>
        <trans-unit id="1636d386afaa9112e3cafc2af385fef845e7f60a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoSideEffect</source>
          <target state="translated">TSymFlag.sfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="277ce17ae708dd1e2e807e085e44d05628bd1cc9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoalias</source>
          <target state="translated">TSymFlag.sfNoalias</target>
        </trans-unit>
        <trans-unit id="2d5cad3f2fc8b04bf4b9760b4ade680573ac4847" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNonReloadable</source>
          <target state="translated">TSymFlag.sfNonReloadable</target>
        </trans-unit>
        <trans-unit id="932c83b43941e8293a0c9790f9f7394ad71414e3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfOverriden</source>
          <target state="translated">TSymFlag.sfOverriden</target>
        </trans-unit>
        <trans-unit id="71409f73c696c09edb6da3f445713c46904ca616" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfProcvar</source>
          <target state="translated">TSymFlag.sfProcvar</target>
        </trans-unit>
        <trans-unit id="76f94fff7ac23d224a5bc526747e1686feb676cb" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfPure</source>
          <target state="translated">TSymFlag.sfPure</target>
        </trans-unit>
        <trans-unit id="4fca142ba180109698776ba0a36c4f4c9002640d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRegister</source>
          <target state="translated">TSymFlag.sfRegister</target>
        </trans-unit>
        <trans-unit id="cfa983785f95c8ce9b0d73629a1d7067f48e010e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRequiresInit</source>
          <target state="translated">TSymFlag.sfRequiresInit</target>
        </trans-unit>
        <trans-unit id="5f6ecd6b6f03c52714fb8853b88eb55430032b09" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfShadowed</source>
          <target state="translated">TSymFlag.sfShadowed</target>
        </trans-unit>
        <trans-unit id="2e289288f11f81e4ac61b02d13c1fec9e78e2192" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSideEffect</source>
          <target state="translated">TSymFlag.sfSideEffect</target>
        </trans-unit>
        <trans-unit id="8d495c01577f4bf009f6865e434af0e0d8466fa6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSingleUsedTemp</source>
          <target state="translated">TSymFlag.sfSingleUsedTemp</target>
        </trans-unit>
        <trans-unit id="7d50321a18c3926dabf7444407d02c677dbc42d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSystemModule</source>
          <target state="translated">TSymFlag.sfSystemModule</target>
        </trans-unit>
        <trans-unit id="b56a7ace7f8cb72017ccb47cf2f59ddfa3bf7a2b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfTemplateParam</source>
          <target state="translated">TSymFlag.sfTemplateParam</target>
        </trans-unit>
        <trans-unit id="f939407b7d9d720c20e219b1739d2160b2c627de" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfThread</source>
          <target state="translated">TSymFlag.sfThread</target>
        </trans-unit>
        <trans-unit id="a32d4997116a1bb7e46d6e2074c08949f77ef009" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsed</source>
          <target state="translated">TSymFlag.sfUsed</target>
        </trans-unit>
        <trans-unit id="f0e174760c583a922fc6dedbb1f219b72c2ec6e4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsedInFinallyOrExcept</source>
          <target state="translated">TSymFlag.sfUsedInFinallyOrExcept</target>
        </trans-unit>
        <trans-unit id="82552db7e730ccc1f98ac08d01dfb4dea5d1f933" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfVolatile</source>
          <target state="translated">TSymFlag.sfVolatile</target>
        </trans-unit>
        <trans-unit id="72bdf7b7b1da7510d785d165cc71e2a29d569556" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfWasForwarded</source>
          <target state="translated">TSymFlag.sfWasForwarded</target>
        </trans-unit>
        <trans-unit id="29c7d5626ad614186f0d440855956d99d98de760" translate="yes" xml:space="preserve">
          <source>TSymFlag:</source>
          <target state="translated">TSymFlag:</target>
        </trans-unit>
        <trans-unit id="d47155ecd82d26176d884a3a5c7290848bc046d7" translate="yes" xml:space="preserve">
          <source>TSymFlags:</source>
          <target state="translated">TSymFlags:</target>
        </trans-unit>
        <trans-unit id="49a417dc99897410b26a479122d7c245c98404df" translate="yes" xml:space="preserve">
          <source>TSymKind.skAlias</source>
          <target state="translated">TSymKind.skAlias</target>
        </trans-unit>
        <trans-unit id="c76f677a9ccca1cb58417acb2f2221011359b50e" translate="yes" xml:space="preserve">
          <source>TSymKind.skConditional</source>
          <target state="translated">TSymKind.skConditional</target>
        </trans-unit>
        <trans-unit id="7dfa50d9174c876ce7d15bc1fd5aa7819f6eb7e8" translate="yes" xml:space="preserve">
          <source>TSymKind.skConst</source>
          <target state="translated">TSymKind.skConst</target>
        </trans-unit>
        <trans-unit id="919d3051204679f680a8114ed54198af8cd03508" translate="yes" xml:space="preserve">
          <source>TSymKind.skConverter</source>
          <target state="translated">TSymKind.skConverter</target>
        </trans-unit>
        <trans-unit id="57d44bfce9d934c7b94cccc0ed40283adea986f6" translate="yes" xml:space="preserve">
          <source>TSymKind.skDynLib</source>
          <target state="translated">TSymKind.skDynLib</target>
        </trans-unit>
        <trans-unit id="5a6a73a73234b278355b6d90ff6594ea1532cc5b" translate="yes" xml:space="preserve">
          <source>TSymKind.skEnumField</source>
          <target state="translated">TSymKind.skEnumField</target>
        </trans-unit>
        <trans-unit id="6b13fc9942e9012939aaa24c01ee74d54785096d" translate="yes" xml:space="preserve">
          <source>TSymKind.skField</source>
          <target state="translated">TSymKind.skField</target>
        </trans-unit>
        <trans-unit id="b42eb31691f0f152a922d109173d10452db09398" translate="yes" xml:space="preserve">
          <source>TSymKind.skForVar</source>
          <target state="translated">TSymKind.skForVar</target>
        </trans-unit>
        <trans-unit id="3c93bc5280899b1704d4939e91709f91bb81c109" translate="yes" xml:space="preserve">
          <source>TSymKind.skFunc</source>
          <target state="translated">TSymKind.skFunc</target>
        </trans-unit>
        <trans-unit id="e946aeda39742b18797afdfbc5ef7d032a114722" translate="yes" xml:space="preserve">
          <source>TSymKind.skGenericParam</source>
          <target state="translated">TSymKind.skGenericParam</target>
        </trans-unit>
        <trans-unit id="8b85c87c4b38369f835e342209e7c7ab4d80b88e" translate="yes" xml:space="preserve">
          <source>TSymKind.skIterator</source>
          <target state="translated">TSymKind.skIterator</target>
        </trans-unit>
        <trans-unit id="b9bec98f25dbc1b1c1c5bd16c387a21a1ad6a3d0" translate="yes" xml:space="preserve">
          <source>TSymKind.skLabel</source>
          <target state="translated">TSymKind.skLabel</target>
        </trans-unit>
        <trans-unit id="2b17d003c02f1eed23328282ec4b75a2c7bab33a" translate="yes" xml:space="preserve">
          <source>TSymKind.skLet</source>
          <target state="translated">TSymKind.skLet</target>
        </trans-unit>
        <trans-unit id="a8285a283b0af2c8fca7edc0b6fdc1913a6ce5b6" translate="yes" xml:space="preserve">
          <source>TSymKind.skMacro</source>
          <target state="translated">TSymKind.skMacro</target>
        </trans-unit>
        <trans-unit id="b8267d7384523a8483da02476006487bdba9d91f" translate="yes" xml:space="preserve">
          <source>TSymKind.skMethod</source>
          <target state="translated">TSymKind.skMethod</target>
        </trans-unit>
        <trans-unit id="60d683994d2f4bfd3a0468b0b5765ebadb8fd4e5" translate="yes" xml:space="preserve">
          <source>TSymKind.skModule</source>
          <target state="translated">TSymKind.skModule</target>
        </trans-unit>
        <trans-unit id="d4b3f8c98e41c6b045e0cf12b69a3c13146ded9b" translate="yes" xml:space="preserve">
          <source>TSymKind.skPackage</source>
          <target state="translated">TSymKind.skPackage</target>
        </trans-unit>
        <trans-unit id="581dde25239097be52aac3d98efd76085651c04c" translate="yes" xml:space="preserve">
          <source>TSymKind.skParam</source>
          <target state="translated">TSymKind.skParam</target>
        </trans-unit>
        <trans-unit id="d5061dd8b70ade95406188521b2aff052a2b8b76" translate="yes" xml:space="preserve">
          <source>TSymKind.skProc</source>
          <target state="translated">TSymKind.skProc</target>
        </trans-unit>
        <trans-unit id="10d6d5f68c3d570f559afef9c7d0e1c503f31c82" translate="yes" xml:space="preserve">
          <source>TSymKind.skResult</source>
          <target state="translated">TSymKind.skResult</target>
        </trans-unit>
        <trans-unit id="4b1403bed05bc383c650ebbd4da253f3677a73a7" translate="yes" xml:space="preserve">
          <source>TSymKind.skStub</source>
          <target state="translated">TSymKind.skStub</target>
        </trans-unit>
        <trans-unit id="e0042cc9bef9afa39e87b6f8dea08bedd12df156" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemp</source>
          <target state="translated">TSymKind.skTemp</target>
        </trans-unit>
        <trans-unit id="baf8eeb56f3a1d01fb53ecac94f2eda78f5750d3" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemplate</source>
          <target state="translated">TSymKind.skTemplate</target>
        </trans-unit>
        <trans-unit id="a4ea389dec6af0c3a90402fd6a64c460d4965315" translate="yes" xml:space="preserve">
          <source>TSymKind.skType</source>
          <target state="translated">TSymKind.skType</target>
        </trans-unit>
        <trans-unit id="e62db8421aee5327a828a735d66f7957f7d3d74f" translate="yes" xml:space="preserve">
          <source>TSymKind.skUnknown</source>
          <target state="translated">TSymKind.skUnknown</target>
        </trans-unit>
        <trans-unit id="c279ecb87280d50b68a3bd440f8e43008b19e819" translate="yes" xml:space="preserve">
          <source>TSymKind.skVar</source>
          <target state="translated">TSymKind.skVar</target>
        </trans-unit>
        <trans-unit id="36000b209f29bc98cf392b4e4456f57a84b3b59b" translate="yes" xml:space="preserve">
          <source>TSymKind:</source>
          <target state="translated">TSymKind:</target>
        </trans-unit>
        <trans-unit id="a3b25836cfbafe08072c36a3f31b50569b89cb87" translate="yes" xml:space="preserve">
          <source>TSymKinds:</source>
          <target state="translated">TSymKinds:</target>
        </trans-unit>
        <trans-unit id="40e65df88cca5769c108db4732546e9385041477" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccBcc</source>
          <target state="translated">TSystemCC.ccBcc</target>
        </trans-unit>
        <trans-unit id="6d00814fd9c17001351f26f74ecf8e0d598070b0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccCLang</source>
          <target state="translated">TSystemCC.ccCLang</target>
        </trans-unit>
        <trans-unit id="19071fc3124e339066eeefd76c5caa5747d3b6d2" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccClangCl</source>
          <target state="translated">TSystemCC.ccClangCl</target>
        </trans-unit>
        <trans-unit id="fcb066cfa947fca39a83432714945b7e0f17d383" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccEnv</source>
          <target state="translated">TSystemCC.ccEnv</target>
        </trans-unit>
        <trans-unit id="97f6f68538eefe119e8183ea5c5e98feb0f79c6d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccGcc</source>
          <target state="translated">TSystemCC.ccGcc</target>
        </trans-unit>
        <trans-unit id="7384f9d26bb7f0967750fd1f751e72ac5b69923c" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcc</source>
          <target state="translated">TSystemCC.ccIcc</target>
        </trans-unit>
        <trans-unit id="0f268723c4eae2053cac77dd39a6d770474f8223" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcl</source>
          <target state="translated">TSystemCC.ccIcl</target>
        </trans-unit>
        <trans-unit id="2b1588d1bf0a5cc64f3bcd66ca1d8ac7081f9e0f" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccLLVM_Gcc</source>
          <target state="translated">TSystemCC.ccLLVM_Gcc</target>
        </trans-unit>
        <trans-unit id="71239fb0d7cf2675e99b0aa8d9958cad2e7f2bc0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNintendoSwitch</source>
          <target state="translated">TSystemCC.ccNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="41f122e6477383f472ab026e739beeca2659006d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNone</source>
          <target state="translated">TSystemCC.ccNone</target>
        </trans-unit>
        <trans-unit id="8e5ec951c8818fd50562a51f1771746f02dd9732" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccTcc</source>
          <target state="translated">TSystemCC.ccTcc</target>
        </trans-unit>
        <trans-unit id="d5d2fddd742551849c57359a32720a1a7c68c407" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccVcc</source>
          <target state="translated">TSystemCC.ccVcc</target>
        </trans-unit>
        <trans-unit id="e4b6b58efbe0ae82d8de0366bbeb65ef571f542b" translate="yes" xml:space="preserve">
          <source>TSystemCC:</source>
          <target state="translated">TSystemCC:</target>
        </trans-unit>
        <trans-unit id="e85203494b9cda1e361884f465c8d21638c17c47" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAVR</source>
          <target state="translated">TSystemCPU.cpuAVR</target>
        </trans-unit>
        <trans-unit id="e28d761304c4f6489545762c0b4c34008fc2245c" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAlpha</source>
          <target state="translated">TSystemCPU.cpuAlpha</target>
        </trans-unit>
        <trans-unit id="d801dcb1b7ceb4ce49f7a098ef0d8a08858eed98" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAmd64</source>
          <target state="translated">TSystemCPU.cpuAmd64</target>
        </trans-unit>
        <trans-unit id="ba596950092238df74b220c68b11c34fc419e0e0" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm</source>
          <target state="translated">TSystemCPU.cpuArm</target>
        </trans-unit>
        <trans-unit id="9ca4c13a0c290114fd7d1c85a30b5b41a67a5bc9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm64</source>
          <target state="translated">TSystemCPU.cpuArm64</target>
        </trans-unit>
        <trans-unit id="5b65105583f3819adb0632e62bb25e0a18da9bbb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuEsp</source>
          <target state="translated">TSystemCPU.cpuEsp</target>
        </trans-unit>
        <trans-unit id="8447db6ec7fdf81f194cc4ecd1414b74f623750a" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuHppa</source>
          <target state="translated">TSystemCPU.cpuHppa</target>
        </trans-unit>
        <trans-unit id="bc456545a8d7ffa3ed8212abdb78b306dde88093" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuI386</source>
          <target state="translated">TSystemCPU.cpuI386</target>
        </trans-unit>
        <trans-unit id="c6083caa9bfe02d7c40b52f99d7b6abb8d7864f7" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuIa64</source>
          <target state="translated">TSystemCPU.cpuIa64</target>
        </trans-unit>
        <trans-unit id="3e878dd5fc4a0168ff6f7991ce1f44372aedc620" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuJS</source>
          <target state="translated">TSystemCPU.cpuJS</target>
        </trans-unit>
        <trans-unit id="76fba4bb86ffe7ff850b133c4c20c39bb685b516" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuM68k</source>
          <target state="translated">TSystemCPU.cpuM68k</target>
        </trans-unit>
        <trans-unit id="f2e8398a63ef93ff4063793c053f8dc154c4a290" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMSP430</source>
          <target state="translated">TSystemCPU.cpuMSP430</target>
        </trans-unit>
        <trans-unit id="c8a9c9af2114a96e56820717902c60073ab32b1f" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips</source>
          <target state="translated">TSystemCPU.cpuMips</target>
        </trans-unit>
        <trans-unit id="24591e6c0052949e99184099449d788dad8f29a9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64</source>
          <target state="translated">TSystemCPU.cpuMips64</target>
        </trans-unit>
        <trans-unit id="6e85a81c06cdf314f2da1ba7bef924bc75a6edce" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64el</source>
          <target state="translated">TSystemCPU.cpuMips64el</target>
        </trans-unit>
        <trans-unit id="1d8ab56ff314237fa81874b96bd0c570456c7697" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMipsel</source>
          <target state="translated">TSystemCPU.cpuMipsel</target>
        </trans-unit>
        <trans-unit id="1023f73aa3e9a1c6576d33e867de8b2de6ccddc1" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNimVM</source>
          <target state="translated">TSystemCPU.cpuNimVM</target>
        </trans-unit>
        <trans-unit id="a5220471302688e090fd0384c2a6d0e2555a35dc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNone</source>
          <target state="translated">TSystemCPU.cpuNone</target>
        </trans-unit>
        <trans-unit id="e073cc300e253e5d6c5f43f1d40975ee3ee35f36" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc</source>
          <target state="translated">TSystemCPU.cpuPowerpc</target>
        </trans-unit>
        <trans-unit id="a0bb3fb97c3f25aa16dfdff5a063669cca1debb9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64</source>
          <target state="translated">TSystemCPU.cpuPowerpc64</target>
        </trans-unit>
        <trans-unit id="d9b7e25410216178660f56da74dbf1b12974e3fc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64el</source>
          <target state="translated">TSystemCPU.cpuPowerpc64el</target>
        </trans-unit>
        <trans-unit id="3541d71f45742618d1e0853f477959e0683a8d59" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuRiscV64</source>
          <target state="translated">TSystemCPU.cpuRiscV64</target>
        </trans-unit>
        <trans-unit id="33e3b76ba433a36d3634e0f2077791506ce9b7cf" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc</source>
          <target state="translated">TSystemCPU.cpuSparc</target>
        </trans-unit>
        <trans-unit id="2195ef6204df47de3f399d523e82333924ee50ee" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc64</source>
          <target state="translated">TSystemCPU.cpuSparc64</target>
        </trans-unit>
        <trans-unit id="9fa0216f565e08a88e069b22b00651362a0a2abb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuVm</source>
          <target state="translated">TSystemCPU.cpuVm</target>
        </trans-unit>
        <trans-unit id="9fb10eff42bbf00edd9d6dac15eb0b596991e106" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuWasm32</source>
          <target state="translated">TSystemCPU.cpuWasm32</target>
        </trans-unit>
        <trans-unit id="5e0590cc52dd7fd9f8c5f71948ac3e4fbb645e7d" translate="yes" xml:space="preserve">
          <source>TSystemCPU:</source>
          <target state="translated">TSystemCPU:</target>
        </trans-unit>
        <trans-unit id="0b357ac76e93964f0e9aa628cf5ff44e248e0aff" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAix</source>
          <target state="translated">TSystemOS.osAix</target>
        </trans-unit>
        <trans-unit id="57e794c9e1abb8e214350a820bef46513aa5410d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAmiga</source>
          <target state="translated">TSystemOS.osAmiga</target>
        </trans-unit>
        <trans-unit id="139f446a98c51f26d348db327105203f84121229" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAndroid</source>
          <target state="translated">TSystemOS.osAndroid</target>
        </trans-unit>
        <trans-unit id="0601a6371692f109064f096efedf7295967e8403" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAny</source>
          <target state="translated">TSystemOS.osAny</target>
        </trans-unit>
        <trans-unit id="9ae1eebbb62dc69485803ce20300a53317d7990e" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAtari</source>
          <target state="translated">TSystemOS.osAtari</target>
        </trans-unit>
        <trans-unit id="2d7d69566045aa8beeaa3254d4276bb3fcfdef2c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDos</source>
          <target state="translated">TSystemOS.osDos</target>
        </trans-unit>
        <trans-unit id="309c21832c4018ef77f374a618bd781eea84a066" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDragonfly</source>
          <target state="translated">TSystemOS.osDragonfly</target>
        </trans-unit>
        <trans-unit id="db54117145d85bc8c33b683ec9ab07263b4d6fd0" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreeRTOS</source>
          <target state="translated">TSystemOS.osFreeRTOS</target>
        </trans-unit>
        <trans-unit id="a664f10fbfe811c5a9d84bdfca93ff12f0358741" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreebsd</source>
          <target state="translated">TSystemOS.osFreebsd</target>
        </trans-unit>
        <trans-unit id="bc47a412753230d118928d7f63b36b9e6309d2c3" translate="yes" xml:space="preserve">
          <source>TSystemOS.osGenode</source>
          <target state="translated">TSystemOS.osGenode</target>
        </trans-unit>
        <trans-unit id="e940630397e431aed1fc63cca4ebe7f6fe232f0b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osHaiku</source>
          <target state="translated">TSystemOS.osHaiku</target>
        </trans-unit>
        <trans-unit id="c197905406125d16d4a6f74ab6b8199d900f4ecb" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIos</source>
          <target state="translated">TSystemOS.osIos</target>
        </trans-unit>
        <trans-unit id="e57f2d8c18cd83b14c9fb9eb4ef124e0a1e3993f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIrix</source>
          <target state="translated">TSystemOS.osIrix</target>
        </trans-unit>
        <trans-unit id="1e7216ad040dd651e0cefb1f37074ad0662ffe75" translate="yes" xml:space="preserve">
          <source>TSystemOS.osJS</source>
          <target state="translated">TSystemOS.osJS</target>
        </trans-unit>
        <trans-unit id="c87dce60adfb5c9c9dc59db4d26f6b0b61fdff55" translate="yes" xml:space="preserve">
          <source>TSystemOS.osLinux</source>
          <target state="translated">TSystemOS.osLinux</target>
        </trans-unit>
        <trans-unit id="51b2d87a29af45151db0dc281d2828f8fc776f6f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacos</source>
          <target state="translated">TSystemOS.osMacos</target>
        </trans-unit>
        <trans-unit id="f3991a53075ffa27b2f9fe0029a6a1412cc9e393" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacosx</source>
          <target state="translated">TSystemOS.osMacosx</target>
        </trans-unit>
        <trans-unit id="d7bc87d6f7e56f805a7e5c270db9eea5752ea7b2" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMorphos</source>
          <target state="translated">TSystemOS.osMorphos</target>
        </trans-unit>
        <trans-unit id="10192972afc69a1d3ba9c793e640fd1d96c5b030" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetbsd</source>
          <target state="translated">TSystemOS.osNetbsd</target>
        </trans-unit>
        <trans-unit id="c20a3ae638bccfe7eadd065e638b9ad9bfa4571b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetware</source>
          <target state="translated">TSystemOS.osNetware</target>
        </trans-unit>
        <trans-unit id="941a5d5eacc491c469cf30cfdacc174c871fce9c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNimVM</source>
          <target state="translated">TSystemOS.osNimVM</target>
        </trans-unit>
        <trans-unit id="271c3ce037881f412f8686ade95524481697197b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNintendoSwitch</source>
          <target state="translated">TSystemOS.osNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="e768046f46b0a39479496146233246e16a916c04" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNone</source>
          <target state="translated">TSystemOS.osNone</target>
        </trans-unit>
        <trans-unit id="e00eb077875a3b48219f06030696c42e78fe57a7" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOpenbsd</source>
          <target state="translated">TSystemOS.osOpenbsd</target>
        </trans-unit>
        <trans-unit id="bf32d61ca1a1af77ebe67ab324a055555ee2e6d8" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOs2</source>
          <target state="translated">TSystemOS.osOs2</target>
        </trans-unit>
        <trans-unit id="1de6f4e8e82651e9f443671af18e016ead98a709" translate="yes" xml:space="preserve">
          <source>TSystemOS.osPalmos</source>
          <target state="translated">TSystemOS.osPalmos</target>
        </trans-unit>
        <trans-unit id="f79e259295c14e93026df87a786a1dd63b1bede9" translate="yes" xml:space="preserve">
          <source>TSystemOS.osQnx</source>
          <target state="translated">TSystemOS.osQnx</target>
        </trans-unit>
        <trans-unit id="7cbac9d74c2ec82ad5104b2e56eb41053dacd2be" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSkyos</source>
          <target state="translated">TSystemOS.osSkyos</target>
        </trans-unit>
        <trans-unit id="3281c9ed268a903d82b811ed828fc68ddfc04fd5" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSolaris</source>
          <target state="translated">TSystemOS.osSolaris</target>
        </trans-unit>
        <trans-unit id="43c30ef6d951f5134eefd74464e64b290de75b49" translate="yes" xml:space="preserve">
          <source>TSystemOS.osStandalone</source>
          <target state="translated">TSystemOS.osStandalone</target>
        </trans-unit>
        <trans-unit id="0c3395ef39ac4ea1500b59f59cd08063a73bab08" translate="yes" xml:space="preserve">
          <source>TSystemOS.osVxWorks</source>
          <target state="translated">TSystemOS.osVxWorks</target>
        </trans-unit>
        <trans-unit id="f4d238b4f6b9e9640466505b29c89e6fca4fec2d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osWindows</source>
          <target state="translated">TSystemOS.osWindows</target>
        </trans-unit>
        <trans-unit id="a398d417d4982e6dc512eed7c6b59f54a754c05a" translate="yes" xml:space="preserve">
          <source>TSystemOS:</source>
          <target state="translated">TSystemOS:</target>
        </trans-unit>
        <trans-unit id="5939aea9b487dbaab0cf08324f9a9a447e0900d6" translate="yes" xml:space="preserve">
          <source>TTabIter:</source>
          <target state="translated">TTabIter:</target>
        </trans-unit>
        <trans-unit id="41a2786fc2af3e24ec0db6712d87f40503eeb20a" translate="yes" xml:space="preserve">
          <source>TType:</source>
          <target state="translated">TType:</target>
        </trans-unit>
        <trans-unit id="0179cb50ac4de959ffb192e0c7cac0b96227caa5" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taConcept</source>
          <target state="translated">TTypeAllowedFlag.taConcept</target>
        </trans-unit>
        <trans-unit id="1ab466e6e741e60ca7ec60a6466864011131025b" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taField</source>
          <target state="translated">TTypeAllowedFlag.taField</target>
        </trans-unit>
        <trans-unit id="41fc7c202eebd75be3d703e98072a7e5c8a9aa2d" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taHeap</source>
          <target state="translated">TTypeAllowedFlag.taHeap</target>
        </trans-unit>
        <trans-unit id="84923533778030da718d0e06375c33a0ac63e9e2" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsOpenArray</source>
          <target state="translated">TTypeAllowedFlag.taIsOpenArray</target>
        </trans-unit>
        <trans-unit id="b776ebbbb740385436b4bfb8d79613dfcd7bcbb0" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsTemplateOrMacro</source>
          <target state="translated">TTypeAllowedFlag.taIsTemplateOrMacro</target>
        </trans-unit>
        <trans-unit id="21016ece821aa9e90d83fb2832e84a88cacbff06" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taNoUntyped</source>
          <target state="translated">TTypeAllowedFlag.taNoUntyped</target>
        </trans-unit>
        <trans-unit id="1e6587542c7ae2cb27035918684c4c8b1e6310a4" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taProcContextIsNotMacro</source>
          <target state="translated">TTypeAllowedFlag.taProcContextIsNotMacro</target>
        </trans-unit>
        <trans-unit id="0c27a5b363ed5d06f5fcff4f8f3cd0f5b9037a56" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag:</source>
          <target state="translated">TTypeAllowedFlag:</target>
        </trans-unit>
        <trans-unit id="1c785b4d25a85f7f1bd956c98d088327a638a168" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlags:</source>
          <target state="translated">TTypeAllowedFlags:</target>
        </trans-unit>
        <trans-unit id="fc314936ddd603367171fd74694532c6adab99c5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedAsgn</source>
          <target state="translated">TTypeAttachedOp.attachedAsgn</target>
        </trans-unit>
        <trans-unit id="244a557e848e3357faa4c21471b5db088d254294" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDeepCopy</source>
          <target state="translated">TTypeAttachedOp.attachedDeepCopy</target>
        </trans-unit>
        <trans-unit id="d228ecd9ce629a0b6a2787576a6558af6f68ae3e" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDestructor</source>
          <target state="translated">TTypeAttachedOp.attachedDestructor</target>
        </trans-unit>
        <trans-unit id="f483a09d6048ebca812d1d5b4b03ae8a218b0bb1" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDispose</source>
          <target state="translated">TTypeAttachedOp.attachedDispose</target>
        </trans-unit>
        <trans-unit id="3096d633136bbc7a07581b04b5aaee8b92e9b64a" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedSink</source>
          <target state="translated">TTypeAttachedOp.attachedSink</target>
        </trans-unit>
        <trans-unit id="86d3ba82c3894d71a1b3ccc344a0436109b3a0f5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedTrace</source>
          <target state="translated">TTypeAttachedOp.attachedTrace</target>
        </trans-unit>
        <trans-unit id="11947d14da2dcca262c11f9b632e36d5279b9394" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp:</source>
          <target state="translated">TTypeAttachedOp:</target>
        </trans-unit>
        <trans-unit id="a4777dfef03acb138ec00e5f5dac24713684c810" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.AllowCommonBase</source>
          <target state="translated">TTypeCmpFlag.AllowCommonBase</target>
        </trans-unit>
        <trans-unit id="08054a53231843d58690f59314cbbb52f2cbc9e1" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactConstraints</source>
          <target state="translated">TTypeCmpFlag.ExactConstraints</target>
        </trans-unit>
        <trans-unit id="dbd1a6dd6abd1ffaf12460691d968606f8673a65" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGcSafety</source>
          <target state="translated">TTypeCmpFlag.ExactGcSafety</target>
        </trans-unit>
        <trans-unit id="9f819df93295a98eaeb321d4b6079aec8c164d85" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGenericParams</source>
          <target state="translated">TTypeCmpFlag.ExactGenericParams</target>
        </trans-unit>
        <trans-unit id="e77812cda4c0753c698e8c0498f046c40895fb34" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactTypeDescValues</source>
          <target state="translated">TTypeCmpFlag.ExactTypeDescValues</target>
        </trans-unit>
        <trans-unit id="5caaebda03569c71bc228f3143586b5714b80433" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreCC</source>
          <target state="translated">TTypeCmpFlag.IgnoreCC</target>
        </trans-unit>
        <trans-unit id="34bb7146abb78508eaa04cb5d2873ff599851422" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreTupleFields</source>
          <target state="translated">TTypeCmpFlag.IgnoreTupleFields</target>
        </trans-unit>
        <trans-unit id="bf93f85a21ebbc559f03dc5707e37933d7b14f2d" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag:</source>
          <target state="translated">TTypeCmpFlag:</target>
        </trans-unit>
        <trans-unit id="498a511c8026855650e5a2ba2b904e6d84f82234" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlags:</source>
          <target state="translated">TTypeCmpFlags:</target>
        </trans-unit>
        <trans-unit id="d0e24d269c517c1b4bc789cfecbbd836ad6fbac9" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frEmbedded</source>
          <target state="translated">TTypeFieldResult.frEmbedded</target>
        </trans-unit>
        <trans-unit id="27e394cb11693eacb4df02e2be4fb610f74ff8c5" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frHeader</source>
          <target state="translated">TTypeFieldResult.frHeader</target>
        </trans-unit>
        <trans-unit id="c880285eca6461cf26d70962d5837af33ec7cc9c" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frNone</source>
          <target state="translated">TTypeFieldResult.frNone</target>
        </trans-unit>
        <trans-unit id="f34b70cba43b23bfa6138b86b37f9d3d7361a027" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult:</source>
          <target state="translated">TTypeFieldResult:</target>
        </trans-unit>
        <trans-unit id="07dda03b526235c5508321c7c957bd5e603ef411" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfAcyclic</source>
          <target state="translated">TTypeFlag.tfAcyclic</target>
        </trans-unit>
        <trans-unit id="492bbf177977468bf98f4d90b2c9714340f015e1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfBorrowDot</source>
          <target state="translated">TTypeFlag.tfBorrowDot</target>
        </trans-unit>
        <trans-unit id="61a1d723dd629d7b07c67072f73b46bc90f0959c" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByCopy</source>
          <target state="translated">TTypeFlag.tfByCopy</target>
        </trans-unit>
        <trans-unit id="541fb2e55b81a6ab5f365397011759c9505ede38" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByRef</source>
          <target state="translated">TTypeFlag.tfByRef</target>
        </trans-unit>
        <trans-unit id="9688f0415838a906d60e24908d80b68f81241882" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCapturesEnv</source>
          <target state="translated">TTypeFlag.tfCapturesEnv</target>
        </trans-unit>
        <trans-unit id="d1b4c04a78c4c7522f83770d237e4d7dfdc924c1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCheckedForDestructor</source>
          <target state="translated">TTypeFlag.tfCheckedForDestructor</target>
        </trans-unit>
        <trans-unit id="e44aebdb77c17dcb57c1d24ad8339727bf36ae48" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCompleteStruct</source>
          <target state="translated">TTypeFlag.tfCompleteStruct</target>
        </trans-unit>
        <trans-unit id="b77dcb2df70fd10ff909ff7e2dbcff5cc591dcf3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfConceptMatchedTypeSym</source>
          <target state="translated">TTypeFlag.tfConceptMatchedTypeSym</target>
        </trans-unit>
        <trans-unit id="fefae8ad7615c4812fbb252a50d8111bf1260edb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfContravariant</source>
          <target state="translated">TTypeFlag.tfContravariant</target>
        </trans-unit>
        <trans-unit id="865ca7278467ef7c57ec318b49c36c1058995317" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCovariant</source>
          <target state="translated">TTypeFlag.tfCovariant</target>
        </trans-unit>
        <trans-unit id="7ec74d81ff75de9cfb8d82d5ab38f21444e79930" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfEnumHasHoles</source>
          <target state="translated">TTypeFlag.tfEnumHasHoles</target>
        </trans-unit>
        <trans-unit id="62891ed3c719c5f3a87e0e3b3d719a87b193e77e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicit</source>
          <target state="translated">TTypeFlag.tfExplicit</target>
        </trans-unit>
        <trans-unit id="e655c39bef25c2645747fda6be0bfd46ffb7eb95" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicitCallConv</source>
          <target state="translated">TTypeFlag.tfExplicitCallConv</target>
        </trans-unit>
        <trans-unit id="2a0a3e3e399b7653b1ce51d297d01a7567960145" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFinal</source>
          <target state="translated">TTypeFlag.tfFinal</target>
        </trans-unit>
        <trans-unit id="7efa2781c32ea8c56df82dc8fdcb82405d5e4ec3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFromGeneric</source>
          <target state="translated">TTypeFlag.tfFromGeneric</target>
        </trans-unit>
        <trans-unit id="c8218feacbb0d962dfc20c78f02f2f19249a2499" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfGenericTypeParam</source>
          <target state="translated">TTypeFlag.tfGenericTypeParam</target>
        </trans-unit>
        <trans-unit id="94b23fdc1f9be74a942541a44b48ace763b7eeba" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasAsgn</source>
          <target state="translated">TTypeFlag.tfHasAsgn</target>
        </trans-unit>
        <trans-unit id="340337f27d0ed433616603d9f2096f2fcc004030" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasGCedMem</source>
          <target state="translated">TTypeFlag.tfHasGCedMem</target>
        </trans-unit>
        <trans-unit id="1ef98b05e773391c3890de47fca15279f6381830" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasMeta</source>
          <target state="translated">TTypeFlag.tfHasMeta</target>
        </trans-unit>
        <trans-unit id="c76cb66820108662e672cda96558668868f0ee8d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasOwned</source>
          <target state="translated">TTypeFlag.tfHasOwned</target>
        </trans-unit>
        <trans-unit id="2e772657dc53ed9a1620b3a0c39627b24331dc04" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasStatic</source>
          <target state="translated">TTypeFlag.tfHasStatic</target>
        </trans-unit>
        <trans-unit id="dff62e95dca9a1dc168f15021d19e34f13feb23e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfImplicitTypeParam</source>
          <target state="translated">TTypeFlag.tfImplicitTypeParam</target>
        </trans-unit>
        <trans-unit id="4df96677e3b3240385e91807dbc9fc3358411860" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIncompleteStruct</source>
          <target state="translated">TTypeFlag.tfIncompleteStruct</target>
        </trans-unit>
        <trans-unit id="930ccf22728f33a61ab0e9df37cdee8e9fea4d7d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInferrableStatic</source>
          <target state="translated">TTypeFlag.tfInferrableStatic</target>
        </trans-unit>
        <trans-unit id="3522e964b52dcccafb9e5b9278cb94ad79dae611" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInheritable</source>
          <target state="translated">TTypeFlag.tfInheritable</target>
        </trans-unit>
        <trans-unit id="b371c0c24a850d8dea175a373e8f12f72a1bc6f9" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIterator</source>
          <target state="translated">TTypeFlag.tfIterator</target>
        </trans-unit>
        <trans-unit id="e1ca502e9e481d427baed979cec9414f52c79127" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNeedsFullInit</source>
          <target state="translated">TTypeFlag.tfNeedsFullInit</target>
        </trans-unit>
        <trans-unit id="01077f60a85e95e4495eab0f02047407c4b30ef5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNoSideEffect</source>
          <target state="translated">TTypeFlag.tfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="79d4b029bb3501a85efe8bede40509b746b3d7a5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNotNil</source>
          <target state="translated">TTypeFlag.tfNotNil</target>
        </trans-unit>
        <trans-unit id="cbd9ad039539212e281c90be72dca6bc97948623" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPacked</source>
          <target state="translated">TTypeFlag.tfPacked</target>
        </trans-unit>
        <trans-unit id="458f48a3e3ae523480285d4c0ca455dc1c932287" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPartial</source>
          <target state="translated">TTypeFlag.tfPartial</target>
        </trans-unit>
        <trans-unit id="30060e7f1dacb103767e0e3290bea2c969e2e05b" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRefsAnonObj</source>
          <target state="translated">TTypeFlag.tfRefsAnonObj</target>
        </trans-unit>
        <trans-unit id="2ce5b832b6054dca36395a8724d2b6bf08d288fd" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRequiresInit</source>
          <target state="translated">TTypeFlag.tfRequiresInit</target>
        </trans-unit>
        <trans-unit id="6cd7c314319b31e80c85e2aeaa5b6d6229861d80" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfResolved</source>
          <target state="translated">TTypeFlag.tfResolved</target>
        </trans-unit>
        <trans-unit id="57d0c1c354ebb903950e18b1ea2422f5a671ebad" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRetType</source>
          <target state="translated">TTypeFlag.tfRetType</target>
        </trans-unit>
        <trans-unit id="19da5492bd0f1c1bed7f9b0bdbb37ad9b80297f1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfShallow</source>
          <target state="translated">TTypeFlag.tfShallow</target>
        </trans-unit>
        <trans-unit id="4fbe0e2add3932e6d78c23adc9387486f4069c85" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfThread</source>
          <target state="translated">TTypeFlag.tfThread</target>
        </trans-unit>
        <trans-unit id="ab0ce2164600dc950eb2b7fb70f55a980b4758fb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfTriggersCompileTime</source>
          <target state="translated">TTypeFlag.tfTriggersCompileTime</target>
        </trans-unit>
        <trans-unit id="124971b39b855098afccb89eafe9573eb9d42cb7" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfUnresolved</source>
          <target state="translated">TTypeFlag.tfUnresolved</target>
        </trans-unit>
        <trans-unit id="1e9a1f1b732cade91b1acda56e8c05cc36b96afb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarIsPtr</source>
          <target state="translated">TTypeFlag.tfVarIsPtr</target>
        </trans-unit>
        <trans-unit id="63329715065a634decbbdfb21351e109a6523dbc" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarargs</source>
          <target state="translated">TTypeFlag.tfVarargs</target>
        </trans-unit>
        <trans-unit id="00d99459be70f9dbf6c6302eaea8bdb97e23f954" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWeakCovariant</source>
          <target state="translated">TTypeFlag.tfWeakCovariant</target>
        </trans-unit>
        <trans-unit id="b5c1f860bd9f168e67788a1c38d26ecc09dec0fa" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWildcard</source>
          <target state="translated">TTypeFlag.tfWildcard</target>
        </trans-unit>
        <trans-unit id="2adde959189d5b343f23cd353b4d37a83cace747" translate="yes" xml:space="preserve">
          <source>TTypeFlag:</source>
          <target state="translated">TTypeFlag:</target>
        </trans-unit>
        <trans-unit id="d59afbc89b03748b97eeb7784a6be209e4ec232e" translate="yes" xml:space="preserve">
          <source>TTypeFlags:</source>
          <target state="translated">TTypeFlags:</target>
        </trans-unit>
        <trans-unit id="0799b6844305ff658e62e4c61e62afea46cba75e" translate="yes" xml:space="preserve">
          <source>TTypeIter:</source>
          <target state="translated">TTypeIter:</target>
        </trans-unit>
        <trans-unit id="0e94930a34c36d8014636584ecef2e6f378c27d4" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAlias</source>
          <target state="translated">TTypeKind.tyAlias</target>
        </trans-unit>
        <trans-unit id="aaa78f2e3d082ce1fbd4438726f28035d92e095d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnd</source>
          <target state="translated">TTypeKind.tyAnd</target>
        </trans-unit>
        <trans-unit id="fd91855f9e2dcde880f924d16173113e3e1b61e1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnything</source>
          <target state="translated">TTypeKind.tyAnything</target>
        </trans-unit>
        <trans-unit id="9354bc694c58a7afeed8a1989ffdcebda8d635ba" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyArray</source>
          <target state="translated">TTypeKind.tyArray</target>
        </trans-unit>
        <trans-unit id="d683a07782061ea2f9df06f8689f622ba9454189" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBool</source>
          <target state="translated">TTypeKind.tyBool</target>
        </trans-unit>
        <trans-unit id="4c9f258391d62b12b4667b1b42b74fb340ba6b59" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBuiltInTypeClass</source>
          <target state="translated">TTypeKind.tyBuiltInTypeClass</target>
        </trans-unit>
        <trans-unit id="6e942a569bf365b7c45b78de9efe9f71ff40de3d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCString</source>
          <target state="translated">TTypeKind.tyCString</target>
        </trans-unit>
        <trans-unit id="511c95f3bf2518a4a39007d083a27a85305bedc1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyChar</source>
          <target state="translated">TTypeKind.tyChar</target>
        </trans-unit>
        <trans-unit id="7742b6ae524066429ad5352a80bda321b5285f75" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCompositeTypeClass</source>
          <target state="translated">TTypeKind.tyCompositeTypeClass</target>
        </trans-unit>
        <trans-unit id="2a784a78647c1e3e964953a212689787e672594d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyDistinct</source>
          <target state="translated">TTypeKind.tyDistinct</target>
        </trans-unit>
        <trans-unit id="18c089e63473641136815b0a6d7bf588d7d64999" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEmpty</source>
          <target state="translated">TTypeKind.tyEmpty</target>
        </trans-unit>
        <trans-unit id="2526b0c10b2351f8dbfa6da5035a8a387fa9c777" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEnum</source>
          <target state="translated">TTypeKind.tyEnum</target>
        </trans-unit>
        <trans-unit id="9fe7ce6fd6ca9fbd4f25ef3769702eb83ff469dd" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat</source>
          <target state="translated">TTypeKind.tyFloat</target>
        </trans-unit>
        <trans-unit id="a4769bad08648c768c93b8baf10d667c24671dad" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat128</source>
          <target state="translated">TTypeKind.tyFloat128</target>
        </trans-unit>
        <trans-unit id="137504e5db5f6079c3f46e17fdc68f112e26aa6f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat32</source>
          <target state="translated">TTypeKind.tyFloat32</target>
        </trans-unit>
        <trans-unit id="2320a8bfb8228efc60a98b1d16d14d4f0d1433c1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat64</source>
          <target state="translated">TTypeKind.tyFloat64</target>
        </trans-unit>
        <trans-unit id="90f5e7cf547d6b01512557903c89b0a2ad5c7032" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyForward</source>
          <target state="translated">TTypeKind.tyForward</target>
        </trans-unit>
        <trans-unit id="3b0b71a42c8eb3c1fdfda0933a8770612f7d08f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFromExpr</source>
          <target state="translated">TTypeKind.tyFromExpr</target>
        </trans-unit>
        <trans-unit id="12d126b517177624b9e02b6b96c24ae10adf45eb" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericBody</source>
          <target state="translated">TTypeKind.tyGenericBody</target>
        </trans-unit>
        <trans-unit id="de845c162ecd730c92bb80e09d4bb9053e73e573" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInst</source>
          <target state="translated">TTypeKind.tyGenericInst</target>
        </trans-unit>
        <trans-unit id="f88959f6c872ba3ea1f46dfc3561a3c5dde14c54" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInvocation</source>
          <target state="translated">TTypeKind.tyGenericInvocation</target>
        </trans-unit>
        <trans-unit id="fbb70eb257b50185f4b954462d2ba16e53967fed" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericParam</source>
          <target state="translated">TTypeKind.tyGenericParam</target>
        </trans-unit>
        <trans-unit id="853c3eecc6fcaf56b29249082e02899201195e48" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInferred</source>
          <target state="translated">TTypeKind.tyInferred</target>
        </trans-unit>
        <trans-unit id="6404738e10ebb3dcb5589e48bb5e56bb2533caaa" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt</source>
          <target state="translated">TTypeKind.tyInt</target>
        </trans-unit>
        <trans-unit id="7c8ee29852e8351d0f1d971179082ce8cd2b0024" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt16</source>
          <target state="translated">TTypeKind.tyInt16</target>
        </trans-unit>
        <trans-unit id="b5b83741acbdbefe77c61f8a51808f3d606f63cc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt32</source>
          <target state="translated">TTypeKind.tyInt32</target>
        </trans-unit>
        <trans-unit id="123cec70680ef83da6e7a9ffb0d86468a21015be" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt64</source>
          <target state="translated">TTypeKind.tyInt64</target>
        </trans-unit>
        <trans-unit id="ac89b343111dc1fff094fe7dbcf90fdc19196e9f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt8</source>
          <target state="translated">TTypeKind.tyInt8</target>
        </trans-unit>
        <trans-unit id="76f25dd9884e161024bfa5f564f1906fa8cf619f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyLent</source>
          <target state="translated">TTypeKind.tyLent</target>
        </trans-unit>
        <trans-unit id="35cb952eb790cfb8e6a4e4aab86c688b8fa7e124" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNil</source>
          <target state="translated">TTypeKind.tyNil</target>
        </trans-unit>
        <trans-unit id="71e8edc4e61c7cdf3e4997d53132d2cda61cf5fc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNone</source>
          <target state="translated">TTypeKind.tyNone</target>
        </trans-unit>
        <trans-unit id="1369f3e3f05baa699232f96db48f89e2c5242e25" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNot</source>
          <target state="translated">TTypeKind.tyNot</target>
        </trans-unit>
        <trans-unit id="9869385fdcf65fc4a99fec4a021241c955d0aa0d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyObject</source>
          <target state="translated">TTypeKind.tyObject</target>
        </trans-unit>
        <trans-unit id="76b82e94d2b94bf82bc8e9254e91d86d17d2978c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOpenArray</source>
          <target state="translated">TTypeKind.tyOpenArray</target>
        </trans-unit>
        <trans-unit id="048e0ed42c7f4744c48765cba6ff85550d9a0211" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOptDeprecated</source>
          <target state="translated">TTypeKind.tyOptDeprecated</target>
        </trans-unit>
        <trans-unit id="18dd91d976315b46cb15e86ec56c56d374119c01" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOr</source>
          <target state="translated">TTypeKind.tyOr</target>
        </trans-unit>
        <trans-unit id="cc7bb6ded55da7fb8d1720b7046d8b4bbae4787d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOrdinal</source>
          <target state="translated">TTypeKind.tyOrdinal</target>
        </trans-unit>
        <trans-unit id="cea6fcc9a7c93c39e116e6f6c1f7689425ab37da" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOwned</source>
          <target state="translated">TTypeKind.tyOwned</target>
        </trans-unit>
        <trans-unit id="be58929a3b5905e5864a5485a037acbc879065fe" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPointer</source>
          <target state="translated">TTypeKind.tyPointer</target>
        </trans-unit>
        <trans-unit id="67120b56f6d6aa69e8bc1107a81083dfa3ee051c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProc</source>
          <target state="translated">TTypeKind.tyProc</target>
        </trans-unit>
        <trans-unit id="59a5014ce6420bae5c138704ad0fd1c37bcde90a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProxy</source>
          <target state="translated">TTypeKind.tyProxy</target>
        </trans-unit>
        <trans-unit id="057a72ed748c03837581945e869c3f0ed0e92469" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPtr</source>
          <target state="translated">TTypeKind.tyPtr</target>
        </trans-unit>
        <trans-unit id="c8eed250118a7a9d611bef4dc76f8aaacce2fd38" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRange</source>
          <target state="translated">TTypeKind.tyRange</target>
        </trans-unit>
        <trans-unit id="cba8b92fdb447a4f368ae8ca4e118769c1b3efbc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRef</source>
          <target state="translated">TTypeKind.tyRef</target>
        </trans-unit>
        <trans-unit id="fa5dda72f61e0985f3c73b6f0bb85cd481daea63" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySequence</source>
          <target state="translated">TTypeKind.tySequence</target>
        </trans-unit>
        <trans-unit id="ee6ab4c13a0e2ed8b67bb350e10728fbc4cf9b33" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySet</source>
          <target state="translated">TTypeKind.tySet</target>
        </trans-unit>
        <trans-unit id="aa5a8169c7e1887deee9d36d06459624aba21871" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySink</source>
          <target state="translated">TTypeKind.tySink</target>
        </trans-unit>
        <trans-unit id="8d1466bb3d8fbc74b547dbb02f8273952a0b78af" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyStatic</source>
          <target state="translated">TTypeKind.tyStatic</target>
        </trans-unit>
        <trans-unit id="b3ef56ea678262c074740aa06af22e3a6787d993" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyString</source>
          <target state="translated">TTypeKind.tyString</target>
        </trans-unit>
        <trans-unit id="64ea2c5a8456daca800c8a3b265eba0a8ade3ce6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTuple</source>
          <target state="translated">TTypeKind.tyTuple</target>
        </trans-unit>
        <trans-unit id="88fc66a60b94046b8dcb50a75f66be0331e70f96" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTypeDesc</source>
          <target state="translated">TTypeKind.tyTypeDesc</target>
        </trans-unit>
        <trans-unit id="142da8d1e146731ca1c66fd3bcd95bba93b8fe3c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTyped</source>
          <target state="translated">TTypeKind.tyTyped</target>
        </trans-unit>
        <trans-unit id="1658fe5326db5a52a5764addf749b1e6161f0ce9" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt</source>
          <target state="translated">TTypeKind.tyUInt</target>
        </trans-unit>
        <trans-unit id="48317f7c389eeb326c561089ca5e8724017fa883" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt16</source>
          <target state="translated">TTypeKind.tyUInt16</target>
        </trans-unit>
        <trans-unit id="6238df6a06ed2f153d500aba172e98e52f860f9b" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt32</source>
          <target state="translated">TTypeKind.tyUInt32</target>
        </trans-unit>
        <trans-unit id="54b6ec0922deab6616588f895ec17ad140779038" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt64</source>
          <target state="translated">TTypeKind.tyUInt64</target>
        </trans-unit>
        <trans-unit id="a60a984a93b313cce3325fc55efa6c80fb9d3af7" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt8</source>
          <target state="translated">TTypeKind.tyUInt8</target>
        </trans-unit>
        <trans-unit id="4d387420fd3b923de5af82186671f01ffdda3b42" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUncheckedArray</source>
          <target state="translated">TTypeKind.tyUncheckedArray</target>
        </trans-unit>
        <trans-unit id="5fea571764be8dd44ae507fe59dfe65eb19a23f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUntyped</source>
          <target state="translated">TTypeKind.tyUntyped</target>
        </trans-unit>
        <trans-unit id="2f7a5d57c0ae3f1e3072ce48e36c4dfa73af6c2d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClass</source>
          <target state="translated">TTypeKind.tyUserTypeClass</target>
        </trans-unit>
        <trans-unit id="24264e5e4579a6ec06665830d8241dd5aa692ba3" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClassInst</source>
          <target state="translated">TTypeKind.tyUserTypeClassInst</target>
        </trans-unit>
        <trans-unit id="9c04403a1098db54c18beaf124b6e51bee5f7895" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVar</source>
          <target state="translated">TTypeKind.tyVar</target>
        </trans-unit>
        <trans-unit id="866cab95392f4667de7ddae8e874f6986631628a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVarargs</source>
          <target state="translated">TTypeKind.tyVarargs</target>
        </trans-unit>
        <trans-unit id="0b2d9d9a212dcc3a4f3dad5f1e7b0175893b324c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVoid</source>
          <target state="translated">TTypeKind.tyVoid</target>
        </trans-unit>
        <trans-unit id="3134e079fd35c63fb7e622ec1abdb7e40e287014" translate="yes" xml:space="preserve">
          <source>TTypeKind:</source>
          <target state="translated">TTypeKind:</target>
        </trans-unit>
        <trans-unit id="a8c405dd55f6718f5c54eeffd414bca9bafc966d" translate="yes" xml:space="preserve">
          <source>TTypeKinds:</source>
          <target state="translated">TTypeKinds:</target>
        </trans-unit>
        <trans-unit id="ae0ffc4a19658ae080fa434ffc876212d8e0d92d" translate="yes" xml:space="preserve">
          <source>TTypeMutator:</source>
          <target state="translated">TTypeMutator:</target>
        </trans-unit>
        <trans-unit id="05748a9a1a8c6a023693c76bab719c68ef5b92fd" translate="yes" xml:space="preserve">
          <source>TTypePredicate:</source>
          <target state="translated">TTypePredicate:</target>
        </trans-unit>
        <trans-unit id="c5566ac9e2bab44c01dcf254d6aee02e6b31a08b" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trBindGenericParam</source>
          <target state="translated">TTypeRelFlag.trBindGenericParam</target>
        </trans-unit>
        <trans-unit id="3e622cd2fec1785d21b7f65f5c359ac7937ffca0" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trDontBind</source>
          <target state="translated">TTypeRelFlag.trDontBind</target>
        </trans-unit>
        <trans-unit id="78c4a7d831ae9cc483125be7ce07c572063bbc4f" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trNoCovariance</source>
          <target state="translated">TTypeRelFlag.trNoCovariance</target>
        </trans-unit>
        <trans-unit id="af4b6bd841aa6a165e0d34d467927854db0bdc8a" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag:</source>
          <target state="translated">TTypeRelFlag:</target>
        </trans-unit>
        <trans-unit id="e94014289638374be4190459e1bb501dfbfe41b3" translate="yes" xml:space="preserve">
          <source>TTypeRelFlags:</source>
          <target state="translated">TTypeRelFlags:</target>
        </trans-unit>
        <trans-unit id="68cb51af66e4090ea344468d781203193c332184" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isBothMetaConvertible</source>
          <target state="translated">TTypeRelation.isBothMetaConvertible</target>
        </trans-unit>
        <trans-unit id="a2e80fd4cc56e47b80e688c235bbc805b6e28b7f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isConvertible</source>
          <target state="translated">TTypeRelation.isConvertible</target>
        </trans-unit>
        <trans-unit id="54f04f59123456c3c8647d13c32aa81bb0bc0b52" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isEqual</source>
          <target state="translated">TTypeRelation.isEqual</target>
        </trans-unit>
        <trans-unit id="76aabe09fdc4d3bcdca6dfca911f86ac68529f00" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isFromIntLit</source>
          <target state="translated">TTypeRelation.isFromIntLit</target>
        </trans-unit>
        <trans-unit id="082a825a1a1a2a4f69e162637c5a47f9d4400e34" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isGeneric</source>
          <target state="translated">TTypeRelation.isGeneric</target>
        </trans-unit>
        <trans-unit id="72c719a9fea45aac02dd7bcd06d7c7ed7f91da1d" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferred</source>
          <target state="translated">TTypeRelation.isInferred</target>
        </trans-unit>
        <trans-unit id="662bc4c4df86dd8e5b1049fa1d4acfbe0e2d8265" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferredConvertible</source>
          <target state="translated">TTypeRelation.isInferredConvertible</target>
        </trans-unit>
        <trans-unit id="8a647b6c47b21eace0c04cd901e76cde68ae44ee" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isIntConv</source>
          <target state="translated">TTypeRelation.isIntConv</target>
        </trans-unit>
        <trans-unit id="4077456390389013fe90dba0c8bf8db83eb1972c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isNone</source>
          <target state="translated">TTypeRelation.isNone</target>
        </trans-unit>
        <trans-unit id="4b202228dda6caf9d917364e5054857c13bc8b7c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubrange</source>
          <target state="translated">TTypeRelation.isSubrange</target>
        </trans-unit>
        <trans-unit id="22c70d23f666f85e7e90ddf5522d7832f8ee4f8f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubtype</source>
          <target state="translated">TTypeRelation.isSubtype</target>
        </trans-unit>
        <trans-unit id="d3d3096e711373571f5b9192698fbb731341abb9" translate="yes" xml:space="preserve">
          <source>TTypeRelation:</source>
          <target state="translated">TTypeRelation:</target>
        </trans-unit>
        <trans-unit id="bef60ed135f7ec02d27299402bbea768a713fd96" translate="yes" xml:space="preserve">
          <source>TTypeSeq:</source>
          <target state="translated">TTypeSeq:</target>
        </trans-unit>
        <trans-unit id="0424f6e7026fa4bc2c4a7043083417315113c79b" translate="yes" xml:space="preserve">
          <source>Table</source>
          <target state="translated">Table</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">表构造器</target>
        </trans-unit>
        <trans-unit id="e587514d976f1576a7f186c3a6d78f175315a9f6" translate="yes" xml:space="preserve">
          <source>Tabulator:</source>
          <target state="translated">Tabulator:</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">标签跟踪</target>
        </trans-unit>
        <trans-unit id="479ac325890826d9bc3274ae4b0deca389100a15" translate="yes" xml:space="preserve">
          <source>TagsExt:</source>
          <target state="translated">TagsExt:</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">在将类型声明为 &lt;code&gt;proc&lt;/code&gt; 时要特别小心。该行为类似于下面的 &lt;code&gt;Procedure declaration&lt;/code&gt; ，但不处理 &lt;code&gt;nnkGenericParams&lt;/code&gt; 。泛型参数按类型而不是 &lt;code&gt;proc&lt;/code&gt; 本身处理。</target>
        </trans-unit>
        <trans-unit id="d3177dcd252a829ea158763962a47c4a3515c7ff" translate="yes" xml:space="preserve">
          <source>Take the address of a memory location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ca39d193d2434090092284c392d73e10f5bf2" translate="yes" xml:space="preserve">
          <source>Take the element at the reversed index &lt;code&gt;x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;typedesc&lt;/code&gt; 作为其第一个参数，以及一系列类型为 &lt;code&gt;key: value&lt;/code&gt; 的表达式，并返回指定类型的值，其中每个字段 &lt;code&gt;key&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt; ，如 &lt;code&gt;{}&lt;/code&gt; 的参数中所指定。</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">取一个float,包含自unix epoch以来的秒数,并返回一个时间对象。</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">取一个包含自unix纪元以来的秒数的int,并返回一个时间对象。</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">取一个整数并输出尽可能多的 &quot;hello world!&quot;。</target>
        </trans-unit>
        <trans-unit id="c9d3b8db138f77125cd16835e385cbe69f4a0651" translate="yes" xml:space="preserve">
          <source>Takes any Nim variable and returns its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">读取多个序列的项目,并将其返回到一个新的序列中。</target>
        </trans-unit>
        <trans-unit id="1d0f497b886e1c9d3d4474b4148e5709da878636" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">获取过程的名称并将其包装到缺少第一个参数的lambda中，该参数将内置 &lt;code&gt;this&lt;/code&gt; 的JavaScript 作为该过程的第一个参数传递。返回结果lambda。</target>
        </trans-unit>
        <trans-unit id="652ac2cbbafccc62d55637f20bfa949ef565ffbd" translate="yes" xml:space="preserve">
          <source>Target:</source>
          <target state="translated">Target:</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="355e12f6e10b7be272268c5408e0e1f1879ead8f" translate="yes" xml:space="preserve">
          <source>Template based implementation of singly and doubly linked lists. The involved types should have 'prev' or 'next' fields and the list header should have 'head' or 'tail' fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">模板声明</target>
        </trans-unit>
        <trans-unit id="29776c1f962d7f1926246264b64cf2699a605475" translate="yes" xml:space="preserve">
          <source>Template evaluation engine. Now hygienic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">模板从左到右折叠一个序列,返回积累。</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">模板从右到左折叠一个序列,返回积累。</target>
        </trans-unit>
        <trans-unit id="59878defe4e964ab557114291111d6b850a911e6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;code&gt;useStdoutAsStdmsg&lt;/code&gt; compile-time switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">根据&lt;em&gt;useStdoutAsStdmsg&lt;/em&gt;编译时开关，扩展为stdout或stderr的模板。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">与proc和迭代器相比，模板（以及宏，我们将看到）具有稍微扩展的AST。这样做的原因是[term-rewriting宏]（&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros）&lt;/a&gt;。注意上面的 &lt;code&gt;nnkProcDef&lt;/code&gt; 和 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 的第二个参数 &lt;code&gt;nnkEmpty()&lt;/code&gt; 吗？这就是术语重写宏的去向。</target>
        </trans-unit>
        <trans-unit id="f36defcdec2c7464ebb1521bbe1cf9a515e6bfe9" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](manual.html#term-rewriting-macros). Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">模板是一种简单的替换机制,它在Nim的抽象语法树上运行。模板在编译器的语义通道中进行处理。它们与语言的其他部分很好地集成在一起,并且没有C语言的预处理器宏的缺陷。</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">模板对于懒惰的评估目的特别有用。考虑一个简单的记录过程。</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readLine&lt;/code&gt; 的临时存储</target>
        </trans-unit>
        <trans-unit id="436d3b3abfa26ce88c28da41a780d32ff7044d09" translate="yes" xml:space="preserve">
          <source>Ten:</source>
          <target state="translated">Ten:</target>
        </trans-unit>
        <trans-unit id="12becf9bfcde13ef359cbd10e21ac3558b60cd6c" translate="yes" xml:space="preserve">
          <source>Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">术语改写宏</target>
        </trans-unit>
        <trans-unit id="4139a7e773cb83cc6ffda3dc77a553344908c967" translate="yes" xml:space="preserve">
          <source>Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, e.g. when rewriting term to same term plus extra content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">术语重写宏是不仅具有&lt;em&gt;名称，&lt;/em&gt;而且具有在编译器的语义检查阶段之后搜索的&lt;em&gt;模式的&lt;/em&gt;宏或模板：这意味着它们提供了一种通过用户定义的优化来增强编译管道的简便方法：</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">终端符号</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的终端符号： &lt;code&gt;RSTR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的终端符号： &lt;code&gt;STR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的 &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; 符号：TRIPLESTR_LIT。</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">语法中的 &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; 符号：GENERALIZED_STR_LIT， &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">终止异步http服务器实例。</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">终止与服务器的连接。</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">测试案例文件格式</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">测试块特殊文件。</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">测试字符特殊文件。</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">测试一个目录。</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">测试消息队列。</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">测试管道或FIFO特殊文件。</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">测试一个常规文件。</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">测试信号灯。</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">测试共享内存对象。</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">测试一个插座。</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">测试一个符号链接。</target>
        </trans-unit>
        <trans-unit id="4605d91385c3aaf247a50562a412cef1a6a892ab" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;body&lt;/code&gt; raises an exception found in the passed &lt;code&gt;exceptions&lt;/code&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">测试&lt;em&gt;body是否&lt;/em&gt;引发在传递的异常中发现的&lt;em&gt;异常&lt;/em&gt;。如果引发的异常是可接受异常的一部分，则测试通过。否则，它将失败。例：</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">类型化内存对象的测试宏。</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">测试套件</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">在这些操作系统上测试。Linux,Windows,OSX</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">测试可以被嵌套,但是嵌套测试的失败并不会将父测试标记为失败。设置和删除是继承的。设置可以在本地被覆盖。</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">执行与&lt;strong&gt;任何&lt;/strong&gt;参数匹配的测试。</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">测试DOM实现是否实现了特定的功能,以及该功能是否被该节点支持。</target>
        </trans-unit>
        <trans-unit id="1e818cf07cf8e76c8618215a67e1d6f19768f1e0" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">在 Amd64 上使用 GCC 进行的测试表明,如果将 &quot;环境 &quot;指针作为最后一个参数,而不是第一个参数传递,那将是非常有益的。</target>
        </trans-unit>
        <trans-unit id="eddf3fb8e9d38e4f4520f01f09a65dc746e3f5e3" translate="yes" xml:space="preserve">
          <source>TexExt:</source>
          <target state="translated">TexExt:</target>
        </trans-unit>
        <trans-unit id="e8cdc19c721145f3b16f493ae9be16412d223832" translate="yes" xml:space="preserve">
          <source>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with &lt;code&gt;-d:futureLogging&lt;/code&gt; and use the &lt;code&gt;getFuturesInProgress&lt;/code&gt; procedure to get the list of pending futures together with the stack traces to the moment of their creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">由于其条件构造 &lt;code&gt;$[0|1|2|else]&lt;/code&gt; 它很好地支持格式字符串文字的&lt;span id=&quot;internationalization_1&quot;&gt;国际化&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">这意味着只有第一个字母会以区分大小写的方式进行比较。其他字母在ASCII码范围内进行不区分大小写的比较,下划线被忽略。</target>
        </trans-unit>
        <trans-unit id="a28d5e34c7b2663c0713d2b4afa31d2e7083c425" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case-sensitive manner. Other letters are compared case-insensitively within the ASCII range and underscores are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">这意味着要将其转换为小写,并删除任何'_'。这不应该用来规范Nim标识符名称。</target>
        </trans-unit>
        <trans-unit id="3e6b575176e4e0021d4817389fa98f764c8fefe3" translate="yes" xml:space="preserve">
          <source>That means to convert to lower case and remove any '_' on all characters except first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff708ff6bc18720eda543fbf97c4bd701261199" translate="yes" xml:space="preserve">
          <source>That these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">&quot;``&quot;符号也可以像其他过程一样用来调用操作符。</target>
        </trans-unit>
        <trans-unit id="5f2ef68a81ed2af2d4d7e3322bfe17eca009c9a5" translate="yes" xml:space="preserve">
          <source>The &quot;compiler&quot; directory contains compiler sources and should not be part of the compiler binary package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">&amp;ldquo; hello world&amp;rdquo;程序包含几个编译器已知的标识符： &lt;code&gt;echo&lt;/code&gt; ，&lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;等。这些内置函数在&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块中声明，该模块由其他模块隐式导入。</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">该模板的&amp;ldquo;类型&amp;rdquo;可以是符号 &lt;code&gt;untyped&lt;/code&gt; ， &lt;code&gt;typed&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 。这些是&amp;ldquo;元类型&amp;rdquo;，它们只能在某些情况下使用。也可以使用常规类型。这意味着应该使用 &lt;code&gt;typed&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="58575d0da306b056823523ef29ad9acd2044c039" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;typedesc&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">精度 &quot;是一个小数,表示在浮点转换中小数点后应该显示多少位。对于非数字类型,该字段表示最大字段大小--换句话说,字段内容将使用多少个字符。对于整数转换,精度被忽略。</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">'return'语句最好在需要其控制流属性的时候使用。尽可能地使用存储过程的隐式'结果'变量。这样可以提高可读性。</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">符号 &quot;选项只对数字类型有效,可以是以下之一。</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">在用于构建程序的架构上,用来表示任何浮点类型的(整数)值。</target>
        </trans-unit>
        <trans-unit id="ff8eeedfc1309560a0b81603400e43bdfaaa92e0" translate="yes" xml:space="preserve">
          <source>The .cursor annotation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb52f076b6836abd5a2c61714693f2d361382a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;format variables&lt;/a&gt; present within &lt;code&gt;frmt&lt;/code&gt; will be replaced with the corresponding values before being prepended to &lt;code&gt;args&lt;/code&gt; and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f1e3b636e0e7248dc7db8e6a0a959c7c1db3d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt iterator&lt;/a&gt;, which is provided for convenience, can be used to iterate through all command line options as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">该&lt;a href=&quot;#nimble&quot;&gt;底部&lt;/a&gt;本页包括由稔社区创建的第三方包的列表。这些软件包是对标准库中模块的有用补充。</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">《&lt;a href=&quot;nimc&quot;&gt;Nim Compiler用户指南》&lt;/a&gt;记录了典型的编译器调用，使用 &lt;code&gt;compile&lt;/code&gt; 或 &lt;code&gt;c&lt;/code&gt; 命令将 &lt;code&gt;.nim&lt;/code&gt; 文件转换为一个或多个 &lt;code&gt;.c&lt;/code&gt; 文件，然后使用平台的C编译器将其编译为静态二进制文件。但是，还有其他命令可以编译为C ++，Objective-C或JavaScript。本文档尝试将所有后端和接口选项集中在一个地方。</target>
        </trans-unit>
        <trans-unit id="8d531a309bd956c39bd6508c1a41b8169d1ae032" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33326c6e57348f7442036bfc7267b110b7072b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt;命令行开关允许避免动态，如果你需要静态链接的东西而不是链接。如果源很少，则设计为静态链接源文件的Nim包装器可以使用&lt;a href=&quot;nimc#compile-pragma&quot;&gt;编译&lt;/a&gt;实用程序，或者与使用系统库相比，沿着Nim代码提供它们很容易。主机系统上安装的库可以与&lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL编译指示&lt;/a&gt;链接。</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">该&lt;a href=&quot;system#inc&quot;&gt;INC&lt;/a&gt;，&lt;a href=&quot;system#dec&quot;&gt;十二月&lt;/a&gt;，&lt;a href=&quot;system#succ&quot;&gt;SUCC&lt;/a&gt;和&lt;a href=&quot;system#pred&quot;&gt;预解码&lt;/a&gt;操作可以通过提高一个失败&lt;em&gt;EOutOfRange&lt;/em&gt;或&lt;em&gt;EOVERFLOW&lt;/em&gt;例外。（如果在正确的运行时检查已打开的情况下编译了代码。）</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">该 &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; ， &lt;code&gt;notin&lt;/code&gt; ， &lt;code&gt;isnot&lt;/code&gt; 运营商其实都是模板：</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">该 &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; ， &lt;code&gt;notin&lt;/code&gt; ， &lt;code&gt;isnot&lt;/code&gt; 运营商实际上都是模板：这一个好处，如果你重载 &lt;code&gt;==&lt;/code&gt; 操作符， &lt;code&gt;!=&lt;/code&gt; 运算符是自动提供并做正确的事。（除了IEEE浮点数-NaN破坏了基本的布尔逻辑。）</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">该 &lt;code&gt;#header&lt;/code&gt; 和 &lt;code&gt;#dynlib&lt;/code&gt; 指令是互斥的。绑定使用 &lt;code&gt;dynlib&lt;/code&gt; 超过一个使用更加优选的 &lt;code&gt;header&lt;/code&gt; ！Nim编译器将来可能会放弃对 &lt;code&gt;header&lt;/code&gt; 编译指示的支持，因为它不适用于不生成C代码的后端。</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">该 &lt;code&gt;#header&lt;/code&gt; 指令告诉c2nim，它应该标注每一个进程内起因于C函数原型和每个导出的变量和类型与 &lt;code&gt;header&lt;/code&gt; 编译：</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">该 &lt;code&gt;#skipcomments&lt;/code&gt; 指令可以被放入C代码，使c2nim忽略注释，而不是将它们复制到生成的文件稔。</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">所述 &lt;code&gt;#typeprefixes&lt;/code&gt; 指令可以被放入C代码，以使c2nim生成 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 为每个定义的类型的前缀。</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">在 &lt;code&gt;$&lt;/code&gt; 操作者可以在任何枚举值转换为它的名称和 &lt;code&gt;ord&lt;/code&gt; PROC可以将其转换到其基础整数值。</target>
        </trans-unit>
        <trans-unit id="95c3c3a1c938decb53d03460e20948578c7b0a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for count tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3f7201a0436a6523f0d28e1c7472c08aaccda5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592ba1cbd0b60e530272f88b56bd19674725e88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for int sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b4969c881c889a18fdc86d07e053ec65d62580" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for ordered hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87980ae4827ecb34a1ff7d3485ef0b12328b955c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for string tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2254ec838e1c34b6ee8c8791b0a6e0a4aeca15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator for string tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">该 &lt;code&gt;**&lt;/code&gt; 很像 &lt;code&gt;*&lt;/code&gt; 运营商，但它收集不仅所有的参数，而且在逆波兰式匹配的运营商：</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;**&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;*&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;*&lt;/code&gt; 操作者可以&lt;em&gt;弄平&lt;/em&gt;嵌套二进制表达式像 &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; 到 &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7325bb59d54b70872d714ee28dd75a93b55b1c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">该 &lt;code&gt;--context&lt;/code&gt; idetools开关是非常相似的建议切换，但不是用户键入点字符之后仍然被使用，这一项是指用户键入开括号开始输入参数后使用。</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">所述 &lt;code&gt;--def&lt;/code&gt; idetools开关执行查询关于特定符号的定义。如果可用，idetools将回答类型，源文件，行/列信息以及其他附件数据（如docstring）。通过此信息，IDE可以提供典型的&lt;em&gt;跳转到定义&lt;/em&gt;，用户将光标放在符号上或使用鼠标将其选中，然后将其重定向到该符号所在的位置。</target>
        </trans-unit>
        <trans-unit id="2c77fdad272c7f83697c8335c9696141ee28e928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">所述 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;编译器开关&lt;/a&gt;可被用于改变 &lt;code&gt;nimcache&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="146fd580f174db8b693f082a350984eb09df126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--opt:size&lt;/code&gt; flag instructs Nim to optimize code generation for small size (with the help of the C compiler), the &lt;code&gt;flto&lt;/code&gt; flags enable link-time optimization in the compiler and linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fec47225002df51e5d78ab7e3be5b902b13708f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--os:any&lt;/code&gt; target makes sure Nim does not depend on any specific operating system primitives. Your platform should support only some basic ANSI C library &lt;code&gt;stdlib&lt;/code&gt; and &lt;code&gt;stdio&lt;/code&gt; functions which should be available on almost any platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">所述 &lt;code&gt;--suggest&lt;/code&gt; idetools开关执行关于可能完成符号查询在文件中的某些点。IDE可以轻松提供自动完成功能，其中IDE扫描当前文件（以及相关文件，如果它知道所编辑的语言并遵循包含/导入），并且当用户开始输入内容时，会出现带有不同选项的完成框。</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">该 &lt;code&gt;--usages&lt;/code&gt; idetools切换列表符号的所有使用的位置。IDE可以使用它查找文件中使用符号的所有位置，并向用户提供同时在所有位置对其进行重命名的功能。同样，基于纯字符串的搜索和替换可能会捕获符号超出功能/循环的范围。</target>
        </trans-unit>
        <trans-unit id="33e88f9afb7898deea226f46d03930aa92460478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d:useMalloc&lt;/code&gt; option configures Nim to use only the standard C memory manage primitives &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt;, &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">的 &lt;code&gt;.&lt;/code&gt; （访问元组/对象字段运算符）和 &lt;code&gt;[]&lt;/code&gt; （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</target>
        </trans-unit>
        <trans-unit id="1d69f7e7cab8a172b5bea310651ee4c1dc8772c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b687c86ec2ab86619a184b73c9bb7473dd71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56b80171a975839d82b828a2290c7051d9d6a18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6340fe457b063ff32ecbbcad36851c6c0ef42d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4893cd5a1f2f96e22540b712be98b5f5c896cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns &lt;code&gt;true&lt;/code&gt; if both the content and the order are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097201b62a35fb9d118671fbad0be2c8082835fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns true if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f0325065de9343e95b504b2a34a35889dcc865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=copy&lt;/code&gt; proc can be marked with the &lt;code&gt;{.error.}&lt;/code&gt; pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time. This looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">该 &lt;code&gt;C2NIM&lt;/code&gt; 符号只承认在 &lt;code&gt;#ifdef&lt;/code&gt; 和 &lt;code&gt;#ifndef&lt;/code&gt; 构造！ &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; 确实&lt;strong&gt;没有&lt;/strong&gt;工作。</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">的 &lt;code&gt;DateTime&lt;/code&gt; 类型可被解析，并使用不同的格式的 &lt;code&gt;parse&lt;/code&gt; 和 &lt;code&gt;format&lt;/code&gt; 的程序。</target>
        </trans-unit>
        <trans-unit id="341a37bcfc2e71e9b4ee3ff4166502922770ca31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INFO&lt;/code&gt; within the output is the result of a format string being prepended to the message, and it will differ depending on the message's level. Format strings are &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;explained in more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; 如果引发异常 &lt;code&gt;x&lt;/code&gt; 是不是 &lt;code&gt;Student&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f5c304640c208580c9c382b206a712cca543ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MonoTime&lt;/code&gt; type stores the timestamp in nanosecond resolution, but note that the actual supported time resolution differs for different systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">的 &lt;code&gt;RstParseOptions&lt;/code&gt; ， &lt;code&gt;FindFileHandler&lt;/code&gt; 和 &lt;code&gt;MsgHandler&lt;/code&gt; 类型的中定义的&lt;a href=&quot;rst&quot;&gt;包/ docutils的/ RST模块&lt;/a&gt;。 &lt;code&gt;options&lt;/code&gt; 选择第一个解析器的行为。</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">该 &lt;code&gt;T&lt;/code&gt; 被称为&lt;span id=&quot;generic-type-parameter_1&quot;&gt;通用型参数&lt;/span&gt;或&lt;span id=&quot;type-variable_1&quot;&gt;类型的变量&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="550a18c4fa132b938176c8146984c85cfbb782d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeInterval&lt;/code&gt; type uses calendar units, and will say that exactly one day has passed. The &lt;code&gt;Duration&lt;/code&gt; type on the other hand normalizes everything to seconds, and will therefore say that 90000 seconds has passed, which is the same as 25 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0401867a6b1c084a80db776014298aa78e4619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UncheckedArray[T]&lt;/code&gt; type is a special kind of &lt;code&gt;array&lt;/code&gt; where its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally, an unchecked array is translated into a C array of undetermined size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">的 &lt;code&gt;[: ]&lt;/code&gt; 符号已被设计为减轻此问题的方法： &lt;code&gt;x.p[:T]&lt;/code&gt; 被分析器改写为 &lt;code&gt;p[T](x)&lt;/code&gt; ， &lt;code&gt;x.p[:T](y)&lt;/code&gt; 被改写为 &lt;code&gt;p[T](x, y)&lt;/code&gt; 。注意 &lt;code&gt;[: ]&lt;/code&gt; 没有AST表示，重写直接在分析步骤中执行。</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">在 &lt;code&gt;[]&lt;/code&gt; 数组访问运算符可以被重载以提供&lt;span id=&quot;array-properties_1&quot;&gt;阵列属性&lt;/span&gt;：</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果指定的字段不存在，则 &lt;code&gt;[]&lt;/code&gt; 运算符将引发异常。如果希望避免这种行为，可以改用 &lt;code&gt;{}&lt;/code&gt; 运算符，当找不到该字段时，它将仅返回 &lt;code&gt;nil&lt;/code&gt; 。过程的 &lt;code&gt;get&lt;/code&gt; - family在 &lt;code&gt;nil&lt;/code&gt; 上调用时将返回默认值。</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">数组/ openarrays / sequence 的 &lt;code&gt;[]&lt;/code&gt; 下标运算符可以重载。</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">该 &lt;code&gt;\A&lt;/code&gt; ， &lt;code&gt;\Z&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 断言之处在于它们仅匹配在起步和目标字符串，任何选项都设置结束了传统的音调符和美元。之间的差 &lt;code&gt;\Z&lt;/code&gt; 和 &lt;code&gt;\z&lt;/code&gt; 是 &lt;code&gt;\Z&lt;/code&gt; 换行符，其在所述串的结束字符串的以及最后一个字符，而在此之前的比赛 &lt;code&gt;\z&lt;/code&gt; 仅在端部相匹配。</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">该 &lt;code&gt;_r&lt;/code&gt; 后缀用于发布版本， &lt;code&gt;_d&lt;/code&gt; 是建立调试。</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">如果在 &lt;code&gt;accept&lt;/code&gt; 期间连接套接字断开连接， &lt;code&gt;accept&lt;/code&gt; 调用可能会导致错误。如果指定了 &lt;code&gt;SafeDisconn&lt;/code&gt; 标志，则不会引发此错误，而是将再次调用accept。</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">该 &lt;code&gt;acyclic&lt;/code&gt; 编译可用于对象类型将它们标记为非周期性尽管他们似乎是循环的。这是垃圾收集器的一种&lt;strong&gt;优化&lt;/strong&gt;，它不将这种类型的对象视为周期的一部分：</target>
        </trans-unit>
        <trans-unit id="266af869ff6d9dd7a44657712727c1997c3421e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;addr&lt;/code&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">该 &lt;code&gt;addr&lt;/code&gt; 运算符返回的左值的地址。如果位置的类型为 &lt;code&gt;T&lt;/code&gt; ，则&lt;em&gt;addr&lt;/em&gt;运算符的结果为 &lt;code&gt;ptr T&lt;/code&gt; 类型。地址始终是未跟踪的引用。获取驻留在堆栈上的对象的地址是&lt;strong&gt;不安全的&lt;/strong&gt;，因为指针的寿命可能比堆栈上的对象的寿命长，因此可以引用不存在的对象。一个可以获取变量的地址，但不能在通过 &lt;code&gt;let&lt;/code&gt; 语句声明的变量上使用它：</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">在 &lt;code&gt;async&lt;/code&gt; 程序还提供了try语句的支持有限。</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">该 &lt;code&gt;auto&lt;/code&gt; 类型只能用于返回类型和参数。对于返回类型，它将导致编译器从例程主体中推断类型：</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;await&lt;/code&gt; 呼叫可以在许多环境中使用。它可以在变量声明的右侧使用： &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; ，在这种情况下，变量将自动设置为future的值。它可以用来等待 &lt;code&gt;Future&lt;/code&gt; 对象，也可以用来等待返回 &lt;code&gt;Future[void]&lt;/code&gt; ： &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">该 &lt;code&gt;bind&lt;/code&gt; 语句是对应于 &lt;code&gt;mixin&lt;/code&gt; 声明。它可用于显式声明应尽早绑定的标识符（即，应在模板/通用定义的范围内查找标识符）：</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">位 &lt;code&gt;bitsize&lt;/code&gt; 编译指示适用于对象字段成员。它在C / C ++中将字段声明为位字段。</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">的 &lt;code&gt;borrow&lt;/code&gt; 编译使得编译器使用相同的实现作为处理的是不同类型的基本类型，所以不生成代码的PROC。</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">该 &lt;code&gt;break&lt;/code&gt; 语句用来立即离开块。如果给出 &lt;code&gt;symbol&lt;/code&gt; ，则是要离开的封闭块的名称。如果不存在，则保留最里面的块。</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">所述 &lt;code&gt;bycopy&lt;/code&gt; 编译可应用于对象或元组类型和指示编译器通过值传递类型的特效：</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">在 &lt;code&gt;byref&lt;/code&gt; 编译可应用于对象或元组类型，并指示编译器通过参考（隐藏指针）特效传递的类型。</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">该 &lt;code&gt;call&lt;/code&gt; 限制是特别有用的实施举措优化具有复制语义类型：</target>
        </trans-unit>
        <trans-unit id="596c2ddba36b2be7462234bbca37dd7763734862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case expression&lt;/code&gt; is again very similar to the case statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a107daa0b6476fd7a15fef2edb54c6f60373d558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement doesn't produce an l-value, so the following example won't work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">的 &lt;code&gt;case&lt;/code&gt; 语句类似于if语句，但它代表了一个多分支选择。计算关键字 &lt;code&gt;case&lt;/code&gt; 之后的表达式，如果其值在&lt;em&gt;slicelist中&lt;/em&gt;，则执行相应的语句（在 &lt;code&gt;of&lt;/code&gt; 关键字之后）。如果该值不在任何给定的&lt;em&gt;切片列表中&lt;/em&gt;，则执行 &lt;code&gt;else&lt;/code&gt; 部分。如果没有 &lt;code&gt;else&lt;/code&gt; 部分，并且 &lt;code&gt;expr&lt;/code&gt; 可以容纳的所有可能值都没有出现在 &lt;code&gt;slicelist&lt;/code&gt; ，则会发生静态错误。这仅适用于序数类型的表达式。的&amp;ldquo;所有可能的值&amp;rdquo; &lt;code&gt;expr&lt;/code&gt; 被确定 &lt;code&gt;expr&lt;/code&gt; 的类型。为了抑制静态错误，应使用带有空的 &lt;code&gt;discard&lt;/code&gt; 语句的 &lt;code&gt;else&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="7b51cba93a6d0694db97762461996e17d9632399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cdf&lt;/code&gt; argument does not have to be normalized, and it could contain any type of elements that can be converted to a &lt;code&gt;float&lt;/code&gt;. It must be the same length as &lt;code&gt;a&lt;/code&gt;. Each element in &lt;code&gt;cdf&lt;/code&gt; should be greater than or equal to the previous element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">该 &lt;code&gt;codegenDecl&lt;/code&gt; 编译可用于直接影响稔的代码生成器。它接收一个格式字符串，该格式字符串确定如何在生成的代码中声明变量或proc。</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">所述 &lt;code&gt;compile&lt;/code&gt; 编译指示可用于编译和链接C / C ++源文件与项目：</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;compileTime&lt;/code&gt; 编译用于标记一个PROC或变量在仅编译时被使用。不会为此生成任何代码。编译时间处理程序可用作宏的帮助程序。从该语言的0.12.0版本开始，在其参数类型内使用 &lt;code&gt;system.NimNode&lt;/code&gt; 的proc 被隐式声明为 &lt;code&gt;compileTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b1f4b5ca84c613d5f2aec3d6366c35d47c3b092" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">该 &lt;code&gt;computedGoto&lt;/code&gt; 编译可以用来告诉编译器如何编译稔&lt;span id=&quot;case_2&quot;&gt;情况下，&lt;/span&gt;在 &lt;code&gt;while true&lt;/code&gt; 声明。从句法上讲，它必须用作循环内的语句：</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">该 &lt;code&gt;con&lt;/code&gt; Nimsuggest命令非常相似，但对建议的命令，而不是用户键入一个点字符之后仍然被使用，这一项是指用户键入开括号开始输入参数后使用。</target>
        </trans-unit>
        <trans-unit id="7ddeba29bb3840db26dd678de22fc2a91b2bc365" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;code&gt;compatible string&lt;/code&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible with the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">在 &lt;code&gt;cstring&lt;/code&gt; 类型含义&lt;em&gt;兼容的字符串&lt;/em&gt;是编译后端字符串的本地表示。对于C后端， &lt;code&gt;cstring&lt;/code&gt; 类型表示一个指针，该指针指向与Ansi C中的 &lt;code&gt;char*&lt;/code&gt; 类型兼容的零终止char数组。其主要目的在于易于与C接口。索引操作 &lt;code&gt;s[i]&lt;/code&gt; 表示第i个&lt;em&gt;char&lt;/em&gt;的 &lt;code&gt;s&lt;/code&gt; ; 但是，不执行对 &lt;code&gt;cstring&lt;/code&gt; 的边界检查，这会使索引操作不安全。</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，时将被传递 &lt;code&gt;ev&lt;/code&gt; 发生。</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，当与方法，该方法将被传递 &lt;code&gt;pid&lt;/code&gt; 已退出。</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，当信号升高，这将被传递。</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 是应用程序定义的数据，这将被传递时，定时器被触发时。</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">的 &lt;code&gt;def&lt;/code&gt; Nimsuggest命令执行关于特定符号的定义查询。如果可用，Nimsuggest将回答类型，源文件，行/列信息以及其他附件数据（如docstring）。通过此信息，IDE可以提供典型的&lt;em&gt;跳转到定义&lt;/em&gt;，用户将光标放在符号上或使用鼠标将其选中，然后将其重定向到该符号所在的位置。</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">该 &lt;code&gt;discard&lt;/code&gt; 的语句也可以用作描述创建块注释&lt;a href=&quot;#comments&quot;&gt;注释&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="bb3b805b82d90e245faef9fdd6f1471f89c50747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away, and should only be used when ignoring this value is known not to cause problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">该 &lt;code&gt;discard&lt;/code&gt; 语句计算其副作用的表达，并引发表达式的结果值了。</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;doc&lt;/code&gt; 的命令：</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">该 &lt;code&gt;dynlib&lt;/code&gt; 进口机制支持的版本控制方案：</target>
        </trans-unit>
        <trans-unit id="cc96537bffb0b9bad329ba2a12ee9fb4ede87416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as an argument but also string expressions in general:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">该 &lt;code&gt;dynlib&lt;/code&gt; 附注不仅支持常量字符串作为参数，而且字符串表达式一般：</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">该 &lt;code&gt;effects&lt;/code&gt; 编译的设计，以协助效果分析程序员。这是一条语句，使编译器可以输出所有推断的效果，直到 &lt;code&gt;effects&lt;/code&gt; 的位置为止：</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">所述 &lt;code&gt;emit&lt;/code&gt; 编译指示可用于直接影响编译器的代码生成器的输出。因此，它使您的代码无法移植到其他代码生成器/后端。不鼓励使用它！但是，对于与&lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt;或&lt;span id=&quot;objective-c_1&quot;&gt;目标C&lt;/span&gt;代码进行接口连接而言，它可能非常有用。</target>
        </trans-unit>
        <trans-unit id="1744e04ac4bf85a742e23451c47c651184464bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. The code is then unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">的 &lt;code&gt;encode&lt;/code&gt; 过程需要一个 &lt;code&gt;openarray&lt;/code&gt; 这样两个阵列和序列可以作为参数被传递。</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">的 &lt;code&gt;error&lt;/code&gt; 附注也可用于标注一个符号（如一个迭代或PROC）。然后，&lt;em&gt;使用&lt;/em&gt;符号会触发编译时错误。这对于排除某些操作由于重载和类型转换而有效的情况特别有用：</target>
        </trans-unit>
        <trans-unit id="d75f88dde94403b5fd845aa53b72776cec145bb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">的 &lt;code&gt;error&lt;/code&gt; 附注用于使编译器输出的错误消息与所述给定的内容。但是，编译不一定会在出错后中止。</target>
        </trans-unit>
        <trans-unit id="33a44bbe47b4c8fdaa3be5e19f100223278506bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. The compilation does not necessarily abort after an error though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55b4e02a1f03c12faf1b7a6871ee52b02f9e3c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errorCode&lt;/code&gt; will determine the message, &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc&lt;/a&gt; will be used to get this message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">该 &lt;code&gt;experimental&lt;/code&gt; 编译使实验的语言功能。根据具体的功能，这意味着该功能要么被认为对于通过其他方式稳定发布而言过于不稳定，要么不确定该功能的未来（可以随时删除）。</target>
        </trans-unit>
        <trans-unit id="2db09f750ba40a04b2a467b51764ca184871542b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature, this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed at any time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">所述 &lt;code&gt;exportc&lt;/code&gt; 编译指示提供到导出类型，变量或C.枚举和常量的过程无法导出的装置。可选参数是包含C标识符的字符串。如果缺少该参数，则C名称是与&lt;em&gt;拼写完全相同&lt;/em&gt;的Nim标识符：</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;let x = expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">的 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;result = expr&lt;/code&gt; 其中 &lt;code&gt;result&lt;/code&gt; 是由编译器引入的特殊符号。</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;return expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;expr&lt;/code&gt; 在 &lt;code&gt;var x = expr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">的 &lt;code&gt;fatal&lt;/code&gt; 编译指示被用来使编译器输出与给定的内容的错误信息。与 &lt;code&gt;error&lt;/code&gt; 编译指示相反，保证编译会被此编译指示中止。例：</target>
        </trans-unit>
        <trans-unit id="79c9a76ff3ec29ee56bce522b023152fceaf2553" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, the compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; paramater是足够的静态分析，但是集成开发环境往往有&lt;em&gt;未保存的缓冲区&lt;/em&gt;，其中用户仍然可以在键入一行的中间。在这种情况下，IDE可以将当前内容保存到一个临时文件中，然后使用 &lt;code&gt;dirtyfile.nim&lt;/code&gt; 选项告诉Nimsuggest &lt;code&gt;foobar.nim&lt;/code&gt; 应该从 &lt;code&gt;temporary/foobar.nim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9509997434d269bb0f68e1b13ca2d2239ff7894" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f648707faaf2c971dac2bc6f092c42cb1b59e97e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;code&gt;filename&lt;/code&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overridden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;final&lt;/code&gt; 编译指示可用于一个对象类型来指定它不能从被继承。请注意，继承仅适用于从现有对象继承（通过 &lt;code&gt;object of SuperType&lt;/code&gt; 语法的对象）或已标记为 &lt;code&gt;inheritable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">在 &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; 语法更美观，但它隐藏了一个小的疑难杂症。该字符串是&lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;广义的原始字符串文字&lt;/a&gt;。这具有一些令人惊讶的效果：</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 循环反复声明的变量-它们的范围，直到达到循环体的结束。迭代变量的类型由迭代器的返回类型推断。</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 语句可以与一个或两个变量，一个序列中使用时，可以使用。当使用一个变量形式时，变量将保存序列提供的值。该 &lt;code&gt;for&lt;/code&gt; 语句从遍历结果&lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;项（）&lt;/a&gt;从迭代器&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块。但是，如果使用两个变量形式，则第一个变量将保留索引位置，第二个变量将保留值。这里的 &lt;code&gt;for&lt;/code&gt; 语句遍历&lt;a href=&quot;system&quot;&gt;系统&lt;/a&gt;模块的&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pair（）&lt;/a&gt;迭代器的结果。例子：</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">该 &lt;code&gt;for&lt;/code&gt; 语句是一个结构遍历的任何元素&lt;em&gt;迭代器&lt;/em&gt;提供。该示例使用内置的&lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt;迭代器：</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 语句也可以强迫符号命名空间限定，从而使符号可用，但需要是有资格被使用。</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">该 &lt;code&gt;func&lt;/code&gt; 关键字引入了一个快捷方式&lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; PROC。</target>
        </trans-unit>
        <trans-unit id="26dd192f9577287d3ff84d0ce8f6615a75baab8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackDefect&lt;/code&gt; if there is no value. Note that &lt;code&gt;UnpackDefect&lt;/code&gt; inherits from &lt;code&gt;system.Defect&lt;/code&gt;, and should therefore never be caught. Instead, rely on checking if the option contains a value with &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt; and &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">上面演示的 &lt;code&gt;get&lt;/code&gt; 操作返回基础值，如果没有值，则引发 &lt;code&gt;UnpackError&lt;/code&gt; 。还有一个获取值的选项： &lt;code&gt;unsafeGet&lt;/code&gt; ，但是只有在绝对确定存在该值时（例如，在检查 &lt;code&gt;isSome&lt;/code&gt; 之后），才必须使用它。如果你不关心的小开销 &lt;code&gt;get&lt;/code&gt; 的原因，你应该永远使用 &lt;code&gt;unsafeGet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79cc36593cae272a27774d93dd0f0cb520bc5bac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt;-family helpers also accept an additional parameter which allow you to fallback to a default value should the key's values be &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">在 &lt;code&gt;global&lt;/code&gt; 编译可以应用到一个变量一个进程内指示编译器将其存储在一个全球性的位置，并在程序启动一次初始化。</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">该 &lt;code&gt;guard&lt;/code&gt; 注释也可以用来在对象上保护领域。然后，防护必须是同一对象内的另一个字段或全局变量。</target>
        </trans-unit>
        <trans-unit id="cecf91584150e32f7e14d844ab583125e19b5fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string constant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">该 &lt;code&gt;header&lt;/code&gt; 编译总是期望一个字符串常量。字符串内容包含头文件：与C一样，系统头文件用尖括号括起来： &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 。如果未提供尖括号，则Nim会将头文件包含在生成的C代码中的 &lt;code&gt;&quot;&quot;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;header&lt;/code&gt; 的pragma是非常相似的 &lt;code&gt;noDecl&lt;/code&gt; 编译指示：它可应用于几乎任何符号，并指定不应该声明，而不是将所生成的代码应包含 &lt;code&gt;#include&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b72401b61f0f4d4b74ca7cd37fb890761035c656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead, the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b64dbd148a29167eb5bce55224c93f8272a383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heapqueue&lt;/code&gt; module implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap data structure&lt;/a&gt; that can be used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;priority queue&lt;/a&gt;. Heaps are arrays for which &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; and &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; for all &lt;code&gt;k&lt;/code&gt;, counting elements from 0. The interesting property of a heap is that &lt;code&gt;a[0]&lt;/code&gt; is always its smallest element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">该 &lt;code&gt;hint&lt;/code&gt; 编译指示被用来使编译器输出一个提示消息与所述给定的内容。提示后，编译继续进行。</target>
        </trans-unit>
        <trans-unit id="8ef0beadd43d9c18e85d2fbeaa068bda72ec3066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;code&gt;id&lt;/code&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 语句是一个简单的方法，使在控制流分支：表达式，关键字后面 &lt;code&gt;if&lt;/code&gt; 被评估，如果以后相应的陈述是真实的 &lt;code&gt;:&lt;/code&gt; 被执行。否则，将评估 &lt;code&gt;elif&lt;/code&gt; 之后的表达式（如果存在 &lt;code&gt;elif&lt;/code&gt; 分支），如果为true，则执行 &lt;code&gt;:&lt;/code&gt; 之后的相应语句。这一直持续到最后一个 &lt;code&gt;elif&lt;/code&gt; 为止。如果所有条件都失败，则执行 &lt;code&gt;else&lt;/code&gt; 部分。如果没有 &lt;code&gt;else&lt;/code&gt; 部分，则从下一条语句继续执行。</target>
        </trans-unit>
        <trans-unit id="0003d13f41be8193835c63a646af8124f68cb7cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; statement is only allowed at the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">该 &lt;code&gt;importc&lt;/code&gt; 编译指示提供了导入一个PROC或可选的参数是一个包含C标识符字符串从C.可变的装置。如果缺少该参数，则C名称是与&lt;em&gt;拼写完全相同&lt;/em&gt;的Nim标识符：</target>
        </trans-unit>
        <trans-unit id="eac30aaa2478fce31be57ea79b6cc59d42ac456c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement can be used outside of the top level, as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">在 &lt;code&gt;include&lt;/code&gt; 语句做的东西比导入模块根本不同：它仅仅包括文件的内容。在 &lt;code&gt;include&lt;/code&gt; 声明是有用的大型模块分成几个文件：</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">所述 &lt;code&gt;incompleteStruct&lt;/code&gt; 编译指示告诉编译器不使用底层C &lt;code&gt;struct&lt;/code&gt; 在一个 &lt;code&gt;sizeof&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="7544df806eff4f7313cff76422ab23377014cb76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; proc can be called with any number of arguments, i.e. &lt;code&gt;initTable(initialSize)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">的 &lt;code&gt;inject&lt;/code&gt; 和 &lt;code&gt;gensym&lt;/code&gt; 编译指示是第二类注释; 它们在模板定义之外没有语义，并且不能通过以下方式抽象：</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">该 &lt;code&gt;injectStmt&lt;/code&gt; 编译可用于当前模块中的所有其他语句之前注入的声明。它仅应用于调试：</target>
        </trans-unit>
        <trans-unit id="cc7da59a3ce1987099582089c22c83123acc3457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient &lt;code&gt;int&lt;/code&gt; set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">所述 &lt;code&gt;intsets&lt;/code&gt; 模块实现为实现一个高效的INT组&lt;span id=&quot;sparse-bit-set_1&quot;&gt;稀疏比特集合&lt;/span&gt;。&lt;strong&gt;注意&lt;/strong&gt;：由于Nim当前不允许重载赋值运算符，因此对于int集的 &lt;code&gt;=&lt;/code&gt; 会执行一些相当无意义的浅表复制；使用 &lt;code&gt;assign&lt;/code&gt; 获取深层副本。</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">的 &lt;code&gt;int{lit}&lt;/code&gt; 针对类型的表达式参数模式匹配 &lt;code&gt;int&lt;/code&gt; ，但只有当它是一个文字。</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">的 &lt;code&gt;is&lt;/code&gt; 用于在编译时型等价操作者检查。因此，这对于通用代码中的类型专门化非常有用：</target>
        </trans-unit>
        <trans-unit id="037a846ce64ff72c6c1886c38f998c5c082548cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">该 &lt;code&gt;iterator&lt;/code&gt; 类型是调用约定的始终 &lt;code&gt;closure&lt;/code&gt; 含蓄; 以下示例显示了如何使用迭代器来实现&lt;span id=&quot;collaborative-tasking_1&quot;&gt;协作式任务&lt;/span&gt;系统：</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;jsondoc0&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">该 &lt;code&gt;jsondoc&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">该 &lt;code&gt;koch&lt;/code&gt; 程序是稔的维护脚本。它替代了make和shell脚本，其优点是更易于移植。可以在&lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt;文档中找到有关其选项的更多信息。</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">该 &lt;code&gt;let&lt;/code&gt; 语句的工作方式的 &lt;code&gt;var&lt;/code&gt; 声明，但声明的符号是&lt;em&gt;单赋值&lt;/em&gt;的变量：初始化后，其价值无法更改：</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">该 &lt;code&gt;line&lt;/code&gt; 编译可以用来影响注释语句行信息在栈回溯看到：</target>
        </trans-unit>
        <trans-unit id="8afa9eeaecb1dea09c8ad531f545e95028e51642" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement, as seen in stack backtraces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">该 &lt;code&gt;lineDir&lt;/code&gt; 选项可以打开或关闭。如果打开，则生成的C代码包含 &lt;code&gt;#line&lt;/code&gt; 指令。这对于使用GDB进行调试可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">所述 &lt;code&gt;lineInfoFrom&lt;/code&gt; 参数用于行信息时生成的代码崩溃。您应该确保将其设置为要转换的节点。</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">该 &lt;code&gt;lineTrace&lt;/code&gt; 选项隐含 &lt;code&gt;stackTrace&lt;/code&gt; 选项。如果打开，生成的C将包含代码，以确保在程序崩溃或引发未捕获的异常时，给出带有行号信息的正确堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">该 &lt;code&gt;linearScanEnd&lt;/code&gt; 编译可以用来告诉编译器如何编译稔&lt;span id=&quot;case_1&quot;&gt;情况&lt;/span&gt;陈述。从句法上讲，它必须用作语句：</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">该 &lt;code&gt;linearScanEnd&lt;/code&gt; 编译应投入应该对通过线性扫描测试的最后一个分支。如果放在整个 &lt;code&gt;case&lt;/code&gt; 语句的最后一个分支中，则整个 &lt;code&gt;case&lt;/code&gt; 语句将使用线性扫描。</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">该 &lt;code&gt;link&lt;/code&gt; 编译可用于与项目链接的其他文件：</target>
        </trans-unit>
        <trans-unit id="e60060003730f2db3edee6726ebcb73673ad9ecf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localPassc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler, but only for the C/C++ file that is produced from the Nim module the pragma resides in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 编译还可以采取特殊值 &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; 。这在动态方法分派的上下文中很有用。在下面的示例中，编译器可以为 &lt;code&gt;base&lt;/code&gt; 情况推断锁定级别0 。但是，其中一个重载方法调用了一个可能锁定的procvar。因此，无法静态推断调用 &lt;code&gt;g.testMethod&lt;/code&gt; 的锁定级别，从而导致编译器警告。通过使用 &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; ，基本方法也可以显式标记为具有未知的锁定级别：</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 编译需要锁定的措辞列表 &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; 为了支持&lt;em&gt;多锁&lt;/em&gt;语句。为什么这些必不可少的原因在&lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;锁定级别&lt;/a&gt;部分中进行了说明。</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">该 &lt;code&gt;locks&lt;/code&gt; 部分故意长相丑陋，因为它没有运行时语义，不应该直接使用！它仅应在还可以在运行时实现某种形式的锁定的模板中使用：</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;mapper&lt;/code&gt; 可以可以修改 &lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;pairExists&lt;/code&gt; 值更改密钥的映射或从表中删除它。添加值时，请确保将 &lt;code&gt;pairExists&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 以及修改 &lt;code&gt;val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">该 &lt;code&gt;mapper&lt;/code&gt; 接受3个参数：</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">的 &lt;code&gt;maxLength&lt;/code&gt; 参数决定了可读取的字符的最大数量。之后， &lt;code&gt;resString&lt;/code&gt; 将被截断。</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">的 &lt;code&gt;maxLength&lt;/code&gt; 参数决定了可读取的字符的最大数量。之后，结果将被截断。</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">该 &lt;code&gt;msgHandler&lt;/code&gt; 是用于用户错误报告一个PROC。将使用解析期间发现的任何错误的文件名，行，列和类型来调用它。如果传递 &lt;code&gt;nil&lt;/code&gt; ，则将使用默认消息处理程序，该消息处理程序会将消息写入标准输出。</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">该 &lt;code&gt;nim&lt;/code&gt; 在以下目录中的可执行程序的配置文件（在这个秩序;更高版本的文件覆盖以前的设置）：</target>
        </trans-unit>
        <trans-unit id="d1de4c15a5d4322e279af56e0f42cc33a1504497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes the &lt;code&gt;.nims&lt;/code&gt; configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b963c0905e1160ea544d741ffdbf201c3a7bf09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nimDisableCertificateValidation&lt;/code&gt; define overrides verifyMode and disables certificate verification globally!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">该 &lt;code&gt;nnkElifBranch&lt;/code&gt; 和 &lt;code&gt;nnkElse&lt;/code&gt; 部分可能会丢失。</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">所述 &lt;code&gt;noDecl&lt;/code&gt; 编译可应用于几乎任何符号（变量，PROC，类型等），并且有时在使用C互操作有用：它告诉稔，它不应该产生在C代码符号的声明。例如：</target>
        </trans-unit>
        <trans-unit id="5ad2ee4458517f6e547cf12f840abec614d3d433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;out T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">所述 &lt;code&gt;noSideEffect&lt;/code&gt; 编译用于标记一个PROC /迭代器没有任何副作用。这意味着proc / iterator仅更改其参数可访问的位置，并且返回值仅取决于参数。如果其所有参数都不具有 &lt;code&gt;var T&lt;/code&gt; 或 &lt;code&gt;ref T&lt;/code&gt; 或 &lt;code&gt;ptr T&lt;/code&gt; 类型,则表示没有位置被修改。如果编译器无法验证，则将proc /迭代器标记为没有副作用是一个静态错误。</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">将 &lt;code&gt;noreturn&lt;/code&gt; 编译是用来标记一个进程，从来没有回报。</target>
        </trans-unit>
        <trans-unit id="85bb1f5f512bb1750c1a4d1ebcd22d1e74a421af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; keyword is always a unary operator, &lt;code&gt;a not b&lt;/code&gt; is parsed as &lt;code&gt;a(not b)&lt;/code&gt;, not as &lt;code&gt;(a) not (b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。由于这是左折，因此对于像减法这样的非关联二进制运算，请认为数字1、2和3的序列将被括为（（（（1）-2）-3）。</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。由于这是正确的对折，因此对于像减法这样的非关联二进制运算，请考虑将数字1、2和3的序列括为（1-（2--（3）））。</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">的 &lt;code&gt;operation&lt;/code&gt; 参数应使用所述变量的表达式 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为所述折叠的每个步骤。第 &lt;code&gt;first&lt;/code&gt; 参数是起始值（第一个 &lt;code&gt;a&lt;/code&gt; ），因此定义了结果的类型。</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">该 &lt;code&gt;optPeg&lt;/code&gt; 模板优化用于字符串的PEG构造的情况下，这样的模式将只在一次程序启动时解析，并存储在全局 &lt;code&gt;gl&lt;/code&gt; 然后用于重。此优化称为提升，因为它可与传统的环路提升相比。</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">该 &lt;code&gt;packed&lt;/code&gt; 编译可应用于任何 &lt;code&gt;object&lt;/code&gt; 类型。它确保对象的字段在内存中背对背打包。存储来自/至网络或硬件驱动程序的数据包或消息，以及与C互操作性很有用。未定义打包的编​​译指示与继承的组合，因此不应将其与GC'ed内存（ref's）一起使用。</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">该 &lt;code&gt;params&lt;/code&gt; 阵列必须与返回类型的进程内，随后是指定PARAMS IdentDefs名单开始。</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">所述 &lt;code&gt;parseJson&lt;/code&gt; 过程需要含有JSON并返回一个字符串 &lt;code&gt;JsonNode&lt;/code&gt; 对象。这是一个对象变体，可以是 &lt;code&gt;JObject&lt;/code&gt; ， &lt;code&gt;JArray&lt;/code&gt; ， &lt;code&gt;JString&lt;/code&gt; ， &lt;code&gt;JInt&lt;/code&gt; ， &lt;code&gt;JFloat&lt;/code&gt; ， &lt;code&gt;JBool&lt;/code&gt; 或 &lt;code&gt;JNull&lt;/code&gt; 。您可以通过使用 &lt;code&gt;kind&lt;/code&gt; 访问器来检查此对象变量的种类。</target>
        </trans-unit>
        <trans-unit id="ab71cca6be976e0916e48654c757813ac229024a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">该 &lt;code&gt;parsecfg&lt;/code&gt; 模块实现高性能的配置文件分析器。配置文件的语法类似于Windows &lt;code&gt;.ini&lt;/code&gt; 格式，但是功能更强大，因为它不是基于行的解析器。与Nim编程语言一样，支持字符串文字，原始字符串文字和带三引号的字符串文字，这是配置文件的外观示例：</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">该 &lt;code&gt;parsesql&lt;/code&gt; 模块实现高性能的SQL文件分析器。它解析PostgreSQL语法和SQL ANSI标准。</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;passC&lt;/code&gt; 编译指示可用于传递附加参数，以C编译器等你会使用命令行开关 &lt;code&gt;--passC&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a226dc1945e0a231e4a09243e7cbc55428953d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like one would be using the command-line switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;passL&lt;/code&gt; 编译可用于其他参数传递给连接器就像您使用命令行开关 &lt;code&gt;--passL&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d5b5550832a02a497dde295f605b34a81b96e37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like one would using the command-line switch &lt;code&gt;--passc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;poll&lt;/code&gt; 功能将不，就其本身而言，返回任何事件。而是将完成一个适当的 &lt;code&gt;Future&lt;/code&gt; 对象。一个 &lt;code&gt;Future&lt;/code&gt; 是保持一个值，该值尚未公布，但一个类型&lt;em&gt;可以&lt;/em&gt;在将来提供。您可以使用 &lt;code&gt;finished&lt;/code&gt; 功能来检查将来是否完成。将来完成时，意味着它持有的值现在可用，或者持有错误。当完成将来的操作失败并发生异常时，会发生后一种情况。您可以使用 &lt;code&gt;failed&lt;/code&gt; 功能来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">所述 &lt;code&gt;pragma&lt;/code&gt; 编译指示可用于声明用户定义的编译指示。这很有用，因为Nim的模板和宏不会影响编译指示。用户定义的编译指示与所有其他符号不在模块范围内。它们不能从模块导入。</target>
        </trans-unit>
        <trans-unit id="51885e189673cb5c6386d2e95a8b73481f631054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user-defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User-defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">该 &lt;code&gt;readCfgAtRuntime&lt;/code&gt; PROC将打开指定的文件名，并返回一个 &lt;code&gt;Table&lt;/code&gt; 从&lt;a href=&quot;tables&quot;&gt;表模块&lt;/a&gt;。使用&lt;a href=&quot;strutils#splitLines&quot;&gt;strutils模块中&lt;/a&gt;的splitLines proc来完成文件的解析（无需过多地处理无效数据或极端情况）。有很多事情可能会失败；我的目的是解释如何在编译时运行它，而不是如何正确实施DRM方案。</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">该 &lt;code&gt;register&lt;/code&gt; 附注仅用于变量。它将变量声明为 &lt;code&gt;register&lt;/code&gt; ，从而向编译器提示该变量应放置在硬件寄存器中以加快访问速度。C编译器通常会忽略这一点，但有充分的理由：不管怎样，他们通常会做得更好。</target>
        </trans-unit>
        <trans-unit id="a0902ad3f56f0d7c35a0065f78a040f1cd74c2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; symbol of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">该 &lt;code&gt;result&lt;/code&gt; 变量已经隐含在函数的开始申报，所以用&amp;ldquo;变种结果&amp;rdquo;再次声明它，例如，将具有相同名称的普通变量的影子吧。结果变量也已经使用类型的默认值进行了初始化。请注意，在过程开始时，引用数据类型将 &lt;code&gt;nil&lt;/code&gt; ，因此可能需要手动初始化。</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">在 &lt;code&gt;return&lt;/code&gt; 语句结束当前程序的执行。仅在过程中允许。如果存在 &lt;code&gt;expr&lt;/code&gt; ，则这是以下语法糖：</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">该 &lt;code&gt;rst2tex&lt;/code&gt; 命令相同地调用 &lt;code&gt;rst2html&lt;/code&gt; ，但输出.tex文件，而不是html的。</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">所述 &lt;code&gt;scanp&lt;/code&gt; 映射语法的代码到执行解析稔代码。借助3个可针对自定义类型实现的帮助程序模板来执行解析。</target>
        </trans-unit>
        <trans-unit id="5a60747c9b966d14e1f72bd788f5ee6cfb1876ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; operation will block until number of unprocessed items is less than &lt;code&gt;maxItems&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5376cae9b12713da42c8c136f625062e3841b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sep&lt;/code&gt; (default: &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;) is used for the path normalizations, this can be useful to ensure the relative path only contains &lt;code&gt;'/'&lt;/code&gt; so that it can be used for URL constructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">该 &lt;code&gt;sets&lt;/code&gt; 模块实现高效的&lt;span id=&quot;hash-set_1&quot;&gt;哈希集合&lt;/span&gt;，并下令哈希集合。</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">在 &lt;code&gt;shallow&lt;/code&gt; 编译影响类型的语义：编译器允许建立一个浅拷贝。这可能会导致严重的语义问题并破坏内存安全！但是，由于Nim的语义需要深度复制序列和字符串，因此它可以大大加快分配速度。这可能会很昂贵，尤其是如果使用序列来构建树结构时：</target>
        </trans-unit>
        <trans-unit id="70490801fb19f53b61e82f0f32ef054d04c4ee37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sink&lt;/code&gt; and &lt;code&gt;lent&lt;/code&gt; annotations allow us to remove most (if not all) superfluous copies and destructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a94cc1faa9d7174f44a4b0eb96e7b131e94500a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std/monotimes&lt;/code&gt; module implements monotonic timestamps. A monotonic timestamp represents the time that has passed since some system defined point in time. The monotonic timestamps are guaranteed to always increase, meaning that that the following is guaranteed to work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0473bd0e810149a939133acc83ef43055abcf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">所述 &lt;code&gt;strtabs&lt;/code&gt; 模块实现一个高效的哈希表，它是从字符串到字符串的映射。支持区分大小写，不区分大小写和不区分样式的模式。还提供了有效的字符串表字符串替换运算符 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">的 &lt;code&gt;sug&lt;/code&gt; Nimsuggest命令执行关于在文件中的某些点有可能完成的符号查询。</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 模块包含由编译器魔术（和东西，需要在它，因为规范是这么说的）需要支持的RTL的一部分。 C代码生成器会像其他任何模块一样为其生成C代码。但是，CCG会插入对诸如 &lt;code&gt;addInt&lt;/code&gt; 之类的某些过程的调用。因此，模块 &lt;code&gt;magicsys&lt;/code&gt; 包含一个表（ &lt;code&gt;compilerprocs&lt;/code&gt; 与被标记为所有的符号） &lt;code&gt;compilerproc&lt;/code&gt; 。代码生成 &lt;code&gt;compilerprocs&lt;/code&gt; 需要editorprocs。一个 &lt;code&gt;magic&lt;/code&gt; PROC是不一样的 &lt;code&gt;compilerproc&lt;/code&gt; ：一个 &lt;code&gt;magic&lt;/code&gt; 是一个进程，对于其语义检查需要编译器法宝，一个 &lt;code&gt;compilerproc&lt;/code&gt; 是代码生成器使用的proc。</target>
        </trans-unit>
        <trans-unit id="f9035ba56cfa6ab02534b3ec0d96d5eab1b2f002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it, just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 模块定义的重要&lt;a href=&quot;system#Natural&quot;&gt;天然&lt;/a&gt;类型为 &lt;code&gt;range[0..high(int)]&lt;/code&gt; （&lt;a href=&quot;system#high&quot;&gt;高&lt;/a&gt;回报最大值）。其他编程语言可能建议对自然数使用无符号整数。这通常是&lt;strong&gt;不明智的&lt;/strong&gt;：仅仅因为数字不能为负数，就不需要无符号算术（环绕）。Nim的 &lt;code&gt;Natural&lt;/code&gt; 类型有助于避免这种常见的编程错误。</target>
        </trans-unit>
        <trans-unit id="c232a0290c3aa227f3d98a650bd1b8e5ea3f4777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">该 &lt;code&gt;tables&lt;/code&gt; 的有效的模块实现变体&lt;span id=&quot;hash-table_1&quot;&gt;哈希表&lt;/span&gt;（也通常命名为&lt;span id=&quot;dictionary_1&quot;&gt;字典&lt;/span&gt;在其他编程语言），其从键到值的映射。 &lt;code&gt;Table&lt;/code&gt; 是通常的哈希表， &lt;code&gt;OrderedTable&lt;/code&gt; 类似于 &lt;code&gt;Table&lt;/code&gt; ,但是记住插入顺序，而 &lt;code&gt;CountTable&lt;/code&gt; 是从键到其出现次数的映射。为了与Nim中的所有其他数据类型保持一致，它们具有&lt;strong&gt;值&lt;/strong&gt;语义，这意味着 &lt;code&gt;=&lt;/code&gt; 将执行哈希表的副本。对于&lt;strong&gt;参考&lt;/strong&gt;语义，请使用 &lt;code&gt;Ref&lt;/code&gt; 变体： &lt;code&gt;TableRef&lt;/code&gt; ， &lt;code&gt;OrderedTableRef&lt;/code&gt; ， &lt;code&gt;CountTableRef&lt;/code&gt; 。举一个例子，当&lt;em&gt;a&lt;/em&gt;是一个表时，则&lt;em&gt;var b = a&lt;/em&gt;给出&lt;em&gt;b&lt;/em&gt;作为新的独立表。b的初始化用的内容&lt;em&gt;一个&lt;/em&gt;。更改&lt;em&gt;b&lt;/em&gt;不会影响&lt;em&gt;a&lt;/em&gt;，反之亦然：</target>
        </trans-unit>
        <trans-unit id="eb85eba1af50fa871f49d79336197980e95f5e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;task&lt;/code&gt; template that the &lt;code&gt;system&lt;/code&gt; module defines allows a NimScript file to be used as a build tool. The following example defines a task &lt;code&gt;build&lt;/code&gt; that is an alias for the &lt;code&gt;c&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 参数指定毫秒的功能将被阻止，如果没有事件准备的最大数量。将超时指定为 &lt;code&gt;-1&lt;/code&gt; 将导致该函数无限期地阻塞。</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 参数指定毫秒的功能将被阻止，如果没有事件准备的最大数量。将超时指定为 &lt;code&gt;-1&lt;/code&gt; 将导致该函数无限期地阻塞。所有可用事件将存储在 &lt;code&gt;results&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="d3ecbe75d06cddb5ee3e9b9b74d9adedd1918e7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; parameter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">该 &lt;code&gt;timeout&lt;/code&gt; 要进行paremeter单位为毫秒的时间以允许连接到服务器上。</target>
        </trans-unit>
        <trans-unit id="38edfa829280086eb1bbb722fc058e36f403cb03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module contains routines and types for dealing with time using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;proleptic Gregorian calendar&lt;/a&gt;. It's also available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551c95a5e7566f1190bf74f48e874beb433d9b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module exports two similar types that are both used to represent some amount of time: &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; and &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval&lt;/a&gt;. This section explains how they differ and when one should be preferred over the other (short answer: use &lt;code&gt;Duration&lt;/code&gt; unless support for months and years is needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">在 &lt;code&gt;try&lt;/code&gt; 语句处理异常：</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">在 &lt;code&gt;unchecked&lt;/code&gt; 编译，可以用来标记命名的数组作为 &lt;code&gt;unchecked&lt;/code&gt; 的意义它的界限，不检查。这对于实现定制的灵活大小的数组通常很有用。此外，未经检查的数组将转换为大小不确定的C数组：</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">该 &lt;code&gt;union&lt;/code&gt; 编译可应用于任何 &lt;code&gt;object&lt;/code&gt; 类型。这意味着该对象的所有字段都覆盖在内存中。这将在生成的C / C ++代码中产生 &lt;code&gt;union&lt;/code&gt; 而不是 &lt;code&gt;struct&lt;/code&gt; 。这样，对象声明一定不能使用继承或任何GC的内存，但是当前不检查。</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">该 &lt;code&gt;unroll&lt;/code&gt; 编译可以用来告诉编译器，它应该展开一个&lt;span id=&quot;for_2&quot;&gt;对&lt;/span&gt;或&lt;span id=&quot;while_1&quot;&gt;同时&lt;/span&gt;循环运行时的效率：</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">在 &lt;code&gt;use&lt;/code&gt; Nimsuggest命令列出了一个位置符号的所有用途。IDE可以使用它查找文件中使用符号的所有位置，并向用户提供同时在所有位置对其进行重命名的功能。</target>
        </trans-unit>
        <trans-unit id="1841570b4e739b5943163d9b9857a19771bd7db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usePlus&lt;/code&gt; parameter is passed down to the &lt;code&gt;encodeUrl&lt;/code&gt; function that is used for the URL encoding of the string values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">在 &lt;code&gt;using&lt;/code&gt; 部分使用基于分组的语法为相同的缩进 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">所述 &lt;code&gt;varargs&lt;/code&gt; 编译可应用于仅程序（和程序类型）。它告诉Nim，该proc可以在最后指定的参数之后接受可变数量的参数。Nim字符串值将自动转换为C字符串：</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">的 &lt;code&gt;void&lt;/code&gt; 类型表示不存在任何类型的。 &lt;code&gt;void&lt;/code&gt; 类型的参数被视为不存在， &lt;code&gt;void&lt;/code&gt; 作为返回类型意味着该过程不返回值：</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;void&lt;/code&gt; 类型仅适用于参数和返回类型; 其他符号的类型不能为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">的 &lt;code&gt;void&lt;/code&gt; 类型是通用代码是特别有用的：</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">该 &lt;code&gt;volatile&lt;/code&gt; 附注仅用于变量。它将变量声明为 &lt;code&gt;volatile&lt;/code&gt; ，无论在C / C ++中意味着什么（在C / C ++中其语义都没有很好地定义）。</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">该 &lt;code&gt;warning&lt;/code&gt; 编译用于使编译器输出给定内容的警告消息。警告后继续编译。</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句使条件编译技术。作为特殊的语法扩展，在 &lt;code&gt;object&lt;/code&gt; 定义中还可以使用 &lt;code&gt;when&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句是几乎相同的 &lt;code&gt;if&lt;/code&gt; 有一些例外的声明：</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句是几乎相同的 &lt;code&gt;if&lt;/code&gt; 声明，但有以下差异：</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">该 &lt;code&gt;when&lt;/code&gt; 声明是编写平台特定的代码，类似有用 &lt;code&gt;#ifdef&lt;/code&gt; 在C编程语言构造。</target>
        </trans-unit>
        <trans-unit id="f95ea01eb63a864b4f10f510dd1f071edf8bc9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;code&gt;implicit block&lt;/code&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">在 &lt;code&gt;while&lt;/code&gt; 语句执行，直到 &lt;code&gt;expr&lt;/code&gt; 的计算结果为假。无休止的循环没有错误。 &lt;code&gt;while&lt;/code&gt; 语句打开一个&lt;em&gt;隐式块&lt;/em&gt;，以便可以将其与 &lt;code&gt;break&lt;/code&gt; 语句一起使用。</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">该 &lt;code&gt;yield&lt;/code&gt; 语句用来代替 &lt;code&gt;return&lt;/code&gt; 迭代器声明。它仅在迭代器中有效。执行将返回到称为迭代器的for循环的主体。Yield不会结束迭代过程，但是如果下一次迭代开始，则执行将传递回迭代器。有关更多信息，请参见有关迭代器的部分（&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators和for语句&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="74a3a7e48222419bc7a04a33163a499728766780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but the execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">该 &lt;code&gt;{}&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; 算子</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; 运算符（如果用作infix运算符）将创建有序选择：</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">该 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 符号用于标记替代项，并且优先级最低。 &lt;code&gt;/&lt;/code&gt; 是有序选择，需要解析器按给定顺序尝试替代项。 &lt;code&gt;/&lt;/code&gt; 通常用于确保语法不模糊。</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">在 &lt;code&gt;~&lt;/code&gt; 运营商</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">该 &lt;code&gt;~&lt;/code&gt; 运营商是&lt;strong&gt;不是&lt;/strong&gt;在模式操作：</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">计数表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">哈希表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">整数集的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">有序哈希表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">字符串表的&lt;em&gt;$&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">字符串表的&lt;em&gt;％&lt;/em&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">计数表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表包含具有相同计数的相同键，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">计数表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且都包含具有相同计数的相同键，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且两个表的内容包含相同的键值对，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表的内容包含相同的键值对，则返回 &lt;code&gt;true&lt;/code&gt; 。插入顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">有序哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果内容和顺序相等，则返回true。</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">有序哈希表的&lt;em&gt;==&lt;/em&gt;运算符。如果两个表均为 &lt;code&gt;nil&lt;/code&gt; 或none为 &lt;code&gt;nil&lt;/code&gt; 并且两者的内容和顺序相等，则返回true 。</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">该&lt;em&gt;稔编译器&lt;/em&gt;还具有与RST（新结构化）文件的支持 &lt;code&gt;rst2html&lt;/code&gt; 和 &lt;code&gt;rst2tex&lt;/code&gt; 命令。像这样的文档最初是用RST方言编写的，它以 &lt;code&gt;.. code-block:: nim&lt;/code&gt; 前缀添加了对nim源代码突出显示的支持。 &lt;code&gt;code-block&lt;/code&gt; 还支持突出显示C ++和其他一些类似c的语言。</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">的&lt;em&gt;情况下表达&lt;/em&gt;又是非常相似的case语句：</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">该&lt;em&gt;字符类型&lt;/em&gt;被称为 &lt;code&gt;char&lt;/code&gt; 。它的大小始终为一个字节，因此不能表示大多数UTF-8字符；但它&lt;em&gt;可以&lt;/em&gt;代表组成多字节UTF-8字符的字节之一。原因是效率：在绝大多数用例中，生成的程序仍将正确处理UTF-8，因为UTF-8是为此专门设计的。字符文字用单引号引起来。</target>
        </trans-unit>
        <trans-unit id="b59bbeebfabbb8d232d246b925687354b59b07ba" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;duration&lt;/em&gt; of a borrow is the span of commands beginning from the assignment to the view and ending with the last usage of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">该&lt;em&gt;文件名&lt;/em&gt;参数将被用于错误报告和创建索引超链接到文件，但你可以，如果你正在分析在内存中的数据流在这里传递一个空字符串。如果&lt;em&gt;filename&lt;/em&gt;以 &lt;code&gt;.nim&lt;/code&gt; 扩展&lt;em&gt;名&lt;/em&gt;结尾，则文档的标题将默认设置为 &lt;code&gt;Module filename&lt;/code&gt; 。嵌入的rst可以覆盖此默认标题，但是如果找不到标题，则可以帮助美化生成的索引。</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">的&lt;em&gt;处理程序&lt;/em&gt;参数由码块的&lt;em&gt;PegKinds&lt;/em&gt;，定义感兴趣的语法元素。每个块都可以包含在解析器输入并留下与语法元素匹配的文本时要执行的处理程序代码。一个&lt;em&gt;输入&lt;/em&gt;处理程序可以访问该特定的PEG AST节点被匹配为&lt;em&gt;p&lt;/em&gt;，则整个解析的字符串作为&lt;em&gt;小号&lt;/em&gt;和匹配的文本段中的位置&lt;em&gt;小号&lt;/em&gt;作为&lt;em&gt;开始&lt;/em&gt;。一个&lt;em&gt;假&lt;/em&gt;处理程序可以访问&lt;em&gt;p&lt;/em&gt;，&lt;em&gt;小号&lt;/em&gt;，&lt;em&gt;开始&lt;/em&gt;也是匹配的文本段的长度&lt;em&gt;长&lt;/em&gt;。对于不成功的比赛，&lt;em&gt;输入&lt;/em&gt;和&lt;em&gt;离开&lt;/em&gt;处理程序将被执行，&lt;em&gt;长度&lt;/em&gt;设置为-1。</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">该&lt;em&gt;ID&lt;/em&gt;将与散列字符被附加仅当它的长度不为零，否则没有具体的锚将生成。通常，只应为独立的第一个文档的标题传递一个空的&lt;em&gt;id&lt;/em&gt;值（它们对于&lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes（）&lt;/a&gt; proc 是特殊的，有关更多信息，请参见&lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index（idx）文件格式&lt;/a&gt;）。与其他索引项不同，标题条目会插入累积缓冲区的开头，以保持条目的逻辑顺序。</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;INITIALSIZE&lt;/em&gt;参数需要两个电源。您可以使用&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo（）&lt;/a&gt;或&lt;em&gt;rightSize&lt;/em&gt;来保证在运行时实现这一点。除&lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid（）&lt;/a&gt;和&lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len（）&lt;/a&gt;外，所有设置变量都必须在与该模块的其他proc一起使用之前进行初始化。</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">该&lt;em&gt;INITIALSIZE&lt;/em&gt;参数需要两个电源。您可以使用&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo（）&lt;/a&gt;或&lt;em&gt;rightSize&lt;/em&gt;来保证在运行时实现这一点。除&lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid（）&lt;/a&gt;和&lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len（）&lt;/a&gt;外，所有设置变量都必须在与该模块的其他proc一起使用之前进行初始化。</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">在块的声明部分声明的变量的&lt;em&gt;范围&lt;/em&gt;从声明点到块结束均有效。如果一个块包含第二个块，在该块中重新声明了标识符，则在该块内部，第二个声明将有效。离开内部块后，第一个声明再次有效。除非在过程或迭代器重载目的上有效，否则不能在同一块中重新定义标识符。</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">的&lt;em&gt;稀松接口&lt;/em&gt;示例用途 &lt;code&gt;.emit&lt;/code&gt; 以产生 &lt;code&gt;using namespace&lt;/code&gt; 声明。通常最好通过 &lt;code&gt;namespace::identifier&lt;/code&gt; 表示法引用导入的名称：</target>
        </trans-unit>
        <trans-unit id="da93781d112d6e740e1375bf8d057a1a694aa4d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;align_1&quot;&gt;align&lt;/span&gt; pragma is for variables and object field members. It modifies the alignment requirement of the entity being declared. The argument must be a constant power of 2. Valid non-zero alignments that are weaker than other align pragmas on the same declaration are ignored. Alignments that are weaker than the alignment requirement of the type are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">该&lt;span id=&quot;backslash_1&quot;&gt;反斜杠&lt;/span&gt;字符有几种用途。首先，如果其后跟非字母数字字符，则它将删除该字符可能具有的任何特殊含义。反斜杠作为转义字符的这种用法适用于内部字符类和外部字符类。</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">在&lt;span id=&quot;boot_1&quot;&gt;启动&lt;/span&gt;命令引导了编译器，它接受不同的选项：</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">所述&lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt;命令构建用于安装的碳源。它接受与传递给&lt;a href=&quot;#boot-command&quot;&gt;boot命令&lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="bdaaec8473ada505740f8f1af6c125ef2f73898b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53b256239da4adea364a3390858d3ee5b4d0c44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks&lt;/span&gt; pragma can be used to disable this inference for a single routine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">该&lt;span id=&quot;for_1&quot;&gt;用于&lt;/span&gt;语句是一个抽象的机制来遍历一个容器中的元素。它依靠&lt;span id=&quot;iterator_1&quot;&gt;迭代器&lt;/span&gt;来做到这一点。与 &lt;code&gt;while&lt;/code&gt; 语句一样， &lt;code&gt;for&lt;/code&gt; 语句打开一个&lt;span id=&quot;implicit-block_1&quot;&gt;隐式block&lt;/span&gt;，以便可以将它们与 &lt;code&gt;break&lt;/code&gt; 语句一起使用。</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">所述&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt;注释可以被用于标记一个PROC是gcsafe，否则该属性是由编译器推断。请注意， &lt;code&gt;noSideEffect&lt;/code&gt; 暗含 &lt;code&gt;gcsafe&lt;/code&gt; 。创建线程的唯一方法是通过 &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;createThread&lt;/code&gt; 。 &lt;code&gt;spawn&lt;/code&gt; 通常是首选方法。无论哪种方式，被调用的proc都不得使用 &lt;code&gt;var&lt;/code&gt; 参数，其任何参数均不得包含 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;closure&lt;/code&gt; 类型。这将强制执行&lt;em&gt;无堆共享限制&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="263dfccfb0e868076dd90d1d32172ba6edfea6cb" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. The invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">该&lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt;选项允许在代码的变化可以自动应用到正在运行的程序的特殊编译模式。代码重装以单个模块的粒度进行。重新加载模块时，Nim将保留所有全局变量的状态，这些全局变量在代码中使用标准变量声明进行了初始化。所有其他顶级代码将在每次重新加载时重复执行。如果要防止这种行为，则可以使用 &lt;code&gt;once&lt;/code&gt; 构造来保护代码块：</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">该&lt;span id=&quot;koch_1&quot;&gt;科赫&lt;/span&gt;程序是稔的维护脚本。它替代了make和shell脚本，其优点是更易于移植。&lt;em&gt;koch&lt;/em&gt;一词在德语中意为&lt;em&gt;厨师&lt;/em&gt;。 &lt;code&gt;koch&lt;/code&gt; 主要用于构建Nim编译器，但也可以用于其他任务。本文档介绍了受支持的命令及其选项。</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">该&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt;编译期间生成的目录，并将举办取决于后端的目标是临时或最终文件。该目录的默认名称取决于使用的后端和您的操作系统，但是您可以使用 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;编译器开关&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="92bf656e3ee386275c0b9697fe2e8bc71b022ce8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">该&lt;span id=&quot;parameter-constraint_1&quot;&gt;参数约束&lt;/span&gt;表达式可以使用运营商 &lt;code&gt;|&lt;/code&gt; （或）， &lt;code&gt;&amp;amp;&lt;/code&gt; （和）和 &lt;code&gt;~&lt;/code&gt; （不是）以及以下谓词：</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">该&lt;span id=&quot;pushslashpop_1&quot;&gt;PUSH / POP&lt;/span&gt;编译指示是非常相似的选项指令，而是用于暂时覆盖设置。例：</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">该&lt;span id=&quot;slice_1&quot;&gt;切片&lt;/span&gt;操作..优先于包含点其他标记：{..}是三个令牌{，...，}，而不是两个标记{，。}。</target>
        </trans-unit>
        <trans-unit id="93730bf4352ebc6a6c5b5cf40a7c97e98830ae75" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;code&gt;formatstr&lt;/code&gt; and returns a modified &lt;code&gt;formatstr&lt;/code&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">在&lt;span id=&quot;substitution_1&quot;&gt;替代&lt;/span&gt;操作者执行字符串替换在&lt;em&gt;formatstr&lt;/em&gt;并返回一个改性&lt;em&gt;formatstr&lt;/em&gt;。这通常称为&lt;span id=&quot;string-interpolation_1&quot;&gt;字符串插值&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">在&lt;span id=&quot;substitution_2&quot;&gt;替代&lt;/span&gt;操作者执行字符串替换在&lt;em&gt;formatstr&lt;/em&gt;并返回一个改性&lt;em&gt;formatstr&lt;/em&gt;。这通常称为&lt;span id=&quot;string-interpolation_2&quot;&gt;字符串插值&lt;/span&gt;。</target>
        </trans-unit>
        <trans-unit id="171382137ee71e60fb08ca9fefa65698e106ef9b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">该&lt;span id=&quot;test_1&quot;&gt;测试&lt;/span&gt;命令也可以用别名调用的 &lt;code&gt;tests&lt;/code&gt; 。该命令将编译并运行 &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; ，这是Nim测试套件的主要驱动程序。您可以将选项传递给 &lt;code&gt;test&lt;/code&gt; 命令，它们将被转发给测试人员。请参阅其源代码以获取可用选项。</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">该&lt;span id=&quot;web_1&quot;&gt;网页&lt;/span&gt;命令转换的文档 &lt;code&gt;doc&lt;/code&gt; 从第一个到HTML目录。它还重复相同的操作，但是将结果放置在 &lt;code&gt;web/upload&lt;/code&gt; 中，该结果可用于更新&lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org上&lt;/a&gt;的网站。</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">该&lt;strong&gt;文件&lt;/strong&gt; paramater是足够的静态分析，但是集成开发环境往往有&lt;em&gt;未保存的缓冲区&lt;/em&gt;，其中用户仍然可以在键入一行的中间。在这种情况下，IDE可以将当前内容保存到一个临时文件中，然后使用 &lt;code&gt;--trackDirty&lt;/code&gt; 开关。</target>
        </trans-unit>
        <trans-unit id="a97375906f1b0145ecfd52bd809ab81d76021e6e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">该API旨在&lt;strong&gt;易于使用&lt;/strong&gt;和保持一致。易用性是通过达到具体的高级别操作的呼叫次数来衡量的。</target>
        </trans-unit>
        <trans-unit id="24ff78d14078efdde3aa0c8a6fca83e77761f981" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high-level action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">该API应该包含AST差异概念：有关最终详细信息，请参见模块 &lt;code&gt;macrocache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">尼姆的AST</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">像C这样的后端会将其临时 &lt;code&gt;.c&lt;/code&gt; ， &lt;code&gt;.cpp&lt;/code&gt; 或 &lt;code&gt;.m&lt;/code&gt; 文件放在 &lt;code&gt;nimcache&lt;/code&gt; 目录中。这些文件的命名遵循 &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; 模式：</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">C类目标</target>
        </trans-unit>
        <trans-unit id="898583fdf4f7e2148aa36867bf4bb2102ecd496c" translate="yes" xml:space="preserve">
          <source>The CPU this build is running on. Can be different from &lt;code&gt;system.hostCPU&lt;/code&gt; for cross compilations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">CellSet数据结构</target>
        </trans-unit>
        <trans-unit id="79e6163dcab816483c82583cef72dec94ae2b158" translate="yes" xml:space="preserve">
          <source>The DOMException interface represents an abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. Each exception has a name, which is a short &quot;CamelCase&quot; style string identifying the error or abnormal condition. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7d4429a0786a309aa9d6b7928dc3d572fde709" translate="yes" xml:space="preserve">
          <source>The Debian package ships bash and ksh completion and manpages that can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;对于Mac / Linux&lt;/a&gt;或&lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;Windows&lt;/a&gt;，DevkitPro的安装程序必须与默认设置相同，并带有其新安装程序。</target>
        </trans-unit>
        <trans-unit id="1008adfd15b693fe20b376424382af8c8cea0aa1" translate="yes" xml:space="preserve">
          <source>The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c27958dc268e2a60ebe42e3d8ceaa6b5e10f68" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversal leads to undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">GC依赖于极其高效的数据结构来存储一组指针- 在源代码中将其称为 &lt;code&gt;TCellSet&lt;/code&gt; 。插入，删除和搜索是在固定时间内完成的。但是，在遍历期间修改 &lt;code&gt;TCellSet&lt;/code&gt; 会导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">GC只在内存分配操作中被触发,它不是由某个定时器触发,也不在后台线程中运行。它不是由某个定时器触发的,也不在后台线程中运行。</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">GC度量时间使用的方式（有关实现，请参见 &lt;code&gt;lib/system/timers.nim&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">垃圾收集器</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">IEEE异常或者在运行时被忽略，或者映射到以下Nim异常：&lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;，&lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;，&lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;，&lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;和&lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;。这些异常继承自&lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt;基类。</target>
        </trans-unit>
        <trans-unit id="ffdbe4b37fb48c6e771a9c49f384954abf693614" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored during execution or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt;, &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt;, &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt;, &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt;, and &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt; base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">IEEE标准定义了五种类型的浮点异常。</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">JS的目标实际上是 &lt;code&gt;node.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">JavaScript目标</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">JavaScript目标没有任何其他接口方面的考虑，因为它也具有垃圾回收功能，但是C目标要求您初始化Nim的内部，这是通过调用 &lt;code&gt;NimMain&lt;/code&gt; 函数来完成的。同样，C代码要求您为函数指定前向声明，否则编译器将假定某些类型的返回值和参数，这可能会使您的程序在运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="665d7845877047d3fa57ee16acbc8e493af72754" translate="yes" xml:space="preserve">
          <source>The MinGW-w64 toolchain can be installed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Nim编译器和标准库的大多数部分都支持异味模式。输入字符串使用在 &lt;code&gt;system&lt;/code&gt; 模块中声明的&lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt;字符串类型声明。</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim编译器可以通过 &lt;code&gt;--header&lt;/code&gt; 命令行开关生成C接口头。生成的标头将包含所有导出的符号和您需要在任何其他Nim代码之前调用的 &lt;code&gt;NimMain&lt;/code&gt; proc。</target>
        </trans-unit>
        <trans-unit id="fd2ac310a54aa34b040fb3ce9d0aae68630ca11b" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command-line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Nim编译器发出不同类型的消息：&lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;，&lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;和&lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt;消息。如果编译器遇到任何静态错误，则会发出一条&lt;em&gt;错误&lt;/em&gt;消息。</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Nim编译器包括一个简单的线性方程求解器,允许它在某些涉及整数运算的情况下推断静态参数。</target>
        </trans-unit>
        <trans-unit id="580ec25bc986f0f51e4fc221c0aaeef6db0aa21e" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files that can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone Node.js program&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Nim编译器主要支持两个后端系列：C，C ++和Objective-C目标以及JavaScript目标。&lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;类似于C的目标将&lt;/a&gt;创建可编译为库或最终可执行文件的源文件。&lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript目标&lt;/a&gt;可以生成一个 &lt;code&gt;.js&lt;/code&gt; 文件，您可以从HTML文件中引用该文件，也可以创建一个&lt;a href=&quot;http://nodejs.org&quot;&gt;独立的nodejs程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Nim编译器支持源代码过滤器,作为一个简单而强大的内置模板系统。</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Nim编译器将处理将 &lt;code&gt;nimcache&lt;/code&gt; 目录中生成的源文件链接到 &lt;code&gt;libfib.nim.a&lt;/code&gt; 静态库中，然后您可以将其链接到C程序中。请注意，这些命令是通用的，并且对于每个系统都会有所不同。例如，在Linux系统上，您可能还需要使用 &lt;code&gt;-ldl&lt;/code&gt; 来链接所需的dlopen功能。</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Nim库大量使用了重载-原因之一是像 &lt;code&gt;+&lt;/code&gt; 这样的每个运算符都只是一个重载proc。解析器可以让你在使用运营商&lt;em&gt;中间符号&lt;/em&gt;（ &lt;code&gt;a + b&lt;/code&gt; ）或&lt;em&gt;前缀符号&lt;/em&gt;（ &lt;code&gt;+ a&lt;/code&gt; ）。前缀运算符始终接收两个参数，前缀运算符始终接收一个参数。 （后缀运算符是不可能的，因为这可能是模棱两可的： &lt;code&gt;a @ @ b&lt;/code&gt; 表示 &lt;code&gt;(a) @ (@b)&lt;/code&gt; @b ）还是 &lt;code&gt;(a@) @ (b)&lt;/code&gt; ？它总是表示 &lt;code&gt;(a) @ (@b)&lt;/code&gt; ，因为Nim中没有后缀运算符。）</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">尼姆手册是一个草案,将演变成一个适当的规范。</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">Nim编程语言没有Posix信号处理机制的概念。但是，标准库为信号处理提供了一些基本支持，特别是，分段错误被转换为致命错误，从而产生堆栈跟踪。可以使用 &lt;code&gt;-d:noSignalHandler&lt;/code&gt; 开关禁用它。</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Nim项目的目录结构是。</target>
        </trans-unit>
        <trans-unit id="f6e9fcfbb1521eca0d91e310af54c8a9ca576233" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;code&gt;addQuoted&lt;/code&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim标准库在生成集合的字符串表示形式时，会对集合的元素使用此函数。建议在用户端集合中也使用此功能。如果用户想要实现自定义元素表示，&lt;em&gt;则可&lt;/em&gt;以为自定义（类字符串）类型重载&lt;em&gt;addQuoted&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Nim教程第一部分讲的是基础知识。</target>
        </trans-unit>
        <trans-unit id="a8d8335d9b3a51e4f9b6b4bc2ad95a64b07b034f" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part three about Nim's macro system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Nim教程第二部分涉及高级语言构造。</target>
        </trans-unit>
        <trans-unit id="b72a9ce64dd38ff10ea38449cca0b32423b2c372" translate="yes" xml:space="preserve">
          <source>The OS this build is running on. Can be different from &lt;code&gt;system.hostOS&lt;/code&gt; for cross compilations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">PEG解析器实现了这个语法(用PEG语法编写)。</target>
        </trans-unit>
        <trans-unit id="31c92217046cc780ba133dace9f5c246558e7313" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ef66e58383b86b1407d1c272ce0bbbbecb587b" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b54829d9f17c2be9946ef0258220a08c1d2b0" translate="yes" xml:space="preserve">
          <source>The System module imports several separate modules, and their documentation is in separate files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5ab7831528adadcc8d1ce6127667976cfbd3e6" translate="yes" xml:space="preserve">
          <source>The ability to access and modify compile-time variables adds flexibility to constant expressions that may be surprising to those coming from other statically typed languages. For example, the following code echoes the beginning of the Fibonacci series &lt;strong&gt;at compile-time&lt;/strong&gt;. (This is a demonstration of flexibility in defining constants, not a recommended style for solving this problem!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5bb6b0158c6a354819839862ad897994206f74" translate="yes" xml:space="preserve">
          <source>The ability to override a hook leads to a phase ordering problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">上面的 &lt;code&gt;debug&lt;/code&gt; 宏依赖于以下事实：在系统模块中声明了 &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;writeLine&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; ，因此它们在实例化上下文中可见。有一种方法可以使用绑定标识符（也称为&lt;span id=&quot;symbols_1&quot;&gt;符号&lt;/span&gt;），而不是使用未绑定标识符。内置的 &lt;code&gt;bindSym&lt;/code&gt; 可用于：</target>
        </trans-unit>
        <trans-unit id="9a16d09084424b9bb5554f6882e18d7b658ef4d4" translate="yes" xml:space="preserve">
          <source>The above code fails with the error message that &lt;code&gt;p&lt;/code&gt; is not declared. The reason for this is that the &lt;code&gt;p()&lt;/code&gt; body is type-checked before getting passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">上面的代码失败与神秘的错误消息， &lt;code&gt;i&lt;/code&gt; 已经声明。这样做的原因是，在将 &lt;code&gt;var i = ...&lt;/code&gt; 主体传递给 &lt;code&gt;body&lt;/code&gt; 参数之前，需要对其进行类型检查，并且在Nim中进行类型检查会隐含符号查找。为了使符号查找成功， &lt;code&gt;i&lt;/code&gt; 需要添加到当前（即外部）范围中。在进行类型检查之后，不会回退这些添加到符号表中的内容（无论好坏）。相同的代码适用于 &lt;code&gt;untyped&lt;/code&gt; ,因为不需要对传递的主体进行类型检查：</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">上述代码输出。</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">上面的示例将失败，以确保c2nim &lt;em&gt;处理&lt;/em&gt;这些定义并扩展它们，请使用c2nim的 &lt;code&gt;#def&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">上面的模块输出 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; ，但是不输出 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">上面的输出可能是一个代码片段的结果,比如。</target>
        </trans-unit>
        <trans-unit id="250cc0bde21eb567c889e1e1664f7d10ce17f191" translate="yes" xml:space="preserve">
          <source>The abstract base type of all loggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">由于其保护 &lt;code&gt;x.L&lt;/code&gt; 处于活动状态，因此允许访问字段 &lt;code&gt;x.v&lt;/code&gt; 。模板扩展后，总计为：</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">addr运算符</target>
        </trans-unit>
        <trans-unit id="d8dbffc47ece2be660786dac5e5599bb2db4ec50" translate="yes" xml:space="preserve">
          <source>The algorithm behind this analysis is described in the &lt;a href=&quot;#view-types-algorithm&quot;&gt;view types section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">编译模块的算法是。</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">该算法的基础是续分理论。</target>
        </trans-unit>
        <trans-unit id="7b81a299b4d6a7c6527f2f9089e8efaf8aa777c1" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3c558bc48c770919c504ee5c6a21e8e07e4d60" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e743ac1a73193134433b9e2665ee58685338dd" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa58ae727a722325206dd1c096f46b46d2c14b" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c822d98d0919ddf989461e7416cedbec8f1ed4d7" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d2e95c77763501f5d08aba1067373c7bd297c8" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e814504ef907959dbfcf0c83b97cf43f9dcf6be" translate="yes" xml:space="preserve">
          <source>The amount of available functions is much larger. Use the table of contents on the left-hand side and/or &lt;code&gt;Ctrl+F&lt;/code&gt; to navigate through this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ba690f34c8a341aefa7154f4cab877c7806570" translate="yes" xml:space="preserve">
          <source>The amount of inserted spaces for each tab character is the difference between the current column number and the next tab position. Tab positions occur every &lt;code&gt;tabSize&lt;/code&gt; characters. The column number starts at 0 and is increased with every single character and inserted space, except for newline, which resets the column number back to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250c5ff56778e008023b7651ae2048c87b91ec39" translate="yes" xml:space="preserve">
          <source>The analysis is currently control flow insensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b75eefe3dbc4504e1b5e9c31e816f67ebe1b353" translate="yes" xml:space="preserve">
          <source>The analysis requires as much precision about mutations as is reasonably obtainable, so it is more effective with the experimental &lt;a href=&quot;#strict-funcs&quot;&gt;strict funcs&lt;/a&gt; feature. In other words &lt;code&gt;--experimental:views&lt;/code&gt; works better with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb382e7222271bd8b9818e2c22f1b22c1d23882" translate="yes" xml:space="preserve">
          <source>The assignment of a location that is derived from a local parameter to a view-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ef3590f8b622cbd763976b293e8b5be0c43bea" translate="yes" xml:space="preserve">
          <source>The assignment of a non-view-type to a view-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">字符串的赋值运算符始终复制该字符串。在 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符连接字符串。</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">字符串的赋值运算符将复制字符串。您可以使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符来连接字符串，并 &lt;code&gt;add&lt;/code&gt; 以追加到字符串。</target>
        </trans-unit>
        <trans-unit id="e76741ef0154f25492ed64d08d5e8f9a5bb9a741" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">元组的赋值运算符复制每个组件。对象的默认赋值运算符将复制每个组件。赋值运算符的重载在&lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator中进行了描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">元组的赋值运算符复制每个组件。 &lt;code&gt;t.field&lt;/code&gt; 表示法用于访问元组的字段。另一个符号是 &lt;code&gt;t[i]&lt;/code&gt; 访问第 &lt;code&gt;i&lt;/code&gt; 个字段。在这里， &lt;code&gt;i&lt;/code&gt; 必须是一个常数整数。</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">赋值运算符需要被附加到对象或不同类型 &lt;code&gt;T&lt;/code&gt; 。其签名必须为 &lt;code&gt;(var T, T)&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">转让声明</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">赋值语句将一个新的值赋给一个变量或更一般的存储位置。</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">async dispatcher实现了proactor模式,也有IOCP的实现。它通过选择器模块实现了其他操作系统的proactor模式。这里也实现了期货,事实上所有的程序都会返回一个未来。</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">可用的浮点表现类型有:</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">可用的整数表现类型有:</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">后端必须具有某种逻辑，以便如果当前处理的模块来自编译缓存，则不会访问 &lt;code&gt;ast&lt;/code&gt; 字段。相反，为符号主体生成的C（++）也需要缓存，然后再插入生成的C文件中。这种方法似乎可以解决上述所有问题。</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">未被选中的数组的基本类型可能不包含任何GC'ed内存,但目前没有被选中。</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">基本算法是带有循环检测的&lt;em&gt;递延参考计数&lt;/em&gt;。为了提高性能（并简化C代码生成），不计算堆栈上的引用。当前，循环检测是通过一个简单的标记扫描GC来完成的，该标记必须扫描完整的（线程本地堆）。 &lt;code&gt;--gc:v2&lt;/code&gt; 将其替换为增量标记和扫描。但是它还没有准备好生产。</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">基本算法是带有循环检测的&lt;em&gt;Deferrent参考计数&lt;/em&gt;。为了更好的性能和更容易的C代码生成，不计算堆栈上的引用。</target>
        </trans-unit>
        <trans-unit id="29593df455bce4317b1e8d46d66107a58482465b" translate="yes" xml:space="preserve">
          <source>The basic flow of using this module is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">二进制 &lt;code&gt;^*&lt;/code&gt; 运算符用作0次或多次出现的简写，并由其第二个参数分隔；同样， &lt;code&gt;^+&lt;/code&gt; 表示1次或多次出现： &lt;code&gt;a ^+ b&lt;/code&gt; 是 &lt;code&gt;a (b a)*&lt;/code&gt; 缩写，而 &lt;code&gt;a ^* b&lt;/code&gt; 是 &lt;code&gt;(a (b a)*)?&lt;/code&gt; 缩写？。例：</target>
        </trans-unit>
        <trans-unit id="838b0fbf81e65abd3b1ad6c600113a2fed59e81e" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5d0d575da00922903cac607fb2fd96251ac2cd" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3840b5815b476e7ad0468e337f35e7346b451d5" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared(block)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98353e7ce043623f414d9bb91bad41b576de19e8" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37a54c51ba932ce88795fda3d2a30d0c461cb79" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068999f6f652deacdb3f97d6673d5b7e6baf16cf" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared(block)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a4b678bcf75d497dac75a45beb59d65212247d" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5f58aae87fa158997bda888132721756d3cb4f" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47a24f074a3169393ff9b7055c7a12a147a3601" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer then realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81438262b2b429a9e9625da21fde5d6db74d0bb7" translate="yes" xml:space="preserve">
          <source>The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">块语句是将语句分组到（命名的） &lt;code&gt;block&lt;/code&gt; 。在该块内部，可以使用 &lt;code&gt;break&lt;/code&gt; 语句立即离开该块。一个 &lt;code&gt;break&lt;/code&gt; 语句可以包含一围框的名称来指定哪些块是离开。</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">块的&lt;em&gt;标签&lt;/em&gt;（ &lt;code&gt;myblock&lt;/code&gt; 中的myblock）是可选的。</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">布尔类型在Nim中称为&lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt;，可以是两个预定义值 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 之一。出条件 &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; -statements需型的 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">借用pragma也可以用来注释独特类型,以允许某些内置操作被解除。</target>
        </trans-unit>
        <trans-unit id="be92dcebf622da6178429443f44552a8ca5101d2" translate="yes" xml:space="preserve">
          <source>The bounds &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; denote the indices of the first and last characters that shall be copied. If &lt;code&gt;last&lt;/code&gt; is omitted, it is treated as &lt;code&gt;high(s)&lt;/code&gt;. If &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt;, &lt;code&gt;s.len&lt;/code&gt; is used instead: This means &lt;code&gt;substr&lt;/code&gt; can also be used to &lt;span id=&quot;cut_1&quot;&gt;cut&lt;/span&gt; or &lt;span id=&quot;limit_1&quot;&gt;limit&lt;/span&gt; a string's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">内置的&lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc返回数组的长度。&lt;a href=&quot;system#low&quot;&gt;low（a）&lt;/a&gt;返回数组&lt;em&gt;a&lt;/em&gt;的最低有效索引，&lt;a href=&quot;system#high&quot;&gt;high（a）返回&lt;/a&gt;最高有效索引。</target>
        </trans-unit>
        <trans-unit id="9840f844923cc10024352c7ba0b3ff45a4914dcf" translate="yes" xml:space="preserve">
          <source>The builtin 'system.locals' implemented as a plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f452d59ca97170597b758692a3b42390c25047e4" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">内置的 &lt;code&gt;deepCopy&lt;/code&gt; 甚至可以克隆闭包及其环境。有关详细信息，请参见&lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">内置的 &lt;code&gt;system.finished&lt;/code&gt; 可用于确定迭代器是否已完成其操作；尝试调用已经完成其工作的迭代器不会引发任何异常。</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">内置文档生成器 &lt;code&gt;nim doc&lt;/code&gt; 从 &lt;code&gt;.nim&lt;/code&gt; 源文件生成HTML文档。</target>
        </trans-unit>
        <trans-unit id="1be5bb95f8a163c45d73b2bf4f448ad5d41520b0" translate="yes" xml:space="preserve">
          <source>The cache is discarded and disabled. The GC will reuse its used memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc2df4285e7ce4148cd07c10af838b3599131c2" translate="yes" xml:space="preserve">
          <source>The caching of modules is critical for 'nimsuggest' and is tricky to get right. If module E is being edited, we need autocompletion (and type checking) for E but we don't want to recompile depending modules right away for faster turnaround times. Instead we mark the module's dependencies as 'dirty'. Let D be a dependency of E. If D is dirty, we need to recompile it and all of its dependencies that are marked as 'dirty'. 'nimsuggest sug' actually is invoked for the file being edited so we know its content changed and there is no need to compute any checksums. Instead of a recursive algorithm, we use an iterative algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fee63106f29dd5e46e2f5ccdba0d7bbe8184064" translate="yes" xml:space="preserve">
          <source>The call can be made more like an inline iterator with a for loop macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">将来完成时也会调用该回调。因此，您应该使用 &lt;code&gt;finished&lt;/code&gt; 检查数据是否可用。</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">回调应该返回以下之一:</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">卡擦字符(^)不被识别为转义字符或定界符。这个字符在被传递到程序中的argv数组之前,完全由操作系统中的命令行解析器处理。</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">case语句可以处理整数、其他序数类型和字符串。(什么是序数类型,稍后将解释)对于整数或其他序数类型,值范围也是可以的。(什么是序数类型,稍后将解释。)对于整数或其他序数类型,也可以使用值范围。</target>
        </trans-unit>
        <trans-unit id="694081c9ba0ead71a23be29d98b9511f2e2c1da7" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under Windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl约定表示过程应使用与C编译器相同的约定。在Windows下，使用 &lt;code&gt;__cdecl&lt;/code&gt; 关键字声明生成的C过程。</target>
        </trans-unit>
        <trans-unit id="058accd23038c62c41c53cefc9d097f2c415abea" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e298a10b48b62e2a169d6c44a14daf34ceeedd" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aa4b50d816fd45a3310fdfe9be5b22b53c8981" translate="yes" xml:space="preserve">
          <source>The change is permanent for the rest of the execution, since this is just a shortcut for &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir()&lt;/a&gt; . Use the &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir()&lt;/a&gt; template if you want to perform a temporary change only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">操作系统通常用来分隔搜索补丁组件的字符(如PATH),如POSIX的':'或Windows的';'。</target>
        </trans-unit>
        <trans-unit id="67cdf84dfd1fc80d813d4abe30055e39e2a1d442" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c48c729604a1469a45dd9f280c6186f2d6305" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent a UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">字符类型在Nim中称为 &lt;code&gt;char&lt;/code&gt; 。它的大小是一个字节。因此，它不能代表UTF-8字符，而是一部分。原因是效率：在绝大多数用例中，生成的程序仍将正确处理UTF-8，因为UTF-8是为此专门设计的。另一个原因是Nim可以有效地支持 &lt;code&gt;array[char, int]&lt;/code&gt; 或 &lt;code&gt;set[char]&lt;/code&gt; 因为许多算法都依赖此功能。的&lt;em&gt;符文&lt;/em&gt;类型用于Unicode字符，它可以代表任何Unicode字符。 &lt;code&gt;Rune&lt;/code&gt; 在&lt;a href=&quot;unicode&quot;&gt;unicode模块中&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">操作系统用来分隔路径名组件的字符,例如,POSIX的'/'或经典Macintosh的':'。</target>
        </trans-unit>
        <trans-unit id="25e189a51726217bd10306adb62ab204d17e2719" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example: &lt;code&gt;'/'&lt;/code&gt; for POSIX, &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh, and &lt;code&gt;'\'&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">将基本文件名与扩展名分开的字符；例如，&amp;ldquo;。&amp;rdquo; 在 &lt;code&gt;os.nim&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0eb96dc2f00e727210b0dc83b639e0b79d1c8c58" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">风格的选择由你决定。</target>
        </trans-unit>
        <trans-unit id="4f81018fe48bb50b55f71f19831d2854f946c504" translate="yes" xml:space="preserve">
          <source>The circle constant PI (Ludolph's number)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88109739e49227795120221865f1a6d8d83ffb4e" translate="yes" xml:space="preserve">
          <source>The circle constant TAU (= 2 * PI)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9025711d3d5dd3e200b0d5ab31809d3ae89c7a5" translate="yes" xml:space="preserve">
          <source>The client data field is used by the HTML parser and generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">&lt;code&gt;@#&lt;/code&gt; 结束处必须自己一行，只能在可选的空白之前。这样， &lt;code&gt;@#&lt;/code&gt; 否则可发生在稔代码作为示例所示。</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">该代码包含一个令人困惑的 &lt;code&gt;var&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">该代码包含一个不支持的八进制序列。</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">代码重排序功能可以隐性地将过程、模板、宏定义以及顶层作用域的变量声明和初始化重新排列,因此,在很大程度上,程序员不必担心定义的排序是否正确,也不必被迫在模块内部使用正向声明来为定义作序。</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">该代码使用了一个废弃的符号。</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">强制 &lt;code&gt;type(x)&lt;/code&gt; 可用于获取给定表达式 &lt;code&gt;x&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">收集器会在每次 &lt;code&gt;workPackage&lt;/code&gt; 的迭代之后检查是否还有剩余的工作时间。当前设置为100，这意味着在再次检查之前将遍历并释放多达100个对象。因此， &lt;code&gt;workPackage&lt;/code&gt; 影响时序粒度，并且可能需要在高度专业化的环境中或针对较旧的硬件进行调整。</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">命令调用语法也不能使用复杂的表达式作为参数。例如：（&lt;a href=&quot;#anonymous-procs&quot;&gt;匿名procs&lt;/a&gt;）， &lt;code&gt;if&lt;/code&gt; ，则为 &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;try&lt;/code&gt; 。（&lt;a href=&quot;#do-notation&quot;&gt;符号&lt;/a&gt;）是有限的，但可用于单个proc（请参见相应部分中的示例）。不带参数的函数调用仍然需要（）来区分调用和函数本身，作为第一类值。</target>
        </trans-unit>
        <trans-unit id="b7e98bb35328ac84f0a9e89f36fd4180318f1d00" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. Function calls with no arguments still need () to distinguish between a call and the function itself as a first-class value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">编译成C、C++或Objective-C的命令是:。</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">通用 &lt;code&gt;--&lt;/code&gt; 非选项参数定界符显示为空字符串长选项键。在这种情况下，可以使用 &lt;code&gt;OptParser.cmd&lt;/code&gt; ， &lt;code&gt;OptParser.pos&lt;/code&gt; 和 &lt;code&gt;os.parseCmdLine&lt;/code&gt; 来完成解析。</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">通用运算符 &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 为浮点定义，并遵循IEEE-754标准。</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">通用运算符 &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 为整数定义。该 &lt;code&gt;and or xor not&lt;/code&gt; 运营商也在为整数定义，并提供&lt;em&gt;按位&lt;/em&gt;操作。左移使用 &lt;code&gt;shl&lt;/code&gt; 完成，右移使用 &lt;code&gt;shr&lt;/code&gt; 运算符。移位运算符始终将其参数视为&lt;em&gt;unsigned&lt;/em&gt;。对于&lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;算术移位，&lt;/span&gt;可以使用普通的乘法或除法。</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">编译器会检查每个参数是否正好收到一个参数。</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">编译器检查语义并&lt;em&gt;仅为&lt;/em&gt;属于第一个条件的语句（其结果为 &lt;code&gt;true&lt;/code&gt; )生成代码。</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">编译器命令选择目标后端，但是如果需要，您可以&lt;a href=&quot;nimc#cross-compilation&quot;&gt;指定用于交叉编译的其他开关&lt;/a&gt;以选择目标CPU，操作系统或编译器/链接器命令。</target>
        </trans-unit>
        <trans-unit id="0bf4f876ba614fab0251ca447032e9c4223c202b" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt;specify additional switches for cross-compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2e3df2d7fda7fee4989683f7777bad3866a03e" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">编译器取决于System模块才能正常工作，而System模块则取决于编译器。此处列出的大多数例程都使用特殊的编译器魔术。每个模块都隐式导入System模块；不能明确列出。因此，不能有一个名为 &lt;code&gt;system&lt;/code&gt; 的用户定义模块。</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">编译器确保每条代码路径都会初始化包含非nilable指针的变量。这个分析的细节在这里还需要具体说明。</target>
        </trans-unit>
        <trans-unit id="fcd92bbcd58119a3a0ac02288b0174193fcb4cee" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9adfb2c991d20ede8d4667f6a86d41c673563e" translate="yes" xml:space="preserve">
          <source>The compiler executes the macro body (which may invoke other procs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">编译器生成的代码就像程序员会写这个一样。</target>
        </trans-unit>
        <trans-unit id="4b55dae2064aca45aa89b0fcdf2d09a19bcd4f27" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">如果建议通过 &lt;code&gt;-d:release&lt;/code&gt; 或 &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;命令行开关&lt;/a&gt;这样做，则编译器可能根本不会为 &lt;code&gt;assert&lt;/code&gt; 生成任何代码。</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">需要告知编译器生成C ++（命令 &lt;code&gt;cpp&lt;/code&gt; ）以使其工作。条件符号 &lt;code&gt;cpp&lt;/code&gt; 是在编译器发出C ++代码时定义的。</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">需要告诉编译器生成目标C（命令 &lt;code&gt;objc&lt;/code&gt; ）以使其工作。当编译器发出目标C代码时，将定义条件符号 &lt;code&gt;objc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">现在，编译器将 &lt;code&gt;x * 2&lt;/code&gt; 重写为 &lt;code&gt;x + x&lt;/code&gt; 。curlies内部的代码是要匹配的模式。运算符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; 如果以infix表示法在模式中具有特殊含义，因此要逐字匹配 &lt;code&gt;*&lt;/code&gt; ，需要使用普通的函数调用语法。</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">编译器优化了字符串案例语句。如果使用了几个不同的字符串常量,就会使用一个散列方案来处理它们。所以这样的代码是相当高效的。</target>
        </trans-unit>
        <trans-unit id="eb71aee62d68e0ffc7703a0f580c4704b2a5314f" translate="yes" xml:space="preserve">
          <source>The compiler parses Nim source code into an internal data structure called the &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;abstract syntax tree&lt;/span&gt; (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Then, before executing the code or compiling it into the executable, it transforms the AST through &lt;span id=&quot;semantic-analysis_1&quot;&gt;semantic analysis&lt;/span&gt;. This adds semantic information such as expression types, identifier meanings, and in some cases expression values. An error detected during semantic analysis is called a &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt;. Errors described in this manual are static errors when not otherwise specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">编译器会生成一条提示消息，提示可以 &lt;code&gt;IOError&lt;/code&gt; 。未列出 &lt;code&gt;OSError&lt;/code&gt; ，因为无法在出现杂物 &lt;code&gt;effects&lt;/code&gt; 的分支中引发它。</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">编译器支持内置的stringify运算符 &lt;code&gt;$&lt;/code&gt; 进行枚举。可以通过显式给出要使用的字符串值来控制stringify的结果：</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">然后，编译器确保对 &lt;code&gt;gdata&lt;/code&gt; 的每次访问都在 &lt;code&gt;locks&lt;/code&gt; 部分内：</target>
        </trans-unit>
        <trans-unit id="3c5f83ca8ab3660248326a08229e050f34a8a0c9" translate="yes" xml:space="preserve">
          <source>The compiler will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24434c511c9a0bbb881f927475e8de7c254d5387" translate="yes" xml:space="preserve">
          <source>The compiler will use this internally to add nodes that will be appended to the module after the sem pass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">编译器的架构</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">补差函数</target>
        </trans-unit>
        <trans-unit id="9b0073d67f30e0c2127f291bae7a611090f6e645" translate="yes" xml:space="preserve">
          <source>The complex case looks like a variant of &lt;code&gt;x = f(x)&lt;/code&gt;, we consider &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt; here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">编译器将报告任何未能评估表达式或可能的类型不匹配错误。</target>
        </trans-unit>
        <trans-unit id="d2436daa78f5945640e1663fb72e8784ed15ea67" translate="yes" xml:space="preserve">
          <source>The concatenation operator for an openarray of ropes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf0dc092d7f032ccb25780c5ba219ec8f7f8ed1" translate="yes" xml:space="preserve">
          <source>The concatenation operator for ropes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">这个概念是一个匹配的如果。</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">概念类型可以像普通的通用类型一样是参数化的。</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">在条件 &lt;code&gt;do while(condition)&lt;/code&gt; 语句必须是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="079ce34e8825e87b63959e1b6bb724035f09b43d" translate="yes" xml:space="preserve">
          <source>The configuration file used to generate this module: &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0cbf2a934ca63dd156a15c83a0955e4f3c96c" translate="yes" xml:space="preserve">
          <source>The constant character used by the operating system to refer to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">操作系统用来表示当前目录的常量字符串。</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">操作系统用来引用父目录的常量字符串。</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">约束可以是一个具体的类型,也可以是一个类型类。</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; 存在。它是 &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">构造 &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; （标识符和开头引号之间没有空格）是广义的原始字符串文字。它是构造 &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; 的快捷方式，因此它表示将原始字符串文字作为唯一参数的过程调用。通用原始字符串文字对于将迷你语言直接嵌入到Nim中（例如正则表达式）特别方便。</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">当前，仅在与具有这种语义的导入类型进行接口连接时，使用 &lt;code&gt;in&lt;/code&gt; 修饰符引入的反变量参数才有用。</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">可以通过用户定义的类型&lt;span id=&quot;converter_1&quot;&gt;转换器&lt;/span&gt;放宽可转换的关系。</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">临界位树既可以用作从字符串到某种类型 &lt;code&gt;T&lt;/code&gt; 的映射，也可以用作一组字符串（如果 &lt;code&gt;T&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="c0fa9cac7ceae42e9a66ef4fbfd5cbc0c0b98a60" translate="yes" xml:space="preserve">
          <source>The current implementation allows to switch between these different behaviors via &lt;code&gt;--panics:on|off&lt;/code&gt;. When panics are turned on, the program dies with a panic, if they are turned off the runtime errors are turned into exceptions. The benefit of &lt;code&gt;--panics:on&lt;/code&gt; is that it produces smaller binary code and the compiler has more freedom to optimize the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135086cb75d914e6f94d6cbecde1ac80f38e6fe2" translate="yes" xml:space="preserve">
          <source>The current implementation also performs &lt;code&gt;.cursor&lt;/code&gt; inference. Cursor inference is a form of copy elision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d19e0e77753e1c01e8179f867553475a7ffcd1" translate="yes" xml:space="preserve">
          <source>The current implementation can do a limited form of sink parameter inference. But it has to be enabled via &lt;code&gt;--sinkInference:on&lt;/code&gt;, either on the command line or via a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5b1ca7fdfb765ee1b960287c15b23201b6d21a" translate="yes" xml:space="preserve">
          <source>The current implementation follows strategy (2). This means that resources are destroyed at the scope exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">当前的实现对编译时评估提出了一些限制：包含 &lt;code&gt;cast&lt;/code&gt; 或使用外部函数接口的代码无法在编译时评估。Nim的更高版本将在编译时支持FFI。</target>
        </trans-unit>
        <trans-unit id="a6c75b39da47586f8ce3f9497858b03d9e773673" translate="yes" xml:space="preserve">
          <source>The current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8021c64a5c2703296dd3be90acd92bb96fdc4cc3" translate="yes" xml:space="preserve">
          <source>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length &lt;code&gt;a.len div 2&lt;/code&gt;. If you do not wish to provide your own &lt;code&gt;cmp&lt;/code&gt;, you may use &lt;code&gt;system.cmp&lt;/code&gt; or instead call the overloaded version of &lt;code&gt;sort&lt;/code&gt;, which uses &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaad5708fa9cdaf05cfb4998ff219d4807eb0f6" translate="yes" xml:space="preserve">
          <source>The current version is compatible with Unicode v12.0.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; 和 &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; 与GC的其他部分独立地启用/禁用循环收集器。</target>
        </trans-unit>
        <trans-unit id="ba5fbe658d27b58a801cb300b7494eb040d69ce3" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the garbage collector with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8940014c2996b2e1e7db8c6a1ff0b6fea342746b" translate="yes" xml:space="preserve">
          <source>The data structures and algorithms used here are inspired by &quot;A Graph&amp;ndash;Free Approach to Data&amp;ndash;Flow Analysis&quot; by Markus Mohnen. &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ac7444c3221b96debd2abc66799170ac26a58d" translate="yes" xml:space="preserve">
          <source>The date (in UTC) of compilation as a string of the form &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940edcabe1639013ff3203ff4f55354615da8e93" translate="yes" xml:space="preserve">
          <source>The day of the month, in the range 1 to 31.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad24cee5b08e1745f4d438cfcaeb59500a70b502" translate="yes" xml:space="preserve">
          <source>The day of the week as an enum, the ordinal value is in the range 0 (monday) to 6 (sunday).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">项目的默认构建是&lt;span id=&quot;debug-build_1&quot;&gt;调试构建&lt;/span&gt;。要编译&lt;span id=&quot;release-build_1&quot;&gt;发布版本，请&lt;/span&gt;定义 &lt;code&gt;release&lt;/code&gt; 符号：</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">默认的调用约定是 &lt;code&gt;nimcall&lt;/code&gt; ，除非它是一个内部proc（proc内部的proc）。对于内部过程，将执行是否访问其环境的分析。如果这样做，它将具有调用约定 &lt;code&gt;closure&lt;/code&gt; ，否则将具有调用约定 &lt;code&gt;nimcall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">默认编译器在 &lt;code&gt;config\nim.cfg&lt;/code&gt; 的顶部定义。更改此设置会影响 &lt;code&gt;koch&lt;/code&gt; 用来（重新）构建Nim 的编译器。</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">默认配置（&lt;em&gt;trim = true&lt;/em&gt;和&lt;em&gt;precision = 10&lt;/em&gt;）显示精确显示该值的&lt;strong&gt;最短&lt;/strong&gt;形式（最多10个小数位）。例如，4.100000将显示为4.1（在数学上是相同的），而4.1000003将显示为4.1000003。</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">默认的float类型是 &lt;code&gt;float&lt;/code&gt; 。在当前的实现中， &lt;code&gt;float&lt;/code&gt; 始终为64位。</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">对于实体的符号的默认 &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 是 &lt;code&gt;gensym&lt;/code&gt; 和 &lt;code&gt;proc&lt;/code&gt; ， &lt;code&gt;iterator&lt;/code&gt; ， &lt;code&gt;converter&lt;/code&gt; ， &lt;code&gt;template&lt;/code&gt; ， &lt;code&gt;macro&lt;/code&gt; 是 &lt;code&gt;inject&lt;/code&gt; 。但是，如果实体名称作为模板参数传递，则它是注入符号：</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">默认整数类型为 &lt;code&gt;int&lt;/code&gt; 。整数文字可以具有&lt;em&gt;类型后缀&lt;/em&gt;以指定非默认整数类型：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
